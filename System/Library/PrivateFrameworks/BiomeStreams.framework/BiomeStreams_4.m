uint64_t outlined init with copy of PgQuery_Node.OneOf_Node(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t outlined init with take of PgQuery_OidList(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t specialized PgQuery_CollateExpr._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_CollateExpr(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_CollateExpr._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
    v6(v4, 1, 1, Node);
    uint64_t v7 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    v6(v3+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
    uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid) = 0;
    uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    uint64_t v10 = v2
        + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v10, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v7, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v8) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CollateExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v9) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_CaseWhen._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_CaseWhen(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_CaseWhen._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
    v6(v4, 1, 1, Node);
    uint64_t v7 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
    v6(v3 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, 1, 1, Node);
    uint64_t v8 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__result;
    v6(v3+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__result, 1, 1, Node);
    uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    uint64_t v10 = v2
        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v10, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__result, v8, &demangling cache variable for type metadata for PgQuery_Node?);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseWhenP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v9) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_CaseTestExpr._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_CaseTestExpr(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_CaseTestExpr._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID) = 0;
    uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod) = 0;
    uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = 0;
    uint64_t v9 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v9, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v6) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID);
    *(_DWORD *)(v3 + v7) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CaseTestExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
    swift_release();
    *(_DWORD *)(v3 + v8) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_BooleanTest._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_BooleanTest(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_BooleanTest._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
    v6(v4, 1, 1, Node);
    uint64_t v7 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    v6(v3+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
    uint64_t v8 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLtesttype;
    *(void *)uint64_t v8 = 0;
    *(unsigned char *)(v8 + 8) = 1;
    uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    uint64_t v10 = v2
        + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v10, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v7, &demangling cache variable for type metadata for PgQuery_Node?);
    char v11 = *(unsigned char *)(v2
                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLtesttype
                   + 8);
    *(void *)uint64_t v8 = *(void *)(v2
                              + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLtesttype);
    *(unsigned char *)(v8 + 8) = v11;
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_BooleanTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v9) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_NextValueExpr._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_NextValueExpr(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_NextValueExpr._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__seqid;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__seqid) = 0;
    uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID) = 0;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v6) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__seqid);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_NextValueExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID);
    swift_release();
    *(_DWORD *)(v3 + v7) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_InferenceElem._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_InferenceElem(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_InferenceElem._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
    v6(v4, 1, 1, Node);
    uint64_t v7 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
    v6(v3+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, 1, 1, Node);
    uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infercollid;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infercollid) = 0;
    uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inferopclass;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inferopclass) = 0;
    uint64_t v10 = v2
        + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v10, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v8) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infercollid);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_InferenceElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inferopclass);
    swift_release();
    *(_DWORD *)(v3 + v9) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_FromExpr._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_FromExpr(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_FromExpr._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = MEMORY[0x1E4FBC860];
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FromExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__quals;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    *(void *)(v3 + 16) = *(void *)(v2 + 16);
    uint64_t v6 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FromExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__quals;
    swift_retain();
    swift_bridgeObjectRetain();
    outlined destroy of AnyValue?(v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined init with copy of PgQuery_Alias?(v6, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    swift_release();
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_RawStmt._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_RawStmt(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_RawStmt._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation) = 0;
    uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen) = 0;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v6) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
    swift_release();
    *(_DWORD *)(v3 + v7) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_CommentStmt._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_CommentStmt(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_CommentStmt._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = 0;
    *(unsigned char *)(v3 + 24) = 1;
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CommentStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = (void *)(v3
                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CommentStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__comment);
    *uint64_t v6 = 0;
    v6[1] = 0xE000000000000000;
    char v7 = *(unsigned char *)(v2 + 24);
    *(void *)(v3 + 16) = *(void *)(v2 + 16);
    *(unsigned char *)(v3 + 24) = v7;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CommentStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v10 = *(void *)(v2
                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CommentStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__comment);
    uint64_t v9 = *(void *)(v2
                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CommentStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__comment
                   + 8);
    swift_bridgeObjectRetain();
    swift_release();
    swift_bridgeObjectRelease();
    *uint64_t v6 = v10;
    v6[1] = v9;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_AlternativeSubPlan._uniqueStorage()(uint64_t (*a1)(void), void (*a2)(void), void *a3, uint64_t *a4)
{
  uint64_t v8 = *(int *)(a1(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v9 = *(void *)(v4 + v8);
    a2(0);
    uint64_t v10 = swift_allocObject();
    uint64_t v11 = v10 + *a3;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v11, 1, 1, Node);
    uint64_t v13 = *a4;
    *(void *)(v10 + *a4) = MEMORY[0x1E4FBC860];
    uint64_t v14 = v9 + *a3;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v14, v11, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v15 = *(void *)(v9 + *a4);
    swift_bridgeObjectRetain();
    swift_release();
    swift_bridgeObjectRelease();
    *(void *)(v10 + v13) = v15;
    *(void *)(v4 + v8) = v10;
    swift_release();
  }
  return *(void *)(v4 + v8);
}

uint64_t specialized PgQuery_A_Indices._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_A_Indices(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_A_Indices._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(unsigned char *)(v3 + 16) = 0;
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_A_IndicesP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lidx;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
    v6(v4, 1, 1, Node);
    uint64_t v7 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_A_IndicesP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__uidx;
    v6(v3 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_A_IndicesP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__uidx, 1, 1, Node);
    *(unsigned char *)(v3 + 16) = *(unsigned char *)(v2 + 16);
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_A_IndicesP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lidx;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v9 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_A_IndicesP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__uidx;
    outlined destroy of AnyValue?(v7, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined init with copy of PgQuery_Alias?(v9, v7, &demangling cache variable for type metadata for PgQuery_Node?);
    swift_release();
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_MultiAssignRef._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_MultiAssignRef(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_MultiAssignRef._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__source;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colno;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colno) = 0;
    uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ncolumns;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ncolumns) = 0;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__source;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    *(_DWORD *)(v3 + v6) = *(_DWORD *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colno);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_MultiAssignRefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ncolumns);
    swift_release();
    *(_DWORD *)(v3 + v7) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_TypeCast._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_TypeCast(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_TypeCast._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
    uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56))(v6, 1, 1, TypeName);
    uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    uint64_t v9 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v9, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v6, &demangling cache variable for type metadata for PgQuery_TypeName?);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_TypeCastP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v8) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_CollateClause._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_CollateClause(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_CollateClause._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collname;
    *(void *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collname) = MEMORY[0x1E4FBC860];
    uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    *(void *)(v3 + v6) = *(void *)(v2
                                     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collname);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CollateClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v7) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_RangeSubselect._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_RangeSubselect(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_RangeSubselect._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(unsigned char *)(v3 + 16) = 0;
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeSubselectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subquery;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeSubselectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias;
    uint64_t Alias = type metadata accessor for PgQuery_Alias(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Alias - 8) + 56))(v6, 1, 1, Alias);
    *(unsigned char *)(v3 + 16) = *(unsigned char *)(v2 + 16);
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeSubselectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subquery;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v9 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeSubselectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias;
    outlined destroy of AnyValue?(v6, &demangling cache variable for type metadata for PgQuery_Alias?);
    outlined init with copy of PgQuery_Alias?(v9, v6, &demangling cache variable for type metadata for PgQuery_Alias?);
    swift_release();
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_XmlSerialize._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_XmlSerialize(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_XmlSerialize._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = 0;
    *(unsigned char *)(v3 + 24) = 1;
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
    uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56))(v6, 1, 1, TypeName);
    uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    char v9 = *(unsigned char *)(v2 + 24);
    *(void *)(v3 + 16) = *(void *)(v2 + 16);
    *(unsigned char *)(v3 + 24) = v9;
    uint64_t v10 = v2
        + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v10, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined assign with copy of PgQuery_Node?(v2+ OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v6, &demangling cache variable for type metadata for PgQuery_TypeName?);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_XmlSerializeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v8) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_PartitionRangeDatum._uniqueStorage()()
{
  uint64_t v1 = *(int *)(type metadata accessor for PgQuery_PartitionRangeDatum(0) + 20);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
  {
    uint64_t v2 = *(void *)(v0 + v1);
    type metadata accessor for PgQuery_PartitionRangeDatum._StorageClass(0);
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = 0;
    *(unsigned char *)(v3 + 24) = 1;
    uint64_t v4 = v3
       + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_PartitionRangeDatumP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__value;
    uint64_t Node = type metadata accessor for PgQuery_Node(0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
    uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_PartitionRangeDatumP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
    *(_DWORD *)(v3
              + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_PartitionRangeDatumP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
    char v7 = *(unsigned char *)(v2 + 24);
    *(void *)(v3 + 16) = *(void *)(v2 + 16);
    *(unsigned char *)(v3 + 24) = v7;
    uint64_t v8 = v2
       + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_PartitionRangeDatumP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__value;
    swift_retain();
    outlined assign with copy of PgQuery_Node?(v8, v4, &demangling cache variable for type metadata for PgQuery_Node?);
    LODWORD(v4) = *(_DWORD *)(v2
                            + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_PartitionRangeDatumP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
    swift_release();
    *(_DWORD *)(v3 + v6) = v4;
    *(void *)(v0 + v1) = v3;
    swift_release();
  }
  return *(void *)(v0 + v1);
}

uint64_t specialized PgQuery_TableFunc._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 16) = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 24) = v3;
  uint64_t v4 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr;
  uint64_t v14 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v6(v4, 1, 1, Node);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr;
  v6(v1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, 1, 1, Node);
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames) = v3;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypes;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypes) = v3;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypmods;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypmods) = v3;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colcollations;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colcollations) = v3;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexprs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexprs) = v3;
  uint64_t v15 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexprs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexprs) = v3;
  uint64_t v16 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__notnulls;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__notnulls) = v3;
  uint64_t v18 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordinalitycol;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordinalitycol) = 0;
  uint64_t v17 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + 24) = *(void *)(a1 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr, v14, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypes);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coltypmods);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colcollations);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v12) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexprs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v15) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexprs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v16) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__notnulls);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v18) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordinalitycol);
  *(_DWORD *)(v1 + v17) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_TableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_Var._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v15 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v14 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varno) = 0;
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattno) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartype) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartypmod) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varcollid) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varlevelsup;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varlevelsup) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varnosyn;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varnosyn) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattnosyn;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattnosyn) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v15, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v14) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varno);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattno);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartype);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__vartypmod);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varcollid);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varlevelsup);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varnosyn);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__varattnosyn);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser11PgQuery_VarP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_Param._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramkind;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtypmod) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramcollid) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramkind
                 + 8);
  *(void *)uint64_t v5 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramkind);
  *(unsigned char *)(v5 + 8) = v11;
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtype);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramtypmod);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramcollid);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_ParamP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_Aggref._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v22 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v21 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfnoid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfnoid) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtype) = 0;
  uint64_t v20 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggcollid) = 0;
  uint64_t v19 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v18 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtranstype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtranstype) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggargtypes;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggargtypes) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdirectargs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdirectargs) = v8;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = v8;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggorder;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggorder) = v8;
  uint64_t v23 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdistinct;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdistinct) = v8;
  uint64_t v25 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfilter;
  v5();
  uint64_t v24 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggstar;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggstar) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggvariadic;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggvariadic) = 0;
  uint64_t v13 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggkind);
  *uint64_t v13 = 0;
  v13[1] = 0xE000000000000000;
  uint64_t v26 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup) = 0;
  uint64_t v14 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggsplit;
  *(void *)uint64_t v14 = 0;
  *(unsigned char *)(v14 + 8) = 1;
  uint64_t v27 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v22, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v21) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfnoid);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtype);
  *(_DWORD *)(v1 + v20) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggcollid);
  *(_DWORD *)(v1 + v19) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(_DWORD *)(v1 + v18) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggtranstype);
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggargtypes);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdirectargs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggorder);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v23) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggdistinct);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfilter, v25, &demangling cache variable for type metadata for PgQuery_Node?);
  *(unsigned char *)(v1 + v24) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggstar);
  *(unsigned char *)(v1 + v12) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggvariadic);
  uint64_t v15 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggkind
                  + 8);
  *uint64_t v13 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggkind);
  v13[1] = v15;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v26) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup);
  char v16 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggsplit
                 + 8);
  *(void *)uint64_t v14 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggsplit);
  *(unsigned char *)(v14 + 8) = v16;
  *(_DWORD *)(v1 + v27) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_AggrefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_GroupingFunc._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  uint64_t v6 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__refs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__refs) = v6;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols) = v6;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__refs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__agglevelsup);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_GroupingFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_WindowFunc._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v15 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winfnoid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winfnoid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wintype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wintype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wincollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wincollid) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v17 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfilter;
  v5();
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winstar;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winstar) = 0;
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winagg;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winagg) = 0;
  uint64_t v16 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v15, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winfnoid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wintype);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__wincollid);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggfilter, v17, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref);
  *(unsigned char *)(v1 + v12) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winstar);
  *(unsigned char *)(v1 + v13) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winagg);
  *(_DWORD *)(v1 + v16) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_WindowFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_FuncExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v15 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcid) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcresulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcresulttype) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcretset;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcretset) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcvariadic;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcvariadic) = 0;
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcformat;
  *(void *)uint64_t v9 = 0;
  *(unsigned char *)(v9 + 8) = 1;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funccollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funccollid) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v16 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v15, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcid);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcresulttype);
  *(unsigned char *)(v1 + v7) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcretset);
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcvariadic);
  char v13 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcformat
                 + 8);
  *(void *)uint64_t v9 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcformat);
  *(unsigned char *)(v9 + 8) = v13;
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funccollid);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v12) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v16) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_NamedArgExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name);
  *uint64_t v7 = 0;
  v7[1] = 0xE000000000000000;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argnumber;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argnumber) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v10 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name
                  + 8);
  *uint64_t v7 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name);
  v7[1] = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argnumber);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_NamedArgExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_OpExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype);
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v13) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_OpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_DistinctExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype);
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v13) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_DistinctExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_NullIfExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opresulttype);
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opretset);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opcollid);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v13) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_NullIfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ScalarArrayOpExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOr;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOr) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opno);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opfuncid);
  *(unsigned char *)(v1 + v7) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOr);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_ScalarArrayOpExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_BoolExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLop;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v8 = *(unsigned char *)(a1
                + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLop
                + 8);
  *(void *)uint64_t v5 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLop);
  *(unsigned char *)(v5 + 8) = v8;
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SubLink._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType;
  *(void *)uint64_t v6 = 0;
  *(unsigned char *)(v6 + 8) = 1;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkID;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkID) = 0;
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr;
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr, 1, 1, Node);
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__operName;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__operName) = MEMORY[0x1E4FBC860];
  uint64_t v13 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subselect;
  v5();
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType
                 + 8);
  *(void *)uint64_t v6 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType);
  *(unsigned char *)(v6 + 8) = v11;
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkID);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr, v8, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__operName);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subselect, v13, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubLinkP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SubPlan._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v17 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType;
  *(void *)uint64_t v6 = 0;
  *(unsigned char *)(v6 + 8) = 1;
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr, 1, 1, Node);
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramIds;
  uint64_t v9 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramIds) = MEMORY[0x1E4FBC860];
  uint64_t v18 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planID;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planID) = 0;
  uint64_t v10 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planName);
  *uint64_t v10 = 0;
  v10[1] = 0xE000000000000000;
  uint64_t v24 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColType;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColType) = 0;
  uint64_t v23 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColTypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColTypmod) = 0;
  uint64_t v22 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColCollation;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColCollation) = 0;
  uint64_t v21 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useHashTable;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useHashTable) = 0;
  uint64_t v20 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unknownEqFalse;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unknownEqFalse) = 0;
  uint64_t v19 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parallelSafe;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parallelSafe) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__setParam;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__setParam) = v9;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parParam;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parParam) = v9;
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = v9;
  uint64_t v26 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startupCost;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startupCost) = 0;
  uint64_t v25 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__perCallCost;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__perCallCost) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v17, &demangling cache variable for type metadata for PgQuery_Node?);
  char v14 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType
                 + 8);
  *(void *)uint64_t v6 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subLinkType);
  *(unsigned char *)(v6 + 8) = v14;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__testexpr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__paramIds);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v18) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planID);
  uint64_t v15 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planName
                  + 8);
  *uint64_t v10 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__planName);
  v10[1] = v15;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v24) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColType);
  *(_DWORD *)(v1 + v23) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColTypmod);
  *(_DWORD *)(v1 + v22) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__firstColCollation);
  *(unsigned char *)(v1 + v21) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useHashTable);
  *(unsigned char *)(v1 + v20) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unknownEqFalse);
  *(unsigned char *)(v1 + v19) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parallelSafe);
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__setParam);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v12) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__parParam);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v13) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v26) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startupCost);
  *(void *)(v1 + v25) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_SubPlanP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__perCallCost);
  return v1;
}

uint64_t specialized PgQuery_FieldSelect._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnum;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnum) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnum);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_FieldSelectP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid);
  return v1;
}

uint64_t specialized PgQuery_FieldStore._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newvals;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newvals) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnums;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnums) = v8;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newvals);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fieldnums);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_FieldStoreP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  return v1;
}

uint64_t specialized PgQuery_RelabelType._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid) = 0;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relabelformat;
  *(void *)uint64_t v10 = 0;
  *(unsigned char *)(v10 + 8) = 1;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid);
  char v12 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relabelformat
                 + 8);
  *(void *)uint64_t v10 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relabelformat);
  *(unsigned char *)(v10 + 8) = v12;
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_RelabelTypeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CoerceViaIO._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid) = 0;
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat;
  *(void *)uint64_t v9 = 0;
  *(unsigned char *)(v9 + 8) = 1;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat
                 + 8);
  *(void *)uint64_t v9 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat);
  *(unsigned char *)(v9 + 8) = v11;
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_CoerceViaIOP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ArrayCoerceExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t v15 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elemexpr;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elemexpr, 1, 1, Node);
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid) = 0;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat;
  *(void *)uint64_t v11 = 0;
  *(unsigned char *)(v11 + 8) = 1;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v15, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elemexpr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid);
  char v13 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat
                 + 8);
  *(void *)uint64_t v11 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coerceformat);
  *(unsigned char *)(v11 + 8) = v13;
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_ArrayCoerceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ConvertRowtypeExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__convertformat;
  *(void *)uint64_t v8 = 0;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  char v10 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__convertformat
                 + 8);
  *(void *)uint64_t v8 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__convertformat);
  *(unsigned char *)(v8 + 8) = v10;
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser26PgQuery_ConvertRowtypeExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CaseExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casetype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casetype) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casecollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casecollid) = 0;
  uint64_t v8 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v12 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defresult;
  v5();
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casetype);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__casecollid);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v8, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defresult, v12, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_CaseExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ArrayExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayTypeid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayTypeid) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayCollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayCollid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elementTypeid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elementTypeid) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elements;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elements) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__multidims;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__multidims) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayTypeid);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arrayCollid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elementTypeid);
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__elements);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + v9) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__multidims);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ArrayExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RowExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  uint64_t v6 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowTypeid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowTypeid) = 0;
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowFormat;
  *(void *)uint64_t v8 = 0;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames) = v6;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowTypeid);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowFormat
                 + 8);
  *(void *)uint64_t v8 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowFormat);
  *(unsigned char *)(v8 + 8) = v11;
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colnames);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RowExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CoalesceExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescetype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescetype) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescecollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescecollid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescetype);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coalescecollid);
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_CoalesceExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_MinMaxExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxtype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxtype) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxcollid) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid) = 0;
  uint64_t v8 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op;
  *(void *)uint64_t v8 = 0;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = MEMORY[0x1E4FBC860];
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxtype);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__minmaxcollid);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inputcollid);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op
                 + 8);
  *(void *)uint64_t v8 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op);
  *(unsigned char *)(v8 + 8) = v11;
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_MinMaxExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SQLValueFunction._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v9 = *(unsigned char *)(a1
                + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op
                + 8);
  *(void *)uint64_t v5 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op);
  *(unsigned char *)(v5 + 8) = v9;
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_SQLValueFunctionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_XmlExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  uint64_t v6 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name);
  *uint64_t v6 = 0;
  v6[1] = 0xE000000000000000;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namedArgs;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namedArgs) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argNames;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argNames) = v8;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = v8;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xmloption;
  *(void *)uint64_t v11 = 0;
  *(unsigned char *)(v11 + 8) = 1;
  uint64_t v18 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type) = 0;
  uint64_t v17 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v13 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op
                 + 8);
  *(void *)uint64_t v5 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__op);
  *(unsigned char *)(v5 + 8) = v13;
  uint64_t v14 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name
                  + 8);
  *uint64_t v6 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__name);
  v6[1] = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namedArgs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argNames);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v15 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xmloption
                 + 8);
  *(void *)uint64_t v11 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xmloption);
  *(unsigned char *)(v11 + 8) = v15;
  *(_DWORD *)(v1 + v18) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__type);
  *(_DWORD *)(v1 + v17) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typmod);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_XmlExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_NullTest._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nulltesttype;
  *(void *)uint64_t v7 = 0;
  *(unsigned char *)(v7 + 8) = 1;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argisrow;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argisrow) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  char v10 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nulltesttype
                 + 8);
  *(void *)uint64_t v7 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nulltesttype);
  *(unsigned char *)(v7 + 8) = v10;
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__argisrow);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CoerceToDomain._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid) = 0;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coercionformat;
  *(void *)uint64_t v10 = 0;
  *(unsigned char *)(v10 + 8) = 1;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttype);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resulttypmod);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultcollid);
  char v12 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coercionformat
                 + 8);
  *(void *)uint64_t v10 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coercionformat);
  *(unsigned char *)(v10 + 8) = v12;
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CoerceToDomainP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CoerceToDomainValue._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser27PgQuery_CoerceToDomainValueP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SetToDefault._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeID);
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeMod);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_SetToDefaultP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_CurrentOfExpr._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cvarno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cvarno) = 0;
  uint64_t v6 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorName);
  *uint64_t v6 = 0;
  v6[1] = 0xE000000000000000;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorParam;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorParam) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v5) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cvarno);
  uint64_t v8 = *(void *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorName
                 + 8);
  *uint64_t v6 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorName);
  v6[1] = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_CurrentOfExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cursorParam);
  return v1;
}

uint64_t specialized PgQuery_TargetEntry._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resno;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resno) = 0;
  uint64_t v8 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resname);
  *uint64_t v8 = 0;
  v8[1] = 0xE000000000000000;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ressortgroupref;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ressortgroupref) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigtbl;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigtbl) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigcol;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigcol) = 0;
  uint64_t v14 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resjunk;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resjunk) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__xpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resno);
  uint64_t v12 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resname
                  + 8);
  *uint64_t v8 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resname);
  v8[1] = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ressortgroupref);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigtbl);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resorigcol);
  *(unsigned char *)(v1 + v14) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_TargetEntryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resjunk);
  return v1;
}

uint64_t specialized PgQuery_JoinExpr._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(_WORD *)(v1 + 24) = 1;
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__larg;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rarg;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rarg, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__usingClause;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__usingClause) = MEMORY[0x1E4FBC860];
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__quals;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__quals, 1, 1, Node);
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias;
  uint64_t Alias = type metadata accessor for PgQuery_Alias(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Alias - 8) + 56))(v9, 1, 1, Alias);
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtindex;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtindex) = 0;
  char v12 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v12;
  *(unsigned char *)(v1 + 25) = *(unsigned char *)(a1 + 25);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__larg, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rarg, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__usingClause);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__quals, v8, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias, v9, &demangling cache variable for type metadata for PgQuery_Alias?);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_JoinExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtindex);
  return v1;
}

uint64_t specialized PgQuery_IntoClause._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rel;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colNames;
  uint64_t v6 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colNames) = MEMORY[0x1E4FBC860];
  uint64_t v7 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  *uint64_t v7 = 0;
  v7[1] = 0xE000000000000000;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v6;
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onCommit;
  *(void *)uint64_t v9 = 0;
  *(unsigned char *)(v9 + 8) = 1;
  uint64_t v10 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpaceName);
  *uint64_t v10 = 0;
  v10[1] = 0xE000000000000000;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__viewQuery;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v11, 1, 1, Node);
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipData;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipData) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rel, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colNames);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v14 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod
                  + 8);
  *uint64_t v7 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  v7[1] = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v15 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onCommit
                 + 8);
  *(void *)uint64_t v9 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onCommit);
  *(unsigned char *)(v9 + 8) = v15;
  uint64_t v16 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpaceName
                  + 8);
  *uint64_t v10 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpaceName);
  v10[1] = v16;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__viewQuery, v11, &demangling cache variable for type metadata for PgQuery_Node?);
  *(unsigned char *)(v1 + v13) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipData);
  return v1;
}

uint64_t specialized PgQuery_Query._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = 0;
  *(_WORD *)(v1 + 40) = 1;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__utilityStmt;
  uint64_t v31 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__utilityStmt;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v30 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultRelation;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultRelation) = 0;
  uint64_t v29 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasAggs_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasAggs_p) = 0;
  uint64_t v28 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasWindowFuncs_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasWindowFuncs_p) = 0;
  uint64_t v27 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasTargetSrfs_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasTargetSrfs_p) = 0;
  uint64_t v26 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasSubLinks_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasSubLinks_p) = 0;
  uint64_t v25 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasDistinctOn_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasDistinctOn_p) = 0;
  uint64_t v24 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRecursive_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRecursive_p) = 0;
  uint64_t v23 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasModifyingCte_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasModifyingCte_p) = 0;
  uint64_t v22 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasForUpdate_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasForUpdate_p) = 0;
  uint64_t v21 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRowSecurity_p;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRowSecurity_p) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cteList;
  uint64_t v7 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cteList) = MEMORY[0x1E4FBC860];
  uint64_t v34 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtable;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtable) = v7;
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__jointree;
  uint64_t v35 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__jointree;
  uint64_t v9 = type metadata accessor for PgQuery_FromExpr(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 56))(v8, 1, 1, v9);
  uint64_t v32 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList) = v7;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override;
  *(void *)uint64_t v10 = 0;
  *(unsigned char *)(v10 + 8) = 1;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onConflict;
  uint64_t v33 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onConflict;
  uint64_t v12 = type metadata accessor for PgQuery_OnConflictExpr(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56))(v11, 1, 1, v12);
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList) = v7;
  uint64_t v36 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupClause;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupClause) = v7;
  uint64_t v37 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupingSets;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupingSets) = v7;
  uint64_t v39 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__havingQual;
  v5();
  uint64_t v38 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__windowClause;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__windowClause) = v7;
  uint64_t v40 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__distinctClause;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__distinctClause) = v7;
  uint64_t v41 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortClause;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortClause) = v7;
  uint64_t v44 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitOffset;
  v5();
  uint64_t v43 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitCount;
  v5();
  uint64_t v14 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitOption;
  *(void *)uint64_t v14 = 0;
  *(unsigned char *)(v14 + 8) = 1;
  uint64_t v42 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowMarks;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowMarks) = v7;
  uint64_t v45 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__setOperations;
  v5();
  uint64_t v15 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraintDeps;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraintDeps) = v7;
  uint64_t v46 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOptions;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOptions) = v7;
  uint64_t v48 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation) = 0;
  uint64_t v47 = OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen) = 0;
  char v16 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v16;
  char v17 = *(unsigned char *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 40) = v17;
  *(unsigned char *)(v1 + 41) = *(unsigned char *)(a1 + 41);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__utilityStmt, v31, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v30) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resultRelation);
  *(unsigned char *)(v1 + v29) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasAggs_p);
  *(unsigned char *)(v1 + v28) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasWindowFuncs_p);
  *(unsigned char *)(v1 + v27) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasTargetSrfs_p);
  *(unsigned char *)(v1 + v26) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasSubLinks_p);
  *(unsigned char *)(v1 + v25) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasDistinctOn_p);
  *(unsigned char *)(v1 + v24) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRecursive_p);
  *(unsigned char *)(v1 + v23) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasModifyingCte_p);
  *(unsigned char *)(v1 + v22) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasForUpdate_p);
  *(unsigned char *)(v1 + v21) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__hasRowSecurity_p);
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cteList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v34) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rtable);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__jointree, v35, &demangling cache variable for type metadata for PgQuery_FromExpr?);
  *(void *)(v1 + v32) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v18 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override
                 + 8);
  *(void *)uint64_t v10 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override);
  *(unsigned char *)(v10 + 8) = v18;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onConflict, v33, &demangling cache variable for type metadata for PgQuery_OnConflictExpr?);
  *(void *)(v1 + v13) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v36) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupClause);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v37) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupingSets);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__havingQual, v39, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v38) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__windowClause);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v40) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__distinctClause);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v41) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortClause);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitOffset, v44, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitCount, v43, &demangling cache variable for type metadata for PgQuery_Node?);
  char v19 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitOption
                 + 8);
  *(void *)uint64_t v14 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__limitOption);
  *(unsigned char *)(v14 + 8) = v19;
  *(void *)(v1 + v42) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowMarks);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__setOperations, v45, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v15) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraintDeps);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v46) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOptions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v48) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation);
  *(_DWORD *)(v1 + v47) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser13PgQuery_QueryP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
  return v1;
}

uint64_t specialized PgQuery_InsertStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = MEMORY[0x1E4FBC860];
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols) = MEMORY[0x1E4FBC860];
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__selectStmt;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v7, 1, 1, Node);
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onConflictClause;
  uint64_t v10 = type metadata accessor for PgQuery_OnConflictClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 56))(v9, 1, 1, v10);
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList) = v5;
  uint64_t v12 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withClause;
  uint64_t v13 = type metadata accessor for PgQuery_WithClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v13 - 8) + 56))(v12, 1, 1, v13);
  uint64_t v14 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override;
  *(void *)uint64_t v14 = 0;
  *(unsigned char *)(v14 + 8) = 1;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cols);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__selectStmt, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__onConflictClause, v9, &demangling cache variable for type metadata for PgQuery_OnConflictClause?);
  *(void *)(v1 + v11) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__returningList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withClause, v12, &demangling cache variable for type metadata for PgQuery_WithClause?);
  char v15 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override
                 + 8);
  *(void *)uint64_t v14 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_InsertStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__override);
  *(unsigned char *)(v14 + 8) = v15;
  return v1;
}

uint64_t specialized PgQuery_AlterTableCmd._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 0xE000000000000000;
  *(_DWORD *)(v1 + 48) = 0;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newowner;
  uint64_t RoleSpec = type metadata accessor for PgQuery_RoleSpec(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RoleSpec - 8) + 56))(v3, 1, 1, RoleSpec);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__def;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v5, 1, 1, Node);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior;
  *(void *)uint64_t v7 = 0;
  *(unsigned char *)(v7 + 8) = 1;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  char v9 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v9;
  uint64_t v10 = *(void *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(void *)(v1 + 40) = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + 48) = *(_DWORD *)(a1 + 48);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newowner, v3, &demangling cache variable for type metadata for PgQuery_RoleSpec?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__def, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior
                 + 8);
  *(void *)uint64_t v7 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior);
  *(unsigned char *)(v7 + 8) = v11;
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_AlterTableCmdP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

void *specialized PgQuery_AlterDomainStmt._StorageClass.init(copying:)(void *a1)
{
  v1[2] = 0;
  v1[3] = 0xE000000000000000;
  v1[4] = MEMORY[0x1E4FBC860];
  v1[5] = 0;
  v1[6] = 0xE000000000000000;
  uint64_t v3 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__def;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = (char *)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior;
  *(void *)uint64_t v5 = 0;
  v5[8] = 1;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *((unsigned char *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  uint64_t v7 = a1[3];
  v1[2] = a1[2];
  v1[3] = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[4] = a1[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v8 = a1[6];
  v1[5] = a1[5];
  v1[6] = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__def, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v9 = *((unsigned char *)a1
       + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior
       + 8);
  *(void *)uint64_t v5 = *(void *)((char *)a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior);
  v5[8] = v9;
  *((unsigned char *)v1 + v6) = *((unsigned char *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_AlterDomainStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType;
  if (!lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType;
  if (!lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType;
  if (!lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType;
  if (!lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GrantTargetType and conformance PgQuery_GrantTargetType);
  }
  return result;
}

uint64_t specialized PgQuery_CreateStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableElts;
  uint64_t v6 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableElts) = MEMORY[0x1E4FBC860];
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhRelations;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhRelations) = v6;
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partbound;
  uint64_t v25 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partbound;
  uint64_t PartitionBoundSpec = type metadata accessor for PgQuery_PartitionBoundSpec(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(PartitionBoundSpec - 8) + 56))(v8, 1, 1, PartitionBoundSpec);
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partspec;
  uint64_t v24 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partspec;
  uint64_t PartitionSpec = type metadata accessor for PgQuery_PartitionSpec(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(PartitionSpec - 8) + 56))(v10, 1, 1, PartitionSpec);
  uint64_t v12 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ofTypename;
  uint64_t v23 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ofTypename;
  uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56))(v12, 1, 1, TypeName);
  uint64_t v14 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints) = v6;
  uint64_t v15 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v6;
  uint64_t v16 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oncommit;
  *(void *)uint64_t v16 = 0;
  *(unsigned char *)(v16 + 8) = 1;
  char v17 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tablespacename);
  *char v17 = 0;
  v17[1] = 0xE000000000000000;
  char v18 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  *char v18 = 0;
  v18[1] = 0xE000000000000000;
  uint64_t v26 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableElts);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhRelations);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partbound, v25, &demangling cache variable for type metadata for PgQuery_PartitionBoundSpec?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__partspec, v24, &demangling cache variable for type metadata for PgQuery_PartitionSpec?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ofTypename, v23, &demangling cache variable for type metadata for PgQuery_TypeName?);
  *(void *)(v1 + v14) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v15) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v19 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oncommit
                 + 8);
  *(void *)uint64_t v16 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oncommit);
  *(unsigned char *)(v16 + 8) = v19;
  uint64_t v20 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tablespacename
                  + 8);
  *char v17 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tablespacename);
  v17[1] = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v21 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod
                  + 8);
  *char v18 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  v18[1] = v21;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + v26) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_CreateStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection;
  if (!lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection;
  if (!lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection;
  if (!lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection;
  if (!lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_FetchDirection and conformance PgQuery_FetchDirection);
  }
  return result;
}

uint64_t specialized PgQuery_IndexStmt._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  *uint64_t v5 = 0;
  v5[1] = 0xE000000000000000;
  uint64_t v6 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpace);
  *uint64_t v6 = 0;
  v6[1] = 0xE000000000000000;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexParams;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexParams) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexIncludingParams;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexIncludingParams) = v8;
  uint64_t v19 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v8;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  uint64_t v20 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v10, 1, 1, Node);
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__excludeOpNames;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__excludeOpNames) = v8;
  uint64_t v13 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__idxcomment);
  *uint64_t v13 = 0;
  v13[1] = 0xE000000000000000;
  uint64_t v33 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexOid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexOid) = 0;
  uint64_t v32 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldNode;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldNode) = 0;
  uint64_t v31 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldCreateSubid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldCreateSubid) = 0;
  uint64_t v30 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldFirstRelfilenodeSubid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldFirstRelfilenodeSubid) = 0;
  uint64_t v29 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unique;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unique) = 0;
  uint64_t v28 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__primary;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__primary) = 0;
  uint64_t v27 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isconstraint;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isconstraint) = 0;
  uint64_t v26 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__deferrable;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__deferrable) = 0;
  uint64_t v25 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initdeferred;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initdeferred) = 0;
  uint64_t v24 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__transformed;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__transformed) = 0;
  uint64_t v23 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__concurrent;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__concurrent) = 0;
  uint64_t v22 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists) = 0;
  uint64_t v21 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc) = 0;
  uint64_t v14 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  uint64_t v15 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod
                  + 8);
  *uint64_t v5 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  v5[1] = v15;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v16 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpace
                  + 8);
  *uint64_t v6 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__tableSpace);
  v6[1] = v16;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexParams);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexIncludingParams);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v19) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v20, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v12) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__excludeOpNames);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v17 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__idxcomment
                  + 8);
  *uint64_t v13 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__idxcomment);
  v13[1] = v17;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v33) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexOid);
  *(_DWORD *)(v1 + v32) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldNode);
  *(_DWORD *)(v1 + v31) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldCreateSubid);
  *(_DWORD *)(v1 + v30) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldFirstRelfilenodeSubid);
  *(unsigned char *)(v1 + v29) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__unique);
  *(unsigned char *)(v1 + v28) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__primary);
  *(unsigned char *)(v1 + v27) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isconstraint);
  *(unsigned char *)(v1 + v26) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__deferrable);
  *(unsigned char *)(v1 + v25) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initdeferred);
  *(unsigned char *)(v1 + v24) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__transformed);
  *(unsigned char *)(v1 + v23) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__concurrent);
  *(unsigned char *)(v1 + v22) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists);
  *(unsigned char *)(v1 + v21) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc);
  return v1;
}

uint64_t specialized PgQuery_RenameStmt._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = 0;
  *(unsigned char *)(v1 + 40) = 1;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v5, 1, 1, Node);
  uint64_t v7 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname);
  *uint64_t v7 = 0;
  v7[1] = 0xE000000000000000;
  uint64_t v8 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname);
  *uint64_t v8 = 0;
  v8[1] = 0xE000000000000000;
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior;
  *(void *)uint64_t v9 = 0;
  *(unsigned char *)(v9 + 8) = 1;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  char v11 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v11;
  char v12 = *(unsigned char *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 40) = v12;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v13 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname
                  + 8);
  *uint64_t v7 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__subname);
  v7[1] = v13;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v14 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname
                  + 8);
  *uint64_t v8 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newname);
  v8[1] = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v15 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior
                 + 8);
  *(void *)uint64_t v9 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__behavior);
  *(unsigned char *)(v9 + 8) = v15;
  *(unsigned char *)(v1 + v10) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_RenameStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

uint64_t specialized PgQuery_RuleStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename);
  *uint64_t v5 = 0;
  v5[1] = 0xE000000000000000;
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v6, 1, 1, Node);
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event;
  *(void *)uint64_t v8 = 0;
  *(unsigned char *)(v8 + 8) = 1;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions) = MEMORY[0x1E4FBC860];
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  uint64_t v12 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename
                  + 8);
  *uint64_t v5 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rulename);
  v5[1] = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  char v13 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event
                 + 8);
  *(void *)uint64_t v8 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__event);
  *(unsigned char *)(v8 + 8) = v13;
  *(unsigned char *)(v1 + v9) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__instead);
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__actions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + v11) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_RuleStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind;
  if (!lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TransactionStmtKind and conformance PgQuery_TransactionStmtKind);
  }
  return result;
}

uint64_t specialized PgQuery_ViewStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__view;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = MEMORY[0x1E4FBC860];
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases) = MEMORY[0x1E4FBC860];
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v7, 1, 1, Node);
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v5;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption;
  *(void *)uint64_t v11 = 0;
  *(unsigned char *)(v11 + 8) = 1;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__view, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aliases);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(unsigned char *)(v1 + v9) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__replace);
  *(void *)(v1 + v10) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v12 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption
                 + 8);
  *(void *)uint64_t v11 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_ViewStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__withCheckOption);
  *(unsigned char *)(v11 + 8) = v12;
  return v1;
}

uint64_t specialized PgQuery_CreateTableAsStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into;
  uint64_t IntoClause = type metadata accessor for PgQuery_IntoClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(IntoClause - 8) + 56))(v5, 1, 1, IntoClause);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind;
  *(void *)uint64_t v7 = 0;
  *(unsigned char *)(v7 + 8) = 1;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into, v5, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  char v10 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind
                 + 8);
  *(void *)uint64_t v7 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind);
  *(unsigned char *)(v7 + 8) = v10;
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isSelectInto);
  *(unsigned char *)(v1 + v9) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ifNotExists);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_VariableSetKind and conformance PgQuery_VariableSetKind);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode;
  if (!lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_DiscardMode and conformance PgQuery_DiscardMode);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleStmtType and conformance PgQuery_RoleStmtType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType;
  if (!lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ReindexObjectType and conformance PgQuery_ReindexObjectType);
  }
  return result;
}

uint64_t specialized PgQuery_CreateCastStmt._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sourcetype;
  uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56);
  v5(v3, 1, 1, TypeName);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype, 1, 1, TypeName);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__func;
  uint64_t ObjectWithArgs = type metadata accessor for PgQuery_ObjectWithArgs(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(ObjectWithArgs - 8) + 56))(v7, 1, 1, ObjectWithArgs);
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context;
  *(void *)uint64_t v9 = 0;
  *(unsigned char *)(v9 + 8) = 1;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sourcetype, v3, &demangling cache variable for type metadata for PgQuery_TypeName?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targettype, v6, &demangling cache variable for type metadata for PgQuery_TypeName?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__func, v7, &demangling cache variable for type metadata for PgQuery_ObjectWithArgs?);
  char v11 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context
                 + 8);
  *(void *)uint64_t v9 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__context);
  *(unsigned char *)(v9 + 8) = v11;
  *(unsigned char *)(v1 + v10) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_CreateCastStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inout);
  return v1;
}

uint64_t specialized PgQuery_AlterObjectDependsStmt._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v7(v5, 1, 1, Node);
  uint64_t v8 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname;
  v7(v1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname, 1, 1, Node);
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove) = 0;
  char v10 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v10;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__extname, v8, &demangling cache variable for type metadata for PgQuery_Node?);
  *(unsigned char *)(v1 + v9) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser30PgQuery_AlterObjectDependsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__remove);
  return v1;
}

uint64_t specialized PgQuery_AlterObjectSchemaStmt._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v3, 1, 1, RangeVar);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v5, 1, 1, Node);
  uint64_t v7 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema);
  *uint64_t v7 = 0;
  v7[1] = 0xE000000000000000;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk) = 0;
  char v9 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v9;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__object, v5, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v10 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema
                  + 8);
  *uint64_t v7 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__newschema);
  v7[1] = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + v8) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser29PgQuery_AlterObjectSchemaStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__missingOk);
  return v1;
}

uint64_t outlined assign with take of PgQuery_Node?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 40))(a2, a1, v5);
  return a2;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterTSConfigType and conformance PgQuery_AlterTSConfigType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType;
  if (!lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ImportForeignSchemaType and conformance PgQuery_ImportForeignSchemaType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType;
  if (!lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AlterSubscriptionType and conformance PgQuery_AlterSubscriptionType);
  }
  return result;
}

uint64_t specialized PgQuery_A_Expr._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = MEMORY[0x1E4FBC860];
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr;
  v5(v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  char v8 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v8;
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

void *specialized PgQuery_FuncCall._StorageClass.init(copying:)(void *a1)
{
  uint64_t v3 = MEMORY[0x1E4FBC860];
  v1[2] = MEMORY[0x1E4FBC860];
  v1[3] = v3;
  v1[4] = v3;
  uint64_t v4 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggFilter;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v4, 1, 1, Node);
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup;
  *((unsigned char *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup) = 0;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar;
  *((unsigned char *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct;
  *((unsigned char *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic;
  *((unsigned char *)v1
  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic) = 0;
  uint64_t v10 = (uint64_t)v1
      + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__over;
  uint64_t WindowDef = type metadata accessor for PgQuery_WindowDef(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(WindowDef - 8) + 56))(v10, 1, 1, WindowDef);
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  v1[2] = a1[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[3] = a1[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[4] = a1[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggFilter, v4, &demangling cache variable for type metadata for PgQuery_Node?);
  *((unsigned char *)v1 + v6) = *((unsigned char *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggWithinGroup);
  *((unsigned char *)v1 + v7) = *((unsigned char *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggStar);
  *((unsigned char *)v1 + v8) = *((unsigned char *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__aggDistinct);
  *((unsigned char *)v1 + v9) = *((unsigned char *)a1
                        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__funcVariadic);
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__over, v10, &demangling cache variable for type metadata for PgQuery_WindowDef?);
  *(_DWORD *)((char *)v1 + v12) = *(_DWORD *)((char *)a1
                                            + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_FuncCallP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

void *specialized PgQuery_ResTarget._StorageClass.init(copying:)(void *a1)
{
  v1[2] = 0;
  v1[3] = 0xE000000000000000;
  v1[4] = MEMORY[0x1E4FBC860];
  uint64_t v3 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v6 = a1[3];
  v1[2] = a1[2];
  v1[3] = v6;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  v1[4] = a1[4];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)((char *)v1 + v5) = *(_DWORD *)((char *)a1
                                           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_SortBy._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir;
  *(void *)uint64_t v5 = 0;
  *(unsigned char *)(v5 + 8) = 1;
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls;
  *(void *)uint64_t v6 = 0;
  *(unsigned char *)(v6 + 8) = 1;
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp) = MEMORY[0x1E4FBC860];
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v9 = *(unsigned char *)(a1
                + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir
                + 8);
  *(void *)uint64_t v5 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyDir);
  *(unsigned char *)(v5 + 8) = v9;
  char v10 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls
                 + 8);
  *(void *)uint64_t v6 = *(void *)(a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__sortbyNulls);
  *(unsigned char *)(v6 + 8) = v10;
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__useOp);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_SortByP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_WindowDef._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 0xE000000000000000;
  uint64_t v3 = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 48) = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 64) = 0;
  uint64_t v4 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v6(v4, 1, 1, Node);
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset;
  v6(v1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, 1, 1, Node);
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v9 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v9;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v10 = *(void *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(void *)(v1 + 40) = v10;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + 48) = *(void *)(a1 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + 56) = *(void *)(a1 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + 64) = *(_DWORD *)(a1 + 64);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset, v4, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_WindowDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableSample._StorageClass.init(copying:)(uint64_t a1)
{
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method;
  uint64_t v7 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method) = MEMORY[0x1E4FBC860];
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args) = v7;
  uint64_t v9 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable, 1, 1, Node);
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relation, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__method);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__repeatable, v9, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v10) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_RangeTableSampleP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableFunc._StorageClass.init(copying:)(uint64_t a1)
{
  *(unsigned char *)(v1 + 16) = 0;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v5(v3, 1, 1, Node);
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr;
  v5(v1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, 1, 1, Node);
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces) = MEMORY[0x1E4FBC860];
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns) = v8;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias;
  uint64_t Alias = type metadata accessor for PgQuery_Alias(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Alias - 8) + 56))(v10, 1, 1, Alias);
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  *(unsigned char *)(v1 + 16) = *(unsigned char *)(a1 + 16);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__docexpr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rowexpr, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__namespaces);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__columns);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__alias, v10, &demangling cache variable for type metadata for PgQuery_Alias?);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser22PgQuery_RangeTableFuncP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_RangeTableFuncCol._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56))(v3, 1, 1, TypeName);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality) = 0;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull) = 0;
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v9 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56);
  v9(v7, 1, 1, Node);
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr;
  v9(v1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr, 1, 1, Node);
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v3, &demangling cache variable for type metadata for PgQuery_TypeName?);
  *(unsigned char *)(v1 + v5) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__forOrdinality);
  *(unsigned char *)(v1 + v6) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__colexpr, v7, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__coldefexpr, v10, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v11) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_RangeTableFuncColP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_ColumnDef._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  uint64_t v32 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName;
  uint64_t TypeName = type metadata accessor for PgQuery_TypeName(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(TypeName - 8) + 56))(v3, 1, 1, TypeName);
  uint64_t v30 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount) = 0;
  uint64_t v29 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal) = 0;
  uint64_t v28 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull) = 0;
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType) = 0;
  uint64_t v6 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage);
  *uint64_t v6 = 0;
  v6[1] = 0xE000000000000000;
  uint64_t v7 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault;
  uint64_t v31 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v9 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v9)(v7, 1, 1, Node);
  uint64_t v27 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedDefault;
  v9();
  uint64_t v10 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity);
  *uint64_t v10 = 0;
  v10[1] = 0xE000000000000000;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence;
  uint64_t v26 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v11, 1, 1, RangeVar);
  char v13 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated);
  *char v13 = 0;
  v13[1] = 0xE000000000000000;
  uint64_t v14 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause;
  uint64_t v25 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause;
  uint64_t CollateClause = type metadata accessor for PgQuery_CollateClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(CollateClause - 8) + 56))(v14, 1, 1, CollateClause);
  uint64_t v16 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid) = 0;
  uint64_t v17 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints;
  uint64_t v18 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints) = MEMORY[0x1E4FBC860];
  uint64_t v19 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions) = v18;
  uint64_t v33 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v20 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__typeName, v32, &demangling cache variable for type metadata for PgQuery_TypeName?);
  *(_DWORD *)(v1 + v30) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inhcount);
  *(unsigned char *)(v1 + v29) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isLocal);
  *(unsigned char *)(v1 + v28) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isNotNull);
  *(unsigned char *)(v1 + v5) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__isFromType);
  uint64_t v21 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage
                  + 8);
  *uint64_t v6 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__storage);
  v6[1] = v21;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawDefault, v31, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedDefault, v27, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v22 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity
                  + 8);
  *uint64_t v10 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identity);
  v10[1] = v22;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__identitySequence, v26, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  uint64_t v23 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated
                  + 8);
  *char v13 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generated);
  v13[1] = v23;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collClause, v25, &demangling cache variable for type metadata for PgQuery_CollateClause?);
  *(_DWORD *)(v1 + v16) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collOid);
  *(void *)(v1 + v17) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__constraints);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v19) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fdwoptions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v33) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ColumnDefP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_IndexElem._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname);
  *uint64_t v5 = 0;
  v5[1] = 0xE000000000000000;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  uint64_t v7 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = MEMORY[0x1E4FBC860];
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass) = v7;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts) = v7;
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering;
  *(void *)uint64_t v10 = 0;
  *(unsigned char *)(v10 + 8) = 1;
  uint64_t v11 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering;
  *(void *)uint64_t v11 = 0;
  *(unsigned char *)(v11 + 8) = 1;
  uint64_t v12 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v12;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v13 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname
                  + 8);
  *uint64_t v5 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexcolname);
  v5[1] = v13;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v6) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v8) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v9) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclassopts);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  char v14 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering
                 + 8);
  *(void *)uint64_t v10 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__ordering);
  *(unsigned char *)(v10 + 8) = v14;
  char v15 = *(unsigned char *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering
                 + 8);
  *(void *)uint64_t v11 = *(void *)(a1
                             + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_IndexElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nullsOrdering);
  *(unsigned char *)(v11 + 8) = v15;
  return v1;
}

uint64_t specialized PgQuery_Constraint._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 0xE000000000000000;
  *(_WORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  *(unsigned char *)(v1 + 56) = 0;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr;
  uint64_t v26 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v5 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v5)(v3, 1, 1, Node);
  uint64_t v6 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr);
  *uint64_t v6 = 0;
  v6[1] = 0xE000000000000000;
  uint64_t v7 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen);
  *uint64_t v7 = 0;
  v7[1] = 0xE000000000000000;
  uint64_t v27 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys;
  uint64_t v8 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys) = MEMORY[0x1E4FBC860];
  uint64_t v28 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including) = v8;
  uint64_t v29 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions) = v8;
  uint64_t v30 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options) = v8;
  uint64_t v9 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname);
  *uint64_t v9 = 0;
  v9[1] = 0xE000000000000000;
  uint64_t v31 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace);
  *uint64_t v31 = 0;
  v31[1] = 0xE000000000000000;
  uint64_t v34 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc) = 0;
  uint64_t v33 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  *uint64_t v33 = 0;
  v33[1] = 0xE000000000000000;
  uint64_t v36 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  v5();
  uint64_t v10 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable;
  uint64_t v32 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable;
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(RangeVar - 8) + 56))(v10, 1, 1, RangeVar);
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs) = v8;
  uint64_t v35 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs) = v8;
  uint64_t v13 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype);
  *uint64_t v13 = 0;
  v13[1] = 0xE000000000000000;
  char v14 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction);
  *char v14 = 0;
  v14[1] = 0xE000000000000000;
  uint64_t v37 = (void *)(v1
                 + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction);
  *uint64_t v37 = 0;
  v37[1] = 0xE000000000000000;
  uint64_t v38 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop) = v8;
  uint64_t v39 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid) = 0;
  uint64_t v41 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation) = 0;
  uint64_t v40 = OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid) = 0;
  char v15 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v15;
  uint64_t v16 = *(void *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(void *)(v1 + 40) = v16;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + 48) = *(unsigned char *)(a1 + 48);
  *(unsigned char *)(v1 + 49) = *(unsigned char *)(a1 + 49);
  *(_DWORD *)(v1 + 52) = *(_DWORD *)(a1 + 52);
  *(unsigned char *)(v1 + 56) = *(unsigned char *)(a1 + 56);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rawExpr, v26, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v17 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr
                  + 8);
  *uint64_t v6 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cookedExpr);
  v6[1] = v17;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v18 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen
                  + 8);
  *uint64_t v7 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__generatedWhen);
  v7[1] = v18;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v27) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__keys);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v28) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__including);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v29) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__exclusions);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v30) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__options);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v19 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname
                  + 8);
  *uint64_t v9 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexname);
  v9[1] = v19;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v20 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace
                  + 8);
  *uint64_t v31 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__indexspace);
  v31[1] = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(v1 + v34) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__resetDefaultTblspc);
  uint64_t v21 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod
                  + 8);
  *uint64_t v33 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__accessMethod);
  v33[1] = v21;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v36, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pktable, v32, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  *(void *)(v1 + v12) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkAttrs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v35) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__pkAttrs);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v22 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype
                  + 8);
  *uint64_t v13 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkMatchtype);
  v13[1] = v22;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v23 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction
                  + 8);
  *char v14 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkUpdAction);
  v14[1] = v23;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v24 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction
                  + 8);
  *uint64_t v37 = *(void *)(a1
                   + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__fkDelAction);
  v37[1] = v24;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v38) = *(void *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldConpfeqop);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v39) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__oldPktableOid);
  *(unsigned char *)(v1 + v41) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__skipValidation);
  *(unsigned char *)(v1 + v40) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_ConstraintP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__initiallyValid);
  return v1;
}

void *specialized PgQuery_DefElem._StorageClass.init(copying:)(void *a1)
{
  v1[2] = 0;
  v1[3] = 0xE000000000000000;
  v1[4] = 0;
  v1[5] = 0xE000000000000000;
  uint64_t v3 = (uint64_t)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = (char *)v1
     + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction;
  *(void *)uint64_t v5 = 0;
  v5[8] = 1;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)((char *)v1
            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v7 = a1[3];
  v1[2] = a1[2];
  v1[3] = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v8 = a1[5];
  v1[4] = a1[4];
  v1[5] = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?((uint64_t)a1+ OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  char v9 = *((unsigned char *)a1
       + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction
       + 8);
  *(void *)uint64_t v5 = *(void *)((char *)a1
                            + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__defaction);
  v5[8] = v9;
  *(_DWORD *)((char *)v1 + v6) = *(_DWORD *)((char *)a1
                                           + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_DefElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_WithCheckOption._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 0xE000000000000000;
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 56) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__qual;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded) = 0;
  char v6 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(void *)(v1 + 40) = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(v1 + 48) = *(void *)(a1 + 48);
  *(void *)(v1 + 56) = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__qual, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(unsigned char *)(v1 + v5) = *(unsigned char *)(a1
                                 + OBJC_IVAR____TtCV14BiomeSQLParser23PgQuery_WithCheckOptionP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__cascaded);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind;
  if (!lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_GroupingSetKind and conformance PgQuery_GroupingSetKind);
  }
  return result;
}

uint64_t specialized PgQuery_WindowClause._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 0xE000000000000000;
  uint64_t v3 = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 48) = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 64) = 0;
  uint64_t v4 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  uint64_t v18 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  char v6 = *(void (**)(void))(*(void *)(Node - 8) + 56);
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v6)(v4, 1, 1, Node);
  uint64_t v17 = v1
      + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset;
  v6();
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc) = 0;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc) = 0;
  uint64_t v9 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl) = 0;
  uint64_t v10 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc) = 0;
  uint64_t v11 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst) = 0;
  uint64_t v12 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref) = 0;
  uint64_t v13 = OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder;
  *(unsigned char *)(v1
           + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder) = 0;
  uint64_t v14 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v14;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v15 = *(void *)(a1 + 40);
  *(void *)(v1 + 32) = *(void *)(a1 + 32);
  *(void *)(v1 + 40) = v15;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + 48) = *(void *)(a1 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + 56) = *(void *)(a1 + 56);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + 64) = *(_DWORD *)(a1 + 64);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startOffset, v18, &demangling cache variable for type metadata for PgQuery_Node?);
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endOffset, v17, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v7) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__startInRangeFunc);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__endInRangeFunc);
  *(_DWORD *)(v1 + v9) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeColl);
  *(unsigned char *)(v1 + v10) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeAsc);
  *(unsigned char *)(v1 + v11) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__inRangeNullsFirst);
  *(_DWORD *)(v1 + v12) = *(_DWORD *)(a1
                                    + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__winref);
  *(unsigned char *)(v1 + v13) = *(unsigned char *)(a1
                                  + OBJC_IVAR____TtCV14BiomeSQLParser20PgQuery_WindowClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__copiedOrder);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength;
  if (!lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockClauseStrength and conformance PgQuery_LockClauseStrength);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy;
  if (!lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockWaitPolicy and conformance PgQuery_LockWaitPolicy);
  }
  return result;
}

uint64_t specialized PgQuery_InferClause._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = MEMORY[0x1E4FBC860];
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = (void *)(v1
                + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname);
  *uint64_t v5 = 0;
  v5[1] = 0xE000000000000000;
  uint64_t v6 = OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v7 = *(void *)(a1
                 + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname
                 + 8);
  *uint64_t v5 = *(void *)(a1
                  + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__conname);
  v5[1] = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v6) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser19PgQuery_InferClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t specialized PgQuery_OnConflictClause._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 24) = 1;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infer;
  uint64_t InferClause = type metadata accessor for PgQuery_InferClause(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(InferClause - 8) + 56))(v3, 1, 1, InferClause);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList) = MEMORY[0x1E4FBC860];
  uint64_t v6 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v6, 1, 1, Node);
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  char v9 = *(unsigned char *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(unsigned char *)(v1 + 24) = v9;
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__infer, v3, &demangling cache variable for type metadata for PgQuery_InferClause?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v6, &demangling cache variable for type metadata for PgQuery_Node?);
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser24PgQuery_OnConflictClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

uint64_t outlined assign with copy of PgQuery_Node?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24))(a2, a1, v5);
  return a2;
}

unint64_t lazy protocol witness table accessor for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType;
  if (!lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_RoleSpecType and conformance PgQuery_RoleSpecType);
  }
  return result;
}

uint64_t specialized PgQuery_PartitionElem._StorageClass.init(copying:)(uint64_t a1)
{
  *(void *)(v1 + 16) = 0;
  *(void *)(v1 + 24) = 0xE000000000000000;
  uint64_t v3 = v1
     + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(Node - 8) + 56))(v3, 1, 1, Node);
  uint64_t v5 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation;
  uint64_t v6 = MEMORY[0x1E4FBC860];
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation) = MEMORY[0x1E4FBC860];
  uint64_t v7 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass;
  *(void *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass) = v6;
  uint64_t v8 = OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location;
  *(_DWORD *)(v1
            + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location) = 0;
  uint64_t v9 = *(void *)(a1 + 24);
  *(void *)(v1 + 16) = *(void *)(a1 + 16);
  *(void *)(v1 + 24) = v9;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  outlined assign with copy of PgQuery_Node?(a1+ OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__expr, v3, &demangling cache variable for type metadata for PgQuery_Node?);
  *(void *)(v1 + v5) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__collation);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(v1 + v7) = *(void *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__opclass);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(_DWORD *)(v1 + v8) = *(_DWORD *)(a1
                                   + OBJC_IVAR____TtCV14BiomeSQLParser21PgQuery_PartitionElemP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  return v1;
}

unint64_t lazy protocol witness table accessor for type PgQuery_Token and conformance PgQuery_Token()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token;
  if (!lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_Token and conformance PgQuery_Token);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind;
  if (!lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_KeywordKind and conformance PgQuery_KeywordKind);
  }
  return result;
}

ValueMetadata *type metadata accessor for PgQuery_TableLikeOption()
{
  return &type metadata for PgQuery_TableLikeOption;
}

ValueMetadata *type metadata accessor for PgQuery_ClusterOption()
{
  return &type metadata for PgQuery_ClusterOption;
}

ValueMetadata *type metadata accessor for PgQuery_AggStrategy()
{
  return &type metadata for PgQuery_AggStrategy;
}

ValueMetadata *type metadata accessor for PgQuery_SetOpCmd()
{
  return &type metadata for PgQuery_SetOpCmd;
}

ValueMetadata *type metadata accessor for PgQuery_SetOpStrategy()
{
  return &type metadata for PgQuery_SetOpStrategy;
}

ValueMetadata *type metadata accessor for PgQuery_LockTupleMode()
{
  return &type metadata for PgQuery_LockTupleMode;
}

ValueMetadata *type metadata accessor for PgQuery_KeywordKind()
{
  return &type metadata for PgQuery_KeywordKind;
}

ValueMetadata *type metadata accessor for PgQuery_Token()
{
  return &type metadata for PgQuery_Token;
}

ValueMetadata *type metadata accessor for PgQuery_RoleSpecType()
{
  return &type metadata for PgQuery_RoleSpecType;
}

uint64_t getEnumTagSinglePayload for PgQuery_Null(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, j____swift_get_extra_inhabitant_index_4155Tm);
}

uint64_t storeEnumTagSinglePayload for PgQuery_Null(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, j____swift_store_extra_inhabitant_index_4156Tm);
}

uint64_t getEnumTagSinglePayload for PgQuery_A_Star(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, j____swift_get_extra_inhabitant_index_4155Tm_0);
}

uint64_t storeEnumTagSinglePayload for PgQuery_A_Star(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, j____swift_store_extra_inhabitant_index_4156Tm_0);
}

uint64_t getEnumTagSinglePayload for PgQuery_CheckPointStmt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, j____swift_get_extra_inhabitant_index_4155Tm_1);
}

uint64_t storeEnumTagSinglePayload for PgQuery_CheckPointStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, j____swift_store_extra_inhabitant_index_4156Tm_1);
}

uint64_t initializeBufferWithCopyOfBuffer for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  uint64_t v5 = **(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v4 - 8);

  return v5(a1, a2, v4);
}

uint64_t destroy for PgQuery_Null(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for UnknownStorage();
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8);

  return v3(a1, v2);
}

uint64_t initializeWithCopy for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a1, a2, v4);
  return a1;
}

uint64_t assignWithCopy for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 24))(a1, a2, v4);
  return a1;
}

uint64_t initializeWithTake for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a1, a2, v4);
  return a1;
}

uint64_t assignWithTake for PgQuery_Null(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40))(a1, a2, v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for PgQuery_Expr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_18EA0B0B0);
}

uint64_t __swift_get_extra_inhabitant_index_4155Tm(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 48);

  return v5(a1, a2, v4);
}

uint64_t storeEnumTagSinglePayload for PgQuery_Expr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18EA0B134);
}

uint64_t __swift_store_extra_inhabitant_index_4156Tm(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for UnknownStorage();
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 56);

  return v5(a1, a2, a2, v4);
}

uint64_t type metadata completion function for PgQuery_Null()
{
  uint64_t result = type metadata accessor for UnknownStorage();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for PgQuery_LockWaitPolicy()
{
  return &type metadata for PgQuery_LockWaitPolicy;
}

ValueMetadata *type metadata accessor for PgQuery_LockClauseStrength()
{
  return &type metadata for PgQuery_LockClauseStrength;
}

ValueMetadata *type metadata accessor for PgQuery_GroupingSetKind()
{
  return &type metadata for PgQuery_GroupingSetKind;
}

ValueMetadata *type metadata accessor for PgQuery_AlterSubscriptionType()
{
  return &type metadata for PgQuery_AlterSubscriptionType;
}

ValueMetadata *type metadata accessor for PgQuery_ImportForeignSchemaType()
{
  return &type metadata for PgQuery_ImportForeignSchemaType;
}

ValueMetadata *type metadata accessor for PgQuery_AlterTSConfigType()
{
  return &type metadata for PgQuery_AlterTSConfigType;
}

ValueMetadata *type metadata accessor for PgQuery_ReindexObjectType()
{
  return &type metadata for PgQuery_ReindexObjectType;
}

ValueMetadata *type metadata accessor for PgQuery_RoleStmtType()
{
  return &type metadata for PgQuery_RoleStmtType;
}

ValueMetadata *type metadata accessor for PgQuery_DiscardMode()
{
  return &type metadata for PgQuery_DiscardMode;
}

ValueMetadata *type metadata accessor for PgQuery_VariableSetKind()
{
  return &type metadata for PgQuery_VariableSetKind;
}

ValueMetadata *type metadata accessor for PgQuery_TransactionStmtKind()
{
  return &type metadata for PgQuery_TransactionStmtKind;
}

ValueMetadata *type metadata accessor for PgQuery_FetchDirection()
{
  return &type metadata for PgQuery_FetchDirection;
}

ValueMetadata *type metadata accessor for PgQuery_GrantTargetType()
{
  return &type metadata for PgQuery_GrantTargetType;
}

void *initializeBufferWithCopyOfBuffer for PgQuery_ScanToken(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = (void *)a1;
  int v4 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v4 & 0x20000) != 0)
  {
    uint64_t v9 = *a2;
    *uint64_t v3 = *a2;
    uint64_t v3 = (void *)(v9 + ((v4 + 16) & ~(unint64_t)v4));
    swift_retain();
  }
  else
  {
    *(void *)a1 = *a2;
    *(void *)(a1 + 8) = a2[1];
    *(unsigned char *)(a1 + 16) = *((unsigned char *)a2 + 16);
    *(void *)(a1 + 24) = a2[3];
    uint64_t v5 = *(int *)(a3 + 32);
    uint64_t v6 = a1 + v5;
    uint64_t v7 = (uint64_t)a2 + v5;
    *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
    uint64_t v8 = type metadata accessor for UnknownStorage();
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(v6, v7, v8);
  }
  return v3;
}

uint64_t destroy for PgQuery_RowMarkClause(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + *(int *)(a2 + 32);
  uint64_t v3 = type metadata accessor for UnknownStorage();
  int v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8);

  return v4(v2, v3);
}

uint64_t initializeWithCopy for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  uint64_t v4 = *(int *)(a3 + 32);
  uint64_t v5 = a1 + v4;
  uint64_t v6 = a2 + v4;
  uint64_t v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 16))(v5, v6, v7);
  return a1;
}

uint64_t assignWithCopy for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  uint64_t v4 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  uint64_t v5 = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(a1 + 24) = v5;
  uint64_t v6 = *(int *)(a3 + 32);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 24))(v7, v8, v9);
  return a1;
}

uint64_t initializeWithTake for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  uint64_t v4 = *(int *)(a3 + 32);
  uint64_t v5 = a1 + v4;
  uint64_t v6 = a2 + v4;
  uint64_t v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32))(v5, v6, v7);
  return a1;
}

uint64_t assignWithTake for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  uint64_t v4 = *(int *)(a3 + 32);
  uint64_t v5 = a1 + v4;
  uint64_t v6 = a2 + v4;
  uint64_t v7 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 40))(v5, v6, v7);
  return a1;
}

uint64_t getEnumTagSinglePayload for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_18EA0B6E4);
}

uint64_t sub_18EA0B6E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1 + *(int *)(a3 + 32);
  uint64_t v5 = type metadata accessor for UnknownStorage();
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 48);

  return v6(v4, a2, v5);
}

uint64_t storeEnumTagSinglePayload for PgQuery_ScanToken(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18EA0B768);
}

uint64_t sub_18EA0B768(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1 + *(int *)(a4 + 32);
  uint64_t v6 = type metadata accessor for UnknownStorage();
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56);

  return v7(v5, a2, a2, v6);
}

uint64_t type metadata completion function for PgQuery_ScanToken()
{
  return type metadata completion function for PgQuery_InlineCodeBlock();
}

unint64_t lazy protocol witness table accessor for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode;
  if (!lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_LockTupleMode and conformance PgQuery_LockTupleMode);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpStrategy and conformance PgQuery_SetOpStrategy);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd;
  if (!lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_SetOpCmd and conformance PgQuery_SetOpCmd);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy;
  if (!lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_AggStrategy and conformance PgQuery_AggStrategy);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption;
  if (!lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_ClusterOption and conformance PgQuery_ClusterOption);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption()
{
  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption;
  if (!lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type PgQuery_TableLikeOption and conformance PgQuery_TableLikeOption);
  }
  return result;
}

BOOL specialized == infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1 == a3;
}

uint64_t specialized == infix<A>(_:_:)()
{
  uint64_t v0 = SQLFunction.rawValue.getter();
  uint64_t v2 = v1;
  if (v0 == SQLFunction.rawValue.getter() && v2 == v3) {
    char v5 = 1;
  }
  else {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v5 & 1;
}

BiomeSQLParser::SQLFunction_optional __swiftcall SQLFunction.init(rawValue:)(Swift::String rawValue)
{
  uint64_t v2 = v1;
  uint64_t v3 = _findStringSwitchCaseWithCache(cases:string:cache:)();
  result.value = swift_bridgeObjectRelease();
  char v5 = 0;
  char v6 = 80;
  switch(v3)
  {
    case 0:
      goto LABEL_82;
    case 1:
      char v5 = 1;
      goto LABEL_82;
    case 2:
      char v5 = 2;
      goto LABEL_82;
    case 3:
      char v5 = 3;
      goto LABEL_82;
    case 4:
      char v5 = 4;
      goto LABEL_82;
    case 5:
      char v5 = 5;
      goto LABEL_82;
    case 6:
      char v5 = 6;
      goto LABEL_82;
    case 7:
      char v5 = 7;
      goto LABEL_82;
    case 8:
      char v5 = 8;
      goto LABEL_82;
    case 9:
      char v5 = 9;
      goto LABEL_82;
    case 10:
      char v5 = 10;
      goto LABEL_82;
    case 11:
      char v5 = 11;
      goto LABEL_82;
    case 12:
      char v5 = 12;
      goto LABEL_82;
    case 13:
      char v5 = 13;
      goto LABEL_82;
    case 14:
      char v5 = 14;
      goto LABEL_82;
    case 15:
      char v5 = 15;
      goto LABEL_82;
    case 16:
      char v5 = 16;
      goto LABEL_82;
    case 17:
      char v5 = 17;
      goto LABEL_82;
    case 18:
      char v5 = 18;
      goto LABEL_82;
    case 19:
      char v5 = 19;
      goto LABEL_82;
    case 20:
      char v5 = 20;
      goto LABEL_82;
    case 21:
      char v5 = 21;
      goto LABEL_82;
    case 22:
      char v5 = 22;
      goto LABEL_82;
    case 23:
      char v5 = 23;
      goto LABEL_82;
    case 24:
      char v5 = 24;
      goto LABEL_82;
    case 25:
      char v5 = 25;
      goto LABEL_82;
    case 26:
      char v5 = 26;
      goto LABEL_82;
    case 27:
      char v5 = 27;
      goto LABEL_82;
    case 28:
      char v5 = 28;
      goto LABEL_82;
    case 29:
      char v5 = 29;
      goto LABEL_82;
    case 30:
      char v5 = 30;
      goto LABEL_82;
    case 31:
      char v5 = 31;
      goto LABEL_82;
    case 32:
      char v5 = 32;
      goto LABEL_82;
    case 33:
      char v5 = 33;
      goto LABEL_82;
    case 34:
      char v5 = 34;
      goto LABEL_82;
    case 35:
      char v5 = 35;
      goto LABEL_82;
    case 36:
      char v5 = 36;
      goto LABEL_82;
    case 37:
      char v5 = 37;
      goto LABEL_82;
    case 38:
      char v5 = 38;
      goto LABEL_82;
    case 39:
      char v5 = 39;
      goto LABEL_82;
    case 40:
      char v5 = 40;
      goto LABEL_82;
    case 41:
      char v5 = 41;
      goto LABEL_82;
    case 42:
      char v5 = 42;
      goto LABEL_82;
    case 43:
      char v5 = 43;
      goto LABEL_82;
    case 44:
      char v5 = 44;
      goto LABEL_82;
    case 45:
      char v5 = 45;
      goto LABEL_82;
    case 46:
      char v5 = 46;
      goto LABEL_82;
    case 47:
      char v5 = 47;
      goto LABEL_82;
    case 48:
      char v5 = 48;
      goto LABEL_82;
    case 49:
      char v5 = 49;
      goto LABEL_82;
    case 50:
      char v5 = 50;
      goto LABEL_82;
    case 51:
      char v5 = 51;
      goto LABEL_82;
    case 52:
      char v5 = 52;
      goto LABEL_82;
    case 53:
      char v5 = 53;
      goto LABEL_82;
    case 54:
      char v5 = 54;
      goto LABEL_82;
    case 55:
      char v5 = 55;
      goto LABEL_82;
    case 56:
      char v5 = 56;
      goto LABEL_82;
    case 57:
      char v5 = 57;
      goto LABEL_82;
    case 58:
      char v5 = 58;
      goto LABEL_82;
    case 59:
      char v5 = 59;
      goto LABEL_82;
    case 60:
      char v5 = 60;
      goto LABEL_82;
    case 61:
      char v5 = 61;
      goto LABEL_82;
    case 62:
      char v5 = 62;
      goto LABEL_82;
    case 63:
      char v5 = 63;
      goto LABEL_82;
    case 64:
      char v5 = 64;
      goto LABEL_82;
    case 65:
      char v5 = 65;
      goto LABEL_82;
    case 66:
      char v5 = 66;
      goto LABEL_82;
    case 67:
      char v5 = 67;
      goto LABEL_82;
    case 68:
      char v5 = 68;
      goto LABEL_82;
    case 69:
      char v5 = 69;
      goto LABEL_82;
    case 70:
      char v5 = 70;
      goto LABEL_82;
    case 71:
      char v5 = 71;
      goto LABEL_82;
    case 72:
      char v5 = 72;
      goto LABEL_82;
    case 73:
      char v5 = 73;
      goto LABEL_82;
    case 74:
      char v5 = 74;
      goto LABEL_82;
    case 75:
      char v5 = 75;
      goto LABEL_82;
    case 76:
      char v5 = 76;
      goto LABEL_82;
    case 77:
      char v5 = 77;
      goto LABEL_82;
    case 78:
      char v5 = 78;
      goto LABEL_82;
    case 79:
      char v5 = 79;
LABEL_82:
      char v6 = v5;
      break;
    case 80:
      break;
    case 81:
      char v6 = 81;
      break;
    case 82:
      char v6 = 82;
      break;
    case 83:
      char v6 = 83;
      break;
    case 84:
      char v6 = 84;
      break;
    case 85:
      char v6 = 85;
      break;
    case 86:
      char v6 = 86;
      break;
    case 87:
      char v6 = 87;
      break;
    case 88:
      char v6 = 88;
      break;
    case 89:
      char v6 = 89;
      break;
    case 90:
      char v6 = 90;
      break;
    case 91:
      char v6 = 91;
      break;
    case 92:
      char v6 = 92;
      break;
    case 93:
      char v6 = 93;
      break;
    case 94:
      char v6 = 94;
      break;
    case 95:
      char v6 = 95;
      break;
    case 96:
      char v6 = 96;
      break;
    case 97:
      char v6 = 97;
      break;
    default:
      char v6 = 98;
      break;
  }
  *uint64_t v2 = v6;
  return result;
}

void *static SQLFunction.allCases.getter()
{
  return &outlined read-only object #0 of static SQLFunction.allCases.getter;
}

uint64_t SQLFunction.rawValue.getter()
{
  uint64_t result = 7561825;
  switch(*v0)
  {
    case 1:
      return 892497250;
    case 2:
      return 0x7365676E616863;
    case 3:
      return 1918986339;
    case 4:
      return 0x656373656C616F63;
    case 5:
      return 0x7369645F656D7563;
    case 6:
    case 7:
      unsigned int v2 = 1920103779;
      goto LABEL_61;
    case 8:
    case 0x16:
    case 0x1E:
    case 0x21:
    case 0x2D:
      return 0xD000000000000011;
    case 9:
      return 1702125924;
    case 0xA:
      unsigned int v3 = 1702125924;
      goto LABEL_84;
    case 0xB:
      return 0x61725F65736E6564;
    case 0xC:
      return 0x61765F7473726966;
    case 0xD:
      return 0x726F6F6C66;
    case 0xE:
      return 0x6B6F745F33737466;
    case 0xF:
      return 896758886;
    case 0x10:
      return 0x756F735F35737466;
    case 0x11:
      return 1651469415;
    case 0x12:
      return 7890280;
    case 0x13:
      return 0x6867696C68676968;
    case 0x14:
      return 0x34353765656569;
    case 0x15:
      return 0xD000000000000010;
    case 0x17:
      return 0xD000000000000010;
    case 0x18:
      return 0x5F34353765656569;
    case 0x19:
      return 0x6C6C756E6669;
    case 0x1A:
      return 6711657;
    case 0x1B:
      return 0x7274736E69;
    case 0x1C:
      return 1852797802;
    case 0x1D:
      return 0x7272615F6E6F736ALL;
    case 0x1F:
      return 0x7478655F6E6F736ALL;
    case 0x20:
      return 0xD000000000000010;
    case 0x22:
      return 0x736E695F6E6F736ALL;
    case 0x23:
      return 0x6A626F5F6E6F736ALL;
    case 0x24:
      return 0x7461705F6E6F736ALL;
    case 0x25:
      return 0x6F75715F6E6F736ALL;
    case 0x26:
      return 0x6D65725F6E6F736ALL;
    case 0x27:
      return 0x7065725F6E6F736ALL;
    case 0x28:
      return 0x7465735F6E6F736ALL;
    case 0x29:
      return 0x7079745F6E6F736ALL;
    case 0x2A:
      unsigned int v4 = 1852797802;
      goto LABEL_43;
    case 0x2B:
      return 0x61646E61696C756ALL;
    case 0x2C:
      return 6775148;
    case 0x2E:
      unsigned int v4 = 1953718636;
LABEL_43:
      uint64_t result = v4 | 0x6C61765F00000000;
      break;
    case 0x2F:
      uint64_t result = 1684104556;
      break;
    case 0x30:
      uint64_t result = 0x6874676E656CLL;
      break;
    case 0x31:
      uint64_t result = 1701538156;
      break;
    case 0x32:
      uint64_t result = 0x6F68696C656B696CLL;
      break;
    case 0x33:
      uint64_t result = 0x796C656B696CLL;
      break;
    case 0x34:
      uint64_t result = 0x7265776F6CLL;
      break;
    case 0x35:
      uint64_t result = 0x6D6972746CLL;
      break;
    case 0x36:
      uint64_t result = 0x686374616DLL;
      break;
    case 0x37:
      uint64_t result = 0x666E69686374616DLL;
      break;
    case 0x38:
      uint64_t result = 7889261;
      break;
    case 0x39:
      uint64_t result = 7235949;
      break;
    case 0x3A:
      uint64_t result = 0x756C61765F68746ELL;
      break;
    case 0x3B:
      uint64_t result = 0x656C69746ELL;
      break;
    case 0x3C:
      uint64_t result = 0x66696C6C756ELL;
      break;
    case 0x3D:
      uint64_t result = 0x7374657366666FLL;
      break;
    case 0x3E:
      uint64_t result = 0x657A696D6974706FLL;
      break;
    case 0x3F:
      unsigned int v2 = 1668441456;
LABEL_61:
      uint64_t result = v2 | 0x5F746E6500000000;
      break;
    case 0x40:
      uint64_t result = 0x66746E697270;
      break;
    case 0x41:
      uint64_t result = 0x65746F7571;
      break;
    case 0x42:
      uint64_t result = 0x6D6F646E6172;
      break;
    case 0x43:
      uint64_t result = 0x6C626D6F646E6172;
      break;
    case 0x44:
      uint64_t result = 1802396018;
      break;
    case 0x45:
      uint64_t result = 0x6563616C706572;
      break;
    case 0x46:
      uint64_t result = 0x646E756F72;
      break;
    case 0x47:
      uint64_t result = 0x626D756E5F776F72;
      break;
    case 0x48:
      uint64_t result = 0x6568636565727472;
      break;
    case 0x49:
      uint64_t result = 0x7065646565727472;
      break;
    case 0x4A:
      uint64_t result = 0x646F6E6565727472;
      break;
    case 0x4B:
      uint64_t result = 0x6D69727472;
      break;
    case 0x4C:
      uint64_t result = 1852270963;
      break;
    case 0x4D:
      uint64_t result = 0x74657070696E73;
      break;
    case 0x4E:
      uint64_t result = 0xD000000000000018;
      break;
    case 0x4F:
      uint64_t result = 0xD000000000000019;
      break;
    case 0x50:
      uint64_t result = 0x6C5F6574696C7173;
      break;
    case 0x51:
      uint64_t result = 0xD000000000000010;
      break;
    case 0x52:
      uint64_t result = 0x765F6574696C7173;
      break;
    case 0x53:
      unsigned int v3 = 1718776947;
LABEL_84:
      uint64_t result = v3 | 0x656D697400000000;
      break;
    case 0x54:
      uint64_t result = 0x727473627573;
      break;
    case 0x55:
      uint64_t result = 0x6E69727473627573;
      break;
    case 0x56:
      uint64_t result = 1701669236;
      break;
    case 0x57:
      uint64_t result = 0x68635F6C61746F74;
      break;
    case 0x58:
      uint64_t result = 1835627124;
      break;
    case 0x59:
      uint64_t result = 0x666F65707974;
      break;
    case 0x5A:
      uint64_t result = 0x65646F63696E75;
      break;
    case 0x5B:
      uint64_t result = 0x6E776F6E6B6E75;
      break;
    case 0x5C:
      uint64_t result = 0x796C656B696C6E75;
      break;
    case 0x5D:
      uint64_t result = 0x7265707075;
      break;
    case 0x5E:
      uint64_t result = 1684632949;
      break;
    case 0x5F:
      uint64_t result = 0x6F6C625F64697575;
      break;
    case 0x60:
      uint64_t result = 0x7274735F64697575;
      break;
    case 0x61:
      uint64_t result = 0x626F6C626F72657ALL;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SQLFunction()
{
  return specialized == infix<A>(_:_:)();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLFunction()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLFunction()
{
  SQLFunction.rawValue.getter();
  String.hash(into:)();

  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLFunction()
{
  return Hasher._finalize()();
}

BiomeSQLParser::SQLFunction_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLFunction(Swift::String *a1)
{
  return SQLFunction.init(rawValue:)(*a1);
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance SQLFunction@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = SQLFunction.rawValue.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

void protocol witness for static CaseIterable.allCases.getter in conformance SQLFunction(void *a1@<X8>)
{
  *a1 = &outlined read-only object #0 of static SQLFunction.allCases.getter;
}

#error "18EA0E56C: too big function (funcsize=0)"

uint64_t specialized static Array<A>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  uint64_t v7 = (char *)&v34 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1F4188790](v8 - 8);
  uint64_t v10 = (char *)&v34 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v41 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  MEMORY[0x1F4188790](v41);
  uint64_t v12 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v13 = MEMORY[0x1F4188790](Node);
  uint64_t v15 = (char *)&v34 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  uint64_t v18 = (char *)&v34 - v17;
  uint64_t v43 = a1;
  uint64_t v19 = *(void *)(a1 + 16);
  if (v19 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (!v19 || v43 == a2) {
    return 1;
  }
  uint64_t v34 = v7;
  uint64_t v35 = a2;
  uint64_t v39 = v4;
  unint64_t v20 = (*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80);
  uint64_t v40 = *(void *)(v16 + 72);
  uint64_t v37 = (char *)&v34 - v17;
  uint64_t v38 = (uint64_t (**)(char *, uint64_t, uint64_t))(v5 + 48);
  uint64_t v36 = v15;
  while (1)
  {
    outlined init with copy of PgQuery_RawStmt(v43 + v20, (uint64_t)v18, type metadata accessor for PgQuery_Node);
    outlined init with copy of PgQuery_RawStmt(a2 + v20, (uint64_t)v15, type metadata accessor for PgQuery_Node);
    uint64_t v21 = *(int *)(Node + 20);
    uint64_t v22 = *(void *)&v18[v21];
    uint64_t v23 = *(void *)&v15[v21];
    if (v22 == v23) {
      goto LABEL_12;
    }
    uint64_t v24 = v23 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
    uint64_t v25 = (uint64_t)&v12[*(int *)(v41 + 48)];
    outlined init with copy of PgQuery_Alias?(v22 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v12, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined init with copy of PgQuery_Alias?(v24, v25, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    uint64_t v26 = *v38;
    uint64_t v27 = v12;
    uint64_t v28 = (uint64_t)v12;
    uint64_t v29 = v39;
    if ((*v38)(v27, 1, v39) == 1)
    {
      int v30 = v26((char *)v25, 1, v29);
      swift_retain();
      swift_retain();
      uint64_t v18 = v37;
      if (v30 != 1) {
        goto LABEL_16;
      }
      uint64_t v12 = (char *)v28;
      outlined destroy of AnyValue?(v28, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      uint64_t v15 = v36;
      goto LABEL_11;
    }
    outlined init with copy of PgQuery_Alias?(v28, (uint64_t)v10, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v26((char *)v25, 1, v29) == 1) {
      break;
    }
    uint64_t v31 = (uint64_t)v34;
    outlined init with take of PgQuery_Node(v25, (uint64_t)v34, type metadata accessor for PgQuery_Node.OneOf_Node);
    swift_retain();
    swift_retain();
    char v32 = static PgQuery_Node.OneOf_Node.== infix(_:_:)(v10, v31);
    outlined destroy of PgQuery_RawStmt(v31, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of PgQuery_RawStmt((uint64_t)v10, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of AnyValue?(v28, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    uint64_t v12 = (char *)v28;
    uint64_t v15 = v36;
    uint64_t v18 = v37;
    if ((v32 & 1) == 0) {
      goto LABEL_17;
    }
LABEL_11:
    swift_release();
    swift_release();
    a2 = v35;
LABEL_12:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, MEMORY[0x1E4F70E60]);
    if ((dispatch thunk of static Equatable.== infix(_:_:)() & 1) == 0) {
      goto LABEL_18;
    }
    outlined destroy of PgQuery_RawStmt((uint64_t)v15, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_RawStmt((uint64_t)v18, type metadata accessor for PgQuery_Node);
    v20 += v40;
    if (!--v19) {
      return 1;
    }
  }
  swift_retain();
  swift_retain();
  outlined destroy of PgQuery_RawStmt((uint64_t)v10, type metadata accessor for PgQuery_Node.OneOf_Node);
  uint64_t v18 = v37;
LABEL_16:
  outlined destroy of AnyValue?(v28, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  uint64_t v15 = v36;
LABEL_17:
  swift_release();
  swift_release();
LABEL_18:
  outlined destroy of PgQuery_RawStmt((uint64_t)v15, type metadata accessor for PgQuery_Node);
  outlined destroy of PgQuery_RawStmt((uint64_t)v18, type metadata accessor for PgQuery_Node);
  return 0;
}

{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t Node;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t RawStmt;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t (*v40)(uint64_t, uint64_t, uint64_t);
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t, uint64_t);
  uint64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  char v62;
  int v63;
  int v64;
  BOOL v65;
  char v66;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t (**v72)(uint64_t, uint64_t, uint64_t);
  char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t (**v77)(uint64_t, uint64_t, uint64_t);
  uint64_t v78;
  char *v79;
  char *v80;
  uint64_t v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;

  v90 = a2;
  v81 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  v89 = *(void *)(v81 - 8);
  MEMORY[0x1F4188790](v81);
  uint64_t v4 = (char *)&v70 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1F4188790](v5 - 8);
  uint64_t v7 = (char *)&v70 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  MEMORY[0x1F4188790](v8);
  uint64_t v10 = (char *)&v70 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  v88 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node);
  uint64_t v13 = (char *)&v70 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1F4188790](v14 - 8);
  uint64_t v16 = (char *)&v70 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?));
  MEMORY[0x1F4188790](v17);
  uint64_t v19 = (char *)&v70 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  RawStmt = type metadata accessor for PgQuery_RawStmt(0);
  uint64_t v21 = MEMORY[0x1F4188790](RawStmt);
  uint64_t v22 = MEMORY[0x1F4188790](v21);
  uint64_t v27 = *(void *)(a1 + 16);
  if (v27 != *(void *)(v26 + 16)) {
    return 0;
  }
  v87 = v17;
  v85 = (char *)&v70 - v24;
  v82 = v16;
  v83 = Node;
  v78 = v25;
  v79 = v10;
  v73 = v4;
  v74 = v8;
  v80 = v13;
  if (!v27 || a1 == v26) {
    return 1;
  }
  uint64_t v28 = (uint64_t)v19;
  uint64_t v29 = v26;
  v86 = v22;
  int v30 = (*(unsigned __int8 *)(v23 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v23 + 80);
  v76 = v28;
  v77 = (uint64_t (**)(uint64_t, uint64_t, uint64_t))(v88 + 48);
  v71 = v7;
  v72 = (uint64_t (**)(uint64_t, uint64_t, uint64_t))(v89 + 48);
  v84 = *(void *)(v23 + 72);
  uint64_t v31 = v28;
  char v32 = v78;
  uint64_t v33 = (uint64_t)v85;
  uint64_t v34 = v87;
  v75 = a1;
  while (1)
  {
    v89 = v27;
    outlined init with copy of PgQuery_RawStmt(a1 + v30, v33, type metadata accessor for PgQuery_RawStmt);
    outlined init with copy of PgQuery_RawStmt(v29 + v30, v32, type metadata accessor for PgQuery_RawStmt);
    uint64_t v35 = *(int *)(v86 + 20);
    uint64_t v36 = *(void *)(v33 + v35);
    uint64_t v37 = *(void *)(v32 + v35);
    if (v36 == v37) {
      goto LABEL_22;
    }
    uint64_t v38 = v37
        + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt;
    uint64_t v39 = v31 + *(int *)(v34 + 48);
    outlined init with copy of PgQuery_Alias?(v36 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt, v31, &demangling cache variable for type metadata for PgQuery_Node?);
    outlined init with copy of PgQuery_Alias?(v38, v39, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v40 = *v77;
    uint64_t v41 = v83;
    uint64_t v42 = (*v77)(v31, 1, v83);
    v88 = v37;
    if (v42 == 1)
    {
      uint64_t v43 = v40(v39, 1, v41);
      swift_retain();
      swift_retain();
      uint64_t v44 = v36;
      if (v43 != 1)
      {
        uint64_t v33 = (uint64_t)v85;
        v68 = &demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?);
        uint64_t v31 = v76;
        goto LABEL_31;
      }
      uint64_t v31 = v76;
      outlined destroy of AnyValue?(v76, &demangling cache variable for type metadata for PgQuery_Node?);
      uint64_t v33 = (uint64_t)v85;
      goto LABEL_19;
    }
    uint64_t v45 = (uint64_t)v82;
    outlined init with copy of PgQuery_Alias?(v31, (uint64_t)v82, &demangling cache variable for type metadata for PgQuery_Node?);
    if (v40(v39, 1, v41) == 1)
    {
      swift_retain();
      swift_retain();
      v68 = &demangling cache variable for type metadata for (PgQuery_Node?, PgQuery_Node?);
      v69 = v45;
      char v32 = v78;
      uint64_t v33 = (uint64_t)v85;
      uint64_t v31 = v76;
      goto LABEL_30;
    }
    uint64_t v46 = (uint64_t)v80;
    outlined init with take of PgQuery_Node(v39, (uint64_t)v80, type metadata accessor for PgQuery_Node);
    uint64_t v47 = *(int *)(v41 + 20);
    uint64_t v48 = *(void *)(v45 + v47);
    v49 = *(void *)(v46 + v47);
    uint64_t v44 = v36;
    if (v48 == v49)
    {
      swift_retain();
      swift_retain();
      uint64_t v33 = (uint64_t)v85;
      uint64_t v31 = v76;
      goto LABEL_18;
    }
    v50 = v49 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
    v51 = (uint64_t)v79;
    v52 = (uint64_t)&v79[*(int *)(v74 + 48)];
    outlined init with copy of PgQuery_Alias?(v48 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v79, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined init with copy of PgQuery_Alias?(v50, v52, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v53 = *v72;
    v54 = v81;
    v55 = (*v72)(v51, 1, v81);
    uint64_t v33 = (uint64_t)v85;
    uint64_t v31 = v76;
    if (v55 == 1)
    {
      v56 = v53(v52, 1, v54);
      swift_retain();
      swift_retain();
      swift_retain();
      swift_retain();
      v57 = (uint64_t)v79;
      if (v56 != 1) {
        goto LABEL_28;
      }
      outlined destroy of AnyValue?((uint64_t)v79, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      goto LABEL_17;
    }
    outlined init with copy of PgQuery_Alias?((uint64_t)v79, (uint64_t)v71, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (v53(v52, 1, v54) == 1) {
      break;
    }
    v58 = (uint64_t)v73;
    outlined init with take of PgQuery_Node(v52, (uint64_t)v73, type metadata accessor for PgQuery_Node.OneOf_Node);
    swift_retain();
    swift_retain();
    swift_retain();
    swift_retain();
    v59 = (uint64_t)v71;
    v60 = static PgQuery_Node.OneOf_Node.== infix(_:_:)(v71, v58);
    outlined destroy of PgQuery_RawStmt(v58, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of PgQuery_RawStmt(v59, type metadata accessor for PgQuery_Node.OneOf_Node);
    outlined destroy of AnyValue?((uint64_t)v79, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if ((v60 & 1) == 0) {
      goto LABEL_29;
    }
LABEL_17:
    swift_release();
    swift_release();
    uint64_t v46 = (uint64_t)v80;
LABEL_18:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, MEMORY[0x1E4F70E60]);
    v61 = (uint64_t)v82;
    v62 = dispatch thunk of static Equatable.== infix(_:_:)();
    outlined destroy of PgQuery_RawStmt(v46, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_RawStmt(v61, type metadata accessor for PgQuery_Node);
    outlined destroy of AnyValue?(v31, &demangling cache variable for type metadata for PgQuery_Node?);
    char v32 = v78;
    if ((v62 & 1) == 0) {
      goto LABEL_32;
    }
LABEL_19:
    if (*(_DWORD *)(v44
                   + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation) != *(_DWORD *)(v88 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation))
      goto LABEL_32;
    v63 = *(_DWORD *)(v44
                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
    v64 = *(_DWORD *)(v88
                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLen);
    swift_release();
    swift_release();
    v65 = v63 == v64;
    a1 = v75;
    if (!v65) {
      goto LABEL_33;
    }
LABEL_22:
    type metadata accessor for UnknownStorage();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, MEMORY[0x1E4F70E60]);
    v66 = dispatch thunk of static Equatable.== infix(_:_:)();
    uint64_t v34 = v87;
    if ((v66 & 1) == 0) {
      goto LABEL_33;
    }
    outlined destroy of PgQuery_RawStmt(v32, type metadata accessor for PgQuery_RawStmt);
    outlined destroy of PgQuery_RawStmt(v33, type metadata accessor for PgQuery_RawStmt);
    v30 += v84;
    uint64_t v29 = v90;
    uint64_t v27 = v89 - 1;
    if (v89 == 1) {
      return 1;
    }
  }
  swift_retain();
  swift_retain();
  swift_retain();
  swift_retain();
  outlined destroy of PgQuery_RawStmt((uint64_t)v71, type metadata accessor for PgQuery_Node.OneOf_Node);
  v57 = (uint64_t)v79;
LABEL_28:
  outlined destroy of AnyValue?(v57, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
LABEL_29:
  swift_release();
  swift_release();
  outlined destroy of PgQuery_RawStmt((uint64_t)v80, type metadata accessor for PgQuery_Node);
  v68 = &demangling cache variable for type metadata for PgQuery_Node?;
  v69 = (uint64_t)v82;
  char v32 = v78;
LABEL_30:
  outlined destroy of PgQuery_RawStmt(v69, type metadata accessor for PgQuery_Node);
LABEL_31:
  outlined destroy of AnyValue?(v31, v68);
LABEL_32:
  swift_release();
  swift_release();
LABEL_33:
  outlined destroy of PgQuery_RawStmt(v32, type metadata accessor for PgQuery_RawStmt);
  outlined destroy of PgQuery_RawStmt(v33, type metadata accessor for PgQuery_RawStmt);
  return 0;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned char v12[200];
  unsigned char v13[200];
  unsigned char v14[200];
  unsigned char v15[200];

  unsigned int v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16))
  {
    if (!v2 || a1 == a2) {
      return 1;
    }
    uint64_t v3 = a1 + 32;
    uint64_t v4 = a2 + 32;
    while (2)
    {
      outlined init with copy of AggregationFunction(v3, (uint64_t)v15);
      outlined init with copy of AggregationFunction(v4, (uint64_t)v14);
      uint64_t v6 = specialized static AggregationFunction.AggregationType.== infix(_:_:)(v15, v14);
      outlined init with copy of AggregationFunction((uint64_t)v15, (uint64_t)v13);
      outlined init with copy of AggregationFunction((uint64_t)v14, (uint64_t)v12);
      if (v6)
      {
        uint64_t v7 = 0xE700000000000000;
        uint64_t v8 = 0x72656765746E69;
        switch(v13[193])
        {
          case 1:
            uint64_t v7 = 0xE600000000000000;
            uint64_t v8 = 0x656C62756F64;
            break;
          case 2:
            uint64_t v7 = 0xE600000000000000;
            uint64_t v8 = 0x676E69727473;
            break;
          case 3:
            uint64_t v7 = 0xE400000000000000;
            uint64_t v8 = 1702125924;
            break;
          case 4:
            uint64_t v7 = 0xE400000000000000;
            uint64_t v8 = 1635017060;
            break;
          case 5:
            uint64_t v7 = 0xE400000000000000;
            uint64_t v8 = 1852797802;
            break;
          case 6:
            uint64_t v7 = 0xE400000000000000;
            uint64_t v8 = 1684632949;
            break;
          case 7:
            uint64_t v7 = 0xE400000000000000;
            uint64_t v8 = 1819047278;
            break;
          default:
            break;
        }
        uint64_t v9 = 0xE700000000000000;
        uint64_t v10 = 0x72656765746E69;
        switch(v12[193])
        {
          case 1:
            uint64_t v9 = 0xE600000000000000;
            if (v8 == 0x656C62756F64) {
              goto LABEL_29;
            }
            goto LABEL_5;
          case 2:
            uint64_t v9 = 0xE600000000000000;
            if (v8 != 0x676E69727473) {
              goto LABEL_5;
            }
            goto LABEL_29;
          case 3:
            uint64_t v9 = 0xE400000000000000;
            if (v8 != 1702125924) {
              goto LABEL_5;
            }
            goto LABEL_29;
          case 4:
            uint64_t v9 = 0xE400000000000000;
            if (v8 != 1635017060) {
              goto LABEL_5;
            }
            goto LABEL_29;
          case 5:
            uint64_t v9 = 0xE400000000000000;
            uint64_t v10 = 1852797802;
            goto LABEL_28;
          case 6:
            uint64_t v9 = 0xE400000000000000;
            if (v8 != 1684632949) {
              goto LABEL_5;
            }
            goto LABEL_29;
          case 7:
            uint64_t v9 = 0xE400000000000000;
            if (v8 != 1819047278) {
              goto LABEL_5;
            }
            goto LABEL_29;
          default:
LABEL_28:
            if (v8 != v10) {
              goto LABEL_5;
            }
LABEL_29:
            if (v7 == v9)
            {
              swift_bridgeObjectRelease_n();
              outlined destroy of AggregationFunction((uint64_t)v12);
              outlined destroy of AggregationFunction((uint64_t)v13);
              outlined destroy of AggregationFunction((uint64_t)v14);
              outlined destroy of AggregationFunction((uint64_t)v15);
            }
            else
            {
LABEL_5:
              uint64_t v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
              swift_bridgeObjectRelease();
              swift_bridgeObjectRelease();
              outlined destroy of AggregationFunction((uint64_t)v12);
              outlined destroy of AggregationFunction((uint64_t)v13);
              outlined destroy of AggregationFunction((uint64_t)v14);
              outlined destroy of AggregationFunction((uint64_t)v15);
              if ((v5 & 1) == 0) {
                return 0;
              }
            }
            v4 += 200;
            v3 += 200;
            if (--v2) {
              continue;
            }
            return 1;
        }
      }
      break;
    }
    outlined destroy of AggregationFunction((uint64_t)v12);
    outlined destroy of AggregationFunction((uint64_t)v13);
    outlined destroy of AggregationFunction((uint64_t)v14);
    outlined destroy of AggregationFunction((uint64_t)v15);
  }
  return 0;
}

{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  unsigned int v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (v2 && a1 != a2)
  {
    uint64_t v3 = (unsigned __int8 *)(a2 + 48);
    uint64_t v4 = (unsigned __int8 *)(a1 + 48);
    while (1)
    {
      uint64_t v6 = *v4;
      uint64_t v7 = *v3;
      uint64_t v8 = *((void *)v4 - 2) == *((void *)v3 - 2) && *((void *)v4 - 1) == *((void *)v3 - 1);
      if (!v8 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
        return 0;
      }
      v3 += 24;
      v4 += 24;
      uint64_t v9 = 0xE700000000000000;
      uint64_t v10 = 0x72656765746E69;
      switch(v6)
      {
        case 1:
          uint64_t v9 = 0xE600000000000000;
          uint64_t v10 = 0x656C62756F64;
          break;
        case 2:
          uint64_t v9 = 0xE600000000000000;
          uint64_t v10 = 0x676E69727473;
          break;
        case 3:
          uint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1702125924;
          break;
        case 4:
          uint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1635017060;
          break;
        case 5:
          uint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1852797802;
          break;
        case 6:
          uint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1684632949;
          break;
        case 7:
          uint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1819047278;
          break;
        default:
          break;
      }
      uint64_t v11 = 0xE700000000000000;
      uint64_t v12 = 0x72656765746E69;
      switch(v7)
      {
        case 1:
          uint64_t v11 = 0xE600000000000000;
          if (v10 == 0x656C62756F64) {
            goto LABEL_33;
          }
          goto LABEL_5;
        case 2:
          uint64_t v11 = 0xE600000000000000;
          if (v10 != 0x676E69727473) {
            goto LABEL_5;
          }
          goto LABEL_33;
        case 3:
          uint64_t v11 = 0xE400000000000000;
          if (v10 != 1702125924) {
            goto LABEL_5;
          }
          goto LABEL_33;
        case 4:
          uint64_t v11 = 0xE400000000000000;
          if (v10 != 1635017060) {
            goto LABEL_5;
          }
          goto LABEL_33;
        case 5:
          uint64_t v11 = 0xE400000000000000;
          if (v10 != 1852797802) {
            goto LABEL_5;
          }
          goto LABEL_33;
        case 6:
          uint64_t v11 = 0xE400000000000000;
          uint64_t v12 = 1684632949;
          goto LABEL_32;
        case 7:
          uint64_t v11 = 0xE400000000000000;
          if (v10 != 1819047278) {
            goto LABEL_5;
          }
          goto LABEL_33;
        default:
LABEL_32:
          if (v10 != v12) {
            goto LABEL_5;
          }
LABEL_33:
          if (v9 == v11)
          {
            swift_bridgeObjectRelease_n();
            if (!--v2) {
              return 1;
            }
          }
          else
          {
LABEL_5:
            uint64_t v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            if ((v5 & 1) == 0) {
              return 0;
            }
            if (!--v2) {
              return 1;
            }
          }
          break;
      }
    }
  }
  return 1;
}

{
  uint64_t ScanToken;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  uint64_t v5 = MEMORY[0x1F4188790](ScanToken);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v5);
  uint64_t v10 = (char *)&v19 - v9;
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (v11 && a1 != a2)
  {
    uint64_t v12 = (*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);
    unint64_t v20 = *(void *)(v8 + 72);
    while (1)
    {
      outlined init with copy of PgQuery_RawStmt(a1 + v12, (uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
      outlined init with copy of PgQuery_RawStmt(a2 + v12, (uint64_t)v7, type metadata accessor for PgQuery_ScanToken);
      if (*(_DWORD *)v10 != *(_DWORD *)v7) {
        break;
      }
      if (*((_DWORD *)v10 + 1) != *((_DWORD *)v7 + 1)) {
        break;
      }
      uint64_t v13 = *((void *)v7 + 1);
      uint64_t v14 = v7[16];
      uint64_t v15 = PgQuery_Token.rawValue.getter(*((void *)v10 + 1), v10[16]);
      if (v15 != PgQuery_Token.rawValue.getter(v13, v14)) {
        break;
      }
      uint64_t v16 = *((void *)v10 + 3);
      uint64_t v17 = *((void *)v7 + 3);
      if (v7[32] == 1)
      {
        switch(v17)
        {
          case 1:
            if (v16 != 1) {
              goto LABEL_23;
            }
            goto LABEL_13;
          case 2:
            if (v16 != 2) {
              goto LABEL_23;
            }
            goto LABEL_13;
          case 3:
            if (v16 != 3) {
              goto LABEL_23;
            }
            goto LABEL_13;
          case 4:
            if (v16 != 4) {
              goto LABEL_23;
            }
            goto LABEL_13;
          default:
            if (v16) {
              goto LABEL_23;
            }
            goto LABEL_13;
        }
      }
      if (v16 != v17) {
        break;
      }
LABEL_13:
      type metadata accessor for UnknownStorage();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError(&lazy protocol witness table cache variable for type UnknownStorage and conformance UnknownStorage, MEMORY[0x1E4F70E60]);
      if ((dispatch thunk of static Equatable.== infix(_:_:)() & 1) == 0) {
        break;
      }
      outlined destroy of PgQuery_RawStmt((uint64_t)v7, type metadata accessor for PgQuery_ScanToken);
      outlined destroy of PgQuery_RawStmt((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
      v12 += v20;
      if (!--v11) {
        return 1;
      }
    }
LABEL_23:
    outlined destroy of PgQuery_RawStmt((uint64_t)v7, type metadata accessor for PgQuery_ScanToken);
    outlined destroy of PgQuery_RawStmt((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
    return 0;
  }
  return 1;
}

{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  char v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  unsigned int v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (v2 && a1 != a2)
  {
    uint64_t v3 = (unsigned __int8 *)(a1 + 32);
    uint64_t v4 = (unsigned __int8 *)(a2 + 32);
    while (1)
    {
      uint64_t v7 = *v3++;
      uint64_t v6 = v7;
      uint64_t v9 = *v4++;
      uint64_t v8 = v9;
      uint64_t v10 = 0xE700000000000000;
      uint64_t v11 = 0x72656765746E69;
      switch(v6)
      {
        case 1:
          uint64_t v10 = 0xE600000000000000;
          uint64_t v11 = 0x656C62756F64;
          break;
        case 2:
          uint64_t v10 = 0xE600000000000000;
          uint64_t v11 = 0x676E69727473;
          break;
        case 3:
          uint64_t v10 = 0xE400000000000000;
          uint64_t v11 = 1702125924;
          break;
        case 4:
          uint64_t v10 = 0xE400000000000000;
          uint64_t v11 = 1635017060;
          break;
        case 5:
          uint64_t v10 = 0xE400000000000000;
          uint64_t v11 = 1852797802;
          break;
        case 6:
          uint64_t v10 = 0xE400000000000000;
          uint64_t v11 = 1684632949;
          break;
        case 7:
          uint64_t v10 = 0xE400000000000000;
          uint64_t v11 = 1819047278;
          break;
        default:
          break;
      }
      uint64_t v12 = 0xE700000000000000;
      uint64_t v13 = 0x72656765746E69;
      switch(v8)
      {
        case 1:
          uint64_t v12 = 0xE600000000000000;
          if (v11 == 0x656C62756F64) {
            goto LABEL_28;
          }
          goto LABEL_5;
        case 2:
          uint64_t v12 = 0xE600000000000000;
          if (v11 != 0x676E69727473) {
            goto LABEL_5;
          }
          goto LABEL_28;
        case 3:
          uint64_t v12 = 0xE400000000000000;
          if (v11 != 1702125924) {
            goto LABEL_5;
          }
          goto LABEL_28;
        case 4:
          uint64_t v12 = 0xE400000000000000;
          if (v11 != 1635017060) {
            goto LABEL_5;
          }
          goto LABEL_28;
        case 5:
          uint64_t v12 = 0xE400000000000000;
          if (v11 != 1852797802) {
            goto LABEL_5;
          }
          goto LABEL_28;
        case 6:
          uint64_t v12 = 0xE400000000000000;
          uint64_t v13 = 1684632949;
          goto LABEL_27;
        case 7:
          uint64_t v12 = 0xE400000000000000;
          if (v11 != 1819047278) {
            goto LABEL_5;
          }
          goto LABEL_28;
        default:
LABEL_27:
          if (v11 != v13) {
            goto LABEL_5;
          }
LABEL_28:
          if (v10 == v12)
          {
            swift_bridgeObjectRelease_n();
            if (!--v2) {
              return 1;
            }
          }
          else
          {
LABEL_5:
            uint64_t v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            if ((v5 & 1) == 0) {
              return 0;
            }
            if (!--v2) {
              return 1;
            }
          }
          break;
      }
    }
  }
  return 1;
}

BOOL specialized static Array<A>.== infix(_:_:)(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  if (v2 != a2[2]) {
    return 0;
  }
  if (!v2 || a1 == a2) {
    return 1;
  }
  if (a1[4] != a2[4]) {
    return 0;
  }
  uint64_t v3 = a1 + 5;
  uint64_t v4 = a2 + 5;
  uint64_t v5 = v2 - 1;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    uint64_t v8 = *v3++;
    uint64_t v7 = v8;
    uint64_t v9 = *v4++;
    --v5;
  }
  while (v7 == v9);
  return result;
}

uint64_t specialized static Array._allocateUninitialized(_:)(uint64_t result)
{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  uint64_t v1;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    uint64_t v1 = result;
    if (result)
    {
      __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [AggregationFunction]);
      BOOL result = static Array._allocateBufferUninitialized(minimumCapacity:)();
      *(void *)(result + 16) = v1;
    }
    else
    {
      return MEMORY[0x1E4FBC860];
    }
  }
  return result;
}

{
  return specialized static Array._allocateUninitialized(_:)(result);
}

{
  uint64_t v1;

  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    uint64_t v1 = result;
    if (result)
    {
      BOOL result = static Array._allocateBufferUninitialized(minimumCapacity:)();
      *(void *)(result + 16) = v1;
    }
    else
    {
      return MEMORY[0x1E4FBC860];
    }
  }
  return result;
}

uint64_t specialized static Array._adoptStorage(_:count:)(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = 2 * a2;
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLFunction and conformance SQLFunction()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction;
  if (!lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLFunction and conformance SQLFunction);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type [SQLFunction] and conformance [A]()
{
  unint64_t result = lazy protocol witness table cache variable for type [SQLFunction] and conformance [A];
  if (!lazy protocol witness table cache variable for type [SQLFunction] and conformance [A])
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for [SQLFunction]);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type [SQLFunction] and conformance [A]);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for SQLFunction(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0x9F) {
    goto LABEL_17;
  }
  if (a2 + 97 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 97) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 97;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 97;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 97;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x62;
  int v8 = v6 - 98;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for SQLFunction(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 97 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 97) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0x9F) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0x9E)
  {
    unsigned int v6 = ((a2 - 159) >> 8) + 1;
    *unint64_t result = a2 + 97;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA44F18);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 97;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for SQLFunction()
{
  return &type metadata for SQLFunction;
}

uint64_t lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t outlined init with take of PgQuery_Node(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t outlined init with copy of PgQuery_RawStmt(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t outlined destroy of PgQuery_RawStmt(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t outlined init with copy of AggregationFunction(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t outlined destroy of AggregationFunction(uint64_t a1)
{
  return a1;
}

uint64_t specialized RawRepresentable<>.hash(into:)()
{
  String.hash(into:)();

  return swift_bridgeObjectRelease();
}

uint64_t SQLExpression.init(expressionNode:schemas:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v9 = specialized ColumnResolver.init(schemas:)(a2);
  if (v4)
  {
    swift_bridgeObjectRelease();
    outlined destroy of SQLExpressionError(a3, type metadata accessor for SQLTokenInformation);
    return outlined destroy of SQLExpressionError(a1, type metadata accessor for PgQuery_Node);
  }
  else
  {
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(a1, a2, v9, v10, a3, v13);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined init with copy of Aggregation((uint64_t)v13, (uint64_t)v12);
    SQLExpression.init(rootNode:)((uint64_t)v12, a4);
    outlined destroy of SQLExpressionError(a3, type metadata accessor for SQLTokenInformation);
    outlined destroy of SQLExpressionError(a1, type metadata accessor for PgQuery_Node);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v13);
  }
}

uint64_t buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v259 = a5;
  uint64_t v260 = a3;
  uint64_t v261 = a4;
  uint64_t v258 = a2;
  uint64_t v275 = a1;
  v263 = a6;
  uint64_t BitString = type metadata accessor for PgQuery_BitString(0);
  MEMORY[0x1F4188790](BitString - 8);
  v255 = (uint64_t *)((char *)&v234 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t Float = type metadata accessor for PgQuery_Float(0);
  MEMORY[0x1F4188790](Float - 8);
  v254 = (uint64_t *)((char *)&v234 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t Integer = type metadata accessor for PgQuery_Integer(0);
  MEMORY[0x1F4188790](Integer - 8);
  v252 = (int *)((char *)&v234 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t String = type metadata accessor for PgQuery_String(0);
  uint64_t v12 = MEMORY[0x1F4188790](String);
  v253 = (uint64_t *)((char *)&v234 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v12);
  v262 = (char *)&v234 - v14;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v235 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node);
  uint64_t v272 = (uint64_t)&v234 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for Locale?);
  MEMORY[0x1F4188790](v17 - 8);
  v236 = (char *)&v234 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ColumnRef = type metadata accessor for PgQuery_ColumnRef(0);
  uint64_t v20 = MEMORY[0x1F4188790](ColumnRef - 8);
  uint64_t v257 = (uint64_t)&v234 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  uint64_t v256 = (uint64_t)&v234 - v22;
  uint64_t v23 = type metadata accessor for PgQuery_FuncCall(0);
  uint64_t v24 = MEMORY[0x1F4188790](v23 - 8);
  uint64_t v250 = (uint64_t)&v234 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v24);
  uint64_t v251 = (uint64_t)&v234 - v26;
  uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
  uint64_t v28 = MEMORY[0x1F4188790](NullTest - 8);
  uint64_t v241 = (uint64_t)&v234 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v28);
  uint64_t v242 = (uint64_t)&v234 - v30;
  uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
  uint64_t v32 = MEMORY[0x1F4188790](BoolExpr - 8);
  uint64_t v239 = (uint64_t)&v234 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v32);
  uint64_t v240 = (uint64_t)&v234 - v34;
  uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
  uint64_t v36 = MEMORY[0x1F4188790](A_Expr - 8);
  uint64_t v248 = (uint64_t)&v234 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v36);
  uint64_t v249 = (uint64_t)&v234 - v38;
  uint64_t v39 = type metadata accessor for SQLTokenInformation(0);
  uint64_t v40 = MEMORY[0x1F4188790](v39 - 8);
  uint64_t v264 = (uint64_t)&v234 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v247 = (uint64_t)&v234 - v43;
  uint64_t v44 = MEMORY[0x1F4188790](v42);
  uint64_t v238 = (uint64_t)&v234 - v45;
  uint64_t v46 = MEMORY[0x1F4188790](v44);
  uint64_t v237 = (uint64_t)&v234 - v47;
  uint64_t v48 = MEMORY[0x1F4188790](v46);
  uint64_t v246 = (uint64_t)&v234 - v49;
  MEMORY[0x1F4188790](v48);
  uint64_t v245 = (uint64_t)&v234 - v50;
  uint64_t A_Const = type metadata accessor for PgQuery_A_Const(0);
  uint64_t v52 = MEMORY[0x1F4188790](A_Const - 8);
  uint64_t v243 = (uint64_t)&v234 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v52);
  uint64_t v244 = (uint64_t)&v234 - v54;
  uint64_t v55 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  uint64_t v56 = *(void *)(v55 - 8);
  MEMORY[0x1F4188790](v55);
  v58 = (char *)&v234 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v59 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
  uint64_t v60 = v59 - 8;
  MEMORY[0x1F4188790](v59);
  v62 = (char *)&v234 - ((v61 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v63 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v64 = MEMORY[0x1F4188790](v63 - 8);
  uint64_t v267 = (uint64_t)&v234 - ((v65 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v66 = MEMORY[0x1F4188790](v64);
  unint64_t v265 = (unint64_t)&v234 - v67;
  uint64_t v68 = MEMORY[0x1F4188790](v66);
  uint64_t v270 = (uint64_t)&v234 - v69;
  uint64_t v70 = MEMORY[0x1F4188790](v68);
  v72 = (char *)&v234 - v71;
  MEMORY[0x1F4188790](v70);
  v74 = (char *)&v234 - v73;
  v75 = (char *)*(int *)(Node + 20);
  uint64_t v268 = Node;
  v269 = v75;
  uint64_t v76 = *(void *)&v75[v275]
      + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v56 + 56))((char *)&v234 - v73, 1, 1, v55);
  uint64_t v77 = (uint64_t)&v62[*(int *)(v60 + 56)];
  uint64_t v78 = v76;
  uint64_t v79 = v55;
  outlined init with copy of PgQuery_Alias?(v78, (uint64_t)v62, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined init with copy of PgQuery_Alias?((uint64_t)v74, v77, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v82 = *(char **)(v56 + 48);
  uint64_t v81 = v56 + 48;
  v80 = v82;
  if (((unsigned int (*)(char *, uint64_t, uint64_t))v82)(v62, 1, v79) == 1)
  {
    outlined destroy of AnyValue?((uint64_t)v74, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))v80)(v77, 1, v79) == 1)
    {
      outlined destroy of AnyValue?((uint64_t)v62, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_13:
      type metadata accessor for SQLExpressionError();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
      swift_allocError();
      swift_storeEnumTagMultiPayload();
      return swift_willThrow();
    }
    goto LABEL_6;
  }
  outlined init with copy of PgQuery_Alias?((uint64_t)v62, (uint64_t)v72, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))v80)(v77, 1, v79) == 1)
  {
    outlined destroy of AnyValue?((uint64_t)v74, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of SQLExpressionError((uint64_t)v72, type metadata accessor for PgQuery_Node.OneOf_Node);
LABEL_6:
    outlined destroy of AnyValue?((uint64_t)v62, &demangling cache variable for type metadata for (PgQuery_Node.OneOf_Node?, PgQuery_Node.OneOf_Node?));
    goto LABEL_7;
  }
  outlined init with take of PgQuery_BitString(v77, (uint64_t)v58, type metadata accessor for PgQuery_Node.OneOf_Node);
  char v100 = specialized static PgQuery_Node.OneOf_Node.== infix(_:_:)((uint64_t)v72, (uint64_t)v58);
  outlined destroy of SQLExpressionError((uint64_t)v58, type metadata accessor for PgQuery_Node.OneOf_Node);
  outlined destroy of AnyValue?((uint64_t)v74, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of SQLExpressionError((uint64_t)v72, type metadata accessor for PgQuery_Node.OneOf_Node);
  outlined destroy of AnyValue?((uint64_t)v62, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (v100) {
    goto LABEL_13;
  }
LABEL_7:
  uint64_t v83 = v275;
  uint64_t v84 = v270;
  outlined init with copy of PgQuery_Alias?(*(void *)&v269[v275]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v270, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))v80)(v84, 1, v79) != 1)
  {
    uint64_t v86 = v265;
    outlined init with copy of PgQuery_Alias?(v84, v265, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
    switch(EnumCaseMultiPayload)
    {
      case 166:
        uint64_t v88 = v249;
        outlined init with take of PgQuery_BitString(v86, v249, type metadata accessor for PgQuery_A_Expr);
        uint64_t v89 = v248;
        outlined init with copy of PgQuery_Node(v88, v248, type metadata accessor for PgQuery_A_Expr);
        uint64_t v90 = v246;
        outlined init with copy of PgQuery_Node(v259, v246, type metadata accessor for SQLTokenInformation);
        v91 = v263;
        v263[3] = (uint64_t)&unk_1EDD71DA8;
        v91[4] = (uint64_t)&protocol witness table for SQLExpressionAExpr;
        uint64_t v92 = swift_allocObject();
        v93 = (void *)(v92 + 16);
        uint64_t *v91 = v92;
        uint64_t v94 = v258;
        swift_bridgeObjectRetain();
        uint64_t v95 = v260;
        swift_bridgeObjectRetain();
        uint64_t v96 = v261;
        swift_bridgeObjectRetain();
        v97 = v93;
        uint64_t v98 = v271;
        SQLExpressionAExpr.init(expr:schemas:columnResolver:tokenInformation:)(v89, v94, v95, v96, v90, v97);
        if (v98)
        {
          v99 = type metadata accessor for PgQuery_A_Expr;
          goto LABEL_36;
        }
        v187 = type metadata accessor for PgQuery_A_Expr;
        goto LABEL_66;
      case 167:
        uint64_t v115 = v256;
        outlined init with take of PgQuery_BitString(v86, v256, type metadata accessor for PgQuery_ColumnRef);
        uint64_t v116 = v257;
        outlined init with copy of PgQuery_Node(v115, v257, type metadata accessor for PgQuery_ColumnRef);
        outlined init with copy of PgQuery_Node(v259, v264, type metadata accessor for SQLTokenInformation);
        v117 = v263;
        v263[3] = (uint64_t)&unk_1EDD74940;
        v117[4] = (uint64_t)&protocol witness table for SQLExpressionColumnRef;
        uint64_t v258 = swift_allocObject();
        uint64_t *v117 = v258;
        uint64_t v118 = *(void *)v116;
        uint64_t v119 = *(void *)(*(void *)v116 + 16);
        if (v119)
        {
          v269 = v80;
          uint64_t v275 = v81;
          v274._uint64_t countAndFlagsBits = MEMORY[0x1E4FBC860];
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v120 = *(unsigned __int8 *)(v235 + 80);
          uint64_t v259 = v118;
          uint64_t v121 = v118 + ((v120 + 32) & ~v120);
          unint64_t v265 = *(void *)(v235 + 72);
          v122 = (uint64_t *)v262;
          uint64_t v123 = v79;
          while (1)
          {
            uint64_t v124 = v272;
            outlined init with copy of PgQuery_Node(v121, v272, type metadata accessor for PgQuery_Node);
            uint64_t v125 = *(void *)(v124 + *(int *)(v268 + 20))
                 + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
            uint64_t v126 = v267;
            outlined init with copy of PgQuery_Alias?(v125, v267, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
            if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))v269)(v126, 1, v79) == 1) {
              break;
            }
            if (swift_getEnumCaseMultiPayload() != 222)
            {
              outlined destroy of SQLExpressionError(v126, type metadata accessor for PgQuery_Node.OneOf_Node);
              goto LABEL_25;
            }
            outlined init with take of PgQuery_BitString(v126, (uint64_t)v122, type metadata accessor for PgQuery_String);
LABEL_26:
            uint64_t v128 = *v122;
            uint64_t v127 = v122[1];
            swift_bridgeObjectRetain();
            outlined destroy of SQLExpressionError((uint64_t)v122, type metadata accessor for PgQuery_String);
            outlined destroy of SQLExpressionError(v272, type metadata accessor for PgQuery_Node);
            uint64_t countAndFlagsBits = v274._countAndFlagsBits;
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              v122 = (uint64_t *)v262;
              uint64_t countAndFlagsBits = v274._countAndFlagsBits;
            }
            unint64_t v130 = *(void *)(countAndFlagsBits + 16);
            if (v130 >= *(void *)(countAndFlagsBits + 24) >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              v122 = (uint64_t *)v262;
              uint64_t countAndFlagsBits = v274._countAndFlagsBits;
            }
            *(void *)(countAndFlagsBits + 16) = v130 + 1;
            uint64_t v131 = countAndFlagsBits + 16 * v130;
            *(void *)(v131 + 32) = v128;
            *(void *)(v131 + 40) = v127;
            v121 += v265;
            --v119;
            uint64_t v79 = v123;
            if (!v119)
            {
              swift_bridgeObjectRelease();
              goto LABEL_50;
            }
          }
          outlined destroy of AnyValue?(v126, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_25:
          uint64_t *v122 = 0;
          v122[1] = 0xE000000000000000;
          UnknownStorage.init()();
          goto LABEL_26;
        }
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        uint64_t countAndFlagsBits = MEMORY[0x1E4FBC860];
LABEL_50:
        v274._uint64_t countAndFlagsBits = countAndFlagsBits;
        uint64_t v188 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        unint64_t v265 = lazy protocol witness table accessor for type [String] and conformance [A]();
        uint64_t String = v188;
        uint64_t v267 = BidirectionalCollection<>.joined(separator:)();
        uint64_t v268 = v189;
        uint64_t v190 = *(void *)(countAndFlagsBits + 16);
        if (v190)
        {
          int v191 = 0;
          LODWORD(v269) = *(_DWORD *)(v257 + 8);
          uint64_t v192 = countAndFlagsBits + 40;
          uint64_t v275 = MEMORY[0x1E4FBC860];
          while (1)
          {
            Swift::Int32 v193 = v269 + v191;
            if (__OFADD__(v269, v191))
            {
              __break(1u);
LABEL_85:
              __break(1u);
LABEL_86:
              __break(1u);
LABEL_87:
              __break(1u);
LABEL_88:
              __break(1u);
              JUMPOUT(0x18EA4706CLL);
            }
            swift_bridgeObjectRetain();
            Swift::String v194 = SQLTokenInformation.tokenName(location:)(v193);
            uint64_t v271 = v195;
            if (v195) {
              break;
            }
            char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
            LODWORD(v272) = v191;
            if ((isUniquelyReferenced_nonNull_native & 1) == 0)
            {
              specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v275 + 16) + 1, 1, v275);
              uint64_t v275 = v202;
            }
            unint64_t v198 = *(void *)(v275 + 16);
            unint64_t v197 = *(void *)(v275 + 24);
            if (v198 >= v197 >> 1)
            {
              specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v197 > 1, v198 + 1, 1, v275);
              uint64_t v275 = v203;
            }
            uint64_t v199 = v275;
            *(void *)(v275 + 16) = v198 + 1;
            *(Swift::String *)(v199 + 16 * v198 + 32) = v194;
            uint64_t v200 = String.count.getter();
            swift_bridgeObjectRelease();
            if (v200 < (uint64_t)0xFFFFFFFF80000000) {
              goto LABEL_85;
            }
            if (v200 > 0x7FFFFFFF) {
              goto LABEL_86;
            }
            int v201 = v272 + v200;
            if (__OFADD__(v272, v200)) {
              goto LABEL_87;
            }
            int v191 = v201 + 1;
            if (__OFADD__(v201, 1)) {
              goto LABEL_88;
            }
            v192 += 16;
            if (!--v190) {
              goto LABEL_71;
            }
          }
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          outlined destroy of SQLExpressionError(v264, type metadata accessor for SQLTokenInformation);
          outlined destroy of SQLExpressionError(v257, type metadata accessor for PgQuery_ColumnRef);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
        }
        else
        {
          uint64_t v275 = MEMORY[0x1E4FBC860];
LABEL_71:
          swift_bridgeObjectRelease();
          v274._uint64_t countAndFlagsBits = v275;
          uint64_t v205 = BidirectionalCollection<>.joined(separator:)();
          uint64_t v207 = v206;
          swift_bridgeObjectRelease();
          Swift::String v274 = String.lowercased()();
          uint64_t v209 = v267;
          uint64_t v208 = v268;
          Swift::String v273 = String.lowercased()();
          uint64_t v210 = type metadata accessor for Locale();
          uint64_t v211 = (uint64_t)v236;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v210 - 8) + 56))(v236, 1, 1, v210);
          lazy protocol witness table accessor for type String and conformance String();
          StringProtocol.range<A>(of:options:range:locale:)();
          char v213 = v212;
          outlined destroy of AnyValue?(v211, (uint64_t *)&demangling cache variable for type metadata for Locale?);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          if ((v213 & 1) == 0)
          {
            uint64_t v214 = String.subscript.getter();
            uint64_t v216 = v215;
            uint64_t v218 = v217;
            uint64_t v220 = v219;
            swift_bridgeObjectRelease();
            uint64_t v221 = MEMORY[0x192FAFFE0](v214, v216, v218, v220);
            uint64_t v223 = v222;
            swift_bridgeObjectRelease();
            if (specialized Set.contains(_:)(v209, v208, v261))
            {
              type metadata accessor for SQLExpressionError();
              lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
              swift_allocError();
              uint64_t *v224 = v209;
              v224[1] = v208;
              swift_storeEnumTagMultiPayload();
              uint64_t v225 = (uint64_t)v263;
            }
            else
            {
              uint64_t v227 = v260;
              uint64_t v225 = (uint64_t)v263;
              if (*(void *)(v260 + 16))
              {
                swift_bridgeObjectRetain();
                unint64_t v228 = specialized __RawDictionaryStorage.find<A>(_:)(v267, v208);
                if (v229)
                {
                  char v230 = *(unsigned char *)(*(void *)(v227 + 56) + v228);
                  swift_bridgeObjectRelease();
                  swift_bridgeObjectRelease();
                  swift_bridgeObjectRelease_n();
                  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
                  uint64_t v231 = swift_allocObject();
                  *(_OWORD *)(v231 + 16) = xmmword_18EB382D0;
                  *(void *)(v231 + 32) = v221;
                  *(void *)(v231 + 40) = v223;
                  *(unsigned char *)(v231 + 48) = v230;
                  outlined destroy of SQLExpressionError(v264, type metadata accessor for SQLTokenInformation);
                  outlined destroy of SQLExpressionError(v257, type metadata accessor for PgQuery_ColumnRef);
                  uint64_t v232 = v258;
                  *(void *)(v258 + 16) = 63;
                  *(void *)(v232 + 24) = 0xE100000000000000;
                  *(unsigned char *)(v232 + 32) = v230;
                  *(void *)(v232 + 40) = v231;
                  *(void *)(v232 + 48) = MEMORY[0x1E4FBC860];
                  outlined destroy of SQLExpressionError(v256, type metadata accessor for PgQuery_ColumnRef);
                  uint64_t v84 = v270;
                  goto LABEL_68;
                }
                swift_bridgeObjectRelease();
              }
              type metadata accessor for SQLExpressionError();
              lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
              swift_allocError();
              void *v233 = v267;
              v233[1] = v208;
              swift_storeEnumTagMultiPayload();
            }
            swift_bridgeObjectRetain();
            swift_willThrow();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            outlined destroy of SQLExpressionError(v264, type metadata accessor for SQLTokenInformation);
            outlined destroy of SQLExpressionError(v257, type metadata accessor for PgQuery_ColumnRef);
            swift_bridgeObjectRelease();
LABEL_83:
            swift_bridgeObjectRelease();
            outlined destroy of SQLExpressionError(v256, type metadata accessor for PgQuery_ColumnRef);
            __swift_deallocate_boxed_opaque_existential_1(v225);
            uint64_t v204 = v270;
            return outlined destroy of AnyValue?(v204, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          }
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          type metadata accessor for SQLExpressionError();
          lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
          swift_allocError();
          uint64_t *v226 = v209;
          v226[1] = v208;
          v226[2] = v205;
          v226[3] = v207;
          swift_storeEnumTagMultiPayload();
          swift_willThrow();
          outlined destroy of SQLExpressionError(v264, type metadata accessor for SQLTokenInformation);
          outlined destroy of SQLExpressionError(v257, type metadata accessor for PgQuery_ColumnRef);
        }
        uint64_t v225 = (uint64_t)v263;
        goto LABEL_83;
      case 168:
      case 171:
      case 172:
      case 173:
      case 174:
      case 175:
      case 176:
      case 177:
      case 178:
      case 179:
      case 180:
      case 181:
      case 182:
      case 183:
      case 184:
      case 185:
      case 186:
      case 187:
      case 188:
      case 189:
      case 190:
      case 191:
      case 192:
      case 193:
      case 194:
      case 195:
      case 196:
      case 197:
      case 198:
      case 199:
      case 200:
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
      case 206:
      case 207:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
        goto LABEL_17;
      case 169:
        uint64_t v132 = v244;
        outlined init with take of PgQuery_BitString(v86, v244, type metadata accessor for PgQuery_A_Const);
        uint64_t v133 = v243;
        outlined init with copy of PgQuery_Node(v132, v243, type metadata accessor for PgQuery_A_Const);
        uint64_t v134 = v245;
        outlined init with copy of PgQuery_Node(v259, v245, type metadata accessor for SQLTokenInformation);
        v91 = v263;
        v263[3] = (uint64_t)&unk_1EDD71E60;
        v91[4] = (uint64_t)&protocol witness table for SQLExpressionConst;
        uint64_t v135 = swift_allocObject();
        uint64_t v136 = v135 + 16;
        uint64_t *v91 = v135;
        uint64_t v137 = v258;
        swift_bridgeObjectRetain();
        uint64_t v138 = v260;
        swift_bridgeObjectRetain();
        uint64_t v139 = v261;
        swift_bridgeObjectRetain();
        uint64_t v140 = v136;
        uint64_t v141 = v271;
        SQLExpressionConst.init(const:schemas:columnResolver:tokenInformation:)(v133, v137, v138, v139, v134, v140);
        if (v141)
        {
          v142 = type metadata accessor for PgQuery_A_Const;
          uint64_t v143 = v132;
          goto LABEL_37;
        }
        v157 = type metadata accessor for PgQuery_A_Const;
        uint64_t v158 = v132;
        goto LABEL_67;
      case 170:
        uint64_t v88 = v251;
        outlined init with take of PgQuery_BitString(v86, v251, type metadata accessor for PgQuery_FuncCall);
        uint64_t v144 = v250;
        outlined init with copy of PgQuery_Node(v88, v250, type metadata accessor for PgQuery_FuncCall);
        uint64_t v145 = v247;
        outlined init with copy of PgQuery_Node(v259, v247, type metadata accessor for SQLTokenInformation);
        v91 = v263;
        v263[3] = (uint64_t)&unk_1EDD73C40;
        v91[4] = (uint64_t)&protocol witness table for SQLExpressionFuncCall;
        uint64_t v146 = swift_allocObject();
        uint64_t v147 = v146 + 16;
        uint64_t *v91 = v146;
        uint64_t v148 = v258;
        swift_bridgeObjectRetain();
        uint64_t v149 = v260;
        swift_bridgeObjectRetain();
        uint64_t v150 = v261;
        swift_bridgeObjectRetain();
        uint64_t v151 = v147;
        uint64_t v152 = v271;
        SQLExpressionFuncCall.init(function:schemas:columnResolver:tokenInformation:)(v144, v148, v149, v150, v145, v151);
        if (v152)
        {
          v99 = type metadata accessor for PgQuery_FuncCall;
LABEL_36:
          v142 = v99;
          uint64_t v143 = v88;
LABEL_37:
          outlined destroy of SQLExpressionError(v143, v142);
          goto LABEL_47;
        }
        v187 = type metadata accessor for PgQuery_FuncCall;
LABEL_66:
        v157 = v187;
        uint64_t v158 = v88;
LABEL_67:
        outlined destroy of SQLExpressionError(v158, v157);
        goto LABEL_68;
      case 220:
        v153 = v252;
        outlined init with take of PgQuery_BitString(v86, (uint64_t)v252, type metadata accessor for PgQuery_Integer);
        int v154 = *v153;
        v155 = v263;
        v263[3] = (uint64_t)&unk_1EDD736E8;
        v155[4] = (uint64_t)&protocol witness table for SQLExpressionInteger;
        *(_DWORD *)v155 = v154;
        *((unsigned char *)v155 + 4) = 0;
        uint64_t v156 = MEMORY[0x1E4FBC860];
        v155[1] = MEMORY[0x1E4FBC860];
        v155[2] = v156;
        v157 = type metadata accessor for PgQuery_Integer;
        uint64_t v158 = (uint64_t)v153;
        goto LABEL_67;
      case 221:
        v159 = v254;
        outlined init with take of PgQuery_BitString(v86, (uint64_t)v254, type metadata accessor for PgQuery_Float);
        uint64_t v161 = *v159;
        uint64_t v160 = v159[1];
        v162 = v263;
        v263[3] = (uint64_t)&unk_1EDD71F10;
        v162[4] = (uint64_t)&protocol witness table for SQLExpressionFloat;
        uint64_t v163 = swift_allocObject();
        uint64_t *v162 = v163;
        *(void *)(v163 + 16) = v161;
        *(void *)(v163 + 24) = v160;
        *(unsigned char *)(v163 + 32) = 1;
        uint64_t v164 = MEMORY[0x1E4FBC860];
        *(void *)(v163 + 40) = MEMORY[0x1E4FBC860];
        *(void *)(v163 + 48) = v164;
        swift_bridgeObjectRetain();
        v165 = type metadata accessor for PgQuery_Float;
        goto LABEL_42;
      case 222:
        v159 = v253;
        outlined init with take of PgQuery_BitString(v86, (uint64_t)v253, type metadata accessor for PgQuery_String);
        uint64_t v167 = *v159;
        uint64_t v166 = v159[1];
        v168 = v263;
        v263[3] = (uint64_t)&unk_1EDD72DE8;
        v168[4] = (uint64_t)&protocol witness table for SQLExpressionString;
        uint64_t v169 = swift_allocObject();
        uint64_t *v168 = v169;
        *(void *)(v169 + 16) = v167;
        *(void *)(v169 + 24) = v166;
        *(unsigned char *)(v169 + 32) = 2;
        uint64_t v170 = MEMORY[0x1E4FBC860];
        *(void *)(v169 + 40) = MEMORY[0x1E4FBC860];
        *(void *)(v169 + 48) = v170;
        swift_bridgeObjectRetain();
        v165 = type metadata accessor for PgQuery_String;
        goto LABEL_42;
      case 223:
        v159 = v255;
        outlined init with take of PgQuery_BitString(v86, (uint64_t)v255, type metadata accessor for PgQuery_BitString);
        uint64_t v172 = *v159;
        uint64_t v171 = v159[1];
        v173 = v263;
        v263[3] = (uint64_t)&unk_1EDD74888;
        v173[4] = (uint64_t)&protocol witness table for SQLExpressionBitString;
        uint64_t v174 = swift_allocObject();
        uint64_t *v173 = v174;
        *(void *)(v174 + 16) = v172;
        *(void *)(v174 + 24) = v171;
        *(unsigned char *)(v174 + 32) = 4;
        uint64_t v175 = MEMORY[0x1E4FBC860];
        *(void *)(v174 + 40) = MEMORY[0x1E4FBC860];
        *(void *)(v174 + 48) = v175;
        swift_bridgeObjectRetain();
        v165 = type metadata accessor for PgQuery_BitString;
LABEL_42:
        v157 = v165;
        uint64_t v158 = (uint64_t)v159;
        goto LABEL_67;
      case 224:
        v176 = v263;
        v263[3] = (uint64_t)&unk_1EDD71548;
        v176[4] = (uint64_t)&protocol witness table for SQLExpressionNull;
        uint64_t v177 = swift_allocObject();
        uint64_t *v176 = v177;
        *(void *)(v177 + 16) = 1280070990;
        *(void *)(v177 + 24) = 0xE400000000000000;
        *(unsigned char *)(v177 + 32) = 7;
        uint64_t v178 = MEMORY[0x1E4FBC860];
        *(void *)(v177 + 40) = MEMORY[0x1E4FBC860];
        *(void *)(v177 + 48) = v178;
        v157 = type metadata accessor for PgQuery_Node.OneOf_Node;
        uint64_t v158 = v86;
        goto LABEL_67;
      default:
        if (EnumCaseMultiPayload == 16)
        {
          uint64_t v179 = v240;
          outlined init with take of PgQuery_BitString(v86, v240, type metadata accessor for PgQuery_BoolExpr);
          uint64_t v180 = v239;
          outlined init with copy of PgQuery_Node(v179, v239, type metadata accessor for PgQuery_BoolExpr);
          uint64_t v181 = v237;
          outlined init with copy of PgQuery_Node(v259, v237, type metadata accessor for SQLTokenInformation);
          v91 = v263;
          v263[3] = (uint64_t)&unk_1EDD73630;
          v91[4] = (uint64_t)&protocol witness table for SQLExpressioBoolExpr;
          uint64_t v182 = v258;
          swift_bridgeObjectRetain();
          uint64_t v183 = v260;
          swift_bridgeObjectRetain();
          uint64_t v184 = v261;
          swift_bridgeObjectRetain();
          uint64_t v185 = v183;
          uint64_t v186 = v271;
          SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)(v180, v182, v185, v184, v181, (uint64_t)v91);
          uint64_t v112 = v186;
          v113 = type metadata accessor for PgQuery_BoolExpr;
          uint64_t v114 = v179;
        }
        else
        {
          if (EnumCaseMultiPayload != 37)
          {
LABEL_17:
            outlined destroy of SQLExpressionError(v86, type metadata accessor for PgQuery_Node.OneOf_Node);
            break;
          }
          uint64_t v102 = v242;
          outlined init with take of PgQuery_BitString(v86, v242, type metadata accessor for PgQuery_NullTest);
          uint64_t v103 = v241;
          outlined init with copy of PgQuery_Node(v102, v241, type metadata accessor for PgQuery_NullTest);
          uint64_t v104 = v238;
          outlined init with copy of PgQuery_Node(v259, v238, type metadata accessor for SQLTokenInformation);
          v91 = v263;
          v263[3] = (uint64_t)&unk_1EDD73CF0;
          v91[4] = (uint64_t)&protocol witness table for SQLExpressionNullTest;
          uint64_t v105 = swift_allocObject();
          uint64_t v106 = v105 + 16;
          uint64_t *v91 = v105;
          uint64_t v107 = v258;
          swift_bridgeObjectRetain();
          uint64_t v108 = v260;
          swift_bridgeObjectRetain();
          uint64_t v109 = v261;
          swift_bridgeObjectRetain();
          uint64_t v110 = v106;
          uint64_t v111 = v271;
          SQLExpressionNullTest.init(nullTest:schemas:columnResolver:tokenInformation:)(v103, v107, v108, v109, v104, v110);
          uint64_t v112 = v111;
          v113 = type metadata accessor for PgQuery_NullTest;
          uint64_t v114 = v102;
        }
        outlined destroy of SQLExpressionError(v114, v113);
        if (v112) {
LABEL_47:
        }
          __swift_deallocate_boxed_opaque_existential_1((uint64_t)v91);
        goto LABEL_68;
    }
  }
  type metadata accessor for SQLExpressionError();
  lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
  swift_allocError();
  outlined init with copy of PgQuery_Node(v83, v85, type metadata accessor for PgQuery_Node);
  swift_storeEnumTagMultiPayload();
  swift_willThrow();
LABEL_68:
  uint64_t v204 = v84;
  return outlined destroy of AnyValue?(v204, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
}

uint64_t SQLExpression.init(rootNode:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  outlined init with copy of Aggregation(a1, a2);
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((void *)a2, v4);
  *(void *)(a2 + 40) = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(v4, v5);
  *(void *)(a2 + 48) = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((void *)a2, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 16))(&v19, v7, v8);
  *(unsigned char *)(a2 + 56) = v19;
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((void *)a2, v9);
  *(void *)(a2 + 64) = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(v9, v10);
  uint64_t v11 = *(void *)(a2 + 24);
  uint64_t v12 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((void *)a2, v11);
  *(void *)(a2 + 72) = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 32))(v11, v12);
  uint64_t v13 = *(void *)(a2 + 24);
  uint64_t v14 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_1((void *)a2, v13);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(v13, v14);
  uint64_t v17 = v16;
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  *(void *)(a2 + 80) = v15;
  *(void *)(a2 + 88) = v17;
  return result;
}

unint64_t SQLExpression.CodingKeys.stringValue.getter(char a1)
{
  unint64_t result = 0xD000000000000010;
  switch(a1)
  {
    case 1:
      unint64_t result = 0x79546E7275746572;
      break;
    case 2:
      unint64_t result = 0xD000000000000014;
      break;
    case 3:
      unint64_t result = 0x73676E69646E6962;
      break;
    case 4:
      unint64_t result = 7106931;
      break;
    default:
      return result;
  }
  return result;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance SQLExpression.CodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void protocol witness for Hashable.hash(into:) in conformance SQLExpression.CodingKeys()
{
  Hasher._combine(_:)(*v0);
}

unint64_t protocol witness for CodingKey.stringValue.getter in conformance SQLExpression.CodingKeys()
{
  return SQLExpression.CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance SQLExpression.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized SQLExpression.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance SQLExpression.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 5;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance SQLExpression.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance SQLExpression.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t SQLExpression.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<SQLExpression.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  LOBYTE(v10) = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    LOBYTE(v10) = *(unsigned char *)(v3 + 56);
    char v11 = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    uint64_t v10 = *(void *)(v3 + 64);
    char v11 = 2;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [AggregationFunction]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [AggregationFunction] and conformance <A> [A], &demangling cache variable for type metadata for [AggregationFunction], (void (*)(void))lazy protocol witness table accessor for type AggregationFunction and conformance AggregationFunction);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    uint64_t v10 = *(void *)(v3 + 72);
    char v11 = 3;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [Binding]);
    lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](&lazy protocol witness table cache variable for type [Binding] and conformance <A> [A], &demangling cache variable for type metadata for [Binding], (void (*)(void))lazy protocol witness table accessor for type Binding and conformance Binding);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    LOBYTE(v10) = 4;
    KeyedEncodingContainer.encode(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

unint64_t lazy protocol witness table accessor for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys;
  if (!lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression.CodingKeys and conformance SQLExpression.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType;
  if (!lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLDataType and conformance SQLDataType);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction and conformance AggregationFunction()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction;
  if (!lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction and conformance AggregationFunction);
  }
  return result;
}

uint64_t lazy protocol witness table accessor for type [AggregationFunction] and conformance <A> [A](unint64_t *a1, uint64_t *a2, void (*a3)(void))
{
  uint64_t result = *a1;
  if (!result)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    a3();
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Binding and conformance Binding()
{
  unint64_t result = lazy protocol witness table cache variable for type Binding and conformance Binding;
  if (!lazy protocol witness table cache variable for type Binding and conformance Binding)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding and conformance Binding);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Binding and conformance Binding;
  if (!lazy protocol witness table cache variable for type Binding and conformance Binding)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding and conformance Binding);
  }
  return result;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SQLExpression(void *a1)
{
  return SQLExpression.encode(to:)(a1);
}

void Binding.dataType.getter(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 16);
}

BiomeSQLParser::Binding __swiftcall Binding.init(name:dataType:)(Swift::String name, BiomeSQLParser::SQLDataType dataType)
{
  char v3 = *(unsigned char *)dataType;
  *(Swift::String *)uint64_t v2 = name;
  *(unsigned char *)(v2 + 16) = v3;
  result.name = name;
  result.dataType = dataType;
  return result;
}

uint64_t Binding.hash(into:)()
{
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  String.hash(into:)();

  return swift_bridgeObjectRelease();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance Binding.CodingKeys()
{
  if (*v0) {
    return 0x6570795461746164;
  }
  else {
    return 1701667182;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance Binding.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized Binding.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance Binding.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Binding.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Binding.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t Binding.encode(to:)(void *a1)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<Binding.CodingKeys>);
  uint64_t v9 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  int v10 = *(unsigned __int8 *)(v1 + 16);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  char v13 = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    char v12 = v10;
    char v11 = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v6, v4);
}

Swift::Int Binding.hashValue.getter()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Binding(void *a1)
{
  return Binding.encode(to:)(a1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Binding()
{
  return Hasher._finalize()();
}

uint64_t static Binding.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(a1 + 16);
  char v3 = *(unsigned char *)(a2 + 16);
  BOOL v4 = *(void *)a1 == *(void *)a2 && *(void *)(a1 + 8) == *(void *)(a2 + 8);
  if (!v4 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
    return 0;
  }

  return specialized == infix<A>(_:_:)(v2, v3);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Binding(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(a1 + 16);
  char v3 = *(unsigned char *)(a2 + 16);
  BOOL v4 = *(void *)a1 == *(void *)a2 && *(void *)(a1 + 8) == *(void *)(a2 + 8);
  if (!v4 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
    return 0;
  }

  return specialized == infix<A>(_:_:)(v2, v3);
}

void _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSDySSSiG_SSs5NeverOTg5181_s14BiomeSQLParser14ColumnResolver33_B787555787B9EFBBEFB0C9C5225A4FB7LLV7schemasADSayAA6SchemaVG_tKcfcS2S3key_Si5valuet_tcfu_32a168a102879cc1a6a91172b0770f0c91SSAI_SiAJtSSTf3nnnpk_nTf1cn_n(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    uint64_t v24 = MEMORY[0x1E4FBC860];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    uint64_t v4 = specialized Dictionary.startIndex.getter(a1);
    uint64_t v5 = 0;
    uint64_t v6 = a1 + 64;
    uint64_t v20 = v1;
    int v21 = v3;
    uint64_t v22 = a1 + 64;
    while ((v4 & 0x8000000000000000) == 0 && v4 < 1 << *(unsigned char *)(a1 + 32))
    {
      unint64_t v9 = (unint64_t)v4 >> 6;
      if ((*(void *)(v6 + 8 * ((unint64_t)v4 >> 6)) & (1 << v4)) == 0) {
        goto LABEL_23;
      }
      if (*(_DWORD *)(a1 + 36) != v3) {
        goto LABEL_24;
      }
      int v10 = (uint64_t *)(*(void *)(a1 + 48) + 16 * v4);
      uint64_t v11 = v10[1];
      uint64_t v23 = *v10;
      unint64_t v13 = *(void *)(v24 + 16);
      unint64_t v12 = *(void *)(v24 + 24);
      swift_bridgeObjectRetain();
      if (v13 >= v12 >> 1) {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
      }
      *(void *)(v24 + 16) = v13 + 1;
      uint64_t v14 = v24 + 16 * v13;
      *(void *)(v14 + 32) = v23;
      *(void *)(v14 + 40) = v11;
      int64_t v7 = 1 << *(unsigned char *)(a1 + 32);
      if (v4 >= v7) {
        goto LABEL_25;
      }
      uint64_t v6 = a1 + 64;
      uint64_t v15 = *(void *)(v22 + 8 * v9);
      if ((v15 & (1 << v4)) == 0) {
        goto LABEL_26;
      }
      int v3 = v21;
      if (*(_DWORD *)(a1 + 36) != v21) {
        goto LABEL_27;
      }
      unint64_t v16 = v15 & (-2 << (v4 & 0x3F));
      if (v16)
      {
        int64_t v7 = __clz(__rbit64(v16)) | v4 & 0xFFFFFFFFFFFFFFC0;
        uint64_t v8 = v20;
      }
      else
      {
        unint64_t v17 = v9 + 1;
        unint64_t v18 = (unint64_t)(v7 + 63) >> 6;
        uint64_t v8 = v20;
        if (v9 + 1 < v18)
        {
          unint64_t v19 = *(void *)(v22 + 8 * v17);
          if (v19)
          {
LABEL_20:
            int64_t v7 = __clz(__rbit64(v19)) + (v17 << 6);
          }
          else
          {
            while (v18 - 2 != v9)
            {
              unint64_t v19 = *(void *)(a1 + 80 + 8 * v9++);
              if (v19)
              {
                unint64_t v17 = v9 + 1;
                goto LABEL_20;
              }
            }
          }
        }
      }
      ++v5;
      uint64_t v4 = v7;
      if (v5 == v8) {
        return;
      }
    }
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    __break(1u);
LABEL_25:
    __break(1u);
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
  }
}

uint64_t specialized SQLExpressionNode.sql()()
{
  uint64_t v1 = v0;
  uint64_t v2 = SQLExpressionAExpr.expressionString.getter();
  uint64_t v4 = v3;
  uint64_t v32 = v2;
  uint64_t v33 = v3;
  lazy protocol witness table accessor for type String and conformance String();
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v23 = (void *)(v0 + 40);
  lazy protocol witness table accessor for type String and conformance String();
  while (1)
  {
    uint64_t v30 = v2;
    uint64_t v31 = v4;
    uint64_t v28 = 63;
    unint64_t v29 = 0xE100000000000000;
    BidirectionalCollection<>.firstRange<A>(of:)();
    if (v25) {
      return v2;
    }
    outlined init with copy of PgQuery_Alias?(v1, (uint64_t)v24, &demangling cache variable for type metadata for SQLExpressionNode?);
    uint64_t v7 = v26;
    if (v26)
    {
      uint64_t v8 = v27;
      __swift_project_boxed_opaque_existential_1(v24, v26);
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 32))(v7, v8);
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v24);
    }
    else
    {
      outlined destroy of AnyValue?((uint64_t)v24, &demangling cache variable for type metadata for SQLExpressionNode?);
      uint64_t v9 = MEMORY[0x1E4FBC860];
    }
    uint64_t v11 = *(void *)(v1 + 64);
    uint64_t v10 = *(void *)(v1 + 72);
    __swift_project_boxed_opaque_existential_1(v23, v11);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 32))(v11, v10);
    uint64_t v13 = *(void *)(result + 16);
    int64_t v14 = *(void *)(v9 + 16);
    int64_t v15 = v14 + v13;
    if (__OFADD__(v14, v13)) {
      break;
    }
    uint64_t v16 = result;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if (result && v15 <= *(void *)(v9 + 24) >> 1)
    {
      if (*(void *)(v16 + 16)) {
        goto LABEL_10;
      }
    }
    else
    {
      if (v14 <= v15) {
        int64_t v20 = v14 + v13;
      }
      else {
        int64_t v20 = v14;
      }
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v20, 1, (char *)v9);
      uint64_t v9 = result;
      if (*(void *)(v16 + 16))
      {
LABEL_10:
        if ((*(void *)(v9 + 24) >> 1) - *(void *)(v9 + 16) < v13) {
          goto LABEL_25;
        }
        uint64_t result = swift_arrayInitWithCopy();
        if (v13)
        {
          uint64_t v17 = *(void *)(v9 + 16);
          BOOL v18 = __OFADD__(v17, v13);
          uint64_t v19 = v17 + v13;
          if (v18) {
            goto LABEL_26;
          }
          *(void *)(v9 + 16) = v19;
        }
        goto LABEL_19;
      }
    }
    if (v13) {
      goto LABEL_24;
    }
LABEL_19:
    uint64_t result = swift_bridgeObjectRelease();
    if (v6 >= *(void *)(v9 + 16)) {
      goto LABEL_23;
    }
    uint64_t v21 = *(void *)(v9 + v5 + 32);
    uint64_t v22 = *(void *)(v9 + v5 + 40);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    v24[0] = v21;
    v24[1] = v22;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v6;
    uint64_t v2 = v32;
    uint64_t v4 = v33;
    v5 += 24;
  }
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
LABEL_25:
  __break(1u);
LABEL_26:
  __break(1u);
  return result;
}

{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  uint64_t v10 = v3;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  uint64_t v4 = 0;
  for (i = 0; ; ++i)
  {
    BidirectionalCollection<>.firstRange<A>(of:)();
    if (v9) {
      return v3;
    }
    unint64_t v6 = v0[3];
    uint64_t v7 = v0[4];
    __swift_project_boxed_opaque_existential_1(v0, v6);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 32))(v6, v7);
    if (i >= *(void *)(result + 16)) {
      break;
    }
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    uint64_t v3 = v10;
    v4 += 24;
  }
  __break(1u);
  return result;
}

{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v7;
  uint64_t v8;

  uint64_t v1 = SQLExpressionNullTest.expressionString.getter();
  uint64_t v8 = v1;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  uint64_t v2 = 0;
  for (i = 0; ; ++i)
  {
    BidirectionalCollection<>.firstRange<A>(of:)();
    if (v7) {
      return v1;
    }
    uint64_t v4 = v0[3];
    uint64_t v5 = v0[4];
    __swift_project_boxed_opaque_existential_1(v0, v4);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v4, v5);
    if (i >= *(void *)(result + 16)) {
      break;
    }
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    uint64_t v1 = v8;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t result;
  char v5;
  uint64_t v6;

  uint64_t v1 = *v0;
  unint64_t v6 = *v0;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  uint64_t v2 = 0;
  for (i = 0; ; ++i)
  {
    uint64_t result = BidirectionalCollection<>.firstRange<A>(of:)();
    if (v5) {
      return v1;
    }
    if (i >= *(void *)(v0[4] + 16)) {
      break;
    }
    String.replaceSubrange<A>(_:with:)();
    uint64_t v1 = v6;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t result;
  char v5;
  uint64_t v6;

  uint64_t v1 = *v0;
  unint64_t v6 = *v0;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  uint64_t v2 = 0;
  for (i = 0; ; ++i)
  {
    uint64_t result = BidirectionalCollection<>.firstRange<A>(of:)();
    if (v5) {
      return v1;
    }
    if (i >= *(void *)(v0[3] + 16)) {
      break;
    }
    String.replaceSubrange<A>(_:with:)();
    uint64_t v1 = v6;
    v2 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t v0;
  Swift::String v1;
  Swift::String v2;
  uint64_t v3;
  unint64_t i;
  uint64_t result;
  char v6;

  lazy protocol witness table accessor for type String and conformance String();
  v1._uint64_t countAndFlagsBits = StringProtocol.replacingOccurrences<A, B>(of:with:options:range:)();
  String.append(_:)(v1);
  swift_bridgeObjectRelease();
  v2._uint64_t countAndFlagsBits = 39;
  v2._object = (void *)0xE100000000000000;
  String.append(_:)(v2);
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  uint64_t v3 = 0;
  for (i = 0; ; ++i)
  {
    uint64_t result = BidirectionalCollection<>.firstRange<A>(of:)();
    if (v6) {
      return 39;
    }
    if (i >= *(void *)(*(void *)(v0 + 32) + 16)) {
      break;
    }
    String.replaceSubrange<A>(_:with:)();
    v3 += 24;
  }
  __break(1u);
  return result;
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t inited;
  Swift::String v3;
  char v4;
  uint64_t result;
  uint64_t v6;
  Swift::String v7;
  char v8;
  char v9;

  uint64_t v1 = *(void *)(v0 + 200);
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  swift_bridgeObjectRetain();
  BidirectionalCollection<>.firstRange<A>(of:)();
  if (v9) {
    return v1;
  }
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_18EB382D0;
  uint64_t v3 = AggregationFunction.name()();
  uint64_t v4 = *(unsigned char *)(v0 + 193);
  *(Swift::String *)(inited + 32) = v3;
  *(unsigned char *)(inited + 48) = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  String.replaceSubrange<A>(_:with:)();
  swift_bridgeObjectRelease();
  BidirectionalCollection<>.firstRange<A>(of:)();
  if (v9 == 1) {
    return v1;
  }
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  unint64_t v6 = swift_initStackObject();
  *(_OWORD *)(v6 + 16) = xmmword_18EB382D0;
  uint64_t v7 = AggregationFunction.name()();
  uint64_t result = v7._countAndFlagsBits;
  uint64_t v8 = *(unsigned char *)(v0 + 193);
  *(Swift::String *)(v6 + 32) = v7;
  *(unsigned char *)(v6 + 48) = v8;
  __break(1u);
  return result;
}

uint64_t specialized SQLExpressionNode.sql()(void *a1, uint64_t a2, char a3)
{
  uint64_t v3 = a1;
  if (a3)
  {
    unint64_t v5 = 0xE000000000000000;
    uint64_t v4 = a2;
    switch(a2)
    {
      case 1:
        uint64_t v64 = 40;
        unint64_t v65 = 0xE100000000000000;
        uint64_t v6 = a1[2];
        uint64_t v7 = MEMORY[0x1E4FBC860];
        if (!v6) {
          goto LABEL_22;
        }
        uint64_t v62 = MEMORY[0x1E4FBC860];
        swift_bridgeObjectRetain();
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v8 = (uint64_t)(v3 + 4);
        uint64_t v7 = v62;
        do
        {
          outlined init with copy of Aggregation(v8, (uint64_t)&v55);
          uint64_t v9 = v58;
          uint64_t v10 = v59;
          __swift_project_boxed_opaque_existential_1(&v55, v58);
          uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 8))(v9, v10);
          uint64_t v13 = v12;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v55);
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v7 = v62;
          }
          unint64_t v14 = *(void *)(v7 + 16);
          if (v14 >= *(void *)(v7 + 24) >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v7 = v62;
          }
          *(void *)(v7 + 16) = v14 + 1;
          uint64_t v15 = v7 + 16 * v14;
          *(void *)(v15 + 32) = v11;
          *(void *)(v15 + 40) = v13;
          v8 += 40;
          --v6;
        }
        while (v6);
        goto LABEL_19;
      case 2:
        uint64_t v64 = 40;
        unint64_t v65 = 0xE100000000000000;
        uint64_t v16 = a1[2];
        uint64_t v7 = MEMORY[0x1E4FBC860];
        if (!v16) {
          goto LABEL_22;
        }
        uint64_t v62 = MEMORY[0x1E4FBC860];
        swift_bridgeObjectRetain();
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v17 = (uint64_t)(v3 + 4);
        uint64_t v7 = v62;
        do
        {
          outlined init with copy of Aggregation(v17, (uint64_t)&v55);
          uint64_t v18 = v58;
          uint64_t v19 = v59;
          __swift_project_boxed_opaque_existential_1(&v55, v58);
          uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v19 + 8))(v18, v19);
          uint64_t v22 = v21;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v55);
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v7 = v62;
          }
          unint64_t v23 = *(void *)(v7 + 16);
          if (v23 >= *(void *)(v7 + 24) >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v7 = v62;
          }
          *(void *)(v7 + 16) = v23 + 1;
          uint64_t v24 = v7 + 16 * v23;
          *(void *)(v24 + 32) = v20;
          *(void *)(v24 + 40) = v22;
          v17 += 40;
          --v16;
        }
        while (v16);
LABEL_19:
        swift_bridgeObjectRelease();
LABEL_22:
        uint64_t v55 = v7;
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        lazy protocol witness table accessor for type [String] and conformance [A]();
        uint64_t v29 = BidirectionalCollection<>.joined(separator:)();
        uint64_t v31 = v30;
        swift_bridgeObjectRelease();
        v32._uint64_t countAndFlagsBits = v29;
        v32._object = v31;
        String.append(_:)(v32);
        swift_bridgeObjectRelease();
        v33._uint64_t countAndFlagsBits = 41;
        v33._object = (void *)0xE100000000000000;
        String.append(_:)(v33);
        uint64_t v4 = v64;
        unint64_t v5 = v65;
        break;
      case 3:
        uint64_t v55 = 0x20544F4E28;
        unint64_t v56 = 0xE500000000000000;
        if (!a1[2]) {
          goto LABEL_52;
        }
        uint64_t v25 = a1[7];
        uint64_t v26 = a1[8];
        __swift_project_boxed_opaque_existential_1(a1 + 4, v25);
        v27._uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v26 + 8))(v25, v26);
        String.append(_:)(v27);
        swift_bridgeObjectRelease();
        v28._uint64_t countAndFlagsBits = 41;
        v28._object = (void *)0xE100000000000000;
        String.append(_:)(v28);
        uint64_t v4 = v55;
        unint64_t v5 = v56;
        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0xE000000000000000;
  }
  uint64_t v64 = v4;
  unint64_t v65 = v5;
  lazy protocol witness table accessor for type String and conformance String();
  unint64_t v34 = 0;
  uint64_t v53 = (uint64_t)(v3 + 4);
  uint64_t v54 = v3;
  lazy protocol witness table accessor for type String and conformance String();
  while (1)
  {
    uint64_t v62 = v4;
    unint64_t v63 = v5;
    uint64_t v60 = 63;
    unint64_t v61 = 0xE100000000000000;
    BidirectionalCollection<>.firstRange<A>(of:)();
    if (v57) {
      return v4;
    }
    uint64_t v35 = v3[2];
    if (v35)
    {
      swift_bridgeObjectRetain_n();
      uint64_t v36 = v53;
      uint64_t v37 = (char *)MEMORY[0x1E4FBC860];
      while (1)
      {
        outlined init with copy of Aggregation(v36, (uint64_t)&v55);
        uint64_t v38 = v58;
        uint64_t v39 = v59;
        __swift_project_boxed_opaque_existential_1(&v55, v58);
        uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(v39 + 32))(v38, v39);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v55);
        uint64_t v41 = *(void *)(v40 + 16);
        int64_t v42 = *((void *)v37 + 2);
        int64_t v43 = v42 + v41;
        if (__OFADD__(v42, v41))
        {
          __break(1u);
LABEL_48:
          __break(1u);
LABEL_49:
          __break(1u);
LABEL_50:
          __break(1u);
          goto LABEL_51;
        }
        char isUniquelyReferenced_nonNull_native = (char *)swift_isUniquelyReferenced_nonNull_native();
        if (isUniquelyReferenced_nonNull_native && v43 <= *((void *)v37 + 3) >> 1)
        {
          if (*(void *)(v40 + 16)) {
            goto LABEL_38;
          }
        }
        else
        {
          if (v42 <= v43) {
            int64_t v45 = v42 + v41;
          }
          else {
            int64_t v45 = v42;
          }
          uint64_t v37 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(isUniquelyReferenced_nonNull_native, v45, 1, v37);
          if (*(void *)(v40 + 16))
          {
LABEL_38:
            if ((*((void *)v37 + 3) >> 1) - *((void *)v37 + 2) < v41) {
              goto LABEL_49;
            }
            swift_arrayInitWithCopy();
            if (v41)
            {
              uint64_t v46 = *((void *)v37 + 2);
              BOOL v47 = __OFADD__(v46, v41);
              uint64_t v48 = v46 + v41;
              if (v47) {
                goto LABEL_50;
              }
              *((void *)v37 + 2) = v48;
            }
            goto LABEL_28;
          }
        }
        if (v41) {
          goto LABEL_48;
        }
LABEL_28:
        swift_bridgeObjectRelease();
        v36 += 40;
        if (!--v35)
        {
          swift_bridgeObjectRelease_n();
          goto LABEL_44;
        }
      }
    }
    uint64_t v37 = (char *)MEMORY[0x1E4FBC860];
LABEL_44:
    if (v34 >= *((void *)v37 + 2))
    {
LABEL_51:
      __break(1u);
LABEL_52:
      __break(1u);
      JUMPOUT(0x18EA48AE8);
    }
    uint64_t v49 = &v37[24 * v34];
    uint64_t v51 = *((void *)v49 + 4);
    unint64_t v50 = *((void *)v49 + 5);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v55 = v51;
    unint64_t v56 = v50;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v34;
    uint64_t v4 = v64;
    unint64_t v5 = v65;
    uint64_t v3 = v54;
  }
}

uint64_t specialized SQLExpressionNode.sql()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = dispatch thunk of CustomStringConvertible.description.getter();
  uint64_t v9 = v4;
  lazy protocol witness table accessor for type String and conformance String();
  lazy protocol witness table accessor for type String and conformance String();
  unint64_t v5 = 0;
  for (uint64_t i = a3 + 40; ; i += 24)
  {
    uint64_t result = BidirectionalCollection<>.firstRange<A>(of:)();
    if (v8) {
      return v4;
    }
    if (v5 >= *(void *)(a3 + 16)) {
      break;
    }
    String.replaceSubrange<A>(_:with:)();
    ++v5;
    uint64_t v4 = v9;
  }
  __break(1u);
  return result;
}

uint64_t specialized SQLExpressionNode.sql()(char a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = MEMORY[0x1E4FBC860];
  uint64_t v42 = v4;
  if (v4)
  {
    uint64_t v50 = MEMORY[0x1E4FBC860];
    swift_bridgeObjectRetain();
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    uint64_t v6 = v2 + 32;
    uint64_t v5 = v50;
    do
    {
      outlined init with copy of Aggregation(v6, (uint64_t)&v45);
      uint64_t v7 = v48;
      uint64_t v8 = v49;
      __swift_project_boxed_opaque_existential_1(&v45, v48);
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
      uint64_t v11 = v10;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v45);
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v5 = v50;
      }
      unint64_t v12 = *(void *)(v5 + 16);
      if (v12 >= *(void *)(v5 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v5 = v50;
      }
      *(void *)(v5 + 16) = v12 + 1;
      uint64_t v13 = v5 + 16 * v12;
      *(void *)(v13 + 32) = v9;
      *(void *)(v13 + 40) = v11;
      v6 += 40;
      --v4;
    }
    while (v4);
    uint64_t v2 = a2;
    swift_bridgeObjectRelease();
  }
  uint64_t v45 = v5;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  uint64_t v14 = BidirectionalCollection<>.joined(separator:)();
  uint64_t v16 = v15;
  swift_bridgeObjectRelease();
  LOBYTE(v45) = a1;
  uint64_t v45 = SQLFunction.rawValue.getter();
  uint64_t v46 = v17;
  v18._uint64_t countAndFlagsBits = 40;
  v18._object = (void *)0xE100000000000000;
  String.append(_:)(v18);
  v19._uint64_t countAndFlagsBits = v14;
  v19._object = v16;
  String.append(_:)(v19);
  swift_bridgeObjectRelease();
  v20._uint64_t countAndFlagsBits = 41;
  v20._object = (void *)0xE100000000000000;
  String.append(_:)(v20);
  uint64_t v21 = v45;
  uint64_t v50 = v45;
  uint64_t v51 = v46;
  lazy protocol witness table accessor for type String and conformance String();
  unint64_t v22 = lazy protocol witness table accessor for type String and conformance String();
  unint64_t v44 = 0;
  uint64_t v41 = v2 + 32;
  while (1)
  {
    unint64_t v23 = v22;
    uint64_t result = BidirectionalCollection<>.firstRange<A>(of:)();
    uint64_t v25 = v42;
    if (v47) {
      return v21;
    }
    if (v42) {
      break;
    }
    uint64_t v27 = MEMORY[0x1E4FBC860];
LABEL_30:
    unint64_t v22 = v23;
    if (v44 >= *(void *)(v27 + 16)) {
      goto LABEL_37;
    }
    uint64_t v38 = v27 + 24 * v44;
    uint64_t v40 = *(void *)(v38 + 32);
    uint64_t v39 = *(void *)(v38 + 40);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    uint64_t v45 = v40;
    uint64_t v46 = v39;
    String.replaceSubrange<A>(_:with:)();
    swift_bridgeObjectRelease();
    ++v44;
    uint64_t v21 = v50;
  }
  swift_bridgeObjectRetain_n();
  uint64_t v26 = v41;
  uint64_t v27 = MEMORY[0x1E4FBC860];
  while (1)
  {
    outlined init with copy of Aggregation(v26, (uint64_t)&v45);
    uint64_t v28 = v48;
    uint64_t v29 = v49;
    __swift_project_boxed_opaque_existential_1(&v45, v48);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v29 + 32))(v28, v29);
    uint64_t v30 = *(void *)(result + 16);
    int64_t v31 = *(void *)(v27 + 16);
    int64_t v32 = v31 + v30;
    if (__OFADD__(v31, v30)) {
      break;
    }
    uint64_t v33 = result;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if (result && v32 <= *(void *)(v27 + 24) >> 1)
    {
      if (*(void *)(v33 + 16)) {
        goto LABEL_24;
      }
    }
    else
    {
      if (v31 <= v32) {
        int64_t v34 = v31 + v30;
      }
      else {
        int64_t v34 = v31;
      }
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v34, 1, (char *)v27);
      uint64_t v27 = result;
      if (*(void *)(v33 + 16))
      {
LABEL_24:
        if ((*(void *)(v27 + 24) >> 1) - *(void *)(v27 + 16) < v30) {
          goto LABEL_35;
        }
        uint64_t result = swift_arrayInitWithCopy();
        if (v30)
        {
          uint64_t v35 = *(void *)(v27 + 16);
          BOOL v36 = __OFADD__(v35, v30);
          uint64_t v37 = v35 + v30;
          if (v36) {
            goto LABEL_36;
          }
          *(void *)(v27 + 16) = v37;
        }
        goto LABEL_14;
      }
    }
    if (v30)
    {
      __break(1u);
      break;
    }
LABEL_14:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v45);
    v26 += 40;
    if (!--v25)
    {
      uint64_t result = swift_bridgeObjectRelease_n();
      goto LABEL_30;
    }
  }
  __break(1u);
LABEL_35:
  __break(1u);
LABEL_36:
  __break(1u);
LABEL_37:
  __break(1u);
  return result;
}

uint64_t SQLExpressionConstString.expressionString.getter()
{
  lazy protocol witness table accessor for type String and conformance String();
  v0._uint64_t countAndFlagsBits = StringProtocol.replacingOccurrences<A, B>(of:with:options:range:)();
  String.append(_:)(v0);
  swift_bridgeObjectRelease();
  v1._uint64_t countAndFlagsBits = 39;
  v1._object = (void *)0xE100000000000000;
  String.append(_:)(v1);
  return 39;
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionConstString()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionInteger()
{
  return dispatch thunk of CustomStringConvertible.description.getter();
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionInteger(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 4);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionInteger()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionInteger()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionInteger()
{
  return specialized SQLExpressionNode.sql()(*v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32), *((void *)v0 + 1), *((void *)v0 + 2));
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionNull(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 16);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionNull()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionNull()
{
  return swift_bridgeObjectRetain();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionNull()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t SQLExpressionConst.init(const:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v51 = a3;
  uint64_t v52 = a5;
  uint64_t v49 = a2;
  uint64_t v50 = a4;
  uint64_t v48 = a6;
  uint64_t String = type metadata accessor for PgQuery_String(0);
  MEMORY[0x1F4188790](String - 8);
  uint64_t v46 = (uint64_t *)((char *)&v44 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v10 = MEMORY[0x1F4188790](v9 - 8);
  uint64_t v47 = (uint64_t)&v44 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v54 = (uint64_t)&v44 - v12;
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 8);
  uint64_t v16 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  Swift::String v18 = (char *)&v44 - v17;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v20 = *(void *)(Node - 8);
  uint64_t v21 = MEMORY[0x1F4188790](Node);
  unint64_t v23 = (char *)&v44 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v44 - v24;
  uint64_t v26 = *(int *)(type metadata accessor for PgQuery_A_Const(0) + 20);
  uint64_t v53 = a1;
  uint64_t v45 = v26;
  uint64_t v27 = *(void *)(a1 + v26);
  outlined init with copy of PgQuery_Alias?(v27 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_A_ConstP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, (uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v28 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v20 + 48);
  if (v28(v18, 1, Node) == 1)
  {
    UnknownStorage.init()();
    uint64_t v29 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)&v25[v29] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)v18, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_BitString((uint64_t)v18, (uint64_t)v25, type metadata accessor for PgQuery_Node);
  }
  uint64_t v30 = v54;
  outlined init with copy of PgQuery_Alias?(*(void *)&v25[*(int *)(Node + 20)]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v54, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of SQLExpressionError((uint64_t)v25, type metadata accessor for PgQuery_Node);
  uint64_t v31 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  int v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v31 - 8) + 48))(v30, 1, v31);
  uint64_t v33 = v53;
  if (v32 != 1)
  {
    uint64_t v34 = v47;
    outlined init with copy of PgQuery_Alias?(v30, v47, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (swift_getEnumCaseMultiPayload() == 222)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v35 = v46;
      outlined init with take of PgQuery_BitString(v34, (uint64_t)v46, type metadata accessor for PgQuery_String);
      uint64_t v37 = *v35;
      uint64_t v36 = v35[1];
      unint64_t v56 = &unk_1EDD75138;
      char v57 = &protocol witness table for SQLExpressionConstString;
      uint64_t v38 = swift_allocObject();
      *(void *)&long long v55 = v38;
      *(void *)(v38 + 16) = v37;
      *(void *)(v38 + 24) = v36;
      *(unsigned char *)(v38 + 32) = 2;
      uint64_t v39 = MEMORY[0x1E4FBC860];
      *(void *)(v38 + 40) = MEMORY[0x1E4FBC860];
      *(void *)(v38 + 48) = v39;
      swift_bridgeObjectRetain();
      outlined destroy of SQLExpressionError(v52, type metadata accessor for SQLTokenInformation);
      outlined destroy of SQLExpressionError(v33, type metadata accessor for PgQuery_A_Const);
      outlined destroy of SQLExpressionError((uint64_t)v35, type metadata accessor for PgQuery_String);
      outlined init with take of Aggregation(&v55, v48);
      return outlined destroy of AnyValue?(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    outlined destroy of SQLExpressionError(v34, type metadata accessor for PgQuery_Node.OneOf_Node);
    uint64_t v27 = *(void *)(v33 + v45);
  }
  outlined init with copy of PgQuery_Alias?(v27 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_A_ConstP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, (uint64_t)v16, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v28(v16, 1, Node) == 1)
  {
    UnknownStorage.init()();
    uint64_t v40 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)&v23[v40] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)v16, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_BitString((uint64_t)v16, (uint64_t)v23, type metadata accessor for PgQuery_Node);
  }
  uint64_t v41 = v52;
  uint64_t v42 = v58;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(&v55, v23, v49, v51, v50, v52);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of SQLExpressionError(v41, type metadata accessor for SQLTokenInformation);
  outlined destroy of SQLExpressionError(v33, type metadata accessor for PgQuery_A_Const);
  outlined destroy of SQLExpressionError((uint64_t)v23, type metadata accessor for PgQuery_Node);
  if (!v42) {
    outlined init with take of Aggregation(&v55, v48);
  }
  return outlined destroy of AnyValue?(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionConst()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionColumnRef()
{
  return specialized SQLExpressionNode.sql()();
}

uint64_t SQLExpressionAExpr.init(expr:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v108 = a3;
  uint64_t v112 = a4;
  uint64_t v113 = a5;
  uint64_t v111 = a2;
  uint64_t v114 = a6;
  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v8 = MEMORY[0x1F4188790](v7 - 8);
  uint64_t v100 = (uint64_t)&v95 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v99 = (uint64_t)&v95 - v10;
  uint64_t String = type metadata accessor for PgQuery_String(0);
  uint64_t v11 = MEMORY[0x1F4188790](String);
  uint64_t v98 = (uint64_t *)((char *)&v95 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v11);
  v97 = (uint64_t *)((char *)&v95 - v13);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v15 = *(void *)(Node - 8);
  uint64_t v16 = MEMORY[0x1F4188790](Node);
  uint64_t v104 = (uint64_t)&v95 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v103 = (uint64_t)&v95 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v107 = (uint64_t)&v95 - v21;
  MEMORY[0x1F4188790](v20);
  uint64_t v105 = (uint64_t)&v95 - v22;
  uint64_t v23 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v24 = MEMORY[0x1F4188790](v23 - 8);
  uint64_t v110 = (uint64_t)&v95 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v95 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v95 - v29;
  uint64_t v31 = *(int *)(type metadata accessor for PgQuery_A_Expr(0) + 20);
  uint64_t v32 = a1;
  outlined init with copy of PgQuery_Alias?(*(void *)(a1 + v31)+ OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, (uint64_t)v30, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v102 = v15;
  uint64_t v33 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v15 + 48);
  LODWORD(a1) = v33(v30, 1, Node);
  outlined destroy of AnyValue?((uint64_t)v30, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v106 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))v33;
  if (a1 == 1)
  {
    uint64_t v34 = v114;
    v114[4] = 0;
    *uint64_t v34 = 0u;
    v34[1] = 0u;
    uint64_t v35 = v108;
    uint64_t v36 = v109;
    uint64_t v37 = v32;
  }
  else
  {
    uint64_t v96 = v31;
    outlined init with copy of PgQuery_Alias?(*(void *)(v32 + v31)+ OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__lexpr, (uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v38 = v32;
    if (v33(v28, 1, Node) == 1)
    {
      uint64_t v39 = v105;
      UnknownStorage.init()();
      uint64_t v40 = Node;
      uint64_t v41 = *(int *)(Node + 20);
      uint64_t v42 = v113;
      uint64_t v35 = v108;
      if (one-time initialization token for defaultInstance != -1) {
        swift_once();
      }
      *(void *)(v39 + v41) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of AnyValue?((uint64_t)v28, &demangling cache variable for type metadata for PgQuery_Node?);
      uint64_t Node = v40;
    }
    else
    {
      uint64_t v39 = v105;
      outlined init with take of PgQuery_BitString((uint64_t)v28, v105, type metadata accessor for PgQuery_Node);
      uint64_t v42 = v113;
      uint64_t v35 = v108;
    }
    uint64_t v43 = v109;
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v115, v39, v111, v35, v112, v42);
    uint64_t v36 = v43;
    if (v43)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of SQLExpressionError(v42, type metadata accessor for SQLTokenInformation);
      outlined destroy of SQLExpressionError(v38, type metadata accessor for PgQuery_A_Expr);
      return outlined destroy of SQLExpressionError(v39, type metadata accessor for PgQuery_Node);
    }
    outlined destroy of SQLExpressionError(v39, type metadata accessor for PgQuery_Node);
    outlined init with take of SQLExpression?((uint64_t)v115, (uint64_t)v114, &demangling cache variable for type metadata for SQLExpressionNode?);
    uint64_t v37 = v38;
    uint64_t v31 = v96;
  }
  uint64_t v45 = v31;
  uint64_t v46 = *(void *)(v37 + v31)
      + OBJC_IVAR____TtCV14BiomeSQLParser14PgQuery_A_ExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rexpr;
  uint64_t v47 = v110;
  outlined init with copy of PgQuery_Alias?(v46, v110, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v106(v47, 1, Node) == 1)
  {
    uint64_t v48 = v107;
    UnknownStorage.init()();
    uint64_t v49 = Node;
    uint64_t v50 = *(int *)(Node + 20);
    uint64_t v51 = v111;
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)(v48 + v50) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?(v110, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t Node = v49;
  }
  else
  {
    uint64_t v52 = v47;
    uint64_t v48 = v107;
    outlined init with take of PgQuery_BitString(v52, v107, type metadata accessor for PgQuery_Node);
    uint64_t v51 = v111;
  }
  uint64_t v53 = v113;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v115, v48, v51, v35, v112, v113);
  if (v36)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of SQLExpressionError(v53, type metadata accessor for SQLTokenInformation);
    outlined destroy of SQLExpressionError(v37, type metadata accessor for PgQuery_A_Expr);
    outlined destroy of SQLExpressionError(v48, type metadata accessor for PgQuery_Node);
    return outlined destroy of AnyValue?((uint64_t)v114, &demangling cache variable for type metadata for SQLExpressionNode?);
  }
  outlined destroy of SQLExpressionError(v48, type metadata accessor for PgQuery_Node);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v54 = v114 + 5;
  uint64_t result = outlined init with take of Aggregation(v115, (uint64_t)(v114 + 5));
  uint64_t v55 = *(void *)(v37 + v45);
  if (*(unsigned char *)(v55 + 24) != 1 || (uint64_t v56 = *(void *)(v55 + 16), ((1 << v56) & 0x1FDFD) != 0))
  {
    type metadata accessor for SQLExpressionError();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
    swift_allocError();
    outlined init with copy of PgQuery_Node(v37, v57, type metadata accessor for PgQuery_A_Expr);
    swift_storeEnumTagMultiPayload();
    swift_willThrow();
    outlined destroy of SQLExpressionError(v113, type metadata accessor for SQLTokenInformation);
    outlined destroy of SQLExpressionError(v37, type metadata accessor for PgQuery_A_Expr);
    outlined destroy of AnyValue?((uint64_t)v114, &demangling cache variable for type metadata for SQLExpressionNode?);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v54);
  }
  if (v56 != 1)
  {
    uint64_t v66 = *(void *)(v55 + 32);
    if (!*(void *)(v66 + 16))
    {
LABEL_51:
      __break(1u);
      return result;
    }
    uint64_t v67 = Node;
    uint64_t v68 = v104;
    outlined init with copy of PgQuery_Node(v66 + ((*(unsigned __int8 *)(v102 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v102 + 80)), v104, type metadata accessor for PgQuery_Node);
    uint64_t v69 = v100;
    outlined init with copy of PgQuery_Alias?(*(void *)(v68 + *(int *)(v67 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v100, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    uint64_t v70 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v70 - 8) + 48))(v69, 1, v70) == 1)
    {
      outlined destroy of AnyValue?(v69, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      uint64_t v71 = v98;
      uint64_t v65 = v113;
    }
    else
    {
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      uint64_t v65 = v113;
      if (EnumCaseMultiPayload == 222)
      {
        uint64_t v71 = v98;
        outlined init with take of PgQuery_BitString(v69, (uint64_t)v98, type metadata accessor for PgQuery_String);
LABEL_37:
        outlined destroy of SQLExpressionError(v104, type metadata accessor for PgQuery_Node);
        uint64_t v77 = (uint64_t)v71;
        uint64_t v79 = *v71;
        uint64_t v78 = v71[1];
        swift_bridgeObjectRetain();
        outlined destroy of SQLExpressionError(v77, type metadata accessor for PgQuery_String);
        if (v79 == 8289825 && v78 == 0xE300000000000000)
        {
          uint64_t v76 = 0x454B494C20544F4ELL;
          swift_bridgeObjectRelease();
          unint64_t v75 = 0xE800000000000000;
        }
        else
        {
          char v80 = _stringCompareWithSmolCheck(_:_:expecting:)();
          swift_bridgeObjectRelease();
          BOOL v81 = (v80 & 1) == 0;
          if (v80) {
            uint64_t v76 = 0x454B494C20544F4ELL;
          }
          else {
            uint64_t v76 = 1162561868;
          }
          if (v81) {
            unint64_t v75 = 0xE400000000000000;
          }
          else {
            unint64_t v75 = 0xE800000000000000;
          }
        }
        goto LABEL_46;
      }
      outlined destroy of SQLExpressionError(v69, type metadata accessor for PgQuery_Node.OneOf_Node);
      uint64_t v71 = v98;
    }
    *uint64_t v71 = 0;
    v71[1] = 0xE000000000000000;
    UnknownStorage.init()();
    goto LABEL_37;
  }
  uint64_t v58 = *(void *)(v55 + 32);
  if (!*(void *)(v58 + 16))
  {
    __break(1u);
    goto LABEL_51;
  }
  uint64_t v59 = Node;
  uint64_t v60 = v103;
  outlined init with copy of PgQuery_Node(v58 + ((*(unsigned __int8 *)(v102 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v102 + 80)), v103, type metadata accessor for PgQuery_Node);
  uint64_t v61 = *(void *)(v60 + *(int *)(v59 + 20))
      + OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node;
  uint64_t v62 = v99;
  outlined init with copy of PgQuery_Alias?(v61, v99, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v63 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  int v64 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v63 - 8) + 48))(v62, 1, v63);
  uint64_t v65 = v113;
  if (v64 == 1)
  {
    outlined destroy of AnyValue?(v62, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_33:
    v72 = v97;
    uint64_t *v97 = 0;
    v72[1] = 0xE000000000000000;
    UnknownStorage.init()();
    goto LABEL_34;
  }
  if (swift_getEnumCaseMultiPayload() != 222)
  {
    outlined destroy of SQLExpressionError(v62, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_33;
  }
  v72 = v97;
  outlined init with take of PgQuery_BitString(v62, (uint64_t)v97, type metadata accessor for PgQuery_String);
LABEL_34:
  outlined destroy of SQLExpressionError(v103, type metadata accessor for PgQuery_Node);
  uint64_t v74 = (uint64_t)v72;
  uint64_t v76 = *v72;
  unint64_t v75 = v72[1];
  swift_bridgeObjectRetain();
  outlined destroy of SQLExpressionError(v74, type metadata accessor for PgQuery_String);
LABEL_46:
  v82 = v114;
  v114[10] = v76;
  v82[11] = v75;
  uint64_t v83 = v82[3];
  if (v83)
  {
    uint64_t v84 = v114[4];
    uint64_t v85 = __swift_project_boxed_opaque_existential_1(v114, v82[3]);
    uint64_t v86 = *(void *)(v83 - 8);
    MEMORY[0x1F4188790](v85);
    uint64_t v88 = (char *)&v95 - ((v87 + 15) & 0xFFFFFFFFFFFFFFF0);
    (*(void (**)(char *))(v86 + 16))(v88);
    (*(void (**)(char *__return_ptr, uint64_t, uint64_t))(v84 + 16))((char *)&v116 + 1, v83, v84);
    (*(void (**)(char *, uint64_t))(v86 + 8))(v88, v83);
    uint64_t v65 = v113;
    char v89 = BYTE1(v116);
  }
  else
  {
    char v89 = 8;
  }
  BYTE1(v116) = v89;
  uint64_t v90 = v114;
  uint64_t v91 = v114[8];
  uint64_t v92 = v114[9];
  __swift_project_boxed_opaque_existential_1(v54, v91);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v92 + 16))(&v116, v91, v92);
  uint64_t v94 = v90[10];
  uint64_t v93 = v90[11];
  swift_bridgeObjectRetain();
  static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)((unsigned char *)&v116 + 1, &v116, v94, v93, (char *)v115);
  swift_bridgeObjectRelease();
  outlined destroy of SQLExpressionError(v65, type metadata accessor for SQLTokenInformation);
  uint64_t result = outlined destroy of SQLExpressionError(v37, type metadata accessor for PgQuery_A_Expr);
  *((unsigned char *)v114 + 96) = v115[0];
  return result;
}

uint64_t static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)@<X0>(unsigned char *a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  int v5 = *a1;
  uint64_t v6 = *a2;
  switch(*a1)
  {
    case 7:
LABEL_5:
      uint64_t result = swift_bridgeObjectRelease();
      goto LABEL_18;
    case 8:
      switch(*a2)
      {
        case 7:
          goto LABEL_5;
        default:
          char v17 = _stringCompareWithSmolCheck(_:_:expecting:)();
          uint64_t result = swift_bridgeObjectRelease();
          if (v17) {
            goto LABEL_18;
          }
          if (a3 == 126 && a4 == 0xE100000000000000) {
            goto LABEL_40;
          }
          uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)();
          if (result) {
            goto LABEL_40;
          }
          char v18 = specialized Sequence<>.contains(_:)(a3, a4, outlined read-only object #5 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:));
          uint64_t result = swift_arrayDestroy();
          if ((v18 & 1) == 0) {
            goto LABEL_40;
          }
          uint64_t result = specialized Sequence<>.contains(_:)(v6, (uint64_t)&outlined read-only object #6 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:));
          if ((result & 1) == 0) {
            goto LABEL_26;
          }
          *a5 = v6;
          break;
      }
      return result;
    default:
      char v10 = _stringCompareWithSmolCheck(_:_:expecting:)();
      uint64_t result = swift_bridgeObjectRelease();
      if (v10)
      {
LABEL_18:
        char v13 = 7;
LABEL_19:
        *a5 = v13;
        return result;
      }
      switch(v6)
      {
        case 7:
          goto LABEL_5;
        default:
          char v12 = _stringCompareWithSmolCheck(_:_:expecting:)();
          uint64_t result = swift_bridgeObjectRelease();
          if (v12) {
            goto LABEL_18;
          }
          if (a3 == 31868 && a4 == 0xE200000000000000
            || (uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)(), (result & 1) != 0))
          {
            char v13 = 2;
            goto LABEL_19;
          }
          char v14 = specialized Sequence<>.contains(_:)(a3, a4, outlined read-only object #0 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:));
          uint64_t result = swift_arrayDestroy();
          if ((v14 & 1) == 0)
          {
            char v15 = specialized Sequence<>.contains(_:)(a3, a4, outlined read-only object #1 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:));
            uint64_t result = swift_arrayDestroy();
            if ((v15 & 1) == 0)
            {
              char v16 = specialized Sequence<>.contains(_:)(a3, a4, outlined read-only object #2 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:));
              uint64_t result = swift_arrayDestroy();
              if (v16)
              {
                if (specialized Sequence<>.contains(_:)(v5, (uint64_t)&outlined read-only object #3 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)))
                {
                  if (specialized Sequence<>.contains(_:)(v6, (uint64_t)&outlined read-only object #4 of static SQLExpressionAExpr.inferExprReturnType(lReturnType:rReturnType:op:)))
                  {
                    switch(v5)
                    {
                      case 3:
LABEL_31:
                        uint64_t result = swift_bridgeObjectRelease();
                        goto LABEL_33;
                      default:
                        char v21 = _stringCompareWithSmolCheck(_:_:expecting:)();
                        uint64_t result = swift_bridgeObjectRelease();
                        if (v21)
                        {
LABEL_33:
                          char v13 = 3;
                        }
                        else
                        {
                          switch(v6)
                          {
                            case 3:
                              goto LABEL_31;
                            default:
                              char v22 = _stringCompareWithSmolCheck(_:_:expecting:)();
                              uint64_t result = swift_bridgeObjectRelease();
                              if (v22) {
                                goto LABEL_33;
                              }
                              switch(v5)
                              {
                                case 1:
LABEL_37:
                                  uint64_t result = swift_bridgeObjectRelease();
                                  break;
                                default:
                                  char v23 = _stringCompareWithSmolCheck(_:_:expecting:)();
                                  uint64_t result = swift_bridgeObjectRelease();
                                  if ((v23 & 1) == 0)
                                  {
                                    switch(v6)
                                    {
                                      case 1:
                                        goto LABEL_37;
                                      default:
                                        char v24 = _stringCompareWithSmolCheck(_:_:expecting:)();
                                        uint64_t result = swift_bridgeObjectRelease();
                                        if (v24) {
                                          goto LABEL_39;
                                        }
                                        goto LABEL_40;
                                    }
                                  }
                                  break;
                              }
LABEL_39:
                              char v13 = 1;
                              break;
                          }
                        }
                        break;
                    }
                    goto LABEL_19;
                  }
LABEL_26:
                  type metadata accessor for SQLExpressionError();
                  lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
                  swift_allocError();
                  *(void *)uint64_t v19 = a3;
                  *(void *)(v19 + 8) = a4;
                  *(unsigned char *)(v19 + 16) = v6;
                }
                else
                {
                  type metadata accessor for SQLExpressionError();
                  lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
                  swift_allocError();
                  *(void *)uint64_t v20 = a3;
                  *(void *)(v20 + 8) = a4;
                  *(unsigned char *)(v20 + 16) = v5;
                }
                swift_storeEnumTagMultiPayload();
                swift_bridgeObjectRetain();
                return swift_willThrow();
              }
            }
          }
LABEL_40:
          *a5 = 0;
          return result;
      }
  }
}

uint64_t specialized Sequence<>.contains(_:)(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3[2];
  if (!v3) {
    return 0;
  }
  if (a3[4] == a1 && a3[5] == a2) {
    return 1;
  }
  uint64_t result = _stringCompareWithSmolCheck(_:_:expecting:)();
  if (result) {
    return 1;
  }
  if (v3 == 1) {
    return 0;
  }
  uint64_t v9 = a3 + 7;
  for (uint64_t i = 1; ; ++i)
  {
    uint64_t v11 = i + 1;
    if (__OFADD__(i, 1)) {
      break;
    }
    BOOL v12 = *(v9 - 1) == a1 && *v9 == a2;
    if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
      return 1;
    }
    uint64_t result = 0;
    v9 += 2;
    if (v11 == v3) {
      return result;
    }
  }
  __break(1u);
  return result;
}

uint64_t specialized Sequence<>.contains(_:)(char a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2)
  {
    swift_bridgeObjectRetain();
    uint64_t v5 = 0;
    while (2)
    {
      uint64_t v6 = a2 + v5++;
      unint64_t v7 = 0xE700000000000000;
      uint64_t v8 = 0x72656765746E69;
      switch(*(unsigned char *)(v6 + 32))
      {
        case 1:
          unint64_t v7 = 0xE600000000000000;
          uint64_t v8 = 0x656C62756F64;
          break;
        case 2:
          unint64_t v7 = 0xE600000000000000;
          uint64_t v8 = 0x676E69727473;
          break;
        case 3:
          unint64_t v7 = 0xE400000000000000;
          uint64_t v8 = 1702125924;
          break;
        case 4:
          unint64_t v7 = 0xE400000000000000;
          uint64_t v8 = 1635017060;
          break;
        case 5:
          unint64_t v7 = 0xE400000000000000;
          uint64_t v8 = 1852797802;
          break;
        case 6:
          unint64_t v7 = 0xE400000000000000;
          uint64_t v8 = 1684632949;
          break;
        case 7:
          unint64_t v7 = 0xE400000000000000;
          uint64_t v8 = 1819047278;
          break;
        default:
          break;
      }
      unint64_t v9 = 0xE700000000000000;
      uint64_t v10 = 0x72656765746E69;
      switch(a1)
      {
        case 1:
          unint64_t v9 = 0xE600000000000000;
          if (v8 == 0x656C62756F64) {
            goto LABEL_24;
          }
          goto LABEL_25;
        case 2:
          unint64_t v9 = 0xE600000000000000;
          if (v8 != 0x676E69727473) {
            goto LABEL_25;
          }
          goto LABEL_24;
        case 3:
          unint64_t v9 = 0xE400000000000000;
          if (v8 != 1702125924) {
            goto LABEL_25;
          }
          goto LABEL_24;
        case 4:
          unint64_t v9 = 0xE400000000000000;
          if (v8 != 1635017060) {
            goto LABEL_25;
          }
          goto LABEL_24;
        case 5:
          unint64_t v9 = 0xE400000000000000;
          if (v8 != 1852797802) {
            goto LABEL_25;
          }
          goto LABEL_24;
        case 6:
          unint64_t v9 = 0xE400000000000000;
          uint64_t v10 = 1684632949;
          goto LABEL_23;
        case 7:
          unint64_t v9 = 0xE400000000000000;
          if (v8 != 1819047278) {
            goto LABEL_25;
          }
          goto LABEL_24;
        default:
LABEL_23:
          if (v8 != v10) {
            goto LABEL_25;
          }
LABEL_24:
          if (v7 == v9)
          {
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease_n();
            return 1;
          }
LABEL_25:
          char v11 = _stringCompareWithSmolCheck(_:_:expecting:)();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          if (v11)
          {
            swift_bridgeObjectRelease();
            return 1;
          }
          if (v2 != v5) {
            continue;
          }
          swift_bridgeObjectRelease();
          break;
      }
      break;
    }
  }
  return 0;
}

uint64_t SQLExpressionAExpr.expressionString.getter()
{
  uint64_t v1 = v0[8];
  uint64_t v2 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  uint64_t v5 = v4;
  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)&v20, &demangling cache variable for type metadata for SQLExpressionNode?);
  uint64_t v6 = v22;
  if (v22)
  {
    uint64_t v7 = v23;
    __swift_project_boxed_opaque_existential_1(&v20, v22);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
    uint64_t v10 = v9;
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v20);
    uint64_t v20 = 40;
    unint64_t v21 = 0xE100000000000000;
    v11._uint64_t countAndFlagsBits = v8;
    v11._object = v10;
    String.append(_:)(v11);
    swift_bridgeObjectRelease();
    v12._uint64_t countAndFlagsBits = 32;
    v12._object = (void *)0xE100000000000000;
    String.append(_:)(v12);
  }
  else
  {
    outlined destroy of AnyValue?((uint64_t)&v20, &demangling cache variable for type metadata for SQLExpressionNode?);
    uint64_t v20 = 40;
    unint64_t v21 = 0xE100000000000000;
  }
  uint64_t v14 = v0[10];
  char v13 = (void *)v0[11];
  swift_bridgeObjectRetain();
  v15._uint64_t countAndFlagsBits = v14;
  v15._object = v13;
  String.append(_:)(v15);
  swift_bridgeObjectRelease();
  v16._uint64_t countAndFlagsBits = 32;
  v16._object = (void *)0xE100000000000000;
  String.append(_:)(v16);
  v17._uint64_t countAndFlagsBits = v3;
  v17._object = v5;
  String.append(_:)(v17);
  swift_bridgeObjectRelease();
  v18._uint64_t countAndFlagsBits = 41;
  v18._object = (void *)0xE100000000000000;
  String.append(_:)(v18);
  return v20;
}

uint64_t SQLExpressionAExpr.aggregationFunctions.getter()
{
  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)v7, &demangling cache variable for type metadata for SQLExpressionNode?);
  uint64_t v1 = v8;
  if (v8)
  {
    uint64_t v2 = v9;
    __swift_project_boxed_opaque_existential_1(v7, v8);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v1, v2);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v7);
  }
  else
  {
    outlined destroy of AnyValue?((uint64_t)v7, &demangling cache variable for type metadata for SQLExpressionNode?);
    uint64_t v3 = MEMORY[0x1E4FBC860];
  }
  uint64_t v5 = v0[8];
  uint64_t v4 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v5);
  (*(void (**)(uint64_t, uint64_t))(v4 + 24))(v5, v4);
  v7[0] = v3;
  specialized Array.append<A>(contentsOf:)();
  return v7[0];
}

uint64_t SQLExpressionAExpr.bindings.getter()
{
  outlined init with copy of PgQuery_Alias?((uint64_t)v0, (uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
  uint64_t v1 = v9;
  if (v9)
  {
    uint64_t v2 = v10;
    __swift_project_boxed_opaque_existential_1(v8, v9);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 32))(v1, v2);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v8);
  }
  else
  {
    outlined destroy of AnyValue?((uint64_t)v8, &demangling cache variable for type metadata for SQLExpressionNode?);
    uint64_t v3 = MEMORY[0x1E4FBC860];
  }
  uint64_t v5 = v0[8];
  uint64_t v4 = v0[9];
  __swift_project_boxed_opaque_existential_1(v0 + 5, v5);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 32))(v5, v4);
  v8[0] = v3;
  specialized Array.append<A>(contentsOf:)(v6);
  return v8[0];
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionAExpr(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 96);
}

uint64_t SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v13 = *(int *)(type metadata accessor for PgQuery_BoolExpr(0) + 20);
  uint64_t v14 = *(void *)(*(void *)(a1 + v13)
                  + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__args);
  v23[2] = a2;
  v23[3] = a3;
  v23[4] = a4;
  v23[5] = a5;
  swift_bridgeObjectRetain();
  uint64_t NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5((void (*)(long long *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:), (uint64_t)v23, v14);
  if (v6)
  {
    outlined destroy of SQLExpressionError(a1, type metadata accessor for PgQuery_BoolExpr);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    return outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
  }
  else
  {
    uint64_t v24 = NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v17 = *(void *)(a1 + v13)
        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_BoolExprP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__BOOLop;
    if (*(unsigned char *)(v17 + 8) == 1)
    {
      uint64_t v18 = *(void *)v17;
      switch(*(void *)v17)
      {
        case 1:
        case 2:
          uint64_t v19 = v24;
          goto LABEL_10;
        case 3:
          uint64_t v21 = *(void *)(v24 + 16);
          if (v21 != 1)
          {
            type metadata accessor for SQLExpressionError();
            lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
            swift_allocError();
            *uint64_t v22 = v21;
            goto LABEL_7;
          }
          uint64_t v19 = v24;
LABEL_10:
          swift_bridgeObjectRetain();
          outlined destroy of SQLExpressionError(a1, type metadata accessor for PgQuery_BoolExpr);
          outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
          *(void *)a6 = v19;
          *(void *)(a6 + 8) = v18;
          *(_WORD *)(a6 + 16) = 1;
          break;
        default:
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      type metadata accessor for SQLExpressionError();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
      swift_allocError();
      outlined init with copy of PgQuery_Node(a1, v20, type metadata accessor for PgQuery_BoolExpr);
LABEL_7:
      swift_storeEnumTagMultiPayload();
      swift_willThrow();
      outlined destroy of SQLExpressionError(a1, type metadata accessor for PgQuery_BoolExpr);
      outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
    }
    return swift_bridgeObjectRelease();
  }
}

uint64_t SQLExpressioBoolExpr.expressionString.getter()
{
  if (*((unsigned char *)v0 + 16) != 1) {
    return 0;
  }
  uint64_t v2 = *v0;
  uint64_t result = v0[1];
  switch(result)
  {
    case 1:
      uint64_t v35 = 40;
      unint64_t v36 = 0xE100000000000000;
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = MEMORY[0x1E4FBC860];
      if (!v3) {
        goto LABEL_22;
      }
      uint64_t v30 = MEMORY[0x1E4FBC860];
      swift_bridgeObjectRetain();
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
      uint64_t v5 = v2 + 32;
      uint64_t v4 = v30;
      do
      {
        outlined init with copy of Aggregation(v5, (uint64_t)v32);
        uint64_t v6 = v33;
        uint64_t v7 = v34;
        __swift_project_boxed_opaque_existential_1(v32, v33);
        uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
        uint64_t v10 = v9;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v32);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v4 = v30;
        }
        unint64_t v11 = *(void *)(v4 + 16);
        if (v11 >= *(void *)(v4 + 24) >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v4 = v30;
        }
        *(void *)(v4 + 16) = v11 + 1;
        uint64_t v12 = v4 + 16 * v11;
        *(void *)(v12 + 32) = v8;
        *(void *)(v12 + 40) = v10;
        v5 += 40;
        --v3;
      }
      while (v3);
      goto LABEL_19;
    case 2:
      uint64_t v35 = 40;
      unint64_t v36 = 0xE100000000000000;
      uint64_t v13 = *(void *)(v2 + 16);
      uint64_t v4 = MEMORY[0x1E4FBC860];
      if (v13)
      {
        uint64_t v31 = MEMORY[0x1E4FBC860];
        swift_bridgeObjectRetain();
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v14 = v2 + 32;
        uint64_t v4 = v31;
        do
        {
          outlined init with copy of Aggregation(v14, (uint64_t)v32);
          uint64_t v15 = v33;
          uint64_t v16 = v34;
          __swift_project_boxed_opaque_existential_1(v32, v33);
          uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 8))(v15, v16);
          uint64_t v19 = v18;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v32);
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v4 = v31;
          }
          unint64_t v20 = *(void *)(v4 + 16);
          if (v20 >= *(void *)(v4 + 24) >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v4 = v31;
          }
          *(void *)(v4 + 16) = v20 + 1;
          uint64_t v21 = v4 + 16 * v20;
          *(void *)(v21 + 32) = v17;
          *(void *)(v21 + 40) = v19;
          v14 += 40;
          --v13;
        }
        while (v13);
LABEL_19:
        swift_bridgeObjectRelease();
      }
LABEL_22:
      v32[0] = v4;
      __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
      lazy protocol witness table accessor for type [String] and conformance [A]();
      uint64_t v25 = BidirectionalCollection<>.joined(separator:)();
      uint64_t v27 = v26;
      swift_bridgeObjectRelease();
      v28._uint64_t countAndFlagsBits = v25;
      v28._object = v27;
      String.append(_:)(v28);
      swift_bridgeObjectRelease();
      goto LABEL_23;
    case 3:
      uint64_t v35 = 0x20544F4E28;
      unint64_t v36 = 0xE500000000000000;
      if (!*(void *)(v2 + 16))
      {
        __break(1u);
        JUMPOUT(0x18EA4C45CLL);
      }
      outlined init with copy of Aggregation(v2 + 32, (uint64_t)v32);
      uint64_t v22 = v33;
      uint64_t v23 = v34;
      __swift_project_boxed_opaque_existential_1(v32, v33);
      v24._uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 8))(v22, v23);
      String.append(_:)(v24);
      swift_bridgeObjectRelease();
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v32);
LABEL_23:
      v29._uint64_t countAndFlagsBits = 41;
      v29._object = (void *)0xE100000000000000;
      String.append(_:)(v29);
      uint64_t result = v35;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t SQLExpressioBoolExpr.aggregationFunctions.getter()
{
  uint64_t v1 = *(void *)(*(void *)v0 + 16);
  if (!v1) {
    return MEMORY[0x1E4FBC860];
  }
  uint64_t v2 = *(void *)v0 + 32;
  swift_bridgeObjectRetain_n();
  uint64_t v3 = MEMORY[0x1E4FBC860];
  while (1)
  {
    outlined init with copy of Aggregation(v2, (uint64_t)v15);
    uint64_t v4 = v16;
    uint64_t v5 = v17;
    __swift_project_boxed_opaque_existential_1(v15, v16);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(v4, v5);
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v15);
    uint64_t v8 = *(void *)(v6 + 16);
    uint64_t v9 = *(void *)(v3 + 16);
    uint64_t v10 = v9 + v8;
    if (__OFADD__(v9, v8)) {
      break;
    }
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if (result && v10 <= *(void *)(v3 + 24) >> 1)
    {
      if (*(void *)(v6 + 16)) {
        goto LABEL_14;
      }
    }
    else
    {
      if (v9 <= v10) {
        uint64_t v11 = v9 + v8;
      }
      else {
        uint64_t v11 = v9;
      }
      uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, v11, 1, v3);
      uint64_t v3 = result;
      if (*(void *)(v6 + 16))
      {
LABEL_14:
        if ((*(void *)(v3 + 24) >> 1) - *(void *)(v3 + 16) < v8) {
          goto LABEL_23;
        }
        uint64_t result = swift_arrayInitWithCopy();
        if (v8)
        {
          uint64_t v12 = *(void *)(v3 + 16);
          BOOL v13 = __OFADD__(v12, v8);
          uint64_t v14 = v12 + v8;
          if (v13) {
            goto LABEL_24;
          }
          *(void *)(v3 + 16) = v14;
        }
        goto LABEL_4;
      }
    }
    if (v8) {
      goto LABEL_22;
    }
LABEL_4:
    swift_bridgeObjectRelease();
    v2 += 40;
    if (!--v1)
    {
      swift_bridgeObjectRelease_n();
      return v3;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

char *SQLExpressioBoolExpr.bindings.getter()
{
  uint64_t v1 = *(void *)(*(void *)v0 + 16);
  if (!v1) {
    return (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v2 = *(void *)v0 + 32;
  swift_bridgeObjectRetain_n();
  uint64_t v3 = (char *)MEMORY[0x1E4FBC860];
  while (1)
  {
    outlined init with copy of Aggregation(v2, (uint64_t)v15);
    uint64_t v4 = v16;
    uint64_t v5 = v17;
    __swift_project_boxed_opaque_existential_1(v15, v16);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v4, v5);
    uint64_t result = (char *)__swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v15);
    uint64_t v8 = *(void *)(v6 + 16);
    int64_t v9 = *((void *)v3 + 2);
    int64_t v10 = v9 + v8;
    if (__OFADD__(v9, v8)) {
      break;
    }
    uint64_t result = (char *)swift_isUniquelyReferenced_nonNull_native();
    if (result && v10 <= *((void *)v3 + 3) >> 1)
    {
      if (*(void *)(v6 + 16)) {
        goto LABEL_14;
      }
    }
    else
    {
      if (v9 <= v10) {
        int64_t v11 = v9 + v8;
      }
      else {
        int64_t v11 = v9;
      }
      uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, v11, 1, v3);
      uint64_t v3 = result;
      if (*(void *)(v6 + 16))
      {
LABEL_14:
        if ((*((void *)v3 + 3) >> 1) - *((void *)v3 + 2) < v8) {
          goto LABEL_23;
        }
        uint64_t result = (char *)swift_arrayInitWithCopy();
        if (v8)
        {
          uint64_t v12 = *((void *)v3 + 2);
          BOOL v13 = __OFADD__(v12, v8);
          uint64_t v14 = v12 + v8;
          if (v13) {
            goto LABEL_24;
          }
          *((void *)v3 + 2) = v14;
        }
        goto LABEL_4;
      }
    }
    if (v8) {
      goto LABEL_22;
    }
LABEL_4:
    swift_bridgeObjectRelease();
    v2 += 40;
    if (!--v1)
    {
      swift_bridgeObjectRelease_n();
      return v3;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressioBoolExpr(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 17);
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressioBoolExpr()
{
  return specialized SQLExpressionNode.sql()(*(void **)v0, *(void *)(v0 + 8), *(unsigned char *)(v0 + 16));
}

uint64_t SQLExpressionNullTest.init(nullTest:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v30 = a3;
  uint64_t v31 = a5;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1F4188790](v10 - 8);
  uint64_t v12 = (char *)&v27 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v14 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node);
  uint64_t v16 = (char *)&v27 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = a6;
  *(unsigned char *)(a6 + 49) = 0;
  uint64_t v17 = *(int *)(type metadata accessor for PgQuery_NullTest(0) + 20);
  uint64_t v33 = a1;
  outlined init with copy of PgQuery_Alias?(*(void *)(a1 + v17)+ OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__arg, (uint64_t)v12, &demangling cache variable for type metadata for PgQuery_Node?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v14 + 48))(v12, 1, Node) == 1)
  {
    UnknownStorage.init()();
    uint64_t v18 = *(int *)(Node + 20);
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)&v16[v18] = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)v12, &demangling cache variable for type metadata for PgQuery_Node?);
  }
  else
  {
    outlined init with take of PgQuery_BitString((uint64_t)v12, (uint64_t)v16, type metadata accessor for PgQuery_Node);
  }
  uint64_t v19 = v31;
  uint64_t v20 = v29;
  buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(v32, v16, a2, v30, a4, v31);
  if (v20)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of SQLExpressionError(v19, type metadata accessor for SQLTokenInformation);
    outlined destroy of SQLExpressionError(v33, type metadata accessor for PgQuery_NullTest);
    return outlined destroy of SQLExpressionError((uint64_t)v16, type metadata accessor for PgQuery_Node);
  }
  else
  {
    outlined destroy of SQLExpressionError((uint64_t)v16, type metadata accessor for PgQuery_Node);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v22 = v28;
    outlined init with take of Aggregation(v32, v28);
    uint64_t v23 = v33;
    uint64_t v24 = *(void *)(v33 + v17)
        + OBJC_IVAR____TtCV14BiomeSQLParser16PgQuery_NullTestP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__nulltesttype;
    if (*(unsigned char *)(v24 + 8) == 1 && (uint64_t v25 = *(void *)v24) != 0)
    {
      outlined destroy of SQLExpressionError(v19, type metadata accessor for SQLTokenInformation);
      uint64_t result = outlined destroy of SQLExpressionError(v23, type metadata accessor for PgQuery_NullTest);
      *(void *)(v22 + 40) = v25;
      *(unsigned char *)(v22 + 48) = 1;
    }
    else
    {
      type metadata accessor for SQLExpressionError();
      lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
      swift_allocError();
      outlined init with copy of PgQuery_Node(v23, v26, type metadata accessor for PgQuery_NullTest);
      swift_storeEnumTagMultiPayload();
      swift_willThrow();
      outlined destroy of SQLExpressionError(v19, type metadata accessor for SQLTokenInformation);
      outlined destroy of SQLExpressionError(v23, type metadata accessor for PgQuery_NullTest);
      return __swift_destroy_boxed_opaque_existential_1Tm(v22);
    }
  }
  return result;
}

uint64_t SQLExpressionNullTest.expressionString.getter()
{
  if (*(unsigned char *)(v0 + 48) != 1) {
    return 0;
  }
  uint64_t result = *(void *)(v0 + 40);
  if (result)
  {
    if (result == 1)
    {
      uint64_t v2 = *(void *)(v0 + 24);
      uint64_t v3 = *(void *)(v0 + 32);
      __swift_project_boxed_opaque_existential_1((void *)v0, v2);
      v4._uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(v2, v3);
      String.append(_:)(v4);
      swift_bridgeObjectRelease();
      uint64_t v5 = 0x4C4C554E20534920;
      unint64_t v6 = 0xE900000000000029;
    }
    else
    {
      _StringGuts.grow(_:)(16);
      swift_bridgeObjectRelease();
      uint64_t v7 = *(void *)(v0 + 24);
      uint64_t v8 = *(void *)(v0 + 32);
      __swift_project_boxed_opaque_existential_1((void *)v0, v7);
      v9._uint64_t countAndFlagsBits = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
      String.append(_:)(v9);
      swift_bridgeObjectRelease();
      uint64_t v5 = 0x20544F4E20534920;
      unint64_t v6 = 0xED0000294C4C554ELL;
    }
    String.append(_:)(*(Swift::String *)&v5);
    return 40;
  }
  return result;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionNullTest(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 49);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionNullTest()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionNullTest()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 32))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionAggregationFunction()
{
  uint64_t v1 = *(void *)(v0 + 200);
  swift_bridgeObjectRetain();
  return v1;
}

void protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionAggregationFunction(unsigned char *a1@<X8>)
{
  *a1 = *(unsigned char *)(v1 + 193);
}

uint64_t protocol witness for SQLExpressionNode.aggregationFunctions.getter in conformance SQLExpressionAggregationFunction()
{
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<AggregationFunction>);
  uint64_t v1 = swift_allocObject();
  *(_OWORD *)(v1 + 16) = xmmword_18EB382D0;
  outlined init with copy of AggregationFunction(v0, v1 + 32);
  return v1;
}

uint64_t protocol witness for SQLExpressionNode.bindings.getter in conformance SQLExpressionAggregationFunction()
{
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for _ContiguousArrayStorage<Binding>);
  uint64_t v1 = swift_allocObject();
  *(_OWORD *)(v1 + 16) = xmmword_18EB382D0;
  Swift::String v2 = AggregationFunction.name()();
  char v3 = *(unsigned char *)(v0 + 193);
  *(Swift::String *)(v1 + 32) = v2;
  *(unsigned char *)(v1 + 48) = v3;
  return v1;
}

uint64_t SQLExpressionNonAggregationFunction.init(functionName:argList:)@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  swift_bridgeObjectRetain();
  v8._uint64_t countAndFlagsBits = a1;
  v8._object = a2;
  SQLFunction.init(rawValue:)(v8);
  char v9 = v23[0];
  if (LOBYTE(v23[0]) == 98)
  {
    swift_bridgeObjectRelease();
    type metadata accessor for SQLExpressionError();
    lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError();
    swift_allocError();
    *uint64_t v10 = a1;
    v10[1] = (uint64_t)a2;
    swift_storeEnumTagMultiPayload();
    return swift_willThrow();
  }
  else
  {
    swift_bridgeObjectRelease();
    BYTE1(v27) = v23[0];
    int64_t v12 = *(void *)(a3 + 16);
    if (v12)
    {
      uint64_t v22 = a4;
      uint64_t v26 = (void *)MEMORY[0x1E4FBC860];
      swift_bridgeObjectRetain_n();
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v12, 0);
      uint64_t v13 = a3 + 32;
      v14._rawValue = v26;
      do
      {
        outlined init with copy of Aggregation(v13, (uint64_t)v23);
        uint64_t v15 = v24;
        uint64_t v16 = v25;
        __swift_project_boxed_opaque_existential_1(v23, v24);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 16))(&v27, v15, v16);
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v23);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((void *)v14._rawValue + 2) + 1, 1);
          v14._rawValue = v26;
        }
        unint64_t v18 = *((void *)v14._rawValue + 2);
        unint64_t v17 = *((void *)v14._rawValue + 3);
        if (v18 >= v17 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v17 > 1), v18 + 1, 1);
          v14._rawValue = v26;
        }
        char v19 = v27;
        *((void *)v14._rawValue + 2) = v18 + 1;
        *((unsigned char *)v14._rawValue + v18 + 32) = v19;
        v13 += 40;
        --v12;
      }
      while (v12);
      swift_bridgeObjectRelease();
      a4 = v22;
    }
    else
    {
      swift_bridgeObjectRetain();
      v14._rawValue = (void *)MEMORY[0x1E4FBC860];
    }
    SQLFunction.returnType(argTypes:)(v14);
    swift_bridgeObjectRelease();
    if (v20)
    {
      swift_bridgeObjectRelease();
    }
    else
    {
      char v21 = BYTE2(v27);
      *(unsigned char *)a4 = v9;
      *(void *)(a4 + 8) = a3;
      *(unsigned char *)(a4 + 16) = v21;
    }
    return swift_bridgeObjectRelease();
  }
}

uint64_t SQLExpressionNonAggregationFunction.expressionString.getter()
{
  char v1 = *v0;
  uint64_t v2 = *((void *)v0 + 1);
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = MEMORY[0x1E4FBC860];
  if (v3)
  {
    uint64_t v24 = MEMORY[0x1E4FBC860];
    swift_bridgeObjectRetain();
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    uint64_t v5 = v2 + 32;
    uint64_t v4 = v24;
    do
    {
      outlined init with copy of Aggregation(v5, (uint64_t)v21);
      uint64_t v6 = v22;
      uint64_t v7 = v23;
      __swift_project_boxed_opaque_existential_1(v21, v22);
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
      uint64_t v10 = v9;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v21);
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v4 = v24;
      }
      unint64_t v11 = *(void *)(v4 + 16);
      if (v11 >= *(void *)(v4 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v4 = v24;
      }
      *(void *)(v4 + 16) = v11 + 1;
      uint64_t v12 = v4 + 16 * v11;
      *(void *)(v12 + 32) = v8;
      *(void *)(v12 + 40) = v10;
      v5 += 40;
      --v3;
    }
    while (v3);
    swift_bridgeObjectRelease();
  }
  v21[0] = v4;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  uint64_t v13 = BidirectionalCollection<>.joined(separator:)();
  uint64_t v15 = v14;
  swift_bridgeObjectRelease();
  LOBYTE(v21[0]) = v1;
  v21[0] = SQLFunction.rawValue.getter();
  v21[1] = v16;
  v17._uint64_t countAndFlagsBits = 40;
  v17._object = (void *)0xE100000000000000;
  String.append(_:)(v17);
  v18._uint64_t countAndFlagsBits = v13;
  v18._object = v15;
  String.append(_:)(v18);
  swift_bridgeObjectRelease();
  v19._uint64_t countAndFlagsBits = 41;
  v19._object = (void *)0xE100000000000000;
  String.append(_:)(v19);
  return v21[0];
}

uint64_t SQLExpressionNonAggregationFunction.aggregationFunctions.getter()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (!v2) {
    return MEMORY[0x1E4FBC860];
  }
  uint64_t v3 = v1 + 32;
  swift_bridgeObjectRetain_n();
  uint64_t v4 = MEMORY[0x1E4FBC860];
  while (1)
  {
    outlined init with copy of Aggregation(v3, (uint64_t)v16);
    uint64_t v5 = v17;
    uint64_t v6 = v18;
    __swift_project_boxed_opaque_existential_1(v16, v17);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 24))(v5, v6);
    uint64_t v8 = *(void *)(result + 16);
    uint64_t v9 = *(void *)(v4 + 16);
    uint64_t v10 = v9 + v8;
    if (__OFADD__(v9, v8)) {
      break;
    }
    uint64_t v11 = result;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if (result && v10 <= *(void *)(v4 + 24) >> 1)
    {
      if (*(void *)(v11 + 16)) {
        goto LABEL_14;
      }
    }
    else
    {
      if (v9 <= v10) {
        uint64_t v12 = v9 + v8;
      }
      else {
        uint64_t v12 = v9;
      }
      uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, v12, 1, v4);
      uint64_t v4 = result;
      if (*(void *)(v11 + 16))
      {
LABEL_14:
        if ((*(void *)(v4 + 24) >> 1) - *(void *)(v4 + 16) < v8) {
          goto LABEL_23;
        }
        uint64_t result = swift_arrayInitWithCopy();
        if (v8)
        {
          uint64_t v13 = *(void *)(v4 + 16);
          BOOL v14 = __OFADD__(v13, v8);
          uint64_t v15 = v13 + v8;
          if (v14) {
            goto LABEL_24;
          }
          *(void *)(v4 + 16) = v15;
        }
        goto LABEL_4;
      }
    }
    if (v8) {
      goto LABEL_22;
    }
LABEL_4:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v16);
    v3 += 40;
    if (!--v2)
    {
      swift_bridgeObjectRelease_n();
      return v4;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t SQLExpressionNonAggregationFunction.bindings.getter()
{
  uint64_t v1 = *(void *)(v0 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (!v2) {
    return MEMORY[0x1E4FBC860];
  }
  uint64_t v3 = v1 + 32;
  swift_bridgeObjectRetain_n();
  uint64_t v4 = MEMORY[0x1E4FBC860];
  while (1)
  {
    outlined init with copy of Aggregation(v3, (uint64_t)v16);
    uint64_t v5 = v17;
    uint64_t v6 = v18;
    __swift_project_boxed_opaque_existential_1(v16, v17);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 32))(v5, v6);
    uint64_t v8 = *(void *)(result + 16);
    int64_t v9 = *(void *)(v4 + 16);
    int64_t v10 = v9 + v8;
    if (__OFADD__(v9, v8)) {
      break;
    }
    uint64_t v11 = result;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native();
    if (result && v10 <= *(void *)(v4 + 24) >> 1)
    {
      if (*(void *)(v11 + 16)) {
        goto LABEL_14;
      }
    }
    else
    {
      if (v9 <= v10) {
        int64_t v12 = v9 + v8;
      }
      else {
        int64_t v12 = v9;
      }
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v12, 1, (char *)v4);
      uint64_t v4 = result;
      if (*(void *)(v11 + 16))
      {
LABEL_14:
        if ((*(void *)(v4 + 24) >> 1) - *(void *)(v4 + 16) < v8) {
          goto LABEL_23;
        }
        uint64_t result = swift_arrayInitWithCopy();
        if (v8)
        {
          uint64_t v13 = *(void *)(v4 + 16);
          BOOL v14 = __OFADD__(v13, v8);
          uint64_t v15 = v13 + v8;
          if (v14) {
            goto LABEL_24;
          }
          *(void *)(v4 + 16) = v15;
        }
        goto LABEL_4;
      }
    }
    if (v8) {
      goto LABEL_22;
    }
LABEL_4:
    swift_bridgeObjectRelease();
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v16);
    v3 += 40;
    if (!--v2)
    {
      swift_bridgeObjectRelease_n();
      return v4;
    }
  }
  __break(1u);
LABEL_22:
  __break(1u);
LABEL_23:
  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t protocol witness for SQLExpressionNode.sql() in conformance SQLExpressionNonAggregationFunction()
{
  return specialized SQLExpressionNode.sql()(*(unsigned char *)v0, *(void *)(v0 + 8));
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  return 0x6973736572707865;
}

void protocol witness for CodingKey.init(intValue:) in conformance AggregationFunction.AggregationType.AVGCodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 1;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.AVGCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.COUNTCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.COUNTCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = swift_bridgeObjectRelease();
  *a1 = 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLExpression.CodingKeys()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.CodingKeys()
{
  uint64_t result = 4675137;
  switch(*v0)
  {
    case 1:
      uint64_t result = 0x544E554F43;
      break;
    case 2:
      uint64_t result = 0x54535F544E554F43;
      break;
    case 3:
      uint64_t result = 0x4F435F50554F5247;
      break;
    case 4:
      uint64_t result = 5783885;
      break;
    case 5:
      uint64_t result = 5130573;
      break;
    case 6:
      uint64_t result = 5068115;
      break;
    case 7:
      uint64_t result = 0x4C41544F54;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized AggregationFunction.AggregationType.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance AggregationFunction.AggregationType.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 8;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  if (*v0) {
    return 0x6F74617261706573;
  }
  else {
    return 0x6973736572707865;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized AggregationFunction.AggregationType.GROUP_CONCATCodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.MAXCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.MAXCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.MINCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.MINCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.SUMCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.SUMCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.AggregationType.AVGCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL)
  {
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = 0;
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.AggregationType.TOTALCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.AggregationType.TOTALCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t AggregationFunction.AggregationType.encode(to:)(void *a1)
{
  uint64_t v48 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.TOTALCodingKeys>);
  uint64_t v53 = *(void *)(v48 - 8);
  MEMORY[0x1F4188790](v48);
  uint64_t v47 = (char *)&v33 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v46 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.SUMCodingKeys>);
  uint64_t v52 = *(void *)(v46 - 8);
  MEMORY[0x1F4188790](v46);
  uint64_t v45 = (char *)&v33 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v44 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.MINCodingKeys>);
  uint64_t v51 = *(void *)(v44 - 8);
  MEMORY[0x1F4188790](v44);
  uint64_t v42 = (char *)&v33 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v41 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.MAXCodingKeys>);
  uint64_t v49 = *(void *)(v41 - 8);
  MEMORY[0x1F4188790](v41);
  uint64_t v39 = (char *)&v33 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v43 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.GROUP_CONCATCodingKeys>);
  uint64_t v50 = *(void *)(v43 - 8);
  MEMORY[0x1F4188790](v43);
  uint64_t v40 = (char *)&v33 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.COUNT_STARCodingKeys>);
  uint64_t v35 = *(void *)(v7 - 8);
  uint64_t v36 = v7;
  MEMORY[0x1F4188790](v7);
  int64_t v9 = (char *)&v33 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.COUNTCodingKeys>);
  uint64_t v37 = *(void *)(v10 - 8);
  uint64_t v38 = v10;
  MEMORY[0x1F4188790](v10);
  int64_t v12 = (char *)&v33 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.AVGCodingKeys>);
  uint64_t v34 = *(void *)(v13 - 8);
  MEMORY[0x1F4188790](v13);
  uint64_t v15 = (char *)&v33 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v55 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.AggregationType.CodingKeys>);
  uint64_t v57 = *(void *)(v55 - 8);
  MEMORY[0x1F4188790](v55);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys();
  uint64_t v54 = v17;
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of AggregationFunction.AggregationType(v73, (uint64_t)&v66);
  switch(v72[96])
  {
    case 1:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 1;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys();
      char v21 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v22 = v38;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      (*(void (**)(char *, uint64_t))(v37 + 8))(v12, v22);
      outlined destroy of SQLExpression((uint64_t)&v60);
      uint64_t v23 = *(uint64_t (**)(char *, uint64_t))(v57 + 8);
      uint64_t v24 = v21;
      return v23(v24, v18);
    case 2:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      outlined init with take of SQLExpression?((uint64_t)v72, (uint64_t)v59, &demangling cache variable for type metadata for SQLExpression?);
      char v58 = 3;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys();
      uint64_t v25 = v40;
      uint64_t v27 = v54;
      uint64_t v26 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      char v58 = 0;
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v28 = v43;
      uint64_t v29 = v56;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      if (!v29)
      {
        char v58 = 1;
        KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
      }
      (*(void (**)(char *, uint64_t))(v50 + 8))(v25, v28);
      outlined destroy of AnyValue?((uint64_t)v59, &demangling cache variable for type metadata for SQLExpression?);
      outlined destroy of SQLExpression((uint64_t)&v60);
      return (*(uint64_t (**)(char *, uint64_t))(v57 + 8))(v27, v26);
    case 3:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 4;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys();
      uint64_t v15 = v39;
      Swift::String v19 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v13 = v41;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      uint64_t v20 = v49;
      goto LABEL_11;
    case 4:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 5;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys();
      uint64_t v15 = v42;
      Swift::String v19 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v13 = v44;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      uint64_t v20 = v51;
      goto LABEL_11;
    case 5:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 6;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys();
      uint64_t v15 = v45;
      Swift::String v19 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v13 = v46;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      uint64_t v20 = v52;
      goto LABEL_11;
    case 6:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 7;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys();
      uint64_t v15 = v47;
      Swift::String v19 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      uint64_t v13 = v48;
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      uint64_t v20 = v53;
      goto LABEL_11;
    case 7:
      LOBYTE(v60) = 2;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys();
      uint64_t v31 = v54;
      uint64_t v32 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      (*(void (**)(char *, uint64_t))(v35 + 8))(v9, v36);
      return (*(uint64_t (**)(char *, uint64_t))(v57 + 8))(v31, v32);
    default:
      long long v62 = v68;
      long long v63 = v69;
      long long v64 = v70;
      long long v65 = v71;
      long long v60 = v66;
      long long v61 = v67;
      v59[0] = 0;
      lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys();
      Swift::String v19 = v54;
      uint64_t v18 = v55;
      KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
      lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
      KeyedEncodingContainer.encode<A>(_:forKey:)();
      uint64_t v20 = v34;
LABEL_11:
      (*(void (**)(char *, uint64_t))(v20 + 8))(v15, v13);
      outlined destroy of SQLExpression((uint64_t)&v60);
      uint64_t v23 = *(uint64_t (**)(char *, uint64_t))(v57 + 8);
      uint64_t v24 = v19;
      return v23(v24, v18);
  }
}

uint64_t protocol witness for Encodable.encode(to:) in conformance AggregationFunction.AggregationType(void *a1)
{
  return AggregationFunction.AggregationType.encode(to:)(a1);
}

uint64_t AggregationFunction.init(functionName:args:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a1 == 6780513 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    uint64_t v8 = *(void *)(a3 + 16);
    if (v8)
    {
      if (v8 == 1)
      {
        swift_bridgeObjectRelease();
        if (*(void *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
          swift_bridgeObjectRelease();
          uint64_t v9 = v123;
          uint64_t v10 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          uint64_t v11 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(v9, v10) + 16);
          swift_bridgeObjectRelease();
          if (v11)
          {
LABEL_8:
            uint64_t v12 = v123;
            uint64_t v13 = v124;
            __swift_project_boxed_opaque_existential_1(v122, v123);
            uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(v12, v13);
            uint64_t v16 = v15;
            lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
            swift_allocError();
            *(void *)uint64_t v17 = v14;
            *(void *)(v17 + 8) = v16;
            *(void *)(v17 + 16) = 0;
            *(void *)(v17 + 24) = 0;
            *(unsigned char *)(v17 + 32) = 3;
            swift_willThrow();
            return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
          }
          outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
          SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
          __int16 v23 = 256;
          goto LABEL_26;
        }
        __break(1u);
        goto LABEL_103;
      }
      uint64_t v138 = v6;
      uint64_t v116 = v5;
      v119[0] = MEMORY[0x1E4FBC860];
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
      uint64_t v24 = a3 + 32;
      uint64_t v25 = v119[0];
      do
      {
        outlined init with copy of Aggregation(v24, (uint64_t)v122);
        uint64_t v26 = v123;
        uint64_t v27 = v124;
        __swift_project_boxed_opaque_existential_1(v122, v123);
        uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 40))(v26, v27);
        uint64_t v30 = v29;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v25 = v119[0];
        }
        unint64_t v31 = *(void *)(v25 + 16);
        if (v31 >= *(void *)(v25 + 24) >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v25 = v119[0];
        }
        *(void *)(v25 + 16) = v31 + 1;
        uint64_t v32 = v25 + 16 * v31;
        *(void *)(v32 + 32) = v28;
        *(void *)(v32 + 40) = v30;
        v24 += 40;
        --v8;
      }
      while (v8);
      goto LABEL_59;
    }
LABEL_92:
    swift_bridgeObjectRelease();
    uint64_t v25 = MEMORY[0x1E4FBC860];
    goto LABEL_93;
  }
  if (v6 == 0x746E756F63 && v5 == 0xE500000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    uint64_t v19 = *(void *)(a3 + 16);
    if (!v19)
    {
      swift_bridgeObjectRelease();
      uint64_t result = swift_bridgeObjectRelease();
      long long v135 = 0u;
      long long v136 = 0u;
      long long v133 = 0u;
      long long v134 = 0u;
      long long v131 = 0u;
      long long v132 = 0u;
      long long v129 = 0u;
      long long v130 = 0u;
      long long v127 = 0u;
      long long v128 = 0u;
      long long v126 = 0u;
      long long v125 = 0u;
      __int16 v137 = 7;
      goto LABEL_39;
    }
    if (v19 != 1)
    {
      uint64_t v138 = v6;
      v119[0] = MEMORY[0x1E4FBC860];
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
      uint64_t v49 = a3 + 32;
      uint64_t v25 = v119[0];
      do
      {
        outlined init with copy of Aggregation(v49, (uint64_t)v122);
        uint64_t v50 = v123;
        uint64_t v51 = v124;
        __swift_project_boxed_opaque_existential_1(v122, v123);
        uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(v51 + 40))(v50, v51);
        uint64_t v54 = v53;
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v25 = v119[0];
        }
        unint64_t v55 = *(void *)(v25 + 16);
        if (v55 >= *(void *)(v25 + 24) >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v25 = v119[0];
        }
        *(void *)(v25 + 16) = v55 + 1;
        uint64_t v56 = v25 + 16 * v55;
        *(void *)(v56 + 32) = v52;
        *(void *)(v56 + 40) = v54;
        v49 += 40;
        --v19;
      }
      while (v19);
      swift_bridgeObjectRelease();
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(void *)uint64_t v57 = v138;
      *(void *)(v57 + 8) = v5;
      goto LABEL_94;
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a3 + 16))
    {
      outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
      swift_bridgeObjectRelease();
      uint64_t v20 = v123;
      uint64_t v21 = v124;
      __swift_project_boxed_opaque_existential_1(v122, v123);
      uint64_t v22 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v21 + 24))(v20, v21) + 16);
      swift_bridgeObjectRelease();
      if (v22) {
        goto LABEL_8;
      }
      outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
      SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
      __int16 v23 = 1;
      goto LABEL_26;
    }
    __break(1u);
LABEL_113:
    char v112 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
    if ((v112 & 1) == 0)
    {
      uint64_t v113 = v120;
      uint64_t v114 = v121;
      __swift_project_boxed_opaque_existential_1(v119, v120);
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v114 + 16))(v118, v113, v114);
      switch(LOBYTE(v118[0]))
      {
        case 7:
          swift_bridgeObjectRelease();
          break;
        default:
          goto LABEL_119;
      }
    }
LABEL_114:
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v119);
    HIBYTE(v137) = 0;
    goto LABEL_27;
  }
  if (v6 == 0x6F635F70756F7267 && v5 == 0xEC0000007461636ELL
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    uint64_t v33 = *(void *)(a3 + 16);
    if (!v33) {
      goto LABEL_92;
    }
    if (v33 != 1)
    {
      if (v33 != 2)
      {
        uint64_t v138 = v6;
        uint64_t v116 = v5;
        v119[0] = MEMORY[0x1E4FBC860];
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v61 = a3 + 32;
        uint64_t v25 = v119[0];
        do
        {
          outlined init with copy of Aggregation(v61, (uint64_t)v122);
          uint64_t v62 = v123;
          uint64_t v63 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(v63 + 40))(v62, v63);
          uint64_t v66 = v65;
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v25 = v119[0];
          }
          unint64_t v67 = *(void *)(v25 + 16);
          if (v67 >= *(void *)(v25 + 24) >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v25 = v119[0];
          }
          *(void *)(v25 + 16) = v67 + 1;
          uint64_t v68 = v25 + 16 * v67;
          *(void *)(v68 + 32) = v64;
          *(void *)(v68 + 40) = v66;
          v61 += 40;
          --v33;
        }
        while (v33);
LABEL_59:
        swift_bridgeObjectRelease();
        uint64_t v5 = v116;
        uint64_t v6 = v138;
LABEL_93:
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(void *)uint64_t v57 = v6;
        *(void *)(v57 + 8) = v5;
LABEL_94:
        *(void *)(v57 + 16) = v25;
        *(void *)(v57 + 24) = 0;
        *(unsigned char *)(v57 + 32) = 4;
        return swift_willThrow();
      }
      swift_bridgeObjectRelease();
      uint64_t v34 = *(void *)(a3 + 16);
      if (v34)
      {
        outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
        if (v34 != 1)
        {
          outlined init with copy of Aggregation(a3 + 72, (uint64_t)v119);
          swift_bridgeObjectRelease();
          uint64_t v35 = v123;
          uint64_t v36 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          uint64_t v37 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v36 + 24))(v35, v36) + 16);
          swift_bridgeObjectRelease();
          if (v37)
          {
            uint64_t v38 = v123;
            uint64_t v39 = v124;
            uint64_t v40 = v122;
          }
          else
          {
            uint64_t v73 = v120;
            uint64_t v74 = v121;
            __swift_project_boxed_opaque_existential_1(v119, v120);
            uint64_t v75 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v74 + 24))(v73, v74) + 16);
            swift_bridgeObjectRelease();
            if (!v75)
            {
              outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v118);
              SQLExpression.init(rootNode:)((uint64_t)v118, (uint64_t)&v125);
              outlined init with copy of Aggregation((uint64_t)v119, (uint64_t)v118);
              SQLExpression.init(rootNode:)((uint64_t)v118, (uint64_t)&v131);
              __int16 v137 = 514;
              __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v119);
              goto LABEL_27;
            }
            uint64_t v38 = v120;
            uint64_t v39 = v121;
            uint64_t v40 = v119;
          }
          __swift_project_boxed_opaque_existential_1(v40, v38);
          uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(v39 + 40))(v38, v39);
          uint64_t v78 = v77;
          lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
          swift_allocError();
          *(void *)uint64_t v79 = v76;
          *(void *)(v79 + 8) = v78;
          *(void *)(v79 + 16) = 0;
          *(void *)(v79 + 24) = 0;
          *(unsigned char *)(v79 + 32) = 3;
          swift_willThrow();
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v119);
          return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
        }
      }
      else
      {
        __break(1u);
      }
      __break(1u);
LABEL_118:
      __break(1u);
LABEL_119:
      char v115 = _stringCompareWithSmolCheck(_:_:expecting:)();
      swift_bridgeObjectRelease();
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v119);
      HIBYTE(v137) = (v115 & 1) == 0;
      goto LABEL_27;
    }
    swift_bridgeObjectRelease();
    if (!*(void *)(a3 + 16)) {
      goto LABEL_118;
    }
    outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
    swift_bridgeObjectRelease();
    uint64_t v58 = v123;
    uint64_t v59 = v124;
    __swift_project_boxed_opaque_existential_1(v122, v123);
    uint64_t v60 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v59 + 24))(v58, v59) + 16);
    swift_bridgeObjectRelease();
    if (v60) {
      goto LABEL_8;
    }
    outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
    SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
    long long v131 = 0u;
    long long v132 = 0u;
    long long v133 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    long long v136 = 0u;
    __int16 v23 = 514;
LABEL_26:
    __int16 v137 = v23;
LABEL_27:
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
LABEL_39:
    long long v41 = v134;
    long long v42 = v136;
    *(_OWORD *)(a4 + 160) = v135;
    *(_OWORD *)(a4 + 176) = v42;
    long long v43 = v130;
    long long v44 = v132;
    long long v45 = v133;
    *(_OWORD *)(a4 + 96) = v131;
    *(_OWORD *)(a4 + 112) = v44;
    *(_OWORD *)(a4 + 128) = v45;
    *(_OWORD *)(a4 + 144) = v41;
    long long v46 = v126;
    long long v47 = v128;
    long long v48 = v129;
    *(_OWORD *)(a4 + 32) = v127;
    *(_OWORD *)(a4 + 48) = v47;
    *(_WORD *)(a4 + 192) = v137;
    *(_OWORD *)(a4 + 64) = v48;
    *(_OWORD *)(a4 + 80) = v43;
    *(_OWORD *)a4 = v125;
    *(_OWORD *)(a4 + 16) = v46;
    return result;
  }
  if (v6 == 7889261 && v5 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    if (*(void *)(a3 + 16) == 1)
    {
      outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
      swift_bridgeObjectRelease();
      uint64_t v69 = v123;
      uint64_t v70 = v124;
      __swift_project_boxed_opaque_existential_1(v122, v123);
      uint64_t v71 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v70 + 24))(v69, v70) + 16);
      swift_bridgeObjectRelease();
      if (v71) {
        goto LABEL_8;
      }
      outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
      SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
      char v72 = 3;
      goto LABEL_73;
    }
  }
  else
  {
    if ((v6 != 7235949 || v5 != 0xE300000000000000) && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      if (v6 == 7173491 && v5 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
      {
        uint64_t v85 = *(void *)(a3 + 16);
        if (!v85) {
          goto LABEL_92;
        }
        if (v85 != 1)
        {
          uint64_t v138 = v6;
          uint64_t v95 = v5;
          v119[0] = MEMORY[0x1E4FBC860];
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v96 = a3 + 32;
          uint64_t v25 = v119[0];
          do
          {
            outlined init with copy of Aggregation(v96, (uint64_t)v122);
            uint64_t v97 = v123;
            uint64_t v98 = v124;
            __swift_project_boxed_opaque_existential_1(v122, v123);
            uint64_t v99 = (*(uint64_t (**)(uint64_t, uint64_t))(v98 + 40))(v97, v98);
            uint64_t v101 = v100;
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              uint64_t v25 = v119[0];
            }
            unint64_t v102 = *(void *)(v25 + 16);
            if (v102 >= *(void *)(v25 + 24) >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              uint64_t v25 = v119[0];
            }
            *(void *)(v25 + 16) = v102 + 1;
            uint64_t v103 = v25 + 16 * v102;
            *(void *)(v103 + 32) = v99;
            *(void *)(v103 + 40) = v101;
            v96 += 40;
            --v85;
          }
          while (v85);
          swift_bridgeObjectRelease();
          uint64_t v5 = v95;
          uint64_t v6 = v138;
          goto LABEL_93;
        }
        swift_bridgeObjectRelease();
        if (*(void *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
          swift_bridgeObjectRelease();
          uint64_t v86 = v123;
          uint64_t v87 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          uint64_t v88 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v87 + 24))(v86, v87) + 16);
          swift_bridgeObjectRelease();
          if (v88) {
            goto LABEL_8;
          }
          outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
          SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
          LOBYTE(v137) = 5;
          uint64_t v89 = v123;
          uint64_t v90 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v90 + 16))(v119, v89, v90);
          switch(LOBYTE(v119[0]))
          {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              goto LABEL_113;
            default:
              swift_bridgeObjectRelease();
              outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
              break;
          }
          goto LABEL_114;
        }
        __break(1u);
      }
      else
      {
        if ((v6 != 0x6C61746F74 || v5 != 0xE500000000000000)
          && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
        {
LABEL_103:
          swift_bridgeObjectRelease();
          goto LABEL_104;
        }
        uint64_t v91 = *(void *)(a3 + 16);
        if (!v91) {
          goto LABEL_92;
        }
        if (v91 != 1)
        {
          uint64_t v117 = v5;
          v119[0] = MEMORY[0x1E4FBC860];
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
          uint64_t v104 = a3 + 32;
          uint64_t v25 = v119[0];
          do
          {
            outlined init with copy of Aggregation(v104, (uint64_t)v122);
            uint64_t v105 = v123;
            uint64_t v106 = v124;
            __swift_project_boxed_opaque_existential_1(v122, v123);
            uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v106 + 40))(v105, v106);
            uint64_t v109 = v108;
            __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)v122);
            if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              uint64_t v25 = v119[0];
            }
            unint64_t v110 = *(void *)(v25 + 16);
            if (v110 >= *(void *)(v25 + 24) >> 1)
            {
              specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
              uint64_t v25 = v119[0];
            }
            *(void *)(v25 + 16) = v110 + 1;
            uint64_t v111 = v25 + 16 * v110;
            *(void *)(v111 + 32) = v107;
            *(void *)(v111 + 40) = v109;
            v104 += 40;
            --v91;
          }
          while (v91);
          swift_bridgeObjectRelease();
          uint64_t v5 = v117;
          goto LABEL_93;
        }
        swift_bridgeObjectRelease();
        if (*(void *)(a3 + 16))
        {
          outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
          swift_bridgeObjectRelease();
          uint64_t v92 = v123;
          uint64_t v93 = v124;
          __swift_project_boxed_opaque_existential_1(v122, v123);
          uint64_t v94 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v93 + 24))(v92, v93) + 16);
          swift_bridgeObjectRelease();
          if (v94) {
            goto LABEL_8;
          }
          outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
          SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
          __int16 v23 = 262;
          goto LABEL_26;
        }
      }
      __break(1u);
      JUMPOUT(0x18EA4F950);
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a3 + 16) == 1)
    {
      outlined init with copy of Aggregation(a3 + 32, (uint64_t)v122);
      swift_bridgeObjectRelease();
      uint64_t v80 = v123;
      uint64_t v81 = v124;
      __swift_project_boxed_opaque_existential_1(v122, v123);
      uint64_t v82 = *(void *)((*(uint64_t (**)(uint64_t, uint64_t))(v81 + 24))(v80, v81) + 16);
      swift_bridgeObjectRelease();
      if (v82) {
        goto LABEL_8;
      }
      outlined init with copy of Aggregation((uint64_t)v122, (uint64_t)v119);
      SQLExpression.init(rootNode:)((uint64_t)v119, (uint64_t)&v125);
      char v72 = 4;
LABEL_73:
      LOBYTE(v137) = v72;
      uint64_t v83 = v123;
      uint64_t v84 = v124;
      __swift_project_boxed_opaque_existential_1(v122, v123);
      (*(void (**)(char *__return_ptr, uint64_t, uint64_t))(v84 + 16))((char *)&v137 + 1, v83, v84);
      goto LABEL_27;
    }
  }
LABEL_104:
  uint64_t result = swift_bridgeObjectRelease();
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_WORD *)(a4 + 192) = 255;
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance AggregationFunction.CodingKeys()
{
  if (*v0) {
    return 0x79546E7275746572;
  }
  else {
    return 0x7461676572676761;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance AggregationFunction.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized AggregationFunction.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AggregationFunction.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AggregationFunction.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t AggregationFunction.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<AggregationFunction.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = &v10[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v10[15] = 0;
  lazy protocol witness table accessor for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    v10[14] = *(unsigned char *)(v3 + 193);
    v10[13] = 1;
    lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance AggregationFunction(void *a1)
{
  return AggregationFunction.encode(to:)(a1);
}

uint64_t static AggregationFunction.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  char v4 = specialized static AggregationFunction.AggregationType.== infix(_:_:)(a1, a2);
  outlined init with copy of AggregationFunction(a1, (uint64_t)v8);
  outlined init with copy of AggregationFunction(a2, (uint64_t)v7);
  if (v4) {
    char v5 = specialized == infix<A>(_:_:)(v8[193], v7[193]);
  }
  else {
    char v5 = 0;
  }
  outlined destroy of AggregationFunction((uint64_t)v7);
  outlined destroy of AggregationFunction((uint64_t)v8);
  return v5 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AggregationFunction(uint64_t a1, uint64_t a2)
{
  char v4 = specialized static AggregationFunction.AggregationType.== infix(_:_:)(a1, a2);
  outlined init with copy of AggregationFunction(a1, (uint64_t)v8);
  outlined init with copy of AggregationFunction(a2, (uint64_t)v7);
  if (v4) {
    char v5 = specialized == infix<A>(_:_:)(v8[193], v7[193]);
  }
  else {
    char v5 = 0;
  }
  outlined destroy of AggregationFunction((uint64_t)v7);
  outlined destroy of AggregationFunction((uint64_t)v8);
  return v5 & 1;
}

uint64_t SQLExpressionFuncCall.init(function:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v39 = a6;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v12 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node - 8);
  uint64_t v14 = (char *)&v36 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t result = type metadata accessor for PgQuery_FuncCall(0);
  uint64_t v16 = *(int *)(result + 20);
  uint64_t v67 = a1;
  uint64_t v17 = *(void *)(*(void *)(a1 + v16) + 16);
  if (*(void *)(v17 + 16))
  {
    outlined init with copy of PgQuery_Node(v17 + ((*(unsigned __int8 *)(v12 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80)), (uint64_t)v14, type metadata accessor for PgQuery_Node);
    uint64_t v18 = a2;
    uint64_t v19 = a2;
    uint64_t v20 = a3;
    uint64_t v21 = a3;
    uint64_t v22 = a4;
    __int16 v23 = v40;
    buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(&v54, v14, v19, v21, a4, a5);
    if (v23)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of SQLExpressionError(v67, type metadata accessor for PgQuery_FuncCall);
      outlined destroy of SQLExpressionError((uint64_t)v14, type metadata accessor for PgQuery_Node);
      return outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
    }
    else
    {
      outlined destroy of SQLExpressionError((uint64_t)v14, type metadata accessor for PgQuery_Node);
      uint64_t v38 = 0;
      uint64_t v25 = *((void *)&v55 + 1);
      uint64_t v24 = v56;
      __swift_project_boxed_opaque_existential_1(&v54, *((uint64_t *)&v55 + 1));
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(v25, v24);
      uint64_t v27 = v26;
      uint64_t v28 = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)&v54);
      uint64_t v40 = &v36;
      uint64_t v29 = *(void *)(*(void *)(v67 + v16) + 24);
      MEMORY[0x1F4188790](v28);
      *(&v36 - 4) = v18;
      *(&v36 - 3) = v20;
      *(&v36 - 2) = v22;
      *(&v36 - 1) = a5;
      swift_bridgeObjectRetain();
      uint64_t v30 = v38;
      uint64_t NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5((void (*)(long long *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:), (uint64_t)(&v36 - 6), v29);
      if (v30)
      {
        swift_bridgeObjectRelease();
        outlined destroy of SQLExpressionError(v67, type metadata accessor for PgQuery_FuncCall);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
      }
      else
      {
        uint64_t v32 = NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5;
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        uint64_t v33 = v37;
        AggregationFunction.init(functionName:args:)(v37, (uint64_t)v27, v32, (uint64_t)&v41);
        if (v53 != 0xFF)
        {
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          long long v64 = v51;
          long long v65 = v52;
          __int16 v66 = v53;
          long long v60 = v47;
          long long v61 = v48;
          long long v62 = v49;
          long long v63 = v50;
          long long v56 = v43;
          long long v57 = v44;
          long long v58 = v45;
          long long v59 = v46;
          long long v54 = v41;
          long long v55 = v42;
          *((void *)&v42 + 1) = &unk_1EDD75C30;
          *(void *)&long long v43 = &protocol witness table for SQLExpressionAggregationFunction;
          uint64_t v35 = swift_allocObject();
          *(void *)&long long v41 = v35;
          outlined init with copy of AggregationFunction((uint64_t)&v54, v35 + 16);
          *(void *)(v35 + 216) = 63;
          *(void *)(v35 + 224) = 0xE100000000000000;
          outlined destroy of SQLExpressionError(v67, type metadata accessor for PgQuery_FuncCall);
          outlined destroy of AggregationFunction((uint64_t)&v54);
          outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
          uint64_t v34 = &v41;
        }
        else
        {
          outlined destroy of AnyValue?((uint64_t)&v41, (uint64_t *)&demangling cache variable for type metadata for AggregationFunction?);
          *((void *)&v55 + 1) = &unk_1EDD75CE0;
          *(void *)&long long v56 = &protocol witness table for SQLExpressionNonAggregationFunction;
          SQLExpressionNonAggregationFunction.init(functionName:argList:)(v33, v27, v32, (uint64_t)&v54);
          outlined destroy of SQLExpressionError(v67, type metadata accessor for PgQuery_FuncCall);
          outlined destroy of SQLExpressionError(a5, type metadata accessor for SQLTokenInformation);
          uint64_t v34 = &v54;
        }
        return outlined init with take of Aggregation(v34, v39);
      }
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t protocol witness for SQLExpressionNode.expressionString.getter in conformance SQLExpressionConst()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
}

uint64_t protocol witness for SQLExpressionNode.returnType.getter in conformance SQLExpressionConst()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_1(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v1, v2);
}

uint64_t SQLExpression.hash(into:)(uint64_t a1)
{
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  uint64_t v3 = *(void *)(v1 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)(a1, v3);

  return swift_bridgeObjectRelease();
}

Swift::Int SQLExpression.hashValue.getter()
{
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  uint64_t v1 = *(void *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLExpression()
{
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  uint64_t v1 = *(void *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLExpression(uint64_t a1)
{
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  uint64_t v3 = *(void *)(v1 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)(a1, v3);

  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLExpression()
{
  Hasher.init(_seed:)();
  swift_bridgeObjectRetain();
  String.hash(into:)();
  swift_bridgeObjectRelease();
  uint64_t v1 = *(void *)(v0 + 72);
  swift_bridgeObjectRetain();
  specialized Array<A>.hash(into:)((uint64_t)v3, v1);
  swift_bridgeObjectRelease();
  return Hasher._finalize()();
}

uint64_t specialized _NativeDictionary.filter(_:)(uint64_t isStackAllocationSafe)
{
  uint64_t v2 = isStackAllocationSafe;
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  char v3 = *(unsigned char *)(isStackAllocationSafe + 32);
  int64_t v84 = (unint64_t)((1 << v3) + 63) >> 6;
  size_t v4 = 8 * v84;
  if ((v3 & 0x3Fu) > 0xD)
  {
    isStackAllocationSafe = swift_stdlib_isStackAllocationSafe();
    if ((isStackAllocationSafe & 1) == 0)
    {
      uint64_t v83 = (unint64_t *)swift_slowAlloc();
      bzero(v83, v4);
      uint64_t v19 = 0;
      int64_t v20 = 0;
      uint64_t v21 = v2 + 64;
      uint64_t v22 = 1 << *(unsigned char *)(v2 + 32);
      if (v22 < 64) {
        uint64_t v23 = ~(-1 << v22);
      }
      else {
        uint64_t v23 = -1;
      }
      unint64_t v24 = v23 & *(void *)(v2 + 64);
      int64_t v25 = (unint64_t)(v22 + 63) >> 6;
      uint64_t v26 = v83;
      while (1)
      {
        if (v24)
        {
          unint64_t v27 = __clz(__rbit64(v24));
          v24 &= v24 - 1;
          unint64_t v28 = v27 | (v20 << 6);
        }
        else
        {
          int64_t v29 = v20 + 1;
          if (__OFADD__(v20, 1)) {
            goto LABEL_132;
          }
          if (v29 >= v25) {
            goto LABEL_58;
          }
          unint64_t v30 = *(void *)(v21 + 8 * v29);
          ++v20;
          if (!v30)
          {
            int64_t v20 = v29 + 1;
            if (v29 + 1 >= v25) {
              goto LABEL_58;
            }
            unint64_t v30 = *(void *)(v21 + 8 * v20);
            if (!v30)
            {
              int64_t v20 = v29 + 2;
              if (v29 + 2 >= v25) {
                goto LABEL_58;
              }
              unint64_t v30 = *(void *)(v21 + 8 * v20);
              if (!v30)
              {
                int64_t v20 = v29 + 3;
                if (v29 + 3 >= v25) {
                  goto LABEL_58;
                }
                unint64_t v30 = *(void *)(v21 + 8 * v20);
                if (!v30)
                {
                  int64_t v31 = v29 + 4;
                  if (v31 >= v25) {
                    goto LABEL_58;
                  }
                  unint64_t v30 = *(void *)(v21 + 8 * v31);
                  if (!v30)
                  {
                    while (1)
                    {
                      int64_t v20 = v31 + 1;
                      if (__OFADD__(v31, 1)) {
                        goto LABEL_136;
                      }
                      if (v20 >= v25) {
                        break;
                      }
                      unint64_t v30 = *(void *)(v21 + 8 * v20);
                      ++v31;
                      if (v30) {
                        goto LABEL_54;
                      }
                    }
LABEL_58:
                    if (!v19)
                    {
                      uint64_t v2 = MEMORY[0x1E4FBC868];
                      goto LABEL_128;
                    }
                    if (v19 == *(void *)(v2 + 16))
                    {
                      swift_retain();
                      goto LABEL_128;
                    }
                    uint64_t v82 = v1;
                    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
                    uint64_t v56 = static _DictionaryStorage.allocate(capacity:)();
                    int64_t v57 = 0;
                    unint64_t v58 = *v83;
                    uint64_t v59 = v56 + 64;
                    while (1)
                    {
                      if (v58)
                      {
                        unint64_t v62 = __clz(__rbit64(v58));
                        v58 &= v58 - 1;
                        int64_t v85 = v57;
                        unint64_t v63 = v62 | (v57 << 6);
                      }
                      else
                      {
                        int64_t v64 = v57 + 1;
                        if (__OFADD__(v57, 1)) {
                          goto LABEL_135;
                        }
                        if (v64 >= v84) {
                          goto LABEL_127;
                        }
                        unint64_t v65 = v83[v64];
                        int64_t v66 = v57 + 1;
                        if (!v65)
                        {
                          int64_t v66 = v57 + 2;
                          if (v57 + 2 >= v84) {
                            goto LABEL_127;
                          }
                          unint64_t v65 = v83[v66];
                          if (!v65)
                          {
                            int64_t v66 = v57 + 3;
                            if (v57 + 3 >= v84) {
                              goto LABEL_127;
                            }
                            unint64_t v65 = v83[v66];
                            if (!v65)
                            {
                              int64_t v66 = v57 + 4;
                              if (v57 + 4 >= v84) {
                                goto LABEL_127;
                              }
                              unint64_t v65 = v83[v66];
                              if (!v65)
                              {
                                int64_t v66 = v57 + 5;
                                if (v57 + 5 >= v84) {
                                  goto LABEL_127;
                                }
                                unint64_t v65 = v83[v66];
                                if (!v65)
                                {
                                  uint64_t v67 = v57 + 6;
                                  if (v57 + 6 >= v84) {
                                    goto LABEL_127;
                                  }
                                  unint64_t v65 = v83[v67];
                                  if (!v65)
                                  {
                                    while (1)
                                    {
                                      int64_t v66 = v67 + 1;
                                      if (__OFADD__(v67, 1)) {
                                        goto LABEL_138;
                                      }
                                      if (v66 >= v84) {
                                        break;
                                      }
                                      unint64_t v65 = v83[v66];
                                      ++v67;
                                      if (v65) {
                                        goto LABEL_117;
                                      }
                                    }
LABEL_127:
                                    uint64_t v2 = v56;
LABEL_128:
                                    MEMORY[0x192FB1900](v83, -1, -1);
                                    return v2;
                                  }
                                  int64_t v66 = v57 + 6;
                                }
                              }
                            }
                          }
                        }
LABEL_117:
                        unint64_t v58 = (v65 - 1) & v65;
                        int64_t v85 = v66;
                        unint64_t v63 = __clz(__rbit64(v65)) + (v66 << 6);
                      }
                      uint64_t v68 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v63);
                      uint64_t v70 = *v68;
                      uint64_t v69 = v68[1];
                      uint64_t v71 = *(void *)(*(void *)(v2 + 56) + 8 * v63);
                      Hasher.init(_seed:)();
                      swift_bridgeObjectRetain();
                      String.hash(into:)();
                      Swift::Int v72 = Hasher._finalize()();
                      uint64_t v73 = -1 << *(unsigned char *)(v56 + 32);
                      unint64_t v74 = v72 & ~v73;
                      unint64_t v75 = v74 >> 6;
                      if (((-1 << v74) & ~*(void *)(v59 + 8 * (v74 >> 6))) != 0)
                      {
                        unint64_t v60 = __clz(__rbit64((-1 << v74) & ~*(void *)(v59 + 8 * (v74 >> 6)))) | v74 & 0x7FFFFFFFFFFFFFC0;
                      }
                      else
                      {
                        char v76 = 0;
                        unint64_t v77 = (unint64_t)(63 - v73) >> 6;
                        do
                        {
                          if (++v75 == v77 && (v76 & 1) != 0) {
                            goto LABEL_131;
                          }
                          BOOL v78 = v75 == v77;
                          if (v75 == v77) {
                            unint64_t v75 = 0;
                          }
                          v76 |= v78;
                          uint64_t v79 = *(void *)(v59 + 8 * v75);
                        }
                        while (v79 == -1);
                        unint64_t v60 = __clz(__rbit64(~v79)) + (v75 << 6);
                      }
                      *(void *)(v59 + ((v60 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v60;
                      long long v61 = (void *)(*(void *)(v56 + 48) + 16 * v60);
                      *long long v61 = v70;
                      v61[1] = v69;
                      *(void *)(*(void *)(v56 + 56) + 8 * v60) = v71;
                      ++*(void *)(v56 + 16);
                      --v19;
                      int64_t v57 = v85;
                      if (!v19) {
                        goto LABEL_127;
                      }
                    }
                  }
                  int64_t v20 = v31;
                }
              }
            }
          }
LABEL_54:
          unint64_t v24 = (v30 - 1) & v30;
          unint64_t v28 = __clz(__rbit64(v30)) + (v20 << 6);
        }
        if (*(uint64_t *)(*(void *)(v2 + 56) + 8 * v28) >= 2)
        {
          *(unint64_t *)((char *)v26 + ((v28 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v28;
          BOOL v18 = __OFADD__(v19++, 1);
          if (v18)
          {
            __break(1u);
            goto LABEL_58;
          }
        }
      }
    }
  }
  MEMORY[0x1F4188790](isStackAllocationSafe);
  char v5 = (void *)((char *)v81 - ((v4 + 15) & 0x3FFFFFFFFFFFFFF0));
  bzero(v5, v4);
  uint64_t v6 = 0;
  int64_t v7 = 0;
  uint64_t v8 = v2 + 64;
  uint64_t v9 = 1 << *(unsigned char *)(v2 + 32);
  uint64_t v10 = -1;
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  unint64_t v11 = v10 & *(void *)(v2 + 64);
  int64_t v12 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v13 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v14 = v13 | (v7 << 6);
      goto LABEL_7;
    }
    int64_t v15 = v7 + 1;
    if (__OFADD__(v7, 1)) {
      goto LABEL_130;
    }
    if (v15 >= v12) {
      goto LABEL_28;
    }
    unint64_t v16 = *(void *)(v8 + 8 * v15);
    ++v7;
    if (!v16)
    {
      int64_t v7 = v15 + 1;
      if (v15 + 1 >= v12) {
        goto LABEL_28;
      }
      unint64_t v16 = *(void *)(v8 + 8 * v7);
      if (!v16)
      {
        int64_t v7 = v15 + 2;
        if (v15 + 2 >= v12) {
          goto LABEL_28;
        }
        unint64_t v16 = *(void *)(v8 + 8 * v7);
        if (!v16)
        {
          int64_t v7 = v15 + 3;
          if (v15 + 3 >= v12) {
            goto LABEL_28;
          }
          unint64_t v16 = *(void *)(v8 + 8 * v7);
          if (!v16) {
            break;
          }
        }
      }
    }
LABEL_24:
    unint64_t v11 = (v16 - 1) & v16;
    unint64_t v14 = __clz(__rbit64(v16)) + (v7 << 6);
LABEL_7:
    if (*(uint64_t *)(*(void *)(v2 + 56) + 8 * v14) >= 2)
    {
      *(unint64_t *)((char *)v5 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v14;
      BOOL v18 = __OFADD__(v6++, 1);
      if (v18)
      {
        __break(1u);
        goto LABEL_28;
      }
    }
  }
  int64_t v17 = v15 + 4;
  if (v17 >= v12) {
    goto LABEL_28;
  }
  unint64_t v16 = *(void *)(v8 + 8 * v17);
  if (v16)
  {
    int64_t v7 = v17;
    goto LABEL_24;
  }
  while (1)
  {
    int64_t v7 = v17 + 1;
    if (__OFADD__(v17, 1)) {
      goto LABEL_134;
    }
    if (v7 >= v12) {
      break;
    }
    unint64_t v16 = *(void *)(v8 + 8 * v7);
    ++v17;
    if (v16) {
      goto LABEL_24;
    }
  }
LABEL_28:
  if (!v6) {
    return MEMORY[0x1E4FBC868];
  }
  if (v6 != *(void *)(v2 + 16))
  {
    v81[1] = v81;
    uint64_t v82 = v1;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
    uint64_t v32 = static _DictionaryStorage.allocate(capacity:)();
    int64_t v33 = 0;
    uint64_t v83 = (void *)((char *)v81 - ((v4 + 15) & 0x3FFFFFFFFFFFFFF0));
    unint64_t v34 = *v5;
    uint64_t v35 = v32 + 64;
    while (1)
    {
      if (v34)
      {
        unint64_t v38 = __clz(__rbit64(v34));
        v34 &= v34 - 1;
        int64_t v85 = v33;
        unint64_t v39 = v38 | (v33 << 6);
      }
      else
      {
        int64_t v40 = v33 + 1;
        if (__OFADD__(v33, 1)) {
          goto LABEL_133;
        }
        if (v40 >= v84) {
          return v32;
        }
        unint64_t v41 = v83[v40];
        int64_t v42 = v33 + 1;
        if (!v41)
        {
          int64_t v42 = v33 + 2;
          if (v33 + 2 >= v84) {
            return v32;
          }
          unint64_t v41 = v83[v42];
          if (!v41)
          {
            int64_t v42 = v33 + 3;
            if (v33 + 3 >= v84) {
              return v32;
            }
            unint64_t v41 = v83[v42];
            if (!v41)
            {
              int64_t v42 = v33 + 4;
              if (v33 + 4 >= v84) {
                return v32;
              }
              unint64_t v41 = v83[v42];
              if (!v41)
              {
                int64_t v42 = v33 + 5;
                if (v33 + 5 >= v84) {
                  return v32;
                }
                unint64_t v41 = v83[v42];
                if (!v41)
                {
                  uint64_t v43 = v33 + 6;
                  if (v33 + 6 >= v84) {
                    return v32;
                  }
                  unint64_t v41 = v83[v43];
                  if (!v41)
                  {
                    while (1)
                    {
                      int64_t v42 = v43 + 1;
                      if (__OFADD__(v43, 1)) {
                        break;
                      }
                      if (v42 >= v84) {
                        return v32;
                      }
                      unint64_t v41 = v83[v42];
                      ++v43;
                      if (v41) {
                        goto LABEL_83;
                      }
                    }
LABEL_137:
                    __break(1u);
LABEL_138:
                    __break(1u);
                  }
                  int64_t v42 = v33 + 6;
                }
              }
            }
          }
        }
LABEL_83:
        unint64_t v34 = (v41 - 1) & v41;
        int64_t v85 = v42;
        unint64_t v39 = __clz(__rbit64(v41)) + (v42 << 6);
      }
      long long v44 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v39);
      uint64_t v46 = *v44;
      uint64_t v45 = v44[1];
      uint64_t v47 = *(void *)(*(void *)(v2 + 56) + 8 * v39);
      Hasher.init(_seed:)();
      swift_bridgeObjectRetain();
      String.hash(into:)();
      Swift::Int v48 = Hasher._finalize()();
      uint64_t v49 = -1 << *(unsigned char *)(v32 + 32);
      unint64_t v50 = v48 & ~v49;
      unint64_t v51 = v50 >> 6;
      if (((-1 << v50) & ~*(void *)(v35 + 8 * (v50 >> 6))) != 0)
      {
        unint64_t v36 = __clz(__rbit64((-1 << v50) & ~*(void *)(v35 + 8 * (v50 >> 6)))) | v50 & 0x7FFFFFFFFFFFFFC0;
        goto LABEL_63;
      }
      char v52 = 0;
      unint64_t v53 = (unint64_t)(63 - v49) >> 6;
      do
      {
        if (++v51 == v53 && (v52 & 1) != 0)
        {
          __break(1u);
LABEL_130:
          __break(1u);
LABEL_131:
          __break(1u);
LABEL_132:
          __break(1u);
LABEL_133:
          __break(1u);
LABEL_134:
          __break(1u);
LABEL_135:
          __break(1u);
LABEL_136:
          __break(1u);
          goto LABEL_137;
        }
        BOOL v54 = v51 == v53;
        if (v51 == v53) {
          unint64_t v51 = 0;
        }
        v52 |= v54;
        uint64_t v55 = *(void *)(v35 + 8 * v51);
      }
      while (v55 == -1);
      unint64_t v36 = __clz(__rbit64(~v55)) + (v51 << 6);
LABEL_63:
      *(void *)(v35 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v36;
      uint64_t v37 = (void *)(*(void *)(v32 + 48) + 16 * v36);
      *uint64_t v37 = v46;
      v37[1] = v45;
      *(void *)(*(void *)(v32 + 56) + 8 * v36) = v47;
      ++*(void *)(v32 + 16);
      --v6;
      int64_t v33 = v85;
      if (!v6) {
        return v32;
      }
    }
  }
  swift_retain();
  return v2;
}

void specialized Array<A>.hash(into:)(uint64_t a1, uint64_t a2)
{
  Swift::UInt v3 = *(void *)(a2 + 16);
  Hasher._combine(_:)(v3);
  if (v3)
  {
    uint64_t v4 = a2 + 48;
    do
    {
      v4 += 24;
      swift_bridgeObjectRetain();
      String.hash(into:)();
      String.hash(into:)();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      --v3;
    }
    while (v3);
  }
}

uint64_t specialized static AggregationFunction.AggregationType.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  outlined init with copy of AggregationFunction.AggregationType(a1, (uint64_t)v67);
  outlined init with copy of AggregationFunction.AggregationType(a2, (uint64_t)&v68);
  switch(v67[192])
  {
    case 1:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 == 1) {
        goto LABEL_16;
      }
      goto LABEL_31;
    case 2:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 == 2)
      {
        *(_OWORD *)unint64_t v58 = *(_OWORD *)v63;
        *(_OWORD *)&v58[16] = *(_OWORD *)&v63[16];
        int8x16_t v59 = v64;
        int8x16_t v60 = v65;
        int8x16_t v56 = v61;
        int8x16_t v57 = v62;
        *(_OWORD *)unint64_t v53 = *(_OWORD *)v70;
        *(_OWORD *)&v53[16] = *(_OWORD *)&v70[16];
        int8x16_t v54 = v71;
        int8x16_t v55 = v72;
        v52[0] = v68;
        v52[1] = v69;
        outlined init with take of SQLExpression?((uint64_t)v66, (uint64_t)v51, &demangling cache variable for type metadata for SQLExpression?);
        outlined init with take of SQLExpression?((uint64_t)v73, (uint64_t)v49, &demangling cache variable for type metadata for SQLExpression?);
        if (*(_OWORD *)&v58[8] == *(_OWORD *)&v53[8])
        {
          outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)&v24);
          outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v47);
        }
        else
        {
          char v9 = _stringCompareWithSmolCheck(_:_:expecting:)();
          outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)&v24);
          outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v47);
          if ((v9 & 1) == 0)
          {
            outlined destroy of SQLExpression((uint64_t)&v24);
            outlined destroy of SQLExpression((uint64_t)v47);
            outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v44);
            outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v40);
            goto LABEL_39;
          }
        }
        char v10 = specialized == infix<A>(_:_:)(BYTE8(v27), v47[56]);
        outlined destroy of SQLExpression((uint64_t)&v24);
        outlined destroy of SQLExpression((uint64_t)v47);
        outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v44);
        outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v40);
        if (v10)
        {
          char v11 = specialized static Array<A>.== infix(_:_:)(v45, v42);
          outlined destroy of SQLExpression((uint64_t)v44);
          outlined destroy of SQLExpression((uint64_t)v40);
          outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v37);
          outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v35);
          if (v11)
          {
            char v12 = specialized static Array<A>.== infix(_:_:)(*((uint64_t *)&v38 + 1), v36);
            goto LABEL_41;
          }
LABEL_40:
          char v12 = 0;
LABEL_41:
          outlined destroy of SQLExpression((uint64_t)v37);
          outlined destroy of SQLExpression((uint64_t)v35);
          outlined init with copy of PgQuery_Alias?((uint64_t)v51, (uint64_t)v47, &demangling cache variable for type metadata for SQLExpression?);
          outlined init with copy of PgQuery_Alias?((uint64_t)v49, (uint64_t)v44, &demangling cache variable for type metadata for SQLExpression?);
          if (v12)
          {
            outlined init with copy of PgQuery_Alias?((uint64_t)v47, (uint64_t)&v24, &demangling cache variable for type metadata for SQLExpression?);
            outlined init with copy of PgQuery_Alias?((uint64_t)v44, (uint64_t)&v30, &demangling cache variable for type metadata for SQLExpression?);
            if (v25.i64[1])
            {
              outlined init with copy of PgQuery_Alias?((uint64_t)&v24, (uint64_t)v40, &demangling cache variable for type metadata for SQLExpression?);
              if (*((void *)&v31 + 1))
              {
                v37[2] = *(_OWORD *)v32;
                v37[3] = *(_OWORD *)&v32[16];
                long long v38 = v33;
                long long v39 = v34;
                v37[0] = v30;
                v37[1] = v31;
                if (v41 == *(_OWORD *)&v32[8])
                {
                  outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v35);
                  outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v23);
                }
                else
                {
                  char v13 = _stringCompareWithSmolCheck(_:_:expecting:)();
                  outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v35);
                  outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v23);
                  if ((v13 & 1) == 0)
                  {
                    outlined destroy of SQLExpression((uint64_t)v35);
                    outlined destroy of SQLExpression((uint64_t)v23);
                    outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v21);
                    outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v19);
                    goto LABEL_57;
                  }
                }
                char v14 = specialized == infix<A>(_:_:)(v35[56], v23[56]);
                outlined destroy of SQLExpression((uint64_t)v35);
                outlined destroy of SQLExpression((uint64_t)v23);
                outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v21);
                outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v19);
                if (v14)
                {
                  char v15 = specialized static Array<A>.== infix(_:_:)(v22, v20);
                  outlined destroy of SQLExpression((uint64_t)v21);
                  outlined destroy of SQLExpression((uint64_t)v19);
                  outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v17);
                  outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v16);
                  if (v15)
                  {
                    char v6 = specialized static Array<A>.== infix(_:_:)(v18, v16[9]);
LABEL_59:
                    outlined destroy of SQLExpression((uint64_t)v17);
                    outlined destroy of SQLExpression((uint64_t)v16);
                    outlined destroy of SQLExpression((uint64_t)v37);
                    outlined destroy of AnyValue?((uint64_t)v44, &demangling cache variable for type metadata for SQLExpression?);
                    outlined destroy of AnyValue?((uint64_t)v47, &demangling cache variable for type metadata for SQLExpression?);
                    outlined destroy of AnyValue?((uint64_t)v49, &demangling cache variable for type metadata for SQLExpression?);
                    outlined destroy of AnyValue?((uint64_t)v51, &demangling cache variable for type metadata for SQLExpression?);
                    outlined destroy of SQLExpression((uint64_t)v52);
                    outlined destroy of SQLExpression((uint64_t)&v56);
                    outlined destroy of SQLExpression((uint64_t)v40);
                    outlined destroy of AnyValue?((uint64_t)&v24, &demangling cache variable for type metadata for SQLExpression?);
LABEL_29:
                    outlined destroy of AggregationFunction.AggregationType((uint64_t)v67);
                    return v6 & 1;
                  }
LABEL_58:
                  char v6 = 0;
                  goto LABEL_59;
                }
LABEL_57:
                outlined destroy of SQLExpression((uint64_t)v21);
                outlined destroy of SQLExpression((uint64_t)v19);
                outlined init with copy of SQLExpression((uint64_t)v40, (uint64_t)v17);
                outlined init with copy of SQLExpression((uint64_t)v37, (uint64_t)v16);
                goto LABEL_58;
              }
              outlined destroy of AnyValue?((uint64_t)v44, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v47, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v49, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v51, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of SQLExpression((uint64_t)v52);
              outlined destroy of SQLExpression((uint64_t)&v56);
              outlined destroy of SQLExpression((uint64_t)v40);
            }
            else
            {
              outlined destroy of AnyValue?((uint64_t)v44, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v47, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v49, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of AnyValue?((uint64_t)v51, &demangling cache variable for type metadata for SQLExpression?);
              outlined destroy of SQLExpression((uint64_t)v52);
              outlined destroy of SQLExpression((uint64_t)&v56);
              if (!*((void *)&v31 + 1))
              {
                outlined destroy of AnyValue?((uint64_t)&v24, &demangling cache variable for type metadata for SQLExpression?);
                char v6 = 1;
                goto LABEL_29;
              }
            }
            outlined destroy of AnyValue?((uint64_t)&v24, &demangling cache variable for type metadata for (SQLExpression?, SQLExpression?));
          }
          else
          {
            outlined destroy of AnyValue?((uint64_t)v44, &demangling cache variable for type metadata for SQLExpression?);
            outlined destroy of AnyValue?((uint64_t)v47, &demangling cache variable for type metadata for SQLExpression?);
            outlined destroy of AnyValue?((uint64_t)v49, &demangling cache variable for type metadata for SQLExpression?);
            outlined destroy of AnyValue?((uint64_t)v51, &demangling cache variable for type metadata for SQLExpression?);
            outlined destroy of SQLExpression((uint64_t)v52);
            outlined destroy of SQLExpression((uint64_t)&v56);
          }
          char v6 = 0;
          goto LABEL_29;
        }
LABEL_39:
        outlined destroy of SQLExpression((uint64_t)v44);
        outlined destroy of SQLExpression((uint64_t)v40);
        outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v37);
        outlined init with copy of SQLExpression((uint64_t)v52, (uint64_t)v35);
        goto LABEL_40;
      }
      outlined destroy of AnyValue?((uint64_t)v66, &demangling cache variable for type metadata for SQLExpression?);
LABEL_31:
      outlined destroy of SQLExpression((uint64_t)&v61);
LABEL_32:
      outlined destroy of AnyValue?((uint64_t)v67, &demangling cache variable for type metadata for (AggregationFunction.AggregationType, AggregationFunction.AggregationType));
      char v6 = 0;
      return v6 & 1;
    case 3:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 != 3) {
        goto LABEL_31;
      }
      goto LABEL_16;
    case 4:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 != 4) {
        goto LABEL_31;
      }
      goto LABEL_16;
    case 5:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 != 5) {
        goto LABEL_31;
      }
      goto LABEL_16;
    case 6:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74 == 6) {
        goto LABEL_16;
      }
      goto LABEL_31;
    case 7:
      if (v74 != 7) {
        goto LABEL_32;
      }
      int8x16_t v7 = vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(v71, v73[2]), vorrq_s8(v73[0], v73[4])), vorrq_s8(vorrq_s8(v72, v73[3]), vorrq_s8(v73[1], v73[5]))), vorrq_s8(vorrq_s8(v68, *(int8x16_t *)v70), vorrq_s8(v69, *(int8x16_t *)&v70[16])));
      if (vorr_s8(*(int8x8_t *)v7.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL))) {
        goto LABEL_32;
      }
      outlined destroy of AggregationFunction.AggregationType((uint64_t)v67);
      char v6 = 1;
      return v6 & 1;
    default:
      outlined init with copy of AggregationFunction.AggregationType((uint64_t)v67, (uint64_t)&v61);
      if (v74) {
        goto LABEL_31;
      }
LABEL_16:
      long long v26 = *(_OWORD *)v63;
      long long v27 = *(_OWORD *)&v63[16];
      int8x16_t v28 = v64;
      int8x16_t v29 = v65;
      int8x16_t v24 = v61;
      int8x16_t v25 = v62;
      *(_OWORD *)&v58[16] = *(_OWORD *)&v70[16];
      *(_OWORD *)unint64_t v58 = *(_OWORD *)v70;
      int8x16_t v59 = v71;
      int8x16_t v60 = v72;
      int8x16_t v56 = v68;
      int8x16_t v57 = v69;
      if (*(_OWORD *)&v63[8] == *(_OWORD *)&v70[8])
      {
        outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v52);
        outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v51);
      }
      else
      {
        char v3 = _stringCompareWithSmolCheck(_:_:expecting:)();
        outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v52);
        outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v51);
        if ((v3 & 1) == 0)
        {
          outlined destroy of SQLExpression((uint64_t)v52);
          outlined destroy of SQLExpression((uint64_t)v51);
          outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v49);
          outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v47);
          goto LABEL_26;
        }
      }
      char v4 = specialized == infix<A>(_:_:)(v53[24], v51[56]);
      outlined destroy of SQLExpression((uint64_t)v52);
      outlined destroy of SQLExpression((uint64_t)v51);
      outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v49);
      outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v47);
      if (v4)
      {
        char v5 = specialized static Array<A>.== infix(_:_:)(v50, v48);
        outlined destroy of SQLExpression((uint64_t)v49);
        outlined destroy of SQLExpression((uint64_t)v47);
        outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v44);
        outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v40);
        if (v5)
        {
          char v6 = specialized static Array<A>.== infix(_:_:)(v46, v43);
          goto LABEL_28;
        }
LABEL_27:
        char v6 = 0;
LABEL_28:
        outlined destroy of SQLExpression((uint64_t)v44);
        outlined destroy of SQLExpression((uint64_t)v40);
        outlined destroy of SQLExpression((uint64_t)&v56);
        outlined destroy of SQLExpression((uint64_t)&v24);
        goto LABEL_29;
      }
LABEL_26:
      outlined destroy of SQLExpression((uint64_t)v49);
      outlined destroy of SQLExpression((uint64_t)v47);
      outlined init with copy of SQLExpression((uint64_t)&v24, (uint64_t)v44);
      outlined init with copy of SQLExpression((uint64_t)&v56, (uint64_t)v40);
      goto LABEL_27;
  }
}

uint64_t specialized static SQLExpression.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 40) == *(void *)(a2 + 40) && *(void *)(a1 + 48) == *(void *)(a2 + 48))
  {
    outlined init with copy of SQLExpression(a1, (uint64_t)v18);
    outlined init with copy of SQLExpression(a2, (uint64_t)v17);
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    outlined init with copy of SQLExpression(a1, (uint64_t)v18);
    outlined init with copy of SQLExpression(a2, (uint64_t)v17);
    if ((v5 & 1) == 0)
    {
      outlined destroy of SQLExpression((uint64_t)v17);
      outlined destroy of SQLExpression((uint64_t)v18);
      outlined init with copy of SQLExpression(a1, (uint64_t)v15);
      outlined init with copy of SQLExpression(a2, (uint64_t)v13);
LABEL_11:
      outlined destroy of SQLExpression((uint64_t)v15);
      outlined destroy of SQLExpression((uint64_t)v13);
      outlined init with copy of SQLExpression(a1, (uint64_t)v11);
      outlined init with copy of SQLExpression(a2, (uint64_t)v10);
      goto LABEL_12;
    }
  }
  char v6 = specialized == infix<A>(_:_:)(v18[56], v17[56]);
  outlined destroy of SQLExpression((uint64_t)v17);
  outlined destroy of SQLExpression((uint64_t)v18);
  outlined init with copy of SQLExpression(a1, (uint64_t)v15);
  outlined init with copy of SQLExpression(a2, (uint64_t)v13);
  if ((v6 & 1) == 0) {
    goto LABEL_11;
  }
  char v7 = specialized static Array<A>.== infix(_:_:)(v16, v14);
  outlined destroy of SQLExpression((uint64_t)v15);
  outlined destroy of SQLExpression((uint64_t)v13);
  outlined init with copy of SQLExpression(a1, (uint64_t)v11);
  outlined init with copy of SQLExpression(a2, (uint64_t)v10);
  if ((v7 & 1) == 0)
  {
LABEL_12:
    char v8 = 0;
    goto LABEL_13;
  }
  char v8 = specialized static Array<A>.== infix(_:_:)(v12, v10[9]);
LABEL_13:
  outlined destroy of SQLExpression((uint64_t)v11);
  outlined destroy of SQLExpression((uint64_t)v10);
  return v8 & 1;
}

unint64_t lazy protocol witness table accessor for type Binding.CodingKeys and conformance Binding.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys;
  if (!lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Binding.CodingKeys and conformance Binding.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.CodingKeys and conformance AggregationFunction.AggregationType.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.TOTALCodingKeys and conformance AggregationFunction.AggregationType.TOTALCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression;
  if (!lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression;
  if (!lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpression and conformance SQLExpression);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.SUMCodingKeys and conformance AggregationFunction.AggregationType.SUMCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MINCodingKeys and conformance AggregationFunction.AggregationType.MINCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.MAXCodingKeys and conformance AggregationFunction.AggregationType.MAXCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.GROUP_CONCATCodingKeys and conformance AggregationFunction.AggregationType.GROUP_CONCATCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNT_STARCodingKeys and conformance AggregationFunction.AggregationType.COUNT_STARCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.COUNTCodingKeys and conformance AggregationFunction.AggregationType.COUNTCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType.AVGCodingKeys and conformance AggregationFunction.AggregationType.AVGCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys;
  if (!lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.CodingKeys and conformance AggregationFunction.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType()
{
  unint64_t result = lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType;
  if (!lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type AggregationFunction.AggregationType and conformance AggregationFunction.AggregationType);
  }
  return result;
}

uint64_t assignWithCopy for SQLExpression(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    char v3 = result;
    uint64_t v4 = result[3];
    uint64_t v5 = a2[3];
    if (v4 == v5)
    {
      uint64_t v10 = *(void *)(v4 - 8);
      if ((*(unsigned char *)(v10 + 82) & 2) != 0)
      {
        uint64_t v12 = *a2;
        swift_retain();
        unint64_t result = (uint64_t *)swift_release();
        *char v3 = v12;
      }
      else
      {
        char v11 = *(uint64_t (**)(void))(v10 + 24);
        return (uint64_t *)v11();
      }
    }
    else
    {
      result[3] = v5;
      result[4] = a2[4];
      uint64_t v6 = *(void *)(v4 - 8);
      uint64_t v7 = *(void *)(v5 - 8);
      uint64_t v8 = v7;
      int v9 = *(_DWORD *)(v7 + 80);
      if ((*(unsigned char *)(v6 + 82) & 2) != 0)
      {
        if ((v9 & 0x20000) != 0)
        {
          *unint64_t result = *a2;
          swift_retain();
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v7 + 16))(result, a2, v5);
        }
        return (uint64_t *)swift_release();
      }
      else
      {
        (*(void (**)(unsigned char *, uint64_t *, uint64_t))(v6 + 32))(v13, result, v4);
        if ((v9 & 0x20000) != 0)
        {
          *char v3 = *a2;
          swift_retain();
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t *, uint64_t))(v8 + 16))(v3, a2, v5);
        }
        return (uint64_t *)(*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v13, v4);
      }
    }
  }
  return result;
}

uint64_t assignWithTake for SQLExpression(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease();
  uint64_t v5 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v5;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithCopy for Binding(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

uint64_t assignWithTake for Binding(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

uint64_t assignWithCopy for AggregationFunction(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    switch(*(unsigned char *)(a2 + 192))
    {
      case 0:
        uint64_t v4 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v4;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(unsigned char *)(a1 + 192) = 0;
        goto LABEL_13;
      case 1:
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v14;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 1;
        goto LABEL_12;
      case 2:
        uint64_t v16 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v16;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        uint64_t v17 = *(void *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v17)
        {
          *(void *)(a1 + 120) = v17;
          *(void *)(a1 + 128) = *(void *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v17 - 8))(a1 + 96, a2 + 96, v17);
          *(void *)(a1 + 136) = *(void *)(a2 + 136);
          *(void *)(a1 + 144) = *(void *)(a2 + 144);
          *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
          *(void *)(a1 + 160) = *(void *)(a2 + 160);
          *(void *)(a1 + 168) = *(void *)(a2 + 168);
          *(void *)(a1 + 176) = *(void *)(a2 + 176);
          *(void *)(a1 + 184) = *(void *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          long long v23 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v23;
          long long v24 = *(_OWORD *)(a2 + 128);
          long long v25 = *(_OWORD *)(a2 + 144);
          long long v26 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v26;
          *(_OWORD *)(a1 + 128) = v24;
          *(_OWORD *)(a1 + 144) = v25;
        }
        *(unsigned char *)(a1 + 192) = 2;
        break;
      case 3:
        uint64_t v18 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v18;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 3;
        goto LABEL_12;
      case 4:
        uint64_t v19 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v19;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 4;
        goto LABEL_12;
      case 5:
        uint64_t v20 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v20;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 5;
        goto LABEL_12;
      case 6:
        uint64_t v21 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v21;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 6;
LABEL_12:
        *(unsigned char *)(a1 + 192) = v15;
LABEL_13:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        long long v5 = *(_OWORD *)(a2 + 16);
        long long v6 = *(_OWORD *)(a2 + 32);
        long long v7 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v7;
        *(_OWORD *)(a1 + 16) = v5;
        *(_OWORD *)(a1 + 32) = v6;
        long long v8 = *(_OWORD *)(a2 + 80);
        long long v9 = *(_OWORD *)(a2 + 96);
        long long v10 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v10;
        *(_OWORD *)(a1 + 80) = v8;
        *(_OWORD *)(a1 + 96) = v9;
        long long v11 = *(_OWORD *)(a2 + 144);
        long long v12 = *(_OWORD *)(a2 + 160);
        long long v13 = *(_OWORD *)(a2 + 176);
        *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v12;
        *(_OWORD *)(a1 + 176) = v13;
        *(_OWORD *)(a1 + 144) = v11;
        break;
    }
  }
  *(unsigned char *)(a1 + 193) = *(unsigned char *)(a2 + 193);
  return a1;
}

uint64_t outlined destroy of AggregationFunction.AggregationType(uint64_t a1)
{
  return a1;
}

uint64_t assignWithTake for AggregationFunction(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    long long v4 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 176) = v4;
    *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
    long long v5 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 112) = v5;
    long long v6 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 144) = v6;
    long long v7 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 48) = v7;
    long long v8 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 80) = v8;
    long long v9 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v9;
  }
  *(unsigned char *)(a1 + 193) = *(unsigned char *)(a2 + 193);
  return a1;
}

uint64_t getEnumTagSinglePayload for AggregationFunction(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xF9 && *(unsigned char *)(a1 + 194)) {
    return (*(_DWORD *)a1 + 249);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 192);
  if (v3 <= 7) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for AggregationFunction(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF8)
  {
    *(void *)(result + 184) = 0;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_WORD *)(result + 192) = 0;
    *(void *)unint64_t result = a2 - 249;
    if (a3 >= 0xF9) {
      *(unsigned char *)(result + 194) = 1;
    }
  }
  else
  {
    if (a3 >= 0xF9) {
      *(unsigned char *)(result + 194) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 192) = -(char)a2;
    }
  }
  return result;
}

uint64_t assignWithCopy for AggregationFunction.AggregationType(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 192);
    if (v4 >= 7) {
      unsigned int v4 = *(_DWORD *)a1 + 7;
    }
    switch(v4)
    {
      case 0u:
      case 1u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        goto LABEL_6;
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(a1 + 120))
        {
          __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
LABEL_6:
          swift_bridgeObjectRelease();
        }
        break;
      default:
        break;
    }
    unsigned int v5 = *(unsigned __int8 *)(a2 + 192);
    if (v5 >= 7) {
      unsigned int v5 = *(_DWORD *)a2 + 7;
    }
    switch(v5)
    {
      case 0u:
        uint64_t v6 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v6;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(unsigned char *)(a1 + 192) = 0;
        goto LABEL_22;
      case 1u:
        uint64_t v16 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v16;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v17 = 1;
        goto LABEL_21;
      case 2u:
        uint64_t v18 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v18;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        uint64_t v19 = *(void *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v19)
        {
          *(void *)(a1 + 120) = v19;
          *(void *)(a1 + 128) = *(void *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v19 - 8))(a1 + 96, a2 + 96, v19);
          *(void *)(a1 + 136) = *(void *)(a2 + 136);
          *(void *)(a1 + 144) = *(void *)(a2 + 144);
          *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
          *(void *)(a1 + 160) = *(void *)(a2 + 160);
          *(void *)(a1 + 168) = *(void *)(a2 + 168);
          *(void *)(a1 + 176) = *(void *)(a2 + 176);
          *(void *)(a1 + 184) = *(void *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          long long v25 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v25;
          long long v26 = *(_OWORD *)(a2 + 128);
          long long v27 = *(_OWORD *)(a2 + 144);
          long long v28 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v28;
          *(_OWORD *)(a1 + 128) = v26;
          *(_OWORD *)(a1 + 144) = v27;
        }
        *(unsigned char *)(a1 + 192) = 2;
        return a1;
      case 3u:
        uint64_t v20 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v20;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v17 = 3;
        goto LABEL_21;
      case 4u:
        uint64_t v21 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v21;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v17 = 4;
        goto LABEL_21;
      case 5u:
        uint64_t v22 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v22;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v22 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v17 = 5;
        goto LABEL_21;
      case 6u:
        uint64_t v23 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v23;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v23 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v17 = 6;
LABEL_21:
        *(unsigned char *)(a1 + 192) = v17;
LABEL_22:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        long long v7 = *(_OWORD *)(a2 + 16);
        long long v8 = *(_OWORD *)(a2 + 32);
        long long v9 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v9;
        *(_OWORD *)(a1 + 16) = v7;
        *(_OWORD *)(a1 + 32) = v8;
        long long v10 = *(_OWORD *)(a2 + 80);
        long long v11 = *(_OWORD *)(a2 + 96);
        long long v12 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v12;
        *(_OWORD *)(a1 + 80) = v10;
        *(_OWORD *)(a1 + 96) = v11;
        long long v13 = *(_OWORD *)(a2 + 144);
        long long v14 = *(_OWORD *)(a2 + 160);
        long long v15 = *(_OWORD *)(a2 + 176);
        *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v14;
        *(_OWORD *)(a1 + 176) = v15;
        *(_OWORD *)(a1 + 144) = v13;
        break;
    }
  }
  return a1;
}

__n128 __swift_memcpy193_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(_OWORD *)(a1 + 16) = v2;
  *(_OWORD *)(a1 + 32) = v3;
  long long v5 = *(_OWORD *)(a2 + 80);
  long long v6 = *(_OWORD *)(a2 + 96);
  long long v7 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v7;
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 96) = v6;
  __n128 result = *(__n128 *)(a2 + 144);
  long long v9 = *(_OWORD *)(a2 + 160);
  long long v10 = *(_OWORD *)(a2 + 176);
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(_OWORD *)(a1 + 160) = v9;
  *(_OWORD *)(a1 + 176) = v10;
  *(__n128 *)(a1 + 144) = result;
  return result;
}

uint64_t assignWithTake for AggregationFunction.AggregationType(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 192);
    if (v4 >= 7) {
      unsigned int v4 = *(_DWORD *)a1 + 7;
    }
    switch(v4)
    {
      case 0u:
      case 1u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        goto LABEL_6;
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm(a1);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (*(void *)(a1 + 120))
        {
          __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
LABEL_6:
          swift_bridgeObjectRelease();
        }
        break;
      default:
        break;
    }
    unsigned int v5 = *(unsigned __int8 *)(a2 + 192);
    if (v5 >= 7) {
      unsigned int v5 = *(_DWORD *)a2 + 7;
    }
    switch(v5)
    {
      case 0u:
        long long v6 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v6;
        long long v7 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v7;
        long long v8 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v8;
        *(unsigned char *)(a1 + 192) = 0;
        return a1;
      case 1u:
        long long v15 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v15;
        long long v16 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v16;
        long long v17 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v17;
        char v18 = 1;
        goto LABEL_20;
      case 2u:
        long long v19 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v19;
        long long v20 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v20;
        long long v21 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v21;
        long long v22 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v22;
        long long v23 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v23;
        long long v24 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v24;
        char v18 = 2;
        goto LABEL_20;
      case 3u:
        long long v25 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v25;
        long long v26 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v26;
        long long v27 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v27;
        char v18 = 3;
        goto LABEL_20;
      case 4u:
        long long v28 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v28;
        long long v29 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v29;
        long long v30 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v30;
        char v18 = 4;
        goto LABEL_20;
      case 5u:
        long long v31 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v31;
        long long v32 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v32;
        long long v33 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v33;
        char v18 = 5;
        goto LABEL_20;
      case 6u:
        long long v34 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v34;
        long long v35 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v35;
        long long v36 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v36;
        char v18 = 6;
LABEL_20:
        *(unsigned char *)(a1 + 192) = v18;
        break;
      default:
        long long v9 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v9;
        *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
        long long v10 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v10;
        long long v11 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v11;
        long long v12 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v12;
        long long v13 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 80) = v13;
        long long v14 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v14;
        break;
    }
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for AggregationFunction.AggregationType(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xF9 && *(unsigned char *)(a1 + 193)) {
    return (*(_DWORD *)a1 + 249);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 192);
  if (v3 >= 8) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for AggregationFunction.AggregationType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF8)
  {
    *(unsigned char *)(result + 192) = 0;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 249;
    if (a3 >= 0xF9) {
      *(unsigned char *)(result + 193) = 1;
    }
  }
  else
  {
    if (a3 >= 0xF9) {
      *(unsigned char *)(result + 193) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 192) = -(char)a2;
    }
  }
  return result;
}

uint64_t destructiveInjectEnumTag for AggregationFunction.AggregationType(uint64_t result, unsigned int a2)
{
  if (a2 > 6)
  {
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 7;
    LOBYTE(a2) = 7;
  }
  *(unsigned char *)(result + 192) = a2;
  return result;
}

void *type metadata accessor for AggregationFunction.CodingKeys()
{
  return &unk_1EDD724C8;
}

unsigned char *storeEnumTagSinglePayload for AggregationFunction.AggregationType.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 7 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 7) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF9) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF8)
  {
    unsigned int v6 = ((a2 - 249) >> 8) + 1;
    *__n128 result = a2 + 7;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA53590);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 7;
        break;
    }
  }
  return result;
}

void *type metadata accessor for AggregationFunction.AggregationType.CodingKeys()
{
  return &unk_1EDD71F98;
}

void *type metadata accessor for AggregationFunction.AggregationType.AVGCodingKeys()
{
  return &unk_1EDD72028;
}

void *type metadata accessor for AggregationFunction.AggregationType.COUNTCodingKeys()
{
  return &unk_1EDD72268;
}

void *type metadata accessor for AggregationFunction.AggregationType.COUNT_STARCodingKeys()
{
  return &unk_1EDD72388;
}

void *type metadata accessor for AggregationFunction.AggregationType.GROUP_CONCATCodingKeys()
{
  return &unk_1EDD723A8;
}

void *type metadata accessor for AggregationFunction.AggregationType.MAXCodingKeys()
{
  return &unk_1EDD720B8;
}

void *type metadata accessor for AggregationFunction.AggregationType.MINCodingKeys()
{
  return &unk_1EDD72148;
}

void *type metadata accessor for AggregationFunction.AggregationType.SUMCodingKeys()
{
  return &unk_1EDD721D8;
}

unsigned char *storeEnumTagSinglePayload for AggregationFunction.AggregationType.AVGCodingKeys(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *__n128 result = a2;
        return result;
      case 2:
        *(_WORD *)__n128 result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)__n128 result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *__n128 result = 0;
      break;
    case 2:
      *(_WORD *)__n128 result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x18EA536D8);
    case 4:
      *(_DWORD *)__n128 result = 0;
      break;
    default:
      return result;
  }
  return result;
}

void *type metadata accessor for AggregationFunction.AggregationType.TOTALCodingKeys()
{
  return &unk_1EDD722F8;
}

uint64_t getEnumTagSinglePayload for AggregationFunction.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for AggregationFunction.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *__n128 result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA5386CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 1;
        break;
    }
  }
  return result;
}

void *type metadata accessor for Binding.CodingKeys()
{
  return &unk_1EDD75E78;
}

uint64_t getEnumTagSinglePayload for SQLExpression.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFC) {
    goto LABEL_17;
  }
  if (a2 + 4 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 4) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 4;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 5;
  int v8 = v6 - 5;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for SQLExpression.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFB)
  {
    unsigned int v6 = ((a2 - 252) >> 8) + 1;
    *__n128 result = a2 + 4;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA53A00);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 4;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for SQLExpression.CodingKeys()
{
  return &type metadata for SQLExpression.CodingKeys;
}

void *initializeBufferWithCopyOfBuffer for SQLExpressionError(void *a1, void *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v9 = *a2;
    *a1 = *a2;
    a1 = (void *)(v9 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    uint64_t v6 = *(void *)(a3 - 8);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        uint64_t v7 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v7 - 8) + 16))(a1, a2, v7);
        uint64_t Node = type metadata accessor for PgQuery_Node(0);
        *(void *)((char *)a1 + *(int *)(Node + 20)) = *(void *)((char *)a2 + *(int *)(Node + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 1u:
        uint64_t v11 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v11 - 8) + 16))(a1, a2, v11);
        uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(void *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(void *)((char *)a2 + *(int *)(BoolExpr + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 3u:
        uint64_t v13 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v13 - 8) + 16))(a1, a2, v13);
        uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(void *)((char *)a1 + *(int *)(A_Expr + 20)) = *(void *)((char *)a2 + *(int *)(A_Expr + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 4u:
        uint64_t v15 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v15 - 8) + 16))(a1, a2, v15);
        uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(void *)((char *)a1 + *(int *)(NullTest + 20)) = *(void *)((char *)a2 + *(int *)(NullTest + 20));
        swift_retain();
        swift_storeEnumTagMultiPayload();
        break;
      case 5u:
        uint64_t v17 = a2[1];
        *a1 = *a2;
        a1[1] = v17;
        *((unsigned char *)a1 + 16) = *((unsigned char *)a2 + 16);
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 6u:
      case 0xBu:
        uint64_t v18 = a2[1];
        *a1 = *a2;
        a1[1] = v18;
        uint64_t v19 = a2[2];
        uint64_t v20 = a2[3];
        a1[2] = v19;
        a1[3] = v20;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 7u:
      case 8u:
      case 9u:
        uint64_t v21 = a2[1];
        *a1 = *a2;
        a1[1] = v21;
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      case 0xAu:
        uint64_t v22 = a2[1];
        *a1 = *a2;
        a1[1] = v22;
        a1[2] = a2[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(void *)(v6 + 64));
        break;
    }
  }
  return a1;
}

uint64_t destroy for SQLExpressionError(uint64_t a1)
{
  uint64_t result = swift_getEnumCaseMultiPayload();
  switch((int)result)
  {
    case 0:
      uint64_t v3 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
      type metadata accessor for PgQuery_Node(0);
      goto LABEL_6;
    case 1:
      uint64_t v4 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
      type metadata accessor for PgQuery_BoolExpr(0);
      goto LABEL_6;
    case 3:
      uint64_t v5 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8))(a1, v5);
      type metadata accessor for PgQuery_A_Expr(0);
      goto LABEL_6;
    case 4:
      uint64_t v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
      type metadata accessor for PgQuery_NullTest(0);
LABEL_6:
      return swift_release();
    case 5:
    case 7:
    case 8:
    case 9:
      goto LABEL_10;
    case 6:
    case 10:
    case 11:
      swift_bridgeObjectRelease();
LABEL_10:
      uint64_t result = swift_bridgeObjectRelease();
      break;
    default:
      return result;
  }
  return result;
}

void *initializeWithCopy for SQLExpressionError(void *a1, void *a2, uint64_t a3)
{
  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      uint64_t v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(void *, void *, uint64_t))(*(void *)(v6 - 8) + 16))(a1, a2, v6);
      uint64_t Node = type metadata accessor for PgQuery_Node(0);
      *(void *)((char *)a1 + *(int *)(Node + 20)) = *(void *)((char *)a2 + *(int *)(Node + 20));
      swift_retain();
      goto LABEL_11;
    case 1u:
      uint64_t v8 = type metadata accessor for UnknownStorage();
      (*(void (**)(void *, void *, uint64_t))(*(void *)(v8 - 8) + 16))(a1, a2, v8);
      uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
      *(void *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(void *)((char *)a2 + *(int *)(BoolExpr + 20));
      swift_retain();
      goto LABEL_11;
    case 3u:
      uint64_t v10 = type metadata accessor for UnknownStorage();
      (*(void (**)(void *, void *, uint64_t))(*(void *)(v10 - 8) + 16))(a1, a2, v10);
      uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
      *(void *)((char *)a1 + *(int *)(A_Expr + 20)) = *(void *)((char *)a2 + *(int *)(A_Expr + 20));
      swift_retain();
      goto LABEL_11;
    case 4u:
      uint64_t v12 = type metadata accessor for UnknownStorage();
      (*(void (**)(void *, void *, uint64_t))(*(void *)(v12 - 8) + 16))(a1, a2, v12);
      uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
      *(void *)((char *)a1 + *(int *)(NullTest + 20)) = *(void *)((char *)a2 + *(int *)(NullTest + 20));
      swift_retain();
      goto LABEL_11;
    case 5u:
      uint64_t v14 = a2[1];
      *a1 = *a2;
      a1[1] = v14;
      *((unsigned char *)a1 + 16) = *((unsigned char *)a2 + 16);
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 6u:
    case 0xBu:
      uint64_t v17 = a2[1];
      *a1 = *a2;
      a1[1] = v17;
      uint64_t v18 = a2[2];
      uint64_t v19 = a2[3];
      a1[2] = v18;
      a1[3] = v19;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 7u:
    case 8u:
    case 9u:
      uint64_t v15 = a2[1];
      *a1 = *a2;
      a1[1] = v15;
      swift_bridgeObjectRetain();
      goto LABEL_11;
    case 0xAu:
      uint64_t v16 = a2[1];
      *a1 = *a2;
      a1[1] = v16;
      a1[2] = a2[2];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
LABEL_11:
      swift_storeEnumTagMultiPayload();
      break;
    default:
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
      break;
  }
  return a1;
}

void *assignWithCopy for SQLExpressionError(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    outlined destroy of SQLExpressionError((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for SQLExpressionError);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        uint64_t v6 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v6 - 8) + 16))(a1, a2, v6);
        uint64_t Node = type metadata accessor for PgQuery_Node(0);
        *(void *)((char *)a1 + *(int *)(Node + 20)) = *(void *)((char *)a2 + *(int *)(Node + 20));
        swift_retain();
        goto LABEL_12;
      case 1u:
        uint64_t v8 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v8 - 8) + 16))(a1, a2, v8);
        uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(void *)((char *)a1 + *(int *)(BoolExpr + 20)) = *(void *)((char *)a2 + *(int *)(BoolExpr + 20));
        swift_retain();
        goto LABEL_12;
      case 3u:
        uint64_t v10 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v10 - 8) + 16))(a1, a2, v10);
        uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(void *)((char *)a1 + *(int *)(A_Expr + 20)) = *(void *)((char *)a2 + *(int *)(A_Expr + 20));
        swift_retain();
        goto LABEL_12;
      case 4u:
        uint64_t v12 = type metadata accessor for UnknownStorage();
        (*(void (**)(void *, void *, uint64_t))(*(void *)(v12 - 8) + 16))(a1, a2, v12);
        uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(void *)((char *)a1 + *(int *)(NullTest + 20)) = *(void *)((char *)a2 + *(int *)(NullTest + 20));
        swift_retain();
        goto LABEL_12;
      case 5u:
        *a1 = *a2;
        a1[1] = a2[1];
        *((unsigned char *)a1 + 16) = *((unsigned char *)a2 + 16);
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 6u:
      case 0xBu:
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        a1[3] = a2[3];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 7u:
      case 8u:
      case 9u:
        *a1 = *a2;
        a1[1] = a2[1];
        swift_bridgeObjectRetain();
        goto LABEL_12;
      case 0xAu:
        *a1 = *a2;
        a1[1] = a2[1];
        a1[2] = a2[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
LABEL_12:
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
        break;
    }
  }
  return a1;
}

uint64_t type metadata accessor for SQLExpressionError()
{
  uint64_t result = type metadata singleton initialization cache for SQLExpressionError;
  if (!type metadata singleton initialization cache for SQLExpressionError) {
    return swift_getSingletonMetadata();
  }
  return result;
}

char *initializeWithTake for SQLExpressionError(char *a1, char *a2, uint64_t a3)
{
  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      uint64_t v6 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
      uint64_t Node = type metadata accessor for PgQuery_Node(0);
      *(void *)&a1[*(int *)(Node + 20)] = *(void *)&a2[*(int *)(Node + 20)];
      goto LABEL_7;
    case 1u:
      uint64_t v8 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v8 - 8) + 32))(a1, a2, v8);
      uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
      *(void *)&a1[*(int *)(BoolExpr + 20)] = *(void *)&a2[*(int *)(BoolExpr + 20)];
      goto LABEL_7;
    case 3u:
      uint64_t v10 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 32))(a1, a2, v10);
      uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
      *(void *)&a1[*(int *)(A_Expr + 20)] = *(void *)&a2[*(int *)(A_Expr + 20)];
      goto LABEL_7;
    case 4u:
      uint64_t v12 = type metadata accessor for UnknownStorage();
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 32))(a1, a2, v12);
      uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
      *(void *)&a1[*(int *)(NullTest + 20)] = *(void *)&a2[*(int *)(NullTest + 20)];
LABEL_7:
      swift_storeEnumTagMultiPayload();
      break;
    default:
      memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
      break;
  }
  return a1;
}

char *assignWithTake for SQLExpressionError(char *a1, char *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    outlined destroy of SQLExpressionError((uint64_t)a1, (uint64_t (*)(void))type metadata accessor for SQLExpressionError);
    switch(swift_getEnumCaseMultiPayload())
    {
      case 0u:
        uint64_t v6 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
        uint64_t Node = type metadata accessor for PgQuery_Node(0);
        *(void *)&a1[*(int *)(Node + 20)] = *(void *)&a2[*(int *)(Node + 20)];
        goto LABEL_8;
      case 1u:
        uint64_t v8 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v8 - 8) + 32))(a1, a2, v8);
        uint64_t BoolExpr = type metadata accessor for PgQuery_BoolExpr(0);
        *(void *)&a1[*(int *)(BoolExpr + 20)] = *(void *)&a2[*(int *)(BoolExpr + 20)];
        goto LABEL_8;
      case 3u:
        uint64_t v10 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 32))(a1, a2, v10);
        uint64_t A_Expr = type metadata accessor for PgQuery_A_Expr(0);
        *(void *)&a1[*(int *)(A_Expr + 20)] = *(void *)&a2[*(int *)(A_Expr + 20)];
        goto LABEL_8;
      case 4u:
        uint64_t v12 = type metadata accessor for UnknownStorage();
        (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 32))(a1, a2, v12);
        uint64_t NullTest = type metadata accessor for PgQuery_NullTest(0);
        *(void *)&a1[*(int *)(NullTest + 20)] = *(void *)&a2[*(int *)(NullTest + 20)];
LABEL_8:
        swift_storeEnumTagMultiPayload();
        break;
      default:
        memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
        break;
    }
  }
  return a1;
}

uint64_t type metadata completion function for SQLExpressionError()
{
  uint64_t result = type metadata accessor for PgQuery_Node(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for PgQuery_BoolExpr(319);
    if (v2 <= 0x3F)
    {
      uint64_t result = type metadata accessor for PgQuery_A_Expr(319);
      if (v3 <= 0x3F)
      {
        uint64_t result = type metadata accessor for PgQuery_NullTest(319);
        if (v4 <= 0x3F)
        {
          swift_initEnumMetadataMultiPayload();
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t specialized ColumnResolver.init(schemas:)(uint64_t a1)
{
  uint64_t v148 = *(void *)(a1 + 16);
  if (!v148)
  {
    uint64_t v2 = MEMORY[0x1E4FBC868];
    goto LABEL_76;
  }
  uint64_t v153 = a1 + 32;
  swift_bridgeObjectRetain();
  uint64_t v1 = 0;
  uint64_t v2 = MEMORY[0x1E4FBC868];
LABEL_4:
  uint64_t v3 = *(void *)(v153 + 24 * v1 + 16);
  uint64_t v156 = v1 + 1;
  uint64_t v158 = v3 + 64;
  uint64_t v4 = 1 << *(unsigned char *)(v3 + 32);
  if (v4 < 64) {
    uint64_t v5 = ~(-1 << v4);
  }
  else {
    uint64_t v5 = -1;
  }
  unint64_t v6 = v5 & *(void *)(v3 + 64);
  int64_t v160 = (unint64_t)(v4 + 63) >> 6;
  swift_bridgeObjectRetain();
  uint64_t v161 = v3;
  swift_bridgeObjectRetain_n();
  int64_t v7 = 0;
  while (1)
  {
    if (v6)
    {
      unint64_t v8 = __clz(__rbit64(v6));
      uint64_t v9 = (v6 - 1) & v6;
      unint64_t v10 = v8 | (v7 << 6);
      goto LABEL_26;
    }
    int64_t v11 = v7 + 1;
    if (__OFADD__(v7, 1)) {
      goto LABEL_201;
    }
    if (v11 >= v160)
    {
LABEL_3:
      swift_bridgeObjectRelease();
      swift_release();
      swift_bridgeObjectRelease();
      uint64_t v1 = v156;
      if (v156 == v148)
      {
        swift_bridgeObjectRelease();
LABEL_76:
        uint64_t v57 = specialized _NativeDictionary.filter(_:)(v2);
        swift_bridgeObjectRelease();
        _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSDySSSiG_SSs5NeverOTg5181_s14BiomeSQLParser14ColumnResolver33_B787555787B9EFBBEFB0C9C5225A4FB7LLV7schemasADSayAA6SchemaVG_tKcfcS2S3key_Si5valuet_tcfu_32a168a102879cc1a6a91172b0770f0c91SSAI_SiAJtSSTf3nnnpk_nTf1cn_n(v57);
        uint64_t v59 = v58;
        swift_release();
        uint64_t v60 = Set.init(minimumCapacity:)();
        uint64_t v166 = v60;
        uint64_t v61 = *(void *)(v59 + 16);
        if (v61)
        {
          int8x16_t v62 = (unint64_t *)(v59 + 40);
          do
          {
            unint64_t v63 = *(v62 - 1);
            unint64_t v64 = *v62;
            swift_bridgeObjectRetain();
            specialized Set._Variant.insert(_:)(v165, v63, v64);
            swift_bridgeObjectRelease();
            v62 += 2;
            --v61;
          }
          while (v61);
          swift_bridgeObjectRelease();
          uint64_t v65 = v166;
          if (v148) {
            goto LABEL_80;
          }
        }
        else
        {
          uint64_t v65 = v60;
          swift_bridgeObjectRelease();
          if (v148)
          {
LABEL_80:
            uint64_t v66 = 0;
            unint64_t v67 = MEMORY[0x1E4FBC868];
            uint64_t v145 = a1 + 32;
            uint64_t v154 = v65;
            while (1)
            {
              int8x16_t v68 = (unint64_t *)(v145 + 24 * v66);
              unint64_t v155 = *v68;
              unint64_t v157 = v68[1];
              unint64_t v69 = v68[2];
              uint64_t v147 = v66 + 1;
              unint64_t v150 = v69 + 64;
              uint64_t v70 = 1 << *(unsigned char *)(v69 + 32);
              uint64_t v71 = v70 < 64 ? ~(-1 << v70) : -1;
              unint64_t v72 = v71 & *(void *)(v69 + 64);
              int64_t v152 = (unint64_t)(v70 + 63) >> 6;
              swift_bridgeObjectRetain();
              unint64_t v159 = v69;
              swift_bridgeObjectRetain_n();
              int64_t v73 = 0;
              while (v72)
              {
                unint64_t v74 = __clz(__rbit64(v72));
                v72 &= v72 - 1;
                int64_t v162 = v73;
                unint64_t v75 = v74 | (v73 << 6);
LABEL_101:
                uint64_t v79 = (uint64_t *)(*(void *)(v159 + 48) + 16 * v75);
                uint64_t v80 = *v79;
                uint64_t v81 = (void *)v79[1];
                char v164 = *(unsigned char *)(*(void *)(v159 + 56) + v75);
                swift_bridgeObjectRetain();
                if (specialized Set.contains(_:)(v80, (uint64_t)v81, v65))
                {
                  unint64_t v82 = v67;
                  goto LABEL_113;
                }
                Swift::String v83 = String.lowercased()();
                char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
                v165[0] = v67;
                unint64_t v86 = specialized __RawDictionaryStorage.find<A>(_:)(v83._countAndFlagsBits, (uint64_t)v83._object);
                uint64_t v87 = *(void *)(v67 + 16);
                BOOL v88 = (v85 & 1) == 0;
                uint64_t v89 = v87 + v88;
                if (__OFADD__(v87, v88)) {
                  goto LABEL_202;
                }
                char v90 = v85;
                if (*(void *)(v67 + 24) < v89)
                {
                  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v89, isUniquelyReferenced_nonNull_native);
                  unint64_t v82 = v165[0];
                  unint64_t v91 = specialized __RawDictionaryStorage.find<A>(_:)(v83._countAndFlagsBits, (uint64_t)v83._object);
                  if ((v90 & 1) != (v92 & 1)) {
                    goto LABEL_214;
                  }
                  unint64_t v86 = v91;
                  if ((v90 & 1) == 0) {
                    goto LABEL_110;
                  }
                  goto LABEL_107;
                }
                if (isUniquelyReferenced_nonNull_native)
                {
                  unint64_t v82 = v67;
                  if ((v85 & 1) == 0) {
                    goto LABEL_110;
                  }
LABEL_107:
                  *(unsigned char *)(*(void *)(v82 + 56) + v86) = v164;
                  goto LABEL_112;
                }
                __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
                uint64_t v126 = static _DictionaryStorage.copy(original:)();
                unint64_t v82 = v126;
                if (!*(void *)(v67 + 16)) {
                  goto LABEL_192;
                }
                long long v127 = (char *)(v126 + 64);
                long long v128 = (char *)(v67 + 64);
                unint64_t v129 = (unint64_t)((1 << *(unsigned char *)(v82 + 32)) + 63) >> 6;
                unint64_t v143 = v67 + 64;
                if (v82 != v67 || v127 >= &v128[8 * v129]) {
                  memmove(v127, v128, 8 * v129);
                }
                int64_t v130 = 0;
                *(void *)(v82 + 16) = *(void *)(v67 + 16);
                uint64_t v131 = 1 << *(unsigned char *)(v67 + 32);
                if (v131 < 64) {
                  uint64_t v132 = ~(-1 << v131);
                }
                else {
                  uint64_t v132 = -1;
                }
                unint64_t v133 = v132 & *(void *)(v67 + 64);
                int64_t v144 = (unint64_t)(v131 + 63) >> 6;
                while (1)
                {
                  if (v133)
                  {
                    unint64_t v134 = __clz(__rbit64(v133));
                    v133 &= v133 - 1;
                    unint64_t v135 = v134 | (v130 << 6);
                    goto LABEL_169;
                  }
                  BOOL v35 = __OFADD__(v130++, 1);
                  if (v35) {
                    goto LABEL_210;
                  }
                  if (v130 >= v144) {
                    goto LABEL_192;
                  }
                  unint64_t v140 = *(void *)(v143 + 8 * v130);
                  if (!v140) {
                    break;
                  }
LABEL_187:
                  unint64_t v133 = (v140 - 1) & v140;
                  unint64_t v135 = __clz(__rbit64(v140)) + (v130 << 6);
LABEL_169:
                  long long v136 = (uint64_t *)(*(void *)(v67 + 48) + 16 * v135);
                  uint64_t v138 = *v136;
                  uint64_t v137 = v136[1];
                  LOBYTE(v136) = *(unsigned char *)(*(void *)(v67 + 56) + v135);
                  uint64_t v139 = (void *)(*(void *)(v82 + 48) + 16 * v135);
                  *uint64_t v139 = v138;
                  v139[1] = v137;
                  *(unsigned char *)(*(void *)(v82 + 56) + v135) = (_BYTE)v136;
                  swift_bridgeObjectRetain();
                }
                int64_t v141 = v130 + 1;
                if (v130 + 1 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140) {
                  goto LABEL_186;
                }
                int64_t v141 = v130 + 2;
                if (v130 + 2 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140) {
                  goto LABEL_186;
                }
                int64_t v141 = v130 + 3;
                if (v130 + 3 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140) {
                  goto LABEL_186;
                }
                int64_t v141 = v130 + 4;
                if (v130 + 4 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140) {
                  goto LABEL_186;
                }
                int64_t v141 = v130 + 5;
                if (v130 + 5 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140) {
                  goto LABEL_186;
                }
                int64_t v141 = v130 + 6;
                if (v130 + 6 >= v144) {
                  goto LABEL_192;
                }
                unint64_t v140 = *(void *)(v143 + 8 * v141);
                if (v140)
                {
LABEL_186:
                  int64_t v130 = v141;
                  goto LABEL_187;
                }
                while (1)
                {
                  int64_t v130 = v141 + 1;
                  if (__OFADD__(v141, 1)) {
                    goto LABEL_213;
                  }
                  if (v130 >= v144) {
                    break;
                  }
                  unint64_t v140 = *(void *)(v143 + 8 * v130);
                  ++v141;
                  if (v140) {
                    goto LABEL_187;
                  }
                }
LABEL_192:
                swift_bridgeObjectRelease();
                if (v90) {
                  goto LABEL_107;
                }
LABEL_110:
                *(void *)(v82 + 8 * (v86 >> 6) + 64) |= 1 << v86;
                *(Swift::String *)(*(void *)(v82 + 48) + 16 * v86) = v83;
                *(unsigned char *)(*(void *)(v82 + 56) + v86) = v164;
                uint64_t v93 = *(void *)(v82 + 16);
                BOOL v35 = __OFADD__(v93, 1);
                uint64_t v94 = v93 + 1;
                if (v35) {
                  goto LABEL_205;
                }
                *(void *)(v82 + 16) = v94;
                swift_bridgeObjectRetain();
LABEL_112:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
LABEL_113:
                v165[0] = v155;
                v165[1] = v157;
                swift_bridgeObjectRetain();
                v95._uint64_t countAndFlagsBits = 46;
                v95._object = (void *)0xE100000000000000;
                String.append(_:)(v95);
                v96._uint64_t countAndFlagsBits = v80;
                v96._object = v81;
                String.append(_:)(v96);
                swift_bridgeObjectRelease();
                Swift::String v97 = String.lowercased()();
                swift_bridgeObjectRelease();
                char v98 = swift_isUniquelyReferenced_nonNull_native();
                v165[0] = v82;
                unint64_t v100 = specialized __RawDictionaryStorage.find<A>(_:)(v97._countAndFlagsBits, (uint64_t)v97._object);
                uint64_t v101 = *(void *)(v82 + 16);
                BOOL v102 = (v99 & 1) == 0;
                uint64_t v103 = v101 + v102;
                if (__OFADD__(v101, v102)) {
                  goto LABEL_199;
                }
                char v104 = v99;
                if (*(void *)(v82 + 24) < v103)
                {
                  specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v103, v98);
                  unint64_t v67 = v165[0];
                  unint64_t v105 = specialized __RawDictionaryStorage.find<A>(_:)(v97._countAndFlagsBits, (uint64_t)v97._object);
                  if ((v104 & 1) != (v106 & 1)) {
                    goto LABEL_214;
                  }
                  unint64_t v100 = v105;
                  if (v104) {
                    goto LABEL_86;
                  }
                  goto LABEL_120;
                }
                if (v98)
                {
                  unint64_t v67 = v82;
                  if (v99) {
                    goto LABEL_86;
                  }
                  goto LABEL_120;
                }
                __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
                uint64_t v109 = static _DictionaryStorage.copy(original:)();
                unint64_t v67 = v109;
                if (!*(void *)(v82 + 16)) {
                  goto LABEL_158;
                }
                unint64_t v110 = (void *)(v109 + 64);
                unint64_t v111 = v82 + 64;
                unint64_t v112 = (unint64_t)((1 << *(unsigned char *)(v67 + 32)) + 63) >> 6;
                if (v67 != v82 || (unint64_t)v110 >= v111 + 8 * v112) {
                  memmove(v110, (const void *)(v82 + 64), 8 * v112);
                }
                int64_t v113 = 0;
                *(void *)(v67 + 16) = *(void *)(v82 + 16);
                uint64_t v114 = 1 << *(unsigned char *)(v82 + 32);
                if (v114 < 64) {
                  uint64_t v115 = ~(-1 << v114);
                }
                else {
                  uint64_t v115 = -1;
                }
                unint64_t v116 = v115 & *(void *)(v82 + 64);
                int64_t v117 = (unint64_t)(v114 + 63) >> 6;
                while (2)
                {
                  if (v116)
                  {
                    unint64_t v118 = __clz(__rbit64(v116));
                    v116 &= v116 - 1;
                    unint64_t v119 = v118 | (v113 << 6);
LABEL_135:
                    uint64_t v120 = (uint64_t *)(*(void *)(v82 + 48) + 16 * v119);
                    uint64_t v122 = *v120;
                    uint64_t v121 = v120[1];
                    LOBYTE(v120) = *(unsigned char *)(*(void *)(v82 + 56) + v119);
                    uint64_t v123 = (void *)(*(void *)(v67 + 48) + 16 * v119);
                    *uint64_t v123 = v122;
                    v123[1] = v121;
                    *(unsigned char *)(*(void *)(v67 + 56) + v119) = (_BYTE)v120;
                    swift_bridgeObjectRetain();
                    continue;
                  }
                  break;
                }
                BOOL v35 = __OFADD__(v113++, 1);
                if (v35) {
                  goto LABEL_209;
                }
                if (v113 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v113);
                if (v124)
                {
LABEL_153:
                  unint64_t v116 = (v124 - 1) & v124;
                  unint64_t v119 = __clz(__rbit64(v124)) + (v113 << 6);
                  goto LABEL_135;
                }
                int64_t v125 = v113 + 1;
                if (v113 + 1 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124) {
                  goto LABEL_152;
                }
                int64_t v125 = v113 + 2;
                if (v113 + 2 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124) {
                  goto LABEL_152;
                }
                int64_t v125 = v113 + 3;
                if (v113 + 3 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124) {
                  goto LABEL_152;
                }
                int64_t v125 = v113 + 4;
                if (v113 + 4 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124) {
                  goto LABEL_152;
                }
                int64_t v125 = v113 + 5;
                if (v113 + 5 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124) {
                  goto LABEL_152;
                }
                int64_t v125 = v113 + 6;
                if (v113 + 6 >= v117) {
                  goto LABEL_158;
                }
                unint64_t v124 = *(void *)(v111 + 8 * v125);
                if (v124)
                {
LABEL_152:
                  int64_t v113 = v125;
                  goto LABEL_153;
                }
                while (1)
                {
                  int64_t v113 = v125 + 1;
                  if (__OFADD__(v125, 1)) {
                    goto LABEL_212;
                  }
                  if (v113 >= v117) {
                    break;
                  }
                  unint64_t v124 = *(void *)(v111 + 8 * v113);
                  ++v125;
                  if (v124) {
                    goto LABEL_153;
                  }
                }
LABEL_158:
                swift_bridgeObjectRelease();
                if (v104)
                {
LABEL_86:
                  *(unsigned char *)(*(void *)(v67 + 56) + v100) = v164;
                  goto LABEL_87;
                }
LABEL_120:
                *(void *)(v67 + 8 * (v100 >> 6) + 64) |= 1 << v100;
                *(Swift::String *)(*(void *)(v67 + 48) + 16 * v100) = v97;
                *(unsigned char *)(*(void *)(v67 + 56) + v100) = v164;
                uint64_t v107 = *(void *)(v67 + 16);
                BOOL v35 = __OFADD__(v107, 1);
                uint64_t v108 = v107 + 1;
                if (v35) {
                  goto LABEL_203;
                }
                *(void *)(v67 + 16) = v108;
                swift_bridgeObjectRetain();
LABEL_87:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                uint64_t v65 = v154;
                int64_t v73 = v162;
              }
              BOOL v35 = __OFADD__(v73, 1);
              int64_t v76 = v73 + 1;
              if (v35) {
                goto LABEL_204;
              }
              if (v76 < v152) {
                break;
              }
LABEL_81:
              swift_bridgeObjectRelease();
              swift_release();
              swift_bridgeObjectRelease();
              uint64_t v66 = v147;
              if (v147 == v148) {
                return v67;
              }
            }
            unint64_t v77 = *(void *)(v150 + 8 * v76);
            if (!v77)
            {
              int64_t v78 = v76 + 1;
              if (v76 + 1 >= v152) {
                goto LABEL_81;
              }
              unint64_t v77 = *(void *)(v150 + 8 * v78);
              if (!v77)
              {
                int64_t v78 = v76 + 2;
                if (v76 + 2 >= v152) {
                  goto LABEL_81;
                }
                unint64_t v77 = *(void *)(v150 + 8 * v78);
                if (!v77)
                {
                  int64_t v78 = v76 + 3;
                  if (v76 + 3 >= v152) {
                    goto LABEL_81;
                  }
                  unint64_t v77 = *(void *)(v150 + 8 * v78);
                  if (!v77)
                  {
                    while (1)
                    {
                      int64_t v76 = v78 + 1;
                      if (__OFADD__(v78, 1)) {
                        break;
                      }
                      if (v76 >= v152) {
                        goto LABEL_81;
                      }
                      unint64_t v77 = *(void *)(v150 + 8 * v76);
                      ++v78;
                      if (v77) {
                        goto LABEL_100;
                      }
                    }
LABEL_207:
                    __break(1u);
LABEL_208:
                    __break(1u);
LABEL_209:
                    __break(1u);
LABEL_210:
                    __break(1u);
                    goto LABEL_211;
                  }
                }
              }
              int64_t v76 = v78;
            }
LABEL_100:
            unint64_t v72 = (v77 - 1) & v77;
            int64_t v162 = v76;
            unint64_t v75 = __clz(__rbit64(v77)) + (v76 << 6);
            goto LABEL_101;
          }
        }
        return MEMORY[0x1E4FBC868];
      }
      goto LABEL_4;
    }
    unint64_t v12 = *(void *)(v158 + 8 * v11);
    ++v7;
    if (!v12)
    {
      int64_t v7 = v11 + 1;
      if (v11 + 1 >= v160) {
        goto LABEL_3;
      }
      unint64_t v12 = *(void *)(v158 + 8 * v7);
      if (!v12)
      {
        int64_t v7 = v11 + 2;
        if (v11 + 2 >= v160) {
          goto LABEL_3;
        }
        unint64_t v12 = *(void *)(v158 + 8 * v7);
        if (!v12)
        {
          int64_t v13 = v11 + 3;
          if (v13 >= v160) {
            goto LABEL_3;
          }
          unint64_t v12 = *(void *)(v158 + 8 * v13);
          if (!v12)
          {
            while (1)
            {
              int64_t v7 = v13 + 1;
              if (__OFADD__(v13, 1)) {
                goto LABEL_206;
              }
              if (v7 >= v160) {
                goto LABEL_3;
              }
              unint64_t v12 = *(void *)(v158 + 8 * v7);
              ++v13;
              if (v12) {
                goto LABEL_25;
              }
            }
          }
          int64_t v7 = v13;
        }
      }
    }
LABEL_25:
    uint64_t v9 = (v12 - 1) & v12;
    unint64_t v10 = __clz(__rbit64(v12)) + (v7 << 6);
LABEL_26:
    uint64_t v14 = (uint64_t *)(*(void *)(v161 + 48) + 16 * v10);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    uint64_t v17 = *(void *)(v2 + 16);
    swift_bridgeObjectRetain();
    if (v17)
    {
      swift_bridgeObjectRetain();
      unint64_t v18 = specialized __RawDictionaryStorage.find<A>(_:)(v15, v16);
      if (v19) {
        uint64_t v20 = *(void *)(*(void *)(v2 + 56) + 8 * v18);
      }
      else {
        uint64_t v20 = 0;
      }
      swift_bridgeObjectRelease();
      uint64_t v21 = v20 + 1;
      if (__OFADD__(v20, 1))
      {
        __break(1u);
LABEL_198:
        __break(1u);
LABEL_199:
        __break(1u);
LABEL_200:
        __break(1u);
LABEL_201:
        __break(1u);
LABEL_202:
        __break(1u);
LABEL_203:
        __break(1u);
LABEL_204:
        __break(1u);
LABEL_205:
        __break(1u);
LABEL_206:
        __break(1u);
        goto LABEL_207;
      }
    }
    else
    {
      uint64_t v21 = 1;
    }
    unint64_t v163 = v9;
    char v22 = swift_isUniquelyReferenced_nonNull_native();
    v165[0] = v2;
    uint64_t v23 = v15;
    unint64_t v25 = specialized __RawDictionaryStorage.find<A>(_:)(v15, v16);
    uint64_t v26 = *(void *)(v2 + 16);
    BOOL v27 = (v24 & 1) == 0;
    uint64_t v28 = v26 + v27;
    if (__OFADD__(v26, v27)) {
      goto LABEL_198;
    }
    char v29 = v24;
    if (*(void *)(v2 + 24) >= v28) {
      break;
    }
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v28, v22);
    unint64_t v30 = v165[0];
    unint64_t v31 = specialized __RawDictionaryStorage.find<A>(_:)(v23, v16);
    if ((v29 & 1) != (v32 & 1)) {
      goto LABEL_214;
    }
    unint64_t v25 = v31;
    if (v29)
    {
LABEL_8:
      *(void *)(*(void *)(v30 + 56) + 8 * v25) = v21;
      goto LABEL_9;
    }
LABEL_39:
    *(void *)(v30 + 8 * (v25 >> 6) + 64) |= 1 << v25;
    long long v33 = (uint64_t *)(*(void *)(v30 + 48) + 16 * v25);
    *long long v33 = v23;
    v33[1] = v16;
    *(void *)(*(void *)(v30 + 56) + 8 * v25) = v21;
    uint64_t v34 = *(void *)(v30 + 16);
    BOOL v35 = __OFADD__(v34, 1);
    uint64_t v36 = v34 + 1;
    if (v35) {
      goto LABEL_200;
    }
    *(void *)(v30 + 16) = v36;
    swift_bridgeObjectRetain();
LABEL_9:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v2 = v30;
    unint64_t v6 = v163;
  }
  if (v22)
  {
    unint64_t v30 = v2;
    if (v24) {
      goto LABEL_8;
    }
    goto LABEL_39;
  }
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Int>);
  uint64_t v37 = static _DictionaryStorage.copy(original:)();
  unint64_t v30 = v37;
  if (!*(void *)(v2 + 16))
  {
LABEL_72:
    swift_bridgeObjectRelease();
    if (v29) {
      goto LABEL_8;
    }
    goto LABEL_39;
  }
  long long v38 = (char *)(v37 + 64);
  long long v39 = (char *)(v2 + 64);
  unint64_t v40 = (unint64_t)((1 << *(unsigned char *)(v30 + 32)) + 63) >> 6;
  uint64_t v146 = v2 + 64;
  if (v30 != v2 || v38 >= &v39[8 * v40]) {
    memmove(v38, v39, 8 * v40);
  }
  int64_t v41 = 0;
  *(void *)(v30 + 16) = *(void *)(v2 + 16);
  uint64_t v42 = 1 << *(unsigned char *)(v2 + 32);
  if (v42 < 64) {
    uint64_t v43 = ~(-1 << v42);
  }
  else {
    uint64_t v43 = -1;
  }
  unint64_t v44 = v43 & *(void *)(v2 + 64);
  int64_t v149 = (unint64_t)(v42 + 63) >> 6;
  while (2)
  {
    if (v44)
    {
      unint64_t v45 = __clz(__rbit64(v44));
      v44 &= v44 - 1;
      unint64_t v46 = v45 | (v41 << 6);
LABEL_50:
      uint64_t v47 = 16 * v46;
      uint64_t v48 = (uint64_t *)(*(void *)(v2 + 48) + 16 * v46);
      uint64_t v50 = *v48;
      uint64_t v49 = v48[1];
      uint64_t v51 = 8 * v46;
      uint64_t v52 = *(void *)(*(void *)(v2 + 56) + v51);
      unint64_t v53 = (void *)(*(void *)(v30 + 48) + v47);
      *unint64_t v53 = v50;
      v53[1] = v49;
      *(void *)(*(void *)(v30 + 56) + v51) = v52;
      swift_bridgeObjectRetain();
      continue;
    }
    break;
  }
  int64_t v54 = v41 + 1;
  if (__OFADD__(v41, 1)) {
    goto LABEL_208;
  }
  if (v54 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v54);
  ++v41;
  if (v55) {
    goto LABEL_71;
  }
  int64_t v41 = v54 + 1;
  if (v54 + 1 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v41);
  if (v55) {
    goto LABEL_71;
  }
  int64_t v41 = v54 + 2;
  if (v54 + 2 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v41);
  if (v55) {
    goto LABEL_71;
  }
  int64_t v41 = v54 + 3;
  if (v54 + 3 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v41);
  if (v55) {
    goto LABEL_71;
  }
  int64_t v41 = v54 + 4;
  if (v54 + 4 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v41);
  if (v55) {
    goto LABEL_71;
  }
  int64_t v41 = v54 + 5;
  if (v54 + 5 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v41);
  if (v55)
  {
LABEL_71:
    unint64_t v44 = (v55 - 1) & v55;
    unint64_t v46 = __clz(__rbit64(v55)) + (v41 << 6);
    goto LABEL_50;
  }
  int64_t v56 = v54 + 6;
  if (v56 >= v149) {
    goto LABEL_72;
  }
  unint64_t v55 = *(void *)(v146 + 8 * v56);
  if (v55)
  {
    int64_t v41 = v56;
    goto LABEL_71;
  }
  while (1)
  {
    int64_t v41 = v56 + 1;
    if (__OFADD__(v56, 1)) {
      break;
    }
    if (v41 >= v149) {
      goto LABEL_72;
    }
    unint64_t v55 = *(void *)(v146 + 8 * v41);
    ++v56;
    if (v55) {
      goto LABEL_71;
    }
  }
LABEL_211:
  __break(1u);
LABEL_212:
  __break(1u);
LABEL_213:
  __break(1u);
LABEL_214:
  uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
  __break(1u);
  return result;
}

uint64_t specialized SQLExpression.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  if (a1 == 0xD000000000000010 && a2 == 0x800000018EBF7A10
    || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x79546E7275746572 && a2 == 0xEA00000000006570 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000014 && a2 == 0x800000018EBF7A30 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x73676E69646E6962 && a2 == 0xE800000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 7106931 && a2 == 0xE300000000000000)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v5) {
      return 4;
    }
    else {
      return 5;
    }
  }
}

uint64_t specialized Binding.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 1701667182 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6570795461746164 && a2 == 0xE800000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

uint64_t specialized AggregationFunction.AggregationType.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 4675137 && a2 == 0xE300000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x544E554F43 && a2 == 0xE500000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x54535F544E554F43 && a2 == 0xEA00000000005241 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x4F435F50554F5247 && a2 == 0xEC0000005441434ELL {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 5783885 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else if (a1 == 5130573 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 5;
  }
  else if (a1 == 5068115 && a2 == 0xE300000000000000 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 6;
  }
  else if (a1 == 0x4C41544F54 && a2 == 0xE500000000000000)
  {
    swift_bridgeObjectRelease();
    return 7;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 7;
    }
    else {
      return 8;
    }
  }
}

uint64_t specialized AggregationFunction.AggregationType.GROUP_CONCATCodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6F74617261706573 && a2 == 0xE900000000000072)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

uint64_t specialized AggregationFunction.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x7461676572676761 && a2 == 0xEF657079546E6F69;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x79546E7275746572 && a2 == 0xEA00000000006570)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

unint64_t lazy protocol witness table accessor for type SQLExpressionError and conformance SQLExpressionError()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError;
  if (!lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError)
  {
    type metadata accessor for SQLExpressionError();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLExpressionError and conformance SQLExpressionError);
  }
  return result;
}

uint64_t __swift_deallocate_boxed_opaque_existential_1(uint64_t result)
{
  if ((*(_DWORD *)(*(void *)(*(void *)(result + 24) - 8) + 80) & 0x20000) != 0) {
    JUMPOUT(0x192FB1900);
  }
  return result;
}

uint64_t sub_18EA57064()
{
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);

  return MEMORY[0x1F4186498](v0, 56, 7);
}

uint64_t sub_18EA5709C()
{
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);

  return MEMORY[0x1F4186498](v0, 66, 7);
}

uint64_t sub_18EA570D4()
{
  if (*(void *)(v0 + 40)) {
    __swift_destroy_boxed_opaque_existential_1Tm(v0 + 16);
  }
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 56);
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 113, 7);
}

uint64_t outlined init with copy of PgQuery_Node(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t outlined destroy of SQLExpressionError(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t outlined init with take of PgQuery_BitString(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t objectdestroyTm()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 56, 7);
}

uint64_t outlined init with take of SQLExpression?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

void *partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  return partial apply for closure #1 in SQLExpressioBoolExpr.init(BOOLExpr:schemas:columnResolver:tokenInformation:)(a1, a2, a3);
}

{
  void *v3;
  uint64_t v4;
  void *result;

  unint64_t result = buildSQLExpression(expressionNode:schemas:columnResolver:tokenInformation:)(a3, a1, v3[2], v3[3], v3[4], v3[5]);
  if (v4) {
    *a2 = v4;
  }
  return result;
}

uint64_t sub_18EA57354()
{
  uint64_t v1 = v0 + 16;
  switch(*(unsigned char *)(v0 + 208))
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
      __swift_destroy_boxed_opaque_existential_1Tm(v1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_3;
    case 2:
      __swift_destroy_boxed_opaque_existential_1Tm(v1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(v0 + 136))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v0 + 112);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_3:
        swift_bridgeObjectRelease();
      }
      break;
    default:
      break;
  }
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 232, 7);
}

unint64_t lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError;
  if (!lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLParserError and conformance SQLParserError);
  }
  return result;
}

uint64_t destroy for SQLExpressionAggregationFunction(uint64_t a1)
{
  switch(*(unsigned char *)(a1 + 192))
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
      __swift_destroy_boxed_opaque_existential_1Tm(a1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      goto LABEL_3;
    case 2:
      __swift_destroy_boxed_opaque_existential_1Tm(a1);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 120))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 96);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
LABEL_3:
        swift_bridgeObjectRelease();
      }
      break;
    default:
      break;
  }

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  switch(*(unsigned char *)(a2 + 192))
  {
    case 0:
      long long v4 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v4;
      (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
      uint64_t v5 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v5;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v6 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v6;
      uint64_t v7 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v7;
      *(unsigned char *)(a1 + 192) = 0;
      goto LABEL_12;
    case 1:
      long long v14 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v14;
      (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
      uint64_t v15 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v15;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v16 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v16;
      uint64_t v17 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v17;
      char v18 = 1;
      goto LABEL_11;
    case 2:
      long long v19 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v19;
      (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
      uint64_t v20 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v20;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v21 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v21;
      uint64_t v22 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v22;
      uint64_t v23 = *(void *)(a2 + 120);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v23)
      {
        uint64_t v24 = *(void *)(a2 + 128);
        *(void *)(a1 + 120) = v23;
        *(void *)(a1 + 128) = v24;
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v23 - 8))(a1 + 96, a2 + 96, v23);
        uint64_t v25 = *(void *)(a2 + 144);
        *(void *)(a1 + 136) = *(void *)(a2 + 136);
        *(void *)(a1 + 144) = v25;
        *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
        uint64_t v26 = *(void *)(a2 + 168);
        *(void *)(a1 + 160) = *(void *)(a2 + 160);
        *(void *)(a1 + 168) = v26;
        uint64_t v27 = *(void *)(a2 + 184);
        *(void *)(a1 + 176) = *(void *)(a2 + 176);
        *(void *)(a1 + 184) = v27;
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v46 = *(_OWORD *)(a2 + 144);
        *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 144) = v46;
        long long v47 = *(_OWORD *)(a2 + 176);
        *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 176) = v47;
        long long v48 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a1 + 112) = v48;
      }
      *(unsigned char *)(a1 + 192) = 2;
      break;
    case 3:
      long long v28 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v28;
      (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1, a2);
      uint64_t v29 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v29;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v30 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v30;
      uint64_t v31 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v31;
      char v18 = 3;
      goto LABEL_11;
    case 4:
      long long v32 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v32;
      (**(void (***)(uint64_t, uint64_t))(v32 - 8))(a1, a2);
      uint64_t v33 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v33;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v34 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v34;
      uint64_t v35 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v35;
      char v18 = 4;
      goto LABEL_11;
    case 5:
      long long v36 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v36;
      (**(void (***)(uint64_t, uint64_t))(v36 - 8))(a1, a2);
      uint64_t v37 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v37;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v38 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v38;
      uint64_t v39 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v39;
      char v18 = 5;
      goto LABEL_11;
    case 6:
      long long v40 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v40;
      (**(void (***)(uint64_t, uint64_t))(v40 - 8))(a1, a2);
      uint64_t v41 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a1 + 48) = v41;
      *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
      uint64_t v42 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v42;
      uint64_t v43 = *(void *)(a2 + 88);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = v43;
      char v18 = 6;
LABEL_11:
      *(unsigned char *)(a1 + 192) = v18;
LABEL_12:
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      break;
    default:
      long long v8 = *(_OWORD *)(a2 + 176);
      *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
      *(_OWORD *)(a1 + 176) = v8;
      *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
      long long v9 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
      *(_OWORD *)(a1 + 112) = v9;
      long long v10 = *(_OWORD *)(a2 + 144);
      *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 144) = v10;
      long long v11 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 48) = v11;
      long long v12 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 80) = v12;
      long long v13 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v13;
      break;
  }
  *(unsigned char *)(a1 + 193) = *(unsigned char *)(a2 + 193);
  uint64_t v44 = *(void *)(a2 + 208);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a1 + 208) = v44;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    switch(*(unsigned char *)(a2 + 192))
    {
      case 0:
        uint64_t v4 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v4;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(unsigned char *)(a1 + 192) = 0;
        goto LABEL_13;
      case 1:
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v14;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 1;
        goto LABEL_12;
      case 2:
        uint64_t v16 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v16;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v16 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        uint64_t v17 = *(void *)(a2 + 120);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v17)
        {
          *(void *)(a1 + 120) = v17;
          *(void *)(a1 + 128) = *(void *)(a2 + 128);
          (**(void (***)(uint64_t, uint64_t, uint64_t))(v17 - 8))(a1 + 96, a2 + 96, v17);
          *(void *)(a1 + 136) = *(void *)(a2 + 136);
          *(void *)(a1 + 144) = *(void *)(a2 + 144);
          *(unsigned char *)(a1 + 152) = *(unsigned char *)(a2 + 152);
          *(void *)(a1 + 160) = *(void *)(a2 + 160);
          *(void *)(a1 + 168) = *(void *)(a2 + 168);
          *(void *)(a1 + 176) = *(void *)(a2 + 176);
          *(void *)(a1 + 184) = *(void *)(a2 + 184);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
        }
        else
        {
          long long v23 = *(_OWORD *)(a2 + 112);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(a1 + 112) = v23;
          long long v24 = *(_OWORD *)(a2 + 128);
          long long v25 = *(_OWORD *)(a2 + 144);
          long long v26 = *(_OWORD *)(a2 + 176);
          *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
          *(_OWORD *)(a1 + 176) = v26;
          *(_OWORD *)(a1 + 128) = v24;
          *(_OWORD *)(a1 + 144) = v25;
        }
        *(unsigned char *)(a1 + 192) = 2;
        break;
      case 3:
        uint64_t v18 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v18;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v18 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 3;
        goto LABEL_12;
      case 4:
        uint64_t v19 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v19;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v19 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 4;
        goto LABEL_12;
      case 5:
        uint64_t v20 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v20;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v20 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 5;
        goto LABEL_12;
      case 6:
        uint64_t v21 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v21;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v21 - 8))(a1, a2);
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        char v15 = 6;
LABEL_12:
        *(unsigned char *)(a1 + 192) = v15;
LABEL_13:
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        break;
      default:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        long long v5 = *(_OWORD *)(a2 + 16);
        long long v6 = *(_OWORD *)(a2 + 32);
        long long v7 = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 64) = v7;
        *(_OWORD *)(a1 + 16) = v5;
        *(_OWORD *)(a1 + 32) = v6;
        long long v8 = *(_OWORD *)(a2 + 80);
        long long v9 = *(_OWORD *)(a2 + 96);
        long long v10 = *(_OWORD *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 128) = v10;
        *(_OWORD *)(a1 + 80) = v8;
        *(_OWORD *)(a1 + 96) = v9;
        long long v11 = *(_OWORD *)(a2 + 144);
        long long v12 = *(_OWORD *)(a2 + 160);
        long long v13 = *(_OWORD *)(a2 + 176);
        *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
        *(_OWORD *)(a1 + 160) = v12;
        *(_OWORD *)(a1 + 176) = v13;
        *(_OWORD *)(a1 + 144) = v11;
        break;
    }
  }
  *(unsigned char *)(a1 + 193) = *(unsigned char *)(a2 + 193);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy216_8(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  long long v6 = *(_OWORD *)(a2 + 96);
  long long v7 = *(_OWORD *)(a2 + 112);
  long long v8 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v8;
  *(_OWORD *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 112) = v7;
  __n128 result = *(__n128 *)(a2 + 160);
  long long v10 = *(_OWORD *)(a2 + 176);
  long long v11 = *(_OWORD *)(a2 + 192);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 192) = v11;
  *(__n128 *)(a1 + 160) = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionAggregationFunction(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    outlined destroy of AggregationFunction.AggregationType(a1);
    long long v4 = *(_OWORD *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 176) = v4;
    *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
    long long v5 = *(_OWORD *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
    *(_OWORD *)(a1 + 112) = v5;
    long long v6 = *(_OWORD *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
    *(_OWORD *)(a1 + 144) = v6;
    long long v7 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 48) = v7;
    long long v8 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 80) = v8;
    long long v9 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v9;
  }
  *(unsigned char *)(a1 + 193) = *(unsigned char *)(a2 + 193);
  uint64_t v10 = *(void *)(a2 + 208);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a1 + 208) = v10;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionAggregationFunction(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 216)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 208);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionAggregationFunction(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 216) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 208) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 216) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionAggregationFunction()
{
  return &unk_1EDD75C30;
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

uint64_t assignWithTake for SQLExpressionNonAggregationFunction(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  return a1;
}

void *type metadata accessor for SQLExpressionNonAggregationFunction()
{
  return &unk_1EDD75CE0;
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

void *type metadata accessor for SQLExpressionConstString()
{
  return &unk_1EDD75138;
}

uint64_t *assignWithCopy for SQLExpressionConst(uint64_t *a1, uint64_t *a2)
{
  return a1;
}

uint64_t assignWithTake for SQLExpressionConst(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

void *type metadata accessor for SQLExpressionConst()
{
  return &unk_1EDD71E60;
}

uint64_t destroy for SQLExpressionAExpr(uint64_t a1)
{
  if (*(void *)(a1 + 24)) {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 40);

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionAExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v5 = *(void *)(a2 + 32);
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = v5;
    (**(void (***)(uint64_t, uint64_t))(v4 - 8))(a1, a2);
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v6;
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
  }
  long long v7 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 64) = v7;
  (**(void (***)(uint64_t, uint64_t))(v7 - 8))(a1 + 40, a2 + 40);
  uint64_t v8 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v8;
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionAExpr(uint64_t a1, long long *a2)
{
  uint64_t v4 = *((void *)a2 + 3);
  if (!*(void *)(a1 + 24))
  {
    if (v4)
    {
      *(void *)(a1 + 24) = v4;
      *(void *)(a1 + 32) = *((void *)a2 + 4);
      (**(void (***)(uint64_t, long long *))(v4 - 8))(a1, a2);
      goto LABEL_8;
    }
LABEL_7:
    long long v5 = *a2;
    long long v6 = a2[1];
    *(void *)(a1 + 32) = *((void *)a2 + 4);
    *(_OWORD *)a1 = v5;
    *(_OWORD *)(a1 + 16) = v6;
    goto LABEL_8;
  }
  if (!v4)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    goto LABEL_7;
  }
  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
LABEL_8:
  __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 40), (uint64_t *)a2 + 5);
  *(void *)(a1 + 80) = *((void *)a2 + 10);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a2 + 96);
  return a1;
}

__n128 __swift_memcpy97_8(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  __n128 result = (__n128)a2[3];
  long long v5 = a2[4];
  long long v6 = a2[5];
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a2 + 96);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionAExpr(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24)) {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 40);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionAExpr(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 97)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 64);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionAExpr(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 88) = 0;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 96) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 97) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 64) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 97) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionAExpr()
{
  return &unk_1EDD71DA8;
}

uint64_t destroy for SQLExpressioBoolExpr()
{
  return swift_bridgeObjectRelease();
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v4 = *(void *)(a2 + 8);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(a2 + 17);
  return a1;
}

__n128 __swift_memcpy18_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u16[0] = a2[1].n128_u16[0];
  *a1 = result;
  return result;
}

uint64_t assignWithTake for SQLExpressioBoolExpr(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressioBoolExpr(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 18)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressioBoolExpr(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_WORD *)(result + 16) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 18) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 18) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressioBoolExpr()
{
  return &unk_1EDD73630;
}

uint64_t initializeWithCopy for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v4;
  (**(void (***)(void))(v4 - 8))();
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return a1;
}

uint64_t assignWithCopy for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  __swift_assign_boxed_opaque_existential_1((uint64_t *)a1, (uint64_t *)a2);
  uint64_t v4 = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  *(void *)(a1 + 40) = v4;
  *(unsigned char *)(a1 + 49) = *(unsigned char *)(a2 + 49);
  return a1;
}

__n128 __swift_memcpy50_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for SQLExpressionNullTest(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v5;
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionNullTest(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 50)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionNullTest(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_WORD *)(result + 48) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 50) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 50) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionNullTest()
{
  return &unk_1EDD73CF0;
}

uint64_t initializeWithCopy for SQLExpressionConst(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v3;
  (**(void (***)(void))(v3 - 8))();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionConst(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionConst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionFuncCall()
{
  return &unk_1EDD73C40;
}

void *type metadata accessor for SQLExpressionColumnRef()
{
  return &unk_1EDD74940;
}

uint64_t initializeBufferWithCopyOfBuffer for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v3;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SQLExpressionInteger(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(unsigned char *)(a1 + 4) = *(unsigned char *)(a2 + 4);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionInteger(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionInteger(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionInteger()
{
  return &unk_1EDD736E8;
}

void *type metadata accessor for SQLExpressionFloat()
{
  return &unk_1EDD71F10;
}

void *type metadata accessor for SQLExpressionString()
{
  return &unk_1EDD72DE8;
}

void *type metadata accessor for SQLExpressionBitString()
{
  return &unk_1EDD74888;
}

uint64_t destroy for SQLExpressionConstString()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SQLExpressionConstString(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLExpressionConstString(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLExpressionConstString(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

void *type metadata accessor for SQLExpressionNull()
{
  return &unk_1EDD71548;
}

Swift::Int specialized RawRepresentable<>._rawHashValue(seed:)()
{
  return Hasher._finalize()();
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF013SQLExpressionH033_B787555787B9EFBBEFB0C9C5225A4FB7LL_psAE_pTg5(void (*a1)(long long *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  int64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1E4FBC860];
  if (v5)
  {
    uint64_t v17 = MEMORY[0x1E4FBC860];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v5, 0);
    uint64_t v6 = v17;
    uint64_t v9 = *(void *)(type metadata accessor for PgQuery_Node(0) - 8);
    uint64_t v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    uint64_t v11 = *(void *)(v9 + 72);
    while (1)
    {
      a1(v16, v10, &v15);
      if (v4) {
        break;
      }
      uint64_t v4 = 0;
      uint64_t v17 = v6;
      unint64_t v13 = *(void *)(v6 + 16);
      unint64_t v12 = *(void *)(v6 + 24);
      if (v13 >= v12 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((void *)(v12 > 1), v13 + 1, 1);
        uint64_t v6 = v17;
      }
      *(void *)(v6 + 16) = v13 + 1;
      outlined init with take of Aggregation(v16, v6 + 40 * v13 + 32);
      v10 += v11;
      if (!--v5) {
        return v6;
      }
    }
    swift_release();
  }
  return v6;
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF12ResultColumnVsAE_pTg5(void (*a1)(_OWORD *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1E4FBC860];
  if (v5)
  {
    uint64_t v23 = MEMORY[0x1E4FBC860];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    uint64_t v6 = v23;
    uint64_t v9 = *(void *)(type metadata accessor for PgQuery_Node(0) - 8);
    uint64_t v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    uint64_t v11 = *(void *)(v9 + 72);
    while (1)
    {
      a1(v22, v10, &v21);
      if (v4) {
        break;
      }
      uint64_t v4 = 0;
      uint64_t v23 = v6;
      unint64_t v12 = *(void *)(v6 + 16);
      if (v12 >= *(void *)(v6 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v6 = v23;
      }
      *(void *)(v6 + 16) = v12 + 1;
      unint64_t v13 = (_OWORD *)(v6 + (v12 << 7));
      long long v14 = v22[0];
      long long v15 = v22[1];
      long long v16 = v22[3];
      v13[4] = v22[2];
      uint64_t v13[5] = v16;
      v13[2] = v14;
      v13[3] = v15;
      long long v17 = v22[4];
      long long v18 = v22[5];
      long long v19 = v22[7];
      v13[8] = v22[6];
      v13[9] = v19;
      v13[6] = v17;
      v13[7] = v18;
      v10 += v11;
      if (!--v5) {
        return v6;
      }
    }
    swift_release();
  }
  return v6;
}

uint64_t _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF13SQLExpressionVsAE_pTg5(void (*a1)(_OWORD *__return_ptr, uint64_t, uint64_t *), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1E4FBC860];
  if (v5)
  {
    uint64_t v21 = MEMORY[0x1E4FBC860];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
    uint64_t v6 = v21;
    uint64_t v9 = *(void *)(type metadata accessor for PgQuery_Node(0) - 8);
    uint64_t v10 = a3 + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80));
    uint64_t v11 = *(void *)(v9 + 72);
    while (1)
    {
      a1(v20, v10, &v19);
      if (v4) {
        break;
      }
      uint64_t v4 = 0;
      uint64_t v21 = v6;
      unint64_t v12 = *(void *)(v6 + 16);
      if (v12 >= *(void *)(v6 + 24) >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        uint64_t v6 = v21;
      }
      *(void *)(v6 + 16) = v12 + 1;
      unint64_t v13 = (_OWORD *)(v6 + 96 * v12);
      long long v14 = v20[1];
      v13[2] = v20[0];
      v13[3] = v14;
      long long v15 = v20[2];
      long long v16 = v20[3];
      long long v17 = v20[5];
      v13[6] = v20[4];
      v13[7] = v17;
      v13[4] = v15;
      uint64_t v13[5] = v16;
      v10 += v11;
      if (!--v5) {
        return v6;
      }
    }
    swift_release();
  }
  return v6;
}

uint64_t specialized Set.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 16))
  {
    Hasher.init(_seed:)();
    String.hash(into:)();
    Swift::Int v6 = Hasher._finalize()();
    uint64_t v7 = -1 << *(unsigned char *)(a3 + 32);
    unint64_t v8 = v6 & ~v7;
    uint64_t v9 = a3 + 56;
    if ((*(void *)(a3 + 56 + ((v8 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v8))
    {
      uint64_t v10 = *(void *)(a3 + 48);
      uint64_t v11 = (void *)(v10 + 16 * v8);
      BOOL v12 = *v11 == a1 && v11[1] == a2;
      if (v12 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
        return 1;
      }
      uint64_t v14 = ~v7;
      unint64_t v15 = (v8 + 1) & v14;
      if ((*(void *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15))
      {
        while (1)
        {
          long long v16 = (void *)(v10 + 16 * v15);
          BOOL v17 = *v16 == a1 && v16[1] == a2;
          if (v17 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
            break;
          }
          uint64_t result = 0;
          unint64_t v15 = (v15 + 1) & v14;
          if (((*(void *)(v9 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v15) & 1) == 0) {
            return result;
          }
        }
        return 1;
      }
    }
  }
  return 0;
}

Swift::String __swiftcall __spoils<CF,ZF,NF,VF,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X21,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> SQLTokenInformation.tokenName(location:)(Swift::Int32 location)
{
  uint64_t v3 = *(void **)&location;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_ScanToken?);
  MEMORY[0x1F4188790](v4 - 8);
  Swift::Int v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  uint64_t v7 = *(void *)(ScanToken - 8);
  uint64_t v8 = MEMORY[0x1F4188790](ScanToken);
  uint64_t v10 = (_DWORD *)((char *)&v32 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v8);
  BOOL v12 = (char *)&v32 - v11;
  uint64_t v13 = *(void *)(v1 + 8);
  uint64_t v14 = *(void *)(v13 + 16);
  if (v14)
  {
    uint64_t v33 = (char *)&v32 - v11;
    uint64_t v34 = v2;
    uint64_t v15 = v13 + ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
    uint64_t v16 = *(void *)(v7 + 72);
    swift_bridgeObjectRetain();
    while (1)
    {
      outlined init with copy of PgQuery_ScanResult(v15, (uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
      if (*v10 == v3) {
        break;
      }
      outlined destroy of PgQuery_ParseResult((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
      v15 += v16;
      if (!--v14)
      {
        uint64_t v17 = 1;
        goto LABEL_8;
      }
    }
    outlined init with take of PgQuery_ParseResult((uint64_t)v10, (uint64_t)v6, type metadata accessor for PgQuery_ScanToken);
    uint64_t v17 = 0;
LABEL_8:
    BOOL v12 = v33;
  }
  else
  {
    swift_bridgeObjectRetain();
    uint64_t v17 = 1;
  }
  uint64_t v18 = ScanToken;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 56))(v6, v17, 1, ScanToken);
  swift_bridgeObjectRelease();
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48))(v6, 1, v18) == 1)
  {
    outlined destroy of AnyValue?((uint64_t)v6, &demangling cache variable for type metadata for PgQuery_ScanToken?);
    uint64_t v19 = (uint64_t *)(v1 + *(int *)(type metadata accessor for SQLTokenInformation(0) + 20));
    uint64_t v21 = *v19;
    uint64_t v20 = v19[1];
    unint64_t v36 = 0;
    unint64_t v37 = 0xE000000000000000;
    swift_bridgeObjectRetain();
    _StringGuts.grow(_:)(28);
    swift_bridgeObjectRelease();
    unint64_t v36 = 0xD00000000000001ALL;
    unint64_t v37 = 0x800000018EBF7D60;
    int v38 = (int)v3;
    v22._uint64_t countAndFlagsBits = dispatch thunk of CustomStringConvertible.description.getter();
    String.append(_:)(v22);
    swift_bridgeObjectRelease();
    unint64_t v23 = v36;
    uint64_t v24 = v37;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v25 = v21;
    *(void *)(v25 + 8) = v20;
    *(void *)(v25 + 16) = v23;
    *(void *)(v25 + 24) = v24;
    *(unsigned char *)(v25 + 32) = 0;
    swift_willThrow();
  }
  else
  {
    outlined init with take of PgQuery_ParseResult((uint64_t)v6, (uint64_t)v12, type metadata accessor for PgQuery_ScanToken);
    type metadata accessor for SQLTokenInformation(0);
    unint64_t v26 = String.index(_:offsetBy:)();
    unint64_t v27 = String.index(_:offsetBy:)();
    if (v27 >> 14 < v26 >> 14)
    {
      __break(1u);
      goto LABEL_15;
    }
    uint64_t v29 = String.subscript.getter();
    uint64_t v24 = MEMORY[0x192FAFFE0](v29);
    uint64_t v3 = v30;
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult((uint64_t)v12, type metadata accessor for PgQuery_ScanToken);
  }
  unint64_t v27 = v24;
  long long v28 = v3;
LABEL_15:
  result._object = v28;
  result._uint64_t countAndFlagsBits = v27;
  return result;
}

uint64_t specialized Array.append<A>(contentsOf:)(uint64_t result)
{
  uint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = *v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v6 = result;
  Swift::String result = swift_isUniquelyReferenced_nonNull_native();
  if (result && v5 <= *(void *)(v3 + 24) >> 1)
  {
    if (*(void *)(v6 + 16)) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  if (v4 <= v5) {
    int64_t v10 = v4 + v2;
  }
  else {
    int64_t v10 = v4;
  }
  Swift::String result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v10, 1, (char *)v3);
  uint64_t v3 = result;
  if (!*(void *)(v6 + 16))
  {
LABEL_13:
    if (!v2) {
      goto LABEL_14;
    }
    goto LABEL_16;
  }
LABEL_5:
  if ((*(void *)(v3 + 24) >> 1) - *(void *)(v3 + 16) < v2)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  Swift::String result = swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_14:
    Swift::String result = swift_bridgeObjectRelease();
    *uint64_t v1 = v3;
    return result;
  }
  uint64_t v7 = *(void *)(v3 + 16);
  BOOL v8 = __OFADD__(v7, v2);
  uint64_t v9 = v7 + v2;
  if (!v8)
  {
    *(void *)(v3 + 16) = v9;
    goto LABEL_14;
  }
LABEL_18:
  __break(1u);
  return result;
}

{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  int64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  int64_t v10;

  uint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = *v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }
  uint64_t v6 = result;
  Swift::String result = swift_isUniquelyReferenced_nonNull_native();
  if (result && v5 <= *(void *)(v3 + 24) >> 1)
  {
    if (*(void *)(v6 + 16)) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  if (v4 <= v5) {
    int64_t v10 = v4 + v2;
  }
  else {
    int64_t v10 = v4;
  }
  Swift::String result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)result, v10, 1, (char *)v3);
  uint64_t v3 = result;
  if (!*(void *)(v6 + 16))
  {
LABEL_13:
    if (!v2) {
      goto LABEL_14;
    }
    goto LABEL_16;
  }
LABEL_5:
  if ((*(void *)(v3 + 24) >> 1) - *(void *)(v3 + 16) < v2)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  Swift::String result = swift_arrayInitWithCopy();
  if (!v2)
  {
LABEL_14:
    Swift::String result = swift_bridgeObjectRelease();
    *uint64_t v1 = v3;
    return result;
  }
  uint64_t v7 = *(void *)(v3 + 16);
  BOOL v8 = __OFADD__(v7, v2);
  uint64_t v9 = v7 + v2;
  if (!v8)
  {
    *(void *)(v3 + 16) = v9;
    goto LABEL_14;
  }
LABEL_18:
  __break(1u);
  return result;
}

unint64_t SQLParserError.description.getter()
{
  uint64_t v2 = *(void *)v0;
  unint64_t v1 = *(void *)(v0 + 8);
  uint64_t v3 = *(void *)(v0 + 16);
  unint64_t v4 = *(void *)(v0 + 24);
  switch(*(unsigned char *)(v0 + 32))
  {
    case 1:
      _StringGuts.grow(_:)(29);
      swift_bridgeObjectRelease();
      unint64_t v5 = 0xD00000000000001ALL;
      goto LABEL_5;
    case 2:
      _StringGuts.grow(_:)(42);
      swift_bridgeObjectRelease();
      unint64_t v22 = 0x20656C626154;
      v8._uint64_t countAndFlagsBits = v2;
      v8._object = (void *)v1;
      String.append(_:)(v8);
      unint64_t v9 = 0xD000000000000022;
      unint64_t v10 = 0x800000018EBF7BE0;
      goto LABEL_15;
    case 3:
      unint64_t v22 = 0;
      _StringGuts.grow(_:)(53);
      v11._uint64_t countAndFlagsBits = 0xD000000000000032;
      v11._object = (void *)0x800000018EBF7BA0;
      String.append(_:)(v11);
      goto LABEL_8;
    case 4:
      unint64_t v22 = 0;
      _StringGuts.grow(_:)(60);
      v14._uint64_t countAndFlagsBits = 0xD000000000000029;
      v14._object = (void *)0x800000018EBF7B70;
      String.append(_:)(v14);
      v15._uint64_t countAndFlagsBits = v2;
      v15._object = (void *)v1;
      String.append(_:)(v15);
      v16._uint64_t countAndFlagsBits = 0x6120687469772022;
      v16._object = (void *)0xEE0022203A736772;
      String.append(_:)(v16);
      v17._uint64_t countAndFlagsBits = MEMORY[0x192FB0130](v3, MEMORY[0x1E4FBB1A0]);
      String.append(_:)(v17);
      swift_bridgeObjectRelease();
      goto LABEL_12;
    case 5:
    case 6:
      _StringGuts.grow(_:)(50);
      swift_bridgeObjectRelease();
      unint64_t v5 = 0xD00000000000002FLL;
LABEL_5:
      unint64_t v22 = v5;
LABEL_8:
      uint64_t v12 = v2;
      unint64_t v13 = v1;
      goto LABEL_11;
    case 7:
      unint64_t v22 = 0;
      _StringGuts.grow(_:)(109);
      v18._uint64_t countAndFlagsBits = 0xD00000000000005CLL;
      v18._object = (void *)0x800000018EBF7A70;
      String.append(_:)(v18);
      v19._uint64_t countAndFlagsBits = v2;
      v19._object = (void *)v1;
      String.append(_:)(v19);
      v20._uint64_t countAndFlagsBits = 0x6F73616552202E22;
      v20._object = (void *)0xEC00000022203A6ELL;
      String.append(_:)(v20);
      uint64_t v12 = v3;
      unint64_t v13 = v4;
LABEL_11:
      String.append(_:)(*(Swift::String *)&v12);
LABEL_12:
      unint64_t v9 = 34;
      unint64_t v10 = 0xE100000000000000;
      goto LABEL_15;
    case 8:
      _StringGuts.grow(_:)(33);
      swift_bridgeObjectRelease();
      unint64_t v22 = 0xD00000000000001FLL;
      goto LABEL_14;
    case 9:
      if (v1 | v2 | v3 | v4) {
        return 0xD000000000000036;
      }
      else {
        return 0xD000000000000026;
      }
    default:
      _StringGuts.grow(_:)(29);
      swift_bridgeObjectRelease();
      unint64_t v22 = 0xD000000000000016;
      v6._uint64_t countAndFlagsBits = v3;
      v6._object = (void *)v4;
      String.append(_:)(v6);
      v7._uint64_t countAndFlagsBits = 657954;
      v7._object = (void *)0xE300000000000000;
      String.append(_:)(v7);
LABEL_14:
      unint64_t v9 = v2;
      unint64_t v10 = v1;
LABEL_15:
      String.append(_:)(*(Swift::String *)&v9);
      return v22;
  }
}

BiomeSQLParser::SQLDataType_optional __swiftcall SQLDataType.init(rawValue:)(Swift::String rawValue)
{
  object = rawValue._object;
  v3._uint64_t countAndFlagsBits = rawValue._countAndFlagsBits;
  unint64_t v4 = v1;
  v3._object = object;
  unint64_t v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of SQLDataType.init(rawValue:), v3);
  result.value = swift_bridgeObjectRelease();
  char v7 = 8;
  if (v5 < 8) {
    char v7 = v5;
  }
  *unint64_t v4 = v7;
  return result;
}

uint64_t SQLDataType.rawValue.getter()
{
  uint64_t result = 0x72656765746E69;
  switch(*v0)
  {
    case 1:
      uint64_t result = 0x656C62756F64;
      break;
    case 2:
      uint64_t result = 0x676E69727473;
      break;
    case 3:
      uint64_t result = 1702125924;
      break;
    case 4:
      uint64_t result = 1635017060;
      break;
    case 5:
      uint64_t result = 1852797802;
      break;
    case 6:
      uint64_t result = 1684632949;
      break;
    case 7:
      uint64_t result = 1819047278;
      break;
    default:
      return result;
  }
  return result;
}

BiomeSQLParser::SQLDataType_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLDataType(Swift::String *a1)
{
  return SQLDataType.init(rawValue:)(*a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SQLDataType()
{
  return RawRepresentable<>.init(from:)();
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SQLDataType()
{
  return RawRepresentable<>.encode(to:)();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLDataType()
{
  return specialized RawRepresentable<>._rawHashValue(seed:)();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLDataType()
{
  return specialized RawRepresentable<>.hash(into:)();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLDataType()
{
  return specialized RawRepresentable<>._rawHashValue(seed:)();
}

BiomeSQLParser::SQLRawDataType_optional __swiftcall SQLRawDataType.init(rawValue:)(Swift::String rawValue)
{
  object = rawValue._object;
  v3._uint64_t countAndFlagsBits = rawValue._countAndFlagsBits;
  unint64_t v4 = v1;
  v3._object = object;
  unint64_t v5 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of SQLRawDataType.init(rawValue:), v3);
  result.value = swift_bridgeObjectRelease();
  char v7 = 5;
  if (v5 < 5) {
    char v7 = v5;
  }
  *unint64_t v4 = v7;
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SQLRawDataType(unsigned __int8 *a1, char *a2)
{
  return specialized == infix<A>(_:_:)(*a1, *a2);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance SQLRawDataType()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SQLRawDataType()
{
  String.hash(into:)();

  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SQLRawDataType()
{
  return Hasher._finalize()();
}

BiomeSQLParser::SQLRawDataType_optional protocol witness for RawRepresentable.init(rawValue:) in conformance SQLRawDataType(Swift::String *a1)
{
  return SQLRawDataType.init(rawValue:)(*a1);
}

BiomeSQLParser::DatabaseCatalog __swiftcall DatabaseCatalog.init(schemas:)(Swift::OpaquePointer schemas)
{
  uint64_t v35 = v1;
  int64_t v3 = *((void *)schemas._rawValue + 2);
  if (v3)
  {
    uint64_t v39 = MEMORY[0x1E4FBC860];
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v3, 0);
    uint64_t v4 = v39;
    unint64_t v5 = (char *)schemas._rawValue + 40;
    do
    {
      uint64_t v6 = *((void *)v5 - 1);
      long long v36 = *v5;
      unint64_t v8 = *(void *)(v39 + 16);
      unint64_t v7 = *(void *)(v39 + 24);
      uint64_t v9 = *(void *)v5;
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain();
      if (v8 >= v7 >> 1) {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((void *)(v7 > 1), v8 + 1, 1);
      }
      unint64_t v5 = (_OWORD *)((char *)v5 + 24);
      *(void *)(v39 + 16) = v8 + 1;
      uint64_t v10 = v39 + 40 * v8;
      *(void *)(v10 + 32) = v6;
      *(void *)(v10 + 40) = v9;
      *(void *)(v10 + 48) = v6;
      *(_OWORD *)(v10 + 56) = v36;
      --v3;
    }
    while (v3);
    swift_bridgeObjectRelease();
    if (*(void *)(v39 + 16)) {
      goto LABEL_7;
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    uint64_t v4 = MEMORY[0x1E4FBC860];
    if (*(void *)(MEMORY[0x1E4FBC860] + 16))
    {
LABEL_7:
      __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, Schema>);
      Swift::String v11 = (void *)static _DictionaryStorage.allocate(capacity:)();
      uint64_t v12 = *(void *)(v4 + 16);
      goto LABEL_10;
    }
  }
  uint64_t v12 = 0;
  Swift::String v11 = (void *)MEMORY[0x1E4FBC868];
LABEL_10:
  long long v40 = v11;
  swift_bridgeObjectRetain_n();
  if (v12)
  {
    unint64_t v13 = 0;
    Swift::String v14 = (_OWORD *)(v4 + 56);
    while (v13 < *(void *)(v4 + 16))
    {
      long long v37 = *v14;
      uint64_t v15 = *((void *)v14 - 2);
      uint64_t v16 = *((void *)v14 - 1);
      uint64_t v17 = *((void *)v14 - 3);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (!v15) {
        goto LABEL_20;
      }
      unint64_t v18 = specialized __RawDictionaryStorage.find<A>(_:)(v17, v15);
      uint64_t v20 = v11[2];
      BOOL v21 = (v19 & 1) == 0;
      BOOL v22 = __OFADD__(v20, v21);
      uint64_t v23 = v20 + v21;
      if (v22) {
        goto LABEL_22;
      }
      char v24 = v19;
      if (v11[3] < v23)
      {
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v23, 1);
        Swift::String v11 = v40;
        unint64_t v18 = specialized __RawDictionaryStorage.find<A>(_:)(v17, v15);
        if ((v24 & 1) != (v25 & 1)) {
          goto LABEL_26;
        }
      }
      if (v24) {
        goto LABEL_24;
      }
      v11[(v18 >> 6) + 8] |= 1 << v18;
      unint64_t v26 = (uint64_t *)(v11[6] + 16 * v18);
      *unint64_t v26 = v17;
      v26[1] = v15;
      uint64_t v27 = v11[7] + 24 * v18;
      *(void *)uint64_t v27 = v16;
      *(_OWORD *)(v27 + 8) = v37;
      uint64_t v28 = v11[2];
      BOOL v22 = __OFADD__(v28, 1);
      uint64_t v29 = v28 + 1;
      if (v22) {
        goto LABEL_23;
      }
      ++v13;
      v11[2] = v29;
      Swift::String v14 = (_OWORD *)((char *)v14 + 40);
      if (v12 == v13) {
        goto LABEL_20;
      }
    }
    __break(1u);
LABEL_22:
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    uint64_t v31 = (void *)swift_allocError();
    swift_willThrow();
    id v38 = v31;
    id v32 = v31;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
    if ((swift_dynamicCast() & 1) == 0) {
      goto LABEL_27;
    }
    _StringGuts.grow(_:)(30);
    v33._object = (void *)0x800000018EBE9730;
    v33._uint64_t countAndFlagsBits = 0xD00000000000001BLL;
    String.append(_:)(v33);
    _print_unlocked<A, B>(_:_:)();
    v34._uint64_t countAndFlagsBits = 39;
    v34._object = (void *)0xE100000000000000;
    String.append(_:)(v34);
    _assertionFailure(_:_:file:line:flags:)();
    __break(1u);
LABEL_26:
    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
    __break(1u);
LABEL_27:
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();

    result.schemas._rawValue = (void *)swift_unexpectedError();
    __break(1u);
  }
  else
  {
LABEL_20:
    result.schemas._rawValue = (void *)swift_bridgeObjectRelease_n();
    *uint64_t v35 = v11;
  }
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance DatabaseCatalog.CodingKeys()
{
  return 0x73616D65686373;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance DatabaseCatalog.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (a1 == 0x73616D65686373 && a2 == 0xE700000000000000)
  {
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = 0;
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance DatabaseCatalog.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance DatabaseCatalog.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t DatabaseCatalog.encode(to:)(void *a1)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<DatabaseCatalog.CodingKeys>);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = (char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *v1;
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v9[1] = v7;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : Schema]);
  lazy protocol witness table accessor for type [String : Schema] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : Schema] and conformance <> [A : B], (void (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  return (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t DatabaseCatalog.init(from:)@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedDecodingContainer<DatabaseCatalog.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  unint64_t v8 = (char *)v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys();
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (!v2)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : Schema]);
    lazy protocol witness table accessor for type [String : Schema] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : Schema] and conformance <> [A : B], (void (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema);
    KeyedDecodingContainer.decode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
    *a2 = v10[1];
  }
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance DatabaseCatalog@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return DatabaseCatalog.init(from:)(a1, a2);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance DatabaseCatalog(void *a1)
{
  return DatabaseCatalog.encode(to:)(a1);
}

uint64_t static Schema.lookup(rangeVar:catalog:)@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = a1[3];
  uint64_t v5 = a1[2] & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(v4) & 0xF;
  }
  if (v5)
  {
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v6 = 0xD00000000000003ELL;
    uint64_t v7 = 0x800000018EBF8020;
    char v8 = 1;
  }
  else
  {
    uint64_t v9 = *a2;
    uint64_t v10 = a1[4];
    uint64_t v7 = a1[5];
    uint64_t v11 = *(void *)(*a2 + 16);
    swift_bridgeObjectRetain();
    if (v11)
    {
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      unint64_t v12 = specialized __RawDictionaryStorage.find<A>(_:)(v10, v7);
      if (v13)
      {
        Swift::String v14 = (uint64_t *)(*(void *)(v9 + 56) + 24 * v12);
        uint64_t v16 = *v14;
        uint64_t v15 = v14[1];
        uint64_t v17 = v14[2];
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRelease();
        uint64_t result = swift_bridgeObjectRelease_n();
        *a3 = v16;
        a3[1] = v15;
        a3[2] = v17;
        return result;
      }
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v6 = v10;
    char v8 = 2;
  }
  *(void *)(v6 + 16) = 0;
  *(void *)(v6 + 24) = 0;
  *(void *)(v6 + 8) = v7;
  *(unsigned char *)(v6 + 32) = v8;
  return swift_willThrow();
}

uint64_t static Schema.== infix(_:_:)(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2[2];
  BOOL v4 = *a1 == *a2 && a1[1] == a2[1];
  if (!v4 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
    return 0;
  }

  return specialized static Dictionary<>.== infix(_:_:)(v2, v3);
}

uint64_t specialized static Dictionary<>.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
      return 0;
    }
    int64_t v4 = 0;
    uint64_t v5 = a1 + 64;
    uint64_t v6 = 1 << *(unsigned char *)(a1 + 32);
    uint64_t v7 = -1;
    if (v6 < 64) {
      uint64_t v7 = ~(-1 << v6);
    }
    unint64_t v8 = v7 & *(void *)(a1 + 64);
    int64_t v9 = (unint64_t)(v6 + 63) >> 6;
    if (v8) {
      goto LABEL_9;
    }
LABEL_10:
    int64_t v13 = v4 + 1;
    if (__OFADD__(v4, 1))
    {
      __break(1u);
      goto LABEL_56;
    }
    if (v13 < v9)
    {
      unint64_t v14 = *(void *)(v5 + 8 * v13);
      ++v4;
      if (v14) {
        goto LABEL_25;
      }
      int64_t v4 = v13 + 1;
      if (v13 + 1 < v9)
      {
        unint64_t v14 = *(void *)(v5 + 8 * v4);
        if (v14) {
          goto LABEL_25;
        }
        int64_t v4 = v13 + 2;
        if (v13 + 2 < v9)
        {
          unint64_t v14 = *(void *)(v5 + 8 * v4);
          if (v14) {
            goto LABEL_25;
          }
          int64_t v4 = v13 + 3;
          if (v13 + 3 < v9)
          {
            unint64_t v14 = *(void *)(v5 + 8 * v4);
            if (v14) {
              goto LABEL_25;
            }
            int64_t v15 = v13 + 4;
            if (v15 < v9)
            {
              unint64_t v14 = *(void *)(v5 + 8 * v15);
              if (v14)
              {
                int64_t v4 = v15;
LABEL_25:
                unint64_t v8 = (v14 - 1) & v14;
                unint64_t v12 = __clz(__rbit64(v14)) + (v4 << 6);
                while (1)
                {
                  uint64_t v16 = (uint64_t *)(*(void *)(a1 + 48) + 16 * v12);
                  uint64_t v17 = *v16;
                  uint64_t v18 = v16[1];
                  uint64_t v19 = *(unsigned __int8 *)(*(void *)(a1 + 56) + v12);
                  swift_bridgeObjectRetain();
                  unint64_t v20 = specialized __RawDictionaryStorage.find<A>(_:)(v17, v18);
                  char v22 = v21;
                  swift_bridgeObjectRelease();
                  if ((v22 & 1) == 0) {
                    return 0;
                  }
                  uint64_t v23 = *(unsigned __int8 *)(*(void *)(a2 + 56) + v20);
                  unint64_t v24 = 0xE700000000000000;
                  uint64_t v25 = 0x72656765746E69;
                  switch(v23)
                  {
                    case 1:
                      unint64_t v24 = 0xE600000000000000;
                      uint64_t v25 = 0x656C62756F64;
                      break;
                    case 2:
                      unint64_t v24 = 0xE600000000000000;
                      uint64_t v25 = 0x676E69727473;
                      break;
                    case 3:
                      unint64_t v24 = 0xE400000000000000;
                      uint64_t v25 = 1702125924;
                      break;
                    case 4:
                      unint64_t v24 = 0xE400000000000000;
                      uint64_t v25 = 1635017060;
                      break;
                    case 5:
                      unint64_t v24 = 0xE400000000000000;
                      uint64_t v25 = 1852797802;
                      break;
                    case 6:
                      unint64_t v24 = 0xE400000000000000;
                      uint64_t v25 = 1684632949;
                      break;
                    case 7:
                      unint64_t v24 = 0xE400000000000000;
                      uint64_t v25 = 1819047278;
                      break;
                    default:
                      break;
                  }
                  unint64_t v26 = 0xE700000000000000;
                  uint64_t v27 = 0x72656765746E69;
                  switch(v19)
                  {
                    case 1:
                      unint64_t v26 = 0xE600000000000000;
                      if (v25 != 0x656C62756F64) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    case 2:
                      unint64_t v26 = 0xE600000000000000;
                      if (v25 != 0x676E69727473) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    case 3:
                      unint64_t v26 = 0xE400000000000000;
                      if (v25 != 1702125924) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    case 4:
                      unint64_t v26 = 0xE400000000000000;
                      if (v25 != 1635017060) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    case 5:
                      unint64_t v26 = 0xE400000000000000;
                      if (v25 != 1852797802) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    case 6:
                      unint64_t v26 = 0xE400000000000000;
                      uint64_t v27 = 1684632949;
                      goto LABEL_47;
                    case 7:
                      unint64_t v26 = 0xE400000000000000;
                      if (v25 != 1819047278) {
                        goto LABEL_7;
                      }
                      goto LABEL_48;
                    default:
LABEL_47:
                      if (v25 != v27) {
                        goto LABEL_7;
                      }
LABEL_48:
                      if (v24 == v26)
                      {
                        swift_bridgeObjectRelease_n();
                        if (!v8) {
                          goto LABEL_10;
                        }
                      }
                      else
                      {
LABEL_7:
                        char v10 = _stringCompareWithSmolCheck(_:_:expecting:)();
                        swift_bridgeObjectRelease();
                        swift_bridgeObjectRelease();
                        if ((v10 & 1) == 0) {
                          return 0;
                        }
                        if (!v8) {
                          goto LABEL_10;
                        }
                      }
LABEL_9:
                      unint64_t v11 = __clz(__rbit64(v8));
                      v8 &= v8 - 1;
                      unint64_t v12 = v11 | (v4 << 6);
                      break;
                  }
                }
              }
              while (1)
              {
                int64_t v4 = v15 + 1;
                if (__OFADD__(v15, 1)) {
                  break;
                }
                if (v4 >= v9) {
                  return 1;
                }
                unint64_t v14 = *(void *)(v5 + 8 * v4);
                ++v15;
                if (v14) {
                  goto LABEL_25;
                }
              }
LABEL_56:
              __break(1u);
              JUMPOUT(0x18EA5B2C0);
            }
          }
        }
      }
    }
  }
  return 1;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance Schema.CodingKeys()
{
  if (*v0) {
    return 0x736E6D756C6F63;
  }
  else {
    return 0x6D614E656C626174;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance Schema.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized Schema.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Schema.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Schema.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t Schema.encode(to:)(void *a1)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<Schema.CodingKeys>);
  uint64_t v10 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4);
  uint64_t v6 = (char *)&v8 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = *(void *)(v1 + 16);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  char v13 = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v2)
  {
    uint64_t v11 = v9;
    char v12 = 1;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : SQLDataType]);
    lazy protocol witness table accessor for type [String : SQLDataType] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : SQLDataType] and conformance <> [A : B], (void (*)(void))lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v6, v4);
}

uint64_t Schema.init(from:)@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedDecodingContainer<Schema.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys();
  dispatch thunk of Decoder.container<A>(keyedBy:)();
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
  }
  char v16 = 0;
  uint64_t v9 = KeyedDecodingContainer.decode(_:forKey:)();
  uint64_t v11 = v10;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : SQLDataType]);
  char v15 = 1;
  lazy protocol witness table accessor for type [String : SQLDataType] and conformance <> [A : B](&lazy protocol witness table cache variable for type [String : SQLDataType] and conformance <> [A : B], (void (*)(void))lazy protocol witness table accessor for type SQLDataType and conformance SQLDataType);
  swift_bridgeObjectRetain();
  KeyedDecodingContainer.decode<A>(_:forKey:)();
  (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
  uint64_t v12 = v14[1];
  *a2 = v9;
  a2[1] = v11;
  a2[2] = v12;
  swift_bridgeObjectRetain();
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)a1);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Schema(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a2[2];
  BOOL v4 = *a1 == *a2 && a1[1] == a2[1];
  if (!v4 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0) {
    return 0;
  }

  return specialized static Dictionary<>.== infix(_:_:)(v2, v3);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Schema@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return Schema.init(from:)(a1, a2);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Schema(void *a1)
{
  return Schema.encode(to:)(a1);
}

uint64_t FromClause.jsonEachExpression.getter@<X0>(uint64_t a1@<X8>)
{
  return outlined init with copy of PgQuery_Alias?(v1 + 8, a1, &demangling cache variable for type metadata for SQLExpression?);
}

uint64_t FromClause.init(fromClauseNodes:resources:)@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  v346 = a3;
  uint64_t v5 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1F4188790](v5 - 8);
  uint64_t v298 = (uint64_t)&v284 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ColumnRef = type metadata accessor for PgQuery_ColumnRef(0);
  uint64_t v7 = MEMORY[0x1F4188790](ColumnRef);
  v299 = (uint64_t *)((char *)&v284 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v7);
  v308 = (uint64_t *)((char *)&v284 - v9);
  uint64_t String = type metadata accessor for PgQuery_String(0);
  MEMORY[0x1F4188790](String);
  v321 = (uint64_t *)((char *)&v284 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v334 = type metadata accessor for PgQuery_FuncCall(0);
  uint64_t v11 = MEMORY[0x1F4188790](v334);
  uint64_t v302 = (uint64_t)&v284 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v311 = (uint64_t)&v284 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v318 = (uint64_t)&v284 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v326 = (uint64_t)&v284 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v331 = (uint64_t)&v284 - v19;
  uint64_t v20 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v21 = MEMORY[0x1F4188790](v20 - 8);
  uint64_t v307 = (uint64_t)&v284 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v303 = (uint64_t)&v284 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v305 = (uint64_t)&v284 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v315 = (uint64_t)&v284 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v312 = (uint64_t)&v284 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  uint64_t v322 = (uint64_t)&v284 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v328 = (uint64_t)&v284 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v329 = (uint64_t)&v284 - v36;
  MEMORY[0x1F4188790](v35);
  v337 = (char *)&v284 - v37;
  uint64_t List = type metadata accessor for PgQuery_List(0);
  uint64_t v38 = MEMORY[0x1F4188790](List);
  long long v40 = (char *)&v284 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v41 = MEMORY[0x1F4188790](v38);
  v313 = (uint64_t *)((char *)&v284 - v42);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  v319 = (uint64_t *)((char *)&v284 - v44);
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  v324 = (uint64_t *)((char *)&v284 - v46);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  v333 = (uint64_t *)((char *)&v284 - v48);
  MEMORY[0x1F4188790](v47);
  v336 = (uint64_t *)((char *)&v284 - v49);
  uint64_t RangeFunction = type metadata accessor for PgQuery_RangeFunction(0);
  uint64_t v341 = *(void *)(RangeFunction - 8);
  MEMORY[0x1F4188790](RangeFunction);
  uint64_t v339 = (uint64_t)&v284 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v51 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeFunction?);
  uint64_t v52 = MEMORY[0x1F4188790](v51 - 8);
  uint64_t v340 = (uint64_t)&v284 - ((v53 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v52);
  uint64_t v344 = (uint64_t)&v284 - v54;
  uint64_t v355 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  uint64_t v366 = *(void *)(v355 - 8);
  uint64_t v55 = MEMORY[0x1F4188790](v355);
  uint64_t v343 = (uint64_t)&v284 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v55);
  uint64_t v345 = (uint64_t)&v284 - v57;
  uint64_t RangeVar = (void *)type metadata accessor for PgQuery_RangeVar(0);
  uint64_t v356 = *(RangeVar - 1);
  MEMORY[0x1F4188790](RangeVar);
  uint64_t v59 = (char *)&v284 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v354 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v60 = MEMORY[0x1F4188790](v354);
  uint64_t v300 = (uint64_t)&v284 - ((v61 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  uint64_t v301 = (uint64_t)&v284 - v63;
  uint64_t v64 = MEMORY[0x1F4188790](v62);
  uint64_t v306 = (uint64_t)&v284 - v65;
  uint64_t v66 = MEMORY[0x1F4188790](v64);
  uint64_t v309 = (uint64_t)&v284 - v67;
  uint64_t v68 = MEMORY[0x1F4188790](v66);
  uint64_t v310 = (uint64_t)&v284 - v69;
  uint64_t v70 = MEMORY[0x1F4188790](v68);
  uint64_t v314 = (uint64_t)&v284 - v71;
  uint64_t v72 = MEMORY[0x1F4188790](v70);
  uint64_t v317 = (uint64_t)&v284 - v73;
  uint64_t v74 = MEMORY[0x1F4188790](v72);
  uint64_t v320 = (uint64_t)&v284 - v75;
  uint64_t v76 = MEMORY[0x1F4188790](v74);
  uint64_t v323 = (uint64_t)&v284 - v77;
  uint64_t v78 = MEMORY[0x1F4188790](v76);
  uint64_t v325 = (uint64_t)&v284 - v79;
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v327 = (uint64_t)&v284 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  uint64_t v330 = (uint64_t)&v284 - v83;
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  uint64_t v332 = (uint64_t)&v284 - v85;
  uint64_t v86 = MEMORY[0x1F4188790](v84);
  uint64_t v335 = (uint64_t)&v284 - v87;
  uint64_t v88 = MEMORY[0x1F4188790](v86);
  v347 = (char *)&v284 - v89;
  uint64_t v90 = MEMORY[0x1F4188790](v88);
  char v92 = (char *)&v284 - v91;
  uint64_t v93 = MEMORY[0x1F4188790](v90);
  Swift::String v95 = (char *)&v284 - v94;
  uint64_t v96 = MEMORY[0x1F4188790](v93);
  char v98 = (char *)&v284 - v97;
  MEMORY[0x1F4188790](v96);
  unint64_t v100 = (char *)&v284 - v99;
  uint64_t v101 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeVar?);
  uint64_t v102 = MEMORY[0x1F4188790](v101 - 8);
  uint64_t v349 = (uint64_t)&v284 - ((v103 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v102);
  unint64_t v105 = (char *)&v284 - v104;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v107 = *(void *)(Node - 8);
  uint64_t v108 = MEMORY[0x1F4188790](Node);
  uint64_t v109 = MEMORY[0x1F4188790](v108);
  uint64_t v110 = MEMORY[0x1F4188790](v109);
  uint64_t v111 = MEMORY[0x1F4188790](v110);
  uint64_t v112 = MEMORY[0x1F4188790](v111);
  uint64_t v118 = a1;
  unint64_t v119 = (char *)&v284 - v114;
  if (!*(void *)(v118 + 16))
  {
    swift_bridgeObjectRelease();
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v127 = 0xD00000000000002FLL;
    *(void *)(v127 + 8) = 0x800000018EBF7FF0;
    *(void *)(v127 + 16) = 0;
    *(void *)(v127 + 24) = 0;
    *(unsigned char *)(v127 + 32) = 1;
    swift_willThrow();
    long long v128 = type metadata accessor for PlanResources;
    uint64_t v129 = (uint64_t)a2;
    return outlined destroy of PgQuery_ParseResult(v129, v128);
  }
  unint64_t v295 = *(void *)(v118 + 16);
  uint64_t v292 = v113;
  v287 = v40;
  uint64_t v285 = v117;
  uint64_t v286 = v116;
  uint64_t v290 = v115;
  v297 = v59;
  v352 = a2;
  uint64_t v288 = v107;
  uint64_t v293 = v107;
  unint64_t v289 = (*(unsigned __int8 *)(v107 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v107 + 80);
  uint64_t v120 = v112;
  uint64_t v291 = v118 + v289;
  uint64_t v121 = v118;
  outlined init with copy of PgQuery_ScanResult(v118 + v289, (uint64_t)&v284 - v114, type metadata accessor for PgQuery_Node);
  uint64_t v122 = (uint64_t)v105;
  uint64_t v123 = *(void (**)(void))(v356 + 56);
  v353 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v122;
  v123();
  uint64_t v294 = v120;
  uint64_t v124 = *(int *)(v120 + 20);
  v351 = v119;
  outlined init with copy of PgQuery_Alias?(*(void *)&v119[v124]+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, (uint64_t)v100, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  v350 = v100;
  outlined init with copy of PgQuery_Alias?((uint64_t)v100, (uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v125 = v366 + 48;
  uint64_t v126 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v366 + 48);
  if (v126(v98, 1, v355) == 1)
  {
    swift_bridgeObjectRelease();
LABEL_9:
    uint64_t v136 = (uint64_t)v350;
    *(void *)&long long v360 = 0;
    *((void *)&v360 + 1) = 0xE000000000000000;
    _StringGuts.grow(_:)(49);
    swift_bridgeObjectRelease();
    *(void *)&long long v360 = 0xD00000000000002FLL;
    *((void *)&v360 + 1) = 0x800000018EBF7F60;
    outlined init with copy of PgQuery_Alias?(v136, (uint64_t)v92, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    v137._uint64_t countAndFlagsBits = String.init<A>(describing:)();
    String.append(_:)(v137);
    swift_bridgeObjectRelease();
    long long v138 = v360;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(_OWORD *)uint64_t v139 = v138;
    *(void *)(v139 + 16) = 0;
    *(void *)(v139 + 24) = 0;
    *(unsigned char *)(v139 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_ParseResult((uint64_t)v352, type metadata accessor for PlanResources);
    outlined destroy of AnyValue?(v136, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of AnyValue?((uint64_t)v353, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    outlined destroy of PgQuery_ParseResult((uint64_t)v351, type metadata accessor for PgQuery_Node);
    return outlined destroy of AnyValue?((uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  }
  uint64_t v296 = v121;
  outlined init with copy of PgQuery_Alias?((uint64_t)v98, (uint64_t)v95, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  if (swift_getEnumCaseMultiPayload() != 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult((uint64_t)v95, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_9;
  }
  uint64_t v366 = v125;
  uint64_t v130 = (uint64_t)v353;
  outlined destroy of AnyValue?((uint64_t)v353, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined init with take of PgQuery_ParseResult((uint64_t)v95, v130, type metadata accessor for PgQuery_RangeVar);
  uint64_t v131 = RangeVar;
  ((void (*)(uint64_t, void, uint64_t, void *))v123)(v130, 0, 1, RangeVar);
  uint64_t v132 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v130;
  outlined destroy of AnyValue?((uint64_t)v98, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v133 = v349;
  outlined init with copy of PgQuery_Alias?(v130, v349, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  if ((*(unsigned int (**)(uint64_t, uint64_t, void *))(v356 + 48))(v133, 1, v131) == 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of AnyValue?(v133, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v134 = 0xD00000000000001CLL;
    *(void *)(v134 + 8) = 0x800000018EBF7F90;
    *(void *)(v134 + 16) = 0;
    *(void *)(v134 + 24) = 0;
    *(unsigned char *)(v134 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_ParseResult((uint64_t)v352, type metadata accessor for PlanResources);
    outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    uint64_t v135 = v130;
LABEL_13:
    outlined destroy of AnyValue?(v135, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    long long v128 = type metadata accessor for PgQuery_Node;
    uint64_t v129 = (uint64_t)v351;
    return outlined destroy of PgQuery_ParseResult(v129, v128);
  }
  int64_t v141 = v297;
  outlined init with take of PgQuery_ParseResult(v133, (uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
  v142 = v352;
  uint64_t v358 = *v352;
  swift_bridgeObjectRetain();
  uint64_t v143 = v348;
  static Schema.lookup(rangeVar:catalog:)(v141, &v358, &v360);
  uint64_t v144 = v143;
  uint64_t v145 = v296;
  if (v143)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult((uint64_t)v142, type metadata accessor for PlanResources);
    swift_bridgeObjectRelease();
    uint64_t v146 = (uint64_t)v141;
LABEL_12:
    outlined destroy of PgQuery_ParseResult(v146, type metadata accessor for PgQuery_RangeVar);
    outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    uint64_t v135 = (uint64_t)v132;
    goto LABEL_13;
  }
  uint64_t RangeVar = v126;
  swift_bridgeObjectRelease();
  long long v147 = v360;
  uint64_t v148 = v361;
  uint64_t v354 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Schema>);
  uint64_t v149 = swift_allocObject();
  *(_OWORD *)(v149 + 16) = xmmword_18EB382D0;
  uint64_t v356 = v147;
  *(_OWORD *)(v149 + 32) = v147;
  *(void *)(v149 + 48) = v148;
  long long v364 = 0u;
  long long v365 = 0u;
  long long v362 = 0u;
  long long v363 = 0u;
  long long v360 = 0u;
  long long v361 = 0u;
  if (*(void *)(v145 + 16) < v295)
  {
    __break(1u);
    goto LABEL_77;
  }
  unint64_t v150 = v149;
  uint64_t v151 = (uint64_t)v347;
  if (v295 != 2)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult((uint64_t)v142, type metadata accessor for PlanResources);
    outlined destroy of PgQuery_ParseResult((uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
    outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of AnyValue?((uint64_t)v132, &demangling cache variable for type metadata for PgQuery_RangeVar?);
    uint64_t v153 = (uint64_t)v351;
LABEL_20:
    outlined destroy of PgQuery_ParseResult(v153, type metadata accessor for PgQuery_Node);
    goto LABEL_21;
  }
  long long v348 = xmmword_18EB382D0;
  uint64_t v152 = v292;
  outlined init with copy of PgQuery_ScanResult(v291 + *(void *)(v293 + 72), v292, type metadata accessor for PgQuery_Node);
  outlined init with copy of PgQuery_Alias?(*(void *)(v152 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v151, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  outlined destroy of PgQuery_ParseResult(v152, type metadata accessor for PgQuery_Node);
  if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v151, 1, v355) != 1)
  {
    uint64_t v292 = v148;
    uint64_t v349 = *((void *)&v147 + 1);
    unint64_t v295 = v150;
    uint64_t v155 = v151;
    uint64_t v156 = v345;
    outlined init with take of PgQuery_ParseResult(v155, v345, type metadata accessor for PgQuery_Node.OneOf_Node);
    uint64_t v157 = v341;
    uint64_t v158 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v341 + 56);
    uint64_t v159 = v344;
    uint64_t v160 = RangeFunction;
    v158(v344, 1, 1, RangeFunction);
    uint64_t v161 = v156;
    uint64_t v162 = v343;
    outlined init with copy of PgQuery_ScanResult(v161, v343, type metadata accessor for PgQuery_Node.OneOf_Node);
    if (swift_getEnumCaseMultiPayload() != 182)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(void *)uint64_t v165 = 0xD000000000000030;
      *(void *)(v165 + 8) = 0x800000018EBF7FB0;
      *(void *)(v165 + 16) = 0;
      *(void *)(v165 + 24) = 0;
      *(unsigned char *)(v165 + 32) = 1;
      swift_willThrow();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult((uint64_t)v142, type metadata accessor for PlanResources);
      outlined destroy of AnyValue?(v159, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
      outlined destroy of PgQuery_ParseResult(v345, type metadata accessor for PgQuery_Node.OneOf_Node);
      outlined destroy of AnyValue?((uint64_t)&v360, &demangling cache variable for type metadata for SQLExpression?);
      outlined destroy of PgQuery_ParseResult((uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
      outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      outlined destroy of AnyValue?((uint64_t)v353, &demangling cache variable for type metadata for PgQuery_RangeVar?);
      outlined destroy of PgQuery_ParseResult((uint64_t)v351, type metadata accessor for PgQuery_Node);
      uint64_t v129 = v162;
      long long v128 = type metadata accessor for PgQuery_Node.OneOf_Node;
      return outlined destroy of PgQuery_ParseResult(v129, v128);
    }
    outlined destroy of AnyValue?(v159, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
    outlined init with take of PgQuery_ParseResult(v162, v159, type metadata accessor for PgQuery_RangeFunction);
    v158(v159, 0, 1, v160);
    uint64_t v163 = v340;
    outlined init with copy of PgQuery_Alias?(v159, v340, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
    uint64_t v164 = v159;
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v157 + 48))(v163, 1, v160) == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of AnyValue?(v163, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
LABEL_62:
      uint64_t v132 = v353;
      goto LABEL_63;
    }
    uint64_t v166 = v339;
    outlined init with take of PgQuery_ParseResult(v163, v339, type metadata accessor for PgQuery_RangeFunction);
    uint64_t v167 = *(void *)(v166 + 8);
    if (*(void *)(v167 + 16) != 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v173 = v166;
LABEL_61:
      outlined destroy of PgQuery_ParseResult(v173, type metadata accessor for PgQuery_RangeFunction);
      swift_bridgeObjectRelease();
      goto LABEL_62;
    }
    v347 = 0;
    uint64_t v168 = v290;
    outlined init with copy of PgQuery_ScanResult(v167 + v289, v290, type metadata accessor for PgQuery_Node);
    uint64_t v144 = *(int *)(v294 + 20);
    uint64_t v169 = v335;
    outlined init with copy of PgQuery_Alias?(*(void *)(v168 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v335, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    int v170 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v169, 1, v355);
    uint64_t v132 = v353;
    if (v170 == 1)
    {
      outlined destroy of AnyValue?(v169, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      uint64_t v171 = (uint64_t)v337;
      uint64_t v172 = v336;
    }
    else
    {
      BOOL v174 = swift_getEnumCaseMultiPayload() == 225;
      uint64_t v171 = (uint64_t)v337;
      uint64_t v175 = v169;
      uint64_t v172 = v336;
      if (v174)
      {
        outlined init with take of PgQuery_ParseResult(v175, (uint64_t)v336, type metadata accessor for PgQuery_List);
        goto LABEL_34;
      }
      outlined destroy of PgQuery_ParseResult(v175, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    *uint64_t v172 = MEMORY[0x1E4FBC860];
    UnknownStorage.init()();
LABEL_34:
    uint64_t v176 = *v172;
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_ParseResult((uint64_t)v172, type metadata accessor for PgQuery_List);
    uint64_t v177 = *(void *)(v176 + 16);
    swift_bridgeObjectRelease();
    if (v177 != 2)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
      outlined destroy of PgQuery_ParseResult(v166, type metadata accessor for PgQuery_RangeFunction);
      swift_bridgeObjectRelease();
LABEL_38:
      uint64_t v164 = v344;
LABEL_63:
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(void *)uint64_t v194 = 0xD000000000000030;
      *(void *)(v194 + 8) = 0x800000018EBF7FB0;
      *(void *)(v194 + 16) = 0;
      *(void *)(v194 + 24) = 0;
      *(unsigned char *)(v194 + 32) = 1;
      swift_willThrow();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult((uint64_t)v142, type metadata accessor for PlanResources);
      outlined destroy of AnyValue?(v164, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
      outlined destroy of PgQuery_ParseResult(v345, type metadata accessor for PgQuery_Node.OneOf_Node);
      outlined destroy of AnyValue?((uint64_t)&v360, &demangling cache variable for type metadata for SQLExpression?);
      uint64_t v146 = (uint64_t)v297;
      goto LABEL_12;
    }
    uint64_t v178 = v332;
    outlined init with copy of PgQuery_Alias?(*(void *)(v290 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v332, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    int v179 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v178, 1, v355);
    uint64_t v164 = v344;
    if (v179 == 1)
    {
      outlined destroy of AnyValue?(v178, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      uint64_t v180 = v293;
      uint64_t v181 = v333;
    }
    else
    {
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      uint64_t v180 = v293;
      uint64_t v181 = v333;
      if (EnumCaseMultiPayload == 225)
      {
        outlined init with take of PgQuery_ParseResult(v178, (uint64_t)v333, type metadata accessor for PgQuery_List);
        goto LABEL_43;
      }
      outlined destroy of PgQuery_ParseResult(v178, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    *uint64_t v181 = MEMORY[0x1E4FBC860];
    UnknownStorage.init()();
LABEL_43:
    uint64_t v183 = *v181;
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_ParseResult((uint64_t)v181, type metadata accessor for PgQuery_List);
    if (*(void *)(v183 + 16))
    {
      outlined init with copy of PgQuery_ScanResult(v183 + v289, v171, type metadata accessor for PgQuery_Node);
      uint64_t v132 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v180 + 56);
      uint64_t v184 = v171;
      uint64_t v185 = 0;
    }
    else
    {
      uint64_t v132 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v180 + 56);
      uint64_t v184 = v171;
      uint64_t v185 = 1;
    }
    uint64_t v186 = v294;
    v132(v184, v185, 1, v294);
    swift_bridgeObjectRelease();
    uint64_t v187 = v180 + 48;
    uint64_t v126 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v180 + 48);
    uint64_t v293 = v187;
    if (v126((char *)v171, 1, v186) == 1)
    {
      outlined destroy of AnyValue?(v171, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_60:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
      uint64_t v173 = v339;
      goto LABEL_61;
    }
    uint64_t v188 = v330;
    outlined init with copy of PgQuery_Alias?(*(void *)(v171 + *(int *)(v186 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v330, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v188, 1, v355) == 1)
    {
      outlined destroy of AnyValue?(v188, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    else
    {
      if (swift_getEnumCaseMultiPayload() == 170)
      {
        uint64_t v189 = v331;
        outlined init with take of PgQuery_ParseResult(v188, v331, type metadata accessor for PgQuery_FuncCall);
        goto LABEL_56;
      }
      outlined destroy of PgQuery_ParseResult(v188, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    uint64_t v189 = v331;
    UnknownStorage.init()();
    uint64_t v190 = *(int *)(v334 + 20);
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)(v189 + v190) = static PgQuery_FuncCall._StorageClass.defaultInstance;
    swift_retain();
LABEL_56:
    outlined destroy of PgQuery_ParseResult(v171, type metadata accessor for PgQuery_Node);
    uint64_t v191 = *(void *)(*(void *)(v189 + *(int *)(v334 + 20)) + 16);
    swift_bridgeObjectRetain();
    outlined destroy of PgQuery_ParseResult(v189, type metadata accessor for PgQuery_FuncCall);
    uint64_t v192 = *(void *)(v191 + 16);
    swift_bridgeObjectRelease();
    BOOL v174 = v192 == 1;
    uint64_t v164 = v344;
    if (!v174) {
      goto LABEL_60;
    }
    uint64_t v193 = v327;
    outlined init with copy of PgQuery_Alias?(*(void *)(v290 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v327, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v193, 1, v355) == 1)
    {
      outlined destroy of AnyValue?(v193, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    else
    {
      if (swift_getEnumCaseMultiPayload() == 225)
      {
        uint64_t v195 = v324;
        outlined init with take of PgQuery_ParseResult(v327, (uint64_t)v324, type metadata accessor for PgQuery_List);
LABEL_68:
        uint64_t v196 = *v195;
        swift_bridgeObjectRetain();
        outlined destroy of PgQuery_ParseResult((uint64_t)v195, type metadata accessor for PgQuery_List);
        if (*(void *)(v196 + 16))
        {
          uint64_t v197 = v328;
          outlined init with copy of PgQuery_ScanResult(v196 + v289, v328, type metadata accessor for PgQuery_Node);
          uint64_t v198 = 0;
        }
        else
        {
          uint64_t v198 = 1;
          uint64_t v197 = v328;
        }
        uint64_t v199 = v294;
        v132(v197, v198, 1, v294);
        swift_bridgeObjectRelease();
        if (v126((char *)v197, 1, v199) == 1) {
          goto LABEL_86;
        }
        uint64_t v200 = v325;
        outlined init with copy of PgQuery_Alias?(*(void *)(v197 + *(int *)(v199 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v325, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v200, 1, v355) == 1)
        {
          outlined destroy of AnyValue?(v325, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_78:
          UnknownStorage.init()();
          uint64_t v201 = *(int *)(v334 + 20);
          if (one-time initialization token for defaultInstance != -1) {
            swift_once();
          }
          *(void *)(v326 + v201) = static PgQuery_FuncCall._StorageClass.defaultInstance;
          swift_retain();
LABEL_81:
          outlined destroy of PgQuery_ParseResult(v328, type metadata accessor for PgQuery_Node);
          uint64_t v202 = v326;
          uint64_t v203 = *(void *)(*(void *)(v326 + *(int *)(v334 + 20)) + 16);
          swift_bridgeObjectRetain();
          outlined destroy of PgQuery_ParseResult(v202, type metadata accessor for PgQuery_FuncCall);
          if (*(void *)(v203 + 16))
          {
            outlined init with copy of PgQuery_ScanResult(v203 + v289, v329, type metadata accessor for PgQuery_Node);
            uint64_t v204 = 0;
          }
          else
          {
            uint64_t v204 = 1;
          }
          uint64_t v205 = v329;
          uint64_t v206 = v294;
          v132(v329, v204, 1, v294);
          swift_bridgeObjectRelease();
          if (v126((char *)v205, 1, v206) == 1)
          {
            uint64_t v197 = v329;
LABEL_86:
            uint64_t v207 = v197;
LABEL_87:
            outlined destroy of AnyValue?(v207, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_88:
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
            outlined destroy of PgQuery_ParseResult(v339, type metadata accessor for PgQuery_RangeFunction);
            swift_bridgeObjectRelease();
LABEL_89:
            v142 = v352;
            uint64_t v132 = v353;
            goto LABEL_38;
          }
          uint64_t v208 = v323;
          outlined init with copy of PgQuery_Alias?(*(void *)(v329 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v323, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v208, 1, v355) == 1)
          {
            outlined destroy of AnyValue?(v323, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          }
          else
          {
            if (swift_getEnumCaseMultiPayload() == 222)
            {
              outlined init with take of PgQuery_ParseResult(v323, (uint64_t)v321, type metadata accessor for PgQuery_String);
LABEL_96:
              outlined destroy of PgQuery_ParseResult(v329, type metadata accessor for PgQuery_Node);
              uint64_t v210 = v321;
              uint64_t v212 = *v321;
              uint64_t v211 = v321[1];
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v210, type metadata accessor for PgQuery_String);
              if (v212 == 0x6361655F6E6F736ALL && v211 == 0xE900000000000068)
              {
                swift_bridgeObjectRelease();
              }
              else
              {
                char v213 = _stringCompareWithSmolCheck(_:_:expecting:)();
                swift_bridgeObjectRelease();
                if ((v213 & 1) == 0) {
                  goto LABEL_88;
                }
              }
              uint64_t v214 = v320;
              outlined init with copy of PgQuery_Alias?(*(void *)(v290 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v320, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v214, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v320, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_ParseResult(v320, (uint64_t)v319, type metadata accessor for PgQuery_List);
                  goto LABEL_106;
                }
                outlined destroy of PgQuery_ParseResult(v320, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              void *v319 = MEMORY[0x1E4FBC860];
              UnknownStorage.init()();
LABEL_106:
              uint64_t v215 = v319;
              uint64_t v216 = *v319;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v215, type metadata accessor for PgQuery_List);
              if (*(void *)(v216 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v216 + v289, v322, type metadata accessor for PgQuery_Node);
                uint64_t v217 = 0;
              }
              else
              {
                uint64_t v217 = 1;
              }
              uint64_t v218 = v322;
              uint64_t v219 = v294;
              v132(v322, v217, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v218, 1, v219) == 1)
              {
                uint64_t v220 = (uint64_t *)&v353;
LABEL_144:
                uint64_t v207 = *(v220 - 32);
                goto LABEL_87;
              }
              uint64_t v221 = v317;
              outlined init with copy of PgQuery_Alias?(*(void *)(v322 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v317, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v221, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v317, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_ParseResult(v317, v318, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_119;
                }
                outlined destroy of PgQuery_ParseResult(v317, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              uint64_t v222 = *(int *)(v334 + 20);
              if (one-time initialization token for defaultInstance != -1) {
                swift_once();
              }
              *(void *)(v318 + v222) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_119:
              outlined destroy of PgQuery_ParseResult(v322, type metadata accessor for PgQuery_Node);
              uint64_t v223 = v318;
              uint64_t v224 = *(void *)(*(void *)(v318 + *(int *)(v334 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult(v223, type metadata accessor for PgQuery_FuncCall);
              uint64_t v225 = *(void *)(v224 + 16);
              swift_bridgeObjectRelease();
              if (v225 != 1) {
                goto LABEL_88;
              }
              uint64_t v226 = v314;
              outlined init with copy of PgQuery_Alias?(*(void *)(v290 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v314, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v226, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v314, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_ParseResult(v314, (uint64_t)v313, type metadata accessor for PgQuery_List);
                  goto LABEL_126;
                }
                outlined destroy of PgQuery_ParseResult(v314, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              void *v313 = MEMORY[0x1E4FBC860];
              UnknownStorage.init()();
LABEL_126:
              uint64_t v227 = v313;
              uint64_t v228 = *v313;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v227, type metadata accessor for PgQuery_List);
              if (*(void *)(v228 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v228 + v289, v315, type metadata accessor for PgQuery_Node);
                uint64_t v229 = 0;
              }
              else
              {
                uint64_t v229 = 1;
              }
              uint64_t v230 = v315;
              uint64_t v231 = v294;
              v132(v315, v229, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v230, 1, v231) == 1) {
                goto LABEL_143;
              }
              uint64_t v232 = v310;
              outlined init with copy of PgQuery_Alias?(*(void *)(v315 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v310, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v232, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v310, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_ParseResult(v310, v311, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_138;
                }
                outlined destroy of PgQuery_ParseResult(v310, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              uint64_t v233 = *(int *)(v334 + 20);
              if (one-time initialization token for defaultInstance != -1) {
                swift_once();
              }
              *(void *)(v311 + v233) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_138:
              outlined destroy of PgQuery_ParseResult(v315, type metadata accessor for PgQuery_Node);
              uint64_t v234 = v311;
              uint64_t v235 = *(void *)(*(void *)(v311 + *(int *)(v334 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult(v234, type metadata accessor for PgQuery_FuncCall);
              if (*(void *)(v235 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v235 + v289, v312, type metadata accessor for PgQuery_Node);
                uint64_t v236 = 0;
              }
              else
              {
                uint64_t v236 = 1;
              }
              uint64_t v237 = v312;
              uint64_t v238 = v294;
              v132(v312, v236, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v237, 1, v238) == 1)
              {
                uint64_t v315 = v312;
LABEL_143:
                uint64_t v220 = (uint64_t *)&v347;
                goto LABEL_144;
              }
              uint64_t v239 = v309;
              outlined init with copy of PgQuery_Alias?(*(void *)(v312 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v309, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v239, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v309, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 167)
                {
                  outlined init with take of PgQuery_ParseResult(v309, (uint64_t)v308, type metadata accessor for PgQuery_ColumnRef);
                  goto LABEL_151;
                }
                outlined destroy of PgQuery_ParseResult(v309, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              uint64_t v240 = v308;
              void *v308 = MEMORY[0x1E4FBC860];
              *((_DWORD *)v240 + 2) = 0;
              UnknownStorage.init()();
LABEL_151:
              outlined destroy of PgQuery_ParseResult(v312, type metadata accessor for PgQuery_Node);
              uint64_t v241 = v308;
              uint64_t v242 = *v308;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v241, type metadata accessor for PgQuery_ColumnRef);
              uint64_t v243 = *(void *)(v242 + 16);
              swift_bridgeObjectRelease();
              if (v243 != 1) {
                goto LABEL_88;
              }
              uint64_t v244 = v306;
              outlined init with copy of PgQuery_Alias?(*(void *)(v290 + v144)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v306, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v244, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v306, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 225)
                {
                  outlined init with take of PgQuery_ParseResult(v306, (uint64_t)v287, type metadata accessor for PgQuery_List);
                  goto LABEL_158;
                }
                outlined destroy of PgQuery_ParseResult(v306, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              void *v287 = MEMORY[0x1E4FBC860];
              UnknownStorage.init()();
LABEL_158:
              uint64_t v245 = v287;
              uint64_t v246 = *v287;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v245, type metadata accessor for PgQuery_List);
              if (*(void *)(v246 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v246 + v289, v307, type metadata accessor for PgQuery_Node);
                uint64_t v247 = 0;
              }
              else
              {
                uint64_t v247 = 1;
              }
              uint64_t v248 = v307;
              uint64_t v249 = v294;
              v132(v307, v247, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v248, 1, v249) == 1) {
                goto LABEL_175;
              }
              uint64_t v250 = v301;
              outlined init with copy of PgQuery_Alias?(*(void *)(v307 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v301, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v250, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v301, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 170)
                {
                  outlined init with take of PgQuery_ParseResult(v301, v302, type metadata accessor for PgQuery_FuncCall);
                  goto LABEL_170;
                }
                outlined destroy of PgQuery_ParseResult(v301, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              UnknownStorage.init()();
              uint64_t v251 = *(int *)(v334 + 20);
              if (one-time initialization token for defaultInstance != -1) {
                swift_once();
              }
              *(void *)(v302 + v251) = static PgQuery_FuncCall._StorageClass.defaultInstance;
              swift_retain();
LABEL_170:
              outlined destroy of PgQuery_ParseResult(v307, type metadata accessor for PgQuery_Node);
              uint64_t v252 = v302;
              uint64_t v253 = *(void *)(*(void *)(v302 + *(int *)(v334 + 20)) + 24);
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult(v252, type metadata accessor for PgQuery_FuncCall);
              if (*(void *)(v253 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v253 + v289, v303, type metadata accessor for PgQuery_Node);
                uint64_t v254 = 0;
              }
              else
              {
                uint64_t v254 = 1;
              }
              uint64_t v255 = v303;
              uint64_t v256 = v294;
              v132(v303, v254, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v255, 1, v256) == 1)
              {
                uint64_t v307 = v303;
LABEL_175:
                outlined destroy of AnyValue?(v307, &demangling cache variable for type metadata for PgQuery_Node?);
                v132(v305, 1, 1, v294);
LABEL_176:
                swift_bridgeObjectRelease();
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_ParseResult(v339, type metadata accessor for PgQuery_RangeFunction);
                swift_bridgeObjectRelease();
                outlined destroy of AnyValue?(v305, &demangling cache variable for type metadata for PgQuery_Node?);
                goto LABEL_89;
              }
              uint64_t v257 = v300;
              outlined init with copy of PgQuery_Alias?(*(void *)(v303 + *(int *)(v294 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v300, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))RangeVar)(v257, 1, v355) == 1)
              {
                outlined destroy of AnyValue?(v300, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
              }
              else
              {
                if (swift_getEnumCaseMultiPayload() == 167)
                {
                  outlined init with take of PgQuery_ParseResult(v300, (uint64_t)v299, type metadata accessor for PgQuery_ColumnRef);
                  goto LABEL_183;
                }
                outlined destroy of PgQuery_ParseResult(v300, type metadata accessor for PgQuery_Node.OneOf_Node);
              }
              uint64_t v258 = v299;
              void *v299 = MEMORY[0x1E4FBC860];
              *((_DWORD *)v258 + 2) = 0;
              UnknownStorage.init()();
LABEL_183:
              outlined destroy of PgQuery_ParseResult(v303, type metadata accessor for PgQuery_Node);
              uint64_t v259 = v299;
              uint64_t v260 = *v299;
              swift_bridgeObjectRetain();
              outlined destroy of PgQuery_ParseResult((uint64_t)v259, type metadata accessor for PgQuery_ColumnRef);
              if (*(void *)(v260 + 16))
              {
                outlined init with copy of PgQuery_ScanResult(v260 + v289, v305, type metadata accessor for PgQuery_Node);
                uint64_t v261 = 0;
              }
              else
              {
                uint64_t v261 = 1;
              }
              uint64_t v262 = v305;
              uint64_t v263 = v294;
              v132(v305, v261, 1, v294);
              swift_bridgeObjectRelease();
              if (v126((char *)v262, 1, v263) == 1) {
                goto LABEL_176;
              }
              uint64_t v264 = v286;
              outlined init with take of PgQuery_ParseResult(v305, v286, type metadata accessor for PgQuery_Node);
              uint64_t v265 = v285;
              outlined init with copy of PgQuery_ScanResult(v264, v285, type metadata accessor for PgQuery_Node);
              uint64_t v266 = swift_allocObject();
              *(_OWORD *)(v266 + 16) = v348;
              uint64_t v267 = v349;
              *(void *)(v266 + 32) = v356;
              *(void *)(v266 + 40) = v267;
              *(void *)(v266 + 48) = v292;
              uint64_t v268 = type metadata accessor for PlanResources(0);
              uint64_t v269 = v298;
              outlined init with copy of PgQuery_ScanResult((uint64_t)v352 + *(int *)(v268 + 20), v298, type metadata accessor for SQLTokenInformation);
              uint64_t v270 = v347;
              SQLExpression.init(expressionNode:schemas:tokenInformation:)(v265, v266, v269, (uint64_t)&v358);
              if (v270)
              {
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_ParseResult((uint64_t)v352, type metadata accessor for PlanResources);
                outlined destroy of PgQuery_ParseResult(v286, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
                outlined destroy of PgQuery_ParseResult(v339, type metadata accessor for PgQuery_RangeFunction);
                outlined destroy of AnyValue?(v344, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
                outlined destroy of PgQuery_ParseResult(v345, type metadata accessor for PgQuery_Node.OneOf_Node);
                outlined destroy of AnyValue?((uint64_t)&v360, &demangling cache variable for type metadata for SQLExpression?);
                swift_bridgeObjectRelease();
                outlined destroy of PgQuery_ParseResult((uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
                outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
                outlined destroy of AnyValue?((uint64_t)v353, &demangling cache variable for type metadata for PgQuery_RangeVar?);
                uint64_t v129 = (uint64_t)v351;
                long long v128 = type metadata accessor for PgQuery_Node;
                return outlined destroy of PgQuery_ParseResult(v129, v128);
              }
              outlined destroy of AnyValue?((uint64_t)&v360, &demangling cache variable for type metadata for SQLExpression?);
              outlined init with copy of SQLExpression((uint64_t)&v358, (uint64_t)&v360);
              char v271 = v359;
              __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, SQLDataType)>);
              uint64_t inited = swift_initStackObject();
              *(_OWORD *)(inited + 16) = v348;
              *(void *)(inited + 32) = 0x65756C6176;
              *(void *)(inited + 40) = 0xE500000000000000;
              *(unsigned char *)(inited + 48) = v271;
              __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
              Swift::String v273 = (void *)static _DictionaryStorage.allocate(capacity:)();
              unint64_t v274 = *(void *)(inited + 32);
              uint64_t v275 = *(void *)(inited + 40);
              char v276 = *(unsigned char *)(inited + 48);
              swift_retain();
              swift_bridgeObjectRetain();
              unint64_t v277 = specialized __RawDictionaryStorage.find<A>(_:)(v274, v275);
              if (v279)
              {
                __break(1u);
              }
              else
              {
                v273[(v277 >> 6) + 8] |= 1 << v277;
                v280 = (unint64_t *)(v273[6] + 16 * v277);
                unint64_t *v280 = v274;
                v280[1] = v275;
                *(unsigned char *)(v273[7] + v277) = v276;
                uint64_t v281 = v273[2];
                BOOL v282 = __OFADD__(v281, 1);
                unint64_t v278 = v281 + 1;
                if (!v282)
                {
                  v273[2] = v278;
                  swift_release();
                  swift_bridgeObjectRelease();
                  unint64_t v274 = *(void *)(v295 + 16);
                  unint64_t v278 = *(void *)(v295 + 24);
                  uint64_t inited = v274 + 1;
                  if (v274 < v278 >> 1)
                  {
LABEL_192:
                    unint64_t v150 = v295;
                    *(void *)(v295 + 16) = inited;
                    v283 = (void *)(v150 + 24 * v274);
                    v283[4] = 0x6361655F6E6F736ALL;
                    v283[5] = 0xE900000000000068;
                    v283[6] = v273;
                    swift_bridgeObjectRelease();
                    outlined destroy of PgQuery_ParseResult((uint64_t)v352, type metadata accessor for PlanResources);
                    outlined destroy of SQLExpression((uint64_t)&v358);
                    outlined destroy of PgQuery_ParseResult(v286, type metadata accessor for PgQuery_Node);
                    outlined destroy of PgQuery_ParseResult(v290, type metadata accessor for PgQuery_Node);
                    outlined destroy of PgQuery_ParseResult(v339, type metadata accessor for PgQuery_RangeFunction);
                    outlined destroy of AnyValue?(v344, &demangling cache variable for type metadata for PgQuery_RangeFunction?);
                    outlined destroy of PgQuery_ParseResult(v345, type metadata accessor for PgQuery_Node.OneOf_Node);
                    outlined destroy of PgQuery_ParseResult((uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
                    outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
                    outlined destroy of AnyValue?((uint64_t)v353, &demangling cache variable for type metadata for PgQuery_RangeVar?);
                    uint64_t v153 = (uint64_t)v351;
                    goto LABEL_20;
                  }
LABEL_195:
                  unint64_t v295 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v278 > 1, inited, 1, v295);
                  goto LABEL_192;
                }
              }
              __break(1u);
              goto LABEL_195;
            }
            outlined destroy of PgQuery_ParseResult(v323, type metadata accessor for PgQuery_Node.OneOf_Node);
          }
          uint64_t v209 = v321;
          void *v321 = 0;
          v209[1] = 0xE000000000000000;
          UnknownStorage.init()();
          goto LABEL_96;
        }
        if (swift_getEnumCaseMultiPayload() == 170)
        {
          outlined init with take of PgQuery_ParseResult(v325, v326, type metadata accessor for PgQuery_FuncCall);
          goto LABEL_81;
        }
LABEL_77:
        outlined destroy of PgQuery_ParseResult(v325, type metadata accessor for PgQuery_Node.OneOf_Node);
        goto LABEL_78;
      }
      outlined destroy of PgQuery_ParseResult(v327, type metadata accessor for PgQuery_Node.OneOf_Node);
    }
    uint64_t v195 = v324;
    uint64_t *v324 = MEMORY[0x1E4FBC860];
    UnknownStorage.init()();
    goto LABEL_68;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_ParseResult((uint64_t)v142, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_ParseResult((uint64_t)v297, type metadata accessor for PgQuery_RangeVar);
  outlined destroy of AnyValue?((uint64_t)v350, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  outlined destroy of AnyValue?((uint64_t)v132, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  outlined destroy of PgQuery_ParseResult((uint64_t)v351, type metadata accessor for PgQuery_Node);
  outlined destroy of AnyValue?(v151, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_21:
  uint64_t v154 = v346;
  unint64_t *v346 = v150;
  return outlined init with take of SQLExpression?((uint64_t)&v360, (uint64_t)(v154 + 1), &demangling cache variable for type metadata for SQLExpression?);
}

uint64_t specialized Collection.dropFirst(_:)(uint64_t result, uint64_t a2)
{
  if (result < 0)
  {
    __break(1u);
  }
  else
  {
    unint64_t v3 = *(void *)(a2 + 16);
    if ((uint64_t)v3 >= result) {
      unint64_t v4 = result;
    }
    else {
      unint64_t v4 = *(void *)(a2 + 16);
    }
    if (result) {
      unint64_t v5 = v4;
    }
    else {
      unint64_t v5 = 0;
    }
    if (v3 >= v5)
    {
      type metadata accessor for PgQuery_ScanToken(0);
      return a2;
    }
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance FromClause.CodingKeys()
{
  if (*v0) {
    return 0xD000000000000012;
  }
  else {
    return 0x73616D65686373;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance FromClause.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized FromClause.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance FromClause.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance FromClause.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t FromClause.encode(to:)(void *a1)
{
  unint64_t v3 = v1;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<FromClause.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = &v10[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  uint64_t v11 = *v3;
  v10[7] = 0;
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [Schema]);
  lazy protocol witness table accessor for type [Schema] and conformance <A> [A](&lazy protocol witness table cache variable for type [Schema] and conformance <A> [A], &demangling cache variable for type metadata for [Schema], (void (*)(void))lazy protocol witness table accessor for type Schema and conformance Schema);
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    v10[6] = 1;
    lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance FromClause(void *a1)
{
  return FromClause.encode(to:)(a1);
}

uint64_t ResultColumn.documentation.getter()
{
  uint64_t v1 = *(void *)(v0 + 112);
  swift_bridgeObjectRetain();
  return v1;
}

__n128 ResultColumn.init(expression:alias:documentation:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  long long v6 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a6 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a6 + 48) = v6;
  long long v7 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a6 + 64) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a6 + 80) = v7;
  __n128 result = *(__n128 *)a1;
  long long v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a6 = *(_OWORD *)a1;
  *(_OWORD *)(a6 + 16) = v9;
  *(void *)(a6 + 96) = a2;
  *(void *)(a6 + 104) = a3;
  *(void *)(a6 + 112) = a4;
  *(void *)(a6 + 120) = a5;
  return result;
}

uint64_t ResultColumn.init(node:schemas:tokenInformation:)@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v168 = a3;
  uint64_t v153 = a4;
  uint64_t v164 = type metadata accessor for CharacterSet();
  uint64_t v146 = *(void *)(v164 - 8);
  MEMORY[0x1F4188790](v164);
  uint64_t v163 = (char *)v141 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  uint64_t v154 = *(void *)(ScanToken - 8);
  uint64_t v8 = MEMORY[0x1F4188790](ScanToken - 8);
  uint64_t v10 = (char *)v141 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v156 = (char *)v141 - v11;
  uint64_t v148 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1F4188790](v148);
  uint64_t v152 = (uint64_t)v141 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1F4188790](v13 - 8);
  uint64_t v151 = (void *)((char *)v141 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v149 = *(void *)(Node - 8);
  uint64_t v16 = MEMORY[0x1F4188790](Node);
  uint64_t v18 = (char *)v141 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  unint64_t v150 = (void *)((char *)v141 - v19);
  uint64_t v20 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for Locale?);
  MEMORY[0x1F4188790](v20 - 8);
  long long v147 = (char *)v141 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v167 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken));
  uint64_t v160 = *(unsigned int (***)(void, void, void))(v167 - 8);
  MEMORY[0x1F4188790](v167);
  uint64_t v161 = (char *)v141 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken)?);
  uint64_t v24 = MEMORY[0x1F4188790](v23 - 8);
  uint64_t v166 = (char *)v141 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v24);
  uint64_t v27 = (void *)((char *)v141 - v26);
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1F4188790](v28 - 8);
  uint64_t v30 = (uint64_t)v141 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ResTarget = type metadata accessor for PgQuery_ResTarget(0);
  MEMORY[0x1F4188790](ResTarget);
  uint64_t v157 = (char *)v141 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v162 = Node;
  uint64_t v33 = *(int *)(Node + 20);
  uint64_t v165 = a1;
  outlined init with copy of PgQuery_Alias?(*(void *)((char *)a1 + v33)+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v34 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v34 - 8) + 48))(v30, 1, v34) == 1)
  {
    swift_bridgeObjectRelease();
    outlined destroy of AnyValue?(v30, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    goto LABEL_13;
  }
  uint64_t v145 = a2;
  if (swift_getEnumCaseMultiPayload() != 175) {
    goto LABEL_12;
  }
  uint64_t v18 = v157;
  outlined init with take of PgQuery_ParseResult(v30, (uint64_t)v157, type metadata accessor for PgQuery_ResTarget);
  uint64_t v35 = *(void *)&v18[*(int *)(ResTarget + 20)];
  unint64_t v36 = *(void *)(v35 + 24);
  uint64_t v37 = *(void *)(v35 + 16) & 0xFFFFFFFFFFFFLL;
  if ((v36 & 0x2000000000000000) != 0) {
    uint64_t v37 = HIBYTE(v36) & 0xF;
  }
  uint64_t v38 = v168;
  uint64_t v142 = *(int *)(ResTarget + 20);
  if (!v37)
  {
    uint64_t v39 = v153;
    *(void *)(v153 + 96) = 0;
    *(void *)(v39 + 104) = 0;
    goto LABEL_31;
  }
  uint64_t v39 = *(void *)(v168 + 8);
  long long v40 = *(char **)(v39 + 16);
  if (!v40) {
    goto LABEL_85;
  }
  uint64_t v18 = 0;
  int v41 = *(_DWORD *)(v35
                  + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
  uint64_t Node = *(void *)(v154 + 72);
  unint64_t v42 = (*(unsigned __int8 *)(v154 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v154 + 80);
  while (*(_DWORD *)(v39 + v42) != v41)
  {
    v42 += Node;
    if (v40 == ++v18)
    {
      __break(1u);
LABEL_12:
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult(v30, type metadata accessor for PgQuery_Node.OneOf_Node);
LABEL_13:
      uint64_t v43 = v168;
      v171._uint64_t countAndFlagsBits = 0;
      v171._object = (void *)0xE000000000000000;
      _StringGuts.grow(_:)(36);
      swift_bridgeObjectRelease();
      v171._uint64_t countAndFlagsBits = 0xD000000000000022;
      v171._object = (void *)0x800000018EBF7F30;
      uint64_t v44 = (uint64_t)v165;
      outlined init with copy of PgQuery_ScanResult((uint64_t)v165, (uint64_t)v18, type metadata accessor for PgQuery_Node);
      v45._uint64_t countAndFlagsBits = String.init<A>(describing:)();
      String.append(_:)(v45);
      swift_bridgeObjectRelease();
      uint64_t countAndFlagsBits = v171._countAndFlagsBits;
      object = v171._object;
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(void *)uint64_t v48 = countAndFlagsBits;
      *(void *)(v48 + 8) = object;
      *(void *)(v48 + 16) = 0;
      *(void *)(v48 + 24) = 0;
      *(unsigned char *)(v48 + 32) = 1;
      swift_willThrow();
      outlined destroy of PgQuery_ParseResult(v44, type metadata accessor for PgQuery_Node);
      uint64_t v49 = type metadata accessor for SQLTokenInformation;
      uint64_t v50 = v43;
      return outlined destroy of PgQuery_ParseResult(v50, v49);
    }
  }
  v141[0] = (*(unsigned __int8 *)(v154 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v154 + 80);
  v141[1] = specialized Collection.dropFirst(_:)((uint64_t)v18, v39);
  uint64_t v143 = v52;
  uint64_t v38 = v53;
  uint64_t v30 = v54 >> 1;
  uint64_t v159 = (void (**)(char *, uint64_t, uint64_t, unint64_t))(v160 + 7);
  v160 += 6;
  swift_bridgeObjectRetain();
  uint64_t v158 = 0;
  uint64_t v144 = v38;
  uint64_t v155 = v30;
  while (1)
  {
    if (v38 == v30)
    {
      a1 = v166;
      uint64_t v39 = v167;
      (*v159)(v166, 1, 1, v167);
      uint64_t v38 = v30;
      goto LABEL_22;
    }
    a1 = v166;
    uint64_t v39 = v167;
    if (v38 < v144 || v38 >= v30)
    {
      __break(1u);
LABEL_84:
      __break(1u);
LABEL_85:
      __break(1u);
LABEL_86:
      __break(1u);
      goto LABEL_87;
    }
    uint64_t v30 = (uint64_t)&v161[*(int *)(v167 + 48)];
    outlined init with copy of PgQuery_ScanResult(v143 + v38 * Node, v30, type metadata accessor for PgQuery_ScanToken);
    uint64_t v34 = v158 + 1;
    if (__OFADD__(v158, 1)) {
      goto LABEL_84;
    }
    ++v38;
    uint64_t v55 = (uint64_t)a1 + *(int *)(v39 + 48);
    *a1 = v158;
    outlined init with take of PgQuery_ParseResult(v30, v55, type metadata accessor for PgQuery_ScanToken);
    (*v159)((char *)a1, 0, 1, v39);
    uint64_t v158 = v34;
LABEL_22:
    outlined init with take of SQLExpression?((uint64_t)a1, (uint64_t)v27, (uint64_t *)&demangling cache variable for type metadata for (offset: Int, element: PgQuery_ScanToken)?);
    if ((*v160)(v27, 1, v39) == 1)
    {
      swift_unknownObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v66 = (uint64_t)v157;
      uint64_t v67 = *(void *)&v157[v142];
      uint64_t v69 = *(void *)(v67 + 16);
      uint64_t v68 = *(void *)(v67 + 24);
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(void *)uint64_t v70 = v69;
      *(void *)(v70 + 8) = v68;
      *(void *)(v70 + 16) = 0;
      *(void *)(v70 + 24) = 0;
      *(unsigned char *)(v70 + 32) = 8;
      swift_bridgeObjectRetain();
      swift_willThrow();
      outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
      outlined destroy of PgQuery_ParseResult(v168, type metadata accessor for SQLTokenInformation);
      uint64_t v49 = type metadata accessor for PgQuery_ResTarget;
      uint64_t v50 = v66;
      return outlined destroy of PgQuery_ParseResult(v50, v49);
    }
    a1 = (void *)*v27;
    uint64_t v56 = (Swift::Int32 *)((char *)v27 + *(int *)(v39 + 48));
    Swift::Int32 v57 = *v56;
    outlined destroy of PgQuery_ParseResult((uint64_t)v56, type metadata accessor for PgQuery_ScanToken);
    Swift::String v58 = SQLTokenInformation.tokenName(location:)(v57);
    uint64_t v169 = v59;
    if (v59)
    {
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
      swift_unknownObjectRelease();
      outlined destroy of PgQuery_ParseResult(v168, type metadata accessor for SQLTokenInformation);
      uint64_t v71 = (uint64_t)v157;
      return outlined destroy of PgQuery_ParseResult(v71, type metadata accessor for PgQuery_ResTarget);
    }
    uint64_t v30 = (uint64_t)v58._object;
    Swift::String v60 = String.lowercased()();
    uint64_t v39 = v60._countAndFlagsBits;
    uint64_t v34 = (uint64_t)v60._object;
    swift_bridgeObjectRelease();
    Swift::String v61 = String.lowercased()();
    if (v60._countAndFlagsBits == v61._countAndFlagsBits && v60._object == v61._object) {
      break;
    }
    uint64_t v39 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v30 = v155;
    if (v39) {
      goto LABEL_45;
    }
  }
  swift_bridgeObjectRelease_n();
LABEL_45:
  uint64_t v82 = (char *)a1 + (void)v18;
  if (__OFADD__(v18, a1)) {
    goto LABEL_86;
  }
  BOOL v83 = __OFADD__(v82, 1);
  uint64_t v84 = v82 + 1;
  uint64_t v38 = v168;
  uint64_t v18 = v157;
  uint64_t v39 = v145;
  if (v83)
  {
LABEL_87:
    __break(1u);
LABEL_88:
    swift_once();
LABEL_33:
    *(void *)((char *)v27 + v30) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)a1, &demangling cache variable for type metadata for PgQuery_Node?);
    goto LABEL_35;
  }
  uint64_t v85 = *(void *)(v168 + 8);
  if ((uint64_t)v84 >= *(void *)(v85 + 16))
  {
    swift_bridgeObjectRelease();
    uint64_t v87 = *(void *)&v18[v142];
    uint64_t v89 = *(void *)(v87 + 16);
    uint64_t v88 = *(void *)(v87 + 24);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v90 = v89;
    *(void *)(v90 + 8) = v88;
    *(void *)(v90 + 16) = 0;
    *(void *)(v90 + 24) = 0;
    *(unsigned char *)(v90 + 32) = 8;
    swift_bridgeObjectRetain();
    swift_willThrow();
    outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
    swift_unknownObjectRelease();
LABEL_53:
    outlined destroy of PgQuery_ParseResult(v38, type metadata accessor for SQLTokenInformation);
    uint64_t v49 = type metadata accessor for PgQuery_ResTarget;
    uint64_t v50 = (uint64_t)v18;
    return outlined destroy of PgQuery_ParseResult(v50, v49);
  }
  if (((unint64_t)v84 & 0x8000000000000000) != 0) {
    goto LABEL_90;
  }
  SQLTokenInformation.tokenName(location:)(*(_DWORD *)(v85 + v141[0] + (void)v84 * Node));
  uint64_t v169 = v86;
  if (v86)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
    swift_unknownObjectRelease();
    outlined destroy of PgQuery_ParseResult(v38, type metadata accessor for SQLTokenInformation);
    uint64_t v71 = (uint64_t)v18;
    return outlined destroy of PgQuery_ParseResult(v71, type metadata accessor for PgQuery_ResTarget);
  }
  swift_unknownObjectRelease();
  Swift::String v171 = String.lowercased()();
  Swift::String v172 = String.lowercased()();
  uint64_t v91 = type metadata accessor for Locale();
  uint64_t v92 = (uint64_t)v147;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v91 - 8) + 56))(v147, 1, 1, v91);
  uint64_t v139 = (Swift::String *)lazy protocol witness table accessor for type String and conformance String();
  unint64_t v140 = v139;
  StringProtocol.range<A>(of:options:range:locale:)();
  char v94 = v93;
  outlined destroy of AnyValue?(v92, (uint64_t *)&demangling cache variable for type metadata for Locale?);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (v94)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v134 = *(void *)&v18[v142];
    uint64_t v136 = *(void *)(v134 + 16);
    uint64_t v135 = *(void *)(v134 + 24);
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v137 = v136;
    *(void *)(v137 + 8) = v135;
    *(void *)(v137 + 16) = 0;
    *(void *)(v137 + 24) = 0;
    *(unsigned char *)(v137 + 32) = 8;
    swift_bridgeObjectRetain();
    swift_willThrow();
    outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
    goto LABEL_53;
  }
  uint64_t v95 = String.subscript.getter();
  uint64_t v97 = v96;
  uint64_t v99 = v98;
  uint64_t v101 = v100;
  swift_bridgeObjectRelease();
  uint64_t v102 = MEMORY[0x192FAFFE0](v95, v97, v99, v101);
  uint64_t v104 = v103;
  swift_bridgeObjectRelease();
  uint64_t v39 = v153;
  *(void *)(v153 + 96) = v102;
  *(void *)(v39 + 104) = v104;
  uint64_t v35 = *(void *)&v18[v142];
LABEL_31:
  uint64_t Node = v169;
  uint64_t v63 = v162;
  a1 = v151;
  outlined init with copy of PgQuery_Alias?(v35 + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__val, (uint64_t)v151, &demangling cache variable for type metadata for PgQuery_Node?);
  int v64 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(v149 + 48))(a1, 1, v63);
  uint64_t v34 = v145;
  uint64_t v27 = v150;
  if (v64 == 1)
  {
    UnknownStorage.init()();
    uint64_t v30 = *(int *)(v63 + 20);
    if (one-time initialization token for defaultInstance == -1) {
      goto LABEL_33;
    }
    goto LABEL_88;
  }
  outlined init with take of PgQuery_ParseResult((uint64_t)a1, (uint64_t)v150, type metadata accessor for PgQuery_Node);
LABEL_35:
  uint64_t v65 = v152;
  outlined init with copy of PgQuery_ScanResult(v38, v152, type metadata accessor for SQLTokenInformation);
  SQLExpression.init(expressionNode:schemas:tokenInformation:)((uint64_t)v27, v34, v65, (uint64_t)&v171);
  if (Node)
  {
    outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
    outlined destroy of PgQuery_ParseResult(v38, type metadata accessor for SQLTokenInformation);
    outlined destroy of PgQuery_ParseResult((uint64_t)v18, type metadata accessor for PgQuery_ResTarget);
    return swift_bridgeObjectRelease();
  }
  else
  {
    outlined init with copy of SQLExpression((uint64_t)&v171, v39);
    uint64_t v72 = *(void *)(v38 + 8);
    uint64_t v73 = *(void *)(v72 + 16);
    if (v73)
    {
      uint64_t v169 = 0;
      int v74 = *(_DWORD *)(*(void *)&v18[v142]
                      + OBJC_IVAR____TtCV14BiomeSQLParser17PgQuery_ResTargetP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__location);
      unint64_t v167 = (*(unsigned __int8 *)(v154 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v154 + 80);
      uint64_t v75 = v72 + v167;
      uint64_t v76 = *(void *)(v154 + 72);
      swift_bridgeObjectRetain();
      unint64_t v77 = 0;
      uint64_t v78 = (int *)v156;
      while (1)
      {
        outlined init with copy of PgQuery_ScanResult(v75, (uint64_t)v78, type metadata accessor for PgQuery_ScanToken);
        int v79 = *v78;
        outlined destroy of PgQuery_ParseResult((uint64_t)v78, type metadata accessor for PgQuery_ScanToken);
        if (v79 == v74) {
          break;
        }
        ++v77;
        v75 += v76;
        if (v73 == v77)
        {
          swift_bridgeObjectRelease();
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          uint64_t v38 = v168;
          uint64_t v18 = v157;
          goto LABEL_81;
        }
      }
      swift_bridgeObjectRelease();
      uint64_t v173 = MEMORY[0x1E4FBC860];
      uint64_t v38 = v168;
      unint64_t v105 = *(char **)(v168 + 8);
      if (*((void *)v105 + 2) < v77) {
        goto LABEL_91;
      }
      if (v77)
      {
        char v106 = &v105[v167];
        uint64_t v161 = (char *)(v146 + 8);
        uint64_t v156 = v105;
        swift_bridgeObjectRetain();
        do
        {
          outlined init with copy of PgQuery_ScanResult((uint64_t)&v106[--v77 * v76], (uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
          if (v10[16] == 1)
          {
            uint64_t v107 = *((void *)v10 + 1);
            if ((unint64_t)(v107 - 39) >= 0x152)
            {
              switch(v107)
              {
                case 6:
                case 377:
                  outlined destroy of PgQuery_ParseResult((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
                  goto LABEL_77;
                case 37:
                case 38:
                  PgQuery_Token.rawValue.getter(v107, 1);
                  unint64_t v108 = String.index(_:offsetBy:)();
                  if ((unint64_t)String.index(_:offsetBy:)() >> 14 < v108 >> 14)
                  {
                    __break(1u);
LABEL_90:
                    __break(1u);
LABEL_91:
                    __break(1u);
                    JUMPOUT(0x18EA60BD4);
                  }
                  uint64_t v109 = String.subscript.getter();
                  uint64_t v110 = MEMORY[0x192FAFFE0](v109);
                  uint64_t v112 = v111;
                  swift_bridgeObjectRelease();
                  v172._uint64_t countAndFlagsBits = v110;
                  v172._object = v112;
                  uint64_t v113 = v163;
                  static CharacterSet.whitespaces.getter();
                  uint64_t v160 = (unsigned int (**)(void, void, void))lazy protocol witness table accessor for type String and conformance String();
                  uint64_t v114 = StringProtocol.trimmingCharacters(in:)();
                  unint64_t v116 = v115;
                  uint64_t v159 = *(void (***)(char *, uint64_t, uint64_t, unint64_t))v161;
                  ((void (*)(char *, uint64_t))v159)(v113, v164);
                  uint64_t v117 = swift_bridgeObjectRelease();
                  v172._uint64_t countAndFlagsBits = 10;
                  v172._object = (void *)0xE100000000000000;
                  MEMORY[0x1F4188790](v117);
                  uint64_t v139 = &v172;
                  swift_bridgeObjectRetain();
                  uint64_t v118 = v169;
                  unint64_t v119 = specialized Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(0x7FFFFFFFFFFFFFFFLL, 1, partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:), (uint64_t)&v141[-4], v114, v116);
                  uint64_t v169 = v118;
                  swift_bridgeObjectRelease();
                  unint64_t v120 = *((void *)v119 + 2);
                  if (v120)
                  {
                    uint64_t v170 = MEMORY[0x1E4FBC860];
                    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
                    uint64_t v158 = (uint64_t)v119;
                    uint64_t v121 = (uint64_t *)(v119 + 56);
                    do
                    {
                      unint64_t v167 = v120;
                      uint64_t v123 = *(v121 - 3);
                      uint64_t v122 = *(v121 - 2);
                      uint64_t v124 = *(v121 - 1);
                      uint64_t v125 = *v121;
                      swift_bridgeObjectRetain();
                      v172._uint64_t countAndFlagsBits = MEMORY[0x192FAFFE0](v123, v122, v124, v125);
                      v172._object = v126;
                      uint64_t v127 = v163;
                      static CharacterSet.whitespaces.getter();
                      uint64_t v166 = (char *)StringProtocol.trimmingCharacters(in:)();
                      uint64_t v162 = v128;
                      ((void (*)(char *, uint64_t))v159)(v127, v164);
                      swift_bridgeObjectRelease();
                      swift_bridgeObjectRelease();
                      uint64_t v129 = v170;
                      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
                      {
                        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
                        uint64_t v129 = v170;
                      }
                      unint64_t v130 = *(void *)(v129 + 16);
                      if (v130 >= *(void *)(v129 + 24) >> 1)
                      {
                        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
                        uint64_t v129 = v170;
                      }
                      *(void *)(v129 + 16) = v130 + 1;
                      uint64_t v131 = v129 + 16 * v130;
                      unint64_t v132 = v167;
                      uint64_t v133 = v162;
                      *(void *)(v131 + 32) = v166;
                      *(void *)(v131 + 40) = v133;
                      v121 += 4;
                      unint64_t v120 = v132 - 1;
                    }
                    while (v120);
                    swift_bridgeObjectRelease();
                    uint64_t v38 = v168;
                  }
                  else
                  {
                    swift_bridgeObjectRelease();
                    uint64_t v129 = MEMORY[0x1E4FBC860];
                  }
                  specialized Array.replaceSubrange<A>(_:with:)(0, 0, v129);
                  swift_bridgeObjectRelease();
                  break;
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                case 129:
                case 130:
                case 131:
                case 132:
                case 133:
                case 134:
                case 135:
                case 136:
                case 137:
                case 138:
                case 139:
                case 140:
                case 141:
                case 142:
                case 143:
                case 144:
                case 145:
                case 146:
                case 147:
                case 148:
                case 149:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                case 164:
                case 165:
                case 166:
                case 167:
                case 168:
                case 169:
                case 170:
                case 171:
                case 172:
                case 173:
                case 174:
                case 175:
                case 176:
                case 177:
                case 178:
                case 179:
                case 180:
                case 181:
                case 182:
                case 183:
                case 184:
                case 185:
                case 186:
                case 187:
                case 188:
                case 189:
                case 190:
                case 191:
                case 192:
                case 193:
                case 194:
                case 195:
                case 196:
                case 197:
                case 198:
                case 199:
                case 200:
                case 201:
                case 202:
                case 203:
                case 204:
                case 205:
                case 206:
                case 207:
                case 208:
                case 209:
                case 210:
                case 211:
                case 212:
                case 213:
                case 214:
                case 215:
                case 216:
                case 217:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 240:
                case 241:
                case 242:
                case 243:
                case 244:
                case 245:
                case 246:
                case 247:
                case 248:
                case 249:
                case 250:
                case 251:
                case 252:
                case 253:
                case 254:
                case 255:
                case 256:
                case 257:
                case 258:
                case 259:
                case 260:
                case 261:
                case 262:
                case 263:
                case 264:
                case 265:
                case 266:
                case 267:
                case 268:
                case 269:
                case 270:
                case 271:
                case 272:
                case 273:
                case 274:
                case 275:
                case 276:
                case 277:
                case 278:
                case 279:
                case 280:
                case 281:
                case 282:
                case 283:
                case 284:
                case 285:
                case 286:
                case 287:
                case 288:
                case 289:
                case 290:
                case 291:
                case 292:
                case 293:
                case 294:
                case 295:
                case 296:
                case 297:
                case 298:
                case 299:
                case 300:
                case 301:
                case 302:
                case 303:
                case 304:
                case 305:
                case 306:
                case 307:
                case 308:
                case 309:
                case 310:
                case 311:
                case 312:
                case 313:
                case 314:
                case 315:
                case 316:
                case 317:
                case 318:
                case 319:
                case 320:
                case 321:
                case 322:
                case 323:
                case 324:
                case 325:
                case 326:
                case 327:
                case 328:
                case 329:
                case 330:
                case 331:
                case 332:
                case 333:
                case 334:
                case 335:
                case 336:
                case 337:
                case 338:
                case 339:
                case 340:
                case 341:
                case 342:
                case 343:
                case 344:
                case 345:
                case 346:
                case 347:
                case 348:
                case 349:
                case 350:
                case 351:
                case 352:
                case 353:
                case 354:
                case 355:
                case 356:
                case 357:
                case 358:
                case 359:
                case 360:
                case 361:
                case 362:
                case 363:
                case 364:
                case 365:
                case 366:
                case 367:
                case 368:
                case 369:
                case 370:
                case 371:
                case 372:
                case 373:
                case 374:
                case 375:
                case 376:
                  goto LABEL_91;
                default:
                  break;
              }
            }
          }
          outlined destroy of PgQuery_ParseResult((uint64_t)v10, type metadata accessor for PgQuery_ScanToken);
        }
        while (v77);
LABEL_77:
        swift_bridgeObjectRelease();
      }
      uint64_t v18 = v157;
      if (*(void *)(v173 + 16))
      {
        v172._uint64_t countAndFlagsBits = v173;
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        lazy protocol witness table accessor for type [String] and conformance [A]();
        uint64_t v80 = BidirectionalCollection<>.joined(separator:)();
        uint64_t v81 = v138;
        swift_bridgeObjectRelease();
      }
      else
      {
        swift_bridgeObjectRelease();
        uint64_t v80 = 0;
        uint64_t v81 = 0;
      }
LABEL_81:
      uint64_t v39 = v153;
    }
    else
    {
      uint64_t v80 = 0;
      uint64_t v81 = 0;
    }
    outlined destroy of PgQuery_ParseResult((uint64_t)v165, type metadata accessor for PgQuery_Node);
    outlined destroy of SQLExpression((uint64_t)&v171);
    outlined destroy of PgQuery_ParseResult(v38, type metadata accessor for SQLTokenInformation);
    uint64_t result = outlined destroy of PgQuery_ParseResult((uint64_t)v18, type metadata accessor for PgQuery_ResTarget);
    *(void *)(v39 + 112) = v80;
    *(void *)(v39 + 120) = v81;
  }
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance ResultColumn.CodingKeys()
{
  uint64_t v1 = 0x7361696C61;
  if (*v0 != 1) {
    uint64_t v1 = 0x746E656D75636F64;
  }
  if (*v0) {
    return v1;
  }
  else {
    return 0x6973736572707865;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance ResultColumn.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized ResultColumn.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance ResultColumn.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 3;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance ResultColumn.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ResultColumn.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t ResultColumn.encode(to:)(void *a1)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<ResultColumn.CodingKeys>);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
    v8[13] = 2;
    KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance ResultColumn(void *a1)
{
  return ResultColumn.encode(to:)(a1);
}

uint64_t SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v317 = (const void *)a2;
  uint64_t v277 = a3;
  uint64_t v4 = type metadata accessor for SQLTokenInformation(0);
  uint64_t v5 = MEMORY[0x1F4188790](v4 - 8);
  uint64_t v269 = (uint64_t *)((char *)&v257 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v5);
  uint64_t v272 = (uint64_t)&v257 - v7;
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v276 = *(void *)(Node - 8);
  uint64_t v8 = MEMORY[0x1F4188790](Node);
  uint64_t v268 = (char *)&v257 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  uint64_t v271 = (uint64_t)&v257 - v10;
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v12 = MEMORY[0x1F4188790](v11 - 8);
  uint64_t v270 = (uint64_t *)((char *)&v257 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v275 = (char *)&v257 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v257 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (uint64_t *)((char *)&v257 - v19);
  uint64_t v21 = type metadata accessor for PlanResources(0);
  MEMORY[0x1F4188790](v21);
  uint64_t v23 = (uint64_t *)((char *)&v257 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v24 = (uint64_t *)*(int *)(type metadata accessor for PgQuery_SelectStmt(0) + 20);
  uint64_t v25 = *(uint64_t *)((char *)v24 + a1);
  outlined init with copy of PgQuery_ScanResult((uint64_t)v317, (uint64_t)v23, type metadata accessor for PlanResources);
  uint64_t v26 = swift_bridgeObjectRetain();
  uint64_t v27 = v278;
  uint64_t v28 = FromClause.init(fromClauseNodes:resources:)(v26, v23, (unint64_t *)&v309);
  if (v27)
  {
    outlined destroy of PgQuery_ParseResult(a1, type metadata accessor for PgQuery_SelectStmt);
    return outlined destroy of PgQuery_ParseResult((uint64_t)v317, type metadata accessor for PlanResources);
  }
  unint64_t v274 = v20;
  uint64_t v262 = v18;
  uint64_t v263 = (unsigned char *)v21;
  uint64_t v264 = v24;
  uint64_t v267 = a1;
  long long v30 = v314;
  uint64_t v31 = v277;
  *(_OWORD *)(v277 + 64) = v313;
  *(_OWORD *)(v31 + 80) = v30;
  *(void *)(v31 + 96) = v315;
  long long v32 = v310;
  *(_OWORD *)uint64_t v31 = v309;
  *(_OWORD *)(v31 + 16) = v32;
  long long v33 = v312;
  *(_OWORD *)(v31 + 32) = v311;
  *(_OWORD *)(v31 + 48) = v33;
  uint64_t v34 = *(void *)(v25
                  + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__targetList);
  uint64_t v35 = *(const void **)v31;
  MEMORY[0x1F4188790](v28);
  unint64_t v36 = v317;
  *(&v257 - 2) = v35;
  *(&v257 - 1) = v36;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF12ResultColumnVsAE_pTg5((void (*)(_OWORD *__return_ptr, uint64_t, uint64_t *))partial apply for closure #1 in SelectCore.init(select:resources:), (uint64_t)(&v257 - 4), v34);
  uint64_t v260 = 0;
  uint64_t v261 = 0;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  *(void *)(v31 + 304) = NodeVG_AF12ResultColumnVsAE_pTg5;
  uint64_t v38 = *(char **)(NodeVG_AF12ResultColumnVsAE_pTg5 + 16);
  if (!v38)
  {
    swift_bridgeObjectRetain();
    uint64_t v41 = MEMORY[0x1E4FBC868];
    uint64_t v42 = (uint64_t)v274;
    goto LABEL_58;
  }
  unint64_t v39 = NodeVG_AF12ResultColumnVsAE_pTg5 + 32;
  int64_t v259 = NodeVG_AF12ResultColumnVsAE_pTg5;
  swift_bridgeObjectRetain_n();
  long long v40 = 0;
  uint64_t v41 = MEMORY[0x1E4FBC868];
  uint64_t v42 = (uint64_t)v274;
  uint64_t v265 = NodeVG_AF12ResultColumnVsAE_pTg5 + 32;
  uint64_t v266 = v38;
  while (2)
  {
    outlined init with copy of ResultColumn(v39 + ((void)v40 << 7), (uint64_t)&v309);
    uint64_t v43 = (uint64_t)v316;
    if (!v316 || *(void *)(v313 + 16)) {
      goto LABEL_11;
    }
    uint64_t v44 = v315;
    LODWORD(v278) = BYTE8(v312);
    swift_bridgeObjectRetain();
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    *(void *)&long long v298 = v41;
    uint64_t v42 = v41;
    unint64_t v47 = specialized __RawDictionaryStorage.find<A>(_:)(v44, v43);
    uint64_t v48 = *(void *)(v41 + 16);
    BOOL v49 = (v46 & 1) == 0;
    uint64_t v50 = v48 + v49;
    if (__OFADD__(v48, v49))
    {
      __break(1u);
      break;
    }
    unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = v46;
    if (*(void *)(v41 + 24) < v50)
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v50, isUniquelyReferenced_nonNull_native);
      uint64_t v42 = v298;
      unint64_t v51 = specialized __RawDictionaryStorage.find<A>(_:)(v44, v43);
      if ((NodeVG_AF12ResultColumnVsAE_pTg5 & 1) != (v52 & 1)) {
        goto LABEL_324;
      }
      unint64_t v47 = v51;
      if (NodeVG_AF12ResultColumnVsAE_pTg5) {
        goto LABEL_9;
      }
      goto LABEL_21;
    }
    if (isUniquelyReferenced_nonNull_native)
    {
      uint64_t v42 = v41;
      if (v46) {
        goto LABEL_9;
      }
      goto LABEL_21;
    }
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
    uint64_t v57 = static _DictionaryStorage.copy(original:)();
    uint64_t v42 = v57;
    if (!*(void *)(v41 + 16)) {
      goto LABEL_54;
    }
    Swift::String v58 = (void *)(v57 + 64);
    unint64_t v59 = (unint64_t)((1 << *(unsigned char *)(v42 + 32)) + 63) >> 6;
    uint64_t v257 = (const void *)(v41 + 64);
    if (v42 != v41 || (unint64_t)v58 >= v41 + 64 + 8 * v59) {
      memmove(v58, v257, 8 * v59);
    }
    int64_t v60 = 0;
    *(void *)(v42 + 16) = *(void *)(v41 + 16);
    uint64_t v61 = 1 << *(unsigned char *)(v41 + 32);
    if (v61 < 64) {
      uint64_t v62 = ~(-1 << v61);
    }
    else {
      uint64_t v62 = -1;
    }
    unint64_t v63 = v62 & *(void *)(v41 + 64);
    int64_t v258 = (unint64_t)(v61 + 63) >> 6;
    while (1)
    {
      if (v63)
      {
        unint64_t v64 = __clz(__rbit64(v63));
        v63 &= v63 - 1;
        unint64_t v65 = v64 | (v60 << 6);
        goto LABEL_32;
      }
      int64_t v70 = v60 + 1;
      if (__OFADD__(v60, 1)) {
        goto LABEL_318;
      }
      if (v70 >= v258) {
        goto LABEL_54;
      }
      unint64_t v71 = *((void *)v257 + v70);
      ++v60;
      if (!v71)
      {
        int64_t v60 = v70 + 1;
        if (v70 + 1 >= v258) {
          goto LABEL_54;
        }
        unint64_t v71 = *((void *)v257 + v60);
        if (!v71)
        {
          int64_t v60 = v70 + 2;
          if (v70 + 2 >= v258) {
            goto LABEL_54;
          }
          unint64_t v71 = *((void *)v257 + v60);
          if (!v71)
          {
            int64_t v60 = v70 + 3;
            if (v70 + 3 >= v258) {
              goto LABEL_54;
            }
            unint64_t v71 = *((void *)v257 + v60);
            if (!v71)
            {
              int64_t v60 = v70 + 4;
              if (v70 + 4 >= v258) {
                goto LABEL_54;
              }
              unint64_t v71 = *((void *)v257 + v60);
              if (!v71)
              {
                int64_t v60 = v70 + 5;
                if (v70 + 5 >= v258) {
                  goto LABEL_54;
                }
                unint64_t v71 = *((void *)v257 + v60);
                if (!v71) {
                  break;
                }
              }
            }
          }
        }
      }
LABEL_53:
      unint64_t v63 = (v71 - 1) & v71;
      unint64_t v65 = __clz(__rbit64(v71)) + (v60 << 6);
LABEL_32:
      uint64_t v66 = (uint64_t *)(*(void *)(v41 + 48) + 16 * v65);
      uint64_t v68 = *v66;
      uint64_t v67 = v66[1];
      LOBYTE(v66) = *(unsigned char *)(*(void *)(v41 + 56) + v65);
      uint64_t v69 = (void *)(*(void *)(v42 + 48) + 16 * v65);
      *uint64_t v69 = v68;
      v69[1] = v67;
      *(unsigned char *)(*(void *)(v42 + 56) + v65) = (_BYTE)v66;
      swift_bridgeObjectRetain();
    }
    int64_t v72 = v70 + 6;
    if (v72 >= v258) {
      goto LABEL_54;
    }
    unint64_t v71 = *((void *)v257 + v72);
    if (v71)
    {
      int64_t v60 = v72;
      goto LABEL_53;
    }
    while (1)
    {
      int64_t v60 = v72 + 1;
      if (__OFADD__(v72, 1)) {
        goto LABEL_322;
      }
      if (v60 >= v258) {
        break;
      }
      unint64_t v71 = *((void *)v257 + v60);
      ++v72;
      if (v71) {
        goto LABEL_53;
      }
    }
LABEL_54:
    swift_bridgeObjectRelease();
    if (NodeVG_AF12ResultColumnVsAE_pTg5)
    {
LABEL_9:
      *(unsigned char *)(*(void *)(v42 + 56) + v47) = (_BYTE)v278;
      goto LABEL_10;
    }
LABEL_21:
    *(void *)(v42 + 8 * (v47 >> 6) + 64) |= 1 << v47;
    uint64_t v53 = (uint64_t *)(*(void *)(v42 + 48) + 16 * v47);
    *uint64_t v53 = v44;
    v53[1] = v43;
    *(unsigned char *)(*(void *)(v42 + 56) + v47) = (_BYTE)v278;
    uint64_t v54 = *(void *)(v42 + 16);
    BOOL v55 = __OFADD__(v54, 1);
    uint64_t v56 = v54 + 1;
    if (!v55)
    {
      *(void *)(v42 + 16) = v56;
      swift_bridgeObjectRetain();
LABEL_10:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v41 = v42;
      uint64_t v42 = (uint64_t)v274;
      unint64_t v39 = v265;
      uint64_t v38 = v266;
LABEL_11:
      ++v40;
      outlined destroy of ResultColumn((uint64_t)&v309);
      if (v40 != v38) {
        continue;
      }
      swift_bridgeObjectRelease();
      uint64_t v31 = v277;
LABEL_58:
      unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = 0xEC0000007361696CLL;
      swift_bridgeObjectRelease();
      uint64_t v44 = *(void *)v31;
      swift_bridgeObjectRetain_n();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      char v73 = swift_isUniquelyReferenced_nonNull_native();
      unint64_t v278 = (void *)v44;
      if (v73) {
        goto LABEL_59;
      }
      goto LABEL_231;
    }
    break;
  }
  __break(1u);
  while (2)
  {
    __break(1u);
LABEL_231:
    unint64_t v278 = (void *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v44 + 16) + 1, 1, v44);
LABEL_59:
    unint64_t v75 = v278[2];
    unint64_t v74 = v278[3];
    if (v75 >= v74 >> 1) {
      unint64_t v278 = (void *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v74 > 1, v75 + 1, 1, (uint64_t)v278);
    }
    uint64_t v76 = v278;
    v278[2] = v75 + 1;
    unint64_t v77 = &v76[3 * v75];
    v77[4] = 0x615F7463656C6573;
    v77[5] = NodeVG_AF12ResultColumnVsAE_pTg5;
    v77[6] = v41;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = v267;
    uint64_t v78 = v264;
    outlined init with copy of PgQuery_Alias?(*(uint64_t *)((char *)v264 + v267)+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause, v42, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v80 = v276 + 48;
    int v79 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v276 + 48);
    uint64_t v81 = Node;
    uint64_t v82 = v79(v42, 1, Node);
    outlined destroy of AnyValue?(v42, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v276 = v80;
    uint64_t v266 = (char *)v79;
    if (v82 == 1)
    {
      uint64_t v83 = v277;
      *(_OWORD *)(v277 + 184) = 0u;
      *(_OWORD *)(v83 + 168) = 0u;
      *(_OWORD *)(v83 + 152) = 0u;
      *(_OWORD *)(v83 + 136) = 0u;
      *(_OWORD *)(v83 + 120) = 0u;
      *(_OWORD *)(v83 + 104) = 0u;
      uint64_t v41 = (uint64_t)v317;
      uint64_t v84 = v261;
      goto LABEL_70;
    }
    uint64_t v85 = *(uint64_t *)((char *)v78 + NodeVG_AF12ResultColumnVsAE_pTg5)
        + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__whereClause;
    unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = (unint64_t)v262;
    outlined init with copy of PgQuery_Alias?(v85, (uint64_t)v262, &demangling cache variable for type metadata for PgQuery_Node?);
    int v86 = v79(NodeVG_AF12ResultColumnVsAE_pTg5, 1, v81);
    uint64_t v87 = v81;
    uint64_t v41 = (uint64_t)v317;
    uint64_t v84 = v261;
    if (v86 != 1)
    {
      uint64_t v82 = v271;
      outlined init with take of PgQuery_ParseResult(NodeVG_AF12ResultColumnVsAE_pTg5, v271, type metadata accessor for PgQuery_Node);
      goto LABEL_67;
    }
    uint64_t v82 = v271;
    UnknownStorage.init()();
    uint64_t v88 = *(int *)(v87 + 20);
    if (one-time initialization token for defaultInstance != -1) {
      goto LABEL_307;
    }
    while (1)
    {
      *(void *)(v82 + v88) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of AnyValue?(NodeVG_AF12ResultColumnVsAE_pTg5, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_67:
      uint64_t v83 = v277;
      uint64_t v89 = v272;
      outlined init with copy of PgQuery_ScanResult(v41 + *((int *)v263 + 5), v272, type metadata accessor for SQLTokenInformation);
      uint64_t v90 = v278;
      swift_bridgeObjectRetain();
      SQLExpression.init(expressionNode:schemas:tokenInformation:)(v82, (uint64_t)v90, v89, (uint64_t)&v309);
      if (v84)
      {
        outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
        swift_bridgeObjectRelease();
        outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
        uint64_t v91 = v260;
        uint64_t result = outlined destroy of FromClause(v83);
        if (v91) {
          return result;
        }
        return swift_bridgeObjectRelease();
      }
      outlined init with take of SQLExpression?((uint64_t)&v309, v83 + 104, &demangling cache variable for type metadata for SQLExpression?);
LABEL_70:
      uint64_t v271 = v83 + 104;
      outlined init with copy of PgQuery_Alias?(v83 + 104, (uint64_t)&v309, &demangling cache variable for type metadata for SQLExpression?);
      if (!*((void *)&v310 + 1))
      {
        uint64_t v96 = v84;
        uint64_t v97 = outlined destroy of AnyValue?((uint64_t)&v309, &demangling cache variable for type metadata for SQLExpression?);
        goto LABEL_77;
      }
      long long v300 = v311;
      long long v301 = v312;
      long long v302 = v313;
      long long v303 = v314;
      long long v298 = v309;
      long long v299 = v310;
      uint64_t v88 = v313;
      if (!*(void *)(v313 + 16)) {
        break;
      }
      swift_bridgeObjectRelease();
      if (*(void *)(v88 + 16))
      {
        outlined init with copy of AggregationFunction(v88 + 32, (uint64_t)&v309);
        Swift::String v92 = AggregationFunction.name()();
        outlined destroy of AggregationFunction((uint64_t)&v309);
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(Swift::String *)uint64_t v93 = v92;
        *(void *)(v93 + 16) = 0;
        *(void *)(v93 + 24) = 0;
        *(unsigned char *)(v93 + 32) = 5;
        swift_willThrow();
        outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of SQLExpression((uint64_t)&v298);
        goto LABEL_74;
      }
LABEL_306:
      __break(1u);
LABEL_307:
      swift_once();
    }
    uint64_t v96 = v84;
    uint64_t v97 = outlined destroy of SQLExpression((uint64_t)&v298);
LABEL_77:
    uint64_t v98 = v267;
    uint64_t v99 = *(void *)(*(uint64_t *)((char *)v264 + v267)
                    + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__groupClause);
    MEMORY[0x1F4188790](v97);
    *(&v257 - 2) = v278;
    *(&v257 - 1) = (const void *)v41;
    swift_bridgeObjectRetain();
    uint64_t NodeVG_AF13SQLExpressionVsAE_pTg5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSay14BiomeSQLParser12PgQuery_NodeVG_AF13SQLExpressionVsAE_pTg5((void (*)(_OWORD *__return_ptr, uint64_t, uint64_t *))partial apply for closure #3 in SelectCore.init(select:resources:), (uint64_t)(&v257 - 4), v99);
    uint64_t v261 = v96;
    if (v96)
    {
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult(v98, type metadata accessor for PgQuery_SelectStmt);
      swift_bridgeObjectRelease();
      outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
      int v94 = 0;
      int v95 = 0;
      goto LABEL_79;
    }
    uint64_t v88 = NodeVG_AF13SQLExpressionVsAE_pTg5;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v101 = *(void *)(v88 + 16);
    if (v101)
    {
      uint64_t v102 = 96;
      uint64_t v82 = (uint64_t)v275;
      uint64_t v103 = v276;
      uint64_t v104 = v264;
      while (1)
      {
        unint64_t v105 = *(uint64_t **)(v88 + v102);
        if (v105[2]) {
          break;
        }
        v102 += 96;
        if (!--v101) {
          goto LABEL_101;
        }
      }
      swift_bridgeObjectRelease();
      if (!v105[2])
      {
        __break(1u);
LABEL_312:
        __break(1u);
        goto LABEL_313;
      }
      outlined init with copy of AggregationFunction((uint64_t)(v105 + 4), (uint64_t)&v309);
      Swift::String v110 = AggregationFunction.name()();
      outlined destroy of AggregationFunction((uint64_t)&v309);
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      *(Swift::String *)uint64_t v111 = v110;
      *(void *)(v111 + 16) = 0;
      *(void *)(v111 + 24) = 0;
      *(unsigned char *)(v111 + 32) = 6;
      swift_willThrow();
      outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
LABEL_74:
      outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
      int v94 = 0;
      int v95 = 0;
      goto LABEL_79;
    }
    swift_bridgeObjectRelease();
    uint64_t v106 = *(void *)(v83 + 304);
    uint64_t v107 = *(void *)(v106 + 16);
    uint64_t v104 = v264;
    if (v107)
    {
      uint64_t v108 = v106 + 32;
      swift_bridgeObjectRetain();
      while (1)
      {
        outlined init with copy of ResultColumn(v108, (uint64_t)&v309);
        uint64_t v109 = *(void *)(v313 + 16);
        outlined destroy of ResultColumn((uint64_t)&v309);
        if (v109) {
          break;
        }
        v108 += 128;
        if (!--v107)
        {
          swift_bridgeObjectRelease();
          uint64_t v88 = 0;
          goto LABEL_100;
        }
      }
      swift_bridgeObjectRelease();
      uint64_t v88 = MEMORY[0x1E4FBC860];
    }
    else
    {
      uint64_t v88 = 0;
    }
LABEL_100:
    uint64_t v82 = (uint64_t)v275;
LABEL_101:
    *(void *)(v83 + 200) = v88;
    uint64_t v112 = *(void *)(v83 + 304);
    unint64_t v274 = *(uint64_t **)(v112 + 16);
    if (!v274)
    {
      swift_bridgeObjectRetain();
      uint64_t v88 = MEMORY[0x1E4FBC868];
      goto LABEL_151;
    }
    uint64_t v272 = v112 + 32;
    uint64_t v265 = v112;
    swift_bridgeObjectRetain_n();
    uint64_t v84 = 0;
    uint64_t v88 = MEMORY[0x1E4FBC868];
LABEL_106:
    outlined init with copy of ResultColumn(v272 + (v84 << 7), (uint64_t)&v309);
    unint64_t NodeVG_AF12ResultColumnVsAE_pTg5 = (unint64_t)v316;
    if (!v316) {
      goto LABEL_105;
    }
    uint64_t v41 = v315;
    LODWORD(v278) = BYTE8(v312);
    swift_bridgeObjectRetain();
    uint64_t v44 = swift_isUniquelyReferenced_nonNull_native();
    *(void *)&long long v298 = v88;
    uint64_t v42 = v88;
    unint64_t v114 = specialized __RawDictionaryStorage.find<A>(_:)(v41, NodeVG_AF12ResultColumnVsAE_pTg5);
    uint64_t v115 = *(void *)(v88 + 16);
    BOOL v116 = (v113 & 1) == 0;
    uint64_t v117 = v115 + v116;
    if (__OFADD__(v115, v116)) {
      continue;
    }
    break;
  }
  char v118 = v113;
  if (*(void *)(v88 + 24) < v117)
  {
    specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v117, v44);
    uint64_t v119 = v298;
    unint64_t v120 = specialized __RawDictionaryStorage.find<A>(_:)(v41, NodeVG_AF12ResultColumnVsAE_pTg5);
    if ((v118 & 1) != (v121 & 1)) {
      goto LABEL_324;
    }
    unint64_t v114 = v120;
    uint64_t v82 = (uint64_t)v275;
    if (v118) {
      goto LABEL_103;
    }
    goto LABEL_114;
  }
  if (v44)
  {
    uint64_t v119 = v88;
    uint64_t v82 = (uint64_t)v275;
    if (v113) {
      goto LABEL_103;
    }
    goto LABEL_114;
  }
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _DictionaryStorage<String, SQLDataType>);
  uint64_t v125 = static _DictionaryStorage.copy(original:)();
  uint64_t v119 = v125;
  if (!*(void *)(v88 + 16)) {
    goto LABEL_147;
  }
  uint64_t v126 = (char *)(v125 + 64);
  uint64_t v127 = 1 << *(unsigned char *)(v119 + 32);
  uint64_t v262 = (char *)(v88 + 64);
  unint64_t v128 = (unint64_t)(v127 + 63) >> 6;
  if (v119 != v88 || v126 >= &v262[8 * v128]) {
    memmove(v126, v262, 8 * v128);
  }
  int64_t v129 = 0;
  *(void *)(v119 + 16) = *(void *)(v88 + 16);
  uint64_t v130 = 1 << *(unsigned char *)(v88 + 32);
  if (v130 < 64) {
    uint64_t v131 = ~(-1 << v130);
  }
  else {
    uint64_t v131 = -1;
  }
  unint64_t v132 = v131 & *(void *)(v88 + 64);
  int64_t v259 = (unint64_t)(v130 + 63) >> 6;
  while (1)
  {
    if (v132)
    {
      unint64_t v133 = __clz(__rbit64(v132));
      v132 &= v132 - 1;
      unint64_t v134 = v133 | (v129 << 6);
      goto LABEL_125;
    }
    int64_t v139 = v129 + 1;
    if (__OFADD__(v129, 1)) {
      goto LABEL_319;
    }
    if (v139 >= v259) {
      goto LABEL_147;
    }
    unint64_t v140 = *(void *)&v262[8 * v139];
    ++v129;
    if (!v140)
    {
      int64_t v129 = v139 + 1;
      if (v139 + 1 >= v259) {
        goto LABEL_147;
      }
      unint64_t v140 = *(void *)&v262[8 * v129];
      if (!v140)
      {
        int64_t v129 = v139 + 2;
        if (v139 + 2 >= v259) {
          goto LABEL_147;
        }
        unint64_t v140 = *(void *)&v262[8 * v129];
        if (!v140)
        {
          int64_t v129 = v139 + 3;
          if (v139 + 3 >= v259) {
            goto LABEL_147;
          }
          unint64_t v140 = *(void *)&v262[8 * v129];
          if (!v140)
          {
            int64_t v129 = v139 + 4;
            if (v139 + 4 >= v259) {
              goto LABEL_147;
            }
            unint64_t v140 = *(void *)&v262[8 * v129];
            if (!v140)
            {
              int64_t v129 = v139 + 5;
              if (v139 + 5 >= v259) {
                goto LABEL_147;
              }
              unint64_t v140 = *(void *)&v262[8 * v129];
              if (!v140) {
                break;
              }
            }
          }
        }
      }
    }
LABEL_146:
    unint64_t v132 = (v140 - 1) & v140;
    unint64_t v134 = __clz(__rbit64(v140)) + (v129 << 6);
LABEL_125:
    uint64_t v135 = (uint64_t *)(*(void *)(v88 + 48) + 16 * v134);
    uint64_t v137 = *v135;
    uint64_t v136 = v135[1];
    LOBYTE(v135) = *(unsigned char *)(*(void *)(v88 + 56) + v134);
    uint64_t v138 = (void *)(*(void *)(v119 + 48) + 16 * v134);
    *uint64_t v138 = v137;
    v138[1] = v136;
    *(unsigned char *)(*(void *)(v119 + 56) + v134) = (_BYTE)v135;
    swift_bridgeObjectRetain();
  }
  int64_t v141 = v139 + 6;
  if (v141 >= v259) {
    goto LABEL_147;
  }
  unint64_t v140 = *(void *)&v262[8 * v141];
  if (v140)
  {
    int64_t v129 = v141;
    goto LABEL_146;
  }
  while (1)
  {
    int64_t v129 = v141 + 1;
    if (__OFADD__(v141, 1)) {
      goto LABEL_323;
    }
    if (v129 >= v259) {
      break;
    }
    unint64_t v140 = *(void *)&v262[8 * v129];
    ++v141;
    if (v140) {
      goto LABEL_146;
    }
  }
LABEL_147:
  swift_bridgeObjectRelease();
  uint64_t v82 = (uint64_t)v275;
  if (v118)
  {
LABEL_103:
    *(unsigned char *)(*(void *)(v119 + 56) + v114) = (_BYTE)v278;
    goto LABEL_104;
  }
LABEL_114:
  *(void *)(v119 + 8 * (v114 >> 6) + 64) |= 1 << v114;
  uint64_t v122 = (uint64_t *)(*(void *)(v119 + 48) + 16 * v114);
  uint64_t *v122 = v41;
  v122[1] = NodeVG_AF12ResultColumnVsAE_pTg5;
  *(unsigned char *)(*(void *)(v119 + 56) + v114) = (_BYTE)v278;
  uint64_t v123 = *(void *)(v119 + 16);
  BOOL v55 = __OFADD__(v123, 1);
  uint64_t v124 = v123 + 1;
  if (v55)
  {
    __break(1u);
    goto LABEL_306;
  }
  *(void *)(v119 + 16) = v124;
  swift_bridgeObjectRetain();
LABEL_104:
  uint64_t v83 = v277;
  uint64_t v41 = (uint64_t)v317;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v88 = v119;
LABEL_105:
  ++v84;
  outlined destroy of ResultColumn((uint64_t)&v309);
  if ((uint64_t *)v84 != v274) {
    goto LABEL_106;
  }
  swift_bridgeObjectRelease();
  uint64_t v104 = v264;
LABEL_151:
  swift_bridgeObjectRelease();
  uint64_t v142 = *(void *)((char *)v104 + v267);
  uint64_t v104 = &lazy cache variable for type metadata for PgQuery_Node.OneOf_Node?;
  unint64_t v105 = &demangling cache variable for type metadata for PgQuery_Node?;
  outlined init with copy of PgQuery_Alias?(v142+ OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_SelectStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__havingClause, v82, &demangling cache variable for type metadata for PgQuery_Node?);
  int v143 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v266)(v82, 1, Node);
  outlined destroy of AnyValue?(v82, &demangling cache variable for type metadata for PgQuery_Node?);
  if (v143 != 1)
  {
    uint64_t v103 = *(void *)v83;
    swift_bridgeObjectRetain_n();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    unint64_t v105 = (uint64_t *)v103;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
LABEL_310:
    }
      unint64_t v105 = (uint64_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v103 + 16) + 1, 1, v103);
    unint64_t v145 = v105[2];
    unint64_t v144 = v105[3];
    if (v145 >= v144 >> 1) {
      unint64_t v105 = (uint64_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v144 > 1, v145 + 1, 1, (uint64_t)v105);
    }
    v105[2] = v145 + 1;
    uint64_t v146 = &v105[3 * v145];
    strcpy((char *)v146 + 32, "select_alias");
    *((unsigned char *)v146 + 45) = 0;
    *((_WORD *)v146 + 23) = -5120;
    v146[6] = v88;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    uint64_t v88 = v267;
    uint64_t v147 = (uint64_t)v270;
    outlined init with copy of PgQuery_Alias?(*(uint64_t *)((char *)v264 + v267) + v104[159], (uint64_t)v270, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v148 = Node;
    if (((unsigned int (*)(uint64_t, uint64_t, uint64_t))v266)(v147, 1, Node) != 1)
    {
      uint64_t v104 = v268;
      outlined init with take of PgQuery_ParseResult(v147, (uint64_t)v268, type metadata accessor for PgQuery_Node);
      uint64_t v41 = (uint64_t)v317;
      uint64_t v103 = v261;
      uint64_t v82 = (uint64_t)v269;
      goto LABEL_160;
    }
    uint64_t v104 = v268;
    UnknownStorage.init()();
    uint64_t v88 = *(int *)(v148 + 20);
    uint64_t v41 = (uint64_t)v317;
    uint64_t v103 = v261;
    uint64_t v82 = (uint64_t)v269;
    if (one-time initialization token for defaultInstance == -1) {
      goto LABEL_158;
    }
    goto LABEL_315;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  *(_OWORD *)(v83 + 272) = 0u;
  *(_OWORD *)(v83 + 288) = 0u;
  *(_OWORD *)(v83 + 240) = 0u;
  *(_OWORD *)(v83 + 256) = 0u;
  *(_OWORD *)(v83 + 208) = 0u;
  *(_OWORD *)(v83 + 224) = 0u;
  uint64_t v103 = v261;
  uint64_t v88 = v267;
  while (2)
  {
    outlined init with copy of PgQuery_Alias?(v83 + 208, (uint64_t)&v309, &demangling cache variable for type metadata for SQLExpression?);
    if (*((void *)&v310 + 1))
    {
      v306[2] = v311;
      v306[3] = v312;
      long long v307 = v313;
      long long v308 = v314;
      v306[0] = v309;
      v306[1] = v310;
      if (!*(void *)(v83 + 200))
      {
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(_OWORD *)uint64_t v204 = 0u;
        *(_OWORD *)(v204 + 16) = 0u;
        *(unsigned char *)(v204 + 32) = 9;
        swift_willThrow();
        outlined destroy of PgQuery_ParseResult(v88, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of SQLExpression((uint64_t)v306);
        outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
LABEL_227:
        int v94 = 1;
        int v95 = 1;
        goto LABEL_79;
      }
      uint64_t v149 = *(void *)(v83 + 304);
      unint64_t v150 = (uint64_t *)MEMORY[0x1E4FBC870];
      *(void *)&long long v292 = MEMORY[0x1E4FBC870];
      uint64_t v151 = specialized Array.count.getter(v149);
      if (v151)
      {
        uint64_t v82 = v151;
        if (v151 < 1) {
          goto LABEL_317;
        }
        uint64_t v152 = v103;
        uint64_t v153 = v149 + 32;
        swift_bridgeObjectRetain_n();
        do
        {
          outlined init with copy of ResultColumn(v153, (uint64_t)&v309);
          uint64_t v104 = v316;
          if (v316)
          {
            unint64_t v154 = v315;
            if (specialized Array.count.getter(v313))
            {
              swift_bridgeObjectRetain();
              specialized Set._Variant.insert(_:)((unint64_t *)&v298, v154, (unint64_t)v104);
              swift_bridgeObjectRelease();
            }
          }
          outlined destroy of ResultColumn((uint64_t)&v309);
          v153 += 128;
          --v82;
        }
        while (v82);
        swift_bridgeObjectRelease_n();
        uint64_t v41 = (uint64_t)v317;
        uint64_t v103 = v152;
        unint64_t v150 = (uint64_t *)v292;
      }
      unint64_t v105 = (uint64_t *)v307;
      uint64_t v155 = specialized Array.count.getter(v307);
      uint64_t v88 = v267;
      uint64_t v266 = (char *)v155;
      if (v155)
      {
        uint64_t v156 = v105 + 4;
        uint64_t v263 = v304;
        unint64_t v278 = v150 + 7;
        swift_bridgeObjectRetain();
        unint64_t v157 = 0;
        unint64_t v274 = v150;
        uint64_t v270 = v105;
        uint64_t v264 = v105 + 4;
        while (v105[2] > v157)
        {
          uint64_t v268 = (char *)(v157 + 1);
          outlined init with copy of AggregationFunction((uint64_t)&v156[25 * v157], (uint64_t)&v309);
          uint64_t v305 = (char *)specialized static Array._allocateUninitialized(_:)(0);
          outlined init with copy of AggregationFunction.AggregationType((uint64_t)&v309, (uint64_t)&v298);
          switch(v304[96])
          {
            case 2:
              long long v294 = v300;
              long long v295 = v301;
              long long v296 = v302;
              long long v297 = v303;
              long long v292 = v298;
              long long v293 = v299;
              outlined init with take of SQLExpression?((uint64_t)v263, (uint64_t)v291, &demangling cache variable for type metadata for SQLExpression?);
              outlined init with copy of SQLExpression((uint64_t)&v292, (uint64_t)&v285);
              specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
              uint64_t v82 = (uint64_t)v305;
              unint64_t v188 = *((void *)v305 + 2);
              unint64_t v187 = *((void *)v305 + 3);
              if (v188 >= v187 >> 1)
              {
                uint64_t v82 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v187 > 1), v188 + 1, 1, v305);
                uint64_t v305 = (char *)v82;
              }
              *(void *)(v82 + 16) = v188 + 1;
              uint64_t v189 = (_OWORD *)(v82 + 96 * v188);
              long long v190 = v286;
              v189[2] = v285;
              v189[3] = v190;
              long long v191 = v287;
              long long v192 = v288;
              long long v193 = v290;
              v189[6] = v289;
              v189[7] = v193;
              v189[4] = v191;
              v189[5] = v192;
              outlined init with copy of PgQuery_Alias?((uint64_t)v291, (uint64_t)&v279, &demangling cache variable for type metadata for SQLExpression?);
              if (!*((void *)&v280 + 1))
              {
                unint64_t v105 = &demangling cache variable for type metadata for SQLExpression?;
                outlined destroy of AnyValue?((uint64_t)v291, &demangling cache variable for type metadata for SQLExpression?);
                outlined destroy of SQLExpression((uint64_t)&v292);
                outlined destroy of AnyValue?((uint64_t)&v279, &demangling cache variable for type metadata for SQLExpression?);
                goto LABEL_182;
              }
              long long v287 = v281;
              long long v288 = v282;
              long long v289 = v283;
              long long v290 = v284;
              long long v285 = v279;
              long long v286 = v280;
              outlined init with copy of SQLExpression((uint64_t)&v285, (uint64_t)&v279);
              specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
              uint64_t v82 = (uint64_t)v305;
              unint64_t v195 = *((void *)v305 + 2);
              unint64_t v194 = *((void *)v305 + 3);
              unint64_t v105 = (uint64_t *)(v195 + 1);
              if (v195 >= v194 >> 1)
              {
                uint64_t v82 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v194 > 1), v195 + 1, 1, v305);
                uint64_t v305 = (char *)v82;
              }
              *(void *)(v82 + 16) = v105;
              uint64_t v196 = (_OWORD *)(v82 + 96 * v195);
              long long v197 = v280;
              v196[2] = v279;
              v196[3] = v197;
              long long v198 = v281;
              long long v199 = v282;
              long long v200 = v284;
              v196[6] = v283;
              v196[7] = v200;
              v196[4] = v198;
              v196[5] = v199;
              outlined destroy of SQLExpression((uint64_t)&v285);
              outlined destroy of AnyValue?((uint64_t)v291, &demangling cache variable for type metadata for SQLExpression?);
              goto LABEL_181;
            case 7:
              uint64_t v201 = specialized static Array._allocateUninitialized(_:)(0);
              unint64_t v105 = (uint64_t *)&v305;
              specialized Array.append<A>(contentsOf:)(v201);
              uint64_t v82 = (uint64_t)v305;
              break;
            default:
              long long v294 = v300;
              long long v295 = v301;
              long long v296 = v302;
              long long v297 = v303;
              long long v292 = v298;
              long long v293 = v299;
              outlined init with copy of SQLExpression((uint64_t)&v292, (uint64_t)v291);
              specialized Array._makeUniqueAndReserveCapacityIfNotUnique()();
              uint64_t v82 = (uint64_t)v305;
              unint64_t v159 = *((void *)v305 + 2);
              unint64_t v158 = *((void *)v305 + 3);
              unint64_t v105 = (uint64_t *)(v159 + 1);
              if (v159 >= v158 >> 1)
              {
                uint64_t v82 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v158 > 1), v159 + 1, 1, v305);
                uint64_t v305 = (char *)v82;
              }
              *(void *)(v82 + 16) = v105;
              uint64_t v160 = (_OWORD *)(v82 + 96 * v159);
              long long v161 = v291[1];
              v160[2] = v291[0];
              v160[3] = v161;
              long long v162 = v291[2];
              long long v163 = v291[3];
              long long v164 = v291[5];
              v160[6] = v291[4];
              v160[7] = v164;
              v160[4] = v162;
              v160[5] = v163;
LABEL_181:
              outlined destroy of SQLExpression((uint64_t)&v292);
LABEL_182:
              uint64_t v88 = v267;
              break;
          }
          uint64_t v269 = (uint64_t *)specialized Array.count.getter(v82);
          if (v269)
          {
            uint64_t v165 = v82 + 32;
            swift_bridgeObjectRetain();
            unint64_t v166 = 0;
            uint64_t v265 = v82 + 32;
            while (*(void *)(v82 + 16) > v166)
            {
              uint64_t v272 = v166;
              outlined init with copy of SQLExpression(v165 + 96 * v166, (uint64_t)&v298);
              uint64_t v167 = *((void *)&v302 + 1);
              uint64_t v168 = specialized Array.count.getter(*((void *)&v302 + 1));
              if (v168)
              {
                uint64_t v104 = (void *)v168;
                uint64_t v261 = v103;
                uint64_t v275 = (char *)(v167 + 32);
                swift_bridgeObjectRetain_n();
                uint64_t v169 = 0;
                uint64_t v276 = v167;
                uint64_t Node = (uint64_t)v104;
                while (1)
                {
                  uint64_t v103 = v169 + 1;
                  if (__OFADD__(v169, 1)) {
                    break;
                  }
                  if (v150[2])
                  {
                    uint64_t v83 = v82;
                    uint64_t v170 = &v275[24 * v169];
                    uint64_t v171 = *(void *)v170;
                    uint64_t v172 = *((void *)v170 + 1);
                    Hasher.init(_seed:)();
                    swift_bridgeObjectRetain_n();
                    String.hash(into:)();
                    Swift::Int v173 = Hasher._finalize()();
                    uint64_t v174 = -1 << *((unsigned char *)v150 + 32);
                    unint64_t v175 = v173 & ~v174;
                    if ((*(void *)((char *)v278 + ((v175 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v175))
                    {
                      uint64_t v176 = v150[6];
                      uint64_t v177 = (void *)(v176 + 16 * v175);
                      BOOL v178 = *v177 == v171 && v177[1] == v172;
                      if (v178 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
                      {
LABEL_225:
                        swift_bridgeObjectRelease_n();
                        swift_bridgeObjectRelease();
                        swift_bridgeObjectRelease_n();
                        swift_bridgeObjectRelease();
                        swift_bridgeObjectRelease_n();
                        long long v202 = v303;
                        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
                        swift_allocError();
                        *(_OWORD *)uint64_t v203 = v202;
                        *(void *)(v203 + 16) = 0;
                        *(void *)(v203 + 24) = 0;
                        *(unsigned char *)(v203 + 32) = 3;
                        swift_bridgeObjectRetain();
                        swift_willThrow();
                        outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
                        outlined destroy of SQLExpression((uint64_t)&v298);
                        outlined destroy of AggregationFunction((uint64_t)&v309);
                        outlined destroy of SQLExpression((uint64_t)v306);
LABEL_283:
                        outlined destroy of PgQuery_ParseResult((uint64_t)v317, type metadata accessor for PlanResources);
                        int v94 = 1;
                        int v95 = 1;
                        uint64_t v83 = v277;
LABEL_79:
                        outlined destroy of FromClause(v83);
                        uint64_t result = outlined destroy of AnyValue?(v271, &demangling cache variable for type metadata for SQLExpression?);
                        if (v94)
                        {
                          uint64_t result = swift_bridgeObjectRelease();
                          if ((v95 & 1) == 0) {
                            goto LABEL_84;
                          }
LABEL_83:
                          uint64_t result = outlined destroy of AnyValue?(v83 + 208, &demangling cache variable for type metadata for SQLExpression?);
                        }
                        else if (v95)
                        {
                          goto LABEL_83;
                        }
LABEL_84:
                        if (v260) {
                          return result;
                        }
                        return swift_bridgeObjectRelease();
                      }
                      uint64_t v179 = ~v174;
                      unint64_t v180 = (v175 + 1) & ~v174;
                      if ((*(void *)((char *)v278 + ((v180 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v180))
                      {
                        uint64_t v181 = (void *)(v176 + 16 * v180);
                        BOOL v182 = *v181 == v171 && v181[1] == v172;
                        if (v182 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
                          goto LABEL_225;
                        }
                        for (unint64_t i = v180 + 1; ; unint64_t i = v184 + 1)
                        {
                          unint64_t v184 = i & v179;
                          if (((*(void *)((char *)v278 + (((i & v179) >> 3) & 0xFFFFFFFFFFFFFF8)) >> (i & v179)) & 1) == 0) {
                            break;
                          }
                          uint64_t v185 = (void *)(v176 + 16 * v184);
                          BOOL v186 = *v185 == v171 && v185[1] == v172;
                          if (v186 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
                            goto LABEL_225;
                          }
                        }
                      }
                    }
                    swift_bridgeObjectRelease_n();
                    uint64_t v41 = (uint64_t)v317;
                    uint64_t v88 = v267;
                    uint64_t v104 = (void *)Node;
                    unint64_t v150 = v274;
                    uint64_t v82 = v83;
                  }
                  uint64_t v169 = v103;
                  if ((void *)v103 == v104)
                  {
                    swift_bridgeObjectRelease_n();
                    uint64_t v103 = v261;
                    goto LABEL_213;
                  }
                }
                __break(1u);
LABEL_309:
                __break(1u);
                goto LABEL_310;
              }
LABEL_213:
              unint64_t v105 = (uint64_t *)(v272 + 1);
              outlined destroy of SQLExpression((uint64_t)&v298);
              unint64_t v166 = (unint64_t)v105;
              uint64_t v83 = v277;
              uint64_t v165 = v265;
              if (v105 == v269)
              {
                swift_bridgeObjectRelease();
                goto LABEL_215;
              }
            }
            goto LABEL_312;
          }
LABEL_215:
          swift_bridgeObjectRelease();
          outlined destroy of AggregationFunction((uint64_t)&v309);
          unint64_t v157 = (unint64_t)v268;
          unint64_t v105 = v270;
          uint64_t v156 = v264;
          if (v268 == v266)
          {
            swift_bridgeObjectRelease();
            goto LABEL_232;
          }
        }
LABEL_313:
        __break(1u);
        goto LABEL_314;
      }
LABEL_232:
      swift_bridgeObjectRelease();
      outlined destroy of SQLExpression((uint64_t)v306);
    }
    else
    {
      outlined destroy of AnyValue?((uint64_t)&v309, &demangling cache variable for type metadata for SQLExpression?);
    }
    uint64_t v104 = *(void **)v83;
    uint64_t v82 = MEMORY[0x1E4FBC870];
    *(void *)&long long v298 = MEMORY[0x1E4FBC870];
    uint64_t v205 = specialized Array.count.getter(v104);
    if (!v205)
    {
      uint64_t v239 = v103;
      goto LABEL_285;
    }
    uint64_t v264 = (uint64_t *)v205;
    uint64_t v268 = (char *)(v104 + 4);
    swift_bridgeObjectRetain_n();
    uint64_t v206 = 0;
    uint64_t Node = (uint64_t)v104;
LABEL_235:
    if (__OFADD__(v206, 1))
    {
LABEL_314:
      __break(1u);
LABEL_315:
      swift_once();
LABEL_158:
      *(void *)((char *)v104 + v88) = static PgQuery_Node._StorageClass.defaultInstance;
      swift_retain();
      outlined destroy of AnyValue?((uint64_t)v270, &demangling cache variable for type metadata for PgQuery_Node?);
      uint64_t v88 = v267;
LABEL_160:
      outlined init with copy of PgQuery_ScanResult(v41 + *((int *)v263 + 5), v82, type metadata accessor for SQLTokenInformation);
      SQLExpression.init(expressionNode:schemas:tokenInformation:)((uint64_t)v104, (uint64_t)v105, v82, (uint64_t)&v309);
      if (v103)
      {
        outlined destroy of PgQuery_ParseResult(v88, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
        int v95 = 0;
        int v94 = 1;
        goto LABEL_79;
      }
      outlined init with take of SQLExpression?((uint64_t)&v309, v83 + 208, &demangling cache variable for type metadata for SQLExpression?);
      continue;
    }
    break;
  }
  uint64_t v207 = &v268[24 * (void)v206];
  uint64_t v208 = (uint64_t *)*((void *)v207 + 1);
  uint64_t v209 = *((void *)v207 + 2);
  uint64_t v265 = (uint64_t)(v206 + 1);
  uint64_t v266 = v206 + 1;
  uint64_t v210 = *(void *)(v209 + 64);
  uint64_t v269 = v208;
  uint64_t v270 = (uint64_t *)(v209 + 64);
  uint64_t v211 = 1 << *(unsigned char *)(v209 + 32);
  if (v211 < 64) {
    uint64_t v212 = ~(-1 << v211);
  }
  else {
    uint64_t v212 = -1;
  }
  unint64_t v213 = v212 & v210;
  uint64_t v272 = (unint64_t)(v211 + 63) >> 6;
  swift_bridgeObjectRetain();
  unint64_t v274 = (uint64_t *)v209;
  swift_bridgeObjectRetain_n();
  uint64_t v214 = 0;
  while (2)
  {
    if (v213)
    {
      uint64_t v261 = v103;
      unint64_t v216 = __clz(__rbit64(v213));
      uint64_t v217 = (v213 - 1) & v213;
      uint64_t v276 = v214;
      unint64_t v218 = v216 | (v214 << 6);
LABEL_255:
      uint64_t v275 = (char *)v217;
      uint64_t v222 = v274[6] + 16 * v218;
      uint64_t v223 = *(void *)(v222 + 8);
      uint64_t v82 = v298;
      unint64_t v278 = *(void **)v222;
      Swift::String v224 = String.lowercased()();
      if (*(void *)(v82 + 16))
      {
        Hasher.init(_seed:)();
        swift_bridgeObjectRetain();
        String.hash(into:)();
        Swift::Int v225 = Hasher._finalize()();
        uint64_t v226 = -1 << *(unsigned char *)(v82 + 32);
        unint64_t v227 = v225 & ~v226;
        uint64_t v228 = v82 + 56;
        if ((*(void *)(v82 + 56 + ((v227 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v227))
        {
          uint64_t v229 = *(void *)(v82 + 48);
          uint64_t v230 = v229 + 16 * v227;
          BOOL v231 = *(void *)v230 == v224._countAndFlagsBits && *(void **)(v230 + 8) == v224._object;
          if (v231 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
          {
LABEL_282:
            swift_bridgeObjectRelease();
            lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
            swift_allocError();
            *(void *)uint64_t v240 = v278;
            *(void *)(v240 + 8) = v223;
            *(void *)(v240 + 16) = 0xD000000000000027;
            *(void *)(v240 + 24) = 0x800000018EBF7D80;
            *(unsigned char *)(v240 + 32) = 7;
            swift_willThrow();
            swift_release();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
            outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
            swift_bridgeObjectRelease();
            goto LABEL_283;
          }
          uint64_t v232 = ~v226;
          unint64_t v233 = (v227 + 1) & v232;
          if ((*(void *)(v228 + ((v233 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v233))
          {
            uint64_t v234 = v229 + 16 * v233;
            BOOL v235 = *(void *)v234 == v224._countAndFlagsBits && *(void **)(v234 + 8) == v224._object;
            if (v235 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
              goto LABEL_282;
            }
            for (uint64_t j = v233 + 1; ; uint64_t j = v82 + 1)
            {
              uint64_t v82 = j & v232;
              if (((*(void *)(v228 + (((j & (unint64_t)v232) >> 3) & 0xFFFFFFFFFFFFFF8)) >> (j & v232)) & 1) == 0) {
                break;
              }
              uint64_t v237 = v229 + 16 * v82;
              BOOL v238 = *(void *)v237 == v224._countAndFlagsBits && *(void **)(v237 + 8) == v224._object;
              if (v238 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
                goto LABEL_282;
              }
            }
          }
        }
      }
      else
      {
        swift_bridgeObjectRetain();
      }
      swift_bridgeObjectRelease();
      Swift::String v215 = String.lowercased()();
      swift_bridgeObjectRelease();
      specialized Set._Variant.insert(_:)((unint64_t *)&v309, v215._countAndFlagsBits, (unint64_t)v215._object);
      swift_bridgeObjectRelease();
      uint64_t v214 = v276;
      uint64_t v83 = v277;
      uint64_t v41 = (uint64_t)v317;
      uint64_t v103 = v261;
      uint64_t v104 = (void *)Node;
      unint64_t v213 = (unint64_t)v275;
      continue;
    }
    break;
  }
  BOOL v55 = __OFADD__(v214, 1);
  uint64_t v219 = v214 + 1;
  uint64_t v88 = v267;
  if (v55) {
    goto LABEL_309;
  }
  if (v219 < v272)
  {
    unint64_t v220 = v270[v219];
    if (!v220)
    {
      uint64_t v221 = v219 + 1;
      if (v219 + 1 >= v272) {
        goto LABEL_280;
      }
      unint64_t v220 = v270[v221];
      if (!v220)
      {
        uint64_t v221 = v219 + 2;
        if (v219 + 2 >= v272) {
          goto LABEL_280;
        }
        unint64_t v220 = v270[v221];
        if (!v220)
        {
          uint64_t v221 = v219 + 3;
          if (v219 + 3 >= v272) {
            goto LABEL_280;
          }
          unint64_t v220 = v270[v221];
          if (!v220)
          {
            while (1)
            {
              uint64_t v219 = v221 + 1;
              if (__OFADD__(v221, 1)) {
                break;
              }
              if (v219 >= v272) {
                goto LABEL_280;
              }
              unint64_t v220 = v270[v219];
              ++v221;
              if (v220) {
                goto LABEL_254;
              }
            }
            __break(1u);
LABEL_317:
            __break(1u);
LABEL_318:
            __break(1u);
LABEL_319:
            __break(1u);
LABEL_320:
            __break(1u);
LABEL_321:
            __break(1u);
LABEL_322:
            __break(1u);
LABEL_323:
            __break(1u);
LABEL_324:
            KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)();
            __break(1u);
            JUMPOUT(0x18EA63B74);
          }
        }
      }
      uint64_t v219 = v221;
    }
LABEL_254:
    uint64_t v261 = v103;
    uint64_t v217 = (v220 - 1) & v220;
    uint64_t v276 = v219;
    unint64_t v218 = __clz(__rbit64(v220)) + (v219 << 6);
    goto LABEL_255;
  }
LABEL_280:
  swift_bridgeObjectRelease();
  unint64_t v105 = v274;
  swift_release();
  swift_bridgeObjectRelease();
  uint64_t v206 = v266;
  if ((uint64_t *)v265 != v264) {
    goto LABEL_235;
  }
  uint64_t v239 = v103;
  swift_bridgeObjectRelease_n();
  uint64_t v82 = v298;
LABEL_285:
  uint64_t v241 = *(void *)(v83 + 304);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  uint64_t v242 = specialized Sequence.reduce<A>(into:_:)(MEMORY[0x1E4FBC870], v241, v82);
  if (v239)
  {
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult(v88, type metadata accessor for PgQuery_SelectStmt);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult(v41, type metadata accessor for PlanResources);
    int v94 = 1;
    int v95 = 1;
    goto LABEL_79;
  }
  uint64_t v243 = (void *)v242;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  specialized Sequence.forEach(_:)(v241, (uint64_t)v243);
  uint64_t v261 = 0;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v244 = specialized Array.count.getter(v241);
  if (v244)
  {
    int64_t v245 = v244;
    unint64_t v278 = v243;
    *(void *)&long long v298 = MEMORY[0x1E4FBC860];
    swift_bridgeObjectRetain();
    specialized ContiguousArray.reserveCapacity(_:)(v245);
    if (v245 < 0) {
      goto LABEL_320;
    }
    uint64_t v246 = v241 + 32;
    do
    {
      outlined init with copy of ResultColumn(v246, (uint64_t)&v309);
      uint64_t v247 = v313;
      swift_bridgeObjectRetain();
      outlined destroy of ResultColumn((uint64_t)&v309);
      specialized ContiguousArray._makeUniqueAndReserveCapacityIfNotUnique()();
      uint64_t v248 = *(void **)(v298 + 16);
      specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(v248);
      uint64_t v249 = v298;
      *(void *)(v298 + 16) = (char *)v248 + 1;
      *(void *)(v249 + 8 * (void)v248 + 32) = v247;
      v246 += 128;
      --v245;
    }
    while (v245);
    swift_bridgeObjectRelease();
    uint64_t v83 = v277;
    uint64_t v243 = v278;
  }
  else
  {
    uint64_t v249 = specialized static Array._allocateUninitialized(_:)(0);
  }
  *(void *)&long long v309 = specialized static Array._allocateUninitialized(_:)(0);
  uint64_t v250 = specialized Array.count.getter(v249);
  uint64_t v251 = (uint64_t)v317;
  if (v250)
  {
    uint64_t v252 = v250;
    if (v250 < 1) {
      goto LABEL_321;
    }
    swift_bridgeObjectRetain();
    for (uint64_t k = 0; k != v252; ++k)
    {
      swift_bridgeObjectRetain();
      specialized Array.append<A>(contentsOf:)();
    }
    swift_bridgeObjectRelease_n();
  }
  else
  {
    swift_bridgeObjectRelease();
  }
  uint64_t v254 = v309;
  uint64_t v255 = v261;
  if (*(void *)(v83 + 232)) {
    swift_bridgeObjectRetain();
  }
  else {
    specialized static Array._allocateUninitialized(_:)(0);
  }
  *(void *)&long long v309 = v254;
  specialized Array.append<A>(contentsOf:)();
  uint64_t v256 = v309;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  specialized Sequence.forEach(_:)(v256, v82, (uint64_t)v243);
  if (v255)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    outlined destroy of PgQuery_ParseResult(v251, type metadata accessor for PlanResources);
    swift_bridgeObjectRelease();
    goto LABEL_227;
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_ParseResult(v267, type metadata accessor for PgQuery_SelectStmt);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_ParseResult(v251, type metadata accessor for PlanResources);
  return swift_bridgeObjectRelease();
}

uint64_t closure #1 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v11 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1F4188790](v11 - 8);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  MEMORY[0x1F4188790](Node - 8);
  uint64_t v16 = (uint64_t *)((char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
  outlined init with copy of PgQuery_ScanResult(a1, (uint64_t)v16, type metadata accessor for PgQuery_Node);
  uint64_t v17 = type metadata accessor for PlanResources(0);
  outlined init with copy of PgQuery_ScanResult(a3 + *(int *)(v17 + 20), (uint64_t)v13, type metadata accessor for SQLTokenInformation);
  swift_bridgeObjectRetain();
  uint64_t result = ResultColumn.init(node:schemas:tokenInformation:)(v16, a2, (uint64_t)v13, a5);
  if (v5) {
    *a4 = v5;
  }
  return result;
}

uint64_t closure #3 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v11 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1F4188790](v11 - 8);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  MEMORY[0x1F4188790](Node - 8);
  uint64_t v16 = (char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  outlined init with copy of PgQuery_ScanResult(a1, (uint64_t)v16, type metadata accessor for PgQuery_Node);
  uint64_t v17 = type metadata accessor for PlanResources(0);
  outlined init with copy of PgQuery_ScanResult(a3 + *(int *)(v17 + 20), (uint64_t)v13, type metadata accessor for SQLTokenInformation);
  swift_bridgeObjectRetain();
  uint64_t result = SQLExpression.init(expressionNode:schemas:tokenInformation:)((uint64_t)v16, a2, (uint64_t)v13, a5);
  if (v5) {
    *a4 = v5;
  }
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance SelectCore.CodingKeys()
{
  uint64_t result = 1836020326;
  switch(*v0)
  {
    case 1:
      uint64_t result = 0x6572656877;
      break;
    case 2:
      uint64_t result = 0x794270756F7267;
      break;
    case 3:
      uint64_t result = 0x676E69766168;
      break;
    case 4:
      uint64_t result = 0x7463656C6573;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance SelectCore.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized SelectCore.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance SelectCore.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance SelectCore.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t SelectCore.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<SelectCore.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char *)&v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  LOBYTE(v11) = 0;
  lazy protocol witness table accessor for type FromClause and conformance FromClause();
  KeyedEncodingContainer.encode<A>(_:forKey:)();
  if (!v2)
  {
    LOBYTE(v11) = 1;
    lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression();
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    uint64_t v11 = *(void *)(v3 + 200);
    HIBYTE(v10) = 2;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [SQLExpression]);
    lazy protocol witness table accessor for type [Schema] and conformance <A> [A](&lazy protocol witness table cache variable for type [SQLExpression] and conformance <A> [A], &demangling cache variable for type metadata for [SQLExpression], (void (*)(void))lazy protocol witness table accessor for type SQLExpression and conformance SQLExpression);
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    LOBYTE(v11) = 3;
    KeyedEncodingContainer.encodeIfPresent<A>(_:forKey:)();
    uint64_t v11 = *(void *)(v3 + 304);
    HIBYTE(v10) = 4;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [ResultColumn]);
    lazy protocol witness table accessor for type [Schema] and conformance <A> [A](&lazy protocol witness table cache variable for type [ResultColumn] and conformance <A> [A], &demangling cache variable for type metadata for [ResultColumn], (void (*)(void))lazy protocol witness table accessor for type ResultColumn and conformance ResultColumn);
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SelectCore(void *a1)
{
  return SelectCore.encode(to:)(a1);
}

void *MaterializedView.init(create:resources:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, Swift::String *a3@<X8>)
{
  uint64_t v67 = a2;
  uint64_t v57 = a3;
  uint64_t v61 = type metadata accessor for PlanResources(0);
  MEMORY[0x1F4188790](v61);
  uint64_t v56 = (uint64_t)&v51 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  MEMORY[0x1F4188790](v5 - 8);
  unint64_t v65 = (char *)&v51 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t SelectStmt = type metadata accessor for PgQuery_SelectStmt(0);
  MEMORY[0x1F4188790](SelectStmt);
  BOOL v55 = (char *)&v51 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1F4188790](v8 - 8);
  uint64_t v58 = (uint64_t)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v54 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node);
  unint64_t v64 = (char *)&v51 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_RangeVar?);
  MEMORY[0x1F4188790](v11 - 8);
  uint64_t v63 = (uint64_t)&v51 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t RangeVar = type metadata accessor for PgQuery_RangeVar(0);
  uint64_t v60 = *(void *)(RangeVar - 8);
  MEMORY[0x1F4188790](RangeVar);
  uint64_t v14 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_IntoClause?);
  MEMORY[0x1F4188790](v15 - 8);
  uint64_t v17 = (char *)&v51 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t IntoClause = type metadata accessor for PgQuery_IntoClause(0);
  uint64_t v19 = *(void *)(IntoClause - 8);
  MEMORY[0x1F4188790](IntoClause);
  uint64_t v21 = (char *)&v51 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v22 = type metadata accessor for SQLTokenInformation(0);
  MEMORY[0x1F4188790](v22 - 8);
  uint64_t v24 = (char *)&v51 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v25 = a1;
  uint64_t v53 = *(int *)(type metadata accessor for PgQuery_CreateTableAsStmt(0) + 20);
  uint64_t v26 = *(void *)(a1 + v53);
  if (destructiveProjectEnumData for StorableValue(*(void *)(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind), *(unsigned __int8 *)(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__relkind+ 8)) != 24)
  {
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v29 = 0xD000000000000039;
    *(void *)(v29 + 8) = 0x800000018EBF7D20;
    *(void *)(v29 + 16) = 0;
    *(void *)(v29 + 24) = 0;
    *(unsigned char *)(v29 + 32) = 1;
    swift_willThrow();
    outlined destroy of PgQuery_ParseResult(v67, type metadata accessor for PlanResources);
    return (void *)outlined destroy of PgQuery_ParseResult(v25, type metadata accessor for PgQuery_CreateTableAsStmt);
  }
  uint64_t v51 = v25;
  outlined init with copy of PgQuery_ScanResult(v67 + *(int *)(v61 + 20), (uint64_t)v24, type metadata accessor for SQLTokenInformation);
  outlined init with copy of PgQuery_Alias?(v26+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__into, (uint64_t)v17, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v17, 1, IntoClause) == 1)
  {
    UnknownStorage.init()();
    uint64_t v27 = *(int *)(IntoClause + 20);
    uint64_t v28 = (uint64_t)v64;
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)&v21[v27] = static PgQuery_IntoClause._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)v17, &demangling cache variable for type metadata for PgQuery_IntoClause?);
  }
  else
  {
    outlined init with take of PgQuery_ParseResult((uint64_t)v17, (uint64_t)v21, type metadata accessor for PgQuery_IntoClause);
    uint64_t v28 = (uint64_t)v64;
  }
  uint64_t v31 = *(void *)&v21[*(int *)(IntoClause + 20)]
      + OBJC_IVAR____TtCV14BiomeSQLParser18PgQuery_IntoClauseP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__rel;
  uint64_t v32 = v63;
  outlined init with copy of PgQuery_Alias?(v31, v63, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  uint64_t v33 = RangeVar;
  int v34 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v60 + 48))(v32, 1, RangeVar);
  uint64_t v35 = v51;
  if (v34 == 1)
  {
    *(void *)uint64_t v14 = 0;
    *((void *)v14 + 1) = 0xE000000000000000;
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = 0xE000000000000000;
    *((void *)v14 + 4) = 0;
    *((void *)v14 + 5) = 0xE000000000000000;
    v14[48] = 0;
    *((void *)v14 + 7) = 0;
    *((void *)v14 + 8) = 0xE000000000000000;
    *((_DWORD *)v14 + 18) = 0;
    UnknownStorage.init()();
    unint64_t v36 = &v14[*(int *)(v33 + 44)];
    uint64_t Alias = type metadata accessor for PgQuery_Alias(0);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(Alias - 8) + 56))(v36, 1, 1, Alias);
    outlined destroy of AnyValue?(v32, &demangling cache variable for type metadata for PgQuery_RangeVar?);
  }
  else
  {
    outlined init with take of PgQuery_ParseResult(v32, (uint64_t)v14, type metadata accessor for PgQuery_RangeVar);
  }
  uint64_t v38 = (uint64_t)v65;
  outlined destroy of PgQuery_ParseResult((uint64_t)v21, type metadata accessor for PgQuery_IntoClause);
  Swift::Int32 v39 = *((_DWORD *)v14 + 18);
  outlined destroy of PgQuery_ParseResult((uint64_t)v14, type metadata accessor for PgQuery_RangeVar);
  Swift::String v40 = SQLTokenInformation.tokenName(location:)(v39);
  if (v41)
  {
    outlined destroy of PgQuery_ParseResult(v67, type metadata accessor for PlanResources);
    outlined destroy of PgQuery_ParseResult(v35, type metadata accessor for PgQuery_CreateTableAsStmt);
    return (void *)outlined destroy of PgQuery_ParseResult((uint64_t)v24, type metadata accessor for SQLTokenInformation);
  }
  outlined destroy of PgQuery_ParseResult((uint64_t)v24, type metadata accessor for SQLTokenInformation);
  uint64_t v42 = v57;
  uint64_t v43 = v58;
  *uint64_t v57 = v40;
  outlined init with copy of PgQuery_Alias?(*(void *)(v35 + v53)+ OBJC_IVAR____TtCV14BiomeSQLParser25PgQuery_CreateTableAsStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__query, v43, &demangling cache variable for type metadata for PgQuery_Node?);
  uint64_t v44 = Node;
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v54 + 48))(v43, 1, Node) == 1)
  {
    UnknownStorage.init()();
    uint64_t v45 = *(int *)(v44 + 20);
    uint64_t v46 = (uint64_t)v55;
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)(v28 + v45) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?(v58, &demangling cache variable for type metadata for PgQuery_Node?);
    uint64_t v44 = Node;
  }
  else
  {
    outlined init with take of PgQuery_ParseResult(v43, v28, type metadata accessor for PgQuery_Node);
    uint64_t v46 = (uint64_t)v55;
  }
  outlined init with copy of PgQuery_Alias?(*(void *)(v28 + *(int *)(v44 + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v38, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v47 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v47 - 8) + 48))(v38, 1, v47) == 1)
  {
    outlined destroy of AnyValue?(v38, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
LABEL_23:
    UnknownStorage.init()();
    uint64_t v48 = *(int *)(SelectStmt + 20);
    if (one-time initialization token for defaultInstance != -1) {
      swift_once();
    }
    *(void *)(v46 + v48) = static PgQuery_SelectStmt._StorageClass.defaultInstance;
    swift_retain();
    goto LABEL_26;
  }
  if (swift_getEnumCaseMultiPayload() != 56)
  {
    outlined destroy of PgQuery_ParseResult(v38, type metadata accessor for PgQuery_Node.OneOf_Node);
    goto LABEL_23;
  }
  outlined init with take of PgQuery_ParseResult(v38, v46, type metadata accessor for PgQuery_SelectStmt);
LABEL_26:
  uint64_t v49 = v67;
  outlined destroy of PgQuery_ParseResult(v28, type metadata accessor for PgQuery_Node);
  uint64_t v50 = v56;
  outlined init with copy of PgQuery_ScanResult(v49, v56, type metadata accessor for PlanResources);
  SelectCore.init(select:resources:)(v46, v50, (uint64_t)v66);
  outlined destroy of PgQuery_ParseResult(v49, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_ParseResult(v35, type metadata accessor for PgQuery_CreateTableAsStmt);
  return memcpy(&v42[1], v66, 0x138uLL);
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance MaterializedView.CodingKeys()
{
  if (*v0) {
    return 0x7463656C6573;
  }
  else {
    return 1701667182;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance MaterializedView.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized MaterializedView.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance MaterializedView.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance MaterializedView.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t MaterializedView.encode(to:)(void *a1)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<MaterializedView.CodingKeys>);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = &v8[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  v8[15] = 0;
  KeyedEncodingContainer.encode(_:forKey:)();
  if (!v1)
  {
    v8[14] = 1;
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
  }
  return (*(uint64_t (**)(unsigned char *, uint64_t))(v4 + 8))(v6, v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance MaterializedView(void *a1)
{
  return MaterializedView.encode(to:)(a1);
}

uint64_t LogicalPlan.plan.getter@<X0>(uint64_t a1@<X8>)
{
  return outlined init with copy of LogicalPlanType(v1, a1);
}

uint64_t LogicalPlan.sql.getter()
{
  uint64_t v1 = *(void *)(v0 + 336);
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t LogicalPlan.documentation.getter()
{
  uint64_t v1 = *(void *)(v0 + 352);
  swift_bridgeObjectRetain();
  return v1;
}

unint64_t protocol witness for CodingKey.stringValue.getter in conformance LogicalPlan.CodingKeys()
{
  unint64_t result = 7106931;
  switch(*v0)
  {
    case 1:
      unint64_t result = 0x746E656D75636F64;
      break;
    case 2:
      unint64_t result = 0xD000000000000010;
      break;
    case 3:
      unint64_t result = 0x6F437463656C6573;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlan.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized LogicalPlan.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance LogicalPlan.CodingKeys(unsigned char *a1@<X8>)
{
  *a1 = 4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlan.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlan.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t LogicalPlan.encode(to:)(void *a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlan.CodingKeys>);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v8 = (char *)v10 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of LogicalPlanType(v3, (uint64_t)v11);
  if (v11[328] == 1)
  {
    memcpy(v10, v11, sizeof(v10));
    char v12 = 2;
    lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    outlined destroy of MaterializedView(v10);
    if (!v2) {
      goto LABEL_7;
    }
  }
  else
  {
    memcpy(v10, v11, 0x138uLL);
    char v12 = 3;
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    if (!v2)
    {
      outlined destroy of SelectCore(v10);
LABEL_7:
      v11[0] = 0;
      KeyedEncodingContainer.encode(_:forKey:)();
      v11[0] = 1;
      KeyedEncodingContainer.encodeIfPresent(_:forKey:)();
      return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
    }
    outlined destroy of SelectCore(v10);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance LogicalPlan(void *a1)
{
  return LogicalPlan.encode(to:)(a1);
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance LogicalPlanType.CodingKeys()
{
  if (*v0) {
    return 0xD000000000000010;
  }
  else {
    return 0x6F437463656C6573;
  }
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlanType.CodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = specialized LogicalPlanType.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.CodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.MaterializedViewCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.MaterializedViewCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance LogicalPlanType.MaterializedViewCodingKeys@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if (a1 == 12383 && a2 == 0xE200000000000000)
  {
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = 0;
  }
  else
  {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
    uint64_t result = swift_bridgeObjectRelease();
    char v7 = v5 ^ 1;
  }
  *a3 = v7 & 1;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance LogicalPlanType.SelectCoreCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance LogicalPlanType.SelectCoreCodingKeys(uint64_t a1)
{
  unint64_t v2 = lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t LogicalPlanType.encode(to:)(void *a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.MaterializedViewCodingKeys>);
  uint64_t v16 = *(void *)(v2 - 8);
  uint64_t v17 = v2;
  MEMORY[0x1F4188790](v2);
  uint64_t v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.SelectCoreCodingKeys>);
  uint64_t v15 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  char v7 = (char *)&v15 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for KeyedEncodingContainer<LogicalPlanType.CodingKeys>);
  uint64_t v8 = *(void *)(v18 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys();
  dispatch thunk of Encoder.container<A>(keyedBy:)();
  outlined init with copy of LogicalPlanType(v19, (uint64_t)v21);
  uint64_t v11 = (uint64_t (**)(char *, uint64_t))(v8 + 8);
  if (v21[328])
  {
    memcpy(v20, v21, sizeof(v20));
    char v22 = 1;
    lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys();
    uint64_t v12 = v18;
    KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
    lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView();
    uint64_t v13 = v17;
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v16 + 8))(v4, v13);
    outlined destroy of MaterializedView(v20);
  }
  else
  {
    memcpy(v20, v21, 0x138uLL);
    char v22 = 0;
    lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys();
    uint64_t v12 = v18;
    KeyedEncodingContainer.nestedContainer<A>(keyedBy:forKey:)();
    lazy protocol witness table accessor for type SelectCore and conformance SelectCore();
    KeyedEncodingContainer.encode<A>(_:forKey:)();
    (*(void (**)(char *, uint64_t))(v15 + 8))(v7, v5);
    outlined destroy of SelectCore(v20);
  }
  return (*v11)(v10, v12);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance LogicalPlanType(void *a1)
{
  return LogicalPlanType.encode(to:)(a1);
}

uint64_t SQLParseResult.plans(with:)(uint64_t *a1)
{
  uint64_t v3 = type metadata accessor for PlanResources(0);
  uint64_t v4 = v3 - 8;
  MEMORY[0x1F4188790](v3);
  uint64_t v6 = &v21[-((v5 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v7 = type metadata accessor for SQLTokenInformation(0);
  uint64_t v8 = v7 - 8;
  MEMORY[0x1F4188790](v7);
  uint64_t v10 = &v21[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v11 = *a1;
  uint64_t v12 = (int *)type metadata accessor for SQLParseResult(0);
  outlined init with copy of PgQuery_ScanResult(v1 + v12[5], (uint64_t)v10, type metadata accessor for PgQuery_ScanResult);
  uint64_t v13 = (uint64_t *)(v1 + v12[7]);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  uint64_t v16 = &v10[*(int *)(v8 + 28)];
  *uint64_t v16 = v14;
  v16[1] = v15;
  outlined init with copy of PgQuery_ScanResult((uint64_t)v10, (uint64_t)v6 + *(int *)(v4 + 28), type metadata accessor for SQLTokenInformation);
  *uint64_t v6 = v11;
  uint64_t v17 = *(void *)(v1 + 8);
  uint64_t v18 = *(void *)(v1 + v12[6]);
  char v22 = v10;
  uint64_t v23 = v6;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  uint64_t RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFs12Zip2SequenceVySay14BiomeSQLParser15PgQuery_RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n(v17, v18, (void (*)(void *__return_ptr, char *, uint64_t, uint64_t))partial apply for closure #1 in SQLParseResult.plans(with:), (uint64_t)v21);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  outlined destroy of PgQuery_ParseResult((uint64_t)v6, type metadata accessor for PlanResources);
  outlined destroy of PgQuery_ParseResult((uint64_t)v10, type metadata accessor for SQLTokenInformation);
  return RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n;
}

uint64_t closure #1 in SQLParseResult.plans(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v107 = a5;
  uint64_t v121 = a4;
  uint64_t v100 = a6;
  uint64_t v101 = a3;
  uint64_t v99 = a2;
  uint64_t SelectStmt = type metadata accessor for PgQuery_SelectStmt(0);
  uint64_t v8 = MEMORY[0x1F4188790](SelectStmt - 8);
  uint64_t v106 = (uint64_t)&v99 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  unint64_t v120 = (char *)&v99 - v10;
  uint64_t v11 = type metadata accessor for PlanResources(0);
  uint64_t v12 = MEMORY[0x1F4188790](v11 - 8);
  uint64_t v105 = (uint64_t)&v99 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v104 = (uint64_t)&v99 - v14;
  uint64_t TableAsStmt = type metadata accessor for PgQuery_CreateTableAsStmt(0);
  uint64_t v16 = MEMORY[0x1F4188790](TableAsStmt - 8);
  uint64_t v102 = (uint64_t)&v99 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  unint64_t v103 = (unint64_t)&v99 - v18;
  uint64_t v128 = type metadata accessor for CharacterSet();
  unint64_t v125 = *(void *)(v128 - 8);
  MEMORY[0x1F4188790](v128);
  uint64_t v127 = (char *)&v99 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ScanToken = type metadata accessor for PgQuery_ScanToken(0);
  unint64_t v126 = *(void *)(ScanToken - 8);
  uint64_t v21 = MEMORY[0x1F4188790](ScanToken - 8);
  char v118 = (char *)&v99 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  unint64_t v24 = (unint64_t)&v99 - v23;
  uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node?);
  MEMORY[0x1F4188790](v25 - 8);
  uint64_t v27 = (char *)&v99 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t Node = type metadata accessor for PgQuery_Node(0);
  uint64_t v29 = *(void *)(Node - 8);
  MEMORY[0x1F4188790](Node);
  uint64_t v31 = (uint64_t *)((char *)&v99 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v110 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
  uint64_t v32 = MEMORY[0x1F4188790](v110);
  uint64_t v109 = (uint64_t)&v99 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  uint64_t v112 = (uint64_t)&v99 - v35;
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  uint64_t v38 = (char *)&v99 - v37;
  MEMORY[0x1F4188790](v36);
  uint64_t v119 = (uint64_t)&v99 - v39;
  unint64_t v40 = *(void *)(a1 + *(int *)(type metadata accessor for PgQuery_RawStmt(0) + 20));
  outlined init with copy of PgQuery_Alias?(v40 + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmt, (uint64_t)v27, &demangling cache variable for type metadata for PgQuery_Node?);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v29 + 48))(v27, 1, Node) != 1)
  {
    outlined init with take of PgQuery_ParseResult((uint64_t)v27, (uint64_t)v31, type metadata accessor for PgQuery_Node);
    goto LABEL_5;
  }
  UnknownStorage.init()();
  uint64_t v41 = *(int *)(Node + 20);
  if (one-time initialization token for defaultInstance != -1) {
    goto LABEL_59;
  }
  while (1)
  {
    *(uint64_t *)((char *)v31 + v41) = static PgQuery_Node._StorageClass.defaultInstance;
    swift_retain();
    outlined destroy of AnyValue?((uint64_t)v27, &demangling cache variable for type metadata for PgQuery_Node?);
LABEL_5:
    outlined init with copy of PgQuery_Alias?(*(uint64_t *)((char *)v31 + *(int *)(Node + 20))+ OBJC_IVAR____TtCV14BiomeSQLParser12PgQuery_NodeP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__node, v119, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    outlined destroy of PgQuery_ParseResult((uint64_t)v31, type metadata accessor for PgQuery_Node);
    uint64_t v42 = *(void *)(v121 + 8);
    uint64_t v41 = *(void *)(v42 + 16);
    if (!v41)
    {
LABEL_10:
      uint64_t v47 = 0;
      uint64_t v48 = 0;
      unint64_t v24 = (unint64_t)v120;
      goto LABEL_41;
    }
    int v43 = *(_DWORD *)(v40
                    + OBJC_IVAR____TtCV14BiomeSQLParser15PgQuery_RawStmtP33_A784F7F2ED97E043416F18646CF1BF1713_StorageClass__stmtLocation);
    uint64_t v44 = v42 + ((*(unsigned __int8 *)(v126 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v126 + 80));
    uint64_t Node = *(void *)(v126 + 72);
    uint64_t v108 = *(uint64_t **)(v121 + 8);
    swift_bridgeObjectRetain();
    unint64_t v45 = 0;
    uint64_t v117 = v44;
    while (1)
    {
      outlined init with copy of PgQuery_ScanResult(v44, v24, type metadata accessor for PgQuery_ScanToken);
      int v46 = *(_DWORD *)v24;
      outlined destroy of PgQuery_ParseResult(v24, type metadata accessor for PgQuery_ScanToken);
      if (v46 >= v43) {
        break;
      }
      v44 += Node;
      if (v41 == ++v45)
      {
        swift_bridgeObjectRelease();
        goto LABEL_10;
      }
    }
    uint64_t v31 = v108;
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v132 = MEMORY[0x1E4FBC860];
    unint64_t v50 = v31[2];
    unint64_t v115 = v50;
    if (v50 < v45) {
      break;
    }
    if (v50 == v45)
    {
      unint64_t v24 = (unint64_t)v120;
LABEL_38:
      if (*(void *)(v132 + 16))
      {
        v130[0]._uint64_t countAndFlagsBits = v132;
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
        lazy protocol witness table accessor for type [String] and conformance [A]();
        uint64_t v47 = BidirectionalCollection<>.joined(separator:)();
        uint64_t v48 = v80;
        swift_bridgeObjectRelease();
      }
      else
      {
        swift_bridgeObjectRelease();
        uint64_t v47 = 0;
        uint64_t v48 = 0;
      }
LABEL_41:
      outlined init with copy of PgQuery_Alias?(v119, (uint64_t)v38, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      uint64_t v81 = type metadata accessor for PgQuery_Node.OneOf_Node(0);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v81 - 8) + 48))(v38, 1, v81) == 1)
      {
        swift_bridgeObjectRelease();
LABEL_51:
        v130[0]._uint64_t countAndFlagsBits = 0;
        v130[0]._object = (void *)0xE000000000000000;
        _StringGuts.grow(_:)(90);
        v91._object = (void *)0x800000018EBF7CC0;
        v91._uint64_t countAndFlagsBits = 0xD000000000000058;
        String.append(_:)(v91);
        uint64_t v92 = v119;
        outlined init with copy of PgQuery_Alias?(v119, v109, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        v93._uint64_t countAndFlagsBits = String.init<A>(describing:)();
        String.append(_:)(v93);
        swift_bridgeObjectRelease();
        uint64_t countAndFlagsBits = v130[0]._countAndFlagsBits;
        object = v130[0]._object;
        lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
        swift_allocError();
        *(void *)uint64_t v96 = countAndFlagsBits;
        *(void *)(v96 + 8) = object;
        *(void *)(v96 + 16) = 0;
        *(void *)(v96 + 24) = 0;
        *(unsigned char *)(v96 + 32) = 1;
        swift_willThrow();
        uint64_t v90 = v92;
        goto LABEL_52;
      }
      outlined init with copy of PgQuery_Alias?((uint64_t)v38, v112, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
      int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload();
      if (EnumCaseMultiPayload == 56)
      {
        outlined init with take of PgQuery_ParseResult(v112, v24, type metadata accessor for PgQuery_SelectStmt);
        uint64_t v87 = v106;
        outlined init with copy of PgQuery_ScanResult(v24, v106, type metadata accessor for PgQuery_SelectStmt);
        uint64_t v88 = v105;
        outlined init with copy of PgQuery_ScanResult(v107, v105, type metadata accessor for PlanResources);
        uint64_t v89 = v123;
        SelectCore.init(select:resources:)(v87, v88, (uint64_t)v130);
        if (v89)
        {
          swift_bridgeObjectRelease();
          int v86 = type metadata accessor for PgQuery_SelectStmt;
          goto LABEL_49;
        }
        outlined destroy of PgQuery_ParseResult(v24, type metadata accessor for PgQuery_SelectStmt);
        outlined destroy of AnyValue?(v119, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        char v131 = 0;
      }
      else
      {
        if (EnumCaseMultiPayload != 90)
        {
          swift_bridgeObjectRelease();
          outlined destroy of PgQuery_ParseResult(v112, type metadata accessor for PgQuery_Node.OneOf_Node);
          goto LABEL_51;
        }
        unint64_t v24 = v103;
        outlined init with take of PgQuery_ParseResult(v112, v103, type metadata accessor for PgQuery_CreateTableAsStmt);
        uint64_t v83 = v102;
        outlined init with copy of PgQuery_ScanResult(v24, v102, type metadata accessor for PgQuery_CreateTableAsStmt);
        uint64_t v84 = v104;
        outlined init with copy of PgQuery_ScanResult(v107, v104, type metadata accessor for PlanResources);
        uint64_t v85 = v123;
        MaterializedView.init(create:resources:)(v83, v84, v130);
        if (v85)
        {
          swift_bridgeObjectRelease();
          int v86 = type metadata accessor for PgQuery_CreateTableAsStmt;
LABEL_49:
          outlined destroy of PgQuery_ParseResult(v24, v86);
          uint64_t v90 = v119;
LABEL_52:
          outlined destroy of AnyValue?(v90, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
          return outlined destroy of AnyValue?((uint64_t)v38, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        }
        outlined destroy of PgQuery_ParseResult(v24, type metadata accessor for PgQuery_CreateTableAsStmt);
        outlined destroy of AnyValue?(v119, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
        char v131 = 1;
      }
      uint64_t v97 = v100;
      outlined init with take of LogicalPlanType(v130, v100);
      uint64_t v98 = v101;
      v97[42] = v99;
      v97[43] = v98;
      v97[44] = v47;
      v97[45] = v48;
      swift_bridgeObjectRetain();
      return outlined destroy of AnyValue?((uint64_t)v38, &demangling cache variable for type metadata for PgQuery_Node.OneOf_Node?);
    }
    unint64_t v40 = v45;
    unint64_t v126 = v125 + 8;
    unint64_t v51 = v115;
    if (v115 <= v45) {
      unint64_t v51 = v45;
    }
    unint64_t v114 = v51;
    swift_bridgeObjectRetain();
    unint64_t v24 = (unint64_t)v120;
    uint64_t v27 = v118;
    uint64_t v111 = v38;
    uint64_t v113 = Node;
    while (v40 != v114)
    {
      outlined init with copy of PgQuery_ScanResult(v117 + v40 * Node, (uint64_t)v27, type metadata accessor for PgQuery_ScanToken);
      uint64_t v52 = *((void *)v27 + 1);
      if (v27[16] != 1 || (unint64_t)(v52 - 37) >= 2)
      {
        outlined destroy of PgQuery_ParseResult((uint64_t)v27, type metadata accessor for PgQuery_ScanToken);
LABEL_37:
        swift_bridgeObjectRelease();
        goto LABEL_38;
      }
      unint64_t v122 = v40;
      uint64_t v41 = PgQuery_Token.rawValue.getter(v52, 1);
      uint64_t v54 = v121 + *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
      uint64_t v31 = *(uint64_t **)v54;
      unint64_t v40 = *(void *)(v54 + 8);
      unint64_t v24 = String.index(_:offsetBy:)();
      if ((unint64_t)String.index(_:offsetBy:)() >> 14 < v24 >> 14) {
        goto LABEL_58;
      }
      uint64_t v55 = String.subscript.getter();
      uint64_t v56 = MEMORY[0x192FAFFE0](v55);
      uint64_t v58 = v57;
      swift_bridgeObjectRelease();
      v130[0]._uint64_t countAndFlagsBits = v56;
      v130[0]._object = v58;
      unint64_t v59 = v127;
      static CharacterSet.whitespaces.getter();
      unint64_t v125 = lazy protocol witness table accessor for type String and conformance String();
      uint64_t v60 = StringProtocol.trimmingCharacters(in:)();
      unint64_t v62 = v61;
      uint64_t v124 = *(void (**)(char *, uint64_t))v126;
      v124(v59, v128);
      uint64_t v63 = swift_bridgeObjectRelease();
      uint64_t v41 = (uint64_t)&v99;
      v130[0]._uint64_t countAndFlagsBits = 10;
      v130[0]._object = (void *)0xE100000000000000;
      MEMORY[0x1F4188790](v63);
      *(&v99 - 2) = (uint64_t)v130;
      swift_bridgeObjectRetain();
      uint64_t v64 = v123;
      unint64_t v65 = specialized Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(0x7FFFFFFFFFFFFFFFLL, 1, partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:), (uint64_t)(&v99 - 4), v60, v62);
      uint64_t v123 = v64;
      swift_bridgeObjectRelease();
      uint64_t v66 = *((void *)v65 + 2);
      if (v66)
      {
        uint64_t v129 = MEMORY[0x1E4FBC860];
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
        BOOL v116 = v65;
        uint64_t v67 = (uint64_t *)(v65 + 56);
        do
        {
          uint64_t v68 = *(v67 - 3);
          uint64_t v69 = *(v67 - 2);
          uint64_t v70 = *(v67 - 1);
          uint64_t v71 = *v67;
          swift_bridgeObjectRetain();
          if (Substring.distance(from:to:)())
          {
            v130[0]._uint64_t countAndFlagsBits = MEMORY[0x192FAFFE0](v68, v69, v70, v71);
            v130[0]._object = v72;
            char v73 = v127;
            static CharacterSet.whitespaces.getter();
            uint64_t v74 = StringProtocol.trimmingCharacters(in:)();
            unint64_t v76 = v75;
            v124(v73, v128);
            swift_bridgeObjectRelease();
            swift_bridgeObjectRelease();
          }
          else
          {
            swift_bridgeObjectRelease();
            unint64_t v76 = 0xE100000000000000;
            uint64_t v74 = 10;
          }
          uint64_t v77 = v129;
          if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v77 = v129;
          }
          unint64_t v78 = *(void *)(v77 + 16);
          uint64_t v41 = v78 + 1;
          if (v78 >= *(void *)(v77 + 24) >> 1)
          {
            specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)();
            uint64_t v77 = v129;
          }
          *(void *)(v77 + 16) = v41;
          uint64_t v79 = v77 + 16 * v78;
          *(void *)(v79 + 32) = v74;
          *(void *)(v79 + 40) = v76;
          v67 += 4;
          --v66;
        }
        while (v66);
        swift_bridgeObjectRelease();
        uint64_t v38 = v111;
      }
      else
      {
        swift_bridgeObjectRelease();
      }
      unint64_t v40 = v122 + 1;
      uint64_t v31 = &v132;
      specialized Array.append<A>(contentsOf:)();
      uint64_t v27 = v118;
      outlined destroy of PgQuery_ParseResult((uint64_t)v118, type metadata accessor for PgQuery_ScanToken);
      unint64_t v24 = (unint64_t)v120;
      uint64_t Node = v113;
      if (v40 == v115) {
        goto LABEL_37;
      }
    }
    __break(1u);
LABEL_58:
    __break(1u);
LABEL_59:
    swift_once();
  }
  __break(1u);
  return result;
}

uint64_t _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFs12Zip2SequenceVySay14BiomeSQLParser15PgQuery_RawStmtVGSaySSGG_AH11LogicalPlanVsAE_pTg504_s14f11SQLParser15hi1_jk7VSSAA11lm3Vs5C33_pIgngrzo_AC_SStAEsAF_pIegnrzr_TRAJSSAOsAE_pIgngrzo_Tf1cn_n(uint64_t a1, uint64_t a2, void (*a3)(void *__return_ptr, char *, uint64_t, uint64_t), uint64_t a4)
{
  void (*v61)(void *__return_ptr, char *, uint64_t, uint64_t);
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  void v67[47];
  uint64_t v68;

  unint64_t v61 = a3;
  unint64_t v62 = a4;
  uint64_t RawStmt = type metadata accessor for PgQuery_RawStmt(0);
  uint64_t v63 = *(void *)(RawStmt - 8);
  uint64_t v7 = MEMORY[0x1F4188790](RawStmt - 8);
  uint64_t v9 = (char *)&v52 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v56 = (uint64_t)&v52 - v10;
  uint64_t v60 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (PgQuery_RawStmt, String));
  uint64_t v11 = MEMORY[0x1F4188790](v60);
  uint64_t v13 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v55 = (uint64_t)&v52 - v15;
  MEMORY[0x1F4188790](v14);
  uint64_t v54 = (uint64_t)&v52 - v16;
  unint64_t v17 = *(void *)(a1 + 16);
  uint64_t v64 = *(void *)(a2 + 16);
  unint64_t v65 = v17;
  if (v64 >= v17) {
    int64_t v18 = v17;
  }
  else {
    int64_t v18 = v64;
  }
  uint64_t v68 = MEMORY[0x1E4FBC860];
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, v18, 0);
  int64_t v58 = v18;
  uint64_t v59 = a1;
  uint64_t v53 = a2;
  if (v18)
  {
    uint64_t v57 = v9;
    uint64_t v19 = v68;
    swift_bridgeObjectRetain();
    uint64_t result = swift_bridgeObjectRetain();
    uint64_t v21 = 0;
    uint64_t v22 = (uint64_t *)(a2 + 40);
    while (v65 != v21)
    {
      uint64_t v23 = (uint64_t)v57;
      uint64_t result = outlined init with copy of PgQuery_ScanResult(a1+ ((*(unsigned __int8 *)(v63 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v63 + 80))+ *(void *)(v63 + 72) * v21, (uint64_t)v57, type metadata accessor for PgQuery_RawStmt);
      if (v64 == v21) {
        goto LABEL_37;
      }
      uint64_t v24 = *(v22 - 1);
      uint64_t v25 = *v22;
      uint64_t v26 = &v13[*(int *)(v60 + 48)];
      outlined init with take of PgQuery_ParseResult(v23, (uint64_t)v13, type metadata accessor for PgQuery_RawStmt);
      *(void *)uint64_t v26 = v24;
      *((void *)v26 + 1) = v25;
      swift_bridgeObjectRetain();
      uint64_t v27 = v66;
      v61(v67, v13, v24, v25);
      uint64_t v66 = v27;
      if (v27)
      {
        swift_release();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return outlined destroy of AnyValue?((uint64_t)v13, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      }
      outlined destroy of AnyValue?((uint64_t)v13, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v19 + 16) + 1, 1);
        uint64_t v19 = v68;
      }
      int64_t v28 = v58;
      unint64_t v30 = *(void *)(v19 + 16);
      unint64_t v29 = *(void *)(v19 + 24);
      if (v30 >= v29 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v29 > 1), v30 + 1, 1);
        uint64_t v19 = v68;
      }
      ++v21;
      *(void *)(v19 + 16) = v30 + 1;
      uint64_t result = (uint64_t)memcpy((void *)(v19 + 368 * v30 + 32), v67, 0x170uLL);
      v22 += 2;
      a1 = v59;
      if (v28 == v21) {
        goto LABEL_16;
      }
    }
    __break(1u);
LABEL_37:
    __break(1u);
  }
  else
  {
    swift_bridgeObjectRetain();
    uint64_t result = swift_bridgeObjectRetain();
    int64_t v28 = v58;
LABEL_16:
    unint64_t v32 = v64;
    unint64_t v31 = v65;
    if (v65 <= v64)
    {
LABEL_34:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v68;
    }
    if (v28 <= (uint64_t)v64) {
      unint64_t v33 = v64;
    }
    else {
      unint64_t v33 = v28;
    }
    int64_t v58 = v33;
    uint64_t v34 = (uint64_t *)(v53 + 16 * v28 + 40);
    uint64_t v35 = v66;
    while (v31 != v28)
    {
      uint64_t v36 = v56;
      uint64_t result = outlined init with copy of PgQuery_ScanResult(a1+ ((*(unsigned __int8 *)(v63 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v63 + 80))+ *(void *)(v63 + 72) * v28, v56, type metadata accessor for PgQuery_RawStmt);
      if (v32 == v28)
      {
        outlined destroy of PgQuery_ParseResult(v36, type metadata accessor for PgQuery_RawStmt);
        goto LABEL_34;
      }
      if (v58 == v28) {
        goto LABEL_39;
      }
      uint64_t v38 = *(v34 - 1);
      uint64_t v37 = *v34;
      uint64_t v66 = v35;
      uint64_t v39 = v60;
      uint64_t v40 = v55;
      uint64_t v41 = (void *)(v55 + *(int *)(v60 + 48));
      outlined init with take of PgQuery_ParseResult(v36, v55, type metadata accessor for PgQuery_RawStmt);
      *uint64_t v41 = v38;
      v41[1] = v37;
      uint64_t v42 = v54;
      outlined init with take of SQLExpression?(v40, v54, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      int v43 = (uint64_t *)(v42 + *(int *)(v39 + 48));
      uint64_t v44 = *v43;
      uint64_t v45 = v43[1];
      swift_bridgeObjectRetain();
      uint64_t v46 = v44;
      uint64_t v47 = v66;
      v61(v67, (char *)v42, v46, v45);
      uint64_t v35 = v47;
      outlined destroy of AnyValue?(v42, &demangling cache variable for type metadata for (PgQuery_RawStmt, String));
      if (v47)
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        return swift_release();
      }
      uint64_t v48 = v68;
      char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
      unint64_t v31 = v65;
      if ((isUniquelyReferenced_nonNull_native & 1) == 0)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(v48 + 16) + 1, 1);
        uint64_t v48 = v68;
      }
      unint64_t v32 = v64;
      unint64_t v51 = *(void *)(v48 + 16);
      unint64_t v50 = *(void *)(v48 + 24);
      if (v51 >= v50 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v50 > 1), v51 + 1, 1);
        uint64_t v48 = v68;
      }
      ++v28;
      *(void *)(v48 + 16) = v51 + 1;
      uint64_t result = (uint64_t)memcpy((void *)(v48 + 368 * v51 + 32), v67, 0x170uLL);
      v34 += 2;
      a1 = v59;
      if (v31 == v28) {
        goto LABEL_34;
      }
    }
  }
  __break(1u);
LABEL_39:
  __break(1u);
  return result;
}

void parse(sql:catalog:)(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v118 = type metadata accessor for CharacterSet();
  BOOL v116 = *(void (***)(char *, uint64_t))(v118 - 8);
  MEMORY[0x1F4188790](v118);
  uint64_t v117 = (char *)&v98 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  MEMORY[0x1F4188790](ScanResult);
  unint64_t v115 = (char *)&v98 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = type metadata accessor for BinaryDecodingOptions();
  uint64_t v9 = MEMORY[0x1F4188790](v8 - 8);
  uint64_t v113 = (char *)&v98 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  unint64_t v120 = (char *)&v98 - v11;
  uint64_t ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  MEMORY[0x1F4188790](ParseResult);
  uint64_t v13 = (char *)&v98 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = type metadata accessor for SQLParseResult(0);
  uint64_t v15 = MEMORY[0x1F4188790](v14);
  unint64_t v17 = (char *)&v98 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v98 - v19;
  uint64_t v112 = *a3;
  uint64_t v21 = &v17[*(int *)(v18 + 28)];
  *(void *)uint64_t v21 = a1;
  *((void *)v21 + 1) = a2;
  unint64_t v122 = a1;
  uint64_t v123 = v21;
  uint64_t v22 = String.utf8CString.getter() + 32;
  uint64_t v127 = a2;
  swift_bridgeObjectRetain_n();
  pg_query_parse_protobuf(v22, (uint64_t)&v124);
  uint64_t v23 = v124;
  uint64_t v24 = (unsigned __int8 *)*((void *)&v124 + 1);
  long long v25 = v125;
  swift_release();
  if (*((void *)&v25 + 1))
  {
    if (**((void **)&v25 + 1))
    {
      uint64_t v26 = String.init(cString:)();
      uint64_t v28 = v27;
      lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
      swift_allocError();
      uint64_t v29 = v127;
      *(void *)uint64_t v30 = v122;
      *(void *)(v30 + 8) = v29;
      *(void *)(v30 + 16) = v26;
      *(void *)(v30 + 24) = v28;
      *(unsigned char *)(v30 + 32) = 0;
      swift_willThrow();
LABEL_31:
      swift_bridgeObjectRelease();
      return;
    }
    goto LABEL_44;
  }
  uint64_t v111 = v23;
  unint64_t v107 = v25;
  uint64_t v108 = v20;
  uint64_t v109 = v14;
  uint64_t v110 = v17;
  if (!v24)
  {
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
LABEL_47:
    __break(1u);
    goto LABEL_48;
  }
  unsigned int v31 = v111;
  uint64_t v32 = specialized Data.init(bytes:count:)(v24, v111);
  unint64_t v34 = v33;
  uint64_t v126 = 0;
  long long v124 = 0u;
  long long v125 = 0u;
  outlined copy of Data._Representation(v32, v33);
  BinaryDecodingOptions.init()();
  lazy protocol witness table accessor for type PgQuery_ParseResult and conformance PgQuery_ParseResult(&lazy protocol witness table cache variable for type PgQuery_ParseResult and conformance PgQuery_ParseResult, (void (*)(uint64_t))type metadata accessor for PgQuery_ParseResult);
  uint64_t v35 = v119;
  Message.init(serializedData:extensions:partial:options:)();
  if (v35)
  {
    swift_bridgeObjectRelease();
    outlined consume of Data._Representation(v32, v34);
    goto LABEL_31;
  }
  uint64_t v36 = (uint64_t)v110;
  outlined init with take of PgQuery_ParseResult((uint64_t)v13, (uint64_t)v110, type metadata accessor for PgQuery_ParseResult);
  deparse_protobuf = pg_query_deparse_protobuf(v31, v24);
  if (v38)
  {
    if (!*v38)
    {
LABEL_48:
      __break(1u);
      goto LABEL_49;
    }
    uint64_t v39 = String.init(cString:)();
    uint64_t v41 = v40;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    uint64_t v42 = v127;
    *(void *)uint64_t v43 = v122;
    *(void *)(v43 + 8) = v42;
    *(void *)(v43 + 16) = v39;
    *(void *)(v43 + 24) = v41;
    *(unsigned char *)(v43 + 32) = 0;
    swift_willThrow();
LABEL_30:
    outlined consume of Data._Representation(v32, v34);
    outlined destroy of PgQuery_ParseResult(v36, type metadata accessor for PgQuery_ParseResult);
    goto LABEL_31;
  }
  uint64_t v44 = deparse_protobuf;
  if (!deparse_protobuf)
  {
LABEL_49:
    __break(1u);
    goto LABEL_50;
  }
  uint64_t v104 = v24;
  unint64_t v106 = v34;
  id v45 = objc_allocWithZone(NSString);
  unint64_t v103 = v44;
  id v46 = objc_msgSend(v45, sel_initWithCString_encoding_, v44, 4);
  if (!v46)
  {
LABEL_50:
    __break(1u);
    goto LABEL_51;
  }
  uint64_t v47 = v46;
  uint64_t v48 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  unint64_t v50 = v49;

  uint64_t v51 = String.utf8CString.getter();
  pg_query_split_with_parser((const char *)(v51 + 32), (uint64_t)&v124);
  uint64_t v105 = (void *)v124;
  uint64_t v52 = DWORD2(v124);
  long long v53 = v125;
  swift_release();
  if (*((void *)&v53 + 1))
  {
    swift_bridgeObjectRelease();
    if (!**((void **)&v53 + 1))
    {
LABEL_51:
      __break(1u);
      goto LABEL_52;
    }
    uint64_t v54 = String.init(cString:)();
    uint64_t v56 = v55;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    uint64_t v57 = v127;
    *(void *)uint64_t v58 = v122;
    *(void *)(v58 + 8) = v57;
    *(void *)(v58 + 16) = v54;
    *(void *)(v58 + 24) = v56;
    *(unsigned char *)(v58 + 32) = 0;
    swift_willThrow();
    unint64_t v34 = v106;
    uint64_t v36 = (uint64_t)v110;
    goto LABEL_30;
  }
  uint64_t v119 = v48;
  unint64_t v120 = v50;
  unint64_t v102 = v53;
  uint64_t v36 = (uint64_t)v110;
  if (*(void *)(*((void *)v110 + 1) + 16) != (int)v52)
  {
    swift_bridgeObjectRelease();
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    uint64_t v80 = v127;
    *(void *)uint64_t v81 = v122;
    *(void *)(v81 + 8) = v80;
    *(void *)(v81 + 16) = 0xD000000000000042;
    *(void *)(v81 + 24) = 0x800000018EBF7C50;
    *(unsigned char *)(v81 + 32) = 0;
    swift_willThrow();
    unint64_t v34 = v106;
    goto LABEL_30;
  }
  if ((v52 & 0x80000000) != 0)
  {
LABEL_43:
    __break(1u);
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  uint64_t v100 = 0;
  uint64_t v99 = 0;
  uint64_t v101 = v32;
  uint64_t v59 = v105;
  uint64_t v98 = v52;
  if (v52)
  {
    ++v116;
    uint64_t ParseResult = MEMORY[0x1E4FBC860];
    uint64_t v60 = (int **)v105;
    uint64_t v61 = v52;
    while (v59)
    {
      unint64_t v62 = *v60;
      if (!*v60) {
        goto LABEL_47;
      }
      int v63 = v62[1];
      int v64 = *v62;
      unint64_t v65 = String.index(_:offsetBy:)();
      if (__OFADD__(v64, v63))
      {
        __break(1u);
LABEL_42:
        __break(1u);
        goto LABEL_43;
      }
      if ((unint64_t)String.index(_:offsetBy:)() >> 14 < v65 >> 14) {
        goto LABEL_42;
      }
      uint64_t v66 = String.subscript.getter();
      uint64_t v67 = MEMORY[0x192FAFFE0](v66);
      uint64_t v69 = v68;
      swift_bridgeObjectRelease();
      *(void *)&long long v124 = v67;
      *((void *)&v124 + 1) = v69;
      uint64_t v70 = v117;
      static CharacterSet.whitespacesAndNewlines.getter();
      lazy protocol witness table accessor for type String and conformance String();
      uint64_t v71 = StringProtocol.trimmingCharacters(in:)();
      uint64_t v73 = v72;
      (*v116)(v70, v118);
      swift_bridgeObjectRelease();
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(void *)(ParseResult + 16) + 1, 1, ParseResult);
        uint64_t ParseResult = v78;
      }
      unint64_t v75 = *(void *)(ParseResult + 16);
      unint64_t v74 = *(void *)(ParseResult + 24);
      if (v75 >= v74 >> 1)
      {
        specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v74 > 1, v75 + 1, 1, ParseResult);
        uint64_t ParseResult = v79;
      }
      uint64_t v76 = ParseResult;
      *(void *)(ParseResult + 16) = v75 + 1;
      uint64_t v77 = v76 + 16 * v75;
      *(void *)(v77 + 32) = v71;
      *(void *)(v77 + 40) = v73;
      ++v60;
      if (!--v61) {
        goto LABEL_33;
      }
    }
    goto LABEL_46;
  }
  uint64_t ParseResult = MEMORY[0x1E4FBC860];
LABEL_33:
  swift_bridgeObjectRelease();
  uint64_t v82 = (uint64_t)v110;
  *(void *)&v110[*(int *)(v109 + 24)] = ParseResult;
  uint64_t v83 = v127;
  uint64_t v84 = String.utf8CString.getter() + 32;
  swift_bridgeObjectRetain();
  pg_query_scan(v84);
  uint64_t v85 = v124;
  int v86 = (unsigned char *)*((void *)&v124 + 1);
  long long v87 = v125;
  swift_release();
  if (*((void *)&v87 + 1))
  {
    if (!**((void **)&v87 + 1))
    {
LABEL_52:
      __break(1u);
      goto LABEL_53;
    }
    swift_bridgeObjectRelease();
    uint64_t v88 = String.init(cString:)();
    uint64_t v90 = v89;
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(void *)uint64_t v91 = v122;
    *(void *)(v91 + 8) = v83;
    *(void *)(v91 + 16) = v88;
    *(void *)(v91 + 24) = v90;
    *(unsigned char *)(v91 + 32) = 0;
    swift_willThrow();
    outlined consume of Data._Representation(v101, v106);
LABEL_39:
    outlined destroy of PgQuery_ParseResult(v82, type metadata accessor for PgQuery_ParseResult);
    swift_bridgeObjectRelease();
    goto LABEL_31;
  }
  unint64_t v122 = v87;
  swift_bridgeObjectRelease();
  if (v86)
  {
    swift_bridgeObjectRelease();
    uint64_t v92 = specialized Data.init(bytes:count:)(v86, v85);
    unint64_t v94 = v93;
    uint64_t v126 = 0;
    long long v124 = 0u;
    long long v125 = 0u;
    outlined copy of Data._Representation(v92, v93);
    BinaryDecodingOptions.init()();
    lazy protocol witness table accessor for type PgQuery_ParseResult and conformance PgQuery_ParseResult(&lazy protocol witness table cache variable for type PgQuery_ScanResult and conformance PgQuery_ScanResult, (void (*)(uint64_t))type metadata accessor for PgQuery_ScanResult);
    uint64_t v95 = (uint64_t)v115;
    uint64_t v96 = v100;
    Message.init(serializedData:extensions:partial:options:)();
    if (!v96)
    {
      outlined init with take of PgQuery_ParseResult(v95, v82 + *(int *)(v109 + 20), type metadata accessor for PgQuery_ScanResult);
      LODWORD(v124) = v85;
      *((void *)&v124 + 1) = v86;
      long long v125 = v122;
      pg_query_free_scan_result((uint64_t)&v124);
      *(void *)&long long v124 = v59;
      DWORD2(v124) = v98;
      long long v125 = v102;
      pg_query_free_split_result((uint64_t)&v124);
      pg_query_free_deparse_result(v103, v99);
      LODWORD(v124) = v111;
      *((void *)&v124 + 1) = v104;
      long long v125 = v107;
      pg_query_free_protobuf_parse_result((uint64_t)&v124);
      outlined consume of Data._Representation(v101, v106);
      outlined consume of Data._Representation(v92, v94);
      uint64_t v97 = (uint64_t)v108;
      outlined init with take of PgQuery_ParseResult(v82, (uint64_t)v108, type metadata accessor for SQLParseResult);
      *(void *)&long long v124 = v112;
      SQLParseResult.plans(with:)((uint64_t *)&v124);
      outlined destroy of PgQuery_ParseResult(v97, type metadata accessor for SQLParseResult);
      return;
    }
    outlined consume of Data._Representation(v101, v106);
    outlined consume of Data._Representation(v92, v94);
    goto LABEL_39;
  }
LABEL_53:
  __break(1u);
}

void *specialized ContiguousArray.reserveCapacity(_:)(int64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t result = (void *)swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v1 = v3;
  if (!result || a1 > *(void *)(v3 + 24) >> 1)
  {
    if (*(void *)(v3 + 16) <= a1) {
      int64_t v5 = a1;
    }
    else {
      int64_t v5 = *(void *)(v3 + 16);
    }
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(result, v5, 0);
  }
  return result;
}

void *specialized ContiguousArray._reserveCapacityAssumingUniqueBuffer(oldCount:)(void *result)
{
  unint64_t v2 = *(void *)(*(void *)v1 + 24);
  if ((uint64_t)result + 1 > (uint64_t)(v2 >> 1)) {
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)((void *)(v2 > 1), (int64_t)result + 1, 1);
  }
  return result;
}

void *specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(void *a1, int64_t a2, char a3)
{
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

{
  void **v3;
  void *result;

  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

{
  void **v3;
  void *result;

  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

char *specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(char *a1, int64_t a2, char a3)
{
  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

{
  char **v3;
  char *result;

  uint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys;
  if (!lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type DatabaseCatalog.CodingKeys and conformance DatabaseCatalog.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Schema and conformance Schema()
{
  unint64_t result = lazy protocol witness table cache variable for type Schema and conformance Schema;
  if (!lazy protocol witness table cache variable for type Schema and conformance Schema)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema and conformance Schema);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Schema and conformance Schema;
  if (!lazy protocol witness table cache variable for type Schema and conformance Schema)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema and conformance Schema);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Schema.CodingKeys and conformance Schema.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys;
  if (!lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Schema.CodingKeys and conformance Schema.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type FromClause.CodingKeys and conformance FromClause.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys;
  if (!lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause.CodingKeys and conformance FromClause.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys;
  if (!lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn.CodingKeys and conformance ResultColumn.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys;
  if (!lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore.CodingKeys and conformance SelectCore.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type FromClause and conformance FromClause()
{
  unint64_t result = lazy protocol witness table cache variable for type FromClause and conformance FromClause;
  if (!lazy protocol witness table cache variable for type FromClause and conformance FromClause)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type FromClause and conformance FromClause);
  }
  return result;
}

uint64_t lazy protocol witness table accessor for type [Schema] and conformance <A> [A](unint64_t *a1, uint64_t *a2, void (*a3)(void))
{
  uint64_t result = *a1;
  if (!result)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    a3();
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type ResultColumn and conformance ResultColumn()
{
  unint64_t result = lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn;
  if (!lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type ResultColumn and conformance ResultColumn);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys;
  if (!lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView.CodingKeys and conformance MaterializedView.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type SelectCore and conformance SelectCore()
{
  unint64_t result = lazy protocol witness table cache variable for type SelectCore and conformance SelectCore;
  if (!lazy protocol witness table cache variable for type SelectCore and conformance SelectCore)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SelectCore and conformance SelectCore);
  }
  return result;
}

uint64_t outlined init with copy of LogicalPlanType(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t lazy protocol witness table accessor for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlan.CodingKeys and conformance LogicalPlan.CodingKeys);
  }
  return result;
}

void *outlined destroy of SelectCore(void *a1)
{
  return a1;
}

unint64_t lazy protocol witness table accessor for type MaterializedView and conformance MaterializedView()
{
  unint64_t result = lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView;
  if (!lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type MaterializedView and conformance MaterializedView);
  }
  return result;
}

void *outlined destroy of MaterializedView(void *a1)
{
  return a1;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.CodingKeys and conformance LogicalPlanType.CodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.MaterializedViewCodingKeys and conformance LogicalPlanType.MaterializedViewCodingKeys);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys()
{
  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys;
  if (!lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type LogicalPlanType.SelectCoreCodingKeys and conformance LogicalPlanType.SelectCoreCodingKeys);
  }
  return result;
}

uint64_t type metadata accessor for SQLParseResult(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for SQLParseResult);
}

char *specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<String>);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 17;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 4);
  }
  else
  {
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v13 = v10 + 32;
  uint64_t v14 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v13 >= &v14[16 * v8]) {
      memmove(v13, v14, 16 * v8);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<SQLDataType>);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * v11 - 64;
  }
  else
  {
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v12 = v10 + 32;
  uint64_t v13 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v12 >= &v13[v8]) {
      memmove(v12, v13, v8);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    memcpy(v12, v13, v8);
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;

  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<ResultColumn>);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 + 95;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 7);
  }
  else
  {
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v13 = v10 + 32;
  uint64_t v14 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v13 >= &v14[128 * v8]) {
      memmove(v13, v14, v8 << 7);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;
  char *v12;
  char *v13;

  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<LogicalPlan>);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * ((uint64_t)(v11 - 32) / 368);
  }
  else
  {
    uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v12 = v10 + 32;
  uint64_t v13 = a4 + 32;
  if (v5)
  {
    if (v10 != a4 || v12 >= &v13[368 * v8]) {
      memmove(v12, v13, 368 * v8);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

void *specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(void *result, int64_t a2, char a3, void *a4)
{
  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<SQLExpressionNode>);
    uint64_t v10 = (void *)swift_allocObject();
    size_t v11 = _swift_stdlib_malloc_size(v10);
    void v10[2] = v8;
    v10[3] = 2 * ((uint64_t)(v11 - 32) / 40);
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
  }
  if (v5)
  {
    if (v10 != a4 || v10 + 4 >= &a4[5 * v8 + 4]) {
      memmove(v10 + 4, a4 + 4, 40 * v8);
    }
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for SQLExpressionNode);
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  size_t v11;

  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Schema)>);
    uint64_t v10 = (void *)swift_allocObject();
    size_t v11 = _swift_stdlib_malloc_size(v10);
    void v10[2] = v8;
    v10[3] = 2 * ((uint64_t)(v11 - 32) / 40);
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
  }
  if (v5)
  {
    if (v10 != a4 || v10 + 4 >= &a4[5 * v8 + 4]) {
      memmove(v10 + 4, a4 + 4, 40 * v8);
    }
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&demangling cache variable for type metadata for (String, Schema));
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int64_t v11;
  uint64_t v12;

  char v5 = (char)result;
  if (a3)
  {
    unint64_t v6 = a4[3];
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000 < 0)
      {
        __break(1u);
        return result;
      }
      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFELL) <= a2) {
        int64_t v7 = a2;
      }
    }
  }
  else
  {
    int64_t v7 = a2;
  }
  uint64_t v8 = a4[2];
  if (v7 <= v8) {
    uint64_t v9 = a4[2];
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<[AggregationFunction]>);
    uint64_t v10 = (void *)swift_allocObject();
    size_t v11 = _swift_stdlib_malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 25;
    }
    void v10[2] = v8;
    v10[3] = 2 * (v12 >> 3);
  }
  else
  {
    uint64_t v10 = (void *)MEMORY[0x1E4FBC860];
  }
  if (v5)
  {
    if (v10 != a4 || v10 + 4 >= &a4[v8 + 4]) {
      memmove(v10 + 4, a4 + 4, 8 * v8);
    }
    a4[2] = 0;
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [AggregationFunction]);
    swift_arrayInitWithCopy();
  }
  swift_release();
  return v10;
}

char *specialized Array._makeUniqueAndReserveCapacityIfNotUnique()()
{
  uint64_t v1 = *v0;
  unint64_t result = (char *)swift_isUniquelyReferenced_nonNull_native();
  *uint64_t v0 = v1;
  if (!result)
  {
    unint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(result, *((void *)v1 + 2) + 1, 1, v1);
    *uint64_t v0 = result;
  }
  return result;
}

char *specialized Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(uint64_t a1, char a2, uint64_t (*a3)(void *), uint64_t a4, uint64_t a5, unint64_t a6)
{
  v46[3] = a4;
  if (a1 < 0)
  {
LABEL_41:
    __break(1u);
    goto LABEL_42;
  }
  uint64_t v11 = a5;
  uint64_t v14 = swift_allocObject();
  *(void *)(v14 + 16) = MEMORY[0x1E4FBC860];
  uint64_t v43 = swift_allocObject();
  *(void *)(v43 + 16) = 15;
  uint64_t v15 = HIBYTE(a6) & 0xF;
  if (!a1 || ((a6 & 0x2000000000000000) != 0 ? (uint64_t v16 = HIBYTE(a6) & 0xF) : (uint64_t v16 = v11 & 0xFFFFFFFFFFFFLL), !v16))
  {
    if ((a6 & 0x2000000000000000) == 0) {
      uint64_t v15 = v11 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v30 = 7;
    if (((a6 >> 60) & ((v11 & 0x800000000000000) == 0)) != 0) {
      uint64_t v30 = 11;
    }
    specialized appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(v30 | (v15 << 16), v43, a2 & 1, v14);
    swift_bridgeObjectRelease();
    uint64_t v10 = *(char **)(v14 + 16);
    swift_bridgeObjectRetain();
    swift_release();
    goto LABEL_38;
  }
  uint64_t v38 = a1;
  uint64_t v39 = v14;
  unint64_t v44 = 4 * v16;
  uint64_t v10 = (char *)MEMORY[0x1E4FBC860];
  unint64_t v9 = 15;
  unint64_t v8 = 15;
  unint64_t v17 = 15;
  while (1)
  {
    v46[0] = String.subscript.getter();
    v46[1] = v18;
    uint64_t v19 = a3(v46);
    if (v7)
    {
      swift_release();
      swift_release();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      return v10;
    }
    uint64_t v6 = v19;
    swift_bridgeObjectRelease();
    if (v6) {
      break;
    }
    unint64_t v9 = String.index(after:)();
LABEL_9:
    if (v44 == v9 >> 14) {
      goto LABEL_29;
    }
  }
  if (v17 >> 14 == v9 >> 14 && (a2 & 1) != 0)
  {
    unint64_t v9 = String.index(after:)();
    *(void *)(v43 + 16) = v9;
    unint64_t v8 = v9;
    unint64_t v17 = v9;
    goto LABEL_9;
  }
  if (v9 >> 14 < v17 >> 14)
  {
    __break(1u);
    goto LABEL_41;
  }
  uint64_t v20 = String.subscript.getter();
  uint64_t v40 = v21;
  uint64_t v41 = v20;
  uint64_t v23 = v22;
  uint64_t v25 = v24;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((void *)v10 + 2) + 1, 1, v10);
  }
  unint64_t v27 = *((void *)v10 + 2);
  unint64_t v26 = *((void *)v10 + 3);
  uint64_t v6 = v27 + 1;
  if (v27 >= v26 >> 1) {
    uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v26 > 1), v27 + 1, 1, v10);
  }
  *((void *)v10 + 2) = v6;
  uint64_t v28 = &v10[32 * v27];
  *((void *)v28 + 4) = v41;
  *((void *)v28 + 5) = v23;
  *((void *)v28 + 6) = v25;
  *((void *)v28 + 7) = v40;
  *(void *)(v39 + 16) = v10;
  uint64_t v29 = String.index(after:)();
  unint64_t v9 = v29;
  *(void *)(v43 + 16) = v29;
  unint64_t v8 = v29;
  if (*((void *)v10 + 2) != v38)
  {
    unint64_t v17 = v29;
    goto LABEL_9;
  }
  unint64_t v17 = v29;
LABEL_29:
  if (v44 == v17 >> 14 && (a2 & 1) != 0)
  {
    swift_bridgeObjectRelease();
    goto LABEL_37;
  }
  if (v44 >= v8 >> 14)
  {
    uint64_t v6 = String.subscript.getter();
    unint64_t v8 = v31;
    unint64_t v9 = v32;
    uint64_t v11 = v33;
    swift_bridgeObjectRelease();
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      goto LABEL_43;
    }
    goto LABEL_34;
  }
LABEL_42:
  __break(1u);
LABEL_43:
  uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((void *)v10 + 2) + 1, 1, v10);
LABEL_34:
  unint64_t v35 = *((void *)v10 + 2);
  unint64_t v34 = *((void *)v10 + 3);
  if (v35 >= v34 >> 1) {
    uint64_t v10 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v34 > 1), v35 + 1, 1, v10);
  }
  *((void *)v10 + 2) = v35 + 1;
  uint64_t v36 = &v10[32 * v35];
  *((void *)v36 + 4) = v6;
  *((void *)v36 + 5) = v8;
  *((void *)v36 + 6) = v9;
  *((void *)v36 + 7) = v11;
  *(void *)(v39 + 16) = v10;
LABEL_37:
  swift_bridgeObjectRetain();
  swift_release();
LABEL_38:
  swift_release();
  return v10;
}

uint64_t specialized appendSubsequence #1 <A>(end:) in Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(unint64_t a1, uint64_t a2, unsigned __int8 a3, uint64_t a4)
{
  unint64_t v10 = *(void *)(a2 + 16) >> 14;
  int v11 = (v10 == a1 >> 14) & a3;
  if (v11 == 1) {
    return v11 ^ 1u;
  }
  if (a1 >> 14 < v10)
  {
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = a4;
  uint64_t v5 = String.subscript.getter();
  uint64_t v6 = v12;
  uint64_t v7 = v13;
  uint64_t v8 = v14;
  unint64_t v9 = *(char **)(v4 + 16);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *(void *)(v4 + 16) = v9;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
LABEL_9:
    unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *((void *)v9 + 2) + 1, 1, v9);
    *(void *)(v4 + 16) = v9;
  }
  unint64_t v17 = *((void *)v9 + 2);
  unint64_t v16 = *((void *)v9 + 3);
  if (v17 >= v16 >> 1)
  {
    unint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((char *)(v16 > 1), v17 + 1, 1, v9);
    *(void *)(v4 + 16) = v9;
  }
  *((void *)v9 + 2) = v17 + 1;
  uint64_t v18 = &v9[32 * v17];
  *((void *)v18 + 4) = v5;
  *((void *)v18 + 5) = v6;
  *((void *)v18 + 6) = v7;
  *((void *)v18 + 7) = v8;
  return v11 ^ 1u;
}

uint64_t specialized Sequence.reduce<A>(into:_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = result;
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return result;
  }
  swift_bridgeObjectRetain();
  for (unint64_t i = (uint64_t *)(a2 + 136); ; i += 16)
  {
    uint64_t v7 = *i;
    if (*i) {
      break;
    }
LABEL_3:
    if (!--v3)
    {
      swift_bridgeObjectRelease();
      return v18;
    }
  }
  uint64_t v8 = *(i - 1);
  uint64_t v9 = v18;
  Swift::String v10 = String.lowercased()();
  swift_bridgeObjectRetain();
  LOBYTE(v9) = specialized Set.contains(_:)(v10._countAndFlagsBits, (uint64_t)v10._object, v9);
  swift_bridgeObjectRelease();
  if (v9)
  {
    unint64_t v14 = 0x800000018EBF7F00;
    unint64_t v15 = 0xD000000000000021;
    goto LABEL_11;
  }
  Swift::String v11 = String.lowercased()();
  char v12 = specialized Set.contains(_:)(v11._countAndFlagsBits, (uint64_t)v11._object, a3);
  swift_bridgeObjectRelease();
  if ((v12 & 1) == 0)
  {
    Swift::String v13 = String.lowercased()();
    swift_bridgeObjectRelease();
    specialized Set._Variant.insert(_:)(&v17, v13._countAndFlagsBits, (unint64_t)v13._object);
    swift_bridgeObjectRelease();
    goto LABEL_3;
  }
  unint64_t v15 = 0xD000000000000043;
  unint64_t v14 = 0x800000018EBF7EB0;
LABEL_11:
  lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
  swift_allocError();
  *(void *)uint64_t v16 = v8;
  *(void *)(v16 + 8) = v7;
  *(void *)(v16 + 16) = v15;
  *(void *)(v16 + 24) = v14;
  *(unsigned char *)(v16 + 32) = 7;
  swift_willThrow();
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t specialized Schema.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x6D614E656C626174 && a2 == 0xE900000000000065;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x736E6D756C6F63 && a2 == 0xE700000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

uint64_t specialized FromClause.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x73616D65686373 && a2 == 0xE700000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x800000018EBF7CA0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

unint64_t specialized Array.replaceSubrange<A>(_:with:)(unint64_t result, uint64_t a2, uint64_t a3)
{
  if ((result & 0x8000000000000000) != 0)
  {
    __break(1u);
    goto LABEL_23;
  }
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 16);
  if (v6 < a2)
  {
LABEL_23:
    __break(1u);
    goto LABEL_24;
  }
  unint64_t v7 = result;
  unint64_t v8 = a2 - result;
  if (__OFSUB__(a2, result))
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v10 = v9 - v8;
  if (__OFSUB__(v9, v8))
  {
LABEL_25:
    __break(1u);
    goto LABEL_26;
  }
  uint64_t v11 = v6 + v10;
  if (__OFADD__(v6, v10))
  {
LABEL_26:
    __break(1u);
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
    return result;
  }
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  if (!isUniquelyReferenced_nonNull_native || v11 > *(void *)(v5 + 24) >> 1)
  {
    if (v6 <= v11) {
      uint64_t v13 = v6 + v10;
    }
    else {
      uint64_t v13 = v6;
    }
    specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(isUniquelyReferenced_nonNull_native, v13, 1, v5);
    uint64_t v5 = v14;
  }
  uint64_t v15 = v5 + 32 + 16 * v7;
  unint64_t result = swift_arrayDestroy();
  if (!v10) {
    goto LABEL_19;
  }
  uint64_t v16 = *(void *)(v5 + 16);
  BOOL v17 = __OFSUB__(v16, a2);
  uint64_t v18 = v16 - a2;
  if (v17) {
    goto LABEL_27;
  }
  unint64_t result = v15 + 16 * v9;
  uint64_t v19 = (const void *)(v5 + 32 + 16 * a2);
  if ((const void *)result != v19 || result >= (unint64_t)v19 + 16 * v18) {
    unint64_t result = (unint64_t)memmove((void *)result, v19, 16 * v18);
  }
  uint64_t v20 = *(void *)(v5 + 16);
  BOOL v17 = __OFADD__(v20, v10);
  uint64_t v21 = v20 + v10;
  if (v17) {
    goto LABEL_28;
  }
  *(void *)(v5 + 16) = v21;
LABEL_19:
  if (v9) {
    unint64_t result = swift_arrayInitWithCopy();
  }
  *uint64_t v3 = v5;
  return result;
}

uint64_t specialized ResultColumn.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x6973736572707865 && a2 == 0xEA00000000006E6FLL;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x7361696C61 && a2 == 0xE500000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x746E656D75636F64 && a2 == 0xED00006E6F697461)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 2;
    }
    else {
      return 3;
    }
  }
}

uint64_t specialized Sequence.forEach(_:)(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2)
  {
    uint64_t v3 = a2;
    uint64_t v4 = result + 32;
    uint64_t v27 = a2 + 56;
    swift_bridgeObjectRetain();
    uint64_t v5 = 0;
    uint64_t v24 = v4;
    uint64_t v25 = v2;
    do
    {
      char v6 = (void *)(v4 + (v5 << 7));
      uint64_t v7 = v6[13];
      outlined init with copy of ResultColumn((uint64_t)v6, (uint64_t)v26);
      if (!v7)
      {
        Swift::String v8 = String.lowercased()();
        uint64_t v9 = v3;
        if (*(void *)(v3 + 16))
        {
          Hasher.init(_seed:)();
          String.hash(into:)();
          Swift::Int v10 = Hasher._finalize()();
          uint64_t v11 = -1 << *(unsigned char *)(v3 + 32);
          unint64_t v12 = v10 & ~v11;
          if ((*(void *)(v27 + ((v12 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v12))
          {
            uint64_t v13 = *(void *)(v9 + 48);
            uint64_t v14 = v13 + 16 * v12;
            BOOL v15 = *(void *)v14 == v8._countAndFlagsBits && *(void **)(v14 + 8) == v8._object;
            if (v15 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
            {
LABEL_21:
              swift_bridgeObjectRelease();
              outlined destroy of ResultColumn((uint64_t)v26);
              uint64_t v21 = v6[10];
              uint64_t v22 = v6[11];
              lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
              swift_allocError();
              *(void *)uint64_t v23 = v21;
              *(void *)(v23 + 8) = v22;
              *(void *)(v23 + 16) = 0xD00000000000003DLL;
              *(void *)(v23 + 24) = 0x800000018EBF7E70;
              *(unsigned char *)(v23 + 32) = 7;
              swift_bridgeObjectRetain();
              swift_willThrow();
              return swift_bridgeObjectRelease();
            }
            uint64_t v16 = ~v11;
            for (unint64_t i = v12 + 1; ; unint64_t i = v18 + 1)
            {
              uint64_t v18 = i & v16;
              if (((*(void *)(v27 + (((i & v16) >> 3) & 0xFFFFFFFFFFFFFF8)) >> (i & v16)) & 1) == 0) {
                break;
              }
              uint64_t v19 = v13 + 16 * v18;
              BOOL v20 = *(void *)v19 == v8._countAndFlagsBits && *(void **)(v19 + 8) == v8._object;
              if (v20 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0) {
                goto LABEL_21;
              }
            }
          }
        }
        swift_bridgeObjectRelease();
        uint64_t v3 = v9;
        uint64_t v4 = v24;
        uint64_t v2 = v25;
      }
      ++v5;
      outlined destroy of ResultColumn((uint64_t)v26);
    }
    while (v5 != v2);
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t specialized Sequence.forEach(_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 16);
  if (v3)
  {
    uint64_t v6 = result + 32;
    swift_bridgeObjectRetain();
    while (1)
    {
      Swift::String v7 = AggregationFunction.name()();
      Swift::String v8 = String.lowercased()();
      char v9 = specialized Set.contains(_:)(v8._countAndFlagsBits, (uint64_t)v8._object, a2);
      swift_bridgeObjectRelease();
      if (v9)
      {
        unint64_t v12 = 0xD000000000000051;
        unint64_t v13 = 0x800000018EBF7E10;
        goto LABEL_9;
      }
      Swift::String v10 = String.lowercased()();
      char v11 = specialized Set.contains(_:)(v10._countAndFlagsBits, (uint64_t)v10._object, a3);
      swift_bridgeObjectRelease();
      if (v11) {
        break;
      }
      swift_bridgeObjectRelease();
      v6 += 200;
      if (!--v3) {
        return swift_bridgeObjectRelease();
      }
    }
    unint64_t v13 = 0x800000018EBF7DB0;
    unint64_t v12 = 0xD000000000000050;
LABEL_9:
    lazy protocol witness table accessor for type SQLParserError and conformance SQLParserError();
    swift_allocError();
    *(Swift::String *)uint64_t v14 = v7;
    *(void *)(v14 + 16) = v12;
    *(void *)(v14 + 24) = v13;
    *(unsigned char *)(v14 + 32) = 7;
    swift_willThrow();
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t specialized SelectCore.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 1836020326 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x6572656877 && a2 == 0xE500000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0x794270756F7267 && a2 == 0xE700000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x676E69766168 && a2 == 0xE600000000000000 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else if (a1 == 0x7463656C6573 && a2 == 0xE600000000000000)
  {
    swift_bridgeObjectRelease();
    return 4;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 4;
    }
    else {
      return 5;
    }
  }
}

uint64_t specialized MaterializedView.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 1701667182 && a2 == 0xE400000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x7463656C6573 && a2 == 0xE600000000000000)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

uint64_t specialized LogicalPlan.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 7106931 && a2 == 0xE300000000000000;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0x746E656D75636F64 && a2 == 0xED00006E6F697461 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x800000018EBEA1B0 {
         || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  }
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else if (a1 == 0x6F437463656C6573 && a2 == 0xEA00000000006572)
  {
    swift_bridgeObjectRelease();
    return 3;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 3;
    }
    else {
      return 4;
    }
  }
}

uint64_t specialized LogicalPlanType.CodingKeys.init(stringValue:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x6F437463656C6573 && a2 == 0xEA00000000006572;
  if (v2 || (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000010 && a2 == 0x800000018EBEA1B0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else
  {
    char v6 = _stringCompareWithSmolCheck(_:_:expecting:)();
    swift_bridgeObjectRelease();
    if (v6) {
      return 1;
    }
    else {
      return 2;
    }
  }
}

uint64_t specialized Data.InlineData.init(_:)(unsigned char *__src, unsigned char *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (__src) {
    unint64_t v2 = a2 - __src;
  }
  else {
    unint64_t v2 = 0;
  }
  if ((v2 & 0x8000000000000000) != 0)
  {
    __break(1u);
LABEL_11:
    __break(1u);
  }
  if (v2 > 0xFF) {
    goto LABEL_11;
  }
  memset(__dst, 0, sizeof(__dst));
  char v5 = v2;
  if (__src && a2 != __src) {
    memcpy(__dst, __src, a2 - __src);
  }
  return *(void *)__dst;
}

uint64_t specialized Data.init(bytes:count:)(unsigned char *__src, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 <= 14) {
    return specialized Data.InlineData.init(_:)(__src, &__src[a2]);
  }
  type metadata accessor for __DataStorage();
  swift_allocObject();
  __DataStorage.init(bytes:length:)();
  if ((unint64_t)a2 < 0x7FFFFFFF) {
    return a2 << 32;
  }
  type metadata accessor for Data.RangeReference();
  uint64_t result = swift_allocObject();
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t lazy protocol witness table accessor for type PgQuery_ParseResult and conformance PgQuery_ParseResult(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t outlined init with take of PgQuery_ParseResult(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t outlined destroy of PgQuery_ParseResult(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

unint64_t lazy protocol witness table accessor for type SQLRawDataType and conformance SQLRawDataType()
{
  unint64_t result = lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType;
  if (!lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type SQLRawDataType and conformance SQLRawDataType);
  }
  return result;
}

uint64_t outlined copy of SQLParserError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  if (a5 <= 8u)
  {
    if (((1 << a5) & 0x16E) == 0) {
      swift_bridgeObjectRetain();
    }
    return swift_bridgeObjectRetain();
  }
  return result;
}

uint64_t destroy for SQLParserError(uint64_t a1)
{
  return outlined consume of SQLParserError(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 32));
}

uint64_t outlined consume of SQLParserError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  if (a5 <= 8u)
  {
    if (((1 << a5) & 0x16E) == 0) {
      swift_bridgeObjectRelease();
    }
    return swift_bridgeObjectRelease();
  }
  return result;
}

uint64_t initializeWithCopy for SQLParserError(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unsigned __int8 v7 = *(unsigned char *)(a2 + 32);
  outlined copy of SQLParserError(*(void *)a2, v4, v5, v6, v7);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  *(unsigned char *)(a1 + 32) = v7;
  return a1;
}

uint64_t assignWithCopy for SQLParserError(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  unsigned __int8 v7 = *(unsigned char *)(a2 + 32);
  outlined copy of SQLParserError(*(void *)a2, v4, v5, v6, v7);
  uint64_t v8 = *(void *)a1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(a1 + 24);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a1 + 24) = v6;
  unsigned __int8 v12 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v7;
  outlined consume of SQLParserError(v8, v9, v10, v11, v12);
  return a1;
}

uint64_t assignWithTake for SQLParserError(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 32);
  uint64_t v4 = *(void *)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  long long v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v8;
  unsigned __int8 v9 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v3;
  outlined consume of SQLParserError(v4, v6, v5, v7, v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLParserError(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xF7 && *(unsigned char *)(a1 + 33)) {
    return (*(_DWORD *)a1 + 247);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 32);
  if (v3 <= 9) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLParserError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xF6)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(unsigned char *)(result + 32) = 0;
    *(void *)uint64_t result = a2 - 247;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xF7) {
      *(unsigned char *)(result + 33) = 1;
    }
  }
  else
  {
    if (a3 >= 0xF7) {
      *(unsigned char *)(result + 33) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 32) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTag for SQLParserError(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 32) <= 8u) {
    return *(unsigned __int8 *)(a1 + 32);
  }
  else {
    return (*(_DWORD *)a1 + 9);
  }
}

uint64_t destructiveInjectEnumTag for SQLParserError(uint64_t result, unsigned int a2)
{
  if (a2 >= 9)
  {
    *(void *)uint64_t result = a2 - 9;
    *(void *)(result + 8) = 0;
    LOBYTE(a2) = 9;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
  }
  *(unsigned char *)(result + 32) = a2;
  return result;
}

ValueMetadata *type metadata accessor for SQLParserError()
{
  return &type metadata for SQLParserError;
}

ValueMetadata *type metadata accessor for DatabaseCatalog()
{
  return &type metadata for DatabaseCatalog;
}

void *assignWithCopy for Schema(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for Schema(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithCopy for FromClause(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  int v4 = (_OWORD *)(a1 + 8);
  uint64_t v5 = (_OWORD *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 32);
  if (*(void *)(a1 + 32))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 8), (uint64_t *)(a2 + 8));
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(void *)(a1 + 56) = *(void *)(a2 + 56);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = *(void *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 8);
      long long v7 = *(_OWORD *)(a2 + 24);
      *int v4 = *v5;
      *(_OWORD *)(a1 + 24) = v7;
      long long v8 = *(_OWORD *)(a2 + 88);
      long long v10 = *(_OWORD *)(a2 + 40);
      long long v9 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v8;
      *(_OWORD *)(a1 + 40) = v10;
      *(_OWORD *)(a1 + 56) = v9;
    }
  }
  else if (v6)
  {
    *(void *)(a1 + 32) = v6;
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 24);
    *int v4 = *v5;
    *(_OWORD *)(a1 + 24) = v11;
    long long v12 = *(_OWORD *)(a2 + 40);
    long long v13 = *(_OWORD *)(a2 + 56);
    long long v14 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 40) = v12;
    *(_OWORD *)(a1 + 56) = v13;
  }
  return a1;
}

__n128 __swift_memcpy104_8(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)a1 = v2;
  __n128 result = (__n128)a2[3];
  long long v5 = a2[4];
  long long v6 = a2[5];
  *(void *)(a1 + 96) = *((void *)a2 + 12);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

uint64_t assignWithTake for FromClause(uint64_t a1, uint64_t a2)
{
  int v4 = (_OWORD *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  long long v5 = (_OWORD *)(a1 + 8);
  if (!*(void *)(a1 + 32)) {
    goto LABEL_5;
  }
  if (!*(void *)(a2 + 32))
  {
    outlined destroy of SQLExpression(a1 + 8);
LABEL_5:
    long long v9 = v4[3];
    *(_OWORD *)(a1 + 40) = v4[2];
    *(_OWORD *)(a1 + 56) = v9;
    long long v10 = v4[5];
    *(_OWORD *)(a1 + 72) = v4[4];
    *(_OWORD *)(a1 + 88) = v10;
    long long v11 = v4[1];
    *long long v5 = *v4;
    *(_OWORD *)(a1 + 24) = v11;
    return a1;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
  long long v6 = v4[1];
  *long long v5 = *v4;
  *(_OWORD *)(a1 + 24) = v6;
  *(void *)(a1 + 40) = *((void *)v4 + 4);
  uint64_t v7 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v7;
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  swift_bridgeObjectRelease();
  uint64_t v8 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v8;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for FromClause(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 104)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for FromClause(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 104) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 104) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t assignWithCopy for ResultColumn(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for ResultColumn(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease();
  uint64_t v5 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v5;
  swift_bridgeObjectRelease();
  uint64_t v6 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v6;
  swift_bridgeObjectRelease();
  uint64_t v7 = *(void *)(a2 + 120);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = v7;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for ResultColumn(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 128)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ResultColumn(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 120) = 0;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 128) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 128) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t assignWithCopy for SelectCore(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  long long v4 = (_OWORD *)(a1 + 8);
  uint64_t v5 = (_OWORD *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 32);
  if (*(void *)(a1 + 32))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 8), (uint64_t *)(a2 + 8));
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(void *)(a1 + 56) = *(void *)(a2 + 56);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = *(void *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 8);
      long long v7 = *(_OWORD *)(a2 + 24);
      *long long v4 = *v5;
      *(_OWORD *)(a1 + 24) = v7;
      long long v8 = *(_OWORD *)(a2 + 88);
      long long v10 = *(_OWORD *)(a2 + 40);
      long long v9 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v8;
      *(_OWORD *)(a1 + 40) = v10;
      *(_OWORD *)(a1 + 56) = v9;
    }
  }
  else if (v6)
  {
    *(void *)(a1 + 32) = v6;
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 24);
    *long long v4 = *v5;
    *(_OWORD *)(a1 + 24) = v11;
    long long v12 = *(_OWORD *)(a2 + 40);
    long long v13 = *(_OWORD *)(a2 + 56);
    long long v14 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v14;
    *(_OWORD *)(a1 + 40) = v12;
    *(_OWORD *)(a1 + 56) = v13;
  }
  BOOL v15 = (_OWORD *)(a1 + 104);
  uint64_t v16 = (_OWORD *)(a2 + 104);
  uint64_t v17 = *(void *)(a2 + 128);
  if (*(void *)(a1 + 128))
  {
    if (v17)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 104), (uint64_t *)(a2 + 104));
      *(void *)(a1 + 144) = *(void *)(a2 + 144);
      *(void *)(a1 + 152) = *(void *)(a2 + 152);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
      *(void *)(a1 + 168) = *(void *)(a2 + 168);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 176) = *(void *)(a2 + 176);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      *(void *)(a1 + 192) = *(void *)(a2 + 192);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 104);
      long long v18 = *(_OWORD *)(a2 + 120);
      *BOOL v15 = *v16;
      *(_OWORD *)(a1 + 120) = v18;
      long long v19 = *(_OWORD *)(a2 + 184);
      long long v21 = *(_OWORD *)(a2 + 136);
      long long v20 = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = v19;
      *(_OWORD *)(a1 + 136) = v21;
      *(_OWORD *)(a1 + 152) = v20;
    }
  }
  else if (v17)
  {
    *(void *)(a1 + 128) = v17;
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    (**(void (***)(uint64_t, uint64_t))(v17 - 8))(a1 + 104, a2 + 104);
    *(void *)(a1 + 144) = *(void *)(a2 + 144);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
    *(void *)(a1 + 168) = *(void *)(a2 + 168);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v22 = *(_OWORD *)(a2 + 120);
    *BOOL v15 = *v16;
    *(_OWORD *)(a1 + 120) = v22;
    long long v23 = *(_OWORD *)(a2 + 136);
    long long v24 = *(_OWORD *)(a2 + 152);
    long long v25 = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 184) = v25;
    *(_OWORD *)(a1 + 136) = v23;
    *(_OWORD *)(a1 + 152) = v24;
  }
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  unint64_t v26 = (_OWORD *)(a1 + 208);
  uint64_t v27 = (_OWORD *)(a2 + 208);
  uint64_t v28 = *(void *)(a2 + 232);
  if (*(void *)(a1 + 232))
  {
    if (v28)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 208), (uint64_t *)(a2 + 208));
      *(void *)(a1 + 248) = *(void *)(a2 + 248);
      *(void *)(a1 + 256) = *(void *)(a2 + 256);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
      *(void *)(a1 + 272) = *(void *)(a2 + 272);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 280) = *(void *)(a2 + 280);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 288) = *(void *)(a2 + 288);
      *(void *)(a1 + 296) = *(void *)(a2 + 296);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 208);
      long long v29 = *(_OWORD *)(a2 + 224);
      *unint64_t v26 = *v27;
      *(_OWORD *)(a1 + 224) = v29;
      long long v30 = *(_OWORD *)(a2 + 288);
      long long v32 = *(_OWORD *)(a2 + 240);
      long long v31 = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = v30;
      *(_OWORD *)(a1 + 240) = v32;
      *(_OWORD *)(a1 + 256) = v31;
    }
  }
  else if (v28)
  {
    *(void *)(a1 + 232) = v28;
    *(void *)(a1 + 240) = *(void *)(a2 + 240);
    (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1 + 208, a2 + 208);
    *(void *)(a1 + 248) = *(void *)(a2 + 248);
    *(void *)(a1 + 256) = *(void *)(a2 + 256);
    *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
    *(void *)(a1 + 272) = *(void *)(a2 + 272);
    *(void *)(a1 + 280) = *(void *)(a2 + 280);
    *(void *)(a1 + 288) = *(void *)(a2 + 288);
    *(void *)(a1 + 296) = *(void *)(a2 + 296);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v33 = *(_OWORD *)(a2 + 224);
    *unint64_t v26 = *v27;
    *(_OWORD *)(a1 + 224) = v33;
    long long v34 = *(_OWORD *)(a2 + 240);
    long long v35 = *(_OWORD *)(a2 + 256);
    long long v36 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v36;
    *(_OWORD *)(a1 + 240) = v34;
    *(_OWORD *)(a1 + 256) = v35;
  }
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for SelectCore(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 8;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  uint64_t v5 = (_OWORD *)(a1 + 8);
  if (*(void *)(a1 + 32))
  {
    if (*(void *)(a2 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      long long v6 = *(_OWORD *)(v4 + 16);
      *uint64_t v5 = *(_OWORD *)v4;
      *(_OWORD *)(a1 + 24) = v6;
      *(void *)(a1 + 40) = *(void *)(v4 + 32);
      uint64_t v7 = *(void *)(a2 + 56);
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(void *)(a1 + 56) = v7;
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      swift_bridgeObjectRelease();
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      swift_bridgeObjectRelease();
      uint64_t v8 = *(void *)(a2 + 96);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = v8;
      swift_bridgeObjectRelease();
      goto LABEL_6;
    }
    outlined destroy of SQLExpression(a1 + 8);
  }
  long long v9 = *(_OWORD *)(v4 + 48);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(v4 + 32);
  *(_OWORD *)(a1 + 56) = v9;
  long long v10 = *(_OWORD *)(v4 + 80);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(v4 + 64);
  *(_OWORD *)(a1 + 88) = v10;
  long long v11 = *(_OWORD *)(v4 + 16);
  *uint64_t v5 = *(_OWORD *)v4;
  *(_OWORD *)(a1 + 24) = v11;
LABEL_6:
  long long v12 = (_OWORD *)(a1 + 104);
  long long v13 = (_OWORD *)(a2 + 104);
  if (*(void *)(a1 + 128))
  {
    if (*(void *)(a2 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      long long v14 = *(_OWORD *)(a2 + 120);
      *long long v12 = *v13;
      *(_OWORD *)(a1 + 120) = v14;
      *(void *)(a1 + 136) = *(void *)(a2 + 136);
      uint64_t v15 = *(void *)(a2 + 152);
      *(void *)(a1 + 144) = *(void *)(a2 + 144);
      *(void *)(a1 + 152) = v15;
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
      *(void *)(a1 + 168) = *(void *)(a2 + 168);
      swift_bridgeObjectRelease();
      *(void *)(a1 + 176) = *(void *)(a2 + 176);
      swift_bridgeObjectRelease();
      uint64_t v16 = *(void *)(a2 + 192);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      *(void *)(a1 + 192) = v16;
      swift_bridgeObjectRelease();
      goto LABEL_11;
    }
    outlined destroy of SQLExpression(a1 + 104);
  }
  long long v17 = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 152) = v17;
  long long v18 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 184) = v18;
  long long v19 = *(_OWORD *)(a2 + 120);
  *long long v12 = *v13;
  *(_OWORD *)(a1 + 120) = v19;
LABEL_11:
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  swift_bridgeObjectRelease();
  long long v20 = (_OWORD *)(a1 + 208);
  long long v21 = (_OWORD *)(a2 + 208);
  if (!*(void *)(a1 + 232))
  {
LABEL_15:
    long long v25 = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
    *(_OWORD *)(a1 + 256) = v25;
    long long v26 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v26;
    long long v27 = *(_OWORD *)(a2 + 224);
    *long long v20 = *v21;
    *(_OWORD *)(a1 + 224) = v27;
    goto LABEL_16;
  }
  if (!*(void *)(a2 + 232))
  {
    outlined destroy of SQLExpression(a1 + 208);
    goto LABEL_15;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
  long long v22 = *(_OWORD *)(a2 + 224);
  *long long v20 = *v21;
  *(_OWORD *)(a1 + 224) = v22;
  *(void *)(a1 + 240) = *(void *)(a2 + 240);
  uint64_t v23 = *(void *)(a2 + 256);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a1 + 256) = v23;
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
  *(void *)(a1 + 272) = *(void *)(a2 + 272);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  swift_bridgeObjectRelease();
  uint64_t v24 = *(void *)(a2 + 296);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(void *)(a1 + 296) = v24;
  swift_bridgeObjectRelease();
LABEL_16:
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SelectCore(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 312)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for SelectCore(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 312) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 312) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t assignWithCopy for MaterializedView(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v4 = (_OWORD *)(a1 + 24);
  uint64_t v5 = (_OWORD *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 48);
  if (*(void *)(a1 + 48))
  {
    if (v6)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 24), (uint64_t *)(a2 + 24));
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 96) = *(void *)(a2 + 96);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 104) = *(void *)(a2 + 104);
      *(void *)(a1 + 112) = *(void *)(a2 + 112);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 24);
      long long v7 = *(_OWORD *)(a2 + 40);
      *uint64_t v4 = *v5;
      *(_OWORD *)(a1 + 40) = v7;
      long long v8 = *(_OWORD *)(a2 + 104);
      long long v10 = *(_OWORD *)(a2 + 56);
      long long v9 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v8;
      *(_OWORD *)(a1 + 56) = v10;
      *(_OWORD *)(a1 + 72) = v9;
    }
  }
  else if (v6)
  {
    *(void *)(a1 + 48) = v6;
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    (**(void (***)(uint64_t, uint64_t))(v6 - 8))(a1 + 24, a2 + 24);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 40);
    *uint64_t v4 = *v5;
    *(_OWORD *)(a1 + 40) = v11;
    long long v12 = *(_OWORD *)(a2 + 56);
    long long v13 = *(_OWORD *)(a2 + 72);
    long long v14 = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 104) = v14;
    *(_OWORD *)(a1 + 56) = v12;
    *(_OWORD *)(a1 + 72) = v13;
  }
  uint64_t v15 = (_OWORD *)(a1 + 120);
  uint64_t v16 = (_OWORD *)(a2 + 120);
  uint64_t v17 = *(void *)(a2 + 144);
  if (*(void *)(a1 + 144))
  {
    if (v17)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 120), (uint64_t *)(a2 + 120));
      *(void *)(a1 + 160) = *(void *)(a2 + 160);
      *(void *)(a1 + 168) = *(void *)(a2 + 168);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 192) = *(void *)(a2 + 192);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      *(void *)(a1 + 208) = *(void *)(a2 + 208);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 120);
      long long v18 = *(_OWORD *)(a2 + 136);
      *uint64_t v15 = *v16;
      *(_OWORD *)(a1 + 136) = v18;
      long long v19 = *(_OWORD *)(a2 + 200);
      long long v21 = *(_OWORD *)(a2 + 152);
      long long v20 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v19;
      *(_OWORD *)(a1 + 152) = v21;
      *(_OWORD *)(a1 + 168) = v20;
    }
  }
  else if (v17)
  {
    *(void *)(a1 + 144) = v17;
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    (**(void (***)(uint64_t, uint64_t))(v17 - 8))(a1 + 120, a2 + 120);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(void *)(a1 + 168) = *(void *)(a2 + 168);
    *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(void *)(a1 + 200) = *(void *)(a2 + 200);
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v22 = *(_OWORD *)(a2 + 136);
    *uint64_t v15 = *v16;
    *(_OWORD *)(a1 + 136) = v22;
    long long v23 = *(_OWORD *)(a2 + 152);
    long long v24 = *(_OWORD *)(a2 + 168);
    long long v25 = *(_OWORD *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 200) = v25;
    *(_OWORD *)(a1 + 152) = v23;
    *(_OWORD *)(a1 + 168) = v24;
  }
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  long long v26 = (_OWORD *)(a1 + 224);
  long long v27 = (_OWORD *)(a2 + 224);
  uint64_t v28 = *(void *)(a2 + 248);
  if (*(void *)(a1 + 248))
  {
    if (v28)
    {
      __swift_assign_boxed_opaque_existential_1((uint64_t *)(a1 + 224), (uint64_t *)(a2 + 224));
      *(void *)(a1 + 264) = *(void *)(a2 + 264);
      *(void *)(a1 + 272) = *(void *)(a2 + 272);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
      *(void *)(a1 + 288) = *(void *)(a2 + 288);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 296) = *(void *)(a2 + 296);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      *(void *)(a1 + 304) = *(void *)(a2 + 304);
      *(void *)(a1 + 312) = *(void *)(a2 + 312);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
    }
    else
    {
      outlined destroy of SQLExpression(a1 + 224);
      long long v29 = *(_OWORD *)(a2 + 240);
      *long long v26 = *v27;
      *(_OWORD *)(a1 + 240) = v29;
      long long v30 = *(_OWORD *)(a2 + 304);
      long long v32 = *(_OWORD *)(a2 + 256);
      long long v31 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v30;
      *(_OWORD *)(a1 + 256) = v32;
      *(_OWORD *)(a1 + 272) = v31;
    }
  }
  else if (v28)
  {
    *(void *)(a1 + 248) = v28;
    *(void *)(a1 + 256) = *(void *)(a2 + 256);
    (**(void (***)(uint64_t, uint64_t))(v28 - 8))(a1 + 224, a2 + 224);
    *(void *)(a1 + 264) = *(void *)(a2 + 264);
    *(void *)(a1 + 272) = *(void *)(a2 + 272);
    *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
    *(void *)(a1 + 288) = *(void *)(a2 + 288);
    *(void *)(a1 + 296) = *(void *)(a2 + 296);
    *(void *)(a1 + 304) = *(void *)(a2 + 304);
    *(void *)(a1 + 312) = *(void *)(a2 + 312);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v33 = *(_OWORD *)(a2 + 240);
    *long long v26 = *v27;
    *(_OWORD *)(a1 + 240) = v33;
    long long v34 = *(_OWORD *)(a2 + 256);
    long long v35 = *(_OWORD *)(a2 + 272);
    long long v36 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 304) = v36;
    *(_OWORD *)(a1 + 256) = v34;
    *(_OWORD *)(a1 + 272) = v35;
  }
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t assignWithTake for MaterializedView(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRelease();
  uint64_t v5 = (_OWORD *)(a1 + 24);
  uint64_t v6 = (_OWORD *)(a2 + 24);
  if (*(void *)(a1 + 48))
  {
    if (*(void *)(a2 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      long long v7 = *(_OWORD *)(a2 + 40);
      *uint64_t v5 = *v6;
      *(_OWORD *)(a1 + 40) = v7;
      *(void *)(a1 + 56) = *(void *)(a2 + 56);
      uint64_t v8 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v8;
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      swift_bridgeObjectRelease();
      *(void *)(a1 + 96) = *(void *)(a2 + 96);
      swift_bridgeObjectRelease();
      uint64_t v9 = *(void *)(a2 + 112);
      *(void *)(a1 + 104) = *(void *)(a2 + 104);
      *(void *)(a1 + 112) = v9;
      swift_bridgeObjectRelease();
      goto LABEL_6;
    }
    outlined destroy of SQLExpression(a1 + 24);
  }
  long long v10 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = v10;
  long long v11 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = v11;
  long long v12 = *(_OWORD *)(a2 + 40);
  *uint64_t v5 = *v6;
  *(_OWORD *)(a1 + 40) = v12;
LABEL_6:
  long long v13 = (_OWORD *)(a1 + 120);
  long long v14 = (_OWORD *)(a2 + 120);
  if (*(void *)(a1 + 144))
  {
    if (*(void *)(a2 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      long long v15 = *(_OWORD *)(a2 + 136);
      *long long v13 = *v14;
      *(_OWORD *)(a1 + 136) = v15;
      *(void *)(a1 + 152) = *(void *)(a2 + 152);
      uint64_t v16 = *(void *)(a2 + 168);
      *(void *)(a1 + 160) = *(void *)(a2 + 160);
      *(void *)(a1 + 168) = v16;
      swift_bridgeObjectRelease();
      *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      swift_bridgeObjectRelease();
      *(void *)(a1 + 192) = *(void *)(a2 + 192);
      swift_bridgeObjectRelease();
      uint64_t v17 = *(void *)(a2 + 208);
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      *(void *)(a1 + 208) = v17;
      swift_bridgeObjectRelease();
      goto LABEL_11;
    }
    outlined destroy of SQLExpression(a1 + 120);
  }
  long long v18 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 168) = v18;
  long long v19 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 200) = v19;
  long long v20 = *(_OWORD *)(a2 + 136);
  *long long v13 = *v14;
  *(_OWORD *)(a1 + 136) = v20;
LABEL_11:
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  swift_bridgeObjectRelease();
  long long v21 = (_OWORD *)(a1 + 224);
  long long v22 = (_OWORD *)(a2 + 224);
  if (!*(void *)(a1 + 248))
  {
LABEL_15:
    long long v26 = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 272) = v26;
    long long v27 = *(_OWORD *)(a2 + 304);
    *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 304) = v27;
    long long v28 = *(_OWORD *)(a2 + 240);
    *long long v21 = *v22;
    *(_OWORD *)(a1 + 240) = v28;
    goto LABEL_16;
  }
  if (!*(void *)(a2 + 248))
  {
    outlined destroy of SQLExpression(a1 + 224);
    goto LABEL_15;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
  long long v23 = *(_OWORD *)(a2 + 240);
  *long long v21 = *v22;
  *(_OWORD *)(a1 + 240) = v23;
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  uint64_t v24 = *(void *)(a2 + 272);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(void *)(a1 + 272) = v24;
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  swift_bridgeObjectRelease();
  uint64_t v25 = *(void *)(a2 + 312);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(void *)(a1 + 312) = v25;
  swift_bridgeObjectRelease();
LABEL_16:
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t storeEnumTagSinglePayload for MaterializedView(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 328) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 328) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t destroy for LogicalPlan(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 328))
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(void *)(a1 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 248))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(void *)(a1 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 232))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for LogicalPlan(uint64_t a1, uint64_t a2)
{
  char v4 = *(unsigned char *)(a2 + 328);
  if (v4)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    uint64_t v6 = (_OWORD *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 56);
      *(void *)(a1 + 48) = v7;
      *(void *)(a1 + 56) = v8;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 24, a2 + 24, v7);
      uint64_t v9 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v9;
      *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
      uint64_t v10 = *(void *)(a2 + 96);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = v10;
      uint64_t v11 = *(void *)(a2 + 112);
      *(void *)(a1 + 104) = *(void *)(a2 + 104);
      *(void *)(a1 + 112) = v11;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v19 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = v19;
      long long v20 = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v20;
      long long v21 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 24) = *v6;
      *(_OWORD *)(a1 + 40) = v21;
    }
    long long v22 = (_OWORD *)(a1 + 120);
    long long v23 = (_OWORD *)(a2 + 120);
    uint64_t v24 = *(void *)(a2 + 144);
    if (v24)
    {
      uint64_t v25 = *(void *)(a2 + 152);
      *(void *)(a1 + 144) = v24;
      *(void *)(a1 + 152) = v25;
      (**(void (***)(_OWORD *, _OWORD *))(v24 - 8))(v22, v23);
      uint64_t v26 = *(void *)(a2 + 168);
      *(void *)(a1 + 160) = *(void *)(a2 + 160);
      *(void *)(a1 + 168) = v26;
      *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
      uint64_t v27 = *(void *)(a2 + 192);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      *(void *)(a1 + 192) = v27;
      uint64_t v28 = *(void *)(a2 + 208);
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      *(void *)(a1 + 208) = v28;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v39 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = v39;
      long long v40 = *(_OWORD *)(a2 + 200);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v40;
      long long v41 = *(_OWORD *)(a2 + 136);
      *long long v22 = *v23;
      *(_OWORD *)(a1 + 136) = v41;
    }
    *(void *)(a1 + 216) = *(void *)(a2 + 216);
    uint64_t v42 = *(void *)(a2 + 248);
    swift_bridgeObjectRetain();
    if (v42)
    {
      uint64_t v43 = *(void *)(a2 + 256);
      *(void *)(a1 + 248) = v42;
      *(void *)(a1 + 256) = v43;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v42 - 8))(a1 + 224, a2 + 224, v42);
      uint64_t v44 = *(void *)(a2 + 272);
      *(void *)(a1 + 264) = *(void *)(a2 + 264);
      *(void *)(a1 + 272) = v44;
      *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
      uint64_t v45 = *(void *)(a2 + 296);
      *(void *)(a1 + 288) = *(void *)(a2 + 288);
      *(void *)(a1 + 296) = v45;
      uint64_t v46 = *(void *)(a2 + 312);
      *(void *)(a1 + 304) = *(void *)(a2 + 304);
      *(void *)(a1 + 312) = v46;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v55 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = v55;
      long long v56 = *(_OWORD *)(a2 + 304);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v56;
      long long v57 = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 240) = v57;
    }
    *(void *)(a1 + 320) = *(void *)(a2 + 320);
  }
  else
  {
    *(void *)a1 = *(void *)a2;
    long long v12 = (_OWORD *)(a1 + 8);
    long long v13 = (_OWORD *)(a2 + 8);
    uint64_t v14 = *(void *)(a2 + 32);
    swift_bridgeObjectRetain();
    if (v14)
    {
      uint64_t v15 = *(void *)(a2 + 40);
      *(void *)(a1 + 32) = v14;
      *(void *)(a1 + 40) = v15;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v14 - 8))(a1 + 8, a2 + 8, v14);
      uint64_t v16 = *(void *)(a2 + 56);
      *(void *)(a1 + 48) = *(void *)(a2 + 48);
      *(void *)(a1 + 56) = v16;
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
      uint64_t v17 = *(void *)(a2 + 80);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      *(void *)(a1 + 80) = v17;
      uint64_t v18 = *(void *)(a2 + 96);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = v18;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v29 = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 56) = v29;
      long long v30 = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 88) = v30;
      long long v31 = *(_OWORD *)(a2 + 24);
      *long long v12 = *v13;
      *(_OWORD *)(a1 + 24) = v31;
    }
    long long v32 = (_OWORD *)(a1 + 104);
    long long v33 = (_OWORD *)(a2 + 104);
    uint64_t v34 = *(void *)(a2 + 128);
    if (v34)
    {
      uint64_t v35 = *(void *)(a2 + 136);
      *(void *)(a1 + 128) = v34;
      *(void *)(a1 + 136) = v35;
      (**(void (***)(_OWORD *, _OWORD *))(v34 - 8))(v32, v33);
      uint64_t v36 = *(void *)(a2 + 152);
      *(void *)(a1 + 144) = *(void *)(a2 + 144);
      *(void *)(a1 + 152) = v36;
      *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
      uint64_t v37 = *(void *)(a2 + 176);
      *(void *)(a1 + 168) = *(void *)(a2 + 168);
      *(void *)(a1 + 176) = v37;
      uint64_t v38 = *(void *)(a2 + 192);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      *(void *)(a1 + 192) = v38;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v47 = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
      *(_OWORD *)(a1 + 152) = v47;
      long long v48 = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 184) = v48;
      long long v49 = *(_OWORD *)(a2 + 120);
      *long long v32 = *v33;
      *(_OWORD *)(a1 + 120) = v49;
    }
    *(void *)(a1 + 200) = *(void *)(a2 + 200);
    uint64_t v50 = *(void *)(a2 + 232);
    swift_bridgeObjectRetain();
    if (v50)
    {
      uint64_t v51 = *(void *)(a2 + 240);
      *(void *)(a1 + 232) = v50;
      *(void *)(a1 + 240) = v51;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v50 - 8))(a1 + 208, a2 + 208, v50);
      uint64_t v52 = *(void *)(a2 + 256);
      *(void *)(a1 + 248) = *(void *)(a2 + 248);
      *(void *)(a1 + 256) = v52;
      *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
      uint64_t v53 = *(void *)(a2 + 280);
      *(void *)(a1 + 272) = *(void *)(a2 + 272);
      *(void *)(a1 + 280) = v53;
      uint64_t v54 = *(void *)(a2 + 296);
      *(void *)(a1 + 288) = *(void *)(a2 + 288);
      *(void *)(a1 + 296) = v54;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v58 = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 256) = v58;
      long long v59 = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 288) = v59;
      long long v60 = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
      *(_OWORD *)(a1 + 224) = v60;
    }
    *(void *)(a1 + 304) = *(void *)(a2 + 304);
  }
  *(unsigned char *)(a1 + 328) = v4;
  swift_bridgeObjectRetain();
  uint64_t v61 = *(void *)(a2 + 344);
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(void *)(a1 + 344) = v61;
  uint64_t v62 = *(void *)(a2 + 352);
  uint64_t v63 = *(void *)(a2 + 360);
  *(void *)(a1 + 352) = v62;
  *(void *)(a1 + 360) = v63;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for LogicalPlan(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    outlined destroy of LogicalPlanType(a1);
    char v4 = *(unsigned char *)(a2 + 328);
    if (v4)
    {
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      uint64_t v5 = *(void *)(a2 + 48);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v5)
      {
        *(void *)(a1 + 48) = v5;
        *(void *)(a1 + 56) = *(void *)(a2 + 56);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v5 - 8))(a1 + 24, a2 + 24, v5);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(void *)(a1 + 96) = *(void *)(a2 + 96);
        *(void *)(a1 + 104) = *(void *)(a2 + 104);
        *(void *)(a1 + 112) = *(void *)(a2 + 112);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v7 = *(_OWORD *)(a2 + 40);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 40) = v7;
        long long v8 = *(_OWORD *)(a2 + 56);
        long long v9 = *(_OWORD *)(a2 + 72);
        long long v10 = *(_OWORD *)(a2 + 104);
        *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 104) = v10;
        *(_OWORD *)(a1 + 56) = v8;
        *(_OWORD *)(a1 + 72) = v9;
      }
      uint64_t v11 = (_OWORD *)(a1 + 120);
      long long v12 = (_OWORD *)(a2 + 120);
      uint64_t v13 = *(void *)(a2 + 144);
      if (v13)
      {
        *(void *)(a1 + 144) = v13;
        *(void *)(a1 + 152) = *(void *)(a2 + 152);
        (**(void (***)(_OWORD *, _OWORD *))(v13 - 8))(v11, v12);
        *(void *)(a1 + 160) = *(void *)(a2 + 160);
        *(void *)(a1 + 168) = *(void *)(a2 + 168);
        *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
        *(void *)(a1 + 184) = *(void *)(a2 + 184);
        *(void *)(a1 + 192) = *(void *)(a2 + 192);
        *(void *)(a1 + 200) = *(void *)(a2 + 200);
        *(void *)(a1 + 208) = *(void *)(a2 + 208);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v21 = *(_OWORD *)(a2 + 136);
        *uint64_t v11 = *v12;
        *(_OWORD *)(a1 + 136) = v21;
        long long v22 = *(_OWORD *)(a2 + 152);
        long long v23 = *(_OWORD *)(a2 + 168);
        long long v24 = *(_OWORD *)(a2 + 200);
        *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 200) = v24;
        *(_OWORD *)(a1 + 152) = v22;
        *(_OWORD *)(a1 + 168) = v23;
      }
      *(void *)(a1 + 216) = *(void *)(a2 + 216);
      uint64_t v25 = *(void *)(a2 + 248);
      swift_bridgeObjectRetain();
      if (v25)
      {
        *(void *)(a1 + 248) = v25;
        *(void *)(a1 + 256) = *(void *)(a2 + 256);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v25 - 8))(a1 + 224, a2 + 224, v25);
        *(void *)(a1 + 264) = *(void *)(a2 + 264);
        *(void *)(a1 + 272) = *(void *)(a2 + 272);
        *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
        *(void *)(a1 + 288) = *(void *)(a2 + 288);
        *(void *)(a1 + 296) = *(void *)(a2 + 296);
        *(void *)(a1 + 304) = *(void *)(a2 + 304);
        *(void *)(a1 + 312) = *(void *)(a2 + 312);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v31 = *(_OWORD *)(a2 + 240);
        *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 240) = v31;
        long long v32 = *(_OWORD *)(a2 + 256);
        long long v33 = *(_OWORD *)(a2 + 272);
        long long v34 = *(_OWORD *)(a2 + 304);
        *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 304) = v34;
        *(_OWORD *)(a1 + 256) = v32;
        *(_OWORD *)(a1 + 272) = v33;
      }
      *(void *)(a1 + 320) = *(void *)(a2 + 320);
    }
    else
    {
      *(void *)a1 = *(void *)a2;
      uint64_t v6 = *(void *)(a2 + 32);
      swift_bridgeObjectRetain();
      if (v6)
      {
        *(void *)(a1 + 32) = v6;
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v6 - 8))(a1 + 8, a2 + 8, v6);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(void *)(a1 + 56) = *(void *)(a2 + 56);
        *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(void *)(a1 + 96) = *(void *)(a2 + 96);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v14 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 24) = v14;
        long long v15 = *(_OWORD *)(a2 + 40);
        long long v16 = *(_OWORD *)(a2 + 56);
        long long v17 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a1 + 88) = v17;
        *(_OWORD *)(a1 + 40) = v15;
        *(_OWORD *)(a1 + 56) = v16;
      }
      uint64_t v18 = (_OWORD *)(a1 + 104);
      long long v19 = (_OWORD *)(a2 + 104);
      uint64_t v20 = *(void *)(a2 + 128);
      if (v20)
      {
        *(void *)(a1 + 128) = v20;
        *(void *)(a1 + 136) = *(void *)(a2 + 136);
        (**(void (***)(_OWORD *, _OWORD *))(v20 - 8))(v18, v19);
        *(void *)(a1 + 144) = *(void *)(a2 + 144);
        *(void *)(a1 + 152) = *(void *)(a2 + 152);
        *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
        *(void *)(a1 + 168) = *(void *)(a2 + 168);
        *(void *)(a1 + 176) = *(void *)(a2 + 176);
        *(void *)(a1 + 184) = *(void *)(a2 + 184);
        *(void *)(a1 + 192) = *(void *)(a2 + 192);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v26 = *(_OWORD *)(a2 + 120);
        *uint64_t v18 = *v19;
        *(_OWORD *)(a1 + 120) = v26;
        long long v27 = *(_OWORD *)(a2 + 136);
        long long v28 = *(_OWORD *)(a2 + 152);
        long long v29 = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
        *(_OWORD *)(a1 + 184) = v29;
        *(_OWORD *)(a1 + 136) = v27;
        *(_OWORD *)(a1 + 152) = v28;
      }
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      uint64_t v30 = *(void *)(a2 + 232);
      swift_bridgeObjectRetain();
      if (v30)
      {
        *(void *)(a1 + 232) = v30;
        *(void *)(a1 + 240) = *(void *)(a2 + 240);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v30 - 8))(a1 + 208, a2 + 208, v30);
        *(void *)(a1 + 248) = *(void *)(a2 + 248);
        *(void *)(a1 + 256) = *(void *)(a2 + 256);
        *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
        *(void *)(a1 + 272) = *(void *)(a2 + 272);
        *(void *)(a1 + 280) = *(void *)(a2 + 280);
        *(void *)(a1 + 288) = *(void *)(a2 + 288);
        *(void *)(a1 + 296) = *(void *)(a2 + 296);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v35 = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
        *(_OWORD *)(a1 + 224) = v35;
        long long v36 = *(_OWORD *)(a2 + 240);
        long long v37 = *(_OWORD *)(a2 + 256);
        long long v38 = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
        *(_OWORD *)(a1 + 288) = v38;
        *(_OWORD *)(a1 + 240) = v36;
        *(_OWORD *)(a1 + 256) = v37;
      }
      *(void *)(a1 + 304) = *(void *)(a2 + 304);
    }
    *(unsigned char *)(a1 + 328) = v4;
    swift_bridgeObjectRetain();
  }
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  *(void *)(a1 + 352) = *(void *)(a2 + 352);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t outlined destroy of LogicalPlanType(uint64_t a1)
{
  return a1;
}

void *__swift_memcpy368_8(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x170uLL);
}

void *assignWithTake for LogicalPlan(void *a1, void *a2)
{
  if (a1 != a2)
  {
    outlined destroy of LogicalPlanType((uint64_t)a1);
    memcpy(a1, a2, 0x149uLL);
  }
  uint64_t v4 = a2[43];
  a1[42] = a2[42];
  a1[43] = v4;
  swift_bridgeObjectRelease();
  uint64_t v5 = a2[45];
  a1[44] = a2[44];
  a1[45] = v5;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for LogicalPlan(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 368)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 344);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for LogicalPlan(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 360) = 0;
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 368) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 344) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 368) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlan()
{
  return &type metadata for LogicalPlan;
}

uint64_t destroy for LogicalPlanType(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 328);
  if (v2 >= 2) {
    unsigned int v2 = *(_DWORD *)a1 + 2;
  }
  if (v2 == 1)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 48))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(void *)(a1 + 144))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 248))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 32))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    if (*(void *)(a1 + 128))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
    swift_bridgeObjectRelease();
    if (*(void *)(a1 + 232))
    {
      __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
    }
  }

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for LogicalPlanType(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int8 *)(a2 + 328);
  if (v4 >= 2)
  {
    if (*(_DWORD *)a2 == -1) {
      goto LABEL_3;
    }
  }
  else if (v4 == 1)
  {
LABEL_3:
    uint64_t v5 = *(void *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    uint64_t v6 = (_OWORD *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 56);
      *(void *)(a1 + 48) = v7;
      *(void *)(a1 + 56) = v8;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 24, a2 + 24, v7);
      uint64_t v9 = *(void *)(a2 + 72);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = v9;
      *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
      uint64_t v10 = *(void *)(a2 + 96);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      *(void *)(a1 + 96) = v10;
      uint64_t v11 = *(void *)(a2 + 112);
      *(void *)(a1 + 104) = *(void *)(a2 + 104);
      *(void *)(a1 + 112) = v11;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v19 = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 72) = v19;
      long long v20 = *(_OWORD *)(a2 + 104);
      *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
      *(_OWORD *)(a1 + 104) = v20;
      long long v21 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 24) = *v6;
      *(_OWORD *)(a1 + 40) = v21;
    }
    long long v22 = (_OWORD *)(a1 + 120);
    long long v23 = (_OWORD *)(a2 + 120);
    uint64_t v24 = *(void *)(a2 + 144);
    if (v24)
    {
      uint64_t v25 = *(void *)(a2 + 152);
      *(void *)(a1 + 144) = v24;
      *(void *)(a1 + 152) = v25;
      (**(void (***)(_OWORD *, _OWORD *))(v24 - 8))(v22, v23);
      uint64_t v26 = *(void *)(a2 + 168);
      *(void *)(a1 + 160) = *(void *)(a2 + 160);
      *(void *)(a1 + 168) = v26;
      *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
      uint64_t v27 = *(void *)(a2 + 192);
      *(void *)(a1 + 184) = *(void *)(a2 + 184);
      *(void *)(a1 + 192) = v27;
      uint64_t v28 = *(void *)(a2 + 208);
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      *(void *)(a1 + 208) = v28;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v39 = *(_OWORD *)(a2 + 168);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
      *(_OWORD *)(a1 + 168) = v39;
      long long v40 = *(_OWORD *)(a2 + 200);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
      *(_OWORD *)(a1 + 200) = v40;
      long long v41 = *(_OWORD *)(a2 + 136);
      *long long v22 = *v23;
      *(_OWORD *)(a1 + 136) = v41;
    }
    *(void *)(a1 + 216) = *(void *)(a2 + 216);
    uint64_t v42 = *(void *)(a2 + 248);
    swift_bridgeObjectRetain();
    if (v42)
    {
      uint64_t v43 = *(void *)(a2 + 256);
      *(void *)(a1 + 248) = v42;
      *(void *)(a1 + 256) = v43;
      (**(void (***)(uint64_t, uint64_t, uint64_t))(v42 - 8))(a1 + 224, a2 + 224, v42);
      uint64_t v44 = *(void *)(a2 + 272);
      *(void *)(a1 + 264) = *(void *)(a2 + 264);
      *(void *)(a1 + 272) = v44;
      *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
      uint64_t v45 = *(void *)(a2 + 296);
      *(void *)(a1 + 288) = *(void *)(a2 + 288);
      *(void *)(a1 + 296) = v45;
      uint64_t v46 = *(void *)(a2 + 312);
      *(void *)(a1 + 304) = *(void *)(a2 + 304);
      *(void *)(a1 + 312) = v46;
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }
    else
    {
      long long v55 = *(_OWORD *)(a2 + 272);
      *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
      *(_OWORD *)(a1 + 272) = v55;
      long long v56 = *(_OWORD *)(a2 + 304);
      *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
      *(_OWORD *)(a1 + 304) = v56;
      long long v57 = *(_OWORD *)(a2 + 240);
      *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
      *(_OWORD *)(a1 + 240) = v57;
    }
    *(void *)(a1 + 320) = *(void *)(a2 + 320);
    char v58 = 1;
    goto LABEL_24;
  }
  *(void *)a1 = *(void *)a2;
  long long v12 = (_OWORD *)(a1 + 8);
  uint64_t v13 = (_OWORD *)(a2 + 8);
  uint64_t v14 = *(void *)(a2 + 32);
  swift_bridgeObjectRetain();
  if (v14)
  {
    uint64_t v15 = *(void *)(a2 + 40);
    *(void *)(a1 + 32) = v14;
    *(void *)(a1 + 40) = v15;
    (**(void (***)(uint64_t, uint64_t, uint64_t))(v14 - 8))(a1 + 8, a2 + 8, v14);
    uint64_t v16 = *(void *)(a2 + 56);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(void *)(a1 + 56) = v16;
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
    uint64_t v17 = *(void *)(a2 + 80);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(void *)(a1 + 80) = v17;
    uint64_t v18 = *(void *)(a2 + 96);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(void *)(a1 + 96) = v18;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v29 = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 56) = v29;
    long long v30 = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 88) = v30;
    long long v31 = *(_OWORD *)(a2 + 24);
    *long long v12 = *v13;
    *(_OWORD *)(a1 + 24) = v31;
  }
  long long v32 = (_OWORD *)(a1 + 104);
  long long v33 = (_OWORD *)(a2 + 104);
  uint64_t v34 = *(void *)(a2 + 128);
  if (v34)
  {
    uint64_t v35 = *(void *)(a2 + 136);
    *(void *)(a1 + 128) = v34;
    *(void *)(a1 + 136) = v35;
    (**(void (***)(_OWORD *, _OWORD *))(v34 - 8))(v32, v33);
    uint64_t v36 = *(void *)(a2 + 152);
    *(void *)(a1 + 144) = *(void *)(a2 + 144);
    *(void *)(a1 + 152) = v36;
    *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
    uint64_t v37 = *(void *)(a2 + 176);
    *(void *)(a1 + 168) = *(void *)(a2 + 168);
    *(void *)(a1 + 176) = v37;
    uint64_t v38 = *(void *)(a2 + 192);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(void *)(a1 + 192) = v38;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v47 = *(_OWORD *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a1 + 152) = v47;
    long long v48 = *(_OWORD *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
    *(_OWORD *)(a1 + 184) = v48;
    long long v49 = *(_OWORD *)(a2 + 120);
    *long long v32 = *v33;
    *(_OWORD *)(a1 + 120) = v49;
  }
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  uint64_t v50 = *(void *)(a2 + 232);
  swift_bridgeObjectRetain();
  if (v50)
  {
    uint64_t v51 = *(void *)(a2 + 240);
    *(void *)(a1 + 232) = v50;
    *(void *)(a1 + 240) = v51;
    (**(void (***)(uint64_t, uint64_t, uint64_t))(v50 - 8))(a1 + 208, a2 + 208, v50);
    uint64_t v52 = *(void *)(a2 + 256);
    *(void *)(a1 + 248) = *(void *)(a2 + 248);
    *(void *)(a1 + 256) = v52;
    *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
    uint64_t v53 = *(void *)(a2 + 280);
    *(void *)(a1 + 272) = *(void *)(a2 + 272);
    *(void *)(a1 + 280) = v53;
    uint64_t v54 = *(void *)(a2 + 296);
    *(void *)(a1 + 288) = *(void *)(a2 + 288);
    *(void *)(a1 + 296) = v54;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    long long v59 = *(_OWORD *)(a2 + 256);
    *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
    *(_OWORD *)(a1 + 256) = v59;
    long long v60 = *(_OWORD *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 288) = v60;
    long long v61 = *(_OWORD *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
    *(_OWORD *)(a1 + 224) = v61;
  }
  char v58 = 0;
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
LABEL_24:
  *(unsigned char *)(a1 + 328) = v58;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for LogicalPlanType(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 328);
    if (v4 >= 2) {
      unsigned int v4 = *(_DWORD *)a1 + 2;
    }
    if (v4 == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 48))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 24);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*(void *)(a1 + 144))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 120);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 248))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 224);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 32))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 8);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*(void *)(a1 + 128))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 104);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 232))
      {
        __swift_destroy_boxed_opaque_existential_1Tm(a1 + 208);
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    swift_bridgeObjectRelease();
    unsigned int v5 = *(unsigned __int8 *)(a2 + 328);
    if (v5 >= 2) {
      unsigned int v5 = *(_DWORD *)a2 + 2;
    }
    if (v5 == 1)
    {
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      uint64_t v6 = *(void *)(a2 + 48);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v6)
      {
        *(void *)(a1 + 48) = v6;
        *(void *)(a1 + 56) = *(void *)(a2 + 56);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v6 - 8))(a1 + 24, a2 + 24, v6);
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(void *)(a1 + 96) = *(void *)(a2 + 96);
        *(void *)(a1 + 104) = *(void *)(a2 + 104);
        *(void *)(a1 + 112) = *(void *)(a2 + 112);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v8 = *(_OWORD *)(a2 + 40);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 40) = v8;
        long long v9 = *(_OWORD *)(a2 + 56);
        long long v10 = *(_OWORD *)(a2 + 72);
        long long v11 = *(_OWORD *)(a2 + 104);
        *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 104) = v11;
        *(_OWORD *)(a1 + 56) = v9;
        *(_OWORD *)(a1 + 72) = v10;
      }
      long long v12 = (_OWORD *)(a1 + 120);
      uint64_t v13 = (_OWORD *)(a2 + 120);
      uint64_t v14 = *(void *)(a2 + 144);
      if (v14)
      {
        *(void *)(a1 + 144) = v14;
        *(void *)(a1 + 152) = *(void *)(a2 + 152);
        (**(void (***)(_OWORD *, _OWORD *))(v14 - 8))(v12, v13);
        *(void *)(a1 + 160) = *(void *)(a2 + 160);
        *(void *)(a1 + 168) = *(void *)(a2 + 168);
        *(unsigned char *)(a1 + 176) = *(unsigned char *)(a2 + 176);
        *(void *)(a1 + 184) = *(void *)(a2 + 184);
        *(void *)(a1 + 192) = *(void *)(a2 + 192);
        *(void *)(a1 + 200) = *(void *)(a2 + 200);
        *(void *)(a1 + 208) = *(void *)(a2 + 208);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v22 = *(_OWORD *)(a2 + 136);
        *long long v12 = *v13;
        *(_OWORD *)(a1 + 136) = v22;
        long long v23 = *(_OWORD *)(a2 + 152);
        long long v24 = *(_OWORD *)(a2 + 168);
        long long v25 = *(_OWORD *)(a2 + 200);
        *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 200) = v25;
        *(_OWORD *)(a1 + 152) = v23;
        *(_OWORD *)(a1 + 168) = v24;
      }
      *(void *)(a1 + 216) = *(void *)(a2 + 216);
      uint64_t v26 = *(void *)(a2 + 248);
      swift_bridgeObjectRetain();
      if (v26)
      {
        *(void *)(a1 + 248) = v26;
        *(void *)(a1 + 256) = *(void *)(a2 + 256);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v26 - 8))(a1 + 224, a2 + 224, v26);
        *(void *)(a1 + 264) = *(void *)(a2 + 264);
        *(void *)(a1 + 272) = *(void *)(a2 + 272);
        *(unsigned char *)(a1 + 280) = *(unsigned char *)(a2 + 280);
        *(void *)(a1 + 288) = *(void *)(a2 + 288);
        *(void *)(a1 + 296) = *(void *)(a2 + 296);
        *(void *)(a1 + 304) = *(void *)(a2 + 304);
        *(void *)(a1 + 312) = *(void *)(a2 + 312);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v32 = *(_OWORD *)(a2 + 240);
        *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 240) = v32;
        long long v33 = *(_OWORD *)(a2 + 256);
        long long v34 = *(_OWORD *)(a2 + 272);
        long long v35 = *(_OWORD *)(a2 + 304);
        *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 304) = v35;
        *(_OWORD *)(a1 + 256) = v33;
        *(_OWORD *)(a1 + 272) = v34;
      }
      *(void *)(a1 + 320) = *(void *)(a2 + 320);
      char v36 = 1;
    }
    else
    {
      *(void *)a1 = *(void *)a2;
      uint64_t v7 = *(void *)(a2 + 32);
      swift_bridgeObjectRetain();
      if (v7)
      {
        *(void *)(a1 + 32) = v7;
        *(void *)(a1 + 40) = *(void *)(a2 + 40);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v7 - 8))(a1 + 8, a2 + 8, v7);
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        *(void *)(a1 + 56) = *(void *)(a2 + 56);
        *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
        *(void *)(a1 + 72) = *(void *)(a2 + 72);
        *(void *)(a1 + 80) = *(void *)(a2 + 80);
        *(void *)(a1 + 88) = *(void *)(a2 + 88);
        *(void *)(a1 + 96) = *(void *)(a2 + 96);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v15 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 24) = v15;
        long long v16 = *(_OWORD *)(a2 + 40);
        long long v17 = *(_OWORD *)(a2 + 56);
        long long v18 = *(_OWORD *)(a2 + 88);
        *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
        *(_OWORD *)(a1 + 88) = v18;
        *(_OWORD *)(a1 + 40) = v16;
        *(_OWORD *)(a1 + 56) = v17;
      }
      long long v19 = (_OWORD *)(a1 + 104);
      long long v20 = (_OWORD *)(a2 + 104);
      uint64_t v21 = *(void *)(a2 + 128);
      if (v21)
      {
        *(void *)(a1 + 128) = v21;
        *(void *)(a1 + 136) = *(void *)(a2 + 136);
        (**(void (***)(_OWORD *, _OWORD *))(v21 - 8))(v19, v20);
        *(void *)(a1 + 144) = *(void *)(a2 + 144);
        *(void *)(a1 + 152) = *(void *)(a2 + 152);
        *(unsigned char *)(a1 + 160) = *(unsigned char *)(a2 + 160);
        *(void *)(a1 + 168) = *(void *)(a2 + 168);
        *(void *)(a1 + 176) = *(void *)(a2 + 176);
        *(void *)(a1 + 184) = *(void *)(a2 + 184);
        *(void *)(a1 + 192) = *(void *)(a2 + 192);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v27 = *(_OWORD *)(a2 + 120);
        *long long v19 = *v20;
        *(_OWORD *)(a1 + 120) = v27;
        long long v28 = *(_OWORD *)(a2 + 136);
        long long v29 = *(_OWORD *)(a2 + 152);
        long long v30 = *(_OWORD *)(a2 + 184);
        *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
        *(_OWORD *)(a1 + 184) = v30;
        *(_OWORD *)(a1 + 136) = v28;
        *(_OWORD *)(a1 + 152) = v29;
      }
      *(void *)(a1 + 200) = *(void *)(a2 + 200);
      uint64_t v31 = *(void *)(a2 + 232);
      swift_bridgeObjectRetain();
      if (v31)
      {
        *(void *)(a1 + 232) = v31;
        *(void *)(a1 + 240) = *(void *)(a2 + 240);
        (**(void (***)(uint64_t, uint64_t, uint64_t))(v31 - 8))(a1 + 208, a2 + 208, v31);
        *(void *)(a1 + 248) = *(void *)(a2 + 248);
        *(void *)(a1 + 256) = *(void *)(a2 + 256);
        *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
        *(void *)(a1 + 272) = *(void *)(a2 + 272);
        *(void *)(a1 + 280) = *(void *)(a2 + 280);
        *(void *)(a1 + 288) = *(void *)(a2 + 288);
        *(void *)(a1 + 296) = *(void *)(a2 + 296);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
      }
      else
      {
        long long v37 = *(_OWORD *)(a2 + 224);
        *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
        *(_OWORD *)(a1 + 224) = v37;
        long long v38 = *(_OWORD *)(a2 + 240);
        long long v39 = *(_OWORD *)(a2 + 256);
        long long v40 = *(_OWORD *)(a2 + 288);
        *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
        *(_OWORD *)(a1 + 288) = v40;
        *(_OWORD *)(a1 + 240) = v38;
        *(_OWORD *)(a1 + 256) = v39;
      }
      char v36 = 0;
      *(void *)(a1 + 304) = *(void *)(a2 + 304);
    }
    *(unsigned char *)(a1 + 328) = v36;
    swift_bridgeObjectRetain();
  }
  return a1;
}

void *__swift_memcpy329_8(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x149uLL);
}

unsigned __int8 *assignWithTake for LogicalPlanType(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = a1[328];
    if (v4 >= 2) {
      unsigned int v4 = *(_DWORD *)a1 + 2;
    }
    if (v4 == 1)
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*((void *)a1 + 6))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 24));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*((void *)a1 + 18))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 120));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*((void *)a1 + 31))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 224));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    else
    {
      swift_bridgeObjectRelease();
      if (*((void *)a1 + 4))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 8));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      if (*((void *)a1 + 16))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 104));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
      swift_bridgeObjectRelease();
      if (*((void *)a1 + 29))
      {
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t)(a1 + 208));
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
      }
    }
    swift_bridgeObjectRelease();
    unsigned int v5 = a2[328];
    if (v5 >= 2) {
      unsigned int v5 = *(_DWORD *)a2 + 2;
    }
    if (v5 == 1)
    {
      memcpy(a1, a2, 0x148uLL);
      char v6 = 1;
    }
    else
    {
      memcpy(a1, a2, 0x138uLL);
      char v6 = 0;
    }
    a1[328] = v6;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for LogicalPlanType(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && *(unsigned char *)(a1 + 329)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 328);
  if (v3 >= 2) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for LogicalPlanType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 224) = 0u;
    *(_OWORD *)(result + 240) = 0u;
    *(_OWORD *)(result + 192) = 0u;
    *(_OWORD *)(result + 208) = 0u;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 313) = 0u;
    *(_DWORD *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 329) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 329) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 328) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTag for LogicalPlanType(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 328);
  if (result >= 2) {
    return (*(_DWORD *)a1 + 2);
  }
  return result;
}

uint64_t destructiveInjectEnumTag for LogicalPlanType(uint64_t result, unsigned int a2)
{
  if (a2 > 1)
  {
    *(void *)(result + 320) = 0;
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 224) = 0u;
    *(_OWORD *)(result + 240) = 0u;
    *(_OWORD *)(result + 192) = 0u;
    *(_OWORD *)(result + 208) = 0u;
    *(_OWORD *)(result + 160) = 0u;
    *(_OWORD *)(result + 176) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = a2 - 2;
    LOBYTE(a2) = 2;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  *(unsigned char *)(result + 328) = a2;
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlanType()
{
  return &type metadata for LogicalPlanType;
}

uint64_t *initializeBufferWithCopyOfBuffer for SQLParseResult(uint64_t *a1, uint64_t *a2, int *a3)
{
  unsigned int v4 = a1;
  int v5 = *(_DWORD *)(*((void *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v22 = *a2;
    *unsigned int v4 = *a2;
    unsigned int v4 = (uint64_t *)(v22 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    a1[1] = a2[1];
    uint64_t v7 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
    long long v8 = (char *)v4 + v7;
    long long v9 = (char *)a2 + v7;
    uint64_t v10 = type metadata accessor for UnknownStorage();
    long long v11 = *(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 16);
    swift_bridgeObjectRetain();
    v11(v8, v9, v10);
    uint64_t v12 = a3[5];
    uint64_t v13 = (char *)v4 + v12;
    uint64_t v14 = (char *)a2 + v12;
    *(_DWORD *)uint64_t v13 = *(_DWORD *)((char *)a2 + v12);
    *((void *)v13 + 1) = *(uint64_t *)((char *)a2 + v12 + 8);
    uint64_t v15 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    long long v16 = &v13[v15];
    long long v17 = &v14[v15];
    swift_bridgeObjectRetain();
    v11(v16, v17, v10);
    uint64_t v18 = a3[7];
    *(uint64_t *)((char *)v4 + a3[6]) = *(uint64_t *)((char *)a2 + a3[6]);
    long long v19 = (uint64_t *)((char *)v4 + v18);
    long long v20 = (uint64_t *)((char *)a2 + v18);
    uint64_t v21 = v20[1];
    *long long v19 = *v20;
    v19[1] = v21;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  return v4;
}

uint64_t destroy for SQLParseResult(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease();
  uint64_t v4 = a1 + *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  uint64_t v5 = type metadata accessor for UnknownStorage();
  char v6 = *(void (**)(uint64_t, uint64_t))(*(void *)(v5 - 8) + 8);
  v6(v4, v5);
  uint64_t v7 = a1 + *(int *)(a2 + 20);
  swift_bridgeObjectRelease();
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v6(v7 + *(int *)(ScanResult + 24), v5);
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16);
  swift_bridgeObjectRetain();
  v10(v7, v8, v9);
  uint64_t v11 = a3[5];
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(_DWORD *)uint64_t v12 = *(_DWORD *)(a2 + v11);
  *(void *)(v12 + 8) = *(void *)(a2 + v11 + 8);
  uint64_t v14 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v15 = v12 + v14;
  uint64_t v16 = v13 + v14;
  swift_bridgeObjectRetain();
  v10(v15, v16, v9);
  uint64_t v17 = a3[7];
  *(void *)(a1 + a3[6]) = *(void *)(a2 + a3[6]);
  uint64_t v18 = (void *)(a1 + v17);
  long long v19 = (void *)(a2 + v17);
  uint64_t v20 = v19[1];
  *uint64_t v18 = *v19;
  v18[1] = v20;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 24);
  v10(v7, v8, v9);
  uint64_t v11 = a3[5];
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(_DWORD *)uint64_t v12 = *(_DWORD *)(a2 + v11);
  *(void *)(v12 + 8) = *(void *)(a2 + v11 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  *(void *)(a1 + a3[6]) = *(void *)(a2 + a3[6]);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v15 = a3[7];
  uint64_t v16 = (void *)(a1 + v15);
  uint64_t v17 = (void *)(a2 + v15);
  *uint64_t v16 = *v17;
  v16[1] = v17[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t initializeWithTake for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32);
  v10(v7, v8, v9);
  uint64_t v11 = a3[5];
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(_DWORD *)uint64_t v12 = *(_DWORD *)(a2 + v11);
  *(void *)(v12 + 8) = *(void *)(a2 + v11 + 8);
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  uint64_t v15 = a3[7];
  *(void *)(a1 + a3[6]) = *(void *)(a2 + a3[6]);
  *(_OWORD *)(a1 + v15) = *(_OWORD *)(a2 + v15);
  return a1;
}

uint64_t assignWithTake for SQLParseResult(uint64_t a1, uint64_t a2, int *a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ParseResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 40);
  v10(v7, v8, v9);
  uint64_t v11 = a3[5];
  uint64_t v12 = a1 + v11;
  uint64_t v13 = a2 + v11;
  *(_DWORD *)uint64_t v12 = *(_DWORD *)(a2 + v11);
  *(void *)(v12 + 8) = *(void *)(a2 + v11 + 8);
  swift_bridgeObjectRelease();
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  v10(v12 + *(int *)(ScanResult + 24), v13 + *(int *)(ScanResult + 24), v9);
  *(void *)(a1 + a3[6]) = *(void *)(a2 + a3[6]);
  swift_bridgeObjectRelease();
  uint64_t v15 = a3[7];
  uint64_t v16 = (void *)(a1 + v15);
  uint64_t v17 = (uint64_t *)(a2 + v15);
  uint64_t v19 = *v17;
  uint64_t v18 = v17[1];
  *uint64_t v16 = v19;
  v16[1] = v18;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLParseResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_18EA6E9B0);
}

uint64_t sub_18EA6E9B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  uint64_t v7 = *(void *)(ParseResult - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = ParseResult;
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    uint64_t v10 = a1;
LABEL_5:
    return v9(v10, a2, v8);
  }
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  uint64_t v12 = *(void *)(ScanResult - 8);
  if (*(_DWORD *)(v12 + 84) == a2)
  {
    uint64_t v8 = ScanResult;
    uint64_t v10 = a1 + *(int *)(a3 + 20);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 48);
    goto LABEL_5;
  }
  unint64_t v14 = *(void *)(a1 + *(int *)(a3 + 24));
  if (v14 >= 0xFFFFFFFF) {
    LODWORD(v14) = -1;
  }
  return (v14 + 1);
}

uint64_t storeEnumTagSinglePayload for SQLParseResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18EA6EAD8);
}

uint64_t sub_18EA6EAD8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t ParseResult = type metadata accessor for PgQuery_ParseResult(0);
  uint64_t v9 = *(void *)(ParseResult - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    uint64_t v10 = ParseResult;
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v12 = a1;
  }
  else
  {
    uint64_t result = type metadata accessor for PgQuery_ScanResult(0);
    uint64_t v14 = *(void *)(result - 8);
    if (*(_DWORD *)(v14 + 84) != a3)
    {
      *(void *)(a1 + *(int *)(a4 + 24)) = (a2 - 1);
      return result;
    }
    uint64_t v10 = result;
    uint64_t v12 = a1 + *(int *)(a4 + 20);
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56);
  }

  return v11(v12, a2, a2, v10);
}

uint64_t type metadata completion function for SQLParseResult()
{
  uint64_t result = type metadata accessor for PgQuery_ParseResult(319);
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for PgQuery_ScanResult(319);
    if (v2 <= 0x3F)
    {
      swift_initStructMetadata();
      return 0;
    }
  }
  return result;
}

void *type metadata accessor for LogicalPlanType.CodingKeys()
{
  return &unk_1EDD706F8;
}

void *type metadata accessor for LogicalPlanType.SelectCoreCodingKeys()
{
  return &unk_1EDD70788;
}

void *type metadata accessor for LogicalPlanType.MaterializedViewCodingKeys()
{
  return &unk_1EDD70818;
}

uint64_t getEnumTagSinglePayload for LogicalPlan.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 4;
  int v8 = v6 - 4;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for LogicalPlan.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFC)
  {
    unsigned int v6 = ((a2 - 253) >> 8) + 1;
    *uint64_t result = a2 + 3;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA6EE5CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 3;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for LogicalPlan.CodingKeys()
{
  return &type metadata for LogicalPlan.CodingKeys;
}

void *type metadata accessor for MaterializedView.CodingKeys()
{
  return &unk_1EDD70CB8;
}

unsigned char *storeEnumTagSinglePayload for SQLRawDataType(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 4 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 4) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFC) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFB)
  {
    unsigned int v6 = ((a2 - 252) >> 8) + 1;
    *uint64_t result = a2 + 4;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA6EF70);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 4;
        break;
    }
  }
  return result;
}

void *type metadata accessor for SelectCore.CodingKeys()
{
  return &unk_1EDD6D578;
}

uint64_t getEnumTagSinglePayload for ResultColumn.CodingKeys(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for ResultColumn.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *uint64_t result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA6F104);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 2;
        break;
    }
  }
  return result;
}

void *type metadata accessor for ResultColumn.CodingKeys()
{
  return &unk_1EDD6E350;
}

void *type metadata accessor for FromClause.CodingKeys()
{
  return &unk_1EDD6D468;
}

unsigned char *storeEnumTagSinglePayload for LogicalPlanType.CodingKeys(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *uint64_t result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18EA6F218);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 1;
        break;
    }
  }
  return result;
}

void *type metadata accessor for Schema.CodingKeys()
{
  return &unk_1EDD75D68;
}

unsigned char *storeEnumTagSinglePayload for LogicalPlanType.SelectCoreCodingKeys(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *uint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)uint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)uint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *uint64_t result = 0;
      break;
    case 2:
      *(_WORD *)uint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x18EA6F2ECLL);
    case 4:
      *(_DWORD *)uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

void *type metadata accessor for DatabaseCatalog.CodingKeys()
{
  return &unk_1EDD70640;
}

uint64_t type metadata accessor for PlanResources(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for PlanResources);
}

uint64_t type metadata accessor for SQLTokenInformation(uint64_t a1)
{
  return type metadata accessor for PgQuery_Node._StorageClass(a1, (uint64_t *)&type metadata singleton initialization cache for SQLTokenInformation);
}

uint64_t outlined init with copy of PgQuery_ScanResult(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t partial apply for closure #1 in SQLParseResult.plans(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  return closure #1 in SQLParseResult.plans(with:)(a1, a2, a3, *(void *)(v4 + 16), *(void *)(v4 + 24), a4);
}

void *outlined init with take of LogicalPlanType(void *__src, void *__dst)
{
  return memcpy(__dst, __src, 0x149uLL);
}

uint64_t partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(void *a1)
{
  return partial apply for specialized closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1) & 1;
}

{
  uint64_t v1;
  void *v2;

  int v2 = *(void **)(v1 + 16);
  if (*a1 == *v2 && a1[1] == v2[1]) {
    return 1;
  }
  else {
    return _stringCompareWithSmolCheck(_:_:expecting:)() & 1;
  }
}

uint64_t sub_18EA6FEBC()
{
  swift_bridgeObjectRelease();

  return MEMORY[0x1F4186498](v0, 24, 7);
}

uint64_t sub_18EA6FEF4()
{
  return MEMORY[0x1F4186498](v0, 24, 7);
}

uint64_t partial apply for closure #1 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in SelectCore.init(select:resources:)(a1, *(void *)(v3 + 16), *(void *)(v3 + 24), a2, a3);
}

uint64_t outlined destroy of FromClause(uint64_t a1)
{
  return a1;
}

uint64_t partial apply for closure #3 in SelectCore.init(select:resources:)@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return closure #3 in SelectCore.init(select:resources:)(a1, *(void *)(v3 + 16), *(void *)(v3 + 24), a2, a3);
}

uint64_t *initializeBufferWithCopyOfBuffer for SQLTokenInformation(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v16 = *a2;
    *uint64_t v4 = *a2;
    uint64_t v4 = (uint64_t *)(v16 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    a1[1] = a2[1];
    uint64_t v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    int v8 = (char *)v4 + v7;
    uint64_t v9 = (char *)a2 + v7;
    uint64_t v10 = type metadata accessor for UnknownStorage();
    uint64_t v11 = *(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 16);
    swift_bridgeObjectRetain();
    v11(v8, v9, v10);
    uint64_t v12 = *(int *)(a3 + 20);
    uint64_t v13 = (uint64_t *)((char *)v4 + v12);
    uint64_t v14 = (uint64_t *)((char *)a2 + v12);
    uint64_t v15 = v14[1];
    *uint64_t v13 = *v14;
    v13[1] = v15;
    swift_bridgeObjectRetain();
  }
  return v4;
}

uint64_t destroy for SQLTokenInformation(uint64_t a1)
{
  swift_bridgeObjectRelease();
  uint64_t v2 = a1 + *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v3 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(v2, v3);

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16);
  swift_bridgeObjectRetain();
  v10(v7, v8, v9);
  uint64_t v11 = *(int *)(a3 + 20);
  uint64_t v12 = (void *)(a1 + v11);
  uint64_t v13 = (void *)(a2 + v11);
  uint64_t v14 = v13[1];
  *uint64_t v12 = *v13;
  v12[1] = v14;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t assignWithCopy for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 24))(v7, v8, v9);
  uint64_t v10 = *(int *)(a3 + 20);
  uint64_t v11 = (void *)(a1 + v10);
  uint64_t v12 = (void *)(a2 + v10);
  *uint64_t v11 = *v12;
  v11[1] = v12[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t initializeWithTake for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32))(v7, v8, v9);
  *(_OWORD *)(a1 + *(int *)(a3 + 20)) = *(_OWORD *)(a2 + *(int *)(a3 + 20));
  return a1;
}

uint64_t assignWithTake for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v7 = a1 + v6;
  uint64_t v8 = a2 + v6;
  uint64_t v9 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 40))(v7, v8, v9);
  uint64_t v10 = *(int *)(a3 + 20);
  uint64_t v11 = (void *)(a1 + v10);
  uint64_t v12 = (uint64_t *)(a2 + v10);
  uint64_t v14 = *v12;
  uint64_t v13 = v12[1];
  *uint64_t v11 = v14;
  v11[1] = v13;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_18EA704A8);
}

uint64_t sub_18EA704A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ScanResult = type metadata accessor for PgQuery_ScanResult(0);
  uint64_t v7 = *(void *)(ScanResult - 8);
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 48);
    return v8(a1, a2, ScanResult);
  }
  else
  {
    unint64_t v10 = *(void *)(a1 + *(int *)(a3 + 20) + 8);
    if (v10 >= 0xFFFFFFFF) {
      LODWORD(v10) = -1;
    }
    return (v10 + 1);
  }
}

uint64_t storeEnumTagSinglePayload for SQLTokenInformation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18EA70580);
}

uint64_t sub_18EA70580(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for PgQuery_ScanResult(0);
  uint64_t v9 = *(void *)(result - 8);
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    unint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 56);
    return v10(a1, a2, a2, result);
  }
  else
  {
    *(void *)(a1 + *(int *)(a4 + 20) + 8) = (a2 - 1);
  }
  return result;
}

uint64_t type metadata completion function for SQLTokenInformation()
{
  uint64_t result = type metadata accessor for PgQuery_ScanResult(319);
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t *initializeBufferWithCopyOfBuffer for PlanResources(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  uint64_t v4 = *a2;
  *a1 = *a2;
  if ((v3 & 0x20000) != 0)
  {
    int v5 = (uint64_t *)(v4 + ((v3 + 16) & ~(unint64_t)v3));
    swift_retain();
  }
  else
  {
    int v5 = a1;
    uint64_t v6 = *(int *)(a3 + 20);
    uint64_t v7 = (char *)a1 + v6;
    uint64_t v8 = (char *)a2 + v6;
    *(_DWORD *)uint64_t v7 = *(_DWORD *)((char *)a2 + v6);
    *((void *)v7 + 1) = *(uint64_t *)((char *)a2 + v6 + 8);
    uint64_t v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
    unint64_t v10 = &v7[v9];
    uint64_t v11 = &v8[v9];
    uint64_t v12 = type metadata accessor for UnknownStorage();
    uint64_t v13 = *(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 16);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    v13(v10, v11, v12);
    uint64_t v14 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
    uint64_t v15 = &v7[v14];
    uint64_t v16 = &v8[v14];
    uint64_t v17 = *((void *)v16 + 1);
    *(void *)uint64_t v15 = *(void *)v16;
    *((void *)v15 + 1) = v17;
    swift_bridgeObjectRetain();
  }
  return v5;
}

uint64_t destroy for PlanResources(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease();
  uint64_t v4 = a1 + *(int *)(a2 + 20);
  swift_bridgeObjectRelease();
  uint64_t v5 = v4 + *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v6 = type metadata accessor for UnknownStorage();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(v5, v6);
  type metadata accessor for SQLTokenInformation(0);

  return swift_bridgeObjectRelease();
}

void *initializeWithCopy for PlanResources(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(int *)(a3 + 20);
  uint64_t v5 = (char *)a1 + v4;
  uint64_t v6 = (char *)a2 + v4;
  *(_DWORD *)uint64_t v5 = *(_DWORD *)((char *)a2 + v4);
  *((void *)v5 + 1) = *(void *)((char *)a2 + v4 + 8);
  uint64_t v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v8 = &v5[v7];
  uint64_t v9 = &v6[v7];
  uint64_t v10 = type metadata accessor for UnknownStorage();
  uint64_t v11 = *(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  v11(v8, v9, v10);
  uint64_t v12 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  uint64_t v13 = &v5[v12];
  uint64_t v14 = &v6[v12];
  uint64_t v15 = *((void *)v14 + 1);
  *(void *)uint64_t v13 = *(void *)v14;
  *((void *)v13 + 1) = v15;
  swift_bridgeObjectRetain();
  return a1;
}

void *assignWithCopy for PlanResources(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(a3 + 20);
  uint64_t v7 = (char *)a1 + v6;
  uint64_t v8 = (char *)a2 + v6;
  *(_DWORD *)uint64_t v7 = *(_DWORD *)((char *)a2 + v6);
  *((void *)v7 + 1) = *(void *)((char *)a2 + v6 + 8);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  uint64_t v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v10 = &v7[v9];
  uint64_t v11 = &v8[v9];
  uint64_t v12 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 24))(v10, v11, v12);
  uint64_t v13 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  uint64_t v14 = &v7[v13];
  uint64_t v15 = &v8[v13];
  *(void *)uint64_t v14 = *(void *)v15;
  *((void *)v14 + 1) = *((void *)v15 + 1);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

void *initializeWithTake for PlanResources(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(int *)(a3 + 20);
  uint64_t v5 = (char *)a1 + v4;
  uint64_t v6 = (char *)a2 + v4;
  *(_DWORD *)uint64_t v5 = *(_DWORD *)((char *)a2 + v4);
  *((void *)v5 + 1) = *(void *)((char *)a2 + v4 + 8);
  uint64_t v7 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v8 = &v5[v7];
  uint64_t v9 = &v6[v7];
  uint64_t v10 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v10 - 8) + 32))(v8, v9, v10);
  uint64_t v11 = type metadata accessor for SQLTokenInformation(0);
  *(_OWORD *)&v5[*(int *)(v11 + 20)] = *(_OWORD *)&v6[*(int *)(v11 + 20)];
  return a1;
}

void *assignWithTake for PlanResources(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  swift_bridgeObjectRelease();
  uint64_t v6 = *(int *)(a3 + 20);
  uint64_t v7 = (char *)a1 + v6;
  uint64_t v8 = (char *)a2 + v6;
  *(_DWORD *)uint64_t v7 = *(_DWORD *)((char *)a2 + v6);
  *((void *)v7 + 1) = *(void *)((char *)a2 + v6 + 8);
  swift_bridgeObjectRelease();
  uint64_t v9 = *(int *)(type metadata accessor for PgQuery_ScanResult(0) + 24);
  uint64_t v10 = &v7[v9];
  uint64_t v11 = &v8[v9];
  uint64_t v12 = type metadata accessor for UnknownStorage();
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v12 - 8) + 40))(v10, v11, v12);
  uint64_t v13 = *(int *)(type metadata accessor for SQLTokenInformation(0) + 20);
  uint64_t v14 = &v7[v13];
  uint64_t v15 = &v8[v13];
  uint64_t v17 = *(void *)v15;
  uint64_t v16 = *((void *)v15 + 1);
  *(void *)uint64_t v14 = v17;
  *((void *)v14 + 1) = v16;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for PlanResources(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_18EA70C58);
}

uint64_t sub_18EA70C58(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 0x7FFFFFFF)
  {
    uint64_t v4 = *a1;
    if ((unint64_t)*a1 >= 0xFFFFFFFF) {
      LODWORD(v4) = -1;
    }
    return (v4 + 1);
  }
  else
  {
    uint64_t v8 = type metadata accessor for SQLTokenInformation(0);
    uint64_t v9 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v8 - 8) + 48);
    uint64_t v10 = v8;
    uint64_t v11 = (char *)a1 + *(int *)(a3 + 20);
    return v9(v11, a2, v10);
  }
}

uint64_t storeEnumTagSinglePayload for PlanResources(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18EA70D1C);
}

void *sub_18EA70D1C(void *result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 0x7FFFFFFF)
  {
    *uint64_t result = (a2 - 1);
  }
  else
  {
    uint64_t v7 = type metadata accessor for SQLTokenInformation(0);
    uint64_t v8 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56);
    uint64_t v9 = v7;
    uint64_t v10 = (char *)v5 + *(int *)(a4 + 20);
    return (void *)v8(v10, a2, a2, v9);
  }
  return result;
}

uint64_t type metadata completion function for PlanResources()
{
  uint64_t result = type metadata accessor for SQLTokenInformation(319);
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

_DWORD *pg_query_init()
{
  uint64_t result = (_DWORD *)pg_query_initialized();
  if (!*result)
  {
    *uint64_t result = 1;
    MemoryContextInit();
    SetDatabaseEncoding(6u);
    pthread_key_create((pthread_key_t *)&pg_query_thread_exit_key, (void (__cdecl *)(void *))pg_query_thread_exit);
    unint64_t v1 = *(const void **)TopMemoryContext();
    return (_DWORD *)pthread_setspecific(v2, v1);
  }
  return result;
}

void *pg_query_thread_exit(void *a1)
{
  MemoryContextDeleteChildren((uint64_t)a1);
  AllocSetDeleteFreeList((uint64_t)a1);
  (*(void (**)(void *))(a1[2] + 32))(a1);
  free(a1);
  *(void *)TopMemoryContext() = 0;
  *(void *)CurrentMemoryContext() = 0;
  uint64_t result = (void *)ErrorContext();
  *uint64_t result = 0;
  return result;
}

void *pg_query_free_top_memory_context(void *a1)
{
  MemoryContextDeleteChildren((uint64_t)a1);
  AllocSetDeleteFreeList((uint64_t)a1);
  (*(void (**)(void *))(a1[2] + 32))(a1);
  free(a1);
  *(void *)TopMemoryContext() = 0;
  *(void *)CurrentMemoryContext(v2) = 0;
  uint64_t result = (void *)ErrorContext();
  *uint64_t result = 0;
  return result;
}

void *pg_query_exit()
{
  uint64_t v0 = (uint64_t *)TopMemoryContext();
  unint64_t v1 = (void *)*v0;
  MemoryContextDeleteChildren(*v0);
  AllocSetDeleteFreeList((uint64_t)v1);
  (*(void (**)(void *))(v1[2] + 32))(v1);
  free(v1);
  *uint64_t v0 = 0;
  *(void *)CurrentMemoryContext(v2) = 0;
  uint64_t result = (void *)ErrorContext();
  *uint64_t result = 0;
  return result;
}

uint64_t pg_query_enter_memory_context()
{
  initialized = (_DWORD *)pg_query_initialized();
  if (*initialized)
  {
    unint64_t v1 = (const void **)TopMemoryContext();
  }
  else
  {
    _DWORD *initialized = 1;
    MemoryContextInit();
    SetDatabaseEncoding(6u);
    pthread_key_create((pthread_key_t *)&pg_query_thread_exit_key, (void (__cdecl *)(void *))pg_query_thread_exit);
    unint64_t v1 = (const void **)TopMemoryContext();
    pthread_setspecific(v2, *v1);
  }
  AllocSetContextCreateInternal((uint64_t)*v1, (size_t)"pg_query", 0, 0x2000uLL, 0x800000);
  int v3 = (void *)CurrentMemoryContext();
  *int v3 = v4;
  return v4;
}

uint64_t pg_query_exit_memory_context()
{
  TopMemoryContext();
  uint64_t v0 = (void *)CurrentMemoryContext();
  *uint64_t v0 = v2;

  return MemoryContextDelete(v1);
}

void pg_query_free_error(uint64_t a1)
{
  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2) {
    free(v2);
  }

  free((void *)a1);
}

char *pg_query_deparse_protobuf(unsigned int a1, unsigned __int8 *a2)
{
  uint64_t v1236 = *MEMORY[0x1E4F143B8];
  __s1 = 0;
  uint64_t v1233 = 0;
  uint64_t v1234 = 0;
  uint64_t enter_memory_context = pg_query_enter_memory_context();
  uint64_t v5 = (int **)PG_exception_stack();
  uint64_t v6 = *v5;
  uint64_t v7 = v5;
  uint64_t v8 = (void *)error_context_stack();
  uint64_t v9 = *v8;
  uint64_t v10 = v8;
  memset(v1235, 0, 196);
  if (!sigsetjmp(v1235, 0))
  {
    v1228 = v10;
    uint64_t v1229 = v9;
    v1231 = v6;
    v1230 = v7;
    *uint64_t v7 = v1235;
    uint64_t protobuf_to_nodes = pg_query_protobuf_to_nodes(a1, a2);
    initStringInfo((uint64_t)&__s1);
    if (!protobuf_to_nodes || *(int *)(protobuf_to_nodes + 4) < 1)
    {
LABEL_2111:
      uint64_t v13 = strdup(__s1);
      uint64_t v6 = v1231;
      uint64_t v9 = v1229;
      uint64_t v7 = v1230;
      uint64_t v10 = v1228;
      goto LABEL_2112;
    }
    uint64_t v15 = protobuf_to_nodes;
    uint64_t v16 = 0;
    uint64_t v1227 = protobuf_to_nodes;
    while (2)
    {
      uint64_t v17 = *(void *)(v15 + 16) + 8 * (int)v16;
      uint64_t v18 = *(void *)(*(void *)v17 + 8);
      if (!v18) {
        pg_query_deparse_protobuf_cold_1();
      }
      uint64_t v19 = *(void *)(*(void *)v17 + 8);
      switch(*(_DWORD *)v18)
      {
        case 0xE9:
          deparseInsertStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0xEA:
          deparseDeleteStmt(&__s1, *(uint64_t **)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0xEB:
          deparseUpdateStmt(&__s1, *(uint64_t **)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0xEC:
          deparseSelectStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0xED:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          int v275 = 0;
          uint64_t v276 = "TABLE ";
          int v277 = 0;
          int v278 = 0;
          int v279 = 0;
          switch(*(_DWORD *)(v18 + 24))
          {
            case 0x12:
              int v277 = 0;
              uint64_t v276 = "FOREIGN TABLE ";
              goto LABEL_1315;
            case 0x13:
            case 0x15:
            case 0x16:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x30:
              goto LABEL_1317;
            case 0x14:
              int v277 = 0;
              uint64_t v276 = "INDEX ";
              goto LABEL_1315;
            case 0x17:
              int v277 = 0;
              uint64_t v276 = "MATERIALIZED VIEW ";
              goto LABEL_1315;
            case 0x23:
              int v277 = 0;
              uint64_t v276 = "SEQUENCE ";
              goto LABEL_1315;
            case 0x27:
              goto LABEL_1316;
            case 0x2F:
              int v278 = 9;
              int v277 = 1;
              uint64_t v276 = "TYPE ";
              goto LABEL_1316;
            case 0x31:
              int v277 = 0;
              uint64_t v276 = "VIEW ";
LABEL_1315:
              int v278 = 0;
LABEL_1316:
              int v275 = v278;
              int v788 = v277;
              appendStringInfoString((uint64_t)&__s1, v276);
              int v279 = v788;
LABEL_1317:
              int v1224 = v279;
              if (*(unsigned char *)(v19 + 28)) {
                goto LABEL_1318;
              }
              goto LABEL_1319;
            default:
              int v1224 = 0;
              if (!*(unsigned char *)(v18 + 28)) {
                goto LABEL_1319;
              }
LABEL_1318:
              appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
LABEL_1319:
              deparseRangeVar((uint64_t)&__s1, *(void *)(v19 + 8), v275);
              appendStringInfoChar((uint64_t)&__s1, 32);
              uint64_t v795 = *(void *)(v19 + 16);
              if (!v795) {
                goto LABEL_2105;
              }
              uint64_t v796 = *(void *)(v19 + 16);
              if (*(int *)(v795 + 4) < 1) {
                goto LABEL_2105;
              }
              uint64_t v797 = 0;
              uint64_t v1223 = *(void *)(v19 + 16);
              break;
          }
LABEL_1323:
          v798 = 0;
          uint64_t v1221 = *(void *)(v796 + 16) + 8 * v797;
          uint64_t v1222 = v797;
          uint64_t v799 = *(void *)v1221;
          uint64_t v800 = *(void *)v1221;
          char v801 = 1;
          v802 = "DROP EXPRESSION";
          switch(*(_DWORD *)(*(void *)v1221 + 4))
          {
            case 0:
              if (v1224) {
                v803 = "ADD ATTRIBUTE ";
              }
              else {
                v803 = "ADD COLUMN ";
              }
              goto LABEL_1387;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              if (*(void *)(v800 + 32)) {
                v798 = "SET DEFAULT";
              }
              else {
                v798 = "DROP DEFAULT";
              }
              goto LABEL_1389;
            case 5:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "DROP NOT NULL";
              goto LABEL_1389;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "SET NOT NULL";
              goto LABEL_1389;
            case 7:
              goto LABEL_1379;
            case 9:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "SET STATISTICS";
              goto LABEL_1389;
            case 0xA:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "SET";
              goto LABEL_1389;
            case 0xB:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "RESET";
              goto LABEL_1389;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              char v801 = 0;
              v798 = "SET STORAGE";
              goto LABEL_1389;
            case 0xD:
              if (v1224) {
                v803 = "DROP ATTRIBUTE ";
              }
              else {
                v803 = "DROP ";
              }
              goto LABEL_1387;
            case 0xF:
              v803 = "ADD INDEX ";
              goto LABEL_1387;
            case 0x11:
              v803 = "ADD ";
              goto LABEL_1387;
            case 0x15:
            case 0x41:
              v803 = "ALTER ";
              goto LABEL_1387;
            case 0x16:
              v803 = "VALIDATE CONSTRAINT ";
              goto LABEL_1387;
            case 0x19:
              v803 = "DROP CONSTRAINT ";
              goto LABEL_1387;
            case 0x1C:
              if (v1224) {
                v805 = "ALTER ATTRIBUTE ";
              }
              else {
                v805 = "ALTER COLUMN ";
              }
              appendStringInfoString((uint64_t)&__s1, v805);
              char v801 = 0;
              v798 = "TYPE";
              goto LABEL_1389;
            case 0x1D:
              v803 = "ALTER COLUMN ";
              goto LABEL_1387;
            case 0x1E:
              appendStringInfoString((uint64_t)&__s1, "OWNER TO ");
              uint64_t v804 = *(void *)(v800 + 24);
              switch(*(_DWORD *)(v804 + 4))
              {
                case 0:
                  v803 = quote_identifier(*(unsigned char **)(v804 + 8));
                  goto LABEL_1387;
                case 1:
                  v803 = "CURRENT_USER";
                  goto LABEL_1387;
                case 2:
                  v803 = "SESSION_USER";
                  goto LABEL_1387;
                case 3:
                  v803 = "public";
                  goto LABEL_1387;
                default:
                  goto LABEL_1388;
              }
              goto LABEL_1388;
            case 0x1F:
              v803 = "CLUSTER ON ";
              goto LABEL_1387;
            case 0x20:
              v803 = "SET WITHOUT CLUSTER ";
              goto LABEL_1387;
            case 0x21:
              v803 = "SET LOGGED ";
              goto LABEL_1387;
            case 0x22:
              v803 = "SET UNLOGGED ";
              goto LABEL_1387;
            case 0x23:
              v803 = "SET WITHOUT OIDS ";
              goto LABEL_1387;
            case 0x24:
              v803 = "SET TABLESPACE ";
              goto LABEL_1387;
            case 0x25:
              v803 = "SET ";
              goto LABEL_1387;
            case 0x26:
              v803 = "RESET ";
              goto LABEL_1387;
            case 0x28:
            case 0x2C:
              v803 = "ENABLE TRIGGER ";
              goto LABEL_1387;
            case 0x29:
              v803 = "ENABLE ALWAYS TRIGGER ";
              goto LABEL_1387;
            case 0x2A:
              v803 = "ENABLE REPLICA TRIGGER ";
              goto LABEL_1387;
            case 0x2B:
              v803 = "DISABLE TRIGGER ";
              goto LABEL_1387;
            case 0x2D:
              v803 = "DISABLE TRIGGER ALL ";
              goto LABEL_1387;
            case 0x2E:
              v803 = "ENABLE TRIGGER USER ";
              goto LABEL_1387;
            case 0x2F:
              v803 = "DISABLE TRIGGER USER ";
              goto LABEL_1387;
            case 0x30:
              v803 = "ENABLE RULE ";
              goto LABEL_1387;
            case 0x31:
              v803 = "ENABLE ALWAYS RULE ";
              goto LABEL_1387;
            case 0x32:
              v803 = "ENABLE REPLICA RULE ";
              goto LABEL_1387;
            case 0x33:
              v803 = "DISABLE RULE ";
              goto LABEL_1387;
            case 0x34:
              v803 = "INHERIT ";
              goto LABEL_1387;
            case 0x35:
              v803 = "NO INHERIT ";
              goto LABEL_1387;
            case 0x36:
              v803 = "OF ";
              goto LABEL_1387;
            case 0x37:
              v803 = "NOT OF ";
              goto LABEL_1387;
            case 0x38:
              v803 = "REPLICA IDENTITY ";
              goto LABEL_1387;
            case 0x39:
              v803 = "ENABLE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3A:
              v803 = "DISABLE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3B:
              v803 = "FORCE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3C:
              v803 = "NO FORCE ROW LEVEL SECURITY ";
              goto LABEL_1387;
            case 0x3E:
              v803 = "ATTACH PARTITION ";
              goto LABEL_1387;
            case 0x3F:
              v803 = "DETACH PARTITION ";
LABEL_1387:
              appendStringInfoString((uint64_t)&__s1, v803);
LABEL_1388:
              v798 = 0;
              char v801 = 1;
              goto LABEL_1389;
            case 0x40:
              appendStringInfoString((uint64_t)&__s1, "ALTER ");
              char v801 = 0;
              v798 = "ADD";
              goto LABEL_1389;
            case 0x42:
              v802 = "DROP IDENTITY";
LABEL_1379:
              uint64_t v806 = v17;
              appendStringInfoString((uint64_t)&__s1, "ALTER COLUMN ");
              v807 = (unsigned char *)(v799 + 44);
              char v808 = 0;
              char v809 = 0;
              goto LABEL_1396;
            default:
LABEL_1389:
              v802 = (char *)v798;
              char v810 = v801;
              if (*(unsigned char *)(v800 + 44))
              {
                uint64_t v806 = v17;
                if (*(_DWORD *)(v800 + 4)) {
                  v811 = "IF EXISTS ";
                }
                else {
                  v811 = "IF NOT EXISTS ";
                }
                appendStringInfoString((uint64_t)&__s1, v811);
              }
              else
              {
                uint64_t v806 = v17;
              }
              char v809 = 1;
              v807 = (unsigned char *)(v800 + 44);
              char v808 = v810;
LABEL_1396:
              char v812 = v809;
              v813 = *(unsigned char **)(v800 + 8);
              if (v813)
              {
                v814 = quote_identifier(v813);
                appendStringInfoString((uint64_t)&__s1, v814);
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              if (*(__int16 *)(v800 + 16) >= 1) {
                appendStringInfo((uint64_t)&__s1, "%d ", v789, v790, v791, v792, v793, v794, *(unsigned __int16 *)(v800 + 16));
              }
              if (v808)
              {
                if (*v807) {
                  char v815 = v812;
                }
                else {
                  char v815 = 1;
                }
                if (v815)
                {
LABEL_1405:
                  unsigned int v816 = *(_DWORD *)(v800 + 4);
                  uint64_t v17 = v806;
                  if (v816 > 0x41) {
                    goto LABEL_1451;
                  }
LABEL_1412:
                  switch(v816)
                  {
                    case 0u:
                    case 0x1Cu:
                      deparseColumnDef((uint64_t)&__s1, *(void **)(v800 + 32));
                      goto LABEL_1450;
                    case 3u:
                      v820 = *(int **)(v800 + 32);
                      if (!v820) {
                        goto LABEL_1451;
                      }
                      deparseExpr(&__s1, v820, v789, v790, v791, v792, v793, v794);
                      goto LABEL_1450;
                    case 9u:
                      appendStringInfo((uint64_t)&__s1, "%d", v789, v790, v791, v792, v793, v794, *(unsigned int *)(*(void *)(v800 + 32) + 8));
                      goto LABEL_1450;
                    case 0xAu:
                    case 0xBu:
                    case 0x25u:
                    case 0x26u:
                      deparseRelOptions(&__s1, *(void *)(v800 + 32));
                      goto LABEL_1450;
                    case 0xCu:
                      v819 = quote_identifier(*(unsigned char **)(*(void *)(v800 + 32) + 8));
LABEL_1423:
                      appendStringInfoString((uint64_t)&__s1, v819);
                      goto LABEL_1450;
                    case 0x11u:
                    case 0x15u:
                    case 0x40u:
                      deparseConstraint(&__s1, *(void *)(v800 + 32));
                      goto LABEL_1450;
                    case 0x1Du:
                    case 0x3Du:
                      deparseAlterGenericOptions((uint64_t)&__s1, *(void *)(v800 + 32));
                      goto LABEL_1450;
                    case 0x34u:
                    case 0x35u:
                      deparseRangeVar((uint64_t)&__s1, *(void *)(v800 + 32), 0);
                      goto LABEL_1450;
                    case 0x36u:
                      deparseTypeName(&__s1, *(void *)(v800 + 32));
                      goto LABEL_1450;
                    case 0x38u:
                      switch(*(unsigned char *)(*(void *)(v800 + 32) + 4))
                      {
                        case 'd':
                          v819 = "DEFAULT ";
                          goto LABEL_1423;
                        case 'f':
                          v819 = "FULL ";
                          goto LABEL_1423;
                        case 'i':
                          uint64_t v840 = *(void *)(v800 + 32);
                          appendStringInfoString((uint64_t)&__s1, "USING INDEX ");
                          v819 = quote_identifier(*(unsigned char **)(v840 + 8));
                          goto LABEL_1423;
                        case 'n':
                          v819 = "NOTHING ";
                          goto LABEL_1423;
                        default:
                          goto LABEL_1450;
                      }
                      goto LABEL_1450;
                    case 0x3Eu:
                    case 0x3Fu:
                      uint64_t v818 = *(void *)(v800 + 32);
                      deparseRangeVar((uint64_t)&__s1, *(void *)(v818 + 8), 0);
                      if (*(void *)(v818 + 16))
                      {
                        appendStringInfoChar((uint64_t)&__s1, 32);
                        deparsePartitionBoundSpec(&__s1, *(void *)(v818 + 16));
                      }
                      goto LABEL_1450;
                    case 0x41u:
                      uint64_t v821 = *(void *)(v800 + 32);
                      if (!v821 || *(int *)(v821 + 4) < 1) {
                        goto LABEL_1450;
                      }
                      uint64_t v822 = 0;
                      uint64_t v823 = 8;
                      break;
                    default:
                      goto LABEL_1451;
                  }
                  while (1)
                  {
                    uint64_t v824 = v17;
                    uint64_t v825 = *(void *)(v821 + 16);
                    uint64_t v826 = *(void *)(v825 + 8 * v822);
                    v827 = *(const char **)(v826 + 16);
                    if (!strcmp(v827, "restart"))
                    {
                      if (*(void *)(v826 + 24))
                      {
                        appendStringInfoString((uint64_t)&__s1, "RESTART ");
                        v834 = *(_DWORD **)(v826 + 24);
                        if (*v834 != 222)
                        {
                          if (*v834 == 221) {
                            appendStringInfo((uint64_t)&__s1, "%d", v828, v829, v830, v831, v832, v833, v834[2]);
                          }
                          goto LABEL_1446;
                        }
                        v836 = (char *)*((void *)v834 + 1);
                      }
                      else
                      {
                        v836 = "RESTART";
                      }
                      goto LABEL_1445;
                    }
                    if (!strcmp(v827, "generated"))
                    {
                      appendStringInfoString((uint64_t)&__s1, "SET GENERATED ");
                      int v835 = *(_DWORD *)(*(void *)(v826 + 24) + 8);
                      if (v835 == 100)
                      {
                        v836 = "BY DEFAULT";
                        goto LABEL_1445;
                      }
                      if (v835 == 97)
                      {
                        v836 = "ALWAYS";
LABEL_1445:
                        appendStringInfoString((uint64_t)&__s1, v836);
                      }
                    }
                    else
                    {
                      appendStringInfoString((uint64_t)&__s1, "SET ");
                      deparseSeqOptElem(&__s1, v826);
                    }
LABEL_1446:
                    uint64_t v837 = *(int *)(v821 + 4);
                    unint64_t v838 = v825 + v823;
                    if (v825 + v823)
                    {
                      uint64_t v17 = v824;
                      if (v838 < *(void *)(v821 + 16) + 8 * *(int *)(v821 + 4))
                      {
                        appendStringInfoChar((uint64_t)&__s1, 32);
                        uint64_t v837 = *(int *)(v821 + 4);
                      }
                    }
                    else
                    {
                      uint64_t v17 = v824;
                    }
                    ++v822;
                    v823 += 8;
                    if (v822 >= v837)
                    {
LABEL_1450:
                      appendStringInfoChar((uint64_t)&__s1, 32);
                      uint64_t v796 = v1223;
LABEL_1451:
                      if (*(_DWORD *)(v800 + 40) == 1) {
                        appendStringInfoString((uint64_t)&__s1, "CASCADE ");
                      }
                      uint64_t v839 = (v1233 - 1);
                      uint64_t v15 = v1227;
                      if ((int)v1233 >= 1 && __s1[v839] == 32)
                      {
                        LODWORD(v1233) = v1233 - 1;
                        __s1[v839] = 0;
                      }
                      if (v1221 != -8
                        && v1221 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
                                                        + 8 * *(int *)(*(void *)(v19 + 16) + 4)))
                      {
                        appendStringInfoString((uint64_t)&__s1, ", ");
                      }
                      uint64_t v797 = v1222 + 1;
                      if (v1222 + 1 < *(int *)(v796 + 4)) {
                        goto LABEL_1323;
                      }
                      goto LABEL_2105;
                    }
                  }
                }
              }
              else
              {
                appendStringInfoString((uint64_t)&__s1, v802);
                appendStringInfoChar((uint64_t)&__s1, 32);
                if (*v807) {
                  char v817 = v812;
                }
                else {
                  char v817 = 1;
                }
                if (v817) {
                  goto LABEL_1405;
                }
              }
              appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              unsigned int v816 = *(_DWORD *)(v800 + 4);
              uint64_t v17 = v806;
              goto LABEL_1412;
          }
        case 0xEF:
          appendStringInfoString((uint64_t)&__s1, "ALTER DOMAIN ");
          uint64_t v217 = *(void *)(v18 + 8);
          if (v217 && *(int *)(v217 + 4) >= 1)
          {
            uint64_t v218 = 8;
            uint64_t v219 = 0;
            do
            {
              uint64_t v220 = *(void *)(v217 + 16);
              uint64_t v221 = quote_identifier(*(unsigned char **)(*(void *)(v220 + 8 * v219) + 8));
              appendStringInfoString((uint64_t)&__s1, v221);
              uint64_t v222 = *(int *)(v217 + 4);
              if (v220 + v218) {
                BOOL v223 = v220 + v218 >= (unint64_t)(*(void *)(v217 + 16) + 8 * v222);
              }
              else {
                BOOL v223 = 1;
              }
              if (!v223)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v222 = *(int *)(v217 + 4);
              }
              ++v219;
              v218 += 8;
            }
            while (v219 < v222);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(unsigned char *)(v19 + 4))
          {
            case 'C':
              appendStringInfoString((uint64_t)&__s1, "ADD ");
              deparseConstraint(&__s1, *(void *)(v19 + 24));
              goto LABEL_2105;
            case 'N':
              long long v27 = "DROP NOT NULL";
              goto LABEL_2104;
            case 'O':
              long long v27 = "SET NOT NULL";
              goto LABEL_2104;
            case 'T':
              if (*(void *)(v19 + 24))
              {
                appendStringInfoString((uint64_t)&__s1, "SET DEFAULT ");
                deparseExpr(&__s1, *(int **)(v19 + 24), v722, v723, v724, v725, v726, v727);
                goto LABEL_2105;
              }
              long long v27 = "DROP DEFAULT";
              break;
            case 'V':
              unint64_t v158 = "VALIDATE CONSTRAINT ";
              goto LABEL_1018;
            case 'X':
              appendStringInfoString((uint64_t)&__s1, "DROP CONSTRAINT ");
              if (*(unsigned char *)(v19 + 36)) {
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              }
              v728 = quote_identifier(*(unsigned char **)(v19 + 16));
              appendStringInfoString((uint64_t)&__s1, v728);
              if (*(_DWORD *)(v19 + 32) != 1) {
                goto LABEL_2105;
              }
              long long v27 = " CASCADE";
              goto LABEL_2104;
            default:
              goto LABEL_2105;
          }
          goto LABEL_2104;
        case 0xF1:
          deparseGrantStmt((uint64_t)&__s1, v18);
          goto LABEL_2105;
        case 0xF2:
          if (*(unsigned char *)(v18 + 24)) {
            unint64_t v159 = "GRANT ";
          }
          else {
            unint64_t v159 = "REVOKE ";
          }
          appendStringInfoString((uint64_t)&__s1, v159);
          uint64_t v160 = *(void *)(v18 + 8);
          if (v160 && *(int *)(v160 + 4) >= 1)
          {
            uint64_t v161 = 8;
            uint64_t v162 = 0;
            do
            {
              uint64_t v163 = *(void *)(v160 + 16);
              deparseAccessPriv((uint64_t)&__s1, *(void *)(v163 + 8 * v162));
              if (v163 + v161) {
                BOOL v164 = v163 + v161 >= (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 8) + 4));
              else {
                BOOL v164 = 1;
              }
              if (!v164) {
                appendStringInfoChar((uint64_t)&__s1, 44);
              }
              appendStringInfoChar((uint64_t)&__s1, 32);
              ++v162;
              v161 += 8;
            }
            while (v162 < *(int *)(v160 + 4));
          }
          if (*(unsigned char *)(v19 + 24)) {
            unint64_t v188 = "TO ";
          }
          else {
            unint64_t v188 = "FROM ";
          }
          appendStringInfoString((uint64_t)&__s1, v188);
          deparseRoleList(&__s1, *(void *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v19 + 25)) {
            appendStringInfoString((uint64_t)&__s1, "WITH ADMIN OPTION ");
          }
          goto LABEL_2092;
        case 0xF3:
          appendStringInfoString((uint64_t)&__s1, "ALTER DEFAULT PRIVILEGES ");
          uint64_t v260 = *(void *)(v18 + 8);
          if (!v260 || *(int *)(v260 + 4) < 1) {
            goto LABEL_423;
          }
          int v261 = *(_DWORD *)(v260 + 4);
          uint64_t v262 = 0;
          while (1)
          {
            uint64_t v263 = *(void *)(*(void *)(v260 + 16) + 8 * v262);
            uint64_t v264 = *(const char **)(v263 + 16);
            if (!strcmp(v264, "schemas"))
            {
              appendStringInfoString((uint64_t)&__s1, "IN SCHEMA ");
              uint64_t v265 = *(void *)(v263 + 24);
              if (v265 && *(int *)(v265 + 4) >= 1)
              {
                uint64_t v266 = 8;
                uint64_t v267 = 0;
                do
                {
                  uint64_t v268 = *(void *)(v265 + 16);
                  uint64_t v269 = quote_identifier(*(unsigned char **)(*(void *)(v268 + 8 * v267) + 8));
                  appendStringInfoString((uint64_t)&__s1, v269);
                  uint64_t v270 = *(int *)(v265 + 4);
                  if (v268 + v266) {
                    BOOL v271 = v268 + v266 >= (unint64_t)(*(void *)(v265 + 16) + 8 * v270);
                  }
                  else {
                    BOOL v271 = 1;
                  }
                  if (!v271)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v270 = *(int *)(v265 + 4);
                  }
                  ++v267;
                  v266 += 8;
                }
                while (v267 < v270);
              }
            }
            else
            {
              if (strcmp(v264, "roles")) {
                goto LABEL_400;
              }
              appendStringInfoString((uint64_t)&__s1, "FOR ROLE ");
              deparseRoleList(&__s1, *(void *)(v263 + 24));
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
            int v261 = *(_DWORD *)(v260 + 4);
LABEL_400:
            if (++v262 >= v261)
            {
LABEL_423:
              deparseGrantStmt((uint64_t)&__s1, *(void *)(v19 + 16));
              uint64_t v15 = v1227;
              goto LABEL_2105;
            }
          }
        case 0xF4:
          appendStringInfoString((uint64_t)&__s1, "CLOSE ");
          uint64_t v108 = *(unsigned char **)(v18 + 8);
          if (!v108) {
            goto LABEL_341;
          }
          goto LABEL_1818;
        case 0xF5:
          appendStringInfoString((uint64_t)&__s1, "CLUSTER ");
          if ((*(unsigned char *)(v18 + 24) & 2) != 0) {
            appendStringInfoString((uint64_t)&__s1, "VERBOSE ");
          }
          uint64_t v272 = *(void *)(v18 + 8);
          if (v272)
          {
            deparseRangeVar((uint64_t)&__s1, v272, 0);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (!*(void *)(v18 + 16)) {
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "USING ");
          Swift::String v273 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v273);
          goto LABEL_1308;
        case 0xF6:
          appendStringInfoString((uint64_t)&__s1, "COPY ");
          uint64_t v189 = *(void *)(v18 + 8);
          if (v189)
          {
            deparseRangeVar((uint64_t)&__s1, v189, 0);
            uint64_t v190 = *(void *)(v18 + 24);
            if (v190 && *(int *)(v190 + 4) >= 1)
            {
              appendStringInfoChar((uint64_t)&__s1, 40);
              uint64_t v191 = *(void *)(v18 + 24);
              if (v191 && *(int *)(v191 + 4) >= 1)
              {
                uint64_t v192 = 8;
                uint64_t v193 = 0;
                do
                {
                  uint64_t v194 = *(void *)(v191 + 16);
                  unint64_t v195 = quote_identifier(*(unsigned char **)(*(void *)(v194 + 8 * v193) + 8));
                  appendStringInfoString((uint64_t)&__s1, v195);
                  uint64_t v196 = *(int *)(v191 + 4);
                  if (v194 + v192) {
                    BOOL v197 = v194 + v192 >= (unint64_t)(*(void *)(v191 + 16) + 8 * v196);
                  }
                  else {
                    BOOL v197 = 1;
                  }
                  if (!v197)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v196 = *(int *)(v191 + 4);
                  }
                  ++v193;
                  v192 += 8;
                }
                while (v193 < v196);
              }
              appendStringInfoChar((uint64_t)&__s1, 41);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(void *)(v19 + 16))
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            v616 = *(uint64_t **)(v19 + 16);
            switch(*(_DWORD *)v616)
            {
              case 0xE9:
                deparseInsertStmt(&__s1, (uint64_t)v616);
                break;
              case 0xEA:
                deparseDeleteStmt(&__s1, v616);
                break;
              case 0xEB:
                deparseUpdateStmt(&__s1, v616);
                break;
              case 0xEC:
                deparseSelectStmt(&__s1, (uint64_t)v616);
                break;
              default:
                break;
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (*(unsigned char *)(v19 + 32)) {
            v730 = "FROM ";
          }
          else {
            v730 = "TO ";
          }
          appendStringInfoString((uint64_t)&__s1, v730);
          if (*(unsigned char *)(v19 + 33)) {
            appendStringInfoString((uint64_t)&__s1, "PROGRAM ");
          }
          v731 = *(char **)(v19 + 40);
          if (v731)
          {
            deparseStringLiteral((uint64_t)&__s1, v731);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else
          {
            if (*(unsigned char *)(v19 + 32)) {
              v732 = "STDIN ";
            }
            else {
              v732 = "STDOUT ";
            }
            appendStringInfoString((uint64_t)&__s1, v732);
          }
          uint64_t v733 = *(void *)(v19 + 48);
          if (!v733 || *(int *)(v733 + 4) < 1) {
            goto LABEL_1306;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH (");
          uint64_t v734 = *(void *)(v19 + 48);
          if (!v734 || *(int *)(v734 + 4) < 1) {
            goto LABEL_1305;
          }
          uint64_t v735 = 0;
          while (1)
          {
            uint64_t v736 = *(void *)(v734 + 16) + 8 * v735;
            uint64_t v737 = *(void *)v736;
            v738 = *(char **)(*(void *)v736 + 16);
            if (!strcmp(v738, "format"))
            {
              appendStringInfoString((uint64_t)&__s1, "FORMAT ");
              v749 = *(const char **)(*(void *)(v737 + 24) + 8);
              if (!strcmp(v749, "binary"))
              {
                v750 = "BINARY";
              }
              else
              {
                if (strcmp(v749, "csv")) {
                  goto LABEL_1260;
                }
                v750 = "CSV";
              }
              goto LABEL_1256;
            }
            if (!strcmp(v738, "freeze") && ((uint64_t v751 = *(void *)(v737 + 24)) == 0 || *(_DWORD *)(v751 + 8) == 1))
            {
              appendStringInfoString((uint64_t)&__s1, "FREEZE");
              uint64_t v752 = *(void *)(v737 + 24);
              if (v752) {
                goto LABEL_1254;
              }
            }
            else
            {
              if (!strcmp(v738, "delimiter"))
              {
                v753 = "DELIMITER ";
LABEL_1259:
                appendStringInfoString((uint64_t)&__s1, v753);
                deparseStringLiteral((uint64_t)&__s1, *(char **)(*(void *)(v737 + 24) + 8));
                goto LABEL_1260;
              }
              if (!strcmp(v738, "null"))
              {
                v753 = "NULL ";
                goto LABEL_1259;
              }
              if (!strcmp(v738, "header"))
              {
                uint64_t v754 = *(void *)(v737 + 24);
                if (!v754 || *(_DWORD *)(v754 + 8) == 1)
                {
                  appendStringInfoString((uint64_t)&__s1, "HEADER");
                  uint64_t v752 = *(void *)(v737 + 24);
                  if (!v752) {
                    goto LABEL_1260;
                  }
LABEL_1254:
                  if (*(_DWORD *)(v752 + 8) != 1) {
                    goto LABEL_1260;
                  }
                  v750 = " 1";
LABEL_1256:
                  appendStringInfoString((uint64_t)&__s1, v750);
                  goto LABEL_1260;
                }
              }
              if (!strcmp(v738, "quote"))
              {
                v753 = "QUOTE ";
                goto LABEL_1259;
              }
              if (!strcmp(v738, "escape"))
              {
                v753 = "ESCAPE ";
                goto LABEL_1259;
              }
              if (!strcmp(v738, "force_quote"))
              {
                appendStringInfoString((uint64_t)&__s1, "FORCE_QUOTE ");
                int v748 = **(_DWORD **)(v737 + 24);
                if (v748 != 226)
                {
LABEL_1264:
                  if (v748 == 351) {
                    appendStringInfoChar((uint64_t)&__s1, 42);
                  }
                  goto LABEL_1260;
                }
                uint64_t v739 = v17;
                appendStringInfoChar((uint64_t)&__s1, 40);
                uint64_t v769 = *(void *)(v737 + 24);
                if (v769 && *(int *)(v769 + 4) >= 1)
                {
                  uint64_t v770 = 8;
                  uint64_t v771 = 0;
                  do
                  {
                    uint64_t v772 = *(void *)(v769 + 16);
                    v773 = quote_identifier(*(unsigned char **)(*(void *)(v772 + 8 * v771) + 8));
                    appendStringInfoString((uint64_t)&__s1, v773);
                    uint64_t v774 = *(int *)(v769 + 4);
                    if (v772 + v770) {
                      BOOL v775 = v772 + v770 >= (unint64_t)(*(void *)(v769 + 16) + 8 * v774);
                    }
                    else {
                      BOOL v775 = 1;
                    }
                    if (!v775)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      uint64_t v774 = *(int *)(v769 + 4);
                    }
                    ++v771;
                    v770 += 8;
                  }
                  while (v771 < v774);
                }
              }
              else
              {
                uint64_t v739 = v17;
                if (!strcmp(v738, "force_not_null"))
                {
                  appendStringInfoString((uint64_t)&__s1, "FORCE_NOT_NULL (");
                  uint64_t v755 = *(void *)(v737 + 24);
                  if (v755 && *(int *)(v755 + 4) >= 1)
                  {
                    uint64_t v756 = 8;
                    uint64_t v757 = 0;
                    do
                    {
                      uint64_t v758 = *(void *)(v755 + 16);
                      v759 = quote_identifier(*(unsigned char **)(*(void *)(v758 + 8 * v757) + 8));
                      appendStringInfoString((uint64_t)&__s1, v759);
                      uint64_t v760 = *(int *)(v755 + 4);
                      if (v758 + v756) {
                        BOOL v761 = v758 + v756 >= (unint64_t)(*(void *)(v755 + 16) + 8 * v760);
                      }
                      else {
                        BOOL v761 = 1;
                      }
                      if (!v761)
                      {
                        appendStringInfoString((uint64_t)&__s1, ", ");
                        uint64_t v760 = *(int *)(v755 + 4);
                      }
                      ++v757;
                      v756 += 8;
                    }
                    while (v757 < v760);
                  }
                }
                else
                {
                  if (strcmp(v738, "force_null"))
                  {
                    if (!strcmp(v738, "encoding"))
                    {
                      appendStringInfoString((uint64_t)&__s1, "ENCODING ");
                      deparseStringLiteral((uint64_t)&__s1, *(char **)(*(void *)(v737 + 24) + 8));
                    }
                    else
                    {
                      v740 = quote_identifier(v738);
                      appendStringInfoString((uint64_t)&__s1, v740);
                      if (*(void *)(v737 + 24))
                      {
                        appendStringInfoChar((uint64_t)&__s1, 32);
                        v747 = *(int **)(v737 + 24);
                        if (v747)
                        {
                          int v748 = *v747;
                          switch(*v747)
                          {
                            case 221:
                              appendStringInfo((uint64_t)&__s1, "%d", v741, v742, v743, v744, v745, v746, v747[2]);
                              break;
                            case 222:
                              v750 = (char *)*((void *)v747 + 1);
                              goto LABEL_1256;
                            case 223:
                              deparseOptBooleanOrString(&__s1, *((char **)v747 + 1));
                              break;
                            case 224:
                            case 225:
                              goto LABEL_1260;
                            case 226:
                              appendStringInfoChar((uint64_t)&__s1, 40);
                              if (v747[1] >= 1)
                              {
                                uint64_t v776 = 8;
                                uint64_t v777 = 0;
                                do
                                {
                                  uint64_t v778 = *((void *)v747 + 2);
                                  deparseOptBooleanOrString(&__s1, *(char **)(*(void *)(v778 + 8 * v777) + 8));
                                  uint64_t v779 = v747[1];
                                  if (v778 + v776) {
                                    BOOL v780 = v778 + v776 >= (unint64_t)(*((void *)v747 + 2) + 8 * v779);
                                  }
                                  else {
                                    BOOL v780 = 1;
                                  }
                                  if (!v780)
                                  {
                                    appendStringInfoString((uint64_t)&__s1, ", ");
                                    uint64_t v779 = v747[1];
                                  }
                                  ++v777;
                                  v776 += 8;
                                }
                                while (v777 < v779);
                              }
                              goto LABEL_1304;
                            default:
                              goto LABEL_1264;
                          }
                        }
                      }
                    }
                    goto LABEL_1260;
                  }
                  appendStringInfoString((uint64_t)&__s1, "FORCE_NULL (");
                  uint64_t v762 = *(void *)(v737 + 24);
                  if (v762 && *(int *)(v762 + 4) >= 1)
                  {
                    uint64_t v763 = 8;
                    uint64_t v764 = 0;
                    do
                    {
                      uint64_t v765 = *(void *)(v762 + 16);
                      v766 = quote_identifier(*(unsigned char **)(*(void *)(v765 + 8 * v764) + 8));
                      appendStringInfoString((uint64_t)&__s1, v766);
                      uint64_t v767 = *(int *)(v762 + 4);
                      if (v765 + v763) {
                        BOOL v768 = v765 + v763 >= (unint64_t)(*(void *)(v762 + 16) + 8 * v767);
                      }
                      else {
                        BOOL v768 = 1;
                      }
                      if (!v768)
                      {
                        appendStringInfoString((uint64_t)&__s1, ", ");
                        uint64_t v767 = *(int *)(v762 + 4);
                      }
                      ++v764;
                      v763 += 8;
                    }
                    while (v764 < v767);
                  }
                }
              }
LABEL_1304:
              appendStringInfoChar((uint64_t)&__s1, 41);
              uint64_t v17 = v739;
            }
LABEL_1260:
            if (v736 != -8
              && v736 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 48) + 16)
                                             + 8 * *(int *)(*(void *)(v19 + 48) + 4)))
            {
              appendStringInfoString((uint64_t)&__s1, ", ");
            }
            if (++v735 >= *(int *)(v734 + 4))
            {
LABEL_1305:
              appendStringInfoString((uint64_t)&__s1, ") ");
              uint64_t v15 = v1227;
LABEL_1306:
              v781 = *(int **)(v19 + 56);
              if (v781)
              {
                appendStringInfoString((uint64_t)&__s1, "WHERE ");
                deparseExpr(&__s1, v781, v782, v783, v784, v785, v786, v787);
LABEL_1308:
                char v553 = 32;
LABEL_1309:
                appendStringInfoChar((uint64_t)&__s1, v553);
              }
              goto LABEL_2092;
            }
          }
        case 0xF7:
          deparseCreateStmt(&__s1, *(void *)(*(void *)v17 + 8), 0);
          goto LABEL_2105;
        case 0xF8:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 41)) {
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          }
          long long v280 = "AGGREGATE ";
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              goto LABEL_1504;
            case 7:
              long long v280 = "COLLATION ";
              goto LABEL_1504;
            case 0x19:
              long long v280 = "OPERATOR ";
              goto LABEL_1504;
            case 0x2B:
              long long v280 = "TEXT SEARCH CONFIGURATION ";
              goto LABEL_1504;
            case 0x2C:
              long long v280 = "TEXT SEARCH DICTIONARY ";
              goto LABEL_1504;
            case 0x2D:
              long long v280 = "TEXT SEARCH PARSER ";
              goto LABEL_1504;
            case 0x2E:
              long long v280 = "TEXT SEARCH TEMPLATE ";
              goto LABEL_1504;
            case 0x2F:
              long long v280 = "TYPE ";
LABEL_1504:
              appendStringInfoString((uint64_t)&__s1, v280);
              break;
            default:
              break;
          }
          if (*(unsigned char *)(v18 + 40)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              uint64_t v857 = *(void *)(v18 + 16);
              if (v857 && *(int *)(v857 + 4) >= 1)
              {
                uint64_t v858 = 8;
                uint64_t v859 = 0;
                do
                {
                  uint64_t v860 = *(void *)(v857 + 16);
                  v861 = quote_identifier(*(unsigned char **)(*(void *)(v860 + 8 * v859) + 8));
                  appendStringInfoString((uint64_t)&__s1, v861);
                  uint64_t v862 = *(int *)(v857 + 4);
                  if (v860 + v858) {
                    BOOL v863 = v860 + v858 >= (unint64_t)(*(void *)(v857 + 16) + 8 * v862);
                  }
                  else {
                    BOOL v863 = 1;
                  }
                  if (!v863)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v862 = *(int *)(v857 + 4);
                  }
                  ++v859;
                  v858 += 8;
                }
                while (v859 < v862);
              }
              goto LABEL_2056;
            case 7:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
              uint64_t v850 = *(void *)(v18 + 16);
              if (v850 && *(int *)(v850 + 4) >= 1)
              {
                uint64_t v851 = 8;
                uint64_t v852 = 0;
                do
                {
                  uint64_t v853 = *(void *)(v850 + 16);
                  v854 = quote_identifier(*(unsigned char **)(*(void *)(v853 + 8 * v852) + 8));
                  appendStringInfoString((uint64_t)&__s1, v854);
                  uint64_t v855 = *(int *)(v850 + 4);
                  if (v853 + v851) {
                    BOOL v856 = v853 + v851 >= (unint64_t)(*(void *)(v850 + 16) + 8 * v855);
                  }
                  else {
                    BOOL v856 = 1;
                  }
                  if (!v856)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v855 = *(int *)(v850 + 4);
                  }
                  ++v852;
                  v851 += 8;
                }
                while (v852 < v855);
              }
              goto LABEL_2056;
            case 0x19:
              uint64_t v864 = *(void *)(v18 + 16);
              if (!v864) {
                goto LABEL_2056;
              }
              int v865 = *(_DWORD *)(v864 + 4);
              if (v865 == 1)
              {
                uint64_t v867 = *(void *)(v864 + 16);
              }
              else
              {
                if (v865 != 2) {
                  goto LABEL_2056;
                }
                v866 = quote_identifier(*(unsigned char **)(**(void **)(v864 + 16) + 8));
                appendStringInfoString((uint64_t)&__s1, v866);
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v867 = *(void *)(v864 + 16) + 8 * (*(_DWORD *)(v864 + 4) - 1);
              }
              appendStringInfoString((uint64_t)&__s1, *(char **)(*(void *)v867 + 8));
LABEL_2056:
              appendStringInfoChar((uint64_t)&__s1, 32);
              if (!*(unsigned char *)(v19 + 8))
              {
                int v1194 = *(_DWORD *)(v19 + 4);
                if (v1194 != 1) {
                  goto LABEL_2074;
                }
                v1195 = *(uint64_t **)(*(void *)(v19 + 24) + 16);
                uint64_t v1196 = *v1195;
                uint64_t v1197 = *(unsigned int *)(v1195[1] + 8);
                appendStringInfoChar((uint64_t)&__s1, 40);
                if (v1196)
                {
                  uint64_t v1198 = v1197;
                  LODWORD(v1199) = *(_DWORD *)(v1196 + 4);
                  if ((int)v1199 >= 1)
                  {
                    v1200 = *(uint64_t **)(v1196 + 16);
                    if (!v1198) {
                      appendStringInfoString((uint64_t)&__s1, "ORDER BY ");
                    }
                    deparseFunctionParameter(&__s1, *v1200);
                    LODWORD(v1199) = *(_DWORD *)(v1196 + 4);
                    if ((int)v1199 >= 2)
                    {
                      uint64_t v1201 = 1;
                      do
                      {
                        uint64_t v1203 = *(void *)(v1196 + 16);
                        if (v1198 == v1201)
                        {
                          appendStringInfoChar((uint64_t)&__s1, 32);
                          v1202 = "ORDER BY ";
                        }
                        else
                        {
                          v1202 = ", ";
                        }
                        appendStringInfoString((uint64_t)&__s1, v1202);
                        deparseFunctionParameter(&__s1, *(void *)(v1203 + 8 * v1201++));
                        uint64_t v1199 = *(int *)(v1196 + 4);
                      }
                      while (v1201 < v1199);
                      uint64_t v15 = v1227;
                    }
                  }
                  if (v1198 == v1199)
                  {
                    appendStringInfoString((uint64_t)&__s1, " ORDER BY ");
                    deparseFunctionParameter(&__s1, *(void *)(*(void *)(v1196 + 16) + 8 * (*(_DWORD *)(v1196 + 4) - 1)));
                  }
                }
                else
                {
                  appendStringInfoChar((uint64_t)&__s1, 42);
                }
                appendStringInfoChar((uint64_t)&__s1, 41);
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              int v1194 = *(_DWORD *)(v19 + 4);
LABEL_2074:
              uint64_t v1204 = *(void *)(v19 + 32);
              if (v1194 == 7)
              {
                if (!v1204) {
                  goto LABEL_2092;
                }
                int v1205 = *(_DWORD *)(v1204 + 4);
                if (v1205 == 1)
                {
                  if (!strcmp(*(const char **)(**(void **)(v1204 + 16) + 16), "from"))
                  {
                    appendStringInfoString((uint64_t)&__s1, "FROM ");
                    uint64_t v1206 = *(void *)(**(void **)(*(void *)(v19 + 32) + 16) + 24);
                    if (v1206 && *(int *)(v1206 + 4) >= 1)
                    {
                      uint64_t v1207 = 8;
                      uint64_t v1208 = 0;
                      do
                      {
                        uint64_t v1209 = *(void *)(v1206 + 16);
                        v1210 = quote_identifier(*(unsigned char **)(*(void *)(v1209 + 8 * v1208) + 8));
                        appendStringInfoString((uint64_t)&__s1, v1210);
                        uint64_t v1211 = *(int *)(v1206 + 4);
                        if (v1209 + v1207) {
                          BOOL v1212 = v1209 + v1207 >= (unint64_t)(*(void *)(v1206 + 16) + 8 * v1211);
                        }
                        else {
                          BOOL v1212 = 1;
                        }
                        if (!v1212)
                        {
                          appendStringInfoChar((uint64_t)&__s1, 46);
                          uint64_t v1211 = *(int *)(v1206 + 4);
                        }
                        ++v1208;
                        v1207 += 8;
                      }
                      while (v1208 < v1211);
                    }
                    goto LABEL_2092;
                  }
                  goto LABEL_2090;
                }
              }
              else
              {
                if (!v1204) {
                  goto LABEL_2092;
                }
                int v1205 = *(_DWORD *)(v1204 + 4);
              }
              if (v1205 < 1) {
                goto LABEL_2092;
              }
LABEL_2090:
              uint64_t v562 = v1204;
LABEL_2091:
              deparseDefinition(&__s1, v562);
LABEL_2092:
              uint64_t v352 = (v1233 - 1);
              if ((int)v1233 < 1) {
                goto LABEL_2105;
              }
LABEL_2093:
              if (__s1[v352] == 32)
              {
                LODWORD(v1233) = v352;
                __s1[v352] = 0;
              }
              goto LABEL_2105;
            default:
              goto LABEL_2056;
          }
        case 0xF9:
          appendStringInfoString((uint64_t)&__s1, "DROP ");
          unsigned int v297 = *(_DWORD *)(v18 + 16);
          if (v297 <= 0x31 && ((0x2FEAF3FBFD1A3uLL >> v297) & 1) != 0) {
            appendStringInfoString((uint64_t)&__s1, (&off_1E55D8C48)[v297]);
          }
          if (*(unsigned char *)(v18 + 25)) {
            appendStringInfoString((uint64_t)&__s1, "CONCURRENTLY ");
          }
          if (*(unsigned char *)(v18 + 24)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          switch(*(_DWORD *)(v18 + 16))
          {
            case 0:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
            case 0x1D:
            case 0x22:
              uint64_t v652 = *(void *)(v18 + 8);
              if (v652 && *(int *)(v652 + 4) >= 1)
              {
                uint64_t v653 = 8;
                uint64_t v654 = 0;
                do
                {
                  uint64_t v655 = *(void *)(v652 + 16);
                  v656 = quote_identifier(*(unsigned char **)(*(void *)(v655 + 8 * v654) + 8));
                  appendStringInfoString((uint64_t)&__s1, v656);
                  uint64_t v657 = *(int *)(v652 + 4);
                  if (v655 + v653) {
                    BOOL v658 = v655 + v653 >= (unint64_t)(*(void *)(v652 + 16) + 8 * v657);
                  }
                  else {
                    BOOL v658 = 1;
                  }
                  if (!v658)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v657 = *(int *)(v652 + 4);
                  }
                  ++v654;
                  v653 += 8;
                }
                while (v654 < v657);
              }
              goto LABEL_462;
            case 1:
              uint64_t v1150 = *(void *)(v18 + 8);
              if (v1150 && *(int *)(v1150 + 4) >= 1)
              {
                uint64_t v1151 = 8;
                uint64_t v1152 = 0;
                do
                {
                  uint64_t v1153 = *(void *)(v1150 + 16);
                  deparseAggregateWithArgtypes(&__s1, *(void *)(v1153 + 8 * v1152));
                  if (v1153 + v1151) {
                    BOOL v1154 = v1153 + v1151 >= (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
                  }
                                                              + 8 * *(int *)(*(void *)(v19 + 8) + 4));
                  else {
                    BOOL v1154 = 1;
                  }
                  if (!v1154) {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  }
                  ++v1152;
                  v1151 += 8;
                }
                while (v1152 < *(int *)(v1150 + 4));
              }
              goto LABEL_462;
            case 5:
              uint64_t v1155 = **(void **)(*(void *)(v18 + 8) + 16);
              appendStringInfoChar((uint64_t)&__s1, 40);
              deparseTypeName(&__s1, **(void **)(v1155 + 16));
              appendStringInfoString((uint64_t)&__s1, " AS ");
              deparseTypeName(&__s1, *(void *)(*(void *)(v1155 + 16) + 8));
              appendStringInfoChar((uint64_t)&__s1, 41);
              goto LABEL_462;
            case 7:
            case 8:
            case 0x12:
            case 0x14:
            case 0x17:
            case 0x23:
            case 0x25:
            case 0x27:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x31:
              deparseAnyNameList((uint64_t)&__s1, *(void *)(v18 + 8));
              goto LABEL_462;
            case 0xC:
            case 0x2F:
              uint64_t v917 = *(void *)(v18 + 8);
              if (v917 && *(int *)(v917 + 4) >= 1)
              {
                uint64_t v918 = 8;
                uint64_t v919 = 0;
                do
                {
                  uint64_t v920 = *(void *)(v917 + 16);
                  deparseTypeName(&__s1, *(void *)(v920 + 8 * v919));
                  if (v920 + v918) {
                    BOOL v921 = v920 + v918 >= (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
                  }
                                                           + 8 * *(int *)(*(void *)(v19 + 8) + 4));
                  else {
                    BOOL v921 = 1;
                  }
                  if (!v921) {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  }
                  ++v919;
                  v918 += 8;
                }
                while (v919 < *(int *)(v917 + 4));
              }
              goto LABEL_462;
            case 0x13:
            case 0x1C:
            case 0x20:
              uint64_t v894 = *(void *)(v18 + 8);
              if (v894 && *(int *)(v894 + 4) >= 1)
              {
                uint64_t v895 = 8;
                uint64_t v896 = 0;
                do
                {
                  uint64_t v897 = *(void *)(v894 + 16);
                  deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v897 + 8 * v896));
                  if (v897 + v895) {
                    BOOL v898 = v897 + v895 >= (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
                  }
                                                           + 8 * *(int *)(*(void *)(v19 + 8) + 4));
                  else {
                    BOOL v898 = 1;
                  }
                  if (!v898) {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  }
                  ++v896;
                  v895 += 8;
                }
                while (v896 < *(int *)(v894 + 4));
              }
              goto LABEL_462;
            case 0x15:
              deparseStringLiteral((uint64_t)&__s1, *(char **)(**(void **)(*(void *)(v18 + 8) + 16) + 8));
              goto LABEL_462;
            case 0x18:
            case 0x1A:
              uint64_t v922 = **(void **)(*(void *)(v18 + 8) + 16);
              if (!v922) {
                goto LABEL_2115;
              }
              if (*(int *)(v922 + 4) >= 2)
              {
                int v923 = 1;
                do
                {
                  v924 = (uint64_t *)(*(void *)(v922 + 16) + 8 * v923);
                  uint64_t v926 = *v924;
                  unint64_t v925 = (unint64_t)(v924 + 1);
                  v927 = quote_identifier(*(unsigned char **)(v926 + 8));
                  appendStringInfoString((uint64_t)&__s1, v927);
                  uint64_t v928 = *(int *)(v922 + 4);
                  if (v925) {
                    BOOL v929 = v925 >= *(void *)(v922 + 16) + 8 * v928;
                  }
                  else {
                    BOOL v929 = 1;
                  }
                  if (!v929)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v928) = *(_DWORD *)(v922 + 4);
                  }
                  ++v923;
                }
                while ((int)v928 > v923);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              uint64_t v930 = **(void **)(v922 + 16);
LABEL_1961:
              v1162 = quote_identifier(*(unsigned char **)(v930 + 8));
              appendStringInfoString((uint64_t)&__s1, v1162);
LABEL_462:
              appendStringInfoChar((uint64_t)&__s1, 32);
              break;
            case 0x19:
              uint64_t v1156 = *(void *)(v18 + 8);
              if (v1156 && *(int *)(v1156 + 4) >= 1)
              {
                uint64_t v1157 = 8;
                uint64_t v1158 = 0;
                do
                {
                  uint64_t v1159 = *(void *)(v1156 + 16);
                  deparseOperatorWithArgtypes(&__s1, *(void *)(v1159 + 8 * v1158));
                  if (v1159 + v1157) {
                    BOOL v1160 = v1159 + v1157 >= (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
                  }
                                                              + 8 * *(int *)(*(void *)(v19 + 8) + 4));
                  else {
                    BOOL v1160 = 1;
                  }
                  if (!v1160) {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  }
                  ++v1158;
                  v1157 += 8;
                }
                while (v1158 < *(int *)(v1156 + 4));
              }
              goto LABEL_462;
            case 0x1B:
            case 0x21:
            case 0x2A:
              uint64_t v899 = **(void **)(*(void *)(v18 + 8) + 16);
              v900 = quote_identifier(*(unsigned char **)(*(void *)(*(void *)(v899 + 16) + 8 * (*(_DWORD *)(v899 + 4) - 1))
                                                + 8));
              appendStringInfoString((uint64_t)&__s1, v900);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              uint64_t v901 = *(unsigned int *)(v899 + 4);
              if ((int)v901 >= 1)
              {
                uint64_t v902 = 8;
                uint64_t v903 = 0;
                do
                {
                  uint64_t v904 = v901;
                  uint64_t v905 = *(void *)(v899 + 16);
                  if (v905 + v902) {
                    BOOL v906 = v905 + v902 >= (unint64_t)(v905 + 8 * (int)v904);
                  }
                  else {
                    BOOL v906 = 1;
                  }
                  if (!v906)
                  {
                    v907 = quote_identifier(*(unsigned char **)(*(void *)(v905 + 8 * v903) + 8));
                    appendStringInfoString((uint64_t)&__s1, v907);
                    uint64_t v904 = *(unsigned int *)(v899 + 4);
                    if (v903 < *(_DWORD *)(v899 + 4) - 2)
                    {
                      appendStringInfoChar((uint64_t)&__s1, 46);
                      uint64_t v904 = *(unsigned int *)(v899 + 4);
                    }
                  }
                  uint64_t v901 = v904;
                  BOOL v885 = v903 + 1 < (int)v904;
                  v902 += 8;
                  ++v903;
                }
                while (v885);
              }
              goto LABEL_462;
            case 0x29:
              uint64_t v1161 = **(void **)(*(void *)(v18 + 8) + 16);
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              deparseTypeName(&__s1, **(void **)(v1161 + 16));
              appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
              uint64_t v930 = *(void *)(*(void *)(v1161 + 16) + 8);
              goto LABEL_1961;
            default:
              goto LABEL_526;
          }
          goto LABEL_526;
        case 0xFA:
          appendStringInfoString((uint64_t)&__s1, "TRUNCATE ");
          uint64_t v325 = *(void *)(v18 + 8);
          if (v325 && *(int *)(v325 + 4) >= 1)
          {
            uint64_t v326 = 8;
            uint64_t v327 = 0;
            do
            {
              uint64_t v328 = *(void *)(v325 + 16);
              deparseRangeVar((uint64_t)&__s1, *(void *)(v328 + 8 * v327), 0);
              uint64_t v329 = *(int *)(v325 + 4);
              if (v328 + v326) {
                BOOL v330 = v328 + v326 >= (unint64_t)(*(void *)(v325 + 16) + 8 * v329);
              }
              else {
                BOOL v330 = 1;
              }
              if (!v330)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v329 = *(int *)(v325 + 4);
              }
              ++v327;
              v326 += 8;
            }
            while (v327 < v329);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v19 + 16)) {
            appendStringInfoString((uint64_t)&__s1, "RESTART IDENTITY ");
          }
LABEL_526:
          if (*(_DWORD *)(v19 + 20) == 1) {
            goto LABEL_2029;
          }
          goto LABEL_2092;
        case 0xFB:
          appendStringInfoString((uint64_t)&__s1, "COMMENT ON ");
          unsigned int v303 = *(_DWORD *)(v18 + 4);
          unsigned int v304 = v303;
          if (v303 <= 0x31 && ((0x2FFFFBFFFF3E3uLL >> v303) & 1) != 0)
          {
            appendStringInfoString((uint64_t)&__s1, (&off_1E55D8A80)[v303]);
            unsigned int v304 = *(_DWORD *)(v18 + 4);
          }
          switch(v304)
          {
            case 0u:
            case 9u:
            case 0xEu:
            case 0xFu:
            case 0x10u:
            case 0x11u:
            case 0x15u:
            case 0x1Du:
            case 0x1Fu:
            case 0x22u:
            case 0x24u:
            case 0x28u:
              v610 = quote_identifier(*(unsigned char **)(*(void *)(v18 + 8) + 8));
              appendStringInfoString((uint64_t)&__s1, v610);
              goto LABEL_2102;
            case 1u:
              deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 8));
              goto LABEL_2102;
            case 5u:
              uint64_t v1213 = *(void *)(v18 + 8);
              appendStringInfoChar((uint64_t)&__s1, 40);
              deparseTypeName(&__s1, **(void **)(v1213 + 16));
              appendStringInfoString((uint64_t)&__s1, " AS ");
              deparseTypeName(&__s1, *(void *)(*(void *)(v1213 + 16) + 8));
              appendStringInfoChar((uint64_t)&__s1, 41);
              goto LABEL_2102;
            case 6u:
            case 7u:
            case 8u:
            case 0x12u:
            case 0x14u:
            case 0x17u:
            case 0x23u:
            case 0x25u:
            case 0x27u:
            case 0x2Bu:
            case 0x2Cu:
            case 0x2Du:
            case 0x2Eu:
            case 0x31u:
              uint64_t v305 = *(void *)(v18 + 8);
              if (v305 && *(int *)(v305 + 4) >= 1)
              {
                uint64_t v306 = 8;
                uint64_t v307 = 0;
                do
                {
                  uint64_t v308 = *(void *)(v305 + 16);
                  long long v309 = quote_identifier(*(unsigned char **)(*(void *)(v308 + 8 * v307) + 8));
                  appendStringInfoString((uint64_t)&__s1, v309);
                  uint64_t v310 = *(int *)(v305 + 4);
                  if (v308 + v306) {
                    BOOL v311 = v308 + v306 >= (unint64_t)(*(void *)(v305 + 16) + 8 * v310);
                  }
                  else {
                    BOOL v311 = 1;
                  }
                  if (!v311)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v310 = *(int *)(v305 + 4);
                  }
                  ++v307;
                  v306 += 8;
                }
                while (v307 < v310);
              }
              goto LABEL_2102;
            case 0xCu:
            case 0x2Fu:
              deparseTypeName(&__s1, *(void *)(v18 + 8));
              goto LABEL_2102;
            case 0xDu:
              uint64_t v1216 = *(void *)(v18 + 8);
              v1217 = quote_identifier(*(unsigned char **)(*(void *)(*(void *)(v1216 + 16)
                                                             + 8 * (*(_DWORD *)(v1216 + 4) - 1))
                                                 + 8));
              appendStringInfoString((uint64_t)&__s1, v1217);
              appendStringInfoString((uint64_t)&__s1, " ON DOMAIN ");
              deparseTypeName(&__s1, **(void **)(v1216 + 16));
              goto LABEL_2102;
            case 0x13u:
            case 0x1Cu:
            case 0x20u:
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 8));
              goto LABEL_2102;
            case 0x16u:
              deparseValue(&__s1, *(_DWORD **)(v18 + 8), 0, v298, v299, v300, v301, v302);
              goto LABEL_2102;
            case 0x18u:
            case 0x1Au:
              uint64_t v931 = *(void *)(v18 + 8);
              if (!v931) {
                goto LABEL_2115;
              }
              if (*(int *)(v931 + 4) >= 2)
              {
                int v932 = 1;
                do
                {
                  v933 = (uint64_t *)(*(void *)(v931 + 16) + 8 * v932);
                  uint64_t v935 = *v933;
                  unint64_t v934 = (unint64_t)(v933 + 1);
                  v936 = quote_identifier(*(unsigned char **)(v935 + 8));
                  appendStringInfoString((uint64_t)&__s1, v936);
                  uint64_t v937 = *(int *)(v931 + 4);
                  if (v934) {
                    BOOL v938 = v934 >= *(void *)(v931 + 16) + 8 * v937;
                  }
                  else {
                    BOOL v938 = 1;
                  }
                  if (!v938)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v937) = *(_DWORD *)(v931 + 4);
                  }
                  ++v932;
                }
                while ((int)v937 > v932);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              uint64_t v990 = **(void **)(v931 + 16);
LABEL_2098:
              v1215 = quote_identifier(*(unsigned char **)(v990 + 8));
              appendStringInfoString((uint64_t)&__s1, v1215);
LABEL_2102:
              appendStringInfoString((uint64_t)&__s1, " IS ");
              char v359 = *(char **)(v19 + 16);
              if (!v359) {
                goto LABEL_2103;
              }
              goto LABEL_1699;
            case 0x19u:
              deparseOperatorWithArgtypes(&__s1, *(void *)(v18 + 8));
              goto LABEL_2102;
            case 0x1Bu:
            case 0x21u:
            case 0x26u:
            case 0x2Au:
              uint64_t v880 = *(void *)(v18 + 8);
              v881 = quote_identifier(*(unsigned char **)(*(void *)(*(void *)(v880 + 16) + 8 * (*(_DWORD *)(v880 + 4) - 1))
                                                + 8));
              appendStringInfoString((uint64_t)&__s1, v881);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              uint64_t v882 = *(unsigned int *)(v880 + 4);
              if ((int)v882 >= 1)
              {
                uint64_t v883 = 8;
                uint64_t v884 = 0;
                do
                {
                  uint64_t v886 = v882;
                  uint64_t v887 = *(void *)(v880 + 16);
                  if (v887 + v883) {
                    BOOL v888 = v887 + v883 >= (unint64_t)(v887 + 8 * (int)v886);
                  }
                  else {
                    BOOL v888 = 1;
                  }
                  if (!v888)
                  {
                    v889 = quote_identifier(*(unsigned char **)(*(void *)(v887 + 8 * v884) + 8));
                    appendStringInfoString((uint64_t)&__s1, v889);
                    uint64_t v886 = *(unsigned int *)(v880 + 4);
                    if (v884 < *(_DWORD *)(v880 + 4) - 2)
                    {
                      appendStringInfoChar((uint64_t)&__s1, 46);
                      uint64_t v886 = *(unsigned int *)(v880 + 4);
                    }
                  }
                  uint64_t v882 = v886;
                  BOOL v885 = v884 + 1 < (int)v886;
                  v883 += 8;
                  ++v884;
                }
                while (v885);
              }
              goto LABEL_2102;
            case 0x29u:
              uint64_t v1214 = *(void *)(v18 + 8);
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              deparseTypeName(&__s1, **(void **)(v1214 + 16));
              appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
              uint64_t v990 = *(void *)(*(void *)(v1214 + 16) + 8);
              goto LABEL_2098;
            default:
              goto LABEL_2102;
          }
        case 0xFC:
          if (*(unsigned char *)(v18 + 24)) {
            long long v281 = "MOVE ";
          }
          else {
            long long v281 = "FETCH ";
          }
          appendStringInfoString((uint64_t)&__s1, v281);
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              uint64_t v288 = *(void *)(v18 + 8);
              if (v288 == 1) {
                goto LABEL_1600;
              }
              if (v288 == 0x7FFFFFFFFFFFFFFFLL)
              {
                long long v289 = "ALL ";
                goto LABEL_1598;
              }
              appendStringInfo((uint64_t)&__s1, "FORWARD %ld ", v282, v283, v284, v285, v286, v287, *(void *)(v19 + 8));
              goto LABEL_1600;
            case 1:
              uint64_t v623 = *(void *)(v18 + 8);
              if (v623 == 0x7FFFFFFFFFFFFFFFLL)
              {
                long long v289 = "BACKWARD ALL ";
                goto LABEL_1598;
              }
              if (v623 == 1)
              {
                long long v289 = "PRIOR ";
                goto LABEL_1598;
              }
              appendStringInfo((uint64_t)&__s1, "BACKWARD %ld ", v282, v283, v284, v285, v286, v287, *(void *)(v19 + 8));
              goto LABEL_1600;
            case 2:
              uint64_t v624 = *(void *)(v18 + 8);
              if (v624 == -1)
              {
                long long v289 = "LAST ";
              }
              else
              {
                if (v624 != 1)
                {
                  appendStringInfo((uint64_t)&__s1, "ABSOLUTE %ld ", v282, v283, v284, v285, v286, v287, *(void *)(v19 + 8));
LABEL_1600:
                  long long v27 = *(char **)(v18 + 16);
                  goto LABEL_2104;
                }
                long long v289 = "FIRST ";
              }
LABEL_1598:
              appendStringInfoString((uint64_t)&__s1, v289);
              long long v27 = *(char **)(v18 + 16);
              goto LABEL_2104;
            case 3:
              appendStringInfo((uint64_t)&__s1, "RELATIVE %ld ", v282, v283, v284, v285, v286, v287, *(void *)(v18 + 8));
              goto LABEL_1600;
            default:
              goto LABEL_1600;
          }
        case 0xFD:
          deparseIndexStmt(&__s1, v18);
          goto LABEL_2105;
        case 0xFE:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 5)) {
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          }
          if (*(unsigned char *)(v18 + 4)) {
            Swift::String v224 = "PROCEDURE ";
          }
          else {
            Swift::String v224 = "FUNCTION ";
          }
          appendStringInfoString((uint64_t)&__s1, v224);
          uint64_t v225 = *(void *)(v18 + 8);
          if (v225 && *(int *)(v225 + 4) >= 1)
          {
            uint64_t v226 = 8;
            uint64_t v227 = 0;
            do
            {
              uint64_t v228 = *(void *)(v225 + 16);
              uint64_t v229 = quote_identifier(*(unsigned char **)(*(void *)(v228 + 8 * v227) + 8));
              appendStringInfoString((uint64_t)&__s1, v229);
              uint64_t v230 = *(int *)(v225 + 4);
              if (v228 + v226) {
                BOOL v231 = v228 + v226 >= (unint64_t)(*(void *)(v225 + 16) + 8 * v230);
              }
              else {
                BOOL v231 = 1;
              }
              if (!v231)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v230 = *(int *)(v225 + 4);
              }
              ++v227;
              v226 += 8;
            }
            while (v227 < v230);
          }
          appendStringInfoChar((uint64_t)&__s1, 40);
          uint64_t v252 = *(void *)(v19 + 16);
          if (v252 && *(int *)(v252 + 4) >= 1)
          {
            uint64_t v253 = 8;
            uint64_t v254 = 0;
            uint64_t v255 = 0;
            do
            {
              uint64_t v257 = *(void *)(v252 + 16);
              uint64_t v258 = *(void *)(v257 + 8 * v254);
              if (*(_DWORD *)(v258 + 24) == 116)
              {
                uint64_t v256 = 1;
              }
              else
              {
                deparseFunctionParameter(&__s1, v258);
                if (v257 + v253) {
                  BOOL v259 = v257 + v253 >= (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
                }
                                                         + 8 * *(int *)(*(void *)(v19 + 16) + 4));
                else {
                  BOOL v259 = 1;
                }
                if (!v259 && *(_DWORD *)(*(void *)(v257 + 8 * v254 + 8) + 24) != 116) {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                }
                uint64_t v256 = v255;
              }
              ++v254;
              v253 += 8;
              uint64_t v255 = v256;
            }
            while (v254 < *(int *)(v252 + 4));
            appendStringInfoString((uint64_t)&__s1, ") ");
            if (v256)
            {
              appendStringInfoString((uint64_t)&__s1, "RETURNS TABLE (");
              uint64_t v547 = *(void *)(v19 + 16);
              if (v547 && *(int *)(v547 + 4) >= 1)
              {
                uint64_t v548 = 8;
                uint64_t v549 = 0;
                do
                {
                  uint64_t v550 = *(void *)(v547 + 16);
                  uint64_t v551 = *(void *)(v550 + 8 * v549);
                  if (*(_DWORD *)(v551 + 24) == 116)
                  {
                    deparseFunctionParameter(&__s1, v551);
                    if (v550 + v548
                      && v550 + v548 < (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
                                                        + 8 * *(int *)(*(void *)(v19 + 16) + 4)))
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                    }
                  }
                  ++v549;
                  v548 += 8;
                }
                while (v549 < *(int *)(v547 + 4));
              }
              appendStringInfoString((uint64_t)&__s1, ") ");
              goto LABEL_1025;
            }
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (*(void *)(v19 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "RETURNS ");
            deparseTypeName(&__s1, *(void *)(v19 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
LABEL_1025:
          uint64_t v626 = *(void *)(v19 + 32);
          if (!v626 || *(int *)(v626 + 4) < 1) {
            goto LABEL_1483;
          }
          uint64_t v627 = *(void *)(v19 + 32);
          uint64_t v628 = 0;
          uint64_t v1220 = v627;
          while (1)
          {
            uint64_t v630 = *(void *)(*(void *)(v627 + 16) + 8 * v628);
            v631 = *(const char **)(v630 + 16);
            uint64_t v632 = v16;
            if (!strcmp(v631, "as"))
            {
              uint64_t v633 = v17;
              appendStringInfoString((uint64_t)&__s1, "AS ");
              uint64_t v634 = *(void *)(v630 + 24);
              if (v634 && *(int *)(v634 + 4) >= 1)
              {
                uint64_t v635 = 0;
                do
                {
                  uint64_t v636 = *(void *)(v634 + 16) + 8 * v635;
                  v637 = *(char **)(*(void *)v636 + 8);
                  if (strstr(v637, "$$"))
                  {
                    if (strchr(v637, 92)) {
                      appendStringInfoChar((uint64_t)&__s1, 69);
                    }
                    appendStringInfoChar((uint64_t)&__s1, 39);
                    for (unint64_t i = v637; ; ++i)
                    {
                      int v639 = *i;
                      char v640 = *i;
                      if (v639 == 39 || v639 == 92)
                      {
                        appendStringInfoChar((uint64_t)&__s1, v639);
                      }
                      else if (!*i)
                      {
                        appendStringInfoChar((uint64_t)&__s1, 39);
                        uint64_t v641 = *(int *)(v634 + 4);
                        uint64_t v642 = v641;
                        unint64_t v643 = v636 + 8;
                        if (v636 == -8) {
                          goto LABEL_1039;
                        }
                        goto LABEL_1052;
                      }
                      appendStringInfoChar((uint64_t)&__s1, v640);
                    }
                  }
                  appendStringInfoString((uint64_t)&__s1, "$$");
                  appendStringInfoString((uint64_t)&__s1, v637);
                  appendStringInfoString((uint64_t)&__s1, "$$");
                  uint64_t v641 = *(int *)(v634 + 4);
                  uint64_t v642 = v641;
                  unint64_t v643 = v636 + 8;
                  if (v636 == -8) {
                    goto LABEL_1039;
                  }
LABEL_1052:
                  if (v643 < *(void *)(v634 + 16) + 8 * v641)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v642 = *(int *)(v634 + 4);
                  }
LABEL_1039:
                  ++v635;
                }
                while (v635 < v642);
              }
              goto LABEL_1030;
            }
            uint64_t v633 = v17;
            if (!strcmp(v631, "language"))
            {
              appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
              v644 = *(char **)(*(void *)(v630 + 24) + 8);
              size_t v645 = strlen(v644);
              if (v645)
              {
                if (v645 >= 0x40)
                {
                  deparseStringLiteral((uint64_t)&__s1, v644);
                  goto LABEL_1030;
                }
                v629 = quote_identifier(v644);
              }
              else
              {
                v629 = "''";
              }
            }
            else
            {
              if (!strcmp(v631, "transform"))
              {
                uint64_t v646 = *(void *)(v630 + 24);
                appendStringInfoString((uint64_t)&__s1, "TRANSFORM ");
                if (v646 && *(int *)(v646 + 4) >= 1)
                {
                  uint64_t v647 = 8;
                  uint64_t v648 = 0;
                  do
                  {
                    uint64_t v649 = *(void *)(v646 + 16);
                    appendStringInfoString((uint64_t)&__s1, "FOR TYPE ");
                    deparseTypeName(&__s1, *(void *)(v649 + 8 * v648));
                    uint64_t v650 = *(int *)(v646 + 4);
                    if (v649 + v647) {
                      BOOL v651 = v649 + v647 >= (unint64_t)(*(void *)(v646 + 16) + 8 * v650);
                    }
                    else {
                      BOOL v651 = 1;
                    }
                    if (!v651)
                    {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                      uint64_t v650 = *(int *)(v646 + 4);
                    }
                    ++v648;
                    v647 += 8;
                  }
                  while (v648 < v650);
                }
                goto LABEL_1030;
              }
              if (strcmp(v631, "window"))
              {
                deparseCommonFuncOptItem(&__s1, v630);
                goto LABEL_1030;
              }
              v629 = "WINDOW";
            }
            appendStringInfoString((uint64_t)&__s1, v629);
LABEL_1030:
            appendStringInfoChar((uint64_t)&__s1, 32);
            ++v628;
            uint64_t v627 = v1220;
            uint64_t v17 = v633;
            uint64_t v16 = v632;
            if (v628 >= *(int *)(v1220 + 4)) {
              goto LABEL_1483;
            }
          }
        case 0xFF:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          int v198 = *(_DWORD *)(v18 + 4);
          switch(v198)
          {
            case 19:
              long long v199 = "FUNCTION ";
              break;
            case 32:
              long long v199 = "ROUTINE ";
              break;
            case 28:
              long long v199 = "PROCEDURE ";
              break;
            default:
              goto LABEL_965;
          }
          appendStringInfoString((uint64_t)&__s1, v199);
LABEL_965:
          deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v611 = *(void *)(v18 + 16);
          if (v611 && *(int *)(v611 + 4) >= 1)
          {
            uint64_t v612 = 8;
            uint64_t v613 = 0;
            do
            {
              uint64_t v614 = *(void *)(v611 + 16);
              deparseCommonFuncOptItem(&__s1, *(void *)(v614 + 8 * v613));
              if (v614 + v612) {
                BOOL v615 = v614 + v612 >= (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 16) + 4));
              else {
                BOOL v615 = 1;
              }
              if (!v615) {
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              ++v613;
              v612 += 8;
            }
            while (v613 < *(int *)(v611 + 4));
          }
          goto LABEL_2105;
        case 0x100:
          appendStringInfoString((uint64_t)&__s1, "DO ");
          uint64_t v312 = *(void *)(v18 + 8);
          if (!v312 || *(int *)(v312 + 4) < 1) {
            goto LABEL_1483;
          }
          int v313 = *(_DWORD *)(v312 + 4);
          uint64_t v314 = 0;
          while (1)
          {
            uint64_t v316 = *(void *)(*(void *)(v312 + 16) + 8 * v314);
            uint64_t v317 = *(const char **)(v316 + 16);
            if (!strcmp(v317, "language"))
            {
              appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
              unint64_t v315 = quote_identifier(*(unsigned char **)(*(void *)(v316 + 24) + 8));
            }
            else
            {
              if (strcmp(v317, "as")) {
                goto LABEL_481;
              }
              uint64_t v318 = *(char **)(*(void *)(v316 + 24) + 8);
              v319 = "$$";
              if (strstr(v318, "$$")) {
                v319 = "$outer$";
              }
              appendStringInfoString((uint64_t)&__s1, v319);
              appendStringInfoString((uint64_t)&__s1, v318);
              unint64_t v315 = v319;
            }
            appendStringInfoString((uint64_t)&__s1, v315);
            appendStringInfoChar((uint64_t)&__s1, 32);
            int v313 = *(_DWORD *)(v312 + 4);
LABEL_481:
            if (++v314 >= v313)
            {
LABEL_1483:
              uint64_t v352 = (v1233 - 1);
              uint64_t v15 = v1227;
              if ((int)v1233 < 1) {
                goto LABEL_2105;
              }
              goto LABEL_2093;
            }
          }
        case 0x101:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          v392 = "AGGREGATE ";
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              goto LABEL_1994;
            case 4:
            case 0x2F:
              v392 = "TYPE ";
              goto LABEL_1994;
            case 6:
              v392 = "TABLE ";
              switch(*(_DWORD *)(v18 + 8))
              {
                case 0x12:
                  goto LABEL_1965;
                case 0x17:
                  goto LABEL_1966;
                case 0x27:
                  goto LABEL_1994;
                case 0x31:
                  goto LABEL_1967;
                default:
                  goto LABEL_1995;
              }
              break;
            case 7:
              v392 = "COLLATION ";
              goto LABEL_1994;
            case 8:
              v392 = "CONVERSION ";
              goto LABEL_1994;
            case 9:
              v392 = "DATABASE ";
              goto LABEL_1994;
            case 0xC:
            case 0xD:
              v392 = "DOMAIN ";
              goto LABEL_1994;
            case 0xE:
              v392 = "EVENT TRIGGER ";
              goto LABEL_1994;
            case 0x10:
              v392 = "FOREIGN DATA WRAPPER ";
              goto LABEL_1994;
            case 0x11:
              v392 = "SERVER ";
              goto LABEL_1994;
            case 0x12:
LABEL_1965:
              v392 = "FOREIGN TABLE ";
              goto LABEL_1994;
            case 0x13:
              v392 = "FUNCTION ";
              goto LABEL_1994;
            case 0x14:
              v392 = "INDEX ";
              goto LABEL_1994;
            case 0x15:
              v392 = "LANGUAGE ";
              goto LABEL_1994;
            case 0x17:
LABEL_1966:
              v392 = "MATERIALIZED VIEW ";
              goto LABEL_1994;
            case 0x18:
              v392 = "OPERATOR CLASS ";
              goto LABEL_1994;
            case 0x1A:
              v392 = "OPERATOR FAMILY ";
              goto LABEL_1994;
            case 0x1B:
              v392 = "POLICY ";
              goto LABEL_1994;
            case 0x1C:
              v392 = "PROCEDURE ";
              goto LABEL_1994;
            case 0x1D:
              v392 = "PUBLICATION ";
              goto LABEL_1994;
            case 0x1F:
              v392 = "ROLE ";
              goto LABEL_1994;
            case 0x20:
              v392 = "ROUTINE ";
              goto LABEL_1994;
            case 0x21:
              v392 = "RULE ";
              goto LABEL_1994;
            case 0x22:
              v392 = "SCHEMA ";
              goto LABEL_1994;
            case 0x23:
              v392 = "SEQUENCE ";
              goto LABEL_1994;
            case 0x24:
              v392 = "SUBSCRIPTION ";
              goto LABEL_1994;
            case 0x25:
              v392 = "STATISTICS ";
              goto LABEL_1994;
            case 0x26:
            case 0x27:
              v392 = "TABLE ";
              goto LABEL_1994;
            case 0x28:
              v392 = "TABLESPACE ";
              goto LABEL_1994;
            case 0x2A:
              v392 = "TRIGGER ";
              goto LABEL_1994;
            case 0x2B:
              v392 = "TEXT SEARCH CONFIGURATION ";
              goto LABEL_1994;
            case 0x2C:
              v392 = "TEXT SEARCH DICTIONARY ";
              goto LABEL_1994;
            case 0x2D:
              v392 = "TEXT SEARCH PARSER ";
              goto LABEL_1994;
            case 0x2E:
              v392 = "TEXT SEARCH TEMPLATE ";
              goto LABEL_1994;
            case 0x31:
LABEL_1967:
              v392 = "VIEW ";
LABEL_1994:
              appendStringInfoString((uint64_t)&__s1, v392);
              break;
            default:
              break;
          }
LABEL_1995:
          if (*(unsigned char *)(v18 + 52)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 24));
              goto LABEL_2027;
            case 4:
              deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 16), 9);
              v1183 = " RENAME ATTRIBUTE ";
              goto LABEL_2043;
            case 6:
              deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 16), 0);
              v1183 = " RENAME COLUMN ";
              goto LABEL_2043;
            case 7:
            case 8:
            case 0xC:
            case 0x25:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
              uint64_t v1163 = *(void *)(v18 + 24);
              if (v1163 && *(int *)(v1163 + 4) >= 1)
              {
                uint64_t v1164 = 8;
                uint64_t v1165 = 0;
                do
                {
                  uint64_t v1166 = *(void *)(v1163 + 16);
                  v1167 = quote_identifier(*(unsigned char **)(*(void *)(v1166 + 8 * v1165) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1167);
                  uint64_t v1168 = *(int *)(v1163 + 4);
                  if (v1166 + v1164) {
                    BOOL v1169 = v1166 + v1164 >= (unint64_t)(*(void *)(v1163 + 16) + 8 * v1168);
                  }
                  else {
                    BOOL v1169 = 1;
                  }
                  if (!v1169)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1168 = *(int *)(v1163 + 4);
                  }
                  ++v1165;
                  v1164 += 8;
                }
                while (v1165 < v1168);
              }
              goto LABEL_2027;
            case 9:
            case 0x1F:
            case 0x22:
            case 0x28:
              v1171 = *(unsigned char **)(v18 + 32);
              goto LABEL_2011;
            case 0xD:
              uint64_t v1184 = *(void *)(v18 + 24);
              if (v1184 && *(int *)(v1184 + 4) >= 1)
              {
                uint64_t v1185 = 8;
                uint64_t v1186 = 0;
                do
                {
                  uint64_t v1187 = *(void *)(v1184 + 16);
                  v1188 = quote_identifier(*(unsigned char **)(*(void *)(v1187 + 8 * v1186) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1188);
                  uint64_t v1189 = *(int *)(v1184 + 4);
                  if (v1187 + v1185) {
                    BOOL v1190 = v1187 + v1185 >= (unint64_t)(*(void *)(v1184 + 16) + 8 * v1189);
                  }
                  else {
                    BOOL v1190 = 1;
                  }
                  if (!v1190)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1189 = *(int *)(v1184 + 4);
                  }
                  ++v1186;
                  v1185 += 8;
                }
                while (v1186 < v1189);
              }
              v1183 = " RENAME CONSTRAINT ";
              goto LABEL_2043;
            case 0xE:
            case 0x10:
            case 0x11:
            case 0x15:
            case 0x1D:
            case 0x24:
              v1171 = *(unsigned char **)(*(void *)(v18 + 24) + 8);
LABEL_2011:
              v1172 = quote_identifier(v1171);
              goto LABEL_2012;
            case 0x12:
            case 0x14:
            case 0x17:
            case 0x23:
            case 0x27:
            case 0x31:
              uint64_t v1170 = *(void *)(v18 + 16);
              goto LABEL_2014;
            case 0x13:
            case 0x1C:
            case 0x20:
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 24));
              goto LABEL_2027;
            case 0x18:
            case 0x1A:
              uint64_t v1174 = *(void *)(v18 + 24);
              if (!v1174) {
                goto LABEL_2115;
              }
              if (*(int *)(v1174 + 4) >= 2)
              {
                int v1175 = 1;
                do
                {
                  v1176 = (uint64_t *)(*(void *)(v1174 + 16) + 8 * v1175);
                  uint64_t v1178 = *v1176;
                  unint64_t v1177 = (unint64_t)(v1176 + 1);
                  v1179 = quote_identifier(*(unsigned char **)(v1178 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1179);
                  uint64_t v1180 = *(int *)(v1174 + 4);
                  if (v1177) {
                    BOOL v1181 = v1177 >= *(void *)(v1174 + 16) + 8 * v1180;
                  }
                  else {
                    BOOL v1181 = 1;
                  }
                  if (!v1181)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1180) = *(_DWORD *)(v1174 + 4);
                  }
                  ++v1175;
                }
                while ((int)v1180 > v1175);
              }
              appendStringInfoString((uint64_t)&__s1, " USING ");
              v1172 = quote_identifier(*(unsigned char **)(**(void **)(v1174 + 16) + 8));
LABEL_2012:
              appendStringInfoString((uint64_t)&__s1, v1172);
              goto LABEL_2027;
            case 0x1B:
            case 0x21:
            case 0x2A:
              v1173 = quote_identifier(*(unsigned char **)(v18 + 32));
              appendStringInfoString((uint64_t)&__s1, v1173);
              appendStringInfoString((uint64_t)&__s1, " ON ");
              uint64_t v1170 = *(void *)(v18 + 16);
LABEL_2014:
              deparseRangeVar((uint64_t)&__s1, v1170, 0);
LABEL_2027:
              appendStringInfoString((uint64_t)&__s1, " RENAME ");
              break;
            case 0x26:
              deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 16), 0);
              v1183 = " RENAME CONSTRAINT ";
LABEL_2043:
              appendStringInfoString((uint64_t)&__s1, v1183);
              v1191 = quote_identifier(*(unsigned char **)(v19 + 32));
              appendStringInfoString((uint64_t)&__s1, v1191);
              appendStringInfoChar((uint64_t)&__s1, 32);
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, "TO ");
          v1182 = quote_identifier(*(unsigned char **)(v19 + 40));
          appendStringInfoString((uint64_t)&__s1, v1182);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v19 + 48) == 1) {
            goto LABEL_2029;
          }
          goto LABEL_2092;
        case 0x102:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 48)) {
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          }
          appendStringInfoString((uint64_t)&__s1, "RULE ");
          uint64_t v117 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v117);
          appendStringInfoString((uint64_t)&__s1, " AS ON ");
          unsigned int v118 = *(_DWORD *)(v18 + 32) - 1;
          if (v118 <= 3) {
            appendStringInfoString((uint64_t)&__s1, (&off_1E55D8E40)[v118]);
          }
          appendStringInfoString((uint64_t)&__s1, "TO ");
          deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 8), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v119 = *(int **)(v18 + 24);
          if (v119)
          {
            appendStringInfoString((uint64_t)&__s1, "WHERE ");
            deparseExpr(&__s1, v119, v120, v121, v122, v123, v124, v125);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "DO ");
          if (*(unsigned char *)(v18 + 36)) {
            appendStringInfoString((uint64_t)&__s1, "INSTEAD ");
          }
          uint64_t v126 = *(void *)(v18 + 40);
          if (!v126) {
            goto LABEL_180;
          }
          int v127 = *(_DWORD *)(v126 + 4);
          if (v127 == 1)
          {
            deparseRuleActionStmt(&__s1, **(void **)(v126 + 16));
          }
          else
          {
            if (!v127)
            {
LABEL_180:
              long long v27 = "NOTHING";
              goto LABEL_2104;
            }
            appendStringInfoChar((uint64_t)&__s1, 40);
            uint64_t v617 = *(void *)(v18 + 40);
            if (v617 && *(int *)(v617 + 4) >= 1)
            {
              uint64_t v618 = 8;
              uint64_t v619 = 0;
              do
              {
                uint64_t v620 = *(void *)(v617 + 16);
                deparseRuleActionStmt(&__s1, *(void *)(v620 + 8 * v619));
                if (v620 + v618) {
                  BOOL v621 = v620 + v618 >= (unint64_t)(*(void *)(*(void *)(v19 + 40) + 16)
                }
                                                         + 8 * *(int *)(*(void *)(v19 + 40) + 4));
                else {
                  BOOL v621 = 1;
                }
                if (!v621) {
                  appendStringInfoString((uint64_t)&__s1, "; ");
                }
                ++v619;
                v618 += 8;
              }
              while (v619 < *(int *)(v617 + 4));
            }
LABEL_996:
            appendStringInfoChar((uint64_t)&__s1, 41);
          }
          goto LABEL_2105;
        case 0x103:
          appendStringInfoString((uint64_t)&__s1, "NOTIFY ");
          v384 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v384);
          if (!*(void *)(v18 + 16)) {
            goto LABEL_2105;
          }
          appendStringInfoString((uint64_t)&__s1, ", ");
          char v359 = *(char **)(v18 + 16);
          goto LABEL_1699;
        case 0x104:
          appendStringInfoString((uint64_t)&__s1, "LISTEN ");
          uint64_t v108 = *(unsigned char **)(v18 + 8);
          goto LABEL_1818;
        case 0x105:
          appendStringInfoString((uint64_t)&__s1, "UNLISTEN ");
          uint64_t v108 = *(unsigned char **)(v18 + 8);
          if (v108) {
            goto LABEL_1818;
          }
          long long v27 = "*";
          goto LABEL_2104;
        case 0x106:
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              v393 = "BEGIN ";
              goto LABEL_1549;
            case 1:
              v393 = "START TRANSACTION ";
LABEL_1549:
              appendStringInfoString((uint64_t)&__s1, v393);
              deparseTransactionModeList((uint64_t)&__s1, *(void *)(v18 + 8));
              goto LABEL_2092;
            case 2:
              v890 = "COMMIT ";
              goto LABEL_1552;
            case 3:
              v890 = "ROLLBACK ";
LABEL_1552:
              appendStringInfoString((uint64_t)&__s1, v890);
              if (*(unsigned char *)(v18 + 32)) {
                appendStringInfoString((uint64_t)&__s1, "AND CHAIN ");
              }
              goto LABEL_2092;
            case 4:
              v891 = "SAVEPOINT ";
              goto LABEL_1558;
            case 5:
              v891 = "RELEASE ";
              goto LABEL_1558;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "ROLLBACK ");
              v891 = "TO SAVEPOINT ";
LABEL_1558:
              appendStringInfoString((uint64_t)&__s1, v891);
              v892 = quote_identifier(*(unsigned char **)(v18 + 16));
              appendStringInfoString((uint64_t)&__s1, v892);
              goto LABEL_2092;
            case 7:
              v893 = "PREPARE TRANSACTION ";
              goto LABEL_1562;
            case 8:
              v893 = "COMMIT PREPARED ";
              goto LABEL_1562;
            case 9:
              v893 = "ROLLBACK PREPARED ";
LABEL_1562:
              appendStringInfoString((uint64_t)&__s1, v893);
              deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
              break;
            default:
              goto LABEL_2092;
          }
          goto LABEL_2092;
        case 0x107:
          deparseViewStmt(&__s1, v18);
          goto LABEL_2105;
        case 0x108:
          appendStringInfoString((uint64_t)&__s1, "LOAD ");
          char v359 = *(char **)(v18 + 8);
          goto LABEL_1699;
        case 0x109:
          appendStringInfoString((uint64_t)&__s1, "CREATE DOMAIN ");
          uint64_t v344 = *(void *)(v18 + 8);
          if (v344 && *(int *)(v344 + 4) >= 1)
          {
            uint64_t v345 = 8;
            uint64_t v346 = 0;
            do
            {
              uint64_t v347 = *(void *)(v344 + 16);
              long long v348 = quote_identifier(*(unsigned char **)(*(void *)(v347 + 8 * v346) + 8));
              appendStringInfoString((uint64_t)&__s1, v348);
              uint64_t v349 = *(int *)(v344 + 4);
              if (v347 + v345) {
                BOOL v350 = v347 + v345 >= (unint64_t)(*(void *)(v344 + 16) + 8 * v349);
              }
              else {
                BOOL v350 = 1;
              }
              if (!v350)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v349 = *(int *)(v344 + 4);
              }
              ++v346;
              v345 += 8;
            }
            while (v346 < v349);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ");
          deparseTypeName(&__s1, *(void *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v353 = *(void *)(v19 + 24);
          if (v353)
          {
            deparseCollateClause((uint64_t)&__s1, v353);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          uint64_t v354 = *(void *)(v19 + 32);
          if (v354 && *(int *)(v354 + 4) >= 1)
          {
            uint64_t v355 = 0;
            do
            {
              uint64_t v356 = v355;
              deparseConstraint(&__s1, *(void *)(*(void *)(v354 + 16) + 8 * v355));
              appendStringInfoChar((uint64_t)&__s1, 32);
              uint64_t v355 = v356 + 1;
            }
            while (v356 + 1 < *(int *)(v354 + 4));
          }
          goto LABEL_2092;
        case 0x10A:
          appendStringInfoString((uint64_t)&__s1, "CREATE DATABASE ");
          v351 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v351);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreatedbOptList((unint64_t)&__s1, *(void *)(v18 + 16));
          uint64_t v352 = (v1233 - 1);
          if ((int)v1233 < 1) {
            goto LABEL_2105;
          }
          goto LABEL_2093;
        case 0x10B:
          appendStringInfoString((uint64_t)&__s1, "DROP DATABASE ");
          if (*(unsigned char *)(v18 + 16)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          long long v360 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v360);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v361 = *(void *)(v18 + 24);
          if (!v361 || *(int *)(v361 + 4) < 1) {
            goto LABEL_2092;
          }
          appendStringInfoChar((uint64_t)&__s1, 40);
          uint64_t v362 = *(void *)(v18 + 24);
          if (v362 && *(int *)(v362 + 4) >= 1)
          {
            uint64_t v363 = 8;
            uint64_t v364 = 0;
            do
            {
              uint64_t v365 = *(void *)(v362 + 16);
              if (!strcmp(*(const char **)(*(void *)(v365 + 8 * v364) + 16), "force")) {
                appendStringInfoString((uint64_t)&__s1, "FORCE");
              }
              if (v365 + v363) {
                BOOL v366 = v365 + v363 >= (unint64_t)(*(void *)(*(void *)(v19 + 24) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 24) + 4));
              else {
                BOOL v366 = 1;
              }
              if (!v366) {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v364;
              v363 += 8;
            }
            while (v364 < *(int *)(v362 + 4));
          }
          char v553 = 41;
          goto LABEL_1309;
        case 0x10C:
          if (*(unsigned char *)(v18 + 24)) {
            uint64_t v232 = "VACUUM ";
          }
          else {
            uint64_t v232 = "ANALYZE ";
          }
          appendStringInfoString((uint64_t)&__s1, v232);
          uint64_t v233 = *(void *)(v18 + 8);
          if (v233 && *(int *)(v233 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            uint64_t v234 = *(void *)(v18 + 8);
            if (v234 && *(int *)(v234 + 4) >= 1)
            {
              uint64_t v235 = 0;
              do
              {
                uint64_t v236 = *(void *)(v234 + 16) + 8 * v235;
                uint64_t v237 = *(void *)v236;
                BOOL v238 = (char *)pstrdup(*(const char **)(*(void *)v236 + 16));
                uint64_t v239 = v238;
                if (*v238)
                {
                  unsigned __int8 v240 = *v238;
                  uint64_t v241 = (unsigned __int8 *)(v238 + 1);
                  do
                  {
                    uint64_t v242 = v241;
                    *(v241 - 1) = pg_toupper(v240);
                    unsigned __int8 v240 = *v242;
                    uint64_t v241 = v242 + 1;
                  }
                  while (*v242);
                }
                appendStringInfoString((uint64_t)&__s1, v239);
                pfree((uint64_t)v239);
                if (*(void *)(v237 + 24))
                {
                  appendStringInfoChar((uint64_t)&__s1, 32);
                  uint64_t v249 = *(char ***)(v237 + 24);
                  int v250 = *(_DWORD *)v249;
                  if (*(_DWORD *)v249 == 223)
                  {
                    deparseOptBooleanOrString(&__s1, v249[1]);
                  }
                  else if (v250 == 222)
                  {
                    appendStringInfoString((uint64_t)&__s1, v249[1]);
                  }
                  else if (v250 == 221)
                  {
                    appendStringInfo((uint64_t)&__s1, "%d", v243, v244, v245, v246, v247, v248, *((unsigned int *)v249 + 2));
                  }
                }
                if (v236 != -8
                  && v236 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 8) + 16)
                                                 + 8 * *(int *)(*(void *)(v19 + 8) + 4)))
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                }
                ++v235;
              }
              while (v235 < *(int *)(v234 + 4));
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          uint64_t v533 = *(void *)(v19 + 16);
          if (v533 && *(int *)(v533 + 4) >= 1)
          {
            uint64_t v534 = 0;
            uint64_t v1225 = v19;
            do
            {
              uint64_t v535 = *(void *)(v533 + 16) + 8 * v534;
              uint64_t v536 = *(void *)v535;
              deparseRangeVar((uint64_t)&__s1, *(void *)(*(void *)v535 + 8), 0);
              uint64_t v537 = *(void *)(v536 + 24);
              if (v537 && *(int *)(v537 + 4) >= 1)
              {
                uint64_t v538 = v16;
                uint64_t v539 = v17;
                appendStringInfoChar((uint64_t)&__s1, 40);
                uint64_t v540 = *(void *)(v536 + 24);
                if (v540 && *(int *)(v540 + 4) >= 1)
                {
                  uint64_t v541 = 8;
                  uint64_t v542 = 0;
                  do
                  {
                    uint64_t v543 = *(void *)(v540 + 16);
                    v544 = quote_identifier(*(unsigned char **)(*(void *)(v543 + 8 * v542) + 8));
                    appendStringInfoString((uint64_t)&__s1, v544);
                    if (v543 + v541) {
                      BOOL v545 = v543 + v541 >= (unint64_t)(*(void *)(*(void *)(v536 + 24) + 16)
                    }
                                                             + 8 * *(int *)(*(void *)(v536 + 24) + 4));
                    else {
                      BOOL v545 = 1;
                    }
                    if (!v545) {
                      appendStringInfoString((uint64_t)&__s1, ", ");
                    }
                    ++v542;
                    v541 += 8;
                  }
                  while (v542 < *(int *)(v540 + 4));
                }
                appendStringInfoChar((uint64_t)&__s1, 41);
                uint64_t v17 = v539;
                uint64_t v16 = v538;
                uint64_t v19 = v1225;
              }
              if (v535 != -8
                && v535 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
                                               + 8 * *(int *)(*(void *)(v19 + 16) + 4)))
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v534;
            }
            while (v534 < *(int *)(v533 + 4));
          }
          goto LABEL_1483;
        case 0x10D:
          appendStringInfoString((uint64_t)&__s1, "EXPLAIN ");
          uint64_t v165 = *(void *)(v18 + 16);
          if (v165 && *(int *)(v165 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            uint64_t v166 = *(void *)(v18 + 16);
            if (v166 && *(int *)(v166 + 4) >= 1)
            {
              uint64_t v167 = 0;
              do
              {
                uint64_t v168 = *(void *)(v166 + 16) + 8 * v167;
                uint64_t v169 = *(void *)v168;
                uint64_t v170 = (char *)pstrdup(*(const char **)(*(void *)v168 + 16));
                uint64_t v171 = v170;
                if (*v170)
                {
                  unsigned __int8 v172 = *v170;
                  Swift::Int v173 = (unsigned __int8 *)(v170 + 1);
                  do
                  {
                    uint64_t v174 = v173;
                    *(v173 - 1) = pg_toupper(v172);
                    unsigned __int8 v172 = *v174;
                    Swift::Int v173 = v174 + 1;
                  }
                  while (*v174);
                }
                appendStringInfoString((uint64_t)&__s1, v171);
                pfree((uint64_t)v171);
                unint64_t v175 = *(int **)(v169 + 24);
                if (v175)
                {
                  int v176 = *v175;
                  if (v176 == 223)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 32);
                    deparseOptBooleanOrString(&__s1, *(char **)(*(void *)(v169 + 24) + 8));
                  }
                  else if ((v176 - 221) <= 1)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 32);
                    uint64_t v183 = *(void *)(v169 + 24);
                    if (*(_DWORD *)v183 == 222)
                    {
                      appendStringInfoString((uint64_t)&__s1, *(char **)(v183 + 8));
                    }
                    else if (*(_DWORD *)v183 == 221)
                    {
                      appendStringInfo((uint64_t)&__s1, "%d", v177, v178, v179, v180, v181, v182, *(unsigned int *)(v183 + 8));
                    }
                  }
                }
                if (v168 != -8
                  && v168 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
                                                 + 8 * *(int *)(*(void *)(v19 + 16) + 4)))
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                }
                ++v167;
              }
              while (v167 < *(int *)(v166 + 4));
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
            uint64_t v15 = v1227;
          }
          v532 = *(uint64_t **)(v19 + 8);
          switch(*(_DWORD *)v532)
          {
            case 0xE9:
              goto LABEL_814;
            case 0xEA:
              goto LABEL_958;
            case 0xEB:
              goto LABEL_959;
            case 0xEC:
              goto LABEL_960;
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
            case 0x100:
            case 0x101:
            case 0x102:
            case 0x103:
            case 0x104:
            case 0x105:
            case 0x106:
            case 0x107:
            case 0x108:
            case 0x109:
            case 0x10A:
            case 0x10B:
            case 0x10C:
            case 0x10D:
            case 0x10F:
            case 0x110:
            case 0x111:
            case 0x112:
            case 0x113:
            case 0x114:
            case 0x115:
            case 0x116:
            case 0x117:
            case 0x118:
            case 0x119:
            case 0x11A:
            case 0x11B:
            case 0x11C:
            case 0x11D:
            case 0x11E:
            case 0x11F:
            case 0x120:
            case 0x121:
            case 0x122:
            case 0x123:
            case 0x124:
            case 0x125:
            case 0x126:
            case 0x128:
              goto LABEL_2105;
            case 0x10E:
              deparseCreateTableAsStmt(&__s1, (uint64_t)v532);
              break;
            case 0x127:
              deparseExecuteStmt(&__s1, (uint64_t)v532);
              break;
            case 0x129:
              deparseDeclareCursorStmt(&__s1, (uint64_t)v532);
              break;
            default:
              if (*(_DWORD *)v532 == 330) {
                deparseRefreshMatViewStmt((uint64_t)&__s1, (uint64_t)v532);
              }
              break;
          }
          goto LABEL_2105;
        case 0x10E:
          deparseCreateTableAsStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x10F:
          deparseCreateSeqStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x110:
          appendStringInfoString((uint64_t)&__s1, "ALTER SEQUENCE ");
          if (*(unsigned char *)(v18 + 25)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 8), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v200 = *(void *)(v18 + 16);
          if (v200 && *(int *)(v200 + 4) >= 1)
          {
            uint64_t v201 = 0;
            do
            {
              uint64_t v202 = v201;
              deparseSeqOptElem(&__s1, *(void *)(*(void *)(v200 + 16) + 8 * v201));
              appendStringInfoChar((uint64_t)&__s1, 32);
              uint64_t v201 = v202 + 1;
            }
            while (v202 + 1 < *(int *)(v200 + 4));
          }
          goto LABEL_2092;
        case 0x111:
          deparseVariableSetStmt((uint64_t)&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x112:
          appendStringInfoString((uint64_t)&__s1, "SHOW ");
          uint64_t v98 = *(const char **)(v18 + 8);
          if (!strcmp(v98, "timezone"))
          {
            long long v27 = "TIME ZONE";
          }
          else if (!strcmp(v98, "transaction_isolation"))
          {
            long long v27 = "TRANSACTION ISOLATION LEVEL";
          }
          else if (!strcmp(v98, "session_authorization"))
          {
            long long v27 = "SESSION AUTHORIZATION";
          }
          else if (!strcmp(v98, "all"))
          {
            long long v27 = "SESSION ALL";
          }
          else
          {
            long long v27 = (char *)v98;
          }
          goto LABEL_2104;
        case 0x113:
          appendStringInfoString((uint64_t)&__s1, "DISCARD ");
          uint64_t v405 = *(int *)(v18 + 4);
          if (v405 > 3) {
            goto LABEL_2105;
          }
          long long v27 = (&off_1E55D8C28)[v405];
          goto LABEL_2104;
        case 0x114:
          deparseCreateTrigStmt(&__s1, v18);
          goto LABEL_2105;
        case 0x115:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 4)) {
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          }
          if (*(unsigned char *)(v18 + 40)) {
            appendStringInfoString((uint64_t)&__s1, "TRUSTED ");
          }
          appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
          unint64_t v106 = *(char **)(v18 + 8);
          size_t v107 = strlen(v106);
          if (v107)
          {
            if (v107 >= 0x40)
            {
              deparseStringLiteral((uint64_t)&__s1, v106);
              goto LABEL_927;
            }
            v563 = quote_identifier(v106);
          }
          else
          {
            v563 = "''";
          }
          appendStringInfoString((uint64_t)&__s1, v563);
LABEL_927:
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "HANDLER ");
          uint64_t v589 = *(void *)(v18 + 16);
          if (v589 && *(int *)(v589 + 4) >= 1)
          {
            uint64_t v590 = 8;
            uint64_t v591 = 0;
            do
            {
              uint64_t v592 = *(void *)(v589 + 16);
              v593 = quote_identifier(*(unsigned char **)(*(void *)(v592 + 8 * v591) + 8));
              appendStringInfoString((uint64_t)&__s1, v593);
              uint64_t v594 = *(int *)(v589 + 4);
              if (v592 + v590) {
                BOOL v595 = v592 + v590 >= (unint64_t)(*(void *)(v589 + 16) + 8 * v594);
              }
              else {
                BOOL v595 = 1;
              }
              if (!v595)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v594 = *(int *)(v589 + 4);
              }
              ++v591;
              v590 += 8;
            }
            while (v591 < v594);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v19 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "INLINE ");
            uint64_t v596 = *(void *)(v19 + 24);
            if (v596 && *(int *)(v596 + 4) >= 1)
            {
              uint64_t v597 = 8;
              uint64_t v598 = 0;
              do
              {
                uint64_t v599 = *(void *)(v596 + 16);
                v600 = quote_identifier(*(unsigned char **)(*(void *)(v599 + 8 * v598) + 8));
                appendStringInfoString((uint64_t)&__s1, v600);
                uint64_t v601 = *(int *)(v596 + 4);
                if (v599 + v597) {
                  BOOL v602 = v599 + v597 >= (unint64_t)(*(void *)(v596 + 16) + 8 * v601);
                }
                else {
                  BOOL v602 = 1;
                }
                if (!v602)
                {
                  appendStringInfoChar((uint64_t)&__s1, 46);
                  uint64_t v601 = *(int *)(v596 + 4);
                }
                ++v598;
                v597 += 8;
              }
              while (v598 < v601);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (!*(void *)(v19 + 32)) {
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "VALIDATOR ");
          uint64_t v603 = *(void *)(v19 + 32);
          if (v603 && *(int *)(v603 + 4) >= 1)
          {
            uint64_t v604 = 8;
            uint64_t v605 = 0;
            do
            {
              uint64_t v606 = *(void *)(v603 + 16);
              v607 = quote_identifier(*(unsigned char **)(*(void *)(v606 + 8 * v605) + 8));
              appendStringInfoString((uint64_t)&__s1, v607);
              uint64_t v608 = *(int *)(v603 + 4);
              if (v606 + v604) {
                BOOL v609 = v606 + v604 >= (unint64_t)(*(void *)(v603 + 16) + 8 * v608);
              }
              else {
                BOOL v609 = 1;
              }
              if (!v609)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v608 = *(int *)(v603 + 4);
              }
              ++v605;
              v604 += 8;
            }
            while (v605 < v608);
          }
          char v553 = 32;
          goto LABEL_1309;
        case 0x116:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          uint64_t v331 = *(int *)(v18 + 4);
          if (v331 <= 2) {
            appendStringInfoString((uint64_t)&__s1, (&off_1E55D8C10)[v331]);
          }
          uint64_t v332 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v332);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(void *)(v18 + 16)) {
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          uint64_t v333 = *(void *)(v18 + 16);
          if (!v333 || *(int *)(v333 + 4) < 1) {
            goto LABEL_2092;
          }
          uint64_t v334 = 0;
          while (1)
          {
            uint64_t v335 = *(void *)(*(void *)(v333 + 16) + 8 * v334);
            v336 = *(const char **)(v335 + 16);
            if (!strcmp(v336, "sysid"))
            {
              appendStringInfo((uint64_t)&__s1, "SYSID %d", v337, v338, v339, v340, v341, v342, *(unsigned int *)(*(void *)(v335 + 24) + 8));
            }
            else
            {
              if (!strcmp(v336, "adminmembers"))
              {
                uint64_t v343 = "ADMIN ";
LABEL_523:
                appendStringInfoString((uint64_t)&__s1, v343);
                deparseRoleList(&__s1, *(void *)(v335 + 24));
                goto LABEL_514;
              }
              if (!strcmp(v336, "rolemembers"))
              {
                uint64_t v343 = "ROLE ";
                goto LABEL_523;
              }
              if (!strcmp(v336, "addroleto"))
              {
                uint64_t v343 = "IN ROLE ";
                goto LABEL_523;
              }
              deparseAlterRoleElem((uint64_t)&__s1, v335);
            }
LABEL_514:
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (++v334 >= *(int *)(v333 + 4)) {
              goto LABEL_2092;
            }
          }
        case 0x117:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          uint64_t v406 = *(void *)(v18 + 16);
          if (!v406
            || *(_DWORD *)(v406 + 4) != 1
            || strcmp(*(const char **)(**(void **)(v406 + 16) + 16), "rolemembers"))
          {
            appendStringInfoString((uint64_t)&__s1, "ROLE ");
            uint64_t v407 = *(void *)(v18 + 8);
            switch(*(_DWORD *)(v407 + 4))
            {
              case 0:
                v408 = quote_identifier(*(unsigned char **)(v407 + 8));
                goto LABEL_1080;
              case 1:
                v408 = "CURRENT_USER";
                goto LABEL_1080;
              case 2:
                v408 = "SESSION_USER";
                goto LABEL_1080;
              case 3:
                v408 = "public";
LABEL_1080:
                appendStringInfoString((uint64_t)&__s1, v408);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
            appendStringInfoString((uint64_t)&__s1, "WITH ");
            uint64_t v659 = *(void *)(v18 + 16);
            if (v659 && *(int *)(v659 + 4) >= 1)
            {
              uint64_t v660 = 0;
              do
              {
                uint64_t v661 = v660;
                deparseAlterRoleElem((uint64_t)&__s1, *(void *)(*(void *)(v659 + 16) + 8 * v660));
                appendStringInfoChar((uint64_t)&__s1, 32);
                uint64_t v660 = v661 + 1;
              }
              while (v661 + 1 < *(int *)(v659 + 4));
            }
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "GROUP ");
          uint64_t v848 = *(void *)(v18 + 8);
          switch(*(_DWORD *)(v848 + 4))
          {
            case 0:
              v849 = quote_identifier(*(unsigned char **)(v848 + 8));
              goto LABEL_2047;
            case 1:
              v849 = "CURRENT_USER";
              goto LABEL_2047;
            case 2:
              v849 = "SESSION_USER";
              goto LABEL_2047;
            case 3:
              v849 = "public";
LABEL_2047:
              appendStringInfoString((uint64_t)&__s1, v849);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          int v1192 = *(_DWORD *)(v18 + 24);
          if (v1192 == 1)
          {
            v1193 = "ADD USER ";
          }
          else
          {
            if (v1192 != -1)
            {
LABEL_2053:
              deparseRoleList(&__s1, *(void *)(**(void **)(*(void *)(v18 + 16) + 16) + 24));
              goto LABEL_2092;
            }
            v1193 = "DROP USER ";
          }
          appendStringInfoString((uint64_t)&__s1, v1193);
          goto LABEL_2053;
        case 0x118:
          appendStringInfoString((uint64_t)&__s1, "DROP ROLE ");
          if (*(unsigned char *)(v18 + 16)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          deparseRoleList(&__s1, *(void *)(v18 + 8));
          goto LABEL_2105;
        case 0x119:
          appendStringInfoString((uint64_t)&__s1, "LOCK TABLE ");
          uint64_t v290 = *(void *)(v18 + 8);
          if (v290 && *(int *)(v290 + 4) >= 1)
          {
            uint64_t v291 = 8;
            uint64_t v292 = 0;
            do
            {
              uint64_t v293 = *(void *)(v290 + 16);
              deparseRangeVar((uint64_t)&__s1, *(void *)(v293 + 8 * v292), 0);
              uint64_t v294 = *(int *)(v290 + 4);
              if (v293 + v291) {
                BOOL v295 = v293 + v291 >= (unint64_t)(*(void *)(v290 + 16) + 8 * v294);
              }
              else {
                BOOL v295 = 1;
              }
              if (!v295)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v294 = *(int *)(v290 + 4);
              }
              ++v292;
              v291 += 8;
            }
            while (v292 < v294);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v19 + 16) != 8)
          {
            appendStringInfoString((uint64_t)&__s1, "IN ");
            unsigned int v296 = *(_DWORD *)(v19 + 16) - 1;
            if (v296 <= 7) {
              appendStringInfoString((uint64_t)&__s1, (&off_1E55D8DD8)[v296]);
            }
            appendStringInfoString((uint64_t)&__s1, "MODE ");
          }
          if (*(unsigned char *)(v19 + 20)) {
            appendStringInfoString((uint64_t)&__s1, "NOWAIT ");
          }
          goto LABEL_2092;
        case 0x11A:
          appendStringInfoString((uint64_t)&__s1, "SET CONSTRAINTS ");
          uint64_t v396 = *(void *)(v18 + 8);
          if (v396 && *(int *)(v396 + 4) >= 1)
          {
            uint64_t v397 = 8;
            uint64_t v398 = 0;
            do
            {
              uint64_t v399 = *(void *)(v396 + 16);
              deparseRangeVar((uint64_t)&__s1, *(void *)(v399 + 8 * v398), 0);
              uint64_t v400 = *(int *)(v396 + 4);
              if (v399 + v397) {
                BOOL v401 = v399 + v397 >= (unint64_t)(*(void *)(v396 + 16) + 8 * v400);
              }
              else {
                BOOL v401 = 1;
              }
              if (!v401)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v400 = *(int *)(v396 + 4);
              }
              ++v398;
              v397 += 8;
            }
            while (v398 < v400);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, "ALL ");
          }
          if (*(unsigned char *)(v19 + 16)) {
            long long v27 = "DEFERRED";
          }
          else {
            long long v27 = "IMMEDIATE";
          }
          goto LABEL_2104;
        case 0x11B:
          appendStringInfoString((uint64_t)&__s1, "REINDEX ");
          if (*(unsigned char *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "(VERBOSE) ");
            uint64_t v420 = *(int *)(v18 + 4);
            if (v420 <= 4)
            {
LABEL_660:
              appendStringInfoString((uint64_t)&__s1, (&off_1E55D8E18)[v420]);
              if (!*(unsigned char *)(v18 + 28)) {
                goto LABEL_789;
              }
              goto LABEL_788;
            }
          }
          else
          {
            uint64_t v420 = *(int *)(v18 + 4);
            if (v420 <= 4) {
              goto LABEL_660;
            }
          }
          if (!*(unsigned char *)(v18 + 28)) {
            goto LABEL_789;
          }
LABEL_788:
          appendStringInfoString((uint64_t)&__s1, "CONCURRENTLY ");
LABEL_789:
          uint64_t v507 = *(void *)(v18 + 8);
          if (v507)
          {
            deparseRangeVar((uint64_t)&__s1, v507, 0);
            goto LABEL_2105;
          }
          uint64_t v108 = *(unsigned char **)(v18 + 16);
          if (v108)
          {
LABEL_1818:
            long long v27 = quote_identifier(v108);
LABEL_2104:
            appendStringInfoString((uint64_t)&__s1, v27);
          }
LABEL_2105:
          if (v17 != -8 && v17 + 8 < (unint64_t)(*(void *)(v15 + 16) + 8 * *(int *)(v15 + 4))) {
            appendStringInfoString((uint64_t)&__s1, "; ");
          }
          uint64_t v16 = (v16 + 1);
          if ((int)v16 >= *(_DWORD *)(v15 + 4)) {
            goto LABEL_2111;
          }
          continue;
        case 0x11C:
          long long v27 = "CHECKPOINT";
          goto LABEL_2104;
        case 0x11D:
          appendStringInfoString((uint64_t)&__s1, "CREATE SCHEMA ");
          if (*(unsigned char *)(v18 + 32)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          v380 = *(unsigned char **)(v18 + 8);
          if (v380)
          {
            v381 = quote_identifier(v380);
            appendStringInfoString((uint64_t)&__s1, v381);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "AUTHORIZATION ");
            uint64_t v382 = *(void *)(v18 + 16);
            switch(*(_DWORD *)(v382 + 4))
            {
              case 0:
                v383 = quote_identifier(*(unsigned char **)(v382 + 8));
                goto LABEL_1465;
              case 1:
                v383 = "CURRENT_USER";
                goto LABEL_1465;
              case 2:
                v383 = "SESSION_USER";
                goto LABEL_1465;
              case 3:
                v383 = "public";
LABEL_1465:
                appendStringInfoString((uint64_t)&__s1, v383);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          uint64_t v841 = *(void *)(v18 + 24);
          if (v841 && *(int *)(v841 + 4) >= 1)
          {
            uint64_t v842 = 8;
            uint64_t v843 = 0;
            do
            {
              uint64_t v844 = *(void *)(v841 + 16);
              v845 = *(_DWORD **)(v844 + 8 * v843);
              switch(*v845)
              {
                case 0xF1:
                  deparseGrantStmt((uint64_t)&__s1, (uint64_t)v845);
                  break;
                case 0xF7:
                  deparseCreateStmt(&__s1, (uint64_t)v845, 0);
                  break;
                case 0xFD:
                  deparseIndexStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x107:
                  deparseViewStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x10F:
                  deparseCreateSeqStmt(&__s1, (uint64_t)v845);
                  break;
                case 0x114:
                  deparseCreateTrigStmt(&__s1, (uint64_t)v845);
                  break;
                default:
                  break;
              }
              if (v844 + v842) {
                BOOL v846 = v844 + v842 >= (unint64_t)(*(void *)(*(void *)(v19 + 24) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 24) + 4));
              else {
                BOOL v846 = 1;
              }
              if (!v846) {
                appendStringInfoChar((uint64_t)&__s1, 32);
              }
              ++v843;
              v842 += 8;
            }
            while (v843 < *(int *)(v841 + 4));
          }
          goto LABEL_1483;
        case 0x11E:
          appendStringInfoString((uint64_t)&__s1, "ALTER DATABASE ");
          v367 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v367);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreatedbOptList((unint64_t)&__s1, *(void *)(v18 + 16));
          goto LABEL_2092;
        case 0x11F:
          appendStringInfoString((uint64_t)&__s1, "ALTER DATABASE ");
          v357 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v357);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v358 = *(void *)(v18 + 16);
          goto LABEL_1492;
        case 0x120:
          appendStringInfoString((uint64_t)&__s1, "ALTER ROLE ");
          uint64_t v418 = *(void *)(v18 + 8);
          if (v418)
          {
            switch(*(_DWORD *)(v418 + 4))
            {
              case 0:
                v419 = quote_identifier(*(unsigned char **)(v418 + 8));
                goto LABEL_1488;
              case 1:
                v419 = "CURRENT_USER";
                goto LABEL_1488;
              case 2:
                v419 = "SESSION_USER";
                goto LABEL_1488;
              case 3:
                v419 = "public";
                goto LABEL_1488;
              default:
                break;
            }
          }
          else
          {
            v419 = "ALL";
LABEL_1488:
            appendStringInfoString((uint64_t)&__s1, v419);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "IN DATABASE ");
            v847 = quote_identifier(*(unsigned char **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, v847);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          uint64_t v358 = *(void *)(v18 + 24);
          goto LABEL_1492;
        case 0x121:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 40)) {
            appendStringInfoString((uint64_t)&__s1, "DEFAULT ");
          }
          appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
          uint64_t v203 = *(void *)(v18 + 8);
          if (v203 && *(int *)(v203 + 4) >= 1)
          {
            uint64_t v204 = 8;
            uint64_t v205 = 0;
            do
            {
              uint64_t v206 = *(void *)(v203 + 16);
              uint64_t v207 = quote_identifier(*(unsigned char **)(*(void *)(v206 + 8 * v205) + 8));
              appendStringInfoString((uint64_t)&__s1, v207);
              uint64_t v208 = *(int *)(v203 + 4);
              if (v206 + v204) {
                BOOL v209 = v206 + v204 >= (unint64_t)(*(void *)(v203 + 16) + 8 * v208);
              }
              else {
                BOOL v209 = 1;
              }
              if (!v209)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v208 = *(int *)(v203 + 4);
              }
              ++v205;
              v204 += 8;
            }
            while (v205 < v208);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v19 + 16));
          appendStringInfoString((uint64_t)&__s1, " TO ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, "FROM ");
          uint64_t v210 = *(void *)(v19 + 32);
          if (v210 && *(int *)(v210 + 4) >= 1)
          {
            uint64_t v211 = 8;
            uint64_t v212 = 0;
            do
            {
              uint64_t v213 = *(void *)(v210 + 16);
              uint64_t v214 = quote_identifier(*(unsigned char **)(*(void *)(v213 + 8 * v212) + 8));
              appendStringInfoString((uint64_t)&__s1, v214);
              uint64_t v215 = *(int *)(v210 + 4);
              if (v213 + v211) {
                BOOL v216 = v213 + v211 >= (unint64_t)(*(void *)(v210 + 16) + 8 * v215);
              }
              else {
                BOOL v216 = 1;
              }
              if (!v216)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v215 = *(int *)(v210 + 4);
              }
              ++v212;
              v211 += 8;
            }
            while (v212 < v215);
          }
          goto LABEL_2105;
        case 0x122:
          appendStringInfoString((uint64_t)&__s1, "CREATE CAST (");
          deparseTypeName(&__s1, *(void *)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, " AS ");
          deparseTypeName(&__s1, *(void *)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, ") ");
          if (*(void *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
            int v274 = *(_DWORD *)(v18 + 32);
            if (v274)
            {
LABEL_421:
              if (v274 != 1) {
                goto LABEL_2105;
              }
              long long v27 = "AS ASSIGNMENT";
              goto LABEL_2104;
            }
          }
          else
          {
            if (*(unsigned char *)(v18 + 36)) {
              v564 = "WITH INOUT ";
            }
            else {
              v564 = "WITHOUT FUNCTION ";
            }
            appendStringInfoString((uint64_t)&__s1, v564);
            int v274 = *(_DWORD *)(v18 + 32);
            if (v274) {
              goto LABEL_421;
            }
          }
          long long v27 = "AS IMPLICIT";
          goto LABEL_2104;
        case 0x123:
          appendStringInfoString((uint64_t)&__s1, "CREATE OPERATOR CLASS ");
          uint64_t v429 = *(void *)(v18 + 8);
          if (v429 && *(int *)(v429 + 4) >= 1)
          {
            uint64_t v430 = 8;
            uint64_t v431 = 0;
            do
            {
              uint64_t v432 = *(void *)(v429 + 16);
              v433 = quote_identifier(*(unsigned char **)(*(void *)(v432 + 8 * v431) + 8));
              appendStringInfoString((uint64_t)&__s1, v433);
              uint64_t v434 = *(int *)(v429 + 4);
              if (v432 + v430) {
                BOOL v435 = v432 + v430 >= (unint64_t)(*(void *)(v429 + 16) + 8 * v434);
              }
              else {
                BOOL v435 = 1;
              }
              if (!v435)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v434 = *(int *)(v429 + 4);
              }
              ++v431;
              v430 += 8;
            }
            while (v431 < v434);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v19 + 48)) {
            appendStringInfoString((uint64_t)&__s1, "DEFAULT ");
          }
          appendStringInfoString((uint64_t)&__s1, "FOR TYPE ");
          deparseTypeName(&__s1, *(void *)(v19 + 32));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "USING ");
          v443 = quote_identifier(*(unsigned char **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, v443);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v19 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "FAMILY ");
            uint64_t v444 = *(void *)(v19 + 16);
            if (v444 && *(int *)(v444 + 4) >= 1)
            {
              uint64_t v445 = 8;
              uint64_t v446 = 0;
              do
              {
                uint64_t v447 = *(void *)(v444 + 16);
                v448 = quote_identifier(*(unsigned char **)(*(void *)(v447 + 8 * v446) + 8));
                appendStringInfoString((uint64_t)&__s1, v448);
                uint64_t v449 = *(int *)(v444 + 4);
                if (v447 + v445) {
                  BOOL v450 = v447 + v445 >= (unint64_t)(*(void *)(v444 + 16) + 8 * v449);
                }
                else {
                  BOOL v450 = 1;
                }
                if (!v450)
                {
                  appendStringInfoChar((uint64_t)&__s1, 46);
                  uint64_t v449 = *(int *)(v444 + 4);
                }
                ++v446;
                v445 += 8;
              }
              while (v446 < v449);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "AS ");
          uint64_t v96 = *(void *)(v19 + 40);
          goto LABEL_778;
        case 0x124:
          appendStringInfoString((uint64_t)&__s1, "CREATE OPERATOR FAMILY ");
          uint64_t v143 = *(void *)(v18 + 8);
          if (v143 && *(int *)(v143 + 4) >= 1)
          {
            uint64_t v144 = 8;
            uint64_t v145 = 0;
            do
            {
              uint64_t v146 = *(void *)(v143 + 16);
              uint64_t v147 = quote_identifier(*(unsigned char **)(*(void *)(v146 + 8 * v145) + 8));
              appendStringInfoString((uint64_t)&__s1, v147);
              uint64_t v148 = *(int *)(v143 + 4);
              if (v146 + v144) {
                BOOL v149 = v146 + v144 >= (unint64_t)(*(void *)(v143 + 16) + 8 * v148);
              }
              else {
                BOOL v149 = 1;
              }
              if (!v149)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v148 = *(int *)(v143 + 4);
              }
              ++v145;
              v144 += 8;
            }
            while (v145 < v148);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          unint64_t v158 = "USING ";
          goto LABEL_1018;
        case 0x125:
          appendStringInfoString((uint64_t)&__s1, "ALTER OPERATOR FAMILY ");
          uint64_t v87 = *(void *)(v18 + 8);
          if (v87 && *(int *)(v87 + 4) >= 1)
          {
            uint64_t v88 = 8;
            uint64_t v89 = 0;
            do
            {
              uint64_t v90 = *(void *)(v87 + 16);
              uint64_t v91 = quote_identifier(*(unsigned char **)(*(void *)(v90 + 8 * v89) + 8));
              appendStringInfoString((uint64_t)&__s1, v91);
              uint64_t v92 = *(int *)(v87 + 4);
              if (v90 + v88) {
                BOOL v93 = v90 + v88 >= (unint64_t)(*(void *)(v87 + 16) + 8 * v92);
              }
              else {
                BOOL v93 = 1;
              }
              if (!v93)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v92 = *(int *)(v87 + 4);
              }
              ++v89;
              v88 += 8;
            }
            while (v89 < v92);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "USING ");
          unint64_t v94 = quote_identifier(*(unsigned char **)(v19 + 16));
          appendStringInfoString((uint64_t)&__s1, v94);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v19 + 24)) {
            uint64_t v95 = "DROP ";
          }
          else {
            uint64_t v95 = "ADD ";
          }
          appendStringInfoString((uint64_t)&__s1, v95);
          uint64_t v96 = *(void *)(v19 + 32);
LABEL_778:
          deparseOpclassItemList((unint64_t)&__s1, v96);
          goto LABEL_2105;
        case 0x126:
          appendStringInfoString((uint64_t)&__s1, "PREPARE ");
          unint64_t v150 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v150);
          uint64_t v151 = *(void *)(v18 + 16);
          if (v151 && *(int *)(v151 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            uint64_t v152 = *(void *)(v18 + 16);
            if (v152 && *(int *)(v152 + 4) >= 1)
            {
              uint64_t v153 = 8;
              uint64_t v154 = 0;
              do
              {
                uint64_t v155 = *(void *)(v152 + 16);
                deparseTypeName(&__s1, *(void *)(v155 + 8 * v154));
                uint64_t v156 = *(int *)(v152 + 4);
                if (v155 + v153) {
                  BOOL v157 = v155 + v153 >= (unint64_t)(*(void *)(v152 + 16) + 8 * v156);
                }
                else {
                  BOOL v157 = 1;
                }
                if (!v157)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  uint64_t v156 = *(int *)(v152 + 4);
                }
                ++v154;
                v153 += 8;
              }
              while (v154 < v156);
            }
            appendStringInfoChar((uint64_t)&__s1, 41);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ");
          v532 = *(uint64_t **)(v19 + 24);
          switch(*(_DWORD *)v532)
          {
            case 0xE9:
LABEL_814:
              deparseInsertStmt(&__s1, (uint64_t)v532);
              break;
            case 0xEA:
LABEL_958:
              deparseDeleteStmt(&__s1, v532);
              break;
            case 0xEB:
LABEL_959:
              deparseUpdateStmt(&__s1, v532);
              break;
            case 0xEC:
LABEL_960:
              deparseSelectStmt(&__s1, (uint64_t)v532);
              break;
            default:
              goto LABEL_2105;
          }
          goto LABEL_2105;
        case 0x127:
          deparseExecuteStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x128:
          appendStringInfoString((uint64_t)&__s1, "DEALLOCATE ");
          uint64_t v108 = *(unsigned char **)(v18 + 8);
          if (v108) {
            goto LABEL_1818;
          }
LABEL_341:
          long long v27 = "ALL";
          goto LABEL_2104;
        case 0x129:
          deparseDeclareCursorStmt(&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x12A:
          appendStringInfoString((uint64_t)&__s1, "CREATE TABLESPACE ");
          uint64_t v101 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v101);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "OWNER ");
            uint64_t v102 = *(void *)(v18 + 16);
            switch(*(_DWORD *)(v102 + 4))
            {
              case 0:
                unint64_t v103 = quote_identifier(*(unsigned char **)(v102 + 8));
                goto LABEL_1200;
              case 1:
                unint64_t v103 = "CURRENT_USER";
                goto LABEL_1200;
              case 2:
                unint64_t v103 = "SESSION_USER";
                goto LABEL_1200;
              case 3:
                unint64_t v103 = "public";
LABEL_1200:
                appendStringInfoString((uint64_t)&__s1, v103);
                break;
              default:
                break;
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "LOCATION ");
          deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v729 = *(void *)(v18 + 32);
          if (!v729 || *(int *)(v729 + 4) < 1) {
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          deparseRelOptions(&__s1, v729);
          goto LABEL_1308;
        case 0x12B:
          uint64_t v97 = "DROP TABLESPACE ";
          goto LABEL_628;
        case 0x12C:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0x13:
              uint64_t v109 = "FUNCTION ";
              goto LABEL_1181;
            case 0x14:
              v720 = "INDEX ";
              goto LABEL_1179;
            case 0x17:
              v720 = "MATERIALIZED VIEW ";
              goto LABEL_1179;
            case 0x1C:
              uint64_t v109 = "PROCEDURE ";
              goto LABEL_1181;
            case 0x20:
              uint64_t v109 = "ROUTINE ";
LABEL_1181:
              appendStringInfoString((uint64_t)&__s1, v109);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 16));
              break;
            case 0x2A:
              appendStringInfoString((uint64_t)&__s1, "TRIGGER ");
              v721 = quote_identifier(*(unsigned char **)(**(void **)(*(void *)(v18 + 16) + 16) + 8));
              appendStringInfoString((uint64_t)&__s1, v721);
              v720 = " ON ";
LABEL_1179:
              appendStringInfoString((uint64_t)&__s1, v720);
              deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 8), 0);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v18 + 32)) {
            appendStringInfoString((uint64_t)&__s1, "NO ");
          }
          appendStringInfoString((uint64_t)&__s1, "DEPENDS ON EXTENSION ");
          uint64_t v108 = *(unsigned char **)(*(void *)(v18 + 24) + 8);
          goto LABEL_1818;
        case 0x12D:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 16));
              break;
            case 7:
              appendStringInfoString((uint64_t)&__s1, "COLLATION ");
              uint64_t v991 = *(void *)(v18 + 16);
              if (v991 && *(int *)(v991 + 4) >= 1)
              {
                uint64_t v992 = 8;
                uint64_t v993 = 0;
                do
                {
                  uint64_t v994 = *(void *)(v991 + 16);
                  v995 = quote_identifier(*(unsigned char **)(*(void *)(v994 + 8 * v993) + 8));
                  appendStringInfoString((uint64_t)&__s1, v995);
                  uint64_t v996 = *(int *)(v991 + 4);
                  if (v994 + v992) {
                    BOOL v997 = v994 + v992 >= (unint64_t)(*(void *)(v991 + 16) + 8 * v996);
                  }
                  else {
                    BOOL v997 = 1;
                  }
                  if (!v997)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v996 = *(int *)(v991 + 4);
                  }
                  ++v993;
                  v992 += 8;
                }
                while (v993 < v996);
              }
              break;
            case 8:
              appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
              uint64_t v998 = *(void *)(v18 + 16);
              if (v998 && *(int *)(v998 + 4) >= 1)
              {
                uint64_t v999 = 8;
                uint64_t v1000 = 0;
                do
                {
                  uint64_t v1001 = *(void *)(v998 + 16);
                  v1002 = quote_identifier(*(unsigned char **)(*(void *)(v1001 + 8 * v1000) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1002);
                  uint64_t v1003 = *(int *)(v998 + 4);
                  if (v1001 + v999) {
                    BOOL v1004 = v1001 + v999 >= (unint64_t)(*(void *)(v998 + 16) + 8 * v1003);
                  }
                  else {
                    BOOL v1004 = 1;
                  }
                  if (!v1004)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1003 = *(int *)(v998 + 4);
                  }
                  ++v1000;
                  v999 += 8;
                }
                while (v1000 < v1003);
              }
              break;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "DOMAIN ");
              uint64_t v1005 = *(void *)(v18 + 16);
              if (v1005 && *(int *)(v1005 + 4) >= 1)
              {
                uint64_t v1006 = 8;
                uint64_t v1007 = 0;
                do
                {
                  uint64_t v1008 = *(void *)(v1005 + 16);
                  v1009 = quote_identifier(*(unsigned char **)(*(void *)(v1008 + 8 * v1007) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1009);
                  uint64_t v1010 = *(int *)(v1005 + 4);
                  if (v1008 + v1006) {
                    BOOL v1011 = v1008 + v1006 >= (unint64_t)(*(void *)(v1005 + 16) + 8 * v1010);
                  }
                  else {
                    BOOL v1011 = 1;
                  }
                  if (!v1011)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1010 = *(int *)(v1005 + 4);
                  }
                  ++v1007;
                  v1006 += 8;
                }
                while (v1007 < v1010);
              }
              break;
            case 0xF:
              appendStringInfoString((uint64_t)&__s1, "EXTENSION ");
              uint64_t v1012 = *(void *)(v18 + 16);
              goto LABEL_1762;
            case 0x12:
              v1013 = "FOREIGN TABLE ";
              goto LABEL_1814;
            case 0x13:
              v1014 = "FUNCTION ";
              goto LABEL_1765;
            case 0x17:
              v1013 = "MATERIALIZED VIEW ";
              goto LABEL_1814;
            case 0x18:
              uint64_t v1015 = *(void *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR CLASS ");
              if (!v1015) {
                goto LABEL_2115;
              }
              if (*(int *)(v1015 + 4) >= 2)
              {
                int v1016 = 1;
                do
                {
                  v1017 = (uint64_t *)(*(void *)(v1015 + 16) + 8 * v1016);
                  uint64_t v1019 = *v1017;
                  unint64_t v1018 = (unint64_t)(v1017 + 1);
                  v1020 = quote_identifier(*(unsigned char **)(v1019 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1020);
                  uint64_t v1021 = *(int *)(v1015 + 4);
                  if (v1018) {
                    BOOL v1022 = v1018 >= *(void *)(v1015 + 16) + 8 * v1021;
                  }
                  else {
                    BOOL v1022 = 1;
                  }
                  if (!v1022)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1021) = *(_DWORD *)(v1015 + 4);
                  }
                  ++v1016;
                }
                while ((int)v1021 > v1016);
              }
              goto LABEL_1761;
            case 0x19:
              appendStringInfoString((uint64_t)&__s1, "OPERATOR ");
              deparseOperatorWithArgtypes(&__s1, *(void *)(v18 + 16));
              break;
            case 0x1A:
              uint64_t v1015 = *(void *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR FAMILY ");
              if (!v1015) {
                goto LABEL_2115;
              }
              if (*(int *)(v1015 + 4) >= 2)
              {
                int v1023 = 1;
                do
                {
                  v1024 = (uint64_t *)(*(void *)(v1015 + 16) + 8 * v1023);
                  uint64_t v1026 = *v1024;
                  unint64_t v1025 = (unint64_t)(v1024 + 1);
                  v1027 = quote_identifier(*(unsigned char **)(v1026 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1027);
                  uint64_t v1028 = *(int *)(v1015 + 4);
                  if (v1025) {
                    BOOL v1029 = v1025 >= *(void *)(v1015 + 16) + 8 * v1028;
                  }
                  else {
                    BOOL v1029 = 1;
                  }
                  if (!v1029)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1028) = *(_DWORD *)(v1015 + 4);
                  }
                  ++v1023;
                }
                while ((int)v1028 > v1023);
              }
LABEL_1761:
              appendStringInfoString((uint64_t)&__s1, " USING ");
              uint64_t v1012 = **(void **)(v1015 + 16);
LABEL_1762:
              v1030 = quote_identifier(*(unsigned char **)(v1012 + 8));
              appendStringInfoString((uint64_t)&__s1, v1030);
              break;
            case 0x1C:
              v1014 = "PROCEDURE ";
              goto LABEL_1765;
            case 0x20:
              v1014 = "ROUTINE ";
LABEL_1765:
              appendStringInfoString((uint64_t)&__s1, v1014);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 16));
              break;
            case 0x23:
              v1013 = "SEQUENCE ";
              goto LABEL_1814;
            case 0x25:
              appendStringInfoString((uint64_t)&__s1, "STATISTICS ");
              uint64_t v1031 = *(void *)(v18 + 16);
              if (v1031 && *(int *)(v1031 + 4) >= 1)
              {
                uint64_t v1032 = 8;
                uint64_t v1033 = 0;
                do
                {
                  uint64_t v1034 = *(void *)(v1031 + 16);
                  v1035 = quote_identifier(*(unsigned char **)(*(void *)(v1034 + 8 * v1033) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1035);
                  uint64_t v1036 = *(int *)(v1031 + 4);
                  if (v1034 + v1032) {
                    BOOL v1037 = v1034 + v1032 >= (unint64_t)(*(void *)(v1031 + 16) + 8 * v1036);
                  }
                  else {
                    BOOL v1037 = 1;
                  }
                  if (!v1037)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1036 = *(int *)(v1031 + 4);
                  }
                  ++v1033;
                  v1032 += 8;
                }
                while (v1033 < v1036);
              }
              break;
            case 0x27:
              v1013 = "TABLE ";
              goto LABEL_1814;
            case 0x2B:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH CONFIGURATION ");
              uint64_t v1038 = *(void *)(v18 + 16);
              if (v1038 && *(int *)(v1038 + 4) >= 1)
              {
                uint64_t v1039 = 8;
                uint64_t v1040 = 0;
                do
                {
                  uint64_t v1041 = *(void *)(v1038 + 16);
                  v1042 = quote_identifier(*(unsigned char **)(*(void *)(v1041 + 8 * v1040) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1042);
                  uint64_t v1043 = *(int *)(v1038 + 4);
                  if (v1041 + v1039) {
                    BOOL v1044 = v1041 + v1039 >= (unint64_t)(*(void *)(v1038 + 16) + 8 * v1043);
                  }
                  else {
                    BOOL v1044 = 1;
                  }
                  if (!v1044)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1043 = *(int *)(v1038 + 4);
                  }
                  ++v1040;
                  v1039 += 8;
                }
                while (v1040 < v1043);
              }
              break;
            case 0x2C:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH DICTIONARY ");
              uint64_t v1045 = *(void *)(v18 + 16);
              if (v1045 && *(int *)(v1045 + 4) >= 1)
              {
                uint64_t v1046 = 8;
                uint64_t v1047 = 0;
                do
                {
                  uint64_t v1048 = *(void *)(v1045 + 16);
                  v1049 = quote_identifier(*(unsigned char **)(*(void *)(v1048 + 8 * v1047) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1049);
                  uint64_t v1050 = *(int *)(v1045 + 4);
                  if (v1048 + v1046) {
                    BOOL v1051 = v1048 + v1046 >= (unint64_t)(*(void *)(v1045 + 16) + 8 * v1050);
                  }
                  else {
                    BOOL v1051 = 1;
                  }
                  if (!v1051)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1050 = *(int *)(v1045 + 4);
                  }
                  ++v1047;
                  v1046 += 8;
                }
                while (v1047 < v1050);
              }
              break;
            case 0x2D:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH PARSER ");
              uint64_t v1052 = *(void *)(v18 + 16);
              if (v1052 && *(int *)(v1052 + 4) >= 1)
              {
                uint64_t v1053 = 8;
                uint64_t v1054 = 0;
                do
                {
                  uint64_t v1055 = *(void *)(v1052 + 16);
                  v1056 = quote_identifier(*(unsigned char **)(*(void *)(v1055 + 8 * v1054) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1056);
                  uint64_t v1057 = *(int *)(v1052 + 4);
                  if (v1055 + v1053) {
                    BOOL v1058 = v1055 + v1053 >= (unint64_t)(*(void *)(v1052 + 16) + 8 * v1057);
                  }
                  else {
                    BOOL v1058 = 1;
                  }
                  if (!v1058)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1057 = *(int *)(v1052 + 4);
                  }
                  ++v1054;
                  v1053 += 8;
                }
                while (v1054 < v1057);
              }
              break;
            case 0x2E:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH TEMPLATE ");
              uint64_t v1059 = *(void *)(v18 + 16);
              if (v1059 && *(int *)(v1059 + 4) >= 1)
              {
                uint64_t v1060 = 8;
                uint64_t v1061 = 0;
                do
                {
                  uint64_t v1062 = *(void *)(v1059 + 16);
                  v1063 = quote_identifier(*(unsigned char **)(*(void *)(v1062 + 8 * v1061) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1063);
                  uint64_t v1064 = *(int *)(v1059 + 4);
                  if (v1062 + v1060) {
                    BOOL v1065 = v1062 + v1060 >= (unint64_t)(*(void *)(v1059 + 16) + 8 * v1064);
                  }
                  else {
                    BOOL v1065 = 1;
                  }
                  if (!v1065)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1064 = *(int *)(v1059 + 4);
                  }
                  ++v1061;
                  v1060 += 8;
                }
                while (v1061 < v1064);
              }
              break;
            case 0x2F:
              appendStringInfoString((uint64_t)&__s1, "TYPE ");
              uint64_t v1066 = *(void *)(v18 + 16);
              if (v1066 && *(int *)(v1066 + 4) >= 1)
              {
                uint64_t v1067 = 8;
                uint64_t v1068 = 0;
                do
                {
                  uint64_t v1069 = *(void *)(v1066 + 16);
                  v1070 = quote_identifier(*(unsigned char **)(*(void *)(v1069 + 8 * v1068) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1070);
                  uint64_t v1071 = *(int *)(v1066 + 4);
                  if (v1069 + v1067) {
                    BOOL v1072 = v1069 + v1067 >= (unint64_t)(*(void *)(v1066 + 16) + 8 * v1071);
                  }
                  else {
                    BOOL v1072 = 1;
                  }
                  if (!v1072)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1071 = *(int *)(v1066 + 4);
                  }
                  ++v1068;
                  v1067 += 8;
                }
                while (v1068 < v1071);
              }
              break;
            case 0x31:
              v1013 = "VIEW ";
LABEL_1814:
              appendStringInfoString((uint64_t)&__s1, v1013);
              if (*(unsigned char *)(v18 + 32)) {
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              }
              deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 8), 0);
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, " SET SCHEMA ");
          uint64_t v108 = *(unsigned char **)(v19 + 24);
          goto LABEL_1818;
        case 0x12E:
          appendStringInfoString((uint64_t)&__s1, "ALTER ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 16));
              goto LABEL_1930;
            case 7:
              appendStringInfoString((uint64_t)&__s1, "COLLATION ");
              uint64_t v1073 = *(void *)(v18 + 16);
              if (v1073 && *(int *)(v1073 + 4) >= 1)
              {
                uint64_t v1074 = 8;
                uint64_t v1075 = 0;
                do
                {
                  uint64_t v1076 = *(void *)(v1073 + 16);
                  v1077 = quote_identifier(*(unsigned char **)(*(void *)(v1076 + 8 * v1075) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1077);
                  uint64_t v1078 = *(int *)(v1073 + 4);
                  if (v1076 + v1074) {
                    BOOL v1079 = v1076 + v1074 >= (unint64_t)(*(void *)(v1073 + 16) + 8 * v1078);
                  }
                  else {
                    BOOL v1079 = 1;
                  }
                  if (!v1079)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1078 = *(int *)(v1073 + 4);
                  }
                  ++v1075;
                  v1074 += 8;
                }
                while (v1075 < v1078);
              }
              goto LABEL_1930;
            case 8:
              appendStringInfoString((uint64_t)&__s1, "CONVERSION ");
              uint64_t v1080 = *(void *)(v18 + 16);
              if (v1080 && *(int *)(v1080 + 4) >= 1)
              {
                uint64_t v1081 = 8;
                uint64_t v1082 = 0;
                do
                {
                  uint64_t v1083 = *(void *)(v1080 + 16);
                  v1084 = quote_identifier(*(unsigned char **)(*(void *)(v1083 + 8 * v1082) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1084);
                  uint64_t v1085 = *(int *)(v1080 + 4);
                  if (v1083 + v1081) {
                    BOOL v1086 = v1083 + v1081 >= (unint64_t)(*(void *)(v1080 + 16) + 8 * v1085);
                  }
                  else {
                    BOOL v1086 = 1;
                  }
                  if (!v1086)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1085 = *(int *)(v1080 + 4);
                  }
                  ++v1082;
                  v1081 += 8;
                }
                while (v1082 < v1085);
              }
              goto LABEL_1930;
            case 9:
              v1087 = "DATABASE ";
              goto LABEL_1927;
            case 0xC:
              appendStringInfoString((uint64_t)&__s1, "DOMAIN ");
              uint64_t v1088 = *(void *)(v18 + 16);
              if (v1088 && *(int *)(v1088 + 4) >= 1)
              {
                uint64_t v1089 = 8;
                uint64_t v1090 = 0;
                do
                {
                  uint64_t v1091 = *(void *)(v1088 + 16);
                  v1092 = quote_identifier(*(unsigned char **)(*(void *)(v1091 + 8 * v1090) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1092);
                  uint64_t v1093 = *(int *)(v1088 + 4);
                  if (v1091 + v1089) {
                    BOOL v1094 = v1091 + v1089 >= (unint64_t)(*(void *)(v1088 + 16) + 8 * v1093);
                  }
                  else {
                    BOOL v1094 = 1;
                  }
                  if (!v1094)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1093 = *(int *)(v1088 + 4);
                  }
                  ++v1090;
                  v1089 += 8;
                }
                while (v1090 < v1093);
              }
              goto LABEL_1930;
            case 0xE:
              v1087 = "EVENT TRIGGER ";
              goto LABEL_1927;
            case 0x10:
              v1087 = "FOREIGN DATA WRAPPER ";
              goto LABEL_1927;
            case 0x11:
              v1087 = "SERVER ";
              goto LABEL_1927;
            case 0x13:
              v1118 = "FUNCTION ";
              goto LABEL_1924;
            case 0x15:
              v1087 = "LANGUAGE ";
              goto LABEL_1927;
            case 0x16:
              appendStringInfoString((uint64_t)&__s1, "LARGE OBJECT ");
              uint64_t v1101 = *(void *)(v18 + 16);
              if (*(_DWORD *)v1101 == 222)
              {
                v1147 = *(char **)(v1101 + 8);
LABEL_1929:
                appendStringInfoString((uint64_t)&__s1, v1147);
              }
              else if (*(_DWORD *)v1101 == 221)
              {
                appendStringInfo((uint64_t)&__s1, "%d", v1095, v1096, v1097, v1098, v1099, v1100, *(unsigned int *)(v1101 + 8));
              }
LABEL_1930:
              appendStringInfoString((uint64_t)&__s1, " OWNER TO ");
              uint64_t v54 = *(void *)(v19 + 24);
              switch(*(_DWORD *)(v54 + 4))
              {
                case 0:
                  goto LABEL_1931;
                case 1:
                  goto LABEL_1934;
                case 2:
                  goto LABEL_1933;
                case 3:
                  goto LABEL_1935;
                default:
                  goto LABEL_2105;
              }
            case 0x18:
              uint64_t v1102 = *(void *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR CLASS ");
              if (!v1102) {
                goto LABEL_2115;
              }
              if (*(int *)(v1102 + 4) >= 2)
              {
                int v1103 = 1;
                do
                {
                  v1104 = (uint64_t *)(*(void *)(v1102 + 16) + 8 * v1103);
                  uint64_t v1106 = *v1104;
                  unint64_t v1105 = (unint64_t)(v1104 + 1);
                  v1107 = quote_identifier(*(unsigned char **)(v1106 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1107);
                  uint64_t v1108 = *(int *)(v1102 + 4);
                  if (v1105) {
                    BOOL v1109 = v1105 >= *(void *)(v1102 + 16) + 8 * v1108;
                  }
                  else {
                    BOOL v1109 = 1;
                  }
                  if (!v1109)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1108) = *(_DWORD *)(v1102 + 4);
                  }
                  ++v1103;
                }
                while ((int)v1108 > v1103);
              }
              goto LABEL_1882;
            case 0x19:
              appendStringInfoString((uint64_t)&__s1, "OPERATOR ");
              deparseOperatorWithArgtypes(&__s1, *(void *)(v18 + 16));
              goto LABEL_1930;
            case 0x1A:
              uint64_t v1102 = *(void *)(v18 + 16);
              appendStringInfoString((uint64_t)&__s1, "OPERATOR FAMILY ");
              if (!v1102) {
                goto LABEL_2115;
              }
              if (*(int *)(v1102 + 4) >= 2)
              {
                int v1110 = 1;
                do
                {
                  v1111 = (uint64_t *)(*(void *)(v1102 + 16) + 8 * v1110);
                  uint64_t v1113 = *v1111;
                  unint64_t v1112 = (unint64_t)(v1111 + 1);
                  v1114 = quote_identifier(*(unsigned char **)(v1113 + 8));
                  appendStringInfoString((uint64_t)&__s1, v1114);
                  uint64_t v1115 = *(int *)(v1102 + 4);
                  if (v1112) {
                    BOOL v1116 = v1112 >= *(void *)(v1102 + 16) + 8 * v1115;
                  }
                  else {
                    BOOL v1116 = 1;
                  }
                  if (!v1116)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    LODWORD(v1115) = *(_DWORD *)(v1102 + 4);
                  }
                  ++v1110;
                }
                while ((int)v1115 > v1110);
              }
LABEL_1882:
              appendStringInfoString((uint64_t)&__s1, " USING ");
              uint64_t v1117 = **(void **)(v1102 + 16);
              goto LABEL_1928;
            case 0x1C:
              v1118 = "PROCEDURE ";
              goto LABEL_1924;
            case 0x1D:
              v1087 = "PUBLICATION ";
              goto LABEL_1927;
            case 0x20:
              v1118 = "ROUTINE ";
LABEL_1924:
              appendStringInfoString((uint64_t)&__s1, v1118);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 16));
              goto LABEL_1930;
            case 0x22:
              v1087 = "SCHEMA ";
              goto LABEL_1927;
            case 0x24:
              v1087 = "SUBSCRIPTION ";
              goto LABEL_1927;
            case 0x25:
              appendStringInfoString((uint64_t)&__s1, "STATISTICS ");
              uint64_t v1119 = *(void *)(v18 + 16);
              if (v1119 && *(int *)(v1119 + 4) >= 1)
              {
                uint64_t v1120 = 8;
                uint64_t v1121 = 0;
                do
                {
                  uint64_t v1122 = *(void *)(v1119 + 16);
                  v1123 = quote_identifier(*(unsigned char **)(*(void *)(v1122 + 8 * v1121) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1123);
                  uint64_t v1124 = *(int *)(v1119 + 4);
                  if (v1122 + v1120) {
                    BOOL v1125 = v1122 + v1120 >= (unint64_t)(*(void *)(v1119 + 16) + 8 * v1124);
                  }
                  else {
                    BOOL v1125 = 1;
                  }
                  if (!v1125)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1124 = *(int *)(v1119 + 4);
                  }
                  ++v1121;
                  v1120 += 8;
                }
                while (v1121 < v1124);
              }
              goto LABEL_1930;
            case 0x28:
              v1087 = "TABLESPACE ";
LABEL_1927:
              appendStringInfoString((uint64_t)&__s1, v1087);
              uint64_t v1117 = *(void *)(v18 + 16);
LABEL_1928:
              v1147 = quote_identifier(*(unsigned char **)(v1117 + 8));
              goto LABEL_1929;
            case 0x2B:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH CONFIGURATION ");
              uint64_t v1126 = *(void *)(v18 + 16);
              if (v1126 && *(int *)(v1126 + 4) >= 1)
              {
                uint64_t v1127 = 8;
                uint64_t v1128 = 0;
                do
                {
                  uint64_t v1129 = *(void *)(v1126 + 16);
                  v1130 = quote_identifier(*(unsigned char **)(*(void *)(v1129 + 8 * v1128) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1130);
                  uint64_t v1131 = *(int *)(v1126 + 4);
                  if (v1129 + v1127) {
                    BOOL v1132 = v1129 + v1127 >= (unint64_t)(*(void *)(v1126 + 16) + 8 * v1131);
                  }
                  else {
                    BOOL v1132 = 1;
                  }
                  if (!v1132)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1131 = *(int *)(v1126 + 4);
                  }
                  ++v1128;
                  v1127 += 8;
                }
                while (v1128 < v1131);
              }
              goto LABEL_1930;
            case 0x2C:
              appendStringInfoString((uint64_t)&__s1, "TEXT SEARCH DICTIONARY ");
              uint64_t v1133 = *(void *)(v18 + 16);
              if (v1133 && *(int *)(v1133 + 4) >= 1)
              {
                uint64_t v1134 = 8;
                uint64_t v1135 = 0;
                do
                {
                  uint64_t v1136 = *(void *)(v1133 + 16);
                  v1137 = quote_identifier(*(unsigned char **)(*(void *)(v1136 + 8 * v1135) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1137);
                  uint64_t v1138 = *(int *)(v1133 + 4);
                  if (v1136 + v1134) {
                    BOOL v1139 = v1136 + v1134 >= (unint64_t)(*(void *)(v1133 + 16) + 8 * v1138);
                  }
                  else {
                    BOOL v1139 = 1;
                  }
                  if (!v1139)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1138 = *(int *)(v1133 + 4);
                  }
                  ++v1135;
                  v1134 += 8;
                }
                while (v1135 < v1138);
              }
              goto LABEL_1930;
            case 0x2F:
              appendStringInfoString((uint64_t)&__s1, "TYPE ");
              uint64_t v1140 = *(void *)(v18 + 16);
              if (v1140 && *(int *)(v1140 + 4) >= 1)
              {
                uint64_t v1141 = 8;
                uint64_t v1142 = 0;
                do
                {
                  uint64_t v1143 = *(void *)(v1140 + 16);
                  v1144 = quote_identifier(*(unsigned char **)(*(void *)(v1143 + 8 * v1142) + 8));
                  appendStringInfoString((uint64_t)&__s1, v1144);
                  uint64_t v1145 = *(int *)(v1140 + 4);
                  if (v1143 + v1141) {
                    BOOL v1146 = v1143 + v1141 >= (unint64_t)(*(void *)(v1140 + 16) + 8 * v1145);
                  }
                  else {
                    BOOL v1146 = 1;
                  }
                  if (!v1146)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v1145 = *(int *)(v1140 + 4);
                  }
                  ++v1142;
                  v1141 += 8;
                }
                while (v1142 < v1145);
              }
              goto LABEL_1930;
            default:
              goto LABEL_1930;
          }
          goto LABEL_2105;
        case 0x12F:
          appendStringInfoString((uint64_t)&__s1, "ALTER OPERATOR ");
          deparseOperatorWithArgtypes(&__s1, *(void *)(v18 + 8));
          goto LABEL_626;
        case 0x130:
          appendStringInfoString((uint64_t)&__s1, "ALTER TYPE ");
          uint64_t v67 = *(void *)(v18 + 8);
          if (v67 && *(int *)(v67 + 4) >= 1)
          {
            uint64_t v68 = 8;
            uint64_t v69 = 0;
            do
            {
              uint64_t v70 = *(void *)(v67 + 16);
              uint64_t v71 = quote_identifier(*(unsigned char **)(*(void *)(v70 + 8 * v69) + 8));
              appendStringInfoString((uint64_t)&__s1, v71);
              uint64_t v72 = *(int *)(v67 + 4);
              if (v70 + v68) {
                BOOL v73 = v70 + v68 >= (unint64_t)(*(void *)(v67 + 16) + 8 * v72);
              }
              else {
                BOOL v73 = 1;
              }
              if (!v73)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v72 = *(int *)(v67 + 4);
              }
              ++v69;
              v68 += 8;
            }
            while (v69 < v72);
          }
LABEL_626:
          appendStringInfoString((uint64_t)&__s1, " SET (");
          deparseOperatorDefList(&__s1, *(void *)(v19 + 16));
          appendStringInfoChar((uint64_t)&__s1, 41);
          goto LABEL_2105;
        case 0x131:
          appendStringInfoString((uint64_t)&__s1, "DROP OWNED BY ");
          deparseRoleList(&__s1, *(void *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(_DWORD *)(v18 + 16) == 1) {
LABEL_2029:
          }
            appendStringInfoString((uint64_t)&__s1, "CASCADE ");
          goto LABEL_2092;
        case 0x132:
          appendStringInfoString((uint64_t)&__s1, "REASSIGN OWNED BY ");
          deparseRoleList(&__s1, *(void *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "TO ");
          uint64_t v54 = *(void *)(v18 + 16);
          switch(*(_DWORD *)(v54 + 4))
          {
            case 0:
              goto LABEL_1931;
            case 1:
LABEL_1934:
              long long v27 = "CURRENT_USER";
              goto LABEL_2104;
            case 2:
LABEL_1933:
              long long v27 = "SESSION_USER";
              goto LABEL_2104;
            case 3:
LABEL_1935:
              long long v27 = "public";
              goto LABEL_2104;
            default:
              goto LABEL_2105;
          }
          goto LABEL_2105;
        case 0x133:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 8), 8);
          appendStringInfoString((uint64_t)&__s1, " AS (");
          uint64_t v320 = *(void *)(v18 + 16);
          if (v320 && *(int *)(v320 + 4) >= 1)
          {
            uint64_t v321 = 8;
            uint64_t v322 = 0;
            do
            {
              uint64_t v323 = *(void *)(v320 + 16);
              deparseColumnDef((uint64_t)&__s1, *(void **)(v323 + 8 * v322));
              if (v323 + v321) {
                BOOL v324 = v323 + v321 >= (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 16) + 4));
              else {
                BOOL v324 = 1;
              }
              if (!v324) {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v322;
              v321 += 8;
            }
            while (v322 < *(int *)(v320 + 4));
          }
          goto LABEL_996;
        case 0x134:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          uint64_t v368 = *(void *)(v18 + 8);
          if (v368 && *(int *)(v368 + 4) >= 1)
          {
            uint64_t v369 = 8;
            uint64_t v370 = 0;
            do
            {
              uint64_t v371 = *(void *)(v368 + 16);
              v372 = quote_identifier(*(unsigned char **)(*(void *)(v371 + 8 * v370) + 8));
              appendStringInfoString((uint64_t)&__s1, v372);
              uint64_t v373 = *(int *)(v368 + 4);
              if (v371 + v369) {
                BOOL v374 = v371 + v369 >= (unint64_t)(*(void *)(v368 + 16) + 8 * v373);
              }
              else {
                BOOL v374 = 1;
              }
              if (!v374)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v373 = *(int *)(v368 + 4);
              }
              ++v370;
              v369 += 8;
            }
            while (v370 < v373);
          }
          appendStringInfoString((uint64_t)&__s1, " AS ENUM (");
          uint64_t v375 = *(void *)(v19 + 16);
          if (v375 && *(int *)(v375 + 4) >= 1)
          {
            uint64_t v376 = 8;
            uint64_t v377 = 0;
            do
            {
              uint64_t v378 = *(void *)(v375 + 16);
              deparseStringLiteral((uint64_t)&__s1, *(char **)(*(void *)(v378 + 8 * v377) + 8));
              if (v378 + v376) {
                BOOL v379 = v378 + v376 >= (unint64_t)(*(void *)(*(void *)(v19 + 16) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 16) + 4));
              else {
                BOOL v379 = 1;
              }
              if (!v379) {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v377;
              v376 += 8;
            }
            while (v377 < *(int *)(v375 + 4));
          }
          goto LABEL_996;
        case 0x135:
          appendStringInfoString((uint64_t)&__s1, "CREATE TYPE ");
          uint64_t v385 = *(void *)(v18 + 8);
          if (v385 && *(int *)(v385 + 4) >= 1)
          {
            uint64_t v386 = 8;
            uint64_t v387 = 0;
            do
            {
              uint64_t v388 = *(void *)(v385 + 16);
              v389 = quote_identifier(*(unsigned char **)(*(void *)(v388 + 8 * v387) + 8));
              appendStringInfoString((uint64_t)&__s1, v389);
              uint64_t v390 = *(int *)(v385 + 4);
              if (v388 + v386) {
                BOOL v391 = v388 + v386 >= (unint64_t)(*(void *)(v385 + 16) + 8 * v390);
              }
              else {
                BOOL v391 = 1;
              }
              if (!v391)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v390 = *(int *)(v385 + 4);
              }
              ++v387;
              v386 += 8;
            }
            while (v387 < v390);
          }
          appendStringInfoString((uint64_t)&__s1, " AS RANGE ");
          deparseDefinition(&__s1, *(void *)(v19 + 16));
          goto LABEL_2105;
        case 0x136:
          appendStringInfoString((uint64_t)&__s1, "ALTER TYPE ");
          uint64_t v55 = *(void *)(v18 + 8);
          if (v55 && *(int *)(v55 + 4) >= 1)
          {
            uint64_t v56 = 8;
            uint64_t v57 = 0;
            do
            {
              uint64_t v58 = *(void *)(v55 + 16);
              long long v59 = quote_identifier(*(unsigned char **)(*(void *)(v58 + 8 * v57) + 8));
              appendStringInfoString((uint64_t)&__s1, v59);
              uint64_t v60 = *(int *)(v55 + 4);
              if (v58 + v56) {
                BOOL v61 = v58 + v56 >= (unint64_t)(*(void *)(v55 + 16) + 8 * v60);
              }
              else {
                BOOL v61 = 1;
              }
              if (!v61)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v60 = *(int *)(v55 + 4);
              }
              ++v57;
              v56 += 8;
            }
            while (v57 < v60);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "RENAME VALUE ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, " TO ");
            uint64_t v62 = (char **)(v18 + 24);
            uint64_t v15 = v1227;
          }
          else
          {
            appendStringInfoString((uint64_t)&__s1, "ADD VALUE ");
            uint64_t v15 = v1227;
            if (*(unsigned char *)(v18 + 41)) {
              appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
            }
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (!*(void *)(v18 + 32)) {
              goto LABEL_2092;
            }
            if (*(unsigned char *)(v18 + 40)) {
              v555 = "AFTER ";
            }
            else {
              v555 = "BEFORE ";
            }
            appendStringInfoString((uint64_t)&__s1, v555);
            uint64_t v62 = (char **)(v18 + 32);
          }
          deparseStringLiteral((uint64_t)&__s1, *v62);
          goto LABEL_2092;
        case 0x137:
          appendStringInfoString((uint64_t)&__s1, "ALTER TEXT SEARCH DICTIONARY ");
          uint64_t v110 = *(void *)(v18 + 8);
          if (v110 && *(int *)(v110 + 4) >= 1)
          {
            uint64_t v111 = 8;
            uint64_t v112 = 0;
            do
            {
              uint64_t v113 = *(void *)(v110 + 16);
              unint64_t v114 = quote_identifier(*(unsigned char **)(*(void *)(v113 + 8 * v112) + 8));
              appendStringInfoString((uint64_t)&__s1, v114);
              uint64_t v115 = *(int *)(v110 + 4);
              if (v113 + v111) {
                BOOL v116 = v113 + v111 >= (unint64_t)(*(void *)(v110 + 16) + 8 * v115);
              }
              else {
                BOOL v116 = 1;
              }
              if (!v116)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v115 = *(int *)(v110 + 4);
              }
              ++v112;
              v111 += 8;
            }
            while (v112 < v115);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          goto LABEL_168;
        case 0x138:
          appendStringInfoString((uint64_t)&__s1, "ALTER TEXT SEARCH CONFIGURATION ");
          uint64_t v479 = *(void *)(v18 + 8);
          if (v479 && *(int *)(v479 + 4) >= 1)
          {
            uint64_t v480 = 8;
            uint64_t v481 = 0;
            do
            {
              uint64_t v482 = *(void *)(v479 + 16);
              v483 = quote_identifier(*(unsigned char **)(*(void *)(v482 + 8 * v481) + 8));
              appendStringInfoString((uint64_t)&__s1, v483);
              uint64_t v484 = *(int *)(v479 + 4);
              if (v482 + v480) {
                BOOL v485 = v482 + v480 >= (unint64_t)(*(void *)(v479 + 16) + 8 * v484);
              }
              else {
                BOOL v485 = 1;
              }
              if (!v485)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v484 = *(int *)(v479 + 4);
              }
              ++v481;
              v480 += 8;
            }
            while (v481 < v484);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(_DWORD *)(v19 + 4))
          {
            case 0:
              appendStringInfoString((uint64_t)&__s1, "ADD MAPPING FOR ");
              uint64_t v486 = *(void *)(v19 + 16);
              if (v486 && *(int *)(v486 + 4) >= 1)
              {
                uint64_t v487 = 8;
                uint64_t v488 = 0;
                do
                {
                  uint64_t v489 = *(void *)(v486 + 16);
                  v490 = quote_identifier(*(unsigned char **)(*(void *)(v489 + 8 * v488) + 8));
                  appendStringInfoString((uint64_t)&__s1, v490);
                  uint64_t v491 = *(int *)(v486 + 4);
                  if (v489 + v487) {
                    BOOL v492 = v489 + v487 >= (unint64_t)(*(void *)(v486 + 16) + 8 * v491);
                  }
                  else {
                    BOOL v492 = 1;
                  }
                  if (!v492)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v491 = *(int *)(v486 + 4);
                  }
                  ++v488;
                  v487 += 8;
                }
                while (v488 < v491);
              }
              goto LABEL_1126;
            case 1:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING FOR ");
              uint64_t v678 = *(void *)(v19 + 16);
              if (v678 && *(int *)(v678 + 4) >= 1)
              {
                uint64_t v679 = 8;
                uint64_t v680 = 0;
                do
                {
                  uint64_t v681 = *(void *)(v678 + 16);
                  v682 = quote_identifier(*(unsigned char **)(*(void *)(v681 + 8 * v680) + 8));
                  appendStringInfoString((uint64_t)&__s1, v682);
                  uint64_t v683 = *(int *)(v678 + 4);
                  if (v681 + v679) {
                    BOOL v684 = v681 + v679 >= (unint64_t)(*(void *)(v678 + 16) + 8 * v683);
                  }
                  else {
                    BOOL v684 = 1;
                  }
                  if (!v684)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v683 = *(int *)(v678 + 4);
                  }
                  ++v680;
                  v679 += 8;
                }
                while (v680 < v683);
              }
LABEL_1126:
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              deparseAnyNameList((uint64_t)&__s1, *(void *)(v19 + 24));
              break;
            case 2:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING REPLACE ");
              uint64_t v685 = **(void **)(*(void *)(v19 + 24) + 16);
              if (v685 && *(int *)(v685 + 4) >= 1)
              {
                uint64_t v686 = 8;
                uint64_t v687 = 0;
                do
                {
                  uint64_t v688 = *(void *)(v685 + 16);
                  v689 = quote_identifier(*(unsigned char **)(*(void *)(v688 + 8 * v687) + 8));
                  appendStringInfoString((uint64_t)&__s1, v689);
                  uint64_t v690 = *(int *)(v685 + 4);
                  if (v688 + v686) {
                    BOOL v691 = v688 + v686 >= (unint64_t)(*(void *)(v685 + 16) + 8 * v690);
                  }
                  else {
                    BOOL v691 = 1;
                  }
                  if (!v691)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v690 = *(int *)(v685 + 4);
                  }
                  ++v687;
                  v686 += 8;
                }
                while (v687 < v690);
              }
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              uint64_t v699 = *(void *)(*(void *)(*(void *)(v19 + 24) + 16) + 8);
              if (v699 && *(int *)(v699 + 4) >= 1)
              {
                uint64_t v700 = 8;
                uint64_t v701 = 0;
                do
                {
                  uint64_t v702 = *(void *)(v699 + 16);
                  v703 = quote_identifier(*(unsigned char **)(*(void *)(v702 + 8 * v701) + 8));
                  appendStringInfoString((uint64_t)&__s1, v703);
                  uint64_t v704 = *(int *)(v699 + 4);
                  if (v702 + v700) {
                    BOOL v705 = v702 + v700 >= (unint64_t)(*(void *)(v699 + 16) + 8 * v704);
                  }
                  else {
                    BOOL v705 = 1;
                  }
                  if (!v705)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v704 = *(int *)(v699 + 4);
                  }
                  ++v701;
                  v700 += 8;
                }
                while (v701 < v704);
              }
              break;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "ALTER MAPPING FOR ");
              uint64_t v692 = *(void *)(v19 + 16);
              if (v692 && *(int *)(v692 + 4) >= 1)
              {
                uint64_t v693 = 8;
                uint64_t v694 = 0;
                do
                {
                  uint64_t v695 = *(void *)(v692 + 16);
                  v696 = quote_identifier(*(unsigned char **)(*(void *)(v695 + 8 * v694) + 8));
                  appendStringInfoString((uint64_t)&__s1, v696);
                  uint64_t v697 = *(int *)(v692 + 4);
                  if (v695 + v693) {
                    BOOL v698 = v695 + v693 >= (unint64_t)(*(void *)(v692 + 16) + 8 * v697);
                  }
                  else {
                    BOOL v698 = 1;
                  }
                  if (!v698)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v697 = *(int *)(v692 + 4);
                  }
                  ++v694;
                  v693 += 8;
                }
                while (v694 < v697);
              }
              appendStringInfoString((uint64_t)&__s1, " REPLACE ");
              uint64_t v706 = **(void **)(*(void *)(v19 + 24) + 16);
              if (v706 && *(int *)(v706 + 4) >= 1)
              {
                uint64_t v707 = 8;
                uint64_t v708 = 0;
                do
                {
                  uint64_t v709 = *(void *)(v706 + 16);
                  v710 = quote_identifier(*(unsigned char **)(*(void *)(v709 + 8 * v708) + 8));
                  appendStringInfoString((uint64_t)&__s1, v710);
                  uint64_t v711 = *(int *)(v706 + 4);
                  if (v709 + v707) {
                    BOOL v712 = v709 + v707 >= (unint64_t)(*(void *)(v706 + 16) + 8 * v711);
                  }
                  else {
                    BOOL v712 = 1;
                  }
                  if (!v712)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v711 = *(int *)(v706 + 4);
                  }
                  ++v708;
                  v707 += 8;
                }
                while (v708 < v711);
              }
              appendStringInfoString((uint64_t)&__s1, " WITH ");
              uint64_t v713 = *(void *)(*(void *)(*(void *)(v19 + 24) + 16) + 8);
              if (v713 && *(int *)(v713 + 4) >= 1)
              {
                uint64_t v714 = 8;
                uint64_t v715 = 0;
                do
                {
                  uint64_t v716 = *(void *)(v713 + 16);
                  v717 = quote_identifier(*(unsigned char **)(*(void *)(v716 + 8 * v715) + 8));
                  appendStringInfoString((uint64_t)&__s1, v717);
                  uint64_t v718 = *(int *)(v713 + 4);
                  if (v716 + v714) {
                    BOOL v719 = v716 + v714 >= (unint64_t)(*(void *)(v713 + 16) + 8 * v718);
                  }
                  else {
                    BOOL v719 = 1;
                  }
                  if (!v719)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v718 = *(int *)(v713 + 4);
                  }
                  ++v715;
                  v714 += 8;
                }
                while (v715 < v718);
              }
              break;
            case 4:
              appendStringInfoString((uint64_t)&__s1, "DROP MAPPING ");
              if (*(unsigned char *)(v19 + 34)) {
                appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
              }
              appendStringInfoString((uint64_t)&__s1, "FOR ");
              uint64_t v671 = *(void *)(v19 + 16);
              if (v671 && *(int *)(v671 + 4) >= 1)
              {
                uint64_t v672 = 8;
                uint64_t v673 = 0;
                do
                {
                  uint64_t v674 = *(void *)(v671 + 16);
                  v675 = quote_identifier(*(unsigned char **)(*(void *)(v674 + 8 * v673) + 8));
                  appendStringInfoString((uint64_t)&__s1, v675);
                  uint64_t v676 = *(int *)(v671 + 4);
                  if (v674 + v672) {
                    BOOL v677 = v674 + v672 >= (unint64_t)(*(void *)(v671 + 16) + 8 * v676);
                  }
                  else {
                    BOOL v677 = 1;
                  }
                  if (!v677)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v676 = *(int *)(v671 + 4);
                  }
                  ++v673;
                  v672 += 8;
                }
                while (v673 < v676);
              }
              break;
            default:
              goto LABEL_2105;
          }
          goto LABEL_2105;
        case 0x139:
          appendStringInfoString((uint64_t)&__s1, "CREATE FOREIGN DATA WRAPPER ");
          v394 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v394);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v395 = *(void *)(v18 + 16);
          if (v395 && *(int *)(v395 + 4) >= 1)
          {
            deparseFdwOptions((uint64_t)&__s1, v395);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          deparseCreateGenericOptions(&__s1, *(void *)(v18 + 24));
          uint64_t v352 = (v1233 - 1);
          if ((int)v1233 < 1) {
            goto LABEL_2105;
          }
          goto LABEL_2093;
        case 0x13A:
          appendStringInfoString((uint64_t)&__s1, "ALTER FOREIGN DATA WRAPPER ");
          v477 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v477);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v478 = *(void *)(v18 + 16);
          if (!v478 || *(int *)(v478 + 4) < 1) {
            goto LABEL_983;
          }
          deparseFdwOptions((uint64_t)&__s1, v478);
          goto LABEL_982;
        case 0x13B:
          appendStringInfoString((uint64_t)&__s1, "CREATE SERVER ");
          if (*(unsigned char *)(v18 + 40)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          unint64_t v65 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v65);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "TYPE ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(void *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "VERSION ");
            deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "FOREIGN DATA WRAPPER ");
          uint64_t v66 = quote_identifier(*(unsigned char **)(v18 + 32));
          appendStringInfoString((uint64_t)&__s1, v66);
          goto LABEL_897;
        case 0x13C:
          appendStringInfoString((uint64_t)&__s1, "ALTER SERVER ");
          uint64_t v104 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v104);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(unsigned char *)(v18 + 32)) {
            goto LABEL_983;
          }
          appendStringInfoString((uint64_t)&__s1, "VERSION ");
          uint64_t v105 = *(char **)(v18 + 16);
          if (v105) {
            deparseStringLiteral((uint64_t)&__s1, v105);
          }
          else {
            appendStringInfoString((uint64_t)&__s1, "NULL");
          }
LABEL_982:
          appendStringInfoChar((uint64_t)&__s1, 32);
LABEL_983:
          uint64_t v403 = *(void *)(v18 + 24);
          if (v403)
          {
LABEL_984:
            if (*(int *)(v403 + 4) >= 1) {
              deparseAlterGenericOptions((uint64_t)&__s1, v403);
            }
          }
          goto LABEL_2092;
        case 0x13D:
          appendStringInfoString((uint64_t)&__s1, "CREATE USER MAPPING ");
          if (*(unsigned char *)(v18 + 24)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          uint64_t v99 = *(void *)(v18 + 8);
          switch(*(_DWORD *)(v99 + 4))
          {
            case 0:
              uint64_t v100 = quote_identifier(*(unsigned char **)(v99 + 8));
              goto LABEL_1003;
            case 1:
              uint64_t v100 = "CURRENT_USER";
              goto LABEL_1003;
            case 2:
              uint64_t v100 = "SESSION_USER";
              goto LABEL_1003;
            case 3:
              uint64_t v100 = "public";
LABEL_1003:
              appendStringInfoString((uint64_t)&__s1, v100);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "SERVER ");
          v622 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v622);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreateGenericOptions(&__s1, *(void *)(v18 + 32));
          uint64_t v352 = (v1233 - 1);
          if ((int)v1233 < 1) {
            goto LABEL_2105;
          }
          goto LABEL_2093;
        case 0x13E:
          appendStringInfoString((uint64_t)&__s1, "ALTER USER MAPPING FOR ");
          uint64_t v461 = *(void *)(v18 + 8);
          switch(*(_DWORD *)(v461 + 4))
          {
            case 0:
              v462 = quote_identifier(*(unsigned char **)(v461 + 8));
              goto LABEL_1022;
            case 1:
              v462 = "CURRENT_USER";
              goto LABEL_1022;
            case 2:
              v462 = "SESSION_USER";
              goto LABEL_1022;
            case 3:
              v462 = "public";
LABEL_1022:
              appendStringInfoString((uint64_t)&__s1, v462);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "SERVER ");
          v625 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v625);
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseAlterGenericOptions((uint64_t)&__s1, *(void *)(v18 + 24));
          goto LABEL_2092;
        case 0x13F:
          appendStringInfoString((uint64_t)&__s1, "DROP USER MAPPING ");
          if (*(unsigned char *)(v18 + 24)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          appendStringInfoString((uint64_t)&__s1, "FOR ");
          uint64_t v459 = *(void *)(v18 + 8);
          switch(*(_DWORD *)(v459 + 4))
          {
            case 0:
              v460 = quote_identifier(*(unsigned char **)(v459 + 8));
              goto LABEL_1016;
            case 1:
              v460 = "CURRENT_USER";
              goto LABEL_1016;
            case 2:
              v460 = "SESSION_USER";
              goto LABEL_1016;
            case 3:
              v460 = "public";
LABEL_1016:
              appendStringInfoString((uint64_t)&__s1, v460);
              break;
            default:
              break;
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          unint64_t v158 = "SERVER ";
LABEL_1018:
          appendStringInfoString((uint64_t)&__s1, v158);
          uint64_t v108 = *(unsigned char **)(v19 + 16);
          goto LABEL_1818;
        case 0x140:
          appendStringInfoString((uint64_t)&__s1, "ALTER TABLESPACE ");
          uint64_t v185 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v185);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(unsigned char *)(v18 + 24)) {
            BOOL v186 = "RESET ";
          }
          else {
            BOOL v186 = "SET ";
          }
          appendStringInfoString((uint64_t)&__s1, v186);
          deparseRelOptions(&__s1, *(void *)(v18 + 16));
          goto LABEL_2105;
        case 0x142:
          appendStringInfoString((uint64_t)&__s1, "SECURITY LABEL ");
          if (*(void *)(v18 + 16))
          {
            appendStringInfoString((uint64_t)&__s1, "FOR ");
            unint64_t v187 = quote_identifier(*(unsigned char **)(v18 + 16));
            appendStringInfoString((uint64_t)&__s1, v187);
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          appendStringInfoString((uint64_t)&__s1, "ON ");
          switch(*(_DWORD *)(v18 + 4))
          {
            case 1:
              appendStringInfoString((uint64_t)&__s1, "AGGREGATE ");
              deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 8));
              break;
            case 6:
              appendStringInfoString((uint64_t)&__s1, "COLUMN ");
              uint64_t v939 = *(void *)(v18 + 8);
              if (v939 && *(int *)(v939 + 4) >= 1)
              {
                uint64_t v940 = 8;
                uint64_t v941 = 0;
                do
                {
                  uint64_t v942 = *(void *)(v939 + 16);
                  v943 = quote_identifier(*(unsigned char **)(*(void *)(v942 + 8 * v941) + 8));
                  appendStringInfoString((uint64_t)&__s1, v943);
                  uint64_t v944 = *(int *)(v939 + 4);
                  if (v942 + v940) {
                    BOOL v945 = v942 + v940 >= (unint64_t)(*(void *)(v939 + 16) + 8 * v944);
                  }
                  else {
                    BOOL v945 = 1;
                  }
                  if (!v945)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v944 = *(int *)(v939 + 4);
                  }
                  ++v941;
                  v940 += 8;
                }
                while (v941 < v944);
              }
              break;
            case 9:
              v946 = "DATABASE ";
              goto LABEL_1695;
            case 0xC:
              v947 = "DOMAIN ";
              goto LABEL_1697;
            case 0xE:
              v946 = "EVENT TRIGGER ";
              goto LABEL_1695;
            case 0x12:
              appendStringInfoString((uint64_t)&__s1, "FOREIGN TABLE ");
              uint64_t v948 = *(void *)(v18 + 8);
              if (v948 && *(int *)(v948 + 4) >= 1)
              {
                uint64_t v949 = 8;
                uint64_t v950 = 0;
                do
                {
                  uint64_t v951 = *(void *)(v948 + 16);
                  v952 = quote_identifier(*(unsigned char **)(*(void *)(v951 + 8 * v950) + 8));
                  appendStringInfoString((uint64_t)&__s1, v952);
                  uint64_t v953 = *(int *)(v948 + 4);
                  if (v951 + v949) {
                    BOOL v954 = v951 + v949 >= (unint64_t)(*(void *)(v948 + 16) + 8 * v953);
                  }
                  else {
                    BOOL v954 = 1;
                  }
                  if (!v954)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v953 = *(int *)(v948 + 4);
                  }
                  ++v950;
                  v949 += 8;
                }
                while (v950 < v953);
              }
              break;
            case 0x13:
              v955 = "FUNCTION ";
              goto LABEL_1673;
            case 0x15:
              v946 = "LANGUAGE ";
              goto LABEL_1695;
            case 0x16:
              appendStringInfoString((uint64_t)&__s1, "LARGE OBJECT ");
              deparseValue(&__s1, *(_DWORD **)(v18 + 8), 11, v956, v957, v958, v959, v960);
              break;
            case 0x17:
              appendStringInfoString((uint64_t)&__s1, "MATERIALIZED VIEW ");
              uint64_t v961 = *(void *)(v18 + 8);
              if (v961 && *(int *)(v961 + 4) >= 1)
              {
                uint64_t v962 = 8;
                uint64_t v963 = 0;
                do
                {
                  uint64_t v964 = *(void *)(v961 + 16);
                  v965 = quote_identifier(*(unsigned char **)(*(void *)(v964 + 8 * v963) + 8));
                  appendStringInfoString((uint64_t)&__s1, v965);
                  uint64_t v966 = *(int *)(v961 + 4);
                  if (v964 + v962) {
                    BOOL v967 = v964 + v962 >= (unint64_t)(*(void *)(v961 + 16) + 8 * v966);
                  }
                  else {
                    BOOL v967 = 1;
                  }
                  if (!v967)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v966 = *(int *)(v961 + 4);
                  }
                  ++v963;
                  v962 += 8;
                }
                while (v963 < v966);
              }
              break;
            case 0x1C:
              v955 = "PROCEDURE ";
              goto LABEL_1673;
            case 0x1D:
              v946 = "PUBLICATION ";
              goto LABEL_1695;
            case 0x1F:
              v946 = "ROLE ";
              goto LABEL_1695;
            case 0x20:
              v955 = "ROUTINE ";
LABEL_1673:
              appendStringInfoString((uint64_t)&__s1, v955);
              deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 8));
              break;
            case 0x22:
              v946 = "SCHEMA ";
              goto LABEL_1695;
            case 0x23:
              appendStringInfoString((uint64_t)&__s1, "SEQUENCE ");
              uint64_t v968 = *(void *)(v18 + 8);
              if (v968 && *(int *)(v968 + 4) >= 1)
              {
                uint64_t v969 = 8;
                uint64_t v970 = 0;
                do
                {
                  uint64_t v971 = *(void *)(v968 + 16);
                  v972 = quote_identifier(*(unsigned char **)(*(void *)(v971 + 8 * v970) + 8));
                  appendStringInfoString((uint64_t)&__s1, v972);
                  uint64_t v973 = *(int *)(v968 + 4);
                  if (v971 + v969) {
                    BOOL v974 = v971 + v969 >= (unint64_t)(*(void *)(v968 + 16) + 8 * v973);
                  }
                  else {
                    BOOL v974 = 1;
                  }
                  if (!v974)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v973 = *(int *)(v968 + 4);
                  }
                  ++v970;
                  v969 += 8;
                }
                while (v970 < v973);
              }
              break;
            case 0x24:
              v946 = "SUBSCRIPTION ";
              goto LABEL_1695;
            case 0x27:
              appendStringInfoString((uint64_t)&__s1, "TABLE ");
              uint64_t v975 = *(void *)(v18 + 8);
              if (v975 && *(int *)(v975 + 4) >= 1)
              {
                uint64_t v976 = 8;
                uint64_t v977 = 0;
                do
                {
                  uint64_t v978 = *(void *)(v975 + 16);
                  v979 = quote_identifier(*(unsigned char **)(*(void *)(v978 + 8 * v977) + 8));
                  appendStringInfoString((uint64_t)&__s1, v979);
                  uint64_t v980 = *(int *)(v975 + 4);
                  if (v978 + v976) {
                    BOOL v981 = v978 + v976 >= (unint64_t)(*(void *)(v975 + 16) + 8 * v980);
                  }
                  else {
                    BOOL v981 = 1;
                  }
                  if (!v981)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v980 = *(int *)(v975 + 4);
                  }
                  ++v977;
                  v976 += 8;
                }
                while (v977 < v980);
              }
              break;
            case 0x28:
              v946 = "TABLESPACE ";
LABEL_1695:
              appendStringInfoString((uint64_t)&__s1, v946);
              v982 = quote_identifier(*(unsigned char **)(*(void *)(v18 + 8) + 8));
              appendStringInfoString((uint64_t)&__s1, v982);
              break;
            case 0x2F:
              v947 = "TYPE ";
LABEL_1697:
              appendStringInfoString((uint64_t)&__s1, v947);
              deparseTypeName(&__s1, *(void *)(v18 + 8));
              break;
            case 0x31:
              appendStringInfoString((uint64_t)&__s1, "VIEW ");
              uint64_t v983 = *(void *)(v18 + 8);
              if (v983 && *(int *)(v983 + 4) >= 1)
              {
                uint64_t v984 = 8;
                uint64_t v985 = 0;
                do
                {
                  uint64_t v986 = *(void *)(v983 + 16);
                  v987 = quote_identifier(*(unsigned char **)(*(void *)(v986 + 8 * v985) + 8));
                  appendStringInfoString((uint64_t)&__s1, v987);
                  uint64_t v988 = *(int *)(v983 + 4);
                  if (v986 + v984) {
                    BOOL v989 = v986 + v984 >= (unint64_t)(*(void *)(v983 + 16) + 8 * v988);
                  }
                  else {
                    BOOL v989 = 1;
                  }
                  if (!v989)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v988 = *(int *)(v983 + 4);
                  }
                  ++v985;
                  v984 += 8;
                }
                while (v985 < v988);
              }
              break;
            default:
              break;
          }
          appendStringInfoString((uint64_t)&__s1, " IS ");
          char v359 = *(char **)(v19 + 24);
          if (v359)
          {
LABEL_1699:
            deparseStringLiteral((uint64_t)&__s1, v359);
            goto LABEL_2105;
          }
LABEL_2103:
          long long v27 = "NULL";
          goto LABEL_2104;
        case 0x143:
          deparseCreateStmt(&__s1, v18, 1);
          appendStringInfoString((uint64_t)&__s1, " SERVER ");
          v402 = quote_identifier(*(unsigned char **)(v18 + 104));
          appendStringInfoString((uint64_t)&__s1, v402);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v403 = *(void *)(v18 + 112);
          if (!v403) {
            goto LABEL_2092;
          }
          goto LABEL_984;
        case 0x144:
          appendStringInfoString((uint64_t)&__s1, "IMPORT FOREIGN SCHEMA ");
          appendStringInfoString((uint64_t)&__s1, *(char **)(v18 + 16));
          appendStringInfoChar((uint64_t)&__s1, 32);
          int v47 = *(_DWORD *)(v18 + 32);
          if (v47 == 2)
          {
            appendStringInfoString((uint64_t)&__s1, "EXCEPT (");
            uint64_t v565 = *(void *)(v18 + 40);
            if (v565 && *(int *)(v565 + 4) >= 1)
            {
              uint64_t v566 = 8;
              uint64_t v567 = 0;
              do
              {
                uint64_t v568 = *(void *)(v565 + 16);
                deparseRangeVar((uint64_t)&__s1, *(void *)(v568 + 8 * v567), 0);
                uint64_t v569 = *(int *)(v565 + 4);
                if (v568 + v566) {
                  BOOL v570 = v568 + v566 >= (unint64_t)(*(void *)(v565 + 16) + 8 * v569);
                }
                else {
                  BOOL v570 = 1;
                }
                if (!v570)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  uint64_t v569 = *(int *)(v565 + 4);
                }
                ++v567;
                v566 += 8;
              }
              while (v567 < v569);
            }
          }
          else
          {
            if (v47 != 1) {
              goto LABEL_896;
            }
            appendStringInfoString((uint64_t)&__s1, "LIMIT TO (");
            uint64_t v48 = *(void *)(v18 + 40);
            if (v48 && *(int *)(v48 + 4) >= 1)
            {
              uint64_t v49 = 8;
              uint64_t v50 = 0;
              do
              {
                uint64_t v51 = *(void *)(v48 + 16);
                deparseRangeVar((uint64_t)&__s1, *(void *)(v51 + 8 * v50), 0);
                uint64_t v52 = *(int *)(v48 + 4);
                if (v51 + v49) {
                  BOOL v53 = v51 + v49 >= (unint64_t)(*(void *)(v48 + 16) + 8 * v52);
                }
                else {
                  BOOL v53 = 1;
                }
                if (!v53)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  uint64_t v52 = *(int *)(v48 + 4);
                }
                ++v50;
                v49 += 8;
              }
              while (v50 < v52);
            }
          }
          appendStringInfoString((uint64_t)&__s1, ") ");
LABEL_896:
          appendStringInfoString((uint64_t)&__s1, "FROM SERVER ");
          v571 = quote_identifier(*(unsigned char **)(v19 + 8));
          appendStringInfoString((uint64_t)&__s1, v571);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "INTO ");
          v572 = quote_identifier(*(unsigned char **)(v19 + 24));
          appendStringInfoString((uint64_t)&__s1, v572);
LABEL_897:
          appendStringInfoChar((uint64_t)&__s1, 32);
          deparseCreateGenericOptions(&__s1, *(void *)(v19 + 48));
          uint64_t v352 = (v1233 - 1);
          if ((int)v1233 < 1) {
            goto LABEL_2105;
          }
          goto LABEL_2093;
        case 0x145:
          appendStringInfoString((uint64_t)&__s1, "CREATE EXTENSION ");
          if (*(unsigned char *)(v18 + 16)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          v451 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v451);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v452 = *(void *)(v18 + 24);
          if (!v452 || *(int *)(v452 + 4) < 1) {
            goto LABEL_2092;
          }
          uint64_t v453 = 0;
          while (1)
          {
            uint64_t v455 = *(void *)(*(void *)(v452 + 16) + 8 * v453);
            v456 = *(const char **)(v455 + 16);
            if (!strcmp(v456, "schema"))
            {
              appendStringInfoString((uint64_t)&__s1, "SCHEMA ");
              v454 = quote_identifier(*(unsigned char **)(*(void *)(v455 + 24) + 8));
            }
            else if (!strcmp(v456, "new_version"))
            {
              appendStringInfoString((uint64_t)&__s1, "VERSION ");
              v457 = *(char **)(*(void *)(v455 + 24) + 8);
              size_t v458 = strlen(v457);
              if (v458)
              {
                if (v458 >= 0x40)
                {
                  deparseStringLiteral((uint64_t)&__s1, v457);
                  goto LABEL_714;
                }
                v454 = quote_identifier(v457);
              }
              else
              {
                v454 = "''";
              }
            }
            else
            {
              if (strcmp(v456, "cascade")) {
                goto LABEL_714;
              }
              v454 = "CASCADE";
            }
            appendStringInfoString((uint64_t)&__s1, v454);
LABEL_714:
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (++v453 >= *(int *)(v452 + 4)) {
              goto LABEL_2092;
            }
          }
        case 0x146:
          appendStringInfoString((uint64_t)&__s1, "ALTER EXTENSION ");
          v436 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v436);
          appendStringInfoString((uint64_t)&__s1, " UPDATE ");
          uint64_t v437 = *(void *)(v18 + 16);
          if (!v437 || *(int *)(v437 + 4) < 1) {
            goto LABEL_2092;
          }
          uint64_t v438 = 0;
          while (1)
          {
            uint64_t v440 = *(void *)(*(void *)(v437 + 16) + 8 * v438);
            if (!strcmp(*(const char **)(v440 + 16), "new_version"))
            {
              appendStringInfoString((uint64_t)&__s1, "TO ");
              v441 = *(char **)(*(void *)(v440 + 24) + 8);
              size_t v442 = strlen(v441);
              if (v442)
              {
                if (v442 >= 0x40)
                {
                  deparseStringLiteral((uint64_t)&__s1, v441);
                  goto LABEL_689;
                }
                v439 = quote_identifier(v441);
              }
              else
              {
                v439 = "''";
              }
              appendStringInfoString((uint64_t)&__s1, v439);
            }
LABEL_689:
            appendStringInfoChar((uint64_t)&__s1, 32);
            if (++v438 >= *(int *)(v437 + 4)) {
              goto LABEL_2092;
            }
          }
        case 0x147:
          appendStringInfoString((uint64_t)&__s1, "ALTER EXTENSION ");
          v496 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v496);
          appendStringInfoChar((uint64_t)&__s1, 32);
          int v497 = *(_DWORD *)(v18 + 16);
          if (v497 == 1)
          {
            v498 = "ADD ";
          }
          else
          {
            if (v497 != -1)
            {
LABEL_912:
              unsigned int v580 = *(_DWORD *)(v18 + 20);
              unsigned int v581 = v580;
              if (v580 <= 0x31 && ((0x2FA8D17AF51A3uLL >> v580) & 1) != 0)
              {
                appendStringInfoString((uint64_t)&__s1, (&off_1E55D88D8)[v580]);
                unsigned int v581 = *(_DWORD *)(v18 + 20);
              }
              switch(v581)
              {
                case 0u:
                case 0xEu:
                case 0x10u:
                case 0x11u:
                case 0x15u:
                case 0x22u:
                  uint64_t v54 = *(void *)(v18 + 24);
LABEL_1931:
                  uint64_t v108 = *(unsigned char **)(v54 + 8);
                  goto LABEL_1818;
                case 1u:
                  deparseAggregateWithArgtypes(&__s1, *(void *)(v18 + 24));
                  goto LABEL_2105;
                case 5u:
                  uint64_t v1148 = *(void *)(v18 + 24);
                  appendStringInfoChar((uint64_t)&__s1, 40);
                  deparseTypeName(&__s1, **(void **)(v1148 + 16));
                  appendStringInfoString((uint64_t)&__s1, " AS ");
                  deparseTypeName(&__s1, *(void *)(*(void *)(v1148 + 16) + 8));
                  appendStringInfoChar((uint64_t)&__s1, 41);
                  goto LABEL_2105;
                case 7u:
                case 8u:
                case 0x12u:
                case 0x17u:
                case 0x23u:
                case 0x27u:
                case 0x2Bu:
                case 0x2Cu:
                case 0x2Du:
                case 0x2Eu:
                case 0x31u:
                  uint64_t v582 = *(void *)(v18 + 24);
                  if (v582 && *(int *)(v582 + 4) >= 1)
                  {
                    uint64_t v583 = 8;
                    uint64_t v584 = 0;
                    do
                    {
                      uint64_t v585 = *(void *)(v582 + 16);
                      v586 = quote_identifier(*(unsigned char **)(*(void *)(v585 + 8 * v584) + 8));
                      appendStringInfoString((uint64_t)&__s1, v586);
                      uint64_t v587 = *(int *)(v582 + 4);
                      if (v585 + v583) {
                        BOOL v588 = v585 + v583 >= (unint64_t)(*(void *)(v582 + 16) + 8 * v587);
                      }
                      else {
                        BOOL v588 = 1;
                      }
                      if (!v588)
                      {
                        appendStringInfoChar((uint64_t)&__s1, 46);
                        uint64_t v587 = *(int *)(v582 + 4);
                      }
                      ++v584;
                      v583 += 8;
                    }
                    while (v584 < v587);
                  }
                  goto LABEL_2105;
                case 0xCu:
                case 0x2Fu:
                  deparseTypeName(&__s1, *(void *)(v18 + 24));
                  goto LABEL_2105;
                case 0x13u:
                case 0x1Cu:
                case 0x20u:
                  deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 24));
                  goto LABEL_2105;
                case 0x18u:
                case 0x1Au:
                  uint64_t v908 = *(void *)(v18 + 24);
                  if (!v908)
                  {
LABEL_2115:
                    appendStringInfoString((uint64_t)&__s1, " USING ");
                    __break(1u);
                    JUMPOUT(0x18EA7AF30);
                  }
                  if (*(int *)(v908 + 4) >= 2)
                  {
                    int v909 = 1;
                    do
                    {
                      v910 = (uint64_t *)(*(void *)(v908 + 16) + 8 * v909);
                      uint64_t v912 = *v910;
                      unint64_t v911 = (unint64_t)(v910 + 1);
                      v913 = quote_identifier(*(unsigned char **)(v912 + 8));
                      appendStringInfoString((uint64_t)&__s1, v913);
                      uint64_t v914 = *(int *)(v908 + 4);
                      if (v911) {
                        BOOL v915 = v911 >= *(void *)(v908 + 16) + 8 * v914;
                      }
                      else {
                        BOOL v915 = 1;
                      }
                      if (!v915)
                      {
                        appendStringInfoChar((uint64_t)&__s1, 46);
                        LODWORD(v914) = *(_DWORD *)(v908 + 4);
                      }
                      ++v909;
                    }
                    while ((int)v914 > v909);
                  }
                  appendStringInfoString((uint64_t)&__s1, " USING ");
                  uint64_t v916 = **(void **)(v908 + 16);
                  goto LABEL_1940;
                case 0x19u:
                  deparseOperatorWithArgtypes(&__s1, *(void *)(v18 + 24));
                  goto LABEL_2105;
                case 0x29u:
                  uint64_t v1149 = *(void *)(v18 + 24);
                  appendStringInfoString((uint64_t)&__s1, "FOR ");
                  deparseTypeName(&__s1, **(void **)(v1149 + 16));
                  appendStringInfoString((uint64_t)&__s1, " LANGUAGE ");
                  uint64_t v916 = *(void *)(*(void *)(v1149 + 16) + 8);
LABEL_1940:
                  long long v27 = quote_identifier(*(unsigned char **)(v916 + 8));
                  goto LABEL_2104;
                default:
                  goto LABEL_2105;
              }
            }
            v498 = "DROP ";
          }
          appendStringInfoString((uint64_t)&__s1, v498);
          goto LABEL_912;
        case 0x148:
          appendStringInfoString((uint64_t)&__s1, "CREATE EVENT TRIGGER ");
          uint64_t v128 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v128);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "ON ");
          uint64_t v129 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v129);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(void *)(v18 + 24)) {
            goto LABEL_766;
          }
          int v1226 = v16;
          uint64_t v16 = v17;
          appendStringInfoString((uint64_t)&__s1, "WHEN ");
          uint64_t v130 = *(void *)(v18 + 24);
          if (!v130 || *(int *)(v130 + 4) < 1) {
            goto LABEL_765;
          }
          uint64_t v131 = 0;
          while (1)
          {
            uint64_t v132 = *(void *)(v130 + 16) + 8 * v131;
            uint64_t v133 = *(void *)(*(void *)v132 + 24);
            unint64_t v134 = quote_identifier(*(unsigned char **)(*(void *)v132 + 16));
            appendStringInfoString((uint64_t)&__s1, v134);
            appendStringInfoString((uint64_t)&__s1, " IN (");
            if (v133)
            {
              if (*(int *)(v133 + 4) >= 1) {
                break;
              }
            }
LABEL_201:
            appendStringInfoChar((uint64_t)&__s1, 41);
            if (v132 != -8
              && v132 + 8 < (unint64_t)(*(void *)(*(void *)(v19 + 24) + 16)
                                             + 8 * *(int *)(*(void *)(v19 + 24) + 4)))
            {
              appendStringInfoString((uint64_t)&__s1, " AND ");
            }
            if (++v131 >= *(int *)(v130 + 4))
            {
LABEL_765:
              appendStringInfoChar((uint64_t)&__s1, 32);
              uint64_t v15 = v1227;
              uint64_t v17 = v16;
              LODWORD(v16) = v1226;
LABEL_766:
              appendStringInfoString((uint64_t)&__s1, "EXECUTE FUNCTION ");
              uint64_t v499 = *(void *)(v19 + 32);
              if (v499 && *(int *)(v499 + 4) >= 1)
              {
                uint64_t v500 = 8;
                uint64_t v501 = 0;
                do
                {
                  uint64_t v502 = *(void *)(v499 + 16);
                  v503 = quote_identifier(*(unsigned char **)(*(void *)(v502 + 8 * v501) + 8));
                  appendStringInfoString((uint64_t)&__s1, v503);
                  uint64_t v504 = *(int *)(v499 + 4);
                  if (v502 + v500) {
                    BOOL v505 = v502 + v500 >= (unint64_t)(*(void *)(v499 + 16) + 8 * v504);
                  }
                  else {
                    BOOL v505 = 1;
                  }
                  if (!v505)
                  {
                    appendStringInfoChar((uint64_t)&__s1, 46);
                    uint64_t v504 = *(int *)(v499 + 4);
                  }
                  ++v501;
                  v500 += 8;
                }
                while (v501 < v504);
              }
              long long v27 = "()";
              goto LABEL_2104;
            }
          }
          uint64_t v135 = 0;
LABEL_190:
          uint64_t v136 = *(void *)(v133 + 16) + 8 * v135;
          uint64_t v137 = *(char **)(*(void *)v136 + 8);
          if (strchr(v137, 92)) {
            appendStringInfoChar((uint64_t)&__s1, 69);
          }
          appendStringInfoChar((uint64_t)&__s1, 39);
          while (1)
          {
            int v138 = *v137;
            char v139 = *v137;
            if (v138 == 39 || v138 == 92)
            {
              appendStringInfoChar((uint64_t)&__s1, v138);
            }
            else if (!*v137)
            {
              appendStringInfoChar((uint64_t)&__s1, 39);
              uint64_t v140 = *(int *)(v133 + 4);
              if (v136 != -8 && v136 + 8 < (unint64_t)(*(void *)(v133 + 16) + 8 * *(int *)(v133 + 4)))
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v140 = *(int *)(v133 + 4);
              }
              if (++v135 >= v140) {
                goto LABEL_201;
              }
              goto LABEL_190;
            }
            appendStringInfoChar((uint64_t)&__s1, v139);
            ++v137;
          }
        case 0x149:
          appendStringInfoString((uint64_t)&__s1, "ALTER EVENT TRIGGER ");
          uint64_t v46 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v46);
          appendStringInfoChar((uint64_t)&__s1, 32);
          long long v27 = "ENABLE";
          switch(*(unsigned char *)(v18 + 16))
          {
            case 'A':
              long long v27 = "ENABLE ALWAYS";
              goto LABEL_2104;
            case 'D':
              long long v27 = "DISABLE";
              goto LABEL_2104;
            case 'O':
              goto LABEL_2104;
            case 'R':
              long long v27 = "ENABLE REPLICA";
              goto LABEL_2104;
            default:
              goto LABEL_2105;
          }
          goto LABEL_2105;
        case 0x14A:
          deparseRefreshMatViewStmt((uint64_t)&__s1, *(void *)(*(void *)v17 + 8));
          goto LABEL_2105;
        case 0x14C:
          appendStringInfoString((uint64_t)&__s1, "ALTER SYSTEM ");
          uint64_t v358 = *(void *)(v18 + 8);
LABEL_1492:
          deparseVariableSetStmt((uint64_t)&__s1, v358);
          goto LABEL_2105;
        case 0x14D:
          appendStringInfoString((uint64_t)&__s1, "CREATE POLICY ");
          long long v28 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v28);
          appendStringInfoString((uint64_t)&__s1, " ON ");
          deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 16), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (!*(unsigned char *)(v18 + 32)) {
            appendStringInfoString((uint64_t)&__s1, "AS RESTRICTIVE ");
          }
          long long v29 = *(const char **)(v18 + 24);
          if (!strcmp(v29, "all")) {
            goto LABEL_1533;
          }
          if (!strcmp(v29, "select"))
          {
            long long v30 = "FOR SELECT ";
          }
          else if (!strcmp(v29, "insert"))
          {
            long long v30 = "FOR INSERT ";
          }
          else if (!strcmp(v29, "update"))
          {
            long long v30 = "FOR UPDATE ";
          }
          else
          {
            if (strcmp(v29, "delete")) {
              goto LABEL_1533;
            }
            long long v30 = "FOR DELETE ";
          }
          appendStringInfoString((uint64_t)&__s1, v30);
LABEL_1533:
          appendStringInfoString((uint64_t)&__s1, "TO ");
          deparseRoleList(&__s1, *(void *)(v18 + 40));
          appendStringInfoChar((uint64_t)&__s1, 32);
          if (*(void *)(v18 + 48))
          {
            appendStringInfoString((uint64_t)&__s1, "USING (");
            deparseExpr(&__s1, *(int **)(v18 + 48), v868, v869, v870, v871, v872, v873);
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (!*(void *)(v18 + 56)) {
            goto LABEL_2105;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH CHECK (");
          deparseExpr(&__s1, *(int **)(v18 + 56), v874, v875, v876, v877, v878, v879);
          long long v27 = ") ";
          goto LABEL_2104;
        case 0x14E:
          appendStringInfoString((uint64_t)&__s1, "ALTER POLICY ");
          v463 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v463);
          appendStringInfoString((uint64_t)&__s1, " ON ");
          deparseRangeVar((uint64_t)&__s1, *(void *)(v18 + 16), 0);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v464 = *(void *)(v18 + 24);
          if (v464 && *(int *)(v464 + 4) >= 1)
          {
            appendStringInfoString((uint64_t)&__s1, "TO ");
            deparseRoleList(&__s1, *(void *)(v18 + 24));
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          if (*(void *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "USING (");
            deparseExpr(&__s1, *(int **)(v18 + 32), v465, v466, v467, v468, v469, v470);
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          if (!*(void *)(v18 + 40)) {
            goto LABEL_2105;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH CHECK (");
          deparseExpr(&__s1, *(int **)(v18 + 40), v471, v472, v473, v474, v475, v476);
          long long v27 = ") ";
          goto LABEL_2104;
        case 0x14F:
          appendStringInfoString((uint64_t)&__s1, "CREATE ");
          if (*(unsigned char *)(v18 + 4)) {
            appendStringInfoString((uint64_t)&__s1, "OR REPLACE ");
          }
          appendStringInfoString((uint64_t)&__s1, "TRANSFORM FOR ");
          deparseTypeName(&__s1, *(void *)(v18 + 8));
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "LANGUAGE ");
          uint64_t v142 = quote_identifier(*(unsigned char **)(v18 + 16));
          appendStringInfoString((uint64_t)&__s1, v142);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoChar((uint64_t)&__s1, 40);
          if (*(void *)(v18 + 24))
          {
            appendStringInfoString((uint64_t)&__s1, "FROM SQL WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 24));
            if (*(void *)(v18 + 24))
            {
              if (*(void *)(v18 + 32)) {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
            }
          }
          if (*(void *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "TO SQL WITH FUNCTION ");
            deparseFunctionWithArgtypes((uint64_t)&__s1, *(void *)(v18 + 32));
          }
          goto LABEL_996;
        case 0x150:
          appendStringInfoString((uint64_t)&__s1, "CREATE ACCESS METHOD ");
          v493 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v493);
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfoString((uint64_t)&__s1, "TYPE ");
          int v494 = *(char *)(v18 + 24);
          if (v494 == 105)
          {
            v495 = "INDEX ";
          }
          else
          {
            if (v494 != 116) {
              goto LABEL_901;
            }
            v495 = "TABLE ";
          }
          appendStringInfoString((uint64_t)&__s1, v495);
LABEL_901:
          appendStringInfoString((uint64_t)&__s1, "HANDLER ");
          uint64_t v573 = *(void *)(v18 + 16);
          if (v573 && *(int *)(v573 + 4) >= 1)
          {
            uint64_t v574 = 8;
            uint64_t v575 = 0;
            do
            {
              uint64_t v576 = *(void *)(v573 + 16);
              v577 = quote_identifier(*(unsigned char **)(*(void *)(v576 + 8 * v575) + 8));
              appendStringInfoString((uint64_t)&__s1, v577);
              uint64_t v578 = *(int *)(v573 + 4);
              if (v576 + v574) {
                BOOL v579 = v576 + v574 >= (unint64_t)(*(void *)(v573 + 16) + 8 * v578);
              }
              else {
                BOOL v579 = 1;
              }
              if (!v579)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v578 = *(int *)(v573 + 4);
              }
              ++v575;
              v574 += 8;
            }
            while (v575 < v578);
          }
          goto LABEL_2105;
        case 0x151:
          appendStringInfoString((uint64_t)&__s1, "CREATE PUBLICATION ");
          v421 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v421);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v422 = *(void *)(v18 + 24);
          if (v422 && *(int *)(v422 + 4) >= 1)
          {
            appendStringInfoString((uint64_t)&__s1, "FOR TABLE ");
            uint64_t v423 = *(void *)(v18 + 24);
            if (v423 && *(int *)(v423 + 4) >= 1)
            {
              uint64_t v424 = 8;
              uint64_t v425 = 0;
              do
              {
                uint64_t v426 = *(void *)(v423 + 16);
                deparseRangeVar((uint64_t)&__s1, *(void *)(v426 + 8 * v425), 0);
                uint64_t v427 = *(int *)(v423 + 4);
                if (v426 + v424) {
                  BOOL v428 = v426 + v424 >= (unint64_t)(*(void *)(v423 + 16) + 8 * v427);
                }
                else {
                  BOOL v428 = 1;
                }
                if (!v428)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  uint64_t v427 = *(int *)(v423 + 4);
                }
                ++v425;
                v424 += 8;
              }
              while (v425 < v427);
            }
            appendStringInfoChar((uint64_t)&__s1, 32);
          }
          else if (*(unsigned char *)(v18 + 32))
          {
            appendStringInfoString((uint64_t)&__s1, "FOR ALL TABLES ");
          }
          uint64_t v554 = *(void *)(v19 + 16);
          if (!v554) {
            goto LABEL_2092;
          }
          goto LABEL_877;
        case 0x152:
          appendStringInfoString((uint64_t)&__s1, "ALTER PUBLICATION ");
          v409 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v409);
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v410 = *(void *)(v18 + 24);
          if (v410 && *(int *)(v410 + 4) >= 1)
          {
            unsigned int v411 = *(_DWORD *)(v18 + 36) - 1;
            if (v411 > 2
              || (appendStringInfoString((uint64_t)&__s1, (&off_1E55D8A68)[v411]), (uint64_t v410 = *(void *)(v18 + 24)) != 0))
            {
              uint64_t v412 = v410;
              if (*(int *)(v410 + 4) >= 1)
              {
                uint64_t v413 = 8;
                uint64_t v414 = 0;
                do
                {
                  uint64_t v415 = *(void *)(v412 + 16);
                  deparseRangeVar((uint64_t)&__s1, *(void *)(v415 + 8 * v414), 0);
                  uint64_t v416 = *(int *)(v412 + 4);
                  if (v415 + v413) {
                    BOOL v417 = v415 + v413 >= (unint64_t)(*(void *)(v412 + 16) + 8 * v416);
                  }
                  else {
                    BOOL v417 = 1;
                  }
                  if (!v417)
                  {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                    uint64_t v416 = *(int *)(v412 + 4);
                  }
                  ++v414;
                  v413 += 8;
                }
                while (v414 < v416);
              }
            }
          }
          else
          {
            uint64_t v506 = *(void *)(v18 + 16);
            if (v506 && *(int *)(v506 + 4) >= 1)
            {
              appendStringInfoString((uint64_t)&__s1, "SET ");
LABEL_168:
              deparseDefinition(&__s1, *(void *)(v19 + 16));
            }
          }
          goto LABEL_2105;
        case 0x153:
          appendStringInfoString((uint64_t)&__s1, "CREATE SUBSCRIPTION ");
          uint64_t v63 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v63);
          appendStringInfoString((uint64_t)&__s1, " CONNECTION ");
          int v64 = *(char **)(v18 + 16);
          if (v64) {
            deparseStringLiteral((uint64_t)&__s1, v64);
          }
          else {
            appendStringInfoString((uint64_t)&__s1, "''");
          }
          appendStringInfoString((uint64_t)&__s1, " PUBLICATION ");
          uint64_t v556 = *(void *)(v18 + 24);
          if (v556 && *(int *)(v556 + 4) >= 1)
          {
            uint64_t v557 = 8;
            uint64_t v558 = 0;
            do
            {
              uint64_t v559 = *(void *)(v556 + 16);
              v560 = quote_identifier(*(unsigned char **)(*(void *)(v559 + 8 * v558) + 8));
              appendStringInfoString((uint64_t)&__s1, v560);
              if (v559 + v557) {
                BOOL v561 = v559 + v557 >= (unint64_t)(*(void *)(*(void *)(v19 + 24) + 16)
              }
                                                       + 8 * *(int *)(*(void *)(v19 + 24) + 4));
              else {
                BOOL v561 = 1;
              }
              if (!v561) {
                appendStringInfoString((uint64_t)&__s1, ", ");
              }
              ++v558;
              v557 += 8;
            }
            while (v558 < *(int *)(v556 + 4));
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v554 = *(void *)(v19 + 32);
          if (!v554) {
            goto LABEL_2092;
          }
LABEL_877:
          if (*(int *)(v554 + 4) < 1) {
            goto LABEL_2092;
          }
          appendStringInfoString((uint64_t)&__s1, "WITH ");
          uint64_t v562 = v554;
          goto LABEL_2091;
        case 0x154:
          appendStringInfoString((uint64_t)&__s1, "ALTER SUBSCRIPTION ");
          v404 = quote_identifier(*(unsigned char **)(v18 + 8));
          appendStringInfoString((uint64_t)&__s1, v404);
          appendStringInfoChar((uint64_t)&__s1, 32);
          switch(*(_DWORD *)(v18 + 4))
          {
            case 0:
              appendStringInfoString((uint64_t)&__s1, "SET ");
              deparseDefinition(&__s1, *(void *)(v18 + 32));
              goto LABEL_2092;
            case 1:
              appendStringInfoString((uint64_t)&__s1, "CONNECTION ");
              deparseStringLiteral((uint64_t)&__s1, *(char **)(v18 + 16));
              goto LABEL_1308;
            case 2:
              appendStringInfoString((uint64_t)&__s1, "SET PUBLICATION ");
              uint64_t v662 = *(void *)(v18 + 24);
              if (v662 && *(int *)(v662 + 4) >= 1)
              {
                uint64_t v663 = 8;
                uint64_t v664 = 0;
                do
                {
                  uint64_t v665 = *(void *)(v662 + 16);
                  v666 = quote_identifier(*(unsigned char **)(*(void *)(v665 + 8 * v664) + 8));
                  appendStringInfoString((uint64_t)&__s1, v666);
                  if (v665 + v663) {
                    BOOL v667 = v665 + v663 >= (unint64_t)(*(void *)(*(void *)(v19 + 24) + 16)
                  }
                                                           + 8 * *(int *)(*(void *)(v19 + 24) + 4));
                  else {
                    BOOL v667 = 1;
                  }
                  if (!v667) {
                    appendStringInfoString((uint64_t)&__s1, ", ");
                  }
                  ++v664;
                  v663 += 8;
                }
                while (v664 < *(int *)(v662 + 4));
              }
              appendStringInfoChar((uint64_t)&__s1, 32);
              goto LABEL_1103;
            case 3:
              appendStringInfoString((uint64_t)&__s1, "REFRESH PUBLICATION ");
LABEL_1103:
              uint64_t v670 = *(void *)(v19 + 32);
              if (v670 && *(int *)(v670 + 4) >= 1)
              {
                appendStringInfoString((uint64_t)&__s1, "WITH ");
                deparseDefinition(&__s1, v670);
              }
              goto LABEL_2092;
            case 4:
              int v668 = *(_DWORD *)(*(void *)(**(void **)(*(void *)(v18 + 32) + 16) + 24) + 8);
              if (v668)
              {
                if (v668 != 1) {
                  goto LABEL_2092;
                }
                v669 = " ENABLE ";
              }
              else
              {
                v669 = " DISABLE ";
              }
              appendStringInfoString((uint64_t)&__s1, v669);
              break;
            default:
              goto LABEL_2092;
          }
          goto LABEL_2092;
        case 0x155:
          uint64_t v97 = "DROP SUBSCRIPTION ";
LABEL_628:
          appendStringInfoString((uint64_t)&__s1, v97);
          if (*(unsigned char *)(v18 + 16)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          long long v27 = *(char **)(v18 + 8);
          goto LABEL_2104;
        case 0x156:
          appendStringInfoString((uint64_t)&__s1, "CREATE STATISTICS ");
          if (*(unsigned char *)(v18 + 48)) {
            appendStringInfoString((uint64_t)&__s1, "IF NOT EXISTS ");
          }
          uint64_t v31 = *(void *)(v18 + 8);
          if (v31 && *(int *)(v31 + 4) >= 1)
          {
            uint64_t v32 = 8;
            uint64_t v33 = 0;
            do
            {
              uint64_t v34 = *(void *)(v31 + 16);
              long long v35 = quote_identifier(*(unsigned char **)(*(void *)(v34 + 8 * v33) + 8));
              appendStringInfoString((uint64_t)&__s1, v35);
              uint64_t v36 = *(int *)(v31 + 4);
              if (v34 + v32) {
                BOOL v37 = v34 + v32 >= (unint64_t)(*(void *)(v31 + 16) + 8 * v36);
              }
              else {
                BOOL v37 = 1;
              }
              if (!v37)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v36 = *(int *)(v31 + 4);
              }
              ++v33;
              v32 += 8;
            }
            while (v33 < v36);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          uint64_t v38 = *(void *)(v19 + 16);
          if (v38 && *(int *)(v38 + 4) >= 1)
          {
            appendStringInfoChar((uint64_t)&__s1, 40);
            uint64_t v39 = *(void *)(v19 + 16);
            if (v39 && *(int *)(v39 + 4) >= 1)
            {
              uint64_t v40 = 8;
              uint64_t v41 = 0;
              do
              {
                uint64_t v42 = *(void *)(v39 + 16);
                uint64_t v43 = quote_identifier(*(unsigned char **)(*(void *)(v42 + 8 * v41) + 8));
                appendStringInfoString((uint64_t)&__s1, v43);
                uint64_t v44 = *(int *)(v39 + 4);
                if (v42 + v40) {
                  BOOL v45 = v42 + v40 >= (unint64_t)(*(void *)(v39 + 16) + 8 * v44);
                }
                else {
                  BOOL v45 = 1;
                }
                if (!v45)
                {
                  appendStringInfoString((uint64_t)&__s1, ", ");
                  uint64_t v44 = *(int *)(v39 + 4);
                }
                ++v41;
                v40 += 8;
              }
              while (v41 < v44);
            }
            appendStringInfoString((uint64_t)&__s1, ") ");
          }
          appendStringInfoString((uint64_t)&__s1, "ON ");
          uint64_t v514 = *(void *)(v19 + 24);
          if (v514 && *(int *)(v514 + 4) >= 1)
          {
            uint64_t v515 = 8;
            uint64_t v516 = 0;
            do
            {
              uint64_t v517 = *(void *)(v514 + 16);
              deparseExpr(&__s1, *(int **)(v517 + 8 * v516), v508, v509, v510, v511, v512, v513);
              uint64_t v518 = *(int *)(v514 + 4);
              if (v517 + v515) {
                BOOL v519 = v517 + v515 >= (unint64_t)(*(void *)(v514 + 16) + 8 * v518);
              }
              else {
                BOOL v519 = 1;
              }
              if (!v519)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v518 = *(int *)(v514 + 4);
              }
              ++v516;
              v515 += 8;
            }
            while (v516 < v518);
          }
          appendStringInfoString((uint64_t)&__s1, " FROM ");
          uint64_t v526 = *(void *)(v19 + 32);
          if (v526 && *(int *)(v526 + 4) >= 1)
          {
            uint64_t v527 = 8;
            uint64_t v528 = 0;
            do
            {
              uint64_t v529 = *(void *)(v526 + 16);
              deparseTableRef(&__s1, *(void *)(v529 + 8 * v528), v520, v521, v522, v523, v524, v525);
              uint64_t v530 = *(int *)(v526 + 4);
              if (v529 + v527) {
                BOOL v531 = v529 + v527 >= (unint64_t)(*(void *)(v526 + 16) + 8 * v530);
              }
              else {
                BOOL v531 = 1;
              }
              if (!v531)
              {
                appendStringInfoString((uint64_t)&__s1, ", ");
                uint64_t v530 = *(int *)(v526 + 4);
              }
              ++v528;
              v527 += 8;
            }
            while (v528 < v530);
          }
          goto LABEL_2105;
        case 0x157:
          appendStringInfoString((uint64_t)&__s1, "ALTER COLLATION ");
          uint64_t v20 = *(void *)(v18 + 8);
          if (v20 && *(int *)(v20 + 4) >= 1)
          {
            uint64_t v21 = 8;
            uint64_t v22 = 0;
            do
            {
              uint64_t v23 = *(void *)(v20 + 16);
              long long v24 = quote_identifier(*(unsigned char **)(*(void *)(v23 + 8 * v22) + 8));
              appendStringInfoString((uint64_t)&__s1, v24);
              uint64_t v25 = *(int *)(v20 + 4);
              if (v23 + v21) {
                BOOL v26 = v23 + v21 >= (unint64_t)(*(void *)(v20 + 16) + 8 * v25);
              }
              else {
                BOOL v26 = 1;
              }
              if (!v26)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v25 = *(int *)(v20 + 4);
              }
              ++v22;
              v21 += 8;
            }
            while (v22 < v25);
          }
          long long v27 = " REFRESH VERSION";
          goto LABEL_2104;
        case 0x158:
          appendStringInfoString((uint64_t)&__s1, "CALL ");
          deparseFuncCall((uint64_t)&__s1, *(void *)(v18 + 8));
          goto LABEL_2105;
        case 0x159:
          appendStringInfoString((uint64_t)&__s1, "ALTER STATISTICS ");
          if (*(unsigned char *)(v18 + 20)) {
            appendStringInfoString((uint64_t)&__s1, "IF EXISTS ");
          }
          uint64_t v74 = *(void *)(v18 + 8);
          if (v74 && *(int *)(v74 + 4) >= 1)
          {
            uint64_t v75 = 8;
            uint64_t v76 = 0;
            do
            {
              uint64_t v77 = *(void *)(v74 + 16);
              uint64_t v78 = quote_identifier(*(unsigned char **)(*(void *)(v77 + 8 * v76) + 8));
              appendStringInfoString((uint64_t)&__s1, v78);
              uint64_t v79 = *(int *)(v74 + 4);
              if (v77 + v75) {
                BOOL v80 = v77 + v75 >= (unint64_t)(*(void *)(v74 + 16) + 8 * v79);
              }
              else {
                BOOL v80 = 1;
              }
              if (!v80)
              {
                appendStringInfoChar((uint64_t)&__s1, 46);
                uint64_t v79 = *(int *)(v74 + 4);
              }
              ++v76;
              v75 += 8;
            }
            while (v76 < v79);
          }
          appendStringInfoChar((uint64_t)&__s1, 32);
          appendStringInfo((uint64_t)&__s1, "SET STATISTICS %d", v81, v82, v83, v84, v85, v86, *(unsigned int *)(v19 + 16));
          goto LABEL_2105;
        default:
          pg_query_deparse_protobuf_cold_2();
      }
    }
  }
  *uint64_t v7 = v6;
  *uint64_t v10 = v9;
  *(void *)CurrentMemoryContext() = enter_memory_context;
  uint64_t v11 = CopyErrorData();
  uint64_t v12 = malloc_type_malloc(0x28uLL, 0x1010040E871EB1AuLL);
  *uint64_t v12 = strdup(*(const char **)(v11 + 64));
  v12[2] = strdup(*(const char **)(v11 + 16));
  v12[1] = strdup(*(const char **)(v11 + 32));
  v12[4] = 0;
  *((_DWORD *)v12 + 6) = *(_DWORD *)(v11 + 24);
  *((_DWORD *)v12 + 7) = *(_DWORD *)(v11 + 160);
  FlushErrorState();
  uint64_t v13 = 0;
LABEL_2112:
  *uint64_t v7 = v6;
  *uint64_t v10 = v9;
  pg_query_exit_memory_context();
  return v13;
}

void pg_query_free_deparse_result(void *a1, uint64_t a2)
{
  if (a2) {
    pg_query_free_error(a2);
  }

  free(a1);
}

uint64_t deparseCreateTableAsStmt(_DWORD *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  int v4 = *(char *)(*(void *)(*(void *)(a2 + 16) + 8) + 33);
  if (v4 == 117)
  {
    uint64_t v5 = "UNLOGGED ";
  }
  else
  {
    if (v4 != 116) {
      goto LABEL_6;
    }
    uint64_t v5 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_6:
  int v6 = *(_DWORD *)(a2 + 24);
  if (v6 == 39)
  {
    uint64_t v7 = "TABLE ";
  }
  else
  {
    if (v6 != 23) {
      goto LABEL_11;
    }
    uint64_t v7 = "MATERIALIZED VIEW ";
  }
  appendStringInfoString((uint64_t)a1, v7);
LABEL_11:
  if (*(unsigned char *)(a2 + 29)) {
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  }
  deparseIntoClause(a1, *(void *)(a2 + 16));
  appendStringInfoChar((uint64_t)a1, 32);
  appendStringInfoString((uint64_t)a1, "AS ");
  uint64_t v8 = *(_DWORD **)(a2 + 8);
  if (*v8 != 295)
  {
    deparseSelectStmt(a1, (uint64_t)v8);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
    if (!*(unsigned char *)(*(void *)(a2 + 16) + 64)) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  deparseExecuteStmt(a1, (uint64_t)v8);
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(unsigned char *)(*(void *)(a2 + 16) + 64)) {
LABEL_17:
  }
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "WITH NO DATA ");
LABEL_18:
  int v10 = a1[2];
  BOOL v11 = __OFSUB__(v10, 1);
  uint64_t v12 = (v10 - 1);
  if ((int)v12 < 0 == v11)
  {
    uint64_t v13 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v12) == 32)
    {
      a1[2] = v12;
      *(unsigned char *)(v13 + v12) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateSeqStmt(_DWORD *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  int v4 = *(char *)(*(void *)(a2 + 8) + 33);
  if (v4 == 117)
  {
    uint64_t v5 = "UNLOGGED ";
  }
  else
  {
    if (v4 != 116) {
      goto LABEL_6;
    }
    uint64_t v5 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_6:
  appendStringInfoString((uint64_t)a1, "SEQUENCE ");
  if (*(unsigned char *)(a2 + 29)) {
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  }
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 8), 0);
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    uint64_t v8 = 0;
    do
    {
      deparseSeqOptElem(a1, *(void *)(*(void *)(v7 + 16) + 8 * v8));
      uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
      ++v8;
    }
    while (v8 < *(int *)(v7 + 4));
  }
  int v9 = a1[2];
  BOOL v10 = __OFSUB__(v9, 1);
  uint64_t v11 = (v9 - 1);
  if ((int)v11 < 0 == v10)
  {
    uint64_t v12 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v11) == 32)
    {
      a1[2] = v11;
      *(unsigned char *)(v12 + v11) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateStmt(_DWORD *a1, uint64_t a2, int a3)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (a3) {
    appendStringInfoString((uint64_t)a1, "FOREIGN ");
  }
  int v6 = *(char *)(*(void *)(a2 + 8) + 33);
  if (v6 == 117)
  {
    uint64_t v7 = "UNLOGGED ";
  }
  else
  {
    if (v6 != 116) {
      goto LABEL_8;
    }
    uint64_t v7 = "TEMPORARY ";
  }
  appendStringInfoString((uint64_t)a1, v7);
LABEL_8:
  appendStringInfoString((uint64_t)a1, "TABLE ");
  if (*(unsigned char *)(a2 + 96)) {
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  }
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 8), 0);
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(void *)(a2 + 48))
  {
    appendStringInfoString((uint64_t)a1, "OF ");
    deparseTypeName(a1, *(void *)(a2 + 48));
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "PARTITION OF ");
    deparseRangeVar((uint64_t)a1, **(void **)(*(void *)(a2 + 24) + 16), 0);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (v9 && *(int *)(v9 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v10 = *(void *)(a2 + 16);
    if (v10)
    {
      if (*(int *)(v10 + 4) >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 8;
        while (1)
        {
          uint64_t v13 = *(void *)(v10 + 16);
          uint64_t v14 = *(int **)(v13 + 8 * v11);
          int v15 = *v14;
          if (*v14 != 381)
          {
            if (v15 == 369)
            {
              deparseConstraint(a1, *(void *)(v13 + 8 * v11));
            }
            else if (v15 == 367)
            {
              deparseColumnDef((uint64_t)a1, *(void **)(v13 + 8 * v11));
            }
            goto LABEL_47;
          }
          appendStringInfoString((uint64_t)a1, "LIKE ");
          deparseRangeVar((uint64_t)a1, *((void *)v14 + 1), 0);
          appendStringInfoChar((uint64_t)a1, 32);
          int v16 = v14[4];
          uint64_t v17 = "INCLUDING ALL ";
          if (v16 == 0x7FFFFFFF) {
            goto LABEL_44;
          }
          if (v16)
          {
            appendStringInfoString((uint64_t)a1, "INCLUDING COMMENTS ");
            int v16 = v14[4];
            if ((v16 & 2) == 0)
            {
LABEL_27:
              if ((v16 & 4) == 0) {
                goto LABEL_28;
              }
              goto LABEL_39;
            }
          }
          else if ((v16 & 2) == 0)
          {
            goto LABEL_27;
          }
          appendStringInfoString((uint64_t)a1, "INCLUDING CONSTRAINTS ");
          int v16 = v14[4];
          if ((v16 & 4) == 0)
          {
LABEL_28:
            if ((v16 & 0x10) == 0) {
              goto LABEL_29;
            }
            goto LABEL_40;
          }
LABEL_39:
          appendStringInfoString((uint64_t)a1, "INCLUDING DEFAULTS ");
          int v16 = v14[4];
          if ((v16 & 0x10) == 0)
          {
LABEL_29:
            if ((v16 & 8) == 0) {
              goto LABEL_30;
            }
            goto LABEL_41;
          }
LABEL_40:
          appendStringInfoString((uint64_t)a1, "INCLUDING IDENTITY ");
          int v16 = v14[4];
          if ((v16 & 8) == 0)
          {
LABEL_30:
            if ((v16 & 0x20) == 0) {
              goto LABEL_31;
            }
            goto LABEL_42;
          }
LABEL_41:
          appendStringInfoString((uint64_t)a1, "INCLUDING GENERATED ");
          int v16 = v14[4];
          if ((v16 & 0x20) == 0)
          {
LABEL_31:
            if ((v16 & 0x40) == 0) {
              goto LABEL_32;
            }
            goto LABEL_43;
          }
LABEL_42:
          appendStringInfoString((uint64_t)a1, "INCLUDING INDEXES ");
          int v16 = v14[4];
          if ((v16 & 0x40) == 0)
          {
LABEL_32:
            uint64_t v17 = "INCLUDING STORAGE ";
            if ((v16 & 0x80) == 0) {
              goto LABEL_33;
            }
            goto LABEL_44;
          }
LABEL_43:
          appendStringInfoString((uint64_t)a1, "INCLUDING STATISTICS ");
          uint64_t v17 = "INCLUDING STORAGE ";
          if ((v14[4] & 0x80) == 0)
          {
LABEL_33:
            int v18 = a1[2];
            BOOL v19 = __OFSUB__(v18, 1);
            uint64_t v20 = (v18 - 1);
            if ((int)v20 < 0 == v19) {
              goto LABEL_45;
            }
            goto LABEL_47;
          }
LABEL_44:
          appendStringInfoString((uint64_t)a1, v17);
          int v21 = a1[2];
          BOOL v19 = __OFSUB__(v21, 1);
          uint64_t v20 = (v21 - 1);
          if ((int)v20 < 0 == v19)
          {
LABEL_45:
            uint64_t v22 = *(void *)a1;
            if (*(unsigned char *)(*(void *)a1 + v20) == 32)
            {
              a1[2] = v20;
              *(unsigned char *)(v22 + v20) = 0;
            }
          }
LABEL_47:
          if (v13 + v12) {
            BOOL v23 = v13 + v12 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
          }
                                                + 8 * *(int *)(*(void *)(a2 + 16) + 4));
          else {
            BOOL v23 = 1;
          }
          if (!v23) {
            appendStringInfoString((uint64_t)a1, ", ");
          }
          ++v11;
          v12 += 8;
          if (v11 >= *(int *)(v10 + 4)) {
            goto LABEL_56;
          }
        }
      }
      uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
      uint64_t v24 = *(void *)(a2 + 32);
      if (!v24) {
        goto LABEL_97;
      }
LABEL_57:
      deparsePartitionBoundSpec(a1, v24);
      uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
      goto LABEL_58;
    }
LABEL_56:
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
    uint64_t v24 = *(void *)(a2 + 32);
    if (v24) {
      goto LABEL_57;
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a2 + 32);
    if (v24) {
      goto LABEL_57;
    }
    if (!*(void *)(a2 + 48))
    {
      uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "() ");
      uint64_t v24 = *(void *)(a2 + 32);
      if (v24) {
        goto LABEL_57;
      }
    }
  }
LABEL_97:
  uint64_t v55 = *(void *)(a2 + 24);
  if (v55 && *(int *)(v55 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "INHERITS (");
    if (*(int *)(v55 + 4) >= 1)
    {
      uint64_t v56 = 0;
      uint64_t v57 = 8;
      do
      {
        uint64_t v58 = *(void *)(v55 + 16);
        deparseRangeVar((uint64_t)a1, *(void *)(v58 + 8 * v56), 0);
        uint64_t v59 = *(int *)(v55 + 4);
        if (v58 + v57) {
          BOOL v60 = v58 + v57 >= (unint64_t)(*(void *)(v55 + 16) + 8 * v59);
        }
        else {
          BOOL v60 = 1;
        }
        if (!v60)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v59 = *(int *)(v55 + 4);
        }
        ++v56;
        v57 += 8;
      }
      while (v56 < v59);
    }
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  }
LABEL_58:
  uint64_t v25 = *(void *)(a2 + 40);
  if (v25)
  {
    appendStringInfoString((uint64_t)a1, "PARTITION BY ");
    appendStringInfoString((uint64_t)a1, *(char **)(v25 + 8));
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v26 = *(void *)(v25 + 16);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = *(void *)(v26 + 16) + 8 * v27;
        uint64_t v29 = *(void *)v28;
        long long v30 = *(unsigned char **)(*(void *)v28 + 8);
        if (v30)
        {
          uint64_t v31 = quote_identifier(v30);
          appendStringInfoString((uint64_t)a1, v31);
          appendStringInfoChar((uint64_t)a1, 32);
        }
        else if (*(void *)(v29 + 16))
        {
          appendStringInfoChar((uint64_t)a1, 40);
          deparseExpr(a1, *(int **)(v29 + 16), v32, v33, v34, v35, v36, v37);
          appendStringInfoString((uint64_t)a1, ") ");
        }
        deparseOptCollate((uint64_t)a1, *(void *)(v29 + 24));
        uint64_t v38 = *(void *)(v29 + 32);
        if (v38 && *(int *)(v38 + 4) >= 1)
        {
          uint64_t v39 = 0;
          uint64_t v40 = 8;
          do
          {
            uint64_t v41 = *(void *)(v38 + 16);
            uint64_t v42 = quote_identifier(*(unsigned char **)(*(void *)(v41 + 8 * v39) + 8));
            appendStringInfoString((uint64_t)a1, v42);
            uint64_t v43 = *(int *)(v38 + 4);
            if (v41 + v40) {
              BOOL v44 = v41 + v40 >= (unint64_t)(*(void *)(v38 + 16) + 8 * v43);
            }
            else {
              BOOL v44 = 1;
            }
            if (!v44)
            {
              appendStringInfoChar((uint64_t)a1, 46);
              uint64_t v43 = *(int *)(v38 + 4);
            }
            ++v39;
            v40 += 8;
          }
          while (v39 < v43);
        }
        int v45 = a1[2];
        BOOL v19 = __OFSUB__(v45, 1);
        uint64_t v46 = (v45 - 1);
        if ((int)v46 < 0 == v19)
        {
          uint64_t v47 = *(void *)a1;
          if (*(unsigned char *)(*(void *)a1 + v46) == 32)
          {
            a1[2] = v46;
            *(unsigned char *)(v47 + v46) = 0;
          }
        }
        if (v28 != -8
          && v28 + 8 < (unint64_t)(*(void *)(*(void *)(v25 + 16) + 16)
                                        + 8 * *(int *)(*(void *)(v25 + 16) + 4)))
        {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v27;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    appendStringInfoChar((uint64_t)a1, 41);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    uint64_t v48 = quote_identifier(*(unsigned char **)(a2 + 88));
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v48);
  }
  uint64_t v49 = *(void *)(a2 + 64);
  if (v49 && *(int *)(v49 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v49);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  unsigned int v50 = *(_DWORD *)(a2 + 72) - 1;
  if (v50 <= 2) {
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, (&off_1E55D8F28)[v50]);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    uint64_t v51 = quote_identifier(*(unsigned char **)(a2 + 80));
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v51);
  }
  int v52 = a1[2];
  BOOL v19 = __OFSUB__(v52, 1);
  uint64_t v53 = (v52 - 1);
  if ((int)v53 < 0 == v19)
  {
    uint64_t v54 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v53) == 32)
    {
      a1[2] = v53;
      *(unsigned char *)(v54 + v53) = 0;
    }
  }
  return result;
}

uint64_t deparseCreateTrigStmt(void *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(unsigned char *)(a2 + 64)) {
    appendStringInfoString((uint64_t)a1, "CONSTRAINT ");
  }
  appendStringInfoString((uint64_t)a1, "TRIGGER ");
  int v4 = quote_identifier(*(unsigned char **)(a2 + 8));
  appendStringInfoString((uint64_t)a1, v4);
  appendStringInfoChar((uint64_t)a1, 32);
  int v5 = *(__int16 *)(a2 + 42);
  if (v5 == 64)
  {
    int v6 = "INSTEAD OF ";
  }
  else if (v5 == 2)
  {
    int v6 = "BEFORE ";
  }
  else
  {
    if (*(_WORD *)(a2 + 42)) {
      goto LABEL_10;
    }
    int v6 = "AFTER ";
  }
  appendStringInfoString((uint64_t)a1, v6);
LABEL_10:
  __int16 v7 = *(_WORD *)(a2 + 44);
  if ((v7 & 4) == 0)
  {
    if ((v7 & 8) == 0)
    {
      if ((v7 & 0x10) == 0)
      {
        LOBYTE(v8) = 1;
        goto LABEL_32;
      }
      goto LABEL_19;
    }
    goto LABEL_16;
  }
  appendStringInfoString((uint64_t)a1, "INSERT ");
  __int16 v9 = *(_WORD *)(a2 + 44);
  if ((v9 & 8) != 0)
  {
    appendStringInfoString((uint64_t)a1, "OR ");
LABEL_16:
    appendStringInfoString((uint64_t)a1, "DELETE ");
    __int16 v9 = *(_WORD *)(a2 + 44);
  }
  if ((v9 & 0x10) == 0) {
    goto LABEL_31;
  }
  appendStringInfoString((uint64_t)a1, "OR ");
LABEL_19:
  appendStringInfoString((uint64_t)a1, "UPDATE ");
  uint64_t v8 = *(void *)(a2 + 48);
  if (!v8) {
    goto LABEL_32;
  }
  if (*(int *)(v8 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "OF ");
    uint64_t v10 = *(void *)(a2 + 48);
    if (v10 && *(int *)(v10 + 4) >= 1)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 8;
      do
      {
        uint64_t v13 = *(void *)(v10 + 16);
        uint64_t v14 = quote_identifier(*(unsigned char **)(*(void *)(v13 + 8 * v11) + 8));
        appendStringInfoString((uint64_t)a1, v14);
        uint64_t v15 = *(int *)(v10 + 4);
        if (v13 + v12) {
          BOOL v16 = v13 + v12 >= (unint64_t)(*(void *)(v10 + 16) + 8 * v15);
        }
        else {
          BOOL v16 = 1;
        }
        if (!v16)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v15 = *(int *)(v10 + 4);
        }
        ++v11;
        v12 += 8;
      }
      while (v11 < v15);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
LABEL_31:
  LOBYTE(v8) = 0;
LABEL_32:
  if ((*(_WORD *)(a2 + 44) & 0x20) != 0)
  {
    if ((v8 & 1) == 0) {
      appendStringInfoString((uint64_t)a1, "OR ");
    }
    appendStringInfoString((uint64_t)a1, "TRUNCATE ");
  }
  appendStringInfoString((uint64_t)a1, "ON ");
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 16), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  if (*(void *)(a2 + 72))
  {
    appendStringInfoString((uint64_t)a1, "REFERENCING ");
    uint64_t v17 = *(void *)(a2 + 72);
    if (v17)
    {
      if (*(int *)(v17 + 4) >= 1)
      {
        uint64_t v18 = 0;
        do
        {
          uint64_t v19 = *(void *)(*(void *)(v17 + 16) + 8 * v18);
          if (*(unsigned char *)(v19 + 16)) {
            uint64_t v20 = "NEW ";
          }
          else {
            uint64_t v20 = "OLD ";
          }
          appendStringInfoString((uint64_t)a1, v20);
          if (*(unsigned char *)(v19 + 17)) {
            int v21 = "TABLE ";
          }
          else {
            int v21 = "ROW ";
          }
          appendStringInfoString((uint64_t)a1, v21);
          uint64_t v22 = quote_identifier(*(unsigned char **)(v19 + 8));
          appendStringInfoString((uint64_t)a1, v22);
          appendStringInfoChar((uint64_t)a1, 32);
          ++v18;
        }
        while (v18 < *(int *)(v17 + 4));
      }
    }
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    deparseRangeVar((uint64_t)a1, *(void *)(a2 + 88), 0);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(unsigned char *)(a2 + 80)) {
    appendStringInfoString((uint64_t)a1, "DEFERRABLE ");
  }
  if (*(unsigned char *)(a2 + 81)) {
    appendStringInfoString((uint64_t)a1, "INITIALLY DEFERRED ");
  }
  if (*(unsigned char *)(a2 + 40)) {
    appendStringInfoString((uint64_t)a1, "FOR EACH ROW ");
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfoString((uint64_t)a1, "WHEN (");
    deparseExpr(a1, *(int **)(a2 + 56), v23, v24, v25, v26, v27, v28);
    appendStringInfoString((uint64_t)a1, ") ");
  }
  appendStringInfoString((uint64_t)a1, "EXECUTE FUNCTION ");
  uint64_t v29 = *(void *)(a2 + 24);
  if (v29 && *(int *)(v29 + 4) >= 1)
  {
    uint64_t v30 = 0;
    uint64_t v31 = 8;
    do
    {
      uint64_t v32 = *(void *)(v29 + 16);
      uint64_t v33 = quote_identifier(*(unsigned char **)(*(void *)(v32 + 8 * v30) + 8));
      appendStringInfoString((uint64_t)a1, v33);
      uint64_t v34 = *(int *)(v29 + 4);
      if (v32 + v31) {
        BOOL v35 = v32 + v31 >= (unint64_t)(*(void *)(v29 + 16) + 8 * v34);
      }
      else {
        BOOL v35 = 1;
      }
      if (!v35)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        uint64_t v34 = *(int *)(v29 + 4);
      }
      ++v30;
      v31 += 8;
    }
    while (v30 < v34);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  uint64_t v36 = *(void *)(a2 + 32);
  if (v36 && *(int *)(v36 + 4) >= 1)
  {
    uint64_t v37 = 0;
    uint64_t v38 = 8;
    do
    {
      uint64_t v39 = *(void *)(v36 + 16);
      deparseStringLiteral((uint64_t)a1, *(char **)(*(void *)(v39 + 8 * v37) + 8));
      if (v39 + v38) {
        BOOL v40 = v39 + v38 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
      }
                                            + 8 * *(int *)(*(void *)(a2 + 32) + 4));
      else {
        BOOL v40 = 1;
      }
      if (!v40) {
        appendStringInfoString((uint64_t)a1, ", ");
      }
      ++v37;
      v38 += 8;
    }
    while (v37 < *(int *)(v36 + 4));
  }

  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseDeclareCursorStmt(_DWORD *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "DECLARE ");
  int v4 = quote_identifier(*(unsigned char **)(a2 + 8));
  appendStringInfoString((uint64_t)a1, v4);
  appendStringInfoChar((uint64_t)a1, 32);
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5)
  {
    appendStringInfoString((uint64_t)a1, "BINARY ");
    int v5 = *(_DWORD *)(a2 + 16);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  appendStringInfoString((uint64_t)a1, "SCROLL ");
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  appendStringInfoString((uint64_t)a1, "NO SCROLL ");
  if ((*(_DWORD *)(a2 + 16) & 8) == 0)
  {
LABEL_5:
    appendStringInfoString((uint64_t)a1, "CURSOR ");
    if ((*(unsigned char *)(a2 + 16) & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_13:
  appendStringInfoString((uint64_t)a1, "INSENSITIVE ");
  appendStringInfoString((uint64_t)a1, "CURSOR ");
  if ((*(unsigned char *)(a2 + 16) & 0x10) != 0) {
LABEL_6:
  }
    appendStringInfoString((uint64_t)a1, "WITH HOLD ");
LABEL_7:
  appendStringInfoString((uint64_t)a1, "FOR ");
  uint64_t v6 = *(void *)(a2 + 24);

  return deparseSelectStmt(a1, v6);
}

uint64_t deparseDeleteStmt(_DWORD *a1, uint64_t *a2)
{
  if (a2[5])
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "DELETE FROM ");
  deparseRangeVar((uint64_t)a1, a2[1], 0);
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (a2[2])
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    uint64_t v11 = a2[2];
    if (v11 && *(int *)(v11 + 4) >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8;
      do
      {
        uint64_t v14 = *(void *)(v11 + 16);
        deparseTableRef(a1, *(void *)(v14 + 8 * v12), v5, v6, v7, v8, v9, v10);
        uint64_t v15 = *(int *)(v11 + 4);
        if (v14 + v13) {
          BOOL v16 = v14 + v13 >= (unint64_t)(*(void *)(v11 + 16) + 8 * v15);
        }
        else {
          BOOL v16 = 1;
        }
        if (!v16)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v15 = *(int *)(v11 + 4);
        }
        ++v12;
        v13 += 8;
      }
      while (v12 < v15);
    }
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v17 = a2[3];
  if (v17)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v17);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v18 = a2[4];
  if (v18 && *(int *)(v18 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    uint64_t result = deparseTargetList((uint64_t)a1, a2[4]);
  }
  int v19 = a1[2];
  BOOL v20 = __OFSUB__(v19, 1);
  uint64_t v21 = (v19 - 1);
  if ((int)v21 < 0 == v20)
  {
    uint64_t v22 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v21) == 32)
    {
      a1[2] = v21;
      *(unsigned char *)(v22 + v21) = 0;
    }
  }
  return result;
}

void *deparseExecuteStmt(void *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "EXECUTE ");
  int v4 = quote_identifier(*(unsigned char **)(a2 + 8));
  uint64_t result = appendStringInfoString((uint64_t)a1, v4);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v13 = *(void *)(a2 + 16);
    if (v13 && *(int *)(v13 + 4) >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 8;
      do
      {
        uint64_t v16 = *(void *)(v13 + 16);
        deparseExpr(a1, *(int **)(v16 + 8 * v14), v7, v8, v9, v10, v11, v12);
        uint64_t v17 = *(int *)(v13 + 4);
        if (v16 + v15) {
          BOOL v18 = v16 + v15 >= (unint64_t)(*(void *)(v13 + 16) + 8 * v17);
        }
        else {
          BOOL v18 = 1;
        }
        if (!v18)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v17 = *(int *)(v13 + 4);
        }
        ++v14;
        v15 += 8;
      }
      while (v14 < v17);
    }
    return (void *)appendStringInfoChar((uint64_t)a1, 41);
  }
  return result;
}

uint64_t deparseGrantStmt(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 4)) {
    int v4 = "GRANT ";
  }
  else {
    int v4 = "REVOKE ";
  }
  appendStringInfoString(a1, v4);
  if (!*(unsigned char *)(a2 + 4) && *(unsigned char *)(a2 + 40)) {
    appendStringInfoString(a1, "GRANT OPTION FOR ");
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 8;
    do
    {
      uint64_t v8 = *(void *)(v5 + 16);
      deparseAccessPriv(a1, *(void *)(v8 + 8 * v6));
      if (v8 + v7) {
        BOOL v9 = v8 + v7 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
      }
                                         + 8 * *(int *)(*(void *)(a2 + 24) + 4));
      else {
        BOOL v9 = 1;
      }
      if (!v9) {
        appendStringInfoString(a1, ", ");
      }
      ++v6;
      v7 += 8;
    }
    while (v6 < *(int *)(v5 + 4));
    appendStringInfoChar(a1, 32);
  }
  else
  {
    appendStringInfoString(a1, "ALL ");
  }
  appendStringInfoString(a1, "ON ");
  int v11 = *(_DWORD *)(a2 + 8);
  int v10 = *(_DWORD *)(a2 + 12);
  if (v11 == 2)
  {
    switch(v10)
    {
      case 19:
        uint64_t v15 = "FUNCTIONS";
        goto LABEL_47;
      case 34:
        uint64_t v15 = "SCHEMAS";
        goto LABEL_47;
      case 35:
        uint64_t v15 = "SEQUENCES";
        goto LABEL_47;
      case 39:
        uint64_t v15 = "TABLES";
        goto LABEL_47;
      case 47:
        uint64_t v15 = "TYPES";
LABEL_47:
        appendStringInfoString(a1, v15);
        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a2 + 16);
    if (v11 == 1)
    {
      switch(v10)
      {
        case 19:
          appendStringInfoString(a1, "ALL FUNCTIONS IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v16 = 0;
            uint64_t v17 = 8;
            do
            {
              uint64_t v18 = *(void *)(v12 + 16);
              int v19 = quote_identifier(*(unsigned char **)(*(void *)(v18 + 8 * v16) + 8));
              appendStringInfoString(a1, v19);
              uint64_t v20 = *(int *)(v12 + 4);
              if (v18 + v17) {
                BOOL v21 = v18 + v17 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v20);
              }
              else {
                BOOL v21 = 1;
              }
              if (!v21)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v20 = *(int *)(v12 + 4);
              }
              ++v16;
              v17 += 8;
            }
            while (v16 < v20);
          }
          break;
        case 28:
          appendStringInfoString(a1, "ALL PROCEDURES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v40 = 0;
            uint64_t v41 = 8;
            do
            {
              uint64_t v42 = *(void *)(v12 + 16);
              uint64_t v43 = quote_identifier(*(unsigned char **)(*(void *)(v42 + 8 * v40) + 8));
              appendStringInfoString(a1, v43);
              uint64_t v44 = *(int *)(v12 + 4);
              if (v42 + v41) {
                BOOL v45 = v42 + v41 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v44);
              }
              else {
                BOOL v45 = 1;
              }
              if (!v45)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v44 = *(int *)(v12 + 4);
              }
              ++v40;
              v41 += 8;
            }
            while (v40 < v44);
          }
          break;
        case 32:
          appendStringInfoString(a1, "ALL ROUTINES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v46 = 0;
            uint64_t v47 = 8;
            do
            {
              uint64_t v48 = *(void *)(v12 + 16);
              uint64_t v49 = quote_identifier(*(unsigned char **)(*(void *)(v48 + 8 * v46) + 8));
              appendStringInfoString(a1, v49);
              uint64_t v50 = *(int *)(v12 + 4);
              if (v48 + v47) {
                BOOL v51 = v48 + v47 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v50);
              }
              else {
                BOOL v51 = 1;
              }
              if (!v51)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v50 = *(int *)(v12 + 4);
              }
              ++v46;
              v47 += 8;
            }
            while (v46 < v50);
          }
          break;
        case 35:
          appendStringInfoString(a1, "ALL SEQUENCES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v52 = 0;
            uint64_t v53 = 8;
            do
            {
              uint64_t v54 = *(void *)(v12 + 16);
              uint64_t v55 = quote_identifier(*(unsigned char **)(*(void *)(v54 + 8 * v52) + 8));
              appendStringInfoString(a1, v55);
              uint64_t v56 = *(int *)(v12 + 4);
              if (v54 + v53) {
                BOOL v57 = v54 + v53 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v56);
              }
              else {
                BOOL v57 = 1;
              }
              if (!v57)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v56 = *(int *)(v12 + 4);
              }
              ++v52;
              v53 += 8;
            }
            while (v52 < v56);
          }
          break;
        case 39:
          appendStringInfoString(a1, "ALL TABLES IN SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v58 = 0;
            uint64_t v59 = 8;
            do
            {
              uint64_t v60 = *(void *)(v12 + 16);
              BOOL v61 = quote_identifier(*(unsigned char **)(*(void *)(v60 + 8 * v58) + 8));
              appendStringInfoString(a1, v61);
              uint64_t v62 = *(int *)(v12 + 4);
              if (v60 + v59) {
                BOOL v63 = v60 + v59 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v62);
              }
              else {
                BOOL v63 = 1;
              }
              if (!v63)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v62 = *(int *)(v12 + 4);
              }
              ++v58;
              v59 += 8;
            }
            while (v58 < v62);
          }
          break;
        default:
          break;
      }
    }
    else if (!v11)
    {
      switch(v10)
      {
        case 9:
          appendStringInfoString(a1, "DATABASE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v13 = 0;
            uint64_t v14 = 8;
            do
            {
              uint64_t v22 = *(void *)(v12 + 16);
              uint64_t v23 = quote_identifier(*(unsigned char **)(*(void *)(v22 + 8 * v13) + 8));
              appendStringInfoString(a1, v23);
              uint64_t v24 = *(int *)(v12 + 4);
              if (v22 + v14) {
                BOOL v25 = v22 + v14 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v24);
              }
              else {
                BOOL v25 = 1;
              }
              if (!v25)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v24 = *(int *)(v12 + 4);
              }
              ++v13;
              v14 += 8;
            }
            while (v13 < v24);
          }
          break;
        case 12:
          int v64 = "DOMAIN ";
          goto LABEL_216;
        case 16:
          appendStringInfoString(a1, "FOREIGN DATA WRAPPER ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v65 = 0;
            uint64_t v66 = 8;
            do
            {
              uint64_t v67 = *(void *)(v12 + 16);
              uint64_t v68 = quote_identifier(*(unsigned char **)(*(void *)(v67 + 8 * v65) + 8));
              appendStringInfoString(a1, v68);
              uint64_t v69 = *(int *)(v12 + 4);
              if (v67 + v66) {
                BOOL v70 = v67 + v66 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v69);
              }
              else {
                BOOL v70 = 1;
              }
              if (!v70)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v69 = *(int *)(v12 + 4);
              }
              ++v65;
              v66 += 8;
            }
            while (v65 < v69);
          }
          break;
        case 17:
          appendStringInfoString(a1, "FOREIGN SERVER ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v71 = 0;
            uint64_t v72 = 8;
            do
            {
              uint64_t v73 = *(void *)(v12 + 16);
              uint64_t v74 = quote_identifier(*(unsigned char **)(*(void *)(v73 + 8 * v71) + 8));
              appendStringInfoString(a1, v74);
              uint64_t v75 = *(int *)(v12 + 4);
              if (v73 + v72) {
                BOOL v76 = v73 + v72 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v75);
              }
              else {
                BOOL v76 = 1;
              }
              if (!v76)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v75 = *(int *)(v12 + 4);
              }
              ++v71;
              v72 += 8;
            }
            while (v71 < v75);
          }
          break;
        case 19:
          appendStringInfoString(a1, "FUNCTION ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v77 = 0;
            uint64_t v78 = 8;
            do
            {
              uint64_t v79 = *(void *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(void *)(v79 + 8 * v77));
              uint64_t v80 = *(int *)(v12 + 4);
              if (v79 + v78) {
                BOOL v81 = v79 + v78 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v80);
              }
              else {
                BOOL v81 = 1;
              }
              if (!v81)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v80 = *(int *)(v12 + 4);
              }
              ++v77;
              v78 += 8;
            }
            while (v77 < v80);
          }
          break;
        case 21:
          appendStringInfoString(a1, "LANGUAGE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v82 = 0;
            uint64_t v83 = 8;
            do
            {
              uint64_t v84 = *(void *)(v12 + 16);
              uint64_t v85 = quote_identifier(*(unsigned char **)(*(void *)(v84 + 8 * v82) + 8));
              appendStringInfoString(a1, v85);
              uint64_t v86 = *(int *)(v12 + 4);
              if (v84 + v83) {
                BOOL v87 = v84 + v83 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v86);
              }
              else {
                BOOL v87 = 1;
              }
              if (!v87)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v86 = *(int *)(v12 + 4);
              }
              ++v82;
              v83 += 8;
            }
            while (v82 < v86);
          }
          break;
        case 22:
          appendStringInfoString(a1, "LARGE OBJECT ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v94 = 0;
            uint64_t v95 = 8;
            do
            {
              uint64_t v96 = *(void *)(v12 + 16);
              uint64_t v97 = *(void *)(v96 + 8 * v94);
              if (*(_DWORD *)v97 == 222)
              {
                appendStringInfoString(a1, *(char **)(v97 + 8));
              }
              else if (*(_DWORD *)v97 == 221)
              {
                appendStringInfo(a1, "%d", v88, v89, v90, v91, v92, v93, *(unsigned int *)(v97 + 8));
              }
              uint64_t v98 = *(int *)(v12 + 4);
              if (v96 + v95) {
                BOOL v99 = v96 + v95 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v98);
              }
              else {
                BOOL v99 = 1;
              }
              if (!v99)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v98 = *(int *)(v12 + 4);
              }
              ++v94;
              v95 += 8;
            }
            while (v94 < v98);
          }
          break;
        case 28:
          appendStringInfoString(a1, "PROCEDURE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v100 = 0;
            uint64_t v101 = 8;
            do
            {
              uint64_t v102 = *(void *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(void *)(v102 + 8 * v100));
              uint64_t v103 = *(int *)(v12 + 4);
              if (v102 + v101) {
                BOOL v104 = v102 + v101 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v103);
              }
              else {
                BOOL v104 = 1;
              }
              if (!v104)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v103 = *(int *)(v12 + 4);
              }
              ++v100;
              v101 += 8;
            }
            while (v100 < v103);
          }
          break;
        case 32:
          appendStringInfoString(a1, "ROUTINE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v105 = 0;
            uint64_t v106 = 8;
            do
            {
              uint64_t v107 = *(void *)(v12 + 16);
              deparseFunctionWithArgtypes(a1, *(void *)(v107 + 8 * v105));
              uint64_t v108 = *(int *)(v12 + 4);
              if (v107 + v106) {
                BOOL v109 = v107 + v106 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v108);
              }
              else {
                BOOL v109 = 1;
              }
              if (!v109)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v108 = *(int *)(v12 + 4);
              }
              ++v105;
              v106 += 8;
            }
            while (v105 < v108);
          }
          break;
        case 34:
          appendStringInfoString(a1, "SCHEMA ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v110 = 0;
            uint64_t v111 = 8;
            do
            {
              uint64_t v112 = *(void *)(v12 + 16);
              uint64_t v113 = quote_identifier(*(unsigned char **)(*(void *)(v112 + 8 * v110) + 8));
              appendStringInfoString(a1, v113);
              uint64_t v114 = *(int *)(v12 + 4);
              if (v112 + v111) {
                BOOL v115 = v112 + v111 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v114);
              }
              else {
                BOOL v115 = 1;
              }
              if (!v115)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v114 = *(int *)(v12 + 4);
              }
              ++v110;
              v111 += 8;
            }
            while (v110 < v114);
          }
          break;
        case 35:
          appendStringInfoString(a1, "SEQUENCE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v116 = 0;
            uint64_t v117 = 8;
            do
            {
              uint64_t v118 = *(void *)(v12 + 16);
              deparseRangeVar(a1, *(void *)(v118 + 8 * v116), 0);
              uint64_t v119 = *(int *)(v12 + 4);
              if (v118 + v117) {
                BOOL v120 = v118 + v117 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v119);
              }
              else {
                BOOL v120 = 1;
              }
              if (!v120)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v119 = *(int *)(v12 + 4);
              }
              ++v116;
              v117 += 8;
            }
            while (v116 < v119);
          }
          break;
        case 39:
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v121 = 0;
            uint64_t v122 = 8;
            do
            {
              uint64_t v123 = *(void *)(v12 + 16);
              deparseRangeVar(a1, *(void *)(v123 + 8 * v121), 0);
              uint64_t v124 = *(int *)(v12 + 4);
              if (v123 + v122) {
                BOOL v125 = v123 + v122 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v124);
              }
              else {
                BOOL v125 = 1;
              }
              if (!v125)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v124 = *(int *)(v12 + 4);
              }
              ++v121;
              v122 += 8;
            }
            while (v121 < v124);
          }
          break;
        case 40:
          appendStringInfoString(a1, "TABLESPACE ");
          if (v12 && *(int *)(v12 + 4) >= 1)
          {
            uint64_t v126 = 0;
            uint64_t v127 = 8;
            do
            {
              uint64_t v128 = *(void *)(v12 + 16);
              uint64_t v129 = quote_identifier(*(unsigned char **)(*(void *)(v128 + 8 * v126) + 8));
              appendStringInfoString(a1, v129);
              uint64_t v130 = *(int *)(v12 + 4);
              if (v128 + v127) {
                BOOL v131 = v128 + v127 >= (unint64_t)(*(void *)(v12 + 16) + 8 * v130);
              }
              else {
                BOOL v131 = 1;
              }
              if (!v131)
              {
                appendStringInfoString(a1, ", ");
                uint64_t v130 = *(int *)(v12 + 4);
              }
              ++v126;
              v127 += 8;
            }
            while (v126 < v130);
          }
          break;
        case 47:
          int v64 = "TYPE ";
LABEL_216:
          appendStringInfoString(a1, v64);
          deparseAnyNameList(a1, v12);
          break;
        default:
          break;
      }
    }
  }
  appendStringInfoChar(a1, 32);
  if (*(unsigned char *)(a2 + 4)) {
    uint64_t v26 = "TO ";
  }
  else {
    uint64_t v26 = "FROM ";
  }
  uint64_t result = (uint64_t)appendStringInfoString(a1, v26);
  uint64_t v28 = *(void *)(a2 + 32);
  if (v28 && *(int *)(v28 + 4) >= 1)
  {
    uint64_t v29 = 0;
    uint64_t v30 = 8;
    do
    {
      uint64_t v31 = *(void *)(v28 + 16);
      uint64_t v32 = *(void *)(v31 + 8 * v29);
      switch(*(_DWORD *)(v32 + 4))
      {
        case 0:
          uint64_t v33 = quote_identifier(*(unsigned char **)(v32 + 8));
          uint64_t v34 = a1;
          goto LABEL_60;
        case 1:
          uint64_t v34 = a1;
          uint64_t v33 = "CURRENT_USER";
          goto LABEL_60;
        case 2:
          uint64_t v34 = a1;
          uint64_t v33 = "SESSION_USER";
          goto LABEL_60;
        case 3:
          uint64_t v34 = a1;
          uint64_t v33 = "public";
LABEL_60:
          appendStringInfoString(v34, v33);
          break;
        default:
          break;
      }
      if (v31 + v30) {
        BOOL v35 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
      }
                                            + 8 * *(int *)(*(void *)(a2 + 32) + 4));
      else {
        BOOL v35 = 1;
      }
      if (!v35) {
        appendStringInfoChar(a1, 44);
      }
      uint64_t result = appendStringInfoChar(a1, 32);
      ++v29;
      v30 += 8;
    }
    while (v29 < *(int *)(v28 + 4));
  }
  if (*(unsigned char *)(a2 + 4) && *(unsigned char *)(a2 + 40)) {
    uint64_t result = (uint64_t)appendStringInfoString(a1, "WITH GRANT OPTION ");
  }
  if (*(_DWORD *)(a2 + 44) == 1) {
    uint64_t result = (uint64_t)appendStringInfoString(a1, "CASCADE ");
  }
  int v36 = *(_DWORD *)(a1 + 8);
  BOOL v37 = __OFSUB__(v36, 1);
  uint64_t v38 = (v36 - 1);
  if ((int)v38 < 0 == v37)
  {
    uint64_t v39 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v38) == 32)
    {
      *(_DWORD *)(a1 + 8) = v38;
      *(unsigned char *)(v39 + v38) = 0;
    }
  }
  return result;
}

uint64_t deparseIndexStmt(_DWORD *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(unsigned char *)(a2 + 104)) {
    appendStringInfoString((uint64_t)a1, "UNIQUE ");
  }
  appendStringInfoString((uint64_t)a1, "INDEX ");
  if (*(unsigned char *)(a2 + 110)) {
    appendStringInfoString((uint64_t)a1, "CONCURRENTLY ");
  }
  if (*(unsigned char *)(a2 + 111)) {
    appendStringInfoString((uint64_t)a1, "IF NOT EXISTS ");
  }
  int v4 = *(char **)(a2 + 8);
  if (v4)
  {
    appendStringInfoString((uint64_t)a1, v4);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "ON ");
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 16), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  if (*(void *)(a2 + 24))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    uint64_t v5 = quote_identifier(*(unsigned char **)(a2 + 24));
    appendStringInfoString((uint64_t)a1, v5);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  uint64_t v12 = *(void *)(a2 + 40);
  if (v12 && *(int *)(v12 + 4) >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 8;
    do
    {
      uint64_t v15 = *(void *)(v12 + 16);
      deparseIndexElem(a1, *(void *)(v15 + 8 * v13), v6, v7, v8, v9, v10, v11);
      if (v15 + v14) {
        BOOL v16 = v15 + v14 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
      }
                                            + 8 * *(int *)(*(void *)(a2 + 40) + 4));
      else {
        BOOL v16 = 1;
      }
      if (!v16) {
        appendStringInfoString((uint64_t)a1, ", ");
      }
      ++v13;
      v14 += 8;
    }
    while (v13 < *(int *)(v12 + 4));
  }
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  uint64_t v18 = *(void *)(a2 + 48);
  if (v18 && *(int *)(v18 + 4) > 0)
  {
    appendStringInfoString((uint64_t)a1, "INCLUDE (");
    uint64_t v25 = *(void *)(a2 + 48);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        deparseIndexElem(a1, *(void *)(v28 + 8 * v26), v19, v20, v21, v22, v23, v24);
        if (v28 + v27) {
          BOOL v29 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v29 = 1;
        }
        if (!v29) {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ") ");
  }
  uint64_t v30 = *(void *)(a2 + 56);
  if (v30 && *(int *)(v30 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v30);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    uint64_t v31 = quote_identifier(*(unsigned char **)(a2 + 32));
    appendStringInfoString((uint64_t)a1, v31);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v32 = *(int **)(a2 + 64);
  if (v32)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v32, v33, v34, v35, v36, v37, v38);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  int v39 = a1[2];
  BOOL v40 = __OFSUB__(v39, 1);
  uint64_t v41 = (v39 - 1);
  if ((int)v41 < 0 == v40)
  {
    uint64_t v42 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v41) == 32)
    {
      a1[2] = v41;
      *(unsigned char *)(v42 + v41) = 0;
    }
  }
  return result;
}

uint64_t deparseInsertStmt(_DWORD *a1, uint64_t a2)
{
  if (*(void *)(a2 + 48))
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "INSERT INTO ");
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 8), 1);
  appendStringInfoChar((uint64_t)a1, 32);
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v5 = *(void *)(a2 + 16);
    if (v5 && *(int *)(v5 + 4) >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8;
      do
      {
        uint64_t v8 = *(void *)(v5 + 16);
        uint64_t v9 = *(void *)(v8 + 8 * v6);
        uint64_t v10 = quote_identifier(*(unsigned char **)(v9 + 8));
        appendStringInfoString((uint64_t)a1, v10);
        deparseOptIndirection((uint64_t)a1, *(void *)(v9 + 16), 0);
        uint64_t v11 = *(int *)(v5 + 4);
        if (v8 + v7) {
          BOOL v12 = v8 + v7 >= (unint64_t)(*(void *)(v5 + 16) + 8 * v11);
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v11 = *(int *)(v5 + 4);
        }
        ++v6;
        v7 += 8;
      }
      while (v6 < v11);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  int v13 = *(_DWORD *)(a2 + 56);
  if (v13 == 1)
  {
    uint64_t v14 = "OVERRIDING USER VALUE ";
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_20;
    }
    uint64_t v14 = "OVERRIDING SYSTEM VALUE ";
  }
  appendStringInfoString((uint64_t)a1, v14);
LABEL_20:
  uint64_t v15 = *(void *)(a2 + 24);
  if (v15)
  {
    deparseSelectStmt(a1, v15);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
    uint64_t v17 = *(void *)(a2 + 32);
    if (!v17) {
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "DEFAULT VALUES ");
    uint64_t v17 = *(void *)(a2 + 32);
    if (!v17) {
      goto LABEL_59;
    }
  }
  appendStringInfoString((uint64_t)a1, "ON CONFLICT ");
  uint64_t v18 = *(void *)(v17 + 8);
  if (v18)
  {
    uint64_t v19 = *(void *)(v18 + 8);
    if (v19 && *(int *)(v19 + 4) >= 1)
    {
      appendStringInfoChar((uint64_t)a1, 40);
      uint64_t v26 = *(void *)(v18 + 8);
      if (v26 && *(int *)(v26 + 4) >= 1)
      {
        uint64_t v27 = 0;
        uint64_t v28 = 8;
        do
        {
          uint64_t v29 = *(void *)(v26 + 16);
          deparseIndexElem(a1, *(void *)(v29 + 8 * v27), v20, v21, v22, v23, v24, v25);
          if (v29 + v28) {
            BOOL v30 = v29 + v28 >= (unint64_t)(*(void *)(*(void *)(v18 + 8) + 16)
          }
                                                + 8 * *(int *)(*(void *)(v18 + 8) + 4));
          else {
            BOOL v30 = 1;
          }
          if (!v30) {
            appendStringInfoString((uint64_t)a1, ", ");
          }
          ++v27;
          v28 += 8;
        }
        while (v27 < *(int *)(v26 + 4));
      }
      appendStringInfoString((uint64_t)a1, ") ");
    }
    if (*(void *)(v18 + 24))
    {
      appendStringInfoString((uint64_t)a1, "ON CONSTRAINT ");
      uint64_t v31 = quote_identifier(*(unsigned char **)(v18 + 24));
      appendStringInfoString((uint64_t)a1, v31);
      appendStringInfoChar((uint64_t)a1, 32);
    }
    uint64_t v32 = *(void *)(v18 + 16);
    if (v32)
    {
      appendStringInfoString((uint64_t)a1, "WHERE ");
      deparseExpr(a1, v32);
      appendStringInfoChar((uint64_t)a1, 32);
    }
    int v33 = a1[2];
    BOOL v34 = __OFSUB__(v33, 1);
    uint64_t v35 = (v33 - 1);
    if ((int)v35 < 0 == v34)
    {
      uint64_t v36 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v35) == 32)
      {
        a1[2] = v35;
        *(unsigned char *)(v36 + v35) = 0;
      }
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  int v37 = *(_DWORD *)(v17 + 4);
  if (v37 == 1)
  {
    uint64_t v38 = "DO NOTHING ";
  }
  else
  {
    if (v37 != 2) {
      goto LABEL_50;
    }
    uint64_t v38 = "DO UPDATE ";
  }
  appendStringInfoString((uint64_t)a1, v38);
LABEL_50:
  uint64_t v39 = *(void *)(v17 + 16);
  if (v39 && *(int *)(v39 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "SET ");
    deparseSetClauseList((uint64_t)a1, *(void *)(v17 + 16));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v40 = *(void *)(v17 + 24);
  if (v40)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v40);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  int v41 = a1[2];
  BOOL v34 = __OFSUB__(v41, 1);
  uint64_t v42 = (v41 - 1);
  if ((int)v42 < 0 == v34)
  {
    uint64_t v43 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v42) == 32)
    {
      a1[2] = v42;
      *(unsigned char *)(v43 + v42) = 0;
    }
  }
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
LABEL_59:
  uint64_t v44 = *(void *)(a2 + 40);
  if (v44 && *(int *)(v44 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    uint64_t result = deparseTargetList((uint64_t)a1, *(void *)(a2 + 40));
  }
  int v45 = a1[2];
  BOOL v34 = __OFSUB__(v45, 1);
  uint64_t v46 = (v45 - 1);
  if ((int)v46 < 0 == v34)
  {
    uint64_t v47 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v46) == 32)
    {
      a1[2] = v46;
      *(unsigned char *)(v47 + v46) = 0;
    }
  }
  return result;
}

uint64_t deparseRefreshMatViewStmt(uint64_t a1, uint64_t a2)
{
  appendStringInfoString(a1, "REFRESH MATERIALIZED VIEW ");
  if (*(unsigned char *)(a2 + 4)) {
    appendStringInfoString(a1, "CONCURRENTLY ");
  }
  deparseRangeVar(a1, *(void *)(a2 + 8), 0);
  uint64_t result = appendStringInfoChar(a1, 32);
  if (*(unsigned char *)(a2 + 5)) {
    uint64_t result = (uint64_t)appendStringInfoString(a1, "WITH NO DATA ");
  }
  int v5 = *(_DWORD *)(a1 + 8);
  BOOL v6 = __OFSUB__(v5, 1);
  uint64_t v7 = (v5 - 1);
  if ((int)v7 < 0 == v6)
  {
    uint64_t v8 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v7) == 32)
    {
      *(_DWORD *)(a1 + 8) = v7;
      *(unsigned char *)(v8 + v7) = 0;
    }
  }
  return result;
}

uint64_t deparseSelectStmt(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *(void *)(a2 + 120);
  if (v4)
  {
    deparseWithClause(a1, v4);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  int v5 = *(_DWORD *)(v2 + 128);
  if ((v5 - 1) < 3)
  {
    uint64_t v6 = *(void *)(v2 + 136);
    uint64_t v7 = *(void *)(v6 + 80);
    if (v7 && *(int *)(v7 + 4) > 0
      || *(void *)(v6 + 88)
      || *(void *)(v6 + 96)
      || (uint64_t v30 = *(void *)(v6 + 112)) != 0 && *(int *)(v30 + 4) > 0
      || *(void *)(v6 + 120))
    {
      BOOL v8 = 1;
      uint64_t v9 = *(void *)(v2 + 144);
      uint64_t v10 = *(void *)(v9 + 80);
      if (!v10) {
        goto LABEL_10;
      }
    }
    else
    {
      BOOL v8 = *(_DWORD *)(v6 + 128) != 0;
      uint64_t v9 = *(void *)(v2 + 144);
      uint64_t v10 = *(void *)(v9 + 80);
      if (!v10)
      {
LABEL_10:
        if (!*(void *)(v9 + 88) && !*(void *)(v9 + 96))
        {
          uint64_t v31 = *(void *)(v9 + 112);
          if ((!v31 || *(int *)(v31 + 4) <= 0) && !*(void *)(v9 + 120))
          {
            BOOL v11 = *(_DWORD *)(v9 + 128) != 0;
            uint64_t v12 = (uint64_t)a1;
            if (!v8)
            {
LABEL_57:
              deparseSelectStmt(v12, v6);
              unsigned int v13 = *(_DWORD *)(v2 + 128) - 1;
              if (v13 > 2)
              {
LABEL_59:
                if (*(unsigned char *)(v2 + 132)) {
                  appendStringInfoString((uint64_t)a1, "ALL ");
                }
                if (v11)
                {
                  appendStringInfoChar((uint64_t)a1, 40);
                  deparseSelectStmt(a1, *(void *)(v2 + 144));
                  appendStringInfoChar((uint64_t)a1, 41);
                }
                else
                {
                  deparseSelectStmt(a1, *(void *)(v2 + 144));
                }
LABEL_64:
                appendStringInfoChar((uint64_t)a1, 32);
                goto LABEL_65;
              }
LABEL_58:
              appendStringInfoString((uint64_t)a1, (&off_1E55D8E60)[v13]);
              goto LABEL_59;
            }
LABEL_13:
            appendStringInfoChar(v12, 40);
            deparseSelectStmt(a1, *(void *)(v2 + 136));
            appendStringInfoChar((uint64_t)a1, 41);
            unsigned int v13 = *(_DWORD *)(v2 + 128) - 1;
            if (v13 > 2) {
              goto LABEL_59;
            }
            goto LABEL_58;
          }
        }
LABEL_12:
        BOOL v11 = 1;
        uint64_t v12 = (uint64_t)a1;
        if (!v8) {
          goto LABEL_57;
        }
        goto LABEL_13;
      }
    }
    if (*(int *)(v10 + 4) > 0) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (v5) {
    goto LABEL_65;
  }
  uint64_t v14 = *(void *)(v2 + 72);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "VALUES ");
    uint64_t v15 = *(void *)(v2 + 72);
    if (v15 && *(int *)(v15 + 4) >= 1)
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = (uint64_t *)(*(void *)(v15 + 16) + 8 * v16);
        appendStringInfoChar((uint64_t)a1, 40);
        uint64_t v18 = *v17;
        if (*v17 && *(int *)(v18 + 4) >= 1)
        {
          uint64_t v19 = 0;
          uint64_t v20 = 8;
          do
          {
            uint64_t v21 = *(void *)(v18 + 16);
            deparseExpr(a1, *(void *)(v21 + 8 * v19));
            uint64_t v22 = *(int *)(v18 + 4);
            if (v21 + v20) {
              BOOL v23 = v21 + v20 >= (unint64_t)(*(void *)(v18 + 16) + 8 * v22);
            }
            else {
              BOOL v23 = 1;
            }
            if (!v23)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              uint64_t v22 = *(int *)(v18 + 4);
            }
            ++v19;
            v20 += 8;
          }
          while (v19 < v22);
        }
        appendStringInfoChar((uint64_t)a1, 41);
        if (v17 != (uint64_t *)-8
          && (unint64_t)(v17 + 1) < *(void *)(*(void *)(v2 + 72) + 16)
                                         + 8 * *(int *)(*(void *)(v2 + 72) + 4))
        {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v16;
      }
      while (v16 < *(int *)(v15 + 4));
    }
    goto LABEL_64;
  }
  appendStringInfoString((uint64_t)a1, "SELECT ");
  uint64_t v25 = *(void *)(v2 + 24);
  if (v25 && *(int *)(v25 + 4) >= 1)
  {
    if (*(void *)(v2 + 8))
    {
      appendStringInfoString((uint64_t)a1, "DISTINCT ");
      uint64_t v26 = *(void *)(v2 + 8);
      if (v26)
      {
        if (*(int *)(v26 + 4) >= 1 && **(void **)(v26 + 16))
        {
          appendStringInfoString((uint64_t)a1, "ON (");
          deparseExprList(a1, *(void *)(v2 + 8));
          appendStringInfoString((uint64_t)a1, ") ");
        }
      }
    }
    deparseTargetList((uint64_t)a1, *(void *)(v2 + 24));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(v2 + 16))
  {
    appendStringInfoString((uint64_t)a1, "INTO ");
    uint64_t v27 = *(void *)(v2 + 16);
    int v28 = *(char *)(*(void *)(v27 + 8) + 33);
    if (v28 == 117)
    {
      uint64_t v29 = "UNLOGGED ";
    }
    else
    {
      if (v28 != 116)
      {
LABEL_120:
        deparseIntoClause(a1, v27);
        appendStringInfoChar((uint64_t)a1, 32);
        goto LABEL_121;
      }
      uint64_t v29 = "TEMPORARY ";
    }
    appendStringInfoString((uint64_t)a1, v29);
    uint64_t v27 = *(void *)(v2 + 16);
    goto LABEL_120;
  }
LABEL_121:
  uint64_t v63 = *(void *)(v2 + 32);
  if (v63 && *(int *)(v63 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    if (*(int *)(v63 + 4) >= 1)
    {
      uint64_t v70 = 0;
      uint64_t v71 = 8;
      do
      {
        uint64_t v72 = *(void *)(v63 + 16);
        deparseTableRef(a1, *(void *)(v72 + 8 * v70), v64, v65, v66, v67, v68, v69);
        uint64_t v73 = *(int *)(v63 + 4);
        if (v72 + v71) {
          BOOL v74 = v72 + v71 >= (unint64_t)(*(void *)(v63 + 16) + 8 * v73);
        }
        else {
          BOOL v74 = 1;
        }
        if (!v74)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v73 = *(int *)(v63 + 4);
        }
        ++v70;
        v71 += 8;
      }
      while (v70 < v73);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v75 = *(void *)(v2 + 40);
  if (v75)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v75);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v76 = *(void *)(v2 + 48);
  if (v76 && *(int *)(v76 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "GROUP BY ");
    uint64_t v77 = *(void *)(v2 + 48);
    if (v77 && *(int *)(v77 + 4) >= 1)
    {
      uint64_t v78 = 0;
      uint64_t v79 = 8;
      do
      {
        uint64_t v80 = *(void *)(v77 + 16);
        BOOL v81 = *(_DWORD **)(v80 + 8 * v78);
        if (*v81 == 376) {
          deparseGroupingSet(a1, (uint64_t)v81);
        }
        else {
          deparseExpr(a1, v81);
        }
        uint64_t v82 = *(int *)(v77 + 4);
        if (v80 + v79) {
          BOOL v83 = v80 + v79 >= (unint64_t)(*(void *)(v77 + 16) + 8 * v82);
        }
        else {
          BOOL v83 = 1;
        }
        if (!v83)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v82 = *(int *)(v77 + 4);
        }
        ++v78;
        v79 += 8;
      }
      while (v78 < v82);
    }
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(v2 + 56))
  {
    appendStringInfoString((uint64_t)a1, "HAVING ");
    deparseExpr(a1, *(void *)(v2 + 56));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  if (*(void *)(v2 + 64))
  {
    appendStringInfoString((uint64_t)a1, "WINDOW ");
    uint64_t v84 = *(void *)(v2 + 64);
    if (v84 && *(int *)(v84 + 4) >= 1)
    {
      uint64_t v85 = 0;
      uint64_t v86 = 8;
      do
      {
        uint64_t v87 = *(void *)(v84 + 16);
        uint64_t v88 = *(void *)(v87 + 8 * v85);
        appendStringInfoString((uint64_t)a1, *(char **)(v88 + 8));
        appendStringInfoString((uint64_t)a1, " AS ");
        deparseWindowDef((uint64_t)a1, v88);
        if (v87 + v86) {
          BOOL v89 = v87 + v86 >= (unint64_t)(*(void *)(*(void *)(v2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(v2 + 64) + 4));
        else {
          BOOL v89 = 1;
        }
        if (!v89) {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v85;
        v86 += 8;
      }
      while (v85 < *(int *)(v84 + 4));
    }
    goto LABEL_64;
  }
LABEL_65:
  uint64_t result = deparseOptSortClause((uint64_t)a1, *(void *)(v2 + 80));
  if (!*(void *)(v2 + 96)) {
    goto LABEL_166;
  }
  int v39 = *(_DWORD *)(v2 + 104);
  if (v39 == 1)
  {
    uint64_t v40 = "LIMIT ";
    goto LABEL_70;
  }
  if (v39 == 2)
  {
    uint64_t v40 = "FETCH FIRST ";
LABEL_70:
    appendStringInfoString((uint64_t)a1, v40);
  }
  uint64_t v41 = *(void *)(v2 + 96);
  switch(*(_DWORD *)v41)
  {
    case 0x15A:
      appendStringInfoChar((uint64_t)a1, 40);
      deparseAExpr(a1, v41);
LABEL_115:
      appendStringInfoChar((uint64_t)a1, 41);
      break;
    case 0x15B:
      uint64_t v48 = **(void **)(*(void *)(v41 + 8) + 16);
      if (*(_DWORD *)v48 == 223)
      {
        uint64_t v90 = quote_identifier(*(unsigned char **)(v48 + 8));
        appendStringInfoString((uint64_t)a1, v90);
      }
      else if (*(_DWORD *)v48 == 351)
      {
        appendStringInfoChar((uint64_t)a1, 42);
      }
      deparseOptIndirection((uint64_t)a1, *(void *)(v41 + 8), 1);
      break;
    case 0x15C:
      if (*(_DWORD *)(v41 + 4)) {
        appendStringInfo((uint64_t)a1, "$%d", v33, v34, v35, v36, v37, v38, *(unsigned int *)(v41 + 4));
      }
      else {
        appendStringInfoChar((uint64_t)a1, 63);
      }
      break;
    case 0x15D:
      int v50 = *(_DWORD *)(v41 + 8);
      uint64_t v49 = (_DWORD *)(v41 + 8);
      if (v50 == 225) {
        appendStringInfoString((uint64_t)a1, "ALL");
      }
      else {
        deparseValue(a1, v49, 11, v34, v35, v36, v37, v38);
      }
      break;
    case 0x15E:
      deparseFuncCall((uint64_t)a1, *(void *)(v2 + 96));
      break;
    case 0x15F:
    case 0x160:
    case 0x163:
    case 0x164:
LABEL_203:
      deparseSelectStmt_cold_1();
    case 0x161:
      deparseAIndirection((uint64_t)a1, *(void *)(v2 + 96));
      break;
    case 0x162:
      appendStringInfoString((uint64_t)a1, "ARRAY[");
      uint64_t v51 = *(void *)(v41 + 8);
      if (v51 && *(int *)(v51 + 4) >= 1)
      {
        uint64_t v52 = 0;
        uint64_t v53 = 8;
        do
        {
          uint64_t v54 = *(void *)(v51 + 16);
          deparseExpr(a1, *(void *)(v54 + 8 * v52));
          uint64_t v55 = *(int *)(v51 + 4);
          if (v54 + v53) {
            BOOL v56 = v54 + v53 >= (unint64_t)(*(void *)(v51 + 16) + 8 * v55);
          }
          else {
            BOOL v56 = 1;
          }
          if (!v56)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            uint64_t v55 = *(int *)(v51 + 4);
          }
          ++v52;
          v53 += 8;
        }
        while (v52 < v55);
      }
      appendStringInfoChar((uint64_t)a1, 93);
      break;
    case 0x165:
      deparseTypeCast(a1, *(void *)(v2 + 96));
      break;
    default:
      switch(*(_DWORD *)v41)
      {
        case 0x6E:
          appendStringInfoString((uint64_t)a1, "GROUPING(");
          uint64_t v42 = *(void *)(v41 + 8);
          if (v42 && *(int *)(v42 + 4) >= 1)
          {
            uint64_t v43 = 0;
            uint64_t v44 = 8;
            do
            {
              uint64_t v45 = *(void *)(v42 + 16);
              deparseExpr(a1, *(void *)(v45 + 8 * v43));
              uint64_t v46 = *(int *)(v42 + 4);
              if (v45 + v44) {
                BOOL v47 = v45 + v44 >= (unint64_t)(*(void *)(v42 + 16) + 8 * v46);
              }
              else {
                BOOL v47 = 1;
              }
              if (!v47)
              {
                appendStringInfoString((uint64_t)a1, ", ");
                uint64_t v46 = *(int *)(v42 + 4);
              }
              ++v43;
              v44 += 8;
            }
            while (v43 < v46);
          }
          goto LABEL_115;
        case 0x78:
          deparseSubLink(a1, *(void *)(v2 + 96));
          goto LABEL_164;
        case 0x82:
          deparseCaseExpr((uint64_t)a1, *(void **)(v2 + 96));
          goto LABEL_164;
        case 0x86:
          if (!*(_DWORD *)(v41 + 20)) {
            appendStringInfoString((uint64_t)a1, "ROW");
          }
          appendStringInfoString((uint64_t)a1, "(");
          uint64_t v57 = *(void *)(v41 + 8);
          if (v57 && *(int *)(v57 + 4) >= 1)
          {
            uint64_t v58 = 0;
            uint64_t v59 = 8;
            do
            {
              uint64_t v60 = *(void *)(v57 + 16);
              deparseExpr(a1, *(void *)(v60 + 8 * v58));
              uint64_t v61 = *(int *)(v57 + 4);
              if (v60 + v59) {
                BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(v57 + 16) + 8 * v61);
              }
              else {
                BOOL v62 = 1;
              }
              if (!v62)
              {
                appendStringInfoString((uint64_t)a1, ", ");
                uint64_t v61 = *(int *)(v57 + 4);
              }
              ++v58;
              v59 += 8;
            }
            while (v58 < v61);
          }
          goto LABEL_115;
        default:
          goto LABEL_203;
      }
  }
LABEL_164:
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(_DWORD *)(v2 + 104) == 2) {
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "ROWS WITH TIES ");
  }
LABEL_166:
  if (*(void *)(v2 + 88))
  {
    appendStringInfoString((uint64_t)a1, "OFFSET ");
    deparseExpr(a1, *(void *)(v2 + 88));
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v91 = *(void *)(v2 + 112);
  if (v91 && *(int *)(v91 + 4) >= 1)
  {
    uint64_t v92 = 0;
    while (1)
    {
      uint64_t v93 = v2;
      uint64_t v94 = *(void *)(v91 + 16) + 8 * v92;
      uint64_t v95 = *(void *)v94;
      unsigned int v96 = *(_DWORD *)(*(void *)v94 + 16) - 1;
      if (v96 <= 3) {
        appendStringInfoString((uint64_t)a1, (&off_1E55D8E78)[v96]);
      }
      uint64_t v97 = *(void *)(v95 + 8);
      if (v97)
      {
        if (*(int *)(v97 + 4) >= 1)
        {
          appendStringInfoString((uint64_t)a1, "OF ");
          uint64_t v98 = *(void *)(v95 + 8);
          if (v98)
          {
            if (*(int *)(v98 + 4) >= 1)
            {
              uint64_t v99 = 0;
              uint64_t v100 = 8;
              do
              {
                uint64_t v101 = *(void *)(v98 + 16);
                deparseRangeVar((uint64_t)a1, *(void *)(v101 + 8 * v99), 0);
                uint64_t v102 = *(int *)(v98 + 4);
                if (v101 + v100) {
                  BOOL v103 = v101 + v100 >= (unint64_t)(*(void *)(v98 + 16) + 8 * v102);
                }
                else {
                  BOOL v103 = 1;
                }
                if (!v103)
                {
                  appendStringInfoString((uint64_t)a1, ", ");
                  uint64_t v102 = *(int *)(v98 + 4);
                }
                ++v99;
                v100 += 8;
              }
              while (v99 < v102);
            }
          }
        }
      }
      int v104 = *(_DWORD *)(v95 + 20);
      if (v104 == 2)
      {
        uint64_t v105 = "NOWAIT";
        uint64_t v2 = v93;
      }
      else
      {
        uint64_t v2 = v93;
        if (v104 != 1) {
          goto LABEL_190;
        }
        uint64_t v105 = "SKIP LOCKED";
      }
      appendStringInfoString((uint64_t)a1, v105);
LABEL_190:
      int v106 = a1[2];
      BOOL v107 = __OFSUB__(v106, 1);
      uint64_t v108 = (v106 - 1);
      if ((int)v108 < 0 == v107)
      {
        uint64_t v109 = *(void *)a1;
        if (*(unsigned char *)(*(void *)a1 + v108) == 32)
        {
          a1[2] = v108;
          *(unsigned char *)(v109 + v108) = 0;
        }
      }
      if (v94 != -8
        && v94 + 8 < (unint64_t)(*(void *)(*(void *)(v2 + 112) + 16)
                                      + 8 * *(int *)(*(void *)(v2 + 112) + 4)))
      {
        appendStringInfoString((uint64_t)a1, " ");
      }
      if (++v92 >= *(int *)(v91 + 4))
      {
        uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
        break;
      }
    }
  }
  int v111 = a1[2];
  BOOL v107 = __OFSUB__(v111, 1);
  uint64_t v112 = (v111 - 1);
  if ((int)v112 < 0 == v107)
  {
    uint64_t v113 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v112) == 32)
    {
      a1[2] = v112;
      *(unsigned char *)(v113 + v112) = 0;
    }
  }
  return result;
}

uint64_t deparseUpdateStmt(_DWORD *a1, uint64_t *a2)
{
  if (a2[6])
  {
    deparseWithClause(a1);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "UPDATE ");
  deparseRangeVar((uint64_t)a1, a2[1], 0);
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  uint64_t v5 = a2[2];
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "SET ");
    deparseSetClauseList((uint64_t)a1, a2[2]);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v6 = a2[4];
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "FROM ");
    if (*(int *)(v6 + 4) >= 1)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 8;
      do
      {
        uint64_t v15 = *(void *)(v6 + 16);
        deparseTableRef(a1, *(void *)(v15 + 8 * v13), v7, v8, v9, v10, v11, v12);
        uint64_t v16 = *(int *)(v6 + 4);
        if (v15 + v14) {
          BOOL v17 = v15 + v14 >= (unint64_t)(*(void *)(v6 + 16) + 8 * v16);
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v16 = *(int *)(v6 + 4);
        }
        ++v13;
        v14 += 8;
      }
      while (v13 < v16);
    }
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v18 = a2[3];
  if (v18)
  {
    appendStringInfoString((uint64_t)a1, "WHERE ");
    deparseExpr(a1, v18);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v19 = a2[5];
  if (v19 && *(int *)(v19 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "RETURNING ");
    uint64_t result = deparseTargetList((uint64_t)a1, a2[5]);
  }
  int v20 = a1[2];
  BOOL v21 = __OFSUB__(v20, 1);
  uint64_t v22 = (v20 - 1);
  if ((int)v22 < 0 == v21)
  {
    uint64_t v23 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v22) == 32)
    {
      a1[2] = v22;
      *(unsigned char *)(v23 + v22) = 0;
    }
  }
  return result;
}

uint64_t deparseVariableSetStmt(uint64_t result, uint64_t a2)
{
  int v3 = (void *)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      appendStringInfoString(result, "SET ");
      if (*(unsigned char *)(a2 + 24)) {
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      }
      uint64_t v4 = quote_identifier(*(unsigned char **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v4);
      uint64_t result = (uint64_t)appendStringInfoString((uint64_t)v3, " TO ");
      uint64_t v11 = *(void *)(a2 + 16);
      if (v11 && *(int *)(v11 + 4) >= 1)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8;
        do
        {
          uint64_t v14 = *(void *)(v11 + 16);
          uint64_t v15 = *(void *)(v14 + 8 * v12);
          if (*(_DWORD *)v15 == 349)
          {
            int v17 = *(_DWORD *)(v15 + 8);
            switch(v17)
            {
              case 223:
                uint64_t result = (uint64_t)deparseOptBooleanOrString(v3, *(char **)(v15 + 16));
                break;
              case 222:
                uint64_t result = (uint64_t)appendStringInfoString((uint64_t)v3, *(char **)(v15 + 16));
                break;
              case 221:
                uint64_t result = appendStringInfo((uint64_t)v3, "%d", v5, v6, v7, v8, v9, v10, *(unsigned int *)(v15 + 16));
                break;
            }
          }
          else if (*(_DWORD *)v15 == 348)
          {
            size_t v16 = *(unsigned int *)(v15 + 4);
            if (v16) {
              uint64_t result = appendStringInfo((uint64_t)v3, "$%d", v5, v6, v7, v8, v9, v10, v16);
            }
            else {
              uint64_t result = appendStringInfoChar((uint64_t)v3, 63);
            }
          }
          uint64_t v18 = *(int *)(v11 + 4);
          if (v14 + v13) {
            BOOL v19 = v14 + v13 >= (unint64_t)(*(void *)(v11 + 16) + 8 * v18);
          }
          else {
            BOOL v19 = 1;
          }
          if (!v19)
          {
            uint64_t result = (uint64_t)appendStringInfoString((uint64_t)v3, ", ");
            uint64_t v18 = *(int *)(v11 + 4);
          }
          ++v12;
          v13 += 8;
        }
        while (v12 < v18);
      }
      return result;
    case 1:
      appendStringInfoString(result, "SET ");
      if (*(unsigned char *)(a2 + 24)) {
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      }
      int v20 = quote_identifier(*(unsigned char **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v20);
      BOOL v21 = " TO DEFAULT";
      goto LABEL_38;
    case 2:
      appendStringInfoString(result, "SET ");
      if (*(unsigned char *)(a2 + 24)) {
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      }
      uint64_t v22 = quote_identifier(*(unsigned char **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v22);
      BOOL v21 = " FROM CURRENT";
      goto LABEL_38;
    case 3:
      appendStringInfoString(result, "SET ");
      if (*(unsigned char *)(a2 + 24)) {
        appendStringInfoString((uint64_t)v3, "LOCAL ");
      }
      uint64_t v23 = *(const char **)(a2 + 8);
      if (!strcmp(v23, "TRANSACTION"))
      {
        uint64_t v24 = "TRANSACTION ";
      }
      else
      {
        if (strcmp(v23, "SESSION CHARACTERISTICS"))
        {
          uint64_t result = strcmp(v23, "TRANSACTION SNAPSHOT");
          if (!result)
          {
            appendStringInfoString((uint64_t)v3, "TRANSACTION SNAPSHOT ");
            uint64_t v26 = *(char **)(**(void **)(*(void *)(a2 + 16) + 16) + 16);
            return deparseStringLiteral((uint64_t)v3, v26);
          }
          return result;
        }
        uint64_t v24 = "SESSION CHARACTERISTICS AS TRANSACTION ";
      }
      appendStringInfoString((uint64_t)v3, v24);
      uint64_t v25 = *(void *)(a2 + 16);
      return deparseTransactionModeList((uint64_t)v3, v25);
    case 4:
      appendStringInfoString(result, "RESET ");
      BOOL v21 = quote_identifier(*(unsigned char **)(a2 + 8));
      goto LABEL_38;
    case 5:
      BOOL v21 = "RESET ALL";
LABEL_38:
      return (uint64_t)appendStringInfoString((uint64_t)v3, v21);
    default:
      return result;
  }
}

uint64_t deparseViewStmt(_DWORD *a1, uint64_t a2)
{
  appendStringInfoString((uint64_t)a1, "CREATE ");
  if (*(unsigned char *)(a2 + 32)) {
    appendStringInfoString((uint64_t)a1, "OR REPLACE ");
  }
  int v4 = *(char *)(*(void *)(a2 + 8) + 33);
  if (v4 == 117)
  {
    uint64_t v5 = "UNLOGGED ";
    goto LABEL_7;
  }
  if (v4 == 116)
  {
    uint64_t v5 = "TEMPORARY ";
LABEL_7:
    appendStringInfoString((uint64_t)a1, v5);
  }
  appendStringInfoString((uint64_t)a1, "VIEW ");
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 8), 0);
  appendStringInfoChar((uint64_t)a1, 32);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8;
      do
      {
        uint64_t v10 = *(void *)(v7 + 16);
        uint64_t v11 = quote_identifier(*(unsigned char **)(*(void *)(v10 + 8 * v8) + 8));
        appendStringInfoString((uint64_t)a1, v11);
        uint64_t v12 = *(int *)(v7 + 4);
        if (v10 + v9) {
          BOOL v13 = v10 + v9 >= (unint64_t)(*(void *)(v7 + 16) + 8 * v12);
        }
        else {
          BOOL v13 = 1;
        }
        if (!v13)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v12 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v12);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  uint64_t v14 = *(void *)(a2 + 40);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v14);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  appendStringInfoString((uint64_t)a1, "AS ");
  deparseSelectStmt(a1, *(void *)(a2 + 24));
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  int v16 = *(_DWORD *)(a2 + 48);
  if (v16 == 1)
  {
    int v17 = "WITH LOCAL CHECK OPTION ";
  }
  else
  {
    if (v16 != 2) {
      goto LABEL_28;
    }
    int v17 = "WITH CHECK OPTION ";
  }
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v17);
LABEL_28:
  int v18 = a1[2];
  BOOL v19 = __OFSUB__(v18, 1);
  uint64_t v20 = (v18 - 1);
  if ((int)v20 < 0 == v19)
  {
    uint64_t v21 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v20) == 32)
    {
      a1[2] = v20;
      *(unsigned char *)(v21 + v20) = 0;
    }
  }
  return result;
}

uint64_t deparseAnyName(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = quote_identifier(*(unsigned char **)(*(void *)(v6 + 8 * v4) + 8));
      uint64_t result = (uint64_t)appendStringInfoString(v3, v7);
      uint64_t v8 = *(int *)(a2 + 4);
      if (v6 + v5) {
        BOOL v9 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v8);
      }
      else {
        BOOL v9 = 1;
      }
      if (!v9)
      {
        uint64_t result = appendStringInfoChar(v3, 46);
        uint64_t v8 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v8);
  }
  return result;
}

unint64_t deparseCreatedbOptList(unint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = (void *)result;
    for (uint64_t i = 0; i < *(int *)(a2 + 4); ++i)
    {
      uint64_t v5 = *(void *)(a2 + 16) + 8 * i;
      uint64_t v6 = *(void *)v5;
      uint64_t v7 = *(const char **)(*(void *)v5 + 16);
      if (!strcmp(v7, "connection_limit"))
      {
        appendStringInfoString((uint64_t)v3, "CONNECTION LIMIT");
        uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v19 = *(void *)(v6 + 24);
        if (!v19) {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v8 = pstrdup(v7);
        BOOL v9 = v8;
        unsigned __int8 v10 = *v8;
        if (*v8)
        {
          uint64_t v11 = v8 + 1;
          do
          {
            *(v11 - 1) = pg_toupper(v10);
            int v12 = *v11++;
            unsigned __int8 v10 = v12;
          }
          while (v12);
        }
        appendStringInfoString((uint64_t)v3, v9);
        pfree((uint64_t)v9);
        uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v19 = *(void *)(v6 + 24);
        if (!v19)
        {
LABEL_15:
          uint64_t result = (unint64_t)appendStringInfoString((uint64_t)v3, "DEFAULT");
LABEL_16:
          unint64_t v20 = v5 + 8;
          if (v5 != -8) {
            goto LABEL_17;
          }
          continue;
        }
      }
      if (*(_DWORD *)v19 != 223)
      {
        if (*(_DWORD *)v19 == 221)
        {
          uint64_t result = appendStringInfo((uint64_t)v3, "%d", v13, v14, v15, v16, v17, v18, *(unsigned int *)(v19 + 8));
          unint64_t v20 = v5 + 8;
          if (v5 != -8) {
            goto LABEL_17;
          }
          continue;
        }
        goto LABEL_16;
      }
      uint64_t result = (unint64_t)deparseOptBooleanOrString(v3, *(char **)(v19 + 8));
      unint64_t v20 = v5 + 8;
      if (v5 != -8)
      {
LABEL_17:
        if (v20 < *(void *)(a2 + 16) + 8 * *(int *)(a2 + 4)) {
          uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
        }
      }
    }
  }
  return result;
}

void *deparseOptBooleanOrString(void *result, char *__s1)
{
  if (!__s1) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (!strcmp(__s1, "true"))
  {
    uint64_t v5 = "TRUE";
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }
  if (!strcmp(__s1, "false"))
  {
    uint64_t v5 = "FALSE";
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }
  if (!strcmp(__s1, "on"))
  {
    uint64_t v5 = "ON";
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }
  if (!strcmp(__s1, "off"))
  {
    uint64_t v5 = "OFF";
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }
  size_t v4 = strlen(__s1);
  if (!v4)
  {
    uint64_t v5 = "''";
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }
  if (v4 < 0x40)
  {
    uint64_t v5 = quote_identifier(__s1);
    uint64_t v6 = v3;
    return appendStringInfoString(v6, v5);
  }

  return (void *)deparseStringLiteral(v3, __s1);
}

uint64_t deparseStringLiteral(uint64_t a1, char *__s)
{
  uint64_t v2 = __s;
  if (strchr(__s, 92)) {
    appendStringInfoChar(a1, 69);
  }
  appendStringInfoChar(a1, 39);
  while (1)
  {
    int v4 = *v2;
    char v5 = *v2;
    if (v4 == 39 || v4 == 92)
    {
      appendStringInfoChar(a1, v4);
      goto LABEL_5;
    }
    if (!*v2) {
      break;
    }
LABEL_5:
    appendStringInfoChar(a1, v5);
    ++v2;
  }

  return appendStringInfoChar(a1, 39);
}

void *deparseRoleList(void *result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      switch(*(_DWORD *)(v7 + 4))
      {
        case 0:
          uint64_t v8 = quote_identifier(*(unsigned char **)(v7 + 8));
          uint64_t v9 = v3;
          goto LABEL_10;
        case 1:
          uint64_t v9 = v3;
          uint64_t v8 = "CURRENT_USER";
          goto LABEL_10;
        case 2:
          uint64_t v9 = v3;
          uint64_t v8 = "SESSION_USER";
          goto LABEL_10;
        case 3:
          uint64_t v9 = v3;
          uint64_t v8 = "public";
LABEL_10:
          uint64_t result = appendStringInfoString(v9, v8);
          break;
        default:
          break;
      }
      uint64_t v10 = *(int *)(a2 + 4);
      if (v6 + v5) {
        BOOL v11 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v10);
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11)
      {
        uint64_t result = appendStringInfoString(v3, ", ");
        uint64_t v10 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v10);
  }
  return result;
}

void *deparseExpr(void *result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t)a2;
  uint64_t v9 = result;
  int v10 = *a2;
  unsigned int v11 = *a2 - 110;
  while (2)
  {
    switch(v11)
    {
      case 0u:
        appendStringInfoString((uint64_t)v9, "GROUPING(");
        uint64_t v21 = *(void *)(v8 + 8);
        if (v21 && *(int *)(v21 + 4) >= 1)
        {
          uint64_t v22 = 0;
          uint64_t v23 = 8;
          do
          {
            uint64_t v24 = *(void *)(v21 + 16);
            deparseExpr(v9, *(void *)(v24 + 8 * v22));
            uint64_t v25 = *(int *)(v21 + 4);
            if (v24 + v23) {
              BOOL v26 = v24 + v23 >= (unint64_t)(*(void *)(v21 + 16) + 8 * v25);
            }
            else {
              BOOL v26 = 1;
            }
            if (!v26)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v25 = *(int *)(v21 + 4);
            }
            ++v22;
            v23 += 8;
          }
          while (v22 < v25);
        }
        goto LABEL_142;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x19u:
      case 0x20u:
      case 0x21u:
LABEL_162:
        deparseExpr_cold_1();
      case 9u:
        int v12 = *(_DWORD *)(v8 + 4);
        if (v12 != 2)
        {
          if (v12 == 1)
          {
            uint64_t v55 = *(void *)(v8 + 8);
            if (v55 && *(int *)(v55 + 4) >= 1)
            {
              uint64_t v56 = 0;
              uint64_t v57 = 0;
              do
              {
                uint64_t v58 = *(void *)(v55 + 16);
                uint64_t v59 = *(_DWORD **)(v58 + v56);
                if (*v59 == 119 && v59[1] <= 1u)
                {
                  appendStringInfoChar((uint64_t)v9, 40);
                  deparseExpr(v9, *(void *)(v58 + v56));
                  uint64_t result = (void *)appendStringInfoChar((uint64_t)v9, 41);
                }
                else
                {
                  uint64_t result = (void *)deparseExpr(v9, v59);
                }
                if (v58 + v56 != -8
                  && v58 + v56 + 8 < (unint64_t)(*(void *)(*(void *)(v8 + 8) + 16)
                                                      + 8 * *(int *)(*(void *)(v8 + 8) + 4)))
                {
                  uint64_t result = appendStringInfoString((uint64_t)v9, " OR ");
                }
                ++v57;
                v56 += 8;
              }
              while (v57 < *(int *)(v55 + 4));
            }
          }
          else if (!v12)
          {
            uint64_t v15 = *(void *)(v8 + 8);
            if (v15)
            {
              if (*(int *)(v15 + 4) >= 1)
              {
                uint64_t v16 = 0;
                uint64_t v17 = 0;
                do
                {
                  uint64_t v18 = *(void *)(v15 + 16);
                  uint64_t v19 = *(_DWORD **)(v18 + v16);
                  if (*v19 == 119 && v19[1] <= 1u)
                  {
                    appendStringInfoChar((uint64_t)v9, 40);
                    deparseExpr(v9, *(void *)(v18 + v16));
                    uint64_t result = (void *)appendStringInfoChar((uint64_t)v9, 41);
                  }
                  else
                  {
                    uint64_t result = (void *)deparseExpr(v9, v19);
                  }
                  if (v18 + v16 != -8
                    && v18 + v16 + 8 < (unint64_t)(*(void *)(*(void *)(v8 + 8) + 16)
                                                        + 8 * *(int *)(*(void *)(v8 + 8) + 4)))
                  {
                    uint64_t result = appendStringInfoString((uint64_t)v9, " AND ");
                  }
                  ++v17;
                  v16 += 8;
                }
                while (v17 < *(int *)(v15 + 4));
              }
            }
          }
          return result;
        }
        uint64_t v13 = **(_DWORD ***)(*(void *)(v8 + 8) + 16);
        if (*v13 != 119)
        {
          uint64_t result = appendStringInfoString((uint64_t)v9, "NOT ");
LABEL_9:
          uint64_t v8 = **(void **)(*(void *)(v8 + 8) + 16);
          int v10 = *(_DWORD *)v8;
          unsigned int v11 = *(_DWORD *)v8 - 110;
          if (v11 > 0x23)
          {
LABEL_10:
            switch(v10)
            {
              case 346:
                return (void *)deparseAExpr((uint64_t)v9, v8);
              case 347:
                uint64_t v44 = **(void **)(*(void *)(v8 + 8) + 16);
                if (*(_DWORD *)v44 == 223)
                {
                  uint64_t v67 = quote_identifier(*(unsigned char **)(v44 + 8));
                  appendStringInfoString((uint64_t)v9, v67);
                }
                else if (*(_DWORD *)v44 == 351)
                {
                  appendStringInfoChar((uint64_t)v9, 42);
                }
                uint64_t v68 = *(void *)(v8 + 8);
                return (void *)deparseOptIndirection((uint64_t)v9, v68, 1);
              case 348:
                if (*(_DWORD *)(v8 + 4)) {
                  return (void *)appendStringInfo((uint64_t)v9, "$%d", a3, a4, a5, a6, a7, a8, *(unsigned int *)(v8 + 4));
                }
                uint64_t v53 = (uint64_t)v9;
                char v54 = 63;
                goto LABEL_143;
              case 349:
                return deparseValue(v9, (_DWORD *)(v8 + 8), 11, a4, a5, a6, a7, a8);
              case 350:
                return (void *)deparseFuncCall((uint64_t)v9, v8);
              case 353:
                return (void *)deparseAIndirection((uint64_t)v9, v8);
              case 354:
                appendStringInfoString((uint64_t)v9, "ARRAY[");
                uint64_t v45 = *(void *)(v8 + 8);
                if (v45 && *(int *)(v45 + 4) >= 1)
                {
                  uint64_t v46 = 0;
                  uint64_t v47 = 8;
                  do
                  {
                    uint64_t v48 = *(void *)(v45 + 16);
                    deparseExpr(v9, *(void *)(v48 + 8 * v46));
                    uint64_t v49 = *(int *)(v45 + 4);
                    if (v48 + v47) {
                      BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(v45 + 16) + 8 * v49);
                    }
                    else {
                      BOOL v50 = 1;
                    }
                    if (!v50)
                    {
                      appendStringInfoString((uint64_t)v9, ", ");
                      uint64_t v49 = *(int *)(v45 + 4);
                    }
                    ++v46;
                    v47 += 8;
                  }
                  while (v46 < v49);
                }
                uint64_t v53 = (uint64_t)v9;
                char v54 = 93;
                goto LABEL_143;
              case 357:
                return deparseTypeCast(v9, v8);
              case 358:
                return (void *)deparseCollateClause((uint64_t)v9, v8);
              case 385:
                appendStringInfoString((uint64_t)v9, "xmlserialize(");
                int v51 = *(_DWORD *)(v8 + 4);
                if (v51)
                {
                  if (v51 != 1) {
                    goto LABEL_153;
                  }
                  uint64_t v52 = "content ";
                }
                else
                {
                  uint64_t v52 = "document ";
                }
                appendStringInfoString((uint64_t)v9, v52);
LABEL_153:
                deparseExpr(v9, *(void *)(v8 + 8));
                appendStringInfoString((uint64_t)v9, " AS ");
                deparseTypeName(v9, *(void *)(v8 + 16));
                uint64_t v43 = ")";
                break;
              default:
                goto LABEL_162;
            }
LABEL_154:
            return appendStringInfoString((uint64_t)v9, v43);
          }
          continue;
        }
        int v14 = v13[1];
        if (v14)
        {
          uint64_t result = appendStringInfoString((uint64_t)v9, "NOT ");
          if (v14 == 1) {
            goto LABEL_129;
          }
          goto LABEL_9;
        }
        appendStringInfoString((uint64_t)v9, "NOT ");
LABEL_129:
        appendStringInfoChar((uint64_t)v9, 40);
        deparseExpr(v9, **(void **)(*(void *)(v8 + 8) + 16));
LABEL_142:
        uint64_t v53 = (uint64_t)v9;
        char v54 = 41;
LABEL_143:
        return (void *)appendStringInfoChar(v53, v54);
      case 0xAu:
        return (void *)deparseSubLink((uint64_t)v9, v8);
      case 0x14u:
        return deparseCaseExpr((uint64_t)v9, (void *)v8);
      case 0x18u:
        if (!*(_DWORD *)(v8 + 20)) {
          appendStringInfoString((uint64_t)v9, "ROW");
        }
        appendStringInfoString((uint64_t)v9, "(");
        uint64_t v27 = *(void *)(v8 + 8);
        if (v27 && *(int *)(v27 + 4) >= 1)
        {
          uint64_t v28 = 0;
          uint64_t v29 = 8;
          do
          {
            uint64_t v30 = *(void *)(v27 + 16);
            deparseExpr(v9, *(void *)(v30 + 8 * v28));
            uint64_t v31 = *(int *)(v27 + 4);
            if (v30 + v29) {
              BOOL v32 = v30 + v29 >= (unint64_t)(*(void *)(v27 + 16) + 8 * v31);
            }
            else {
              BOOL v32 = 1;
            }
            if (!v32)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v31 = *(int *)(v27 + 4);
            }
            ++v28;
            v29 += 8;
          }
          while (v28 < v31);
        }
        goto LABEL_142;
      case 0x1Au:
        appendStringInfoString((uint64_t)v9, "COALESCE(");
        uint64_t v33 = *(void *)(v8 + 16);
        if (v33 && *(int *)(v33 + 4) >= 1)
        {
          uint64_t v34 = 0;
          uint64_t v35 = 8;
          do
          {
            uint64_t v36 = *(void *)(v33 + 16);
            deparseExpr(v9, *(void *)(v36 + 8 * v34));
            uint64_t v37 = *(int *)(v33 + 4);
            if (v36 + v35) {
              BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(v33 + 16) + 8 * v37);
            }
            else {
              BOOL v38 = 1;
            }
            if (!v38)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v37 = *(int *)(v33 + 4);
            }
            ++v34;
            v35 += 8;
          }
          while (v34 < v37);
        }
        goto LABEL_142;
      case 0x1Bu:
        int v39 = *(_DWORD *)(v8 + 16);
        if (v39)
        {
          if (v39 != 1) {
            goto LABEL_133;
          }
          uint64_t v40 = "LEAST(";
        }
        else
        {
          uint64_t v40 = "GREATEST(";
        }
        appendStringInfoString((uint64_t)v9, v40);
LABEL_133:
        uint64_t v61 = *(void *)(v8 + 24);
        if (v61 && *(int *)(v61 + 4) >= 1)
        {
          uint64_t v62 = 0;
          uint64_t v63 = 8;
          do
          {
            uint64_t v64 = *(void *)(v61 + 16);
            deparseExpr(v9, *(void *)(v64 + 8 * v62));
            uint64_t v65 = *(int *)(v61 + 4);
            if (v64 + v63) {
              BOOL v66 = v64 + v63 >= (unint64_t)(*(void *)(v61 + 16) + 8 * v65);
            }
            else {
              BOOL v66 = 1;
            }
            if (!v66)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v65 = *(int *)(v61 + 4);
            }
            ++v62;
            v63 += 8;
          }
          while (v62 < v65);
        }
        goto LABEL_142;
      case 0x1Cu:
        uint64_t v41 = *(int *)(v8 + 4);
        if (v41 <= 0xE) {
          uint64_t result = appendStringInfoString((uint64_t)v9, (&off_1E55D8EB0)[v41]);
        }
        if (*(_DWORD *)(v8 + 12) != -1) {
          return (void *)appendStringInfo((uint64_t)v9, "(%d)", a3, a4, a5, a6, a7, a8, *(unsigned int *)(v8 + 12));
        }
        return result;
      case 0x1Du:
        return deparseXmlExpr(v9, v8);
      case 0x1Eu:
        uint64_t result = (void *)deparseExpr(v9, *(void *)(v8 + 8));
        int v42 = *(_DWORD *)(v8 + 16);
        if (v42 == 1)
        {
          uint64_t v43 = " IS NOT NULL";
        }
        else
        {
          if (v42) {
            return result;
          }
          uint64_t v43 = " IS NULL";
        }
        goto LABEL_154;
      case 0x1Fu:
        uint64_t result = (void *)deparseExpr(v9, *(void *)(v8 + 8));
        switch(*(_DWORD *)(v8 + 16))
        {
          case 0:
            uint64_t v43 = " IS TRUE";
            goto LABEL_154;
          case 1:
            uint64_t v43 = " IS NOT TRUE";
            goto LABEL_154;
          case 2:
            uint64_t v43 = " IS FALSE";
            goto LABEL_154;
          case 3:
            uint64_t v43 = " IS NOT FALSE";
            goto LABEL_154;
          case 4:
            uint64_t v43 = " IS UNKNOWN";
            goto LABEL_154;
          case 5:
            uint64_t v43 = " IS NOT UNKNOWN";
            goto LABEL_154;
          default:
            return result;
        }
        return result;
      case 0x22u:
        uint64_t v43 = "DEFAULT";
        goto LABEL_154;
      case 0x23u:
        appendStringInfoString((uint64_t)v9, "CURRENT OF ");
        uint64_t v43 = quote_identifier(*(unsigned char **)(v8 + 8));
        goto LABEL_154;
      default:
        goto LABEL_10;
    }
  }
}

unsigned char *deparseConstraint(_DWORD *a1, uint64_t a2)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfoString((uint64_t)a1, "CONSTRAINT ");
    appendStringInfoString((uint64_t)a1, *(char **)(a2 + 8));
    appendStringInfoChar((uint64_t)a1, 32);
  }
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      uint64_t v4 = "NULL ";
      goto LABEL_41;
    case 1:
      uint64_t v4 = "NOT NULL ";
      goto LABEL_41;
    case 2:
      appendStringInfoString((uint64_t)a1, "DEFAULT ");
      deparseExpr(a1, *(void *)(a2 + 32));
      goto LABEL_42;
    case 3:
      appendStringInfoString((uint64_t)a1, "GENERATED ");
      int v5 = *(char *)(a2 + 48);
      if (v5 == 97)
      {
        uint64_t v6 = "ALWAYS ";
      }
      else
      {
        if (v5 != 100) {
          goto LABEL_121;
        }
        uint64_t v6 = "BY DEFAULT ";
      }
      appendStringInfoString((uint64_t)a1, v6);
LABEL_121:
      appendStringInfoString((uint64_t)a1, "AS IDENTITY ");
      uint64_t v80 = *(void *)(a2 + 80);
      if (v80 && *(int *)(v80 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)a1, 40);
        if (*(int *)(v80 + 4) >= 1)
        {
          uint64_t v81 = 0;
          do
          {
            deparseSeqOptElem(a1, *(void *)(*(void *)(v80 + 16) + 8 * v81));
            appendStringInfoChar((uint64_t)a1, 32);
            ++v81;
          }
          while (v81 < *(int *)(v80 + 4));
        }
        appendStringInfoChar((uint64_t)a1, 41);
      }
      goto LABEL_42;
    case 4:
      appendStringInfoString((uint64_t)a1, "GENERATED ALWAYS AS (");
      deparseExpr(a1, *(void *)(a2 + 32));
      uint64_t v4 = ") STORED ";
      goto LABEL_41;
    case 5:
      appendStringInfoString((uint64_t)a1, "CHECK (");
      uint64_t v7 = *(void *)(a2 + 32);
      goto LABEL_40;
    case 6:
      uint64_t v4 = "PRIMARY KEY ";
      goto LABEL_41;
    case 7:
      uint64_t v4 = "UNIQUE ";
      goto LABEL_41;
    case 8:
      appendStringInfoString((uint64_t)a1, "EXCLUDE ");
      if (strcmp(*(const char **)(a2 + 112), "btree"))
      {
        appendStringInfoString((uint64_t)a1, "USING ");
        uint64_t v8 = quote_identifier(*(unsigned char **)(a2 + 112));
        appendStringInfoString((uint64_t)a1, v8);
        appendStringInfoChar((uint64_t)a1, 32);
      }
      appendStringInfoChar((uint64_t)a1, 40);
      uint64_t v15 = *(void *)(a2 + 72);
      if (!v15 || *(int *)(v15 + 4) < 1) {
        goto LABEL_38;
      }
      uint64_t v16 = 0;
      uint64_t v17 = 8;
      break;
    case 9:
      uint64_t v25 = *(void *)(a2 + 136);
      if (!v25 || *(int *)(v25 + 4) < 1) {
        goto LABEL_42;
      }
      uint64_t v4 = "FOREIGN KEY ";
      goto LABEL_41;
    case 0xA:
      uint64_t v4 = "DEFERRABLE ";
      goto LABEL_41;
    case 0xB:
      uint64_t v4 = "NOT DEFERRABLE ";
      goto LABEL_41;
    case 0xC:
      uint64_t v4 = "INITIALLY DEFERRED ";
      goto LABEL_41;
    case 0xD:
      uint64_t v4 = "INITIALLY IMMEDIATE ";
      goto LABEL_41;
    default:
      goto LABEL_42;
  }
  do
  {
    uint64_t v18 = *(void *)(v15 + 16);
    uint64_t v19 = *(void *)(v18 + 8 * v16);
    deparseIndexElem(a1, **(void **)(v19 + 16), v9, v10, v11, v12, v13, v14);
    appendStringInfoString((uint64_t)a1, " WITH ");
    uint64_t v20 = *(void *)(*(void *)(v19 + 16) + 8);
    if (!v20) {
      goto LABEL_26;
    }
    int v21 = *(_DWORD *)(v20 + 4);
    if (v21 == 1)
    {
      uint64_t v23 = *(void *)(v20 + 16);
    }
    else
    {
      if (v21 != 2) {
        goto LABEL_26;
      }
      uint64_t v22 = quote_identifier(*(unsigned char **)(**(void **)(v20 + 16) + 8));
      appendStringInfoString((uint64_t)a1, v22);
      appendStringInfoChar((uint64_t)a1, 46);
      uint64_t v23 = *(void *)(v20 + 16) + 8 * (*(_DWORD *)(v20 + 4) - 1);
    }
    appendStringInfoString((uint64_t)a1, *(char **)(*(void *)v23 + 8));
LABEL_26:
    if (v18 + v17) {
      BOOL v24 = v18 + v17 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
    }
                                          + 8 * *(int *)(*(void *)(a2 + 72) + 4));
    else {
      BOOL v24 = 1;
    }
    if (!v24) {
      appendStringInfoString((uint64_t)a1, ", ");
    }
    ++v16;
    v17 += 8;
  }
  while (v16 < *(int *)(v15 + 4));
LABEL_38:
  appendStringInfoString((uint64_t)a1, ") ");
  if (*(void *)(a2 + 120))
  {
    appendStringInfoString((uint64_t)a1, "WHERE (");
    uint64_t v7 = *(void *)(a2 + 120);
LABEL_40:
    deparseExpr(a1, v7);
    uint64_t v4 = ") ";
LABEL_41:
    appendStringInfoString((uint64_t)a1, v4);
  }
LABEL_42:
  uint64_t v26 = *(void *)(a2 + 56);
  if (v26 && *(int *)(v26 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v27 = *(void *)(a2 + 56);
    if (v27 && *(int *)(v27 + 4) >= 1)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 8;
      do
      {
        uint64_t v30 = *(void *)(v27 + 16);
        uint64_t v31 = quote_identifier(*(unsigned char **)(*(void *)(v30 + 8 * v28) + 8));
        appendStringInfoString((uint64_t)a1, v31);
        uint64_t v32 = *(int *)(v27 + 4);
        if (v30 + v29) {
          BOOL v33 = v30 + v29 >= (unint64_t)(*(void *)(v27 + 16) + 8 * v32);
        }
        else {
          BOOL v33 = 1;
        }
        if (!v33)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v32 = *(int *)(v27 + 4);
        }
        ++v28;
        v29 += 8;
      }
      while (v28 < v32);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  uint64_t v34 = *(void *)(a2 + 136);
  if (v34 && *(int *)(v34 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v35 = *(void *)(a2 + 136);
    if (v35 && *(int *)(v35 + 4) >= 1)
    {
      uint64_t v36 = 0;
      uint64_t v37 = 8;
      do
      {
        uint64_t v38 = *(void *)(v35 + 16);
        int v39 = quote_identifier(*(unsigned char **)(*(void *)(v38 + 8 * v36) + 8));
        appendStringInfoString((uint64_t)a1, v39);
        uint64_t v40 = *(int *)(v35 + 4);
        if (v38 + v37) {
          BOOL v41 = v38 + v37 >= (unint64_t)(*(void *)(v35 + 16) + 8 * v40);
        }
        else {
          BOOL v41 = 1;
        }
        if (!v41)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v40 = *(int *)(v35 + 4);
        }
        ++v36;
        v37 += 8;
      }
      while (v36 < v40);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  if (*(void *)(a2 + 128))
  {
    appendStringInfoString((uint64_t)a1, "REFERENCES ");
    deparseRangeVar((uint64_t)a1, *(void *)(a2 + 128), 0);
    appendStringInfoChar((uint64_t)a1, 32);
    uint64_t v42 = *(void *)(a2 + 144);
    if (v42)
    {
      if (*(int *)(v42 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)a1, 40);
        uint64_t v43 = *(void *)(a2 + 144);
        if (v43 && *(int *)(v43 + 4) >= 1)
        {
          uint64_t v44 = 0;
          uint64_t v45 = 8;
          do
          {
            uint64_t v46 = *(void *)(v43 + 16);
            uint64_t v47 = quote_identifier(*(unsigned char **)(*(void *)(v46 + 8 * v44) + 8));
            appendStringInfoString((uint64_t)a1, v47);
            uint64_t v48 = *(int *)(v43 + 4);
            if (v46 + v45) {
              BOOL v49 = v46 + v45 >= (unint64_t)(*(void *)(v43 + 16) + 8 * v48);
            }
            else {
              BOOL v49 = 1;
            }
            if (!v49)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              uint64_t v48 = *(int *)(v43 + 4);
            }
            ++v44;
            v45 += 8;
          }
          while (v44 < v48);
        }
        appendStringInfoString((uint64_t)a1, ") ");
      }
    }
  }
  if (*(unsigned char *)(a2 + 152) == 102) {
    appendStringInfoString((uint64_t)a1, "MATCH FULL ");
  }
  BOOL v50 = "ON UPDATE RESTRICT ";
  switch(*(unsigned char *)(a2 + 153))
  {
    case 'c':
      BOOL v50 = "ON UPDATE CASCADE ";
      goto LABEL_85;
    case 'd':
      BOOL v50 = "ON UPDATE SET DEFAULT ";
      goto LABEL_85;
    case 'n':
      BOOL v50 = "ON UPDATE SET NULL ";
      goto LABEL_85;
    case 'r':
LABEL_85:
      appendStringInfoString((uint64_t)a1, v50);
      break;
    default:
      break;
  }
  int v51 = "ON DELETE RESTRICT ";
  switch(*(unsigned char *)(a2 + 154))
  {
    case 'c':
      int v51 = "ON DELETE CASCADE ";
      goto LABEL_90;
    case 'd':
      int v51 = "ON DELETE SET DEFAULT ";
      goto LABEL_90;
    case 'n':
      int v51 = "ON DELETE SET NULL ";
      goto LABEL_90;
    case 'r':
LABEL_90:
      appendStringInfoString((uint64_t)a1, v51);
      break;
    default:
      break;
  }
  uint64_t v52 = *(void *)(a2 + 64);
  if (v52 && *(int *)(v52 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "INCLUDE (");
    uint64_t v53 = *(void *)(a2 + 64);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      uint64_t v54 = 0;
      uint64_t v55 = 8;
      do
      {
        uint64_t v56 = *(void *)(v53 + 16);
        uint64_t v57 = quote_identifier(*(unsigned char **)(*(void *)(v56 + 8 * v54) + 8));
        appendStringInfoString((uint64_t)a1, v57);
        uint64_t v58 = *(int *)(v53 + 4);
        if (v56 + v55) {
          BOOL v59 = v56 + v55 >= (unint64_t)(*(void *)(v53 + 16) + 8 * v58);
        }
        else {
          BOOL v59 = 1;
        }
        if (!v59)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v58 = *(int *)(v53 + 4);
        }
        ++v54;
        v55 += 8;
      }
      while (v54 < v58);
    }
    appendStringInfoString((uint64_t)a1, ") ");
  }
  uint64_t v60 = *(unsigned char **)(a2 + 88);
  if (v60)
  {
    uint64_t v61 = quote_identifier(v60);
    appendStringInfo((uint64_t)a1, "USING INDEX %s ", v62, v63, v64, v65, v66, v67, (size_t)v61);
  }
  uint64_t result = *(unsigned char **)(a2 + 96);
  if (result)
  {
    uint64_t v69 = quote_identifier(result);
    uint64_t result = (unsigned char *)appendStringInfo((uint64_t)a1, "USING INDEX TABLESPACE %s ", v70, v71, v72, v73, v74, v75, (size_t)v69);
  }
  if (*(unsigned char *)(a2 + 16)) {
    uint64_t result = appendStringInfoString((uint64_t)a1, "DEFERRABLE ");
  }
  if (*(unsigned char *)(a2 + 17)) {
    uint64_t result = appendStringInfoString((uint64_t)a1, "INITIALLY DEFERRED ");
  }
  if (*(unsigned char *)(a2 + 24)) {
    uint64_t result = appendStringInfoString((uint64_t)a1, "NO INHERIT ");
  }
  if (*(unsigned char *)(a2 + 172)) {
    uint64_t result = appendStringInfoString((uint64_t)a1, "NOT VALID ");
  }
  int v76 = a1[2];
  BOOL v77 = __OFSUB__(v76, 1);
  uint64_t v78 = (v76 - 1);
  if ((int)v78 < 0 == v77)
  {
    uint64_t v79 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v78) == 32)
    {
      a1[2] = v78;
      *(unsigned char *)(v79 + v78) = 0;
    }
  }
  return result;
}

uint64_t deparseFuncCall(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    int v5 = *(_DWORD *)(v4 + 4);
    if (v5 == 2)
    {
      uint64_t v6 = *(void **)(v4 + 16);
      if (!strcmp(*(const char **)(*v6 + 8), "pg_catalog") && !strcmp(*(const char **)(v6[1] + 8), "overlay"))
      {
        uint64_t v7 = *(void *)(a2 + 16);
        if (v7)
        {
          if (*(_DWORD *)(v7 + 4) == 4)
          {
            appendStringInfoString(a1, "OVERLAY(");
            deparseExpr(a1, **(void **)(*(void *)(a2 + 16) + 16));
            appendStringInfoString(a1, " PLACING ");
            deparseExpr(a1, *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8));
            appendStringInfoString(a1, " FROM ");
            deparseExpr(a1, *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 16));
            appendStringInfoString(a1, " FOR ");
            deparseExpr(a1, *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 24));
            return appendStringInfoChar(a1, 41);
          }
        }
      }
    }
    else if (v5 < 1)
    {
      goto LABEL_18;
    }
    uint64_t v9 = 0;
    uint64_t v10 = 8;
    do
    {
      uint64_t v11 = *(void *)(v4 + 16);
      uint64_t v12 = quote_identifier(*(unsigned char **)(*(void *)(v11 + 8 * v9) + 8));
      appendStringInfoString(a1, v12);
      uint64_t v13 = *(int *)(v4 + 4);
      if (v11 + v10) {
        BOOL v14 = v11 + v10 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v13);
      }
      else {
        BOOL v14 = 1;
      }
      if (!v14)
      {
        appendStringInfoChar(a1, 46);
        uint64_t v13 = *(int *)(v4 + 4);
      }
      ++v9;
      v10 += 8;
    }
    while (v9 < v13);
  }
LABEL_18:
  appendStringInfoChar(a1, 40);
  if (*(unsigned char *)(a2 + 42)) {
    appendStringInfoString(a1, "DISTINCT ");
  }
  if (*(unsigned char *)(a2 + 41))
  {
    appendStringInfoChar(a1, 42);
  }
  else
  {
    uint64_t v27 = *(void *)(a2 + 16);
    if (v27 && *(int *)(v27 + 4) >= 1)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 8;
      do
      {
        uint64_t v30 = *(void *)(v27 + 16);
        if (*(unsigned char *)(a2 + 43))
        {
          if (!(v30 + v29)
            || v30 + v29 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
                                             + 8 * *(int *)(*(void *)(a2 + 16) + 4)))
          {
            appendStringInfoString(a1, "VARIADIC ");
          }
        }
        uint64_t v32 = *(void *)(v30 + 8 * v28);
        if (*(_DWORD *)v32 == 114)
        {
          appendStringInfoString(a1, *(char **)(v32 + 16));
          appendStringInfoString(a1, " := ");
          uint64_t v33 = *(void *)(v32 + 8);
          uint64_t v34 = a1;
        }
        else
        {
          uint64_t v34 = a1;
          uint64_t v33 = *(void *)(v30 + 8 * v28);
        }
        deparseExpr(v34, v33);
        if (v30 + v29) {
          BOOL v35 = v30 + v29 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v35 = 1;
        }
        if (!v35) {
          appendStringInfoString(a1, ", ");
        }
        ++v28;
        v29 += 8;
      }
      while (v28 < *(int *)(v27 + 4));
    }
  }
  appendStringInfoChar(a1, 32);
  uint64_t v15 = *(void *)(a2 + 24);
  if (v15 && !*(unsigned char *)(a2 + 40)) {
    deparseOptSortClause(a1, v15);
  }
  int v16 = *(_DWORD *)(a1 + 8);
  BOOL v17 = __OFSUB__(v16, 1);
  uint64_t v18 = (v16 - 1);
  if ((int)v18 < 0 == v17)
  {
    uint64_t v19 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v18) == 32)
    {
      *(_DWORD *)(a1 + 8) = v18;
      *(unsigned char *)(v19 + v18) = 0;
    }
  }
  uint64_t result = (uint64_t)appendStringInfoString(a1, ") ");
  if (*(void *)(a2 + 24) && *(unsigned char *)(a2 + 40))
  {
    appendStringInfoString(a1, "WITHIN GROUP (");
    deparseOptSortClause(a1, *(void *)(a2 + 24));
    int v20 = *(_DWORD *)(a1 + 8);
    BOOL v17 = __OFSUB__(v20, 1);
    uint64_t v21 = (v20 - 1);
    if ((int)v21 < 0 == v17)
    {
      uint64_t v22 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v21) == 32)
      {
        *(_DWORD *)(a1 + 8) = v21;
        *(unsigned char *)(v22 + v21) = 0;
      }
    }
    uint64_t result = (uint64_t)appendStringInfoString(a1, ") ");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfoString(a1, "FILTER (WHERE ");
    deparseExpr(a1, *(void *)(a2 + 32));
    uint64_t result = (uint64_t)appendStringInfoString(a1, ") ");
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfoString(a1, "OVER ");
    uint64_t v23 = *(void *)(a2 + 48);
    if (!*(void *)(v23 + 8))
    {
      uint64_t result = deparseWindowDef(a1, v23);
      int v36 = *(_DWORD *)(a1 + 8);
      BOOL v17 = __OFSUB__(v36, 1);
      uint64_t v25 = (v36 - 1);
      if ((int)v25 < 0 != v17) {
        return result;
      }
      goto LABEL_40;
    }
    uint64_t result = (uint64_t)appendStringInfoString(a1, *(char **)(v23 + 8));
  }
  int v24 = *(_DWORD *)(a1 + 8);
  BOOL v17 = __OFSUB__(v24, 1);
  uint64_t v25 = (v24 - 1);
  if ((int)v25 < 0 != v17) {
    return result;
  }
LABEL_40:
  uint64_t v26 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + v25) == 32)
  {
    *(_DWORD *)(a1 + 8) = v25;
    *(unsigned char *)(v26 + v25) = 0;
  }
  return result;
}

void *deparseXmlExpr(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      appendStringInfoString((uint64_t)result, "xmlconcat(");
      uint64_t v4 = *(void *)(a2 + 32);
      if (v4 && *(int *)(v4 + 4) >= 1)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 8;
        do
        {
          uint64_t v7 = *(void *)(v4 + 16);
          deparseExpr(v3, *(void *)(v7 + 8 * v5));
          uint64_t v8 = *(int *)(v4 + 4);
          if (v7 + v6) {
            BOOL v9 = v7 + v6 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v8);
          }
          else {
            BOOL v9 = 1;
          }
          if (!v9)
          {
            appendStringInfoString((uint64_t)v3, ", ");
            uint64_t v8 = *(int *)(v4 + 4);
          }
          ++v5;
          v6 += 8;
        }
        while (v5 < v8);
      }
      goto LABEL_44;
    case 1:
      appendStringInfoString((uint64_t)result, "xmlelement(name ");
      uint64_t v10 = quote_identifier(*(unsigned char **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v10);
      if (*(void *)(a2 + 16))
      {
        appendStringInfoString((uint64_t)v3, ", xmlattributes(");
        deparseXmlAttributeList(v3, *(void *)(a2 + 16));
        appendStringInfoString((uint64_t)v3, ")");
      }
      if (*(void *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v3, ", ");
        uint64_t v11 = *(void *)(a2 + 32);
        if (v11)
        {
          if (*(int *)(v11 + 4) >= 1)
          {
            uint64_t v12 = 0;
            uint64_t v13 = 8;
            do
            {
              uint64_t v14 = *(void *)(v11 + 16);
              deparseExpr(v3, *(void *)(v14 + 8 * v12));
              uint64_t v15 = *(int *)(v11 + 4);
              if (v14 + v13) {
                BOOL v16 = v14 + v13 >= (unint64_t)(*(void *)(v11 + 16) + 8 * v15);
              }
              else {
                BOOL v16 = 1;
              }
              if (!v16)
              {
                appendStringInfoString((uint64_t)v3, ", ");
                uint64_t v15 = *(int *)(v11 + 4);
              }
              ++v12;
              v13 += 8;
            }
            while (v12 < v15);
          }
        }
      }
      uint64_t v22 = ")";
      goto LABEL_34;
    case 2:
      appendStringInfoString((uint64_t)result, "xmlforest(");
      deparseXmlAttributeList(v3, *(void *)(a2 + 16));
      goto LABEL_44;
    case 3:
      appendStringInfoString((uint64_t)result, "xmlparse(");
      int v17 = *(_DWORD *)(a2 + 40);
      if (v17)
      {
        if (v17 != 1) {
          goto LABEL_41;
        }
        uint64_t v18 = "content ";
      }
      else
      {
        uint64_t v18 = "document ";
      }
      appendStringInfoString((uint64_t)v3, v18);
LABEL_41:
      deparseExpr(v3, **(void **)(*(void *)(a2 + 32) + 16));
      if (strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8) + 8) + 16), "t"))
      {
        goto LABEL_44;
      }
      uint64_t v23 = " PRESERVE WHITESPACE";
      goto LABEL_43;
    case 4:
      appendStringInfoString((uint64_t)result, "xmlpi(name ");
      uint64_t v19 = quote_identifier(*(unsigned char **)(a2 + 8));
      appendStringInfoString((uint64_t)v3, v19);
      if (*(void *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v3, ", ");
        deparseExpr(v3, **(void **)(*(void *)(a2 + 32) + 16));
      }
      goto LABEL_44;
    case 5:
      appendStringInfoString((uint64_t)result, "xmlroot(");
      deparseExpr(v3, **(void **)(*(void *)(a2 + 32) + 16));
      appendStringInfoString((uint64_t)v3, ", version ");
      uint64_t v20 = *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8);
      if (*(_DWORD *)(v20 + 8) == 225)
      {
        appendStringInfoString((uint64_t)v3, "NO VALUE");
        uint64_t v21 = *(int *)(*(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 16) + 16);
        if (v21 > 2) {
          goto LABEL_44;
        }
      }
      else
      {
        deparseExpr(v3, v20);
        uint64_t v21 = *(int *)(*(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 16) + 16);
        if (v21 > 2) {
          goto LABEL_44;
        }
      }
      uint64_t v23 = (&off_1E55D8E98)[v21];
LABEL_43:
      appendStringInfoString((uint64_t)v3, v23);
LABEL_44:
      return (void *)appendStringInfoChar((uint64_t)v3, 41);
    case 7:
      deparseExpr(result, **(void **)(*(void *)(a2 + 32) + 16));
      uint64_t v22 = " IS DOCUMENT";
LABEL_34:
      return appendStringInfoString((uint64_t)v3, v22);
    default:
      return result;
  }
}

void *deparseTypeCast(void *a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD **)(a2 + 8);
  if (*v4 != 349)
  {
    if (*v4 == 346)
    {
      appendStringInfoString((uint64_t)a1, "CAST(");
      deparseExpr(a1, *(void *)(a2 + 8));
      appendStringInfoString((uint64_t)a1, " AS ");
      deparseTypeName(a1, *(void *)(a2 + 16));
      return (void *)appendStringInfoChar((uint64_t)a1, 41);
    }
    goto LABEL_18;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(v6 + 8);
  if (!v7) {
    goto LABEL_15;
  }
  if (*(_DWORD *)(v7 + 4) != 2) {
    goto LABEL_15;
  }
  uint64_t v8 = *(void **)(v7 + 16);
  if (strcmp(*(const char **)(*v8 + 8), "pg_catalog")) {
    goto LABEL_15;
  }
  BOOL v9 = *(const char **)(v8[1] + 8);
  if (!strcmp(v9, "bpchar") && !*(void *)(v6 + 24))
  {
    appendStringInfoString((uint64_t)a1, "char ");
    return deparseValue(a1, v4 + 2, 11, v13, v14, v15, v16, v17);
  }
  if (strcmp(v9, "BOOL") || v4[2] != 223)
  {
LABEL_15:
    int v11 = v4[2];
    if (v11 == 222 || v11 == 221 && (v4[4] & 0x80000000) != 0)
    {
      appendStringInfoChar((uint64_t)a1, 40);
      deparseExpr(a1, *(void *)(a2 + 8));
      appendStringInfoChar((uint64_t)a1, 41);
      goto LABEL_20;
    }
LABEL_18:
    deparseExpr(a1, v4);
LABEL_20:
    appendStringInfoString((uint64_t)a1, "::");
    uint64_t v12 = *(void *)(a2 + 16);
    return deparseTypeName(a1, v12);
  }
  uint64_t v10 = (const char *)*((void *)v4 + 2);
  if (!strcmp(v10, "t"))
  {
    uint64_t v18 = "true";
  }
  else
  {
    if (strcmp(v10, "f")) {
      goto LABEL_15;
    }
    uint64_t v18 = "false";
  }

  return appendStringInfoString((uint64_t)a1, v18);
}

uint64_t deparseAExpr(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (void *)result;
  uint64_t v4 = *(_DWORD **)(a2 + 16);
  if (!v4)
  {
    int v6 = 0;
    uint64_t v7 = *(int **)(a2 + 24);
    if (v7) {
      goto LABEL_8;
    }
LABEL_16:
    int v10 = 0;
    unsigned int v11 = *(_DWORD *)(a2 + 4);
LABEL_17:
    switch(v11)
    {
      case 0u:
        if (v4)
        {
          if (v6)
          {
            appendStringInfoChar(result, 40);
            deparseExpr(v3, *(void *)(a2 + 16));
            appendStringInfoChar((uint64_t)v3, 41);
          }
          else
          {
            deparseExpr(result, v4);
          }
          appendStringInfoChar((uint64_t)v3, 32);
        }
        uint64_t result = (uint64_t)deparseQualOp((uint64_t)v3, *(void *)(a2 + 8));
        if (*(void *)(a2 + 24))
        {
          appendStringInfoChar((uint64_t)v3, 32);
          if (!v10) {
            goto LABEL_81;
          }
          goto LABEL_94;
        }
        return result;
      case 1u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(void *)(a2 + 8));
        uint64_t v17 = " ANY(";
        goto LABEL_37;
      case 2u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(void *)(a2 + 8));
        uint64_t v17 = " ALL(";
        goto LABEL_37;
      case 3u:
        if (v6)
        {
          appendStringInfoChar(result, 40);
          deparseExpr(v3, *(void *)(a2 + 16));
          appendStringInfoChar((uint64_t)v3, 41);
          appendStringInfoString((uint64_t)v3, " IS DISTINCT FROM ");
          if (!v10) {
            goto LABEL_81;
          }
        }
        else
        {
          deparseExpr(result, v4);
          appendStringInfoString((uint64_t)v3, " IS DISTINCT FROM ");
          if (!v10) {
            goto LABEL_81;
          }
        }
LABEL_94:
        appendStringInfoChar((uint64_t)v3, 40);
LABEL_95:
        deparseExpr(v3, *(void *)(a2 + 24));
        goto LABEL_96;
      case 4u:
        deparseExpr(result, v4);
        uint64_t v18 = " IS NOT DISTINCT FROM ";
        goto LABEL_80;
      case 5u:
        appendStringInfoString(result, "NULLIF(");
        deparseExpr(v3, *(void *)(a2 + 16));
        uint64_t v17 = ", ";
LABEL_37:
        appendStringInfoString((uint64_t)v3, v17);
        goto LABEL_95;
      case 6u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v19 = *(const char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8);
        if (!strcmp(v19, "="))
        {
          uint64_t v20 = "IS OF ";
        }
        else
        {
          if (strcmp(v19, "<>")) {
            goto LABEL_57;
          }
          uint64_t v20 = "IS NOT OF ";
        }
        appendStringInfoString((uint64_t)v3, v20);
LABEL_57:
        appendStringInfoChar((uint64_t)v3, 40);
        uint64_t v27 = *(void *)(a2 + 24);
        if (v27 && *(int *)(v27 + 4) >= 1)
        {
          uint64_t v28 = 0;
          uint64_t v29 = 8;
          do
          {
            uint64_t v30 = *(void *)(v27 + 16);
            deparseTypeName(v3, *(void *)(v30 + 8 * v28));
            uint64_t v31 = *(int *)(v27 + 4);
            if (v30 + v29) {
              BOOL v32 = v30 + v29 >= (unint64_t)(*(void *)(v27 + 16) + 8 * v31);
            }
            else {
              BOOL v32 = 1;
            }
            if (!v32)
            {
              appendStringInfoString((uint64_t)v3, ", ");
              uint64_t v31 = *(int *)(v27 + 4);
            }
            ++v28;
            v29 += 8;
          }
          while (v28 < v31);
        }
        goto LABEL_96;
      case 7u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v21 = *(const char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8);
        if (!strcmp(v21, "="))
        {
          uint64_t v22 = "IN ";
        }
        else
        {
          if (strcmp(v21, "<>")) {
            goto LABEL_68;
          }
          uint64_t v22 = "NOT IN ";
        }
        appendStringInfoString((uint64_t)v3, v22);
LABEL_68:
        appendStringInfoChar((uint64_t)v3, 40);
        uint64_t v33 = *(void *)(a2 + 24);
        if (*(_DWORD *)v33 == 120)
        {
          deparseSubLink((uint64_t)v3, v33);
        }
        else if (*(int *)(v33 + 4) >= 1)
        {
          uint64_t v34 = 0;
          uint64_t v35 = 8;
          do
          {
            uint64_t v36 = *(void *)(v33 + 16);
            deparseExpr(v3, *(void *)(v36 + 8 * v34));
            uint64_t v37 = *(int *)(v33 + 4);
            if (v36 + v35) {
              BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(v33 + 16) + 8 * v37);
            }
            else {
              BOOL v38 = 1;
            }
            if (!v38)
            {
              appendStringInfoString((uint64_t)v3, ", ");
              uint64_t v37 = *(int *)(v33 + 4);
            }
            ++v34;
            v35 += 8;
          }
          while (v34 < v37);
        }
LABEL_96:
        return appendStringInfoChar((uint64_t)v3, 41);
      case 8u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v23 = *(const char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8);
        if (!strcmp(v23, "~~"))
        {
          uint64_t v18 = "LIKE ";
        }
        else
        {
          if (strcmp(v23, "!~~")) {
            goto LABEL_81;
          }
          uint64_t v18 = "NOT LIKE ";
        }
        goto LABEL_80;
      case 9u:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        int v24 = *(const char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8);
        if (!strcmp(v24, "~~*"))
        {
          uint64_t v18 = "ILIKE ";
        }
        else
        {
          if (strcmp(v24, "!~~*")) {
            goto LABEL_81;
          }
          uint64_t v18 = "NOT ILIKE ";
        }
LABEL_80:
        appendStringInfoString((uint64_t)v3, v18);
LABEL_81:
        uint64_t v39 = *(void *)(a2 + 24);
        goto LABEL_82;
      case 0xAu:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v25 = *(const char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8);
        if (!strcmp(v25, "~"))
        {
          uint64_t v26 = "SIMILAR TO ";
        }
        else
        {
          if (strcmp(v25, "!~")) {
            goto LABEL_87;
          }
          uint64_t v26 = "NOT SIMILAR TO ";
        }
        appendStringInfoString((uint64_t)v3, v26);
LABEL_87:
        uint64_t v40 = *(void *)(a2 + 24);
        uint64_t result = deparseExpr(v3, **(void **)(*(void *)(v40 + 16) + 16));
        uint64_t v41 = *(void *)(v40 + 16);
        if (v41 && *(_DWORD *)(v41 + 4) == 2)
        {
          appendStringInfoString((uint64_t)v3, " ESCAPE ");
          uint64_t v39 = *(void *)(*(void *)(*(void *)(v40 + 16) + 16) + 8);
LABEL_82:
          uint64_t result = deparseExpr(v3, v39);
        }
        break;
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        deparseExpr(result, v4);
        appendStringInfoChar((uint64_t)v3, 32);
        appendStringInfoString((uint64_t)v3, *(char **)(**(void **)(*(void *)(a2 + 8) + 16) + 8));
        uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
        uint64_t v12 = *(void *)(a2 + 24);
        if (v12 && *(int *)(v12 + 4) >= 1)
        {
          uint64_t v13 = 0;
          uint64_t v14 = 8;
          do
          {
            uint64_t v15 = *(void *)(v12 + 16);
            uint64_t result = deparseExpr(v3, *(void *)(v15 + 8 * v13));
            if (v15 + v14) {
              BOOL v16 = v15 + v14 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
            }
                                                  + 8 * *(int *)(*(void *)(a2 + 24) + 4));
            else {
              BOOL v16 = 1;
            }
            if (!v16) {
              uint64_t result = (uint64_t)appendStringInfoString((uint64_t)v3, " AND ");
            }
            ++v13;
            v14 += 8;
          }
          while (v13 < *(int *)(v12 + 4));
        }
        return result;
      default:
        return result;
    }
    return result;
  }
  BOOL v5 = *v4 == 346;
  if (*v4 == 140) {
    BOOL v5 = 1;
  }
  int v6 = *v4 == 119 || v5;
  uint64_t v7 = *(int **)(a2 + 24);
  if (!v7) {
    goto LABEL_16;
  }
LABEL_8:
  int v8 = *v7;
  BOOL v9 = v8 == 346;
  if (v8 == 140) {
    BOOL v9 = 1;
  }
  int v10 = v8 == 119 || v9;
  unsigned int v11 = *(_DWORD *)(a2 + 4);
  if (v11 <= 0xE) {
    goto LABEL_17;
  }
  return result;
}

void *deparseCaseExpr(uint64_t a1, void *a2)
{
  appendStringInfoString(a1, "CASE ");
  uint64_t v4 = a2[2];
  if (v4)
  {
    deparseExpr(a1, v4);
    appendStringInfoChar(a1, 32);
  }
  uint64_t v5 = a2[3];
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(v5 + 16) + 8 * v6);
      appendStringInfoString(a1, "WHEN ");
      deparseExpr(a1, *(void *)(v7 + 8));
      appendStringInfoString(a1, " THEN ");
      deparseExpr(a1, *(void *)(v7 + 16));
      appendStringInfoChar(a1, 32);
      ++v6;
    }
    while (v6 < *(int *)(v5 + 4));
  }
  if (a2[4])
  {
    appendStringInfoString(a1, "ELSE ");
    deparseExpr(a1, a2[4]);
    appendStringInfoChar(a1, 32);
  }

  return appendStringInfoString(a1, "END");
}

uint64_t deparseSubLink(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (_DWORD *)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      uint64_t v4 = "EXISTS (";
      goto LABEL_9;
    case 1:
      deparseExpr(result, *(void *)(a2 + 16));
      appendStringInfoChar((uint64_t)v3, 32);
      deparseSubqueryOp((uint64_t)v3, *(void *)(a2 + 24));
      uint64_t v4 = " ALL (";
      goto LABEL_9;
    case 2:
      deparseExpr(result, *(void *)(a2 + 16));
      uint64_t v5 = *(void *)(a2 + 24);
      if (v5 && *(int *)(v5 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)v3, 32);
        deparseSubqueryOp((uint64_t)v3, *(void *)(a2 + 24));
        uint64_t v6 = " ANY ";
      }
      else
      {
        uint64_t v6 = " IN ";
      }
      appendStringInfoString((uint64_t)v3, v6);
      appendStringInfoChar((uint64_t)v3, 40);
      goto LABEL_12;
    case 4:
      uint64_t v4 = "(";
      goto LABEL_9;
    case 6:
      uint64_t v4 = "ARRAY(";
LABEL_9:
      appendStringInfoString((uint64_t)v3, v4);
LABEL_12:
      deparseSelectStmt(v3, *(void *)(a2 + 32));
      uint64_t result = appendStringInfoChar((uint64_t)v3, 41);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t deparseAIndirection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD **)(a2 + 8);
  unsigned int v5 = *v4 - 346;
  if (v5 > 0xB) {
    goto LABEL_7;
  }
  if (((1 << v5) & 0x891) != 0)
  {
LABEL_3:
    appendStringInfoChar(a1, 40);
    deparseExpr(a1, *(void *)(a2 + 8));
    appendStringInfoChar(a1, 41);
    goto LABEL_9;
  }
  if (*v4 == 347)
  {
    if (***(_DWORD ***)(*(void *)(a2 + 16) + 16) != 352) {
      goto LABEL_3;
    }
  }
  else
  {
LABEL_7:
    if (*v4 == 134) {
      goto LABEL_3;
    }
  }
  deparseExpr(a1, v4);
LABEL_9:
  uint64_t v6 = *(void *)(a2 + 16);

  return deparseOptIndirection(a1, v6, 0);
}

uint64_t deparseCollateClause(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD **)(a2 + 8);
  if (v4)
  {
    if (*v4 == 346)
    {
      appendStringInfoChar(a1, 40);
      deparseExpr(a1, *(void *)(a2 + 8));
      appendStringInfoChar(a1, 41);
    }
    else
    {
      deparseExpr(a1, v4);
    }
    appendStringInfoChar(a1, 32);
  }
  uint64_t result = (uint64_t)appendStringInfoString(a1, "COLLATE ");
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      uint64_t v9 = *(void *)(v6 + 16);
      int v10 = quote_identifier(*(unsigned char **)(*(void *)(v9 + 8 * v7) + 8));
      uint64_t result = (uint64_t)appendStringInfoString(a1, v10);
      uint64_t v11 = *(int *)(v6 + 4);
      if (v9 + v8) {
        BOOL v12 = v9 + v8 >= (unint64_t)(*(void *)(v6 + 16) + 8 * v11);
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12)
      {
        uint64_t result = appendStringInfoChar(a1, 46);
        uint64_t v11 = *(int *)(v6 + 4);
      }
      ++v7;
      v8 += 8;
    }
    while (v7 < v11);
  }
  return result;
}

uint64_t deparseOptSortClause(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    appendStringInfoString(result, "ORDER BY ");
    if (*(int *)(a2 + 4) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a2 + 16);
        uint64_t v7 = *(void *)(v6 + 8 * v4);
        deparseExpr(v3, *(void *)(v7 + 8));
        appendStringInfoChar(v3, 32);
        int v8 = *(_DWORD *)(v7 + 16);
        switch(v8)
        {
          case 3:
            appendStringInfoString(v3, "USING ");
            deparseQualOp(v3, *(void *)(v7 + 24));
            int v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1)
            {
LABEL_16:
              int v10 = "NULLS FIRST ";
              goto LABEL_17;
            }
            break;
          case 2:
            appendStringInfoString(v3, "DESC ");
            break;
          case 1:
            appendStringInfoString(v3, "ASC ");
            int v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1) {
              goto LABEL_16;
            }
            break;
          default:
            int v9 = *(_DWORD *)(v7 + 20);
            if (v9 == 1) {
              goto LABEL_16;
            }
            break;
        }
        if (v9 != 2) {
          goto LABEL_18;
        }
        int v10 = "NULLS LAST ";
LABEL_17:
        appendStringInfoString(v3, v10);
LABEL_18:
        int v11 = *(_DWORD *)(v3 + 8);
        BOOL v12 = __OFSUB__(v11, 1);
        uint64_t v13 = (v11 - 1);
        if ((int)v13 < 0 == v12)
        {
          uint64_t v14 = *(void *)v3;
          if (*(unsigned char *)(*(void *)v3 + v13) == 32)
          {
            *(_DWORD *)(v3 + 8) = v13;
            *(unsigned char *)(v14 + v13) = 0;
          }
        }
        uint64_t v15 = *(int *)(a2 + 4);
        if (v6 + v5 && v6 + v5 < (unint64_t)(*(void *)(a2 + 16) + 8 * v15))
        {
          appendStringInfoString(v3, ", ");
          uint64_t v15 = *(int *)(a2 + 4);
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v15);
    }
    return appendStringInfoChar(v3, 32);
  }
  return result;
}

uint64_t deparseWindowDef(uint64_t a1, uint64_t a2)
{
  appendStringInfoChar(a1, 40);
  uint64_t v4 = *(unsigned char **)(a2 + 16);
  if (v4)
  {
    uint64_t v5 = quote_identifier(v4);
    appendStringInfoString(a1, v5);
    appendStringInfoChar(a1, 32);
  }
  uint64_t v6 = *(void *)(a2 + 24);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoString(a1, "PARTITION BY ");
    uint64_t v7 = *(void *)(a2 + 24);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8;
      do
      {
        uint64_t v10 = *(void *)(v7 + 16);
        deparseExpr(a1, *(void *)(v10 + 8 * v8));
        uint64_t v11 = *(int *)(v7 + 4);
        if (v10 + v9) {
          BOOL v12 = v10 + v9 >= (unint64_t)(*(void *)(v7 + 16) + 8 * v11);
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          appendStringInfoString(a1, ", ");
          uint64_t v11 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v11);
    }
    appendStringInfoChar(a1, 32);
  }
  deparseOptSortClause(a1, *(void *)(a2 + 32));
  int v13 = *(_DWORD *)(a2 + 40);
  if ((v13 & 1) == 0) {
    goto LABEL_56;
  }
  if ((v13 & 2) != 0)
  {
    appendStringInfoString(a1, "RANGE ");
    int v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0) {
      goto LABEL_31;
    }
    goto LABEL_20;
  }
  if ((v13 & 4) != 0)
  {
    appendStringInfoString(a1, "ROWS ");
    int v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0) {
      goto LABEL_31;
    }
LABEL_20:
    if ((v14 & 0x20) == 0) {
      goto LABEL_21;
    }
LABEL_32:
    uint64_t v15 = "UNBOUNDED PRECEDING ";
LABEL_33:
    appendStringInfoString(a1, v15);
    goto LABEL_34;
  }
  if ((v13 & 8) != 0)
  {
    appendStringInfoString(a1, "GROUPS ");
    int v14 = *(_DWORD *)(a2 + 40);
    if ((v14 & 0x10) != 0) {
      goto LABEL_31;
    }
    goto LABEL_20;
  }
  int v14 = *(_DWORD *)(a2 + 40);
  if ((v14 & 0x10) == 0) {
    goto LABEL_20;
  }
LABEL_31:
  appendStringInfoString(a1, "BETWEEN ");
  int v14 = *(_DWORD *)(a2 + 40);
  if ((v14 & 0x20) != 0) {
    goto LABEL_32;
  }
LABEL_21:
  if ((v14 & 0x80) != 0) {
    goto LABEL_34;
  }
  if ((v14 & 0x200) != 0)
  {
    uint64_t v15 = "CURRENT ROW ";
    goto LABEL_33;
  }
  if ((v14 & 0x800) != 0)
  {
    uint64_t v15 = " PRECEDING ";
    goto LABEL_44;
  }
  if ((v14 & 0x2000) != 0)
  {
    uint64_t v15 = " FOLLOWING ";
LABEL_44:
    deparseExpr(a1, *(void *)(a2 + 48));
    goto LABEL_33;
  }
LABEL_34:
  if ((*(unsigned char *)(a2 + 40) & 0x10) == 0) {
    goto LABEL_49;
  }
  appendStringInfoString(a1, "AND ");
  int v16 = *(_DWORD *)(a2 + 40);
  if ((v16 & 0x40) != 0) {
    goto LABEL_49;
  }
  if ((v16 & 0x100) != 0)
  {
    uint64_t v17 = "UNBOUNDED FOLLOWING ";
LABEL_48:
    appendStringInfoString(a1, v17);
    goto LABEL_49;
  }
  if ((v16 & 0x400) != 0)
  {
    uint64_t v17 = "CURRENT ROW ";
    goto LABEL_48;
  }
  if ((v16 & 0x1000) != 0)
  {
    uint64_t v17 = " PRECEDING ";
    goto LABEL_47;
  }
  if ((v16 & 0x4000) != 0)
  {
    uint64_t v17 = " FOLLOWING ";
LABEL_47:
    deparseExpr(a1, *(void *)(a2 + 56));
    goto LABEL_48;
  }
LABEL_49:
  int v18 = *(_DWORD *)(a2 + 40);
  if ((v18 & 0x8000) != 0)
  {
    uint64_t v19 = "EXCLUDE CURRENT ROW ";
    goto LABEL_55;
  }
  if ((v18 & 0x10000) != 0)
  {
    uint64_t v19 = "EXCLUDE GROUP ";
    goto LABEL_55;
  }
  if ((v18 & 0x20000) != 0)
  {
    uint64_t v19 = "EXCLUDE TIES ";
LABEL_55:
    appendStringInfoString(a1, v19);
  }
LABEL_56:
  int v20 = *(_DWORD *)(a1 + 8);
  BOOL v21 = __OFSUB__(v20, 1);
  uint64_t v22 = (v20 - 1);
  if ((int)v22 < 0 == v21)
  {
    uint64_t v23 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v22) == 32)
    {
      *(_DWORD *)(a1 + 8) = v22;
      *(unsigned char *)(v23 + v22) = 0;
    }
  }

  return appendStringInfoChar(a1, 41);
}

void *deparseQualOp(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(_DWORD *)(a2 + 4) == 1)
    {
      uint64_t v4 = *(char **)(**(void **)(a2 + 16) + 8);
      if (isOp(v4))
      {
        uint64_t v5 = a1;
        uint64_t v6 = v4;
        return appendStringInfoString(v5, v6);
      }
    }
    appendStringInfoString(a1, "OPERATOR(");
    int v8 = *(_DWORD *)(a2 + 4);
    if (v8 == 1)
    {
      uint64_t v10 = *(void *)(a2 + 16);
    }
    else
    {
      if (v8 != 2) {
        goto LABEL_14;
      }
      uint64_t v9 = quote_identifier(*(unsigned char **)(**(void **)(a2 + 16) + 8));
      appendStringInfoString(a1, v9);
      appendStringInfoChar(a1, 46);
      uint64_t v10 = *(void *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
    }
    uint64_t v11 = *(char **)(*(void *)v10 + 8);
  }
  else
  {
    uint64_t v11 = "OPERATOR(";
  }
  appendStringInfoString(a1, v11);
LABEL_14:
  uint64_t v6 = ")";
  uint64_t v5 = a1;

  return appendStringInfoString(v5, v6);
}

uint64_t isOp(unsigned char *a1)
{
  int v1 = *a1;
  if (!*a1) {
    return 1;
  }
  uint64_t v2 = a1 + 1;
  while (2)
  {
    uint64_t result = 0;
    switch(v1)
    {
      case '!':
      case '#':
      case '%':
      case '&':
      case '*':
      case '+':
      case '-':
      case '/':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case '^':
      case '|':
      case '~':
        int v4 = *v2++;
        int v1 = v4;
        if (!v4) {
          return 1;
        }
        continue;
      default:
        return result;
    }
  }
  return result;
}

void *deparseExprList(void *result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t result = (void *)deparseExpr(v3, *(void *)(v6 + 8 * v4));
      uint64_t v7 = *(int *)(a2 + 4);
      if (v6 + v5) {
        BOOL v8 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v7);
      }
      else {
        BOOL v8 = 1;
      }
      if (!v8)
      {
        uint64_t result = appendStringInfoString(v3, ", ");
        uint64_t v7 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v7);
  }
  return result;
}

void *deparseXmlAttributeList(void *result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      uint64_t result = (void *)deparseExpr(v3, *(void *)(v7 + 24));
      if (*(void *)(v7 + 8))
      {
        appendStringInfoString(v3, " AS ");
        BOOL v8 = quote_identifier(*(unsigned char **)(v7 + 8));
        uint64_t result = appendStringInfoString(v3, v8);
      }
      uint64_t v9 = *(int *)(a2 + 4);
      if (v6 + v5) {
        BOOL v10 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v9);
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        uint64_t result = appendStringInfoString(v3, ", ");
        uint64_t v9 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v9);
  }
  return result;
}

void *deparseTypeName(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(a2 + 20)) {
    uint64_t result = appendStringInfoString((uint64_t)result, "SETOF ");
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    goto LABEL_40;
  }
  int v5 = *(_DWORD *)(v4 + 4);
  if (v5 != 2)
  {
    if (v5 < 1)
    {
LABEL_40:
      char v16 = 0;
      goto LABEL_41;
    }
LABEL_23:
    uint64_t v10 = 0;
    uint64_t v11 = 8;
    do
    {
      uint64_t v12 = *(void *)(v4 + 16);
      int v13 = quote_identifier(*(unsigned char **)(*(void *)(v12 + 8 * v10) + 8));
      uint64_t result = appendStringInfoString((uint64_t)v3, v13);
      uint64_t v14 = *(int *)(v4 + 4);
      if (v12 + v11) {
        BOOL v15 = v12 + v11 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v14);
      }
      else {
        BOOL v15 = 1;
      }
      if (!v15)
      {
        uint64_t result = (void *)appendStringInfoChar((uint64_t)v3, 46);
        uint64_t v14 = *(int *)(v4 + 4);
      }
      ++v10;
      v11 += 8;
    }
    while (v10 < v14);
    goto LABEL_40;
  }
  uint64_t v6 = *(void **)(v4 + 16);
  if (strcmp(*(const char **)(*v6 + 8), "pg_catalog")) {
    goto LABEL_23;
  }
  uint64_t v7 = *(const char **)(v6[1] + 8);
  if (!strcmp(v7, "bpchar"))
  {
    uint64_t v9 = "char";
LABEL_38:
    uint64_t v8 = (uint64_t)v3;
    goto LABEL_39;
  }
  if (!strcmp(v7, "varchar"))
  {
    uint64_t v9 = "varchar";
    goto LABEL_38;
  }
  if (!strcmp(v7, "numeric"))
  {
    uint64_t v9 = "numeric";
    goto LABEL_38;
  }
  if (!strcmp(v7, "BOOL"))
  {
    uint64_t v9 = "BOOLean";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int2"))
  {
    uint64_t v9 = "smallint";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int4"))
  {
    uint64_t v9 = "int";
    goto LABEL_38;
  }
  if (!strcmp(v7, "int8"))
  {
    uint64_t v9 = "bigint";
    goto LABEL_38;
  }
  if (!strcmp(v7, "real") || !strcmp(v7, "float4"))
  {
    uint64_t v9 = "real";
    goto LABEL_38;
  }
  if (!strcmp(v7, "float8"))
  {
    uint64_t v9 = "double precision";
    goto LABEL_38;
  }
  if (!strcmp(v7, "time"))
  {
    uint64_t v9 = "time";
    goto LABEL_38;
  }
  if (!strcmp(v7, "timetz"))
  {
    appendStringInfoString((uint64_t)v3, "time ");
    uint64_t v44 = *(void *)(a2 + 24);
    if (!v44 || *(int *)(v44 + 4) < 1) {
      goto LABEL_105;
    }
    appendStringInfoChar((uint64_t)v3, 40);
    uint64_t v51 = *(void *)(a2 + 24);
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      uint64_t v52 = 0;
      uint64_t v53 = 8;
      do
      {
        uint64_t v54 = *(void *)(v51 + 16);
        appendStringInfo((uint64_t)v3, "%d", v45, v46, v47, v48, v49, v50, *(unsigned int *)(*(void *)(v54 + 8 * v52) + 16));
        if (v54 + v53) {
          BOOL v55 = v54 + v53 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString((uint64_t)v3, ", ");
        }
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    goto LABEL_104;
  }
  if (!strcmp(v7, "timestamp"))
  {
    uint64_t v9 = "timestamp";
    goto LABEL_38;
  }
  if (!strcmp(v7, "timestamptz"))
  {
    appendStringInfoString((uint64_t)v3, "timestamp ");
    uint64_t v56 = *(void *)(a2 + 24);
    if (!v56 || *(int *)(v56 + 4) < 1) {
      goto LABEL_105;
    }
    appendStringInfoChar((uint64_t)v3, 40);
    uint64_t v63 = *(void *)(a2 + 24);
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      uint64_t v64 = 0;
      uint64_t v65 = 8;
      do
      {
        uint64_t v66 = *(void *)(v63 + 16);
        appendStringInfo((uint64_t)v3, "%d", v57, v58, v59, v60, v61, v62, *(unsigned int *)(*(void *)(v66 + 8 * v64) + 16));
        if (v66 + v65) {
          BOOL v67 = v66 + v65 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString((uint64_t)v3, ", ");
        }
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
LABEL_104:
    appendStringInfoString((uint64_t)v3, ") ");
LABEL_105:
    uint64_t result = appendStringInfoString((uint64_t)v3, "with time zone");
    char v16 = 1;
    goto LABEL_41;
  }
  if (strcmp(v7, "interval"))
  {
LABEL_21:
    appendStringInfoString((uint64_t)v3, "pg_catalog.");
    uint64_t v8 = (uint64_t)v3;
    uint64_t v9 = (char *)v7;
LABEL_39:
    uint64_t result = appendStringInfoString(v8, v9);
    goto LABEL_40;
  }
  uint64_t v68 = *(void *)(a2 + 24);
  if (!v68 || (int v69 = *(_DWORD *)(v68 + 4)) == 0)
  {
    uint64_t v9 = "interval";
    goto LABEL_38;
  }
  if (v69 < 1) {
    goto LABEL_21;
  }
  int v70 = *(_DWORD *)(**(void **)(v68 + 16) + 16);
  uint64_t result = appendStringInfoString((uint64_t)v3, "interval");
  if (v70 > 3071)
  {
    if (v70 > 6143)
    {
      switch(v70)
      {
        case 6144:
          BOOL v77 = " minute to second";
          goto LABEL_135;
        case 7168:
          BOOL v77 = " hour to second";
          goto LABEL_135;
        case 7176:
          BOOL v77 = " day to second";
          goto LABEL_135;
      }
    }
    else
    {
      switch(v70)
      {
        case 3072:
          BOOL v77 = " hour to minute";
          goto LABEL_135;
        case 3080:
          BOOL v77 = " day to minute";
          goto LABEL_135;
        case 4096:
          BOOL v77 = " second";
LABEL_135:
          uint64_t result = appendStringInfoString((uint64_t)v3, v77);
          break;
      }
    }
  }
  else
  {
    if (v70 <= 1023)
    {
      BOOL v77 = " year";
      switch(v70)
      {
        case 2:
          BOOL v77 = " month";
          goto LABEL_135;
        case 4:
          goto LABEL_135;
        case 6:
          BOOL v77 = " year to month";
          goto LABEL_135;
        case 8:
          BOOL v77 = " day";
          goto LABEL_135;
        default:
          goto LABEL_136;
      }
      goto LABEL_136;
    }
    switch(v70)
    {
      case 1024:
        BOOL v77 = " hour";
        goto LABEL_135;
      case 1032:
        BOOL v77 = " day to hour";
        goto LABEL_135;
      case 2048:
        BOOL v77 = " minute";
        goto LABEL_135;
    }
  }
LABEL_136:
  uint64_t v78 = *(void *)(a2 + 24);
  if (v78
    && *(_DWORD *)(v78 + 4) == 2
    && (size_t v79 = *(unsigned int *)(*(void *)(*(void *)(v78 + 16) + 8) + 16), v79 != 0xFFFF))
  {
    uint64_t result = (void *)appendStringInfo((uint64_t)v3, "(%d)", v71, v72, v73, v74, v75, v76, v79);
    char v16 = 1;
  }
  else
  {
    char v16 = 1;
  }
LABEL_41:
  uint64_t v17 = *(void *)(a2 + 24);
  if (v17)
  {
    if (*(int *)(v17 + 4) < 1) {
      char v16 = 1;
    }
    if ((v16 & 1) == 0)
    {
      appendStringInfoChar((uint64_t)v3, 40);
      uint64_t v24 = *(void *)(a2 + 24);
      if (v24 && *(int *)(v24 + 4) >= 1)
      {
        uint64_t v25 = 0;
        uint64_t v26 = 8;
        do
        {
          uint64_t v27 = *(void *)(v24 + 16);
          uint64_t v28 = *(int **)(v27 + 8 * v25);
          int v29 = *v28;
          if (*v28 == 347)
          {
            uint64_t v30 = **(void **)(*((void *)v28 + 1) + 16);
            if (*(_DWORD *)v30 == 223)
            {
              uint64_t v31 = quote_identifier(*(unsigned char **)(v30 + 8));
              appendStringInfoString((uint64_t)v3, v31);
            }
            else if (*(_DWORD *)v30 == 351)
            {
              appendStringInfoChar((uint64_t)v3, 42);
            }
            deparseOptIndirection((uint64_t)v3, *((void *)v28 + 1), 1);
          }
          else if (v29 == 348)
          {
            if (v28[1]) {
              appendStringInfo((uint64_t)v3, "$%d", v18, v19, v20, v21, v22, v23, v28[1]);
            }
            else {
              appendStringInfoChar((uint64_t)v3, 63);
            }
          }
          else if (v29 == 349)
          {
            deparseValue(v3, v28 + 2, 11, v19, v20, v21, v22, v23);
          }
          if (v27 + v26) {
            BOOL v32 = v27 + v26 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
          }
                                                + 8 * *(int *)(*(void *)(a2 + 24) + 4));
          else {
            BOOL v32 = 1;
          }
          if (!v32) {
            appendStringInfoString((uint64_t)v3, ", ");
          }
          ++v25;
          v26 += 8;
        }
        while (v25 < *(int *)(v24 + 4));
      }
      uint64_t result = (void *)appendStringInfoChar((uint64_t)v3, 41);
    }
  }
  uint64_t v33 = *(void *)(a2 + 40);
  if (v33 && *(int *)(v33 + 4) >= 1)
  {
    uint64_t v34 = 0;
    do
    {
      uint64_t v35 = *(void *)(v33 + 16);
      appendStringInfoChar((uint64_t)v3, 91);
      uint64_t v42 = *(_DWORD **)(v35 + 8 * v34);
      if (*v42 == 221)
      {
        size_t v43 = v42[2];
        if (v43 != -1) {
          appendStringInfo((uint64_t)v3, "%d", v36, v37, v38, v39, v40, v41, v43);
        }
      }
      uint64_t result = (void *)appendStringInfoChar((uint64_t)v3, 93);
      ++v34;
    }
    while (v34 < *(int *)(v33 + 4));
  }
  if (*(unsigned char *)(a2 + 21))
  {
    return appendStringInfoString((uint64_t)v3, "%type");
  }
  return result;
}

void *deparseValue(void *result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  switch(*a2)
  {
    case 0xDD:
      return (void *)appendStringInfo((uint64_t)result, "%d", a3, a4, a5, a6, a7, a8, a2[2]);
    case 0xDE:
      goto LABEL_8;
    case 0xDF:
      if (a3 == 11)
      {
        int v13 = (char *)*((void *)a2 + 1);
        return (void *)deparseStringLiteral((uint64_t)result, v13);
      }
      if (a3 == 10)
      {
        uint64_t v10 = quote_identifier(*((unsigned char **)a2 + 1));
        uint64_t result = v9;
      }
      else
      {
LABEL_8:
        uint64_t v10 = (char *)*((void *)a2 + 1);
      }
      return appendStringInfoString((uint64_t)result, v10);
    case 0xE0:
      int v11 = **((unsigned __int8 **)a2 + 1);
      if (v11 == 98)
      {
        char v12 = 98;
      }
      else
      {
        if (v11 != 120) {
          return result;
        }
        char v12 = 120;
      }
      appendStringInfoChar((uint64_t)result, v12);
      int v13 = (char *)(*((void *)a2 + 1) + 1);
      uint64_t result = v9;
      return (void *)deparseStringLiteral((uint64_t)result, v13);
    case 0xE1:
      uint64_t v10 = "NULL";
      return appendStringInfoString((uint64_t)result, v10);
    default:
      deparseValue_cold_1();
  }
}

void *deparseNumericOnly(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 222)
  {
    uint64_t v8 = *(char **)(a2 + 8);
    return appendStringInfoString((uint64_t)result, v8);
  }
  else if (*(_DWORD *)a2 == 221)
  {
    return (void *)appendStringInfo((uint64_t)result, "%d", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  return result;
}

uint64_t deparseOptIndirection(uint64_t result, uint64_t a2, int a3)
{
  if (a2 && *(_DWORD *)(a2 + 4) > a3)
  {
    uint64_t v4 = result;
    for (int i = a3; *(_DWORD *)(a2 + 4) > i; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      uint64_t v9 = *(int **)(v8 + 8 * i);
      int v10 = *v9;
      if (*v9 == 352)
      {
        appendStringInfoChar(v4, 91);
        uint64_t v11 = *((void *)v9 + 1);
        if (v11) {
          deparseExpr(v4, v11);
        }
        if (*((unsigned char *)v9 + 4)) {
          appendStringInfoChar(v4, 58);
        }
        uint64_t v12 = *((void *)v9 + 2);
        if (v12) {
          deparseExpr(v4, v12);
        }
        uint64_t result = appendStringInfoChar(v4, 93);
        continue;
      }
      if (v10 == 351)
      {
        uint64_t v6 = v4;
        uint64_t v7 = ".*";
      }
      else
      {
        if (v10 != 223) {
          continue;
        }
        appendStringInfoChar(v4, 46);
        uint64_t v7 = quote_identifier(*(unsigned char **)(*(void *)(v8 + 8 * i) + 8));
        uint64_t v6 = v4;
      }
      uint64_t result = (uint64_t)appendStringInfoString(v6, v7);
    }
  }
  return result;
}

void *deparseSubqueryOp(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v8 = "OPERATOR(";
    goto LABEL_20;
  }
  if (*(_DWORD *)(a2 + 4) != 1)
  {
LABEL_12:
    appendStringInfoString(a1, "OPERATOR(");
    int v9 = *(_DWORD *)(a2 + 4);
    if (v9 == 1)
    {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else
    {
      if (v9 != 2) {
        goto LABEL_21;
      }
      int v10 = quote_identifier(*(unsigned char **)(**(void **)(a2 + 16) + 8));
      appendStringInfoString(a1, v10);
      appendStringInfoChar(a1, 46);
      uint64_t v11 = *(void *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
    }
    uint64_t v8 = *(char **)(*(void *)v11 + 8);
LABEL_20:
    appendStringInfoString(a1, v8);
LABEL_21:
    uint64_t v6 = ")";
    uint64_t v5 = a1;
    return appendStringInfoString(v5, v6);
  }
  uint64_t v4 = *(char **)(**(void **)(a2 + 16) + 8);
  if (!strcmp(v4, "~~"))
  {
    uint64_t v6 = "LIKE";
    uint64_t v5 = a1;
  }
  else if (!strcmp(v4, "!~~"))
  {
    uint64_t v6 = "NOT LIKE";
    uint64_t v5 = a1;
  }
  else if (!strcmp(v4, "~~*"))
  {
    uint64_t v6 = "ILIKE";
    uint64_t v5 = a1;
  }
  else
  {
    if (strcmp(v4, "!~~*"))
    {
      if (isOp(v4))
      {
        uint64_t v5 = a1;
        uint64_t v6 = v4;
        return appendStringInfoString(v5, v6);
      }
      goto LABEL_12;
    }
    uint64_t v6 = "NOT ILIKE";
    uint64_t v5 = a1;
  }
  return appendStringInfoString(v5, v6);
}

uint64_t deparseIndexElem(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(unsigned char **)(a2 + 8);
  if (v10)
  {
    uint64_t v11 = quote_identifier(v10);
    appendStringInfoString((uint64_t)a1, v11);
    appendStringInfoChar((uint64_t)a1, 32);
    uint64_t result = deparseOptCollate((uint64_t)a1, *(void *)(a2 + 32));
    uint64_t v13 = *(void *)(a2 + 40);
    if (!v13) {
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v14 = *(_DWORD **)(a2 + 16);
    if (v14)
    {
      if ((*v14 - 136) >= 4)
      {
        unsigned int v15 = *v14 - 350;
        BOOL v16 = v15 > 0x23;
        uint64_t v17 = (1 << v15) & 0x800000081;
        if (v16 || v17 == 0)
        {
          appendStringInfoChar((uint64_t)a1, 40);
          deparseExpr(a1, *(void *)(a2 + 16));
          appendStringInfoString((uint64_t)a1, ") ");
          uint64_t result = deparseOptCollate((uint64_t)a1, *(void *)(a2 + 32));
          uint64_t v13 = *(void *)(a2 + 40);
          if (!v13) {
            goto LABEL_24;
          }
          goto LABEL_12;
        }
      }
      deparseFuncExprWindowless(a1, (uint64_t)v14, a3, a4, a5, a6, a7, a8);
    }
    uint64_t result = deparseOptCollate((uint64_t)a1, *(void *)(a2 + 32));
    uint64_t v13 = *(void *)(a2 + 40);
    if (!v13) {
      goto LABEL_24;
    }
  }
LABEL_12:
  if (*(int *)(v13 + 4) >= 1)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 8;
    do
    {
      uint64_t v21 = *(void *)(v13 + 16);
      uint64_t v22 = quote_identifier(*(unsigned char **)(*(void *)(v21 + 8 * v19) + 8));
      appendStringInfoString((uint64_t)a1, v22);
      uint64_t v23 = *(int *)(v13 + 4);
      if (v21 + v20) {
        BOOL v24 = v21 + v20 >= (unint64_t)(*(void *)(v13 + 16) + 8 * v23);
      }
      else {
        BOOL v24 = 1;
      }
      if (!v24)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        uint64_t v23 = *(int *)(v13 + 4);
      }
      ++v19;
      v20 += 8;
    }
    while (v19 < v23);
    uint64_t v25 = *(void *)(a2 + 48);
    if (v25 && *(int *)(v25 + 4) >= 1) {
      deparseRelOptions(a1, v25);
    }
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
LABEL_24:
  int v26 = *(_DWORD *)(a2 + 56);
  if (v26 == 1)
  {
    uint64_t v27 = "ASC ";
  }
  else
  {
    if (v26 != 2) {
      goto LABEL_29;
    }
    uint64_t v27 = "DESC ";
  }
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v27);
LABEL_29:
  int v28 = *(_DWORD *)(a2 + 60);
  if (v28 == 1)
  {
    int v29 = "NULLS FIRST ";
  }
  else
  {
    if (v28 != 2) {
      goto LABEL_34;
    }
    int v29 = "NULLS LAST ";
  }
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v29);
LABEL_34:
  int v30 = a1[2];
  BOOL v31 = __OFSUB__(v30, 1);
  uint64_t v32 = (v30 - 1);
  if ((int)v32 < 0 == v31)
  {
    uint64_t v33 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v32) == 32)
    {
      a1[2] = v32;
      *(unsigned char *)(v33 + v32) = 0;
    }
  }
  return result;
}

uint64_t deparseRangeVar(uint64_t a1, uint64_t a2, int a3)
{
  if ((a3 - 10) <= 0xFFFFFFFD && *(unsigned char *)(a2 + 32) == 0) {
    appendStringInfoString(a1, "ONLY ");
  }
  uint64_t v7 = *(unsigned char **)(a2 + 8);
  if (v7)
  {
    uint64_t v8 = quote_identifier(v7);
    appendStringInfoString(a1, v8);
    appendStringInfoChar(a1, 46);
  }
  int v9 = *(unsigned char **)(a2 + 16);
  if (v9)
  {
    int v10 = quote_identifier(v9);
    appendStringInfoString(a1, v10);
    appendStringInfoChar(a1, 46);
  }
  uint64_t v11 = quote_identifier(*(unsigned char **)(a2 + 24));
  appendStringInfoString(a1, v11);
  uint64_t result = appendStringInfoChar(a1, 32);
  uint64_t v13 = *(void *)(a2 + 40);
  if (v13)
  {
    if (a3 == 1)
    {
      appendStringInfoString(a1, "AS ");
      uint64_t v13 = *(void *)(a2 + 40);
    }
    deparseAlias(a1, v13);
    uint64_t result = appendStringInfoChar(a1, 32);
  }
  int v14 = *(_DWORD *)(a1 + 8);
  BOOL v15 = __OFSUB__(v14, 1);
  uint64_t v16 = (v14 - 1);
  if ((int)v16 < 0 == v15)
  {
    uint64_t v17 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v16) == 32)
    {
      *(_DWORD *)(a1 + 8) = v16;
      *(unsigned char *)(v17 + v16) = 0;
    }
  }
  return result;
}

unint64_t deparseSeqOptElem(void *a1, uint64_t a2)
{
  uint64_t v4 = *(const char **)(a2 + 16);
  if (!strcmp(v4, "as"))
  {
    appendStringInfoString((uint64_t)a1, "AS ");
    uint64_t v7 = *(void *)(a2 + 24);
    return (unint64_t)deparseTypeName(a1, v7);
  }
  if (!strcmp(v4, "cache"))
  {
    unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, "CACHE ");
    int v14 = *(int **)(a2 + 24);
    int v15 = *v14;
    if (*v14 != 222) {
      goto LABEL_25;
    }
    goto LABEL_31;
  }
  if (!strcmp(v4, "cycle"))
  {
    int v16 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
    if (v16)
    {
      if (v16 != 1) {
        goto LABEL_4;
      }
      uint64_t v17 = "CYCLE";
    }
    else
    {
      uint64_t v17 = "NO CYCLE";
    }
LABEL_32:
    return (unint64_t)appendStringInfoString((uint64_t)a1, v17);
  }
LABEL_4:
  if (!strcmp(v4, "increment"))
  {
    unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, "INCREMENT ");
    int v14 = *(int **)(a2 + 24);
    int v15 = *v14;
    if (*v14 != 222) {
      goto LABEL_25;
    }
LABEL_31:
    uint64_t v17 = (char *)*((void *)v14 + 1);
    goto LABEL_32;
  }
  if (!strcmp(v4, "maxvalue"))
  {
    if (!*(void *)(a2 + 24))
    {
      uint64_t v17 = "NO MAXVALUE";
      goto LABEL_32;
    }
    unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, "MAXVALUE ");
    int v14 = *(int **)(a2 + 24);
    int v15 = *v14;
    if (*v14 == 222) {
      goto LABEL_31;
    }
    goto LABEL_25;
  }
  if (!strcmp(v4, "minvalue"))
  {
    if (!*(void *)(a2 + 24))
    {
      uint64_t v17 = "NO MINVALUE";
      goto LABEL_32;
    }
    unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, "MINVALUE ");
    int v14 = *(int **)(a2 + 24);
    int v15 = *v14;
    if (*v14 == 222) {
      goto LABEL_31;
    }
LABEL_25:
    if (v15 == 221) {
      return appendStringInfo((uint64_t)a1, "%d", v8, v9, v10, v11, v12, v13, v14[2]);
    }
    return result;
  }
  if (!strcmp(v4, "owned_by"))
  {
    unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, "OWNED BY ");
    uint64_t v18 = *(void *)(a2 + 24);
    if (v18 && *(int *)(v18 + 4) >= 1)
    {
      uint64_t v19 = 0;
      uint64_t v20 = 8;
      do
      {
        uint64_t v21 = *(void *)(v18 + 16);
        uint64_t v22 = quote_identifier(*(unsigned char **)(*(void *)(v21 + 8 * v19) + 8));
        unint64_t result = (unint64_t)appendStringInfoString((uint64_t)a1, v22);
        uint64_t v23 = *(int *)(v18 + 4);
        if (v21 + v20) {
          BOOL v24 = v21 + v20 >= (unint64_t)(*(void *)(v18 + 16) + 8 * v23);
        }
        else {
          BOOL v24 = 1;
        }
        if (!v24)
        {
          unint64_t result = appendStringInfoChar((uint64_t)a1, 46);
          uint64_t v23 = *(int *)(v18 + 4);
        }
        ++v19;
        v20 += 8;
      }
      while (v19 < v23);
    }
  }
  else
  {
    if (strcmp(v4, "sequence_name"))
    {
      if (!strcmp(v4, "start"))
      {
        uint64_t v6 = "START ";
        goto LABEL_50;
      }
      unint64_t result = strcmp(v4, "restart");
      if (result) {
        return result;
      }
      if (*(void *)(a2 + 24))
      {
        uint64_t v6 = "RESTART ";
LABEL_50:
        appendStringInfoString((uint64_t)a1, v6);
        uint64_t v32 = *(void *)(a2 + 24);
        return (unint64_t)deparseNumericOnly(a1, v32, v26, v27, v28, v29, v30, v31);
      }
      uint64_t v17 = "RESTART";
      goto LABEL_32;
    }
    appendStringInfoString((uint64_t)a1, "SEQUENCE NAME ");
    uint64_t v25 = *(void *)(a2 + 24);
    return deparseAnyName((uint64_t)a1, v25);
  }
  return result;
}

void *deparseFuncExprWindowless(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  int v10 = *(_DWORD *)a2;
  if (*(int *)a2 <= 349)
  {
    switch(v10)
    {
      case 136:
        appendStringInfoString((uint64_t)result, "COALESCE(");
        uint64_t v11 = *(void *)(a2 + 16);
        if (v11 && *(int *)(v11 + 4) >= 1)
        {
          uint64_t v12 = 0;
          uint64_t v13 = 8;
          do
          {
            uint64_t v14 = *(void *)(v11 + 16);
            deparseExpr(v9, *(void *)(v14 + 8 * v12));
            uint64_t v15 = *(int *)(v11 + 4);
            if (v14 + v13) {
              BOOL v16 = v14 + v13 >= (unint64_t)(*(void *)(v11 + 16) + 8 * v15);
            }
            else {
              BOOL v16 = 1;
            }
            if (!v16)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v15 = *(int *)(v11 + 4);
            }
            ++v12;
            v13 += 8;
          }
          while (v12 < v15);
        }
        goto LABEL_51;
      case 137:
        int v20 = *(_DWORD *)(a2 + 16);
        if (v20)
        {
          if (v20 != 1) {
            goto LABEL_42;
          }
          uint64_t v21 = "LEAST(";
        }
        else
        {
          uint64_t v21 = "GREATEST(";
        }
        appendStringInfoString((uint64_t)result, v21);
LABEL_42:
        uint64_t v22 = *(void *)(a2 + 24);
        if (v22 && *(int *)(v22 + 4) >= 1)
        {
          uint64_t v23 = 0;
          uint64_t v24 = 8;
          do
          {
            uint64_t v25 = *(void *)(v22 + 16);
            deparseExpr(v9, *(void *)(v25 + 8 * v23));
            uint64_t v26 = *(int *)(v22 + 4);
            if (v25 + v24) {
              BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(v22 + 16) + 8 * v26);
            }
            else {
              BOOL v27 = 1;
            }
            if (!v27)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v26 = *(int *)(v22 + 4);
            }
            ++v23;
            v24 += 8;
          }
          while (v23 < v26);
        }
LABEL_51:
        unint64_t result = (void *)appendStringInfoChar((uint64_t)v9, 41);
        break;
      case 138:
        uint64_t v17 = *(int *)(a2 + 4);
        if (v17 <= 0xE) {
          unint64_t result = appendStringInfoString((uint64_t)result, (&off_1E55D8EB0)[v17]);
        }
        if (*(_DWORD *)(a2 + 12) != -1) {
          return (void *)appendStringInfo((uint64_t)v9, "(%d)", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
        }
        return result;
      case 139:
        return deparseXmlExpr(result, a2);
      default:
        return result;
    }
    return result;
  }
  if (v10 != 385)
  {
    if (v10 == 357)
    {
      return deparseTypeCast(result, a2);
    }
    else if (v10 == 350)
    {
      return (void *)deparseFuncCall((uint64_t)result, a2);
    }
    return result;
  }
  appendStringInfoString((uint64_t)result, "xmlserialize(");
  int v18 = *(_DWORD *)(a2 + 4);
  if (!v18)
  {
    uint64_t v19 = "document ";
    goto LABEL_36;
  }
  if (v18 == 1)
  {
    uint64_t v19 = "content ";
LABEL_36:
    appendStringInfoString((uint64_t)v9, v19);
  }
  deparseExpr(v9, *(void *)(a2 + 8));
  appendStringInfoString((uint64_t)v9, " AS ");
  deparseTypeName(v9, *(void *)(a2 + 16));

  return appendStringInfoString((uint64_t)v9, ")");
}

uint64_t deparseOptCollate(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    appendStringInfoString(result, "COLLATE ");
    if (*(int *)(a2 + 4) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a2 + 16);
        uint64_t v7 = quote_identifier(*(unsigned char **)(*(void *)(v6 + 8 * v4) + 8));
        appendStringInfoString(v3, v7);
        uint64_t v8 = *(int *)(a2 + 4);
        if (v6 + v5) {
          BOOL v9 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v8);
        }
        else {
          BOOL v9 = 1;
        }
        if (!v9)
        {
          appendStringInfoChar(v3, 46);
          uint64_t v8 = *(int *)(a2 + 4);
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v8);
    }
    return appendStringInfoChar(v3, 32);
  }
  return result;
}

uint64_t deparseRelOptions(void *a1, uint64_t a2)
{
  appendStringInfoChar((uint64_t)a1, 40);
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 8;
    do
    {
      uint64_t v11 = *(void *)(a2 + 16);
      uint64_t v12 = *(void **)(v11 + 8 * v9);
      uint64_t v13 = (unsigned char *)v12[1];
      if (v13)
      {
        uint64_t v14 = quote_identifier(v13);
        appendStringInfoString((uint64_t)a1, v14);
        appendStringInfoChar((uint64_t)a1, 46);
      }
      uint64_t v15 = (unsigned char *)v12[2];
      if (v15)
      {
        BOOL v16 = quote_identifier(v15);
        appendStringInfoString((uint64_t)a1, v16);
        if (v12[2])
        {
          if (v12[3]) {
            appendStringInfoChar((uint64_t)a1, 61);
          }
        }
      }
      uint64_t v17 = v12[3];
      if (v17) {
        deparseDefArg(a1, v17, 0, v4, v5, v6, v7, v8);
      }
      if (v11 + v10) {
        BOOL v18 = v11 + v10 >= (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4));
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18) {
        appendStringInfoString((uint64_t)a1, ", ");
      }
      ++v9;
      v10 += 8;
    }
    while (v9 < *(int *)(a2 + 4));
  }

  return appendStringInfoChar((uint64_t)a1, 41);
}

void *deparseDefArg(void *result, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  int v10 = *(_DWORD *)a2;
  if (*(int *)a2 <= 225)
  {
    if ((v10 - 221) < 2)
    {
      return deparseValue(result, (_DWORD *)a2, 0, a4, a5, a6, a7, a8);
    }
    if (v10 != 223) {
      return result;
    }
    uint64_t v11 = *(char **)(a2 + 8);
    if ((a3 & 1) == 0 && !strcmp(v11, "none"))
    {
      int v20 = "NONE";
      unint64_t result = v9;
    }
    else
    {
      int v12 = ScanKeywordLookup(v11, (uint64_t)&ScanKeywords);
      int v13 = *v11;
      if (*v11)
      {
        uint64_t v14 = (unsigned __int8 *)(v11 + 1);
        while ((v13 - 97) < 0x1A || v13 == 95 || (v13 - 48) <= 9)
        {
          int v15 = *v14++;
          int v13 = v15;
          if (!v15) {
            goto LABEL_27;
          }
        }
        goto LABEL_32;
      }
LABEL_27:
      if (v12 < 0 || ScanKeywordCategories[v12] != 3)
      {
LABEL_32:
        return (void *)deparseStringLiteral((uint64_t)v9, v11);
      }
      unint64_t result = v9;
      int v20 = v11;
    }
    return appendStringInfoString((uint64_t)result, v20);
  }
  if (v10 != 226)
  {
    if (v10 == 366)
    {
      return deparseTypeName(result, a2);
    }
    return result;
  }
  int v16 = *(_DWORD *)(a2 + 4);
  if (v16 == 1)
  {
    int v20 = *(char **)(**(void **)(a2 + 16) + 8);
    return appendStringInfoString((uint64_t)result, v20);
  }
  if (v16 != 2) {
    return result;
  }
  appendStringInfoString((uint64_t)result, "OPERATOR(");
  int v17 = *(_DWORD *)(a2 + 4);
  if (v17 == 1)
  {
    uint64_t v19 = *(void *)(a2 + 16);
    goto LABEL_42;
  }
  if (v17 == 2)
  {
    BOOL v18 = quote_identifier(*(unsigned char **)(**(void **)(a2 + 16) + 8));
    appendStringInfoString((uint64_t)v9, v18);
    appendStringInfoChar((uint64_t)v9, 46);
    uint64_t v19 = *(void *)(a2 + 16) + 8 * (*(_DWORD *)(a2 + 4) - 1);
LABEL_42:
    appendStringInfoString((uint64_t)v9, *(char **)(*(void *)v19 + 8));
  }

  return (void *)appendStringInfoChar((uint64_t)v9, 41);
}

void *deparseAlias(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = quote_identifier(*(unsigned char **)(a2 + 8));
  unint64_t result = appendStringInfoString(a1, v4);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 && *(int *)(v6 + 4) >= 1)
  {
    appendStringInfoChar(a1, 40);
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7 && *(int *)(v7 + 4) >= 1)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8;
      do
      {
        uint64_t v10 = *(void *)(v7 + 16);
        uint64_t v11 = quote_identifier(*(unsigned char **)(*(void *)(v10 + 8 * v8) + 8));
        appendStringInfoString(a1, v11);
        uint64_t v12 = *(int *)(v7 + 4);
        if (v10 + v9) {
          BOOL v13 = v10 + v9 >= (unint64_t)(*(void *)(v7 + 16) + 8 * v12);
        }
        else {
          BOOL v13 = 1;
        }
        if (!v13)
        {
          appendStringInfoString(a1, ", ");
          uint64_t v12 = *(int *)(v7 + 4);
        }
        ++v8;
        v9 += 8;
      }
      while (v8 < v12);
    }
    return (void *)appendStringInfoChar(a1, 41);
  }
  return result;
}

uint64_t deparseAggregateWithArgtypes(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 8;
    do
    {
      uint64_t v7 = *(void *)(v4 + 16);
      uint64_t v8 = quote_identifier(*(unsigned char **)(*(void *)(v7 + 8 * v5) + 8));
      appendStringInfoString((uint64_t)a1, v8);
      uint64_t v9 = *(int *)(v4 + 4);
      if (v7 + v6) {
        BOOL v10 = v7 + v6 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v9);
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        appendStringInfoChar((uint64_t)a1, 46);
        uint64_t v9 = *(int *)(v4 + 4);
      }
      ++v5;
      v6 += 8;
    }
    while (v5 < v9);
  }
  appendStringInfoChar((uint64_t)a1, 40);
  uint64_t v11 = *(void *)(a2 + 16);
  if (v11)
  {
    if (*(int *)(v11 + 4) >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8;
      do
      {
        uint64_t v14 = *(void *)(v11 + 16);
        deparseTypeName(a1, *(void *)(v14 + 8 * v12));
        if (v14 + v13) {
          BOOL v15 = v14 + v13 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v15 = 1;
        }
        if (!v15) {
          appendStringInfoString((uint64_t)a1, ", ");
        }
        ++v12;
        v13 += 8;
      }
      while (v12 < *(int *)(v11 + 4));
    }
  }
  else
  {
    appendStringInfoChar((uint64_t)a1, 42);
  }

  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseFunctionWithArgtypes(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (_DWORD *)result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 8;
    do
    {
      uint64_t v7 = *(void *)(v4 + 16);
      uint64_t v8 = quote_identifier(*(unsigned char **)(*(void *)(v7 + 8 * v5) + 8));
      unint64_t result = (uint64_t)appendStringInfoString((uint64_t)v3, v8);
      uint64_t v9 = *(int *)(v4 + 4);
      if (v7 + v6) {
        BOOL v10 = v7 + v6 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v9);
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10)
      {
        unint64_t result = appendStringInfoChar((uint64_t)v3, 46);
        uint64_t v9 = *(int *)(v4 + 4);
      }
      ++v5;
      v6 += 8;
    }
    while (v5 < v9);
  }
  if (!*(unsigned char *)(a2 + 24))
  {
    appendStringInfoChar((uint64_t)v3, 40);
    uint64_t v11 = *(void *)(a2 + 16);
    if (v11 && *(int *)(v11 + 4) >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8;
      do
      {
        uint64_t v14 = *(void *)(v11 + 16);
        BOOL v15 = *(_DWORD **)(v14 + 8 * v12);
        if (*v15 == 366) {
          deparseTypeName(v3, (uint64_t)v15);
        }
        else {
          deparseFunctionParameter(v3, (uint64_t)v15);
        }
        if (v14 + v13) {
          BOOL v16 = v14 + v13 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v16 = 1;
        }
        if (!v16) {
          appendStringInfoString((uint64_t)v3, ", ");
        }
        ++v12;
        v13 += 8;
      }
      while (v12 < *(int *)(v11 + 4));
    }
    return appendStringInfoChar((uint64_t)v3, 41);
  }
  return result;
}

uint64_t deparseOperatorWithArgtypes(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(v4 + 4);
  if (v5 == 1)
  {
    uint64_t v7 = *(void *)(v4 + 16);
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_7;
    }
    uint64_t v6 = quote_identifier(*(unsigned char **)(**(void **)(v4 + 16) + 8));
    appendStringInfoString((uint64_t)a1, v6);
    appendStringInfoChar((uint64_t)a1, 46);
    uint64_t v7 = *(void *)(v4 + 16) + 8 * (*(_DWORD *)(v4 + 4) - 1);
  }
  appendStringInfoString((uint64_t)a1, *(char **)(*(void *)v7 + 8));
LABEL_7:
  appendStringInfoChar((uint64_t)a1, 40);
  uint64_t v8 = **(void **)(*(void *)(a2 + 16) + 16);
  if (v8) {
    deparseTypeName(a1, v8);
  }
  else {
    appendStringInfoString((uint64_t)a1, "NONE");
  }
  appendStringInfoString((uint64_t)a1, ", ");
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8);
  if (v9) {
    deparseTypeName(a1, v9);
  }
  else {
    appendStringInfoString((uint64_t)a1, "NONE");
  }

  return appendStringInfoChar((uint64_t)a1, 41);
}

uint64_t deparseFunctionParameter(_DWORD *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 24);
  switch(v4)
  {
    case 'v':
      int v5 = "VARIADIC ";
      break;
    case 'o':
      int v5 = "OUT ";
      break;
    case 'b':
      int v5 = "INOUT ";
      break;
    default:
      goto LABEL_8;
  }
  appendStringInfoString((uint64_t)a1, v5);
LABEL_8:
  uint64_t v6 = *(char **)(a2 + 8);
  if (v6)
  {
    appendStringInfoString((uint64_t)a1, v6);
    appendStringInfoChar((uint64_t)a1, 32);
  }
  deparseTypeName(a1, *(void *)(a2 + 16));
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(void *)(a2 + 32))
  {
    appendStringInfoString((uint64_t)a1, "= ");
    uint64_t result = (uint64_t)deparseExpr(a1, *(int **)(a2 + 32), v8, v9, v10, v11, v12, v13);
  }
  int v14 = a1[2];
  BOOL v15 = __OFSUB__(v14, 1);
  uint64_t v16 = (v14 - 1);
  if ((int)v16 < 0 == v15)
  {
    uint64_t v17 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v16) == 32)
    {
      a1[2] = v16;
      *(unsigned char *)(v17 + v16) = 0;
    }
  }
  return result;
}

uint64_t deparseFdwOptions(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = *(void *)(a2 + 16) + 8 * v4;
      uint64_t v6 = *(void *)v5;
      uint64_t v7 = *(const char **)(*(void *)v5 + 16);
      if (!strcmp(v7, "handler")) {
        break;
      }
      uint64_t result = strcmp(v7, "validator");
      if (!result)
      {
        if (*(void *)(v6 + 24))
        {
          uint64_t result = (uint64_t)appendStringInfoString(v3, "VALIDATOR ");
          uint64_t v8 = *(void *)(v6 + 24);
          if (v8 && *(int *)(v8 + 4) >= 1)
          {
            uint64_t v9 = 0;
            uint64_t v10 = 8;
            do
            {
              uint64_t v11 = *(void *)(v8 + 16);
              uint64_t v12 = quote_identifier(*(unsigned char **)(*(void *)(v11 + 8 * v9) + 8));
              uint64_t result = (uint64_t)appendStringInfoString(v3, v12);
              uint64_t v13 = *(int *)(v8 + 4);
              if (v11 + v10) {
                BOOL v14 = v11 + v10 >= (unint64_t)(*(void *)(v8 + 16) + 8 * v13);
              }
              else {
                BOOL v14 = 1;
              }
              if (!v14)
              {
                uint64_t result = appendStringInfoChar(v3, 46);
                uint64_t v13 = *(int *)(v8 + 4);
              }
              ++v9;
              v10 += 8;
            }
            while (v9 < v13);
          }
          goto LABEL_30;
        }
        uint64_t v22 = "NO VALIDATOR ";
        goto LABEL_29;
      }
LABEL_30:
      if (v5 != -8 && v5 + 8 < (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4))) {
        uint64_t result = appendStringInfoChar(v3, 32);
      }
      if (++v4 >= *(int *)(a2 + 4)) {
        return result;
      }
    }
    if (*(void *)(v6 + 24))
    {
      uint64_t result = (uint64_t)appendStringInfoString(v3, "HANDLER ");
      uint64_t v15 = *(void *)(v6 + 24);
      if (v15 && *(int *)(v15 + 4) >= 1)
      {
        uint64_t v16 = 0;
        uint64_t v17 = 8;
        do
        {
          uint64_t v18 = *(void *)(v15 + 16);
          uint64_t v19 = quote_identifier(*(unsigned char **)(*(void *)(v18 + 8 * v16) + 8));
          uint64_t result = (uint64_t)appendStringInfoString(v3, v19);
          uint64_t v20 = *(int *)(v15 + 4);
          if (v18 + v17) {
            BOOL v21 = v18 + v17 >= (unint64_t)(*(void *)(v15 + 16) + 8 * v20);
          }
          else {
            BOOL v21 = 1;
          }
          if (!v21)
          {
            uint64_t result = appendStringInfoChar(v3, 46);
            uint64_t v20 = *(int *)(v15 + 4);
          }
          ++v16;
          v17 += 8;
        }
        while (v16 < v20);
      }
      goto LABEL_30;
    }
    uint64_t v22 = "NO HANDLER ";
LABEL_29:
    uint64_t result = (uint64_t)appendStringInfoString(v3, v22);
    goto LABEL_30;
  }
  return result;
}

void *deparseAlterGenericOptions(uint64_t a1, uint64_t a2)
{
  appendStringInfoString(a1, "OPTIONS (");
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      switch(*(_DWORD *)(v7 + 32))
      {
        case 0:
          goto LABEL_9;
        case 1:
          uint64_t v8 = a1;
          uint64_t v9 = "SET ";
          goto LABEL_8;
        case 2:
          uint64_t v8 = a1;
          uint64_t v9 = "ADD ";
LABEL_8:
          appendStringInfoString(v8, v9);
LABEL_9:
          uint64_t v10 = quote_identifier(*(unsigned char **)(v7 + 16));
          appendStringInfoString(a1, v10);
          appendStringInfoChar(a1, 32);
          deparseStringLiteral(a1, *(char **)(*(void *)(v7 + 24) + 8));
          break;
        case 3:
          appendStringInfoString(a1, "DROP ");
          uint64_t v11 = quote_identifier(*(unsigned char **)(v7 + 16));
          appendStringInfoString(a1, v11);
          break;
        default:
          break;
      }
      if (v6 + v5) {
        BOOL v12 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4));
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12) {
        appendStringInfoString(a1, ", ");
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }

  return appendStringInfoString(a1, ") ");
}

uint64_t deparseCommonFuncOptItem(void *a1, uint64_t a2)
{
  uint64_t v4 = *(const char **)(a2 + 16);
  if (!strcmp(v4, "strict"))
  {
    int v7 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
    if (!v7)
    {
      uint64_t v8 = "CALLED ON NULL INPUT";
      goto LABEL_38;
    }
    if (v7 == 1)
    {
      uint64_t v8 = "RETURNS NULL ON NULL INPUT";
LABEL_38:
      return (uint64_t)appendStringInfoString((uint64_t)a1, v8);
    }
  }
  if (!strcmp(v4, "volatility"))
  {
    uint64_t v9 = *(const char **)(*(void *)(a2 + 24) + 8);
    if (!strcmp(v9, "immutable"))
    {
      uint64_t v8 = "IMMUTABLE";
      goto LABEL_38;
    }
    if (!strcmp(v9, "stable"))
    {
      uint64_t v8 = "STABLE";
      goto LABEL_38;
    }
    if (!strcmp(v9, "volatile"))
    {
      uint64_t v8 = "VOLATILE";
      goto LABEL_38;
    }
  }
  if (!strcmp(v4, "security"))
  {
    int v10 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
    if (!v10)
    {
      uint64_t v8 = "SECURITY INVOKER";
      goto LABEL_38;
    }
    if (v10 == 1)
    {
      uint64_t v8 = "SECURITY DEFINER";
      goto LABEL_38;
    }
  }
  if (strcmp(v4, "leakproof")) {
    goto LABEL_5;
  }
  int v11 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
  if (!v11)
  {
    uint64_t v8 = "NOT LEAKPROOF";
    goto LABEL_38;
  }
  if (v11 == 1)
  {
    uint64_t v8 = "LEAKPROOF";
    goto LABEL_38;
  }
LABEL_5:
  if (!strcmp(v4, "cost"))
  {
    BOOL v12 = "COST ";
LABEL_30:
    appendStringInfoString((uint64_t)a1, v12);
    uint64_t v18 = *(_DWORD **)(a2 + 24);
    return (uint64_t)deparseValue(a1, v18, 0, v13, v14, v15, v16, v17);
  }
  if (!strcmp(v4, "rows"))
  {
    BOOL v12 = "ROWS ";
    goto LABEL_30;
  }
  if (strcmp(v4, "support"))
  {
    if (!strcmp(v4, "set"))
    {
      uint64_t v5 = *(_DWORD **)(a2 + 24);
      if (*v5 == 273)
      {
        return deparseVariableSetStmt((uint64_t)a1, (uint64_t)v5);
      }
    }
    uint64_t result = strcmp(v4, "parallel");
    if (result) {
      return result;
    }
    appendStringInfoString((uint64_t)a1, "PARALLEL ");
    uint64_t v8 = quote_identifier(*(unsigned char **)(*(void *)(a2 + 24) + 8));
    goto LABEL_38;
  }
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "SUPPORT ");
  uint64_t v19 = *(void *)(a2 + 24);
  if (v19 && *(int *)(v19 + 4) >= 1)
  {
    uint64_t v20 = 0;
    uint64_t v21 = 8;
    do
    {
      uint64_t v22 = *(void *)(v19 + 16);
      uint64_t v23 = quote_identifier(*(unsigned char **)(*(void *)(v22 + 8 * v20) + 8));
      uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, v23);
      uint64_t v24 = *(int *)(v19 + 4);
      if (v22 + v21) {
        BOOL v25 = v22 + v21 >= (unint64_t)(*(void *)(v19 + 16) + 8 * v24);
      }
      else {
        BOOL v25 = 1;
      }
      if (!v25)
      {
        uint64_t result = appendStringInfoChar((uint64_t)a1, 46);
        uint64_t v24 = *(int *)(v19 + 4);
      }
      ++v20;
      v21 += 8;
    }
    while (v20 < v24);
  }
  return result;
}

void *deparseOperatorDefList(void *result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      uint64_t v8 = quote_identifier(*(unsigned char **)(v7 + 16));
      appendStringInfoString((uint64_t)v3, v8);
      appendStringInfoString((uint64_t)v3, " = ");
      uint64_t v14 = *(void *)(v7 + 24);
      if (v14)
      {
        uint64_t result = deparseDefArg(v3, v14, 1, v9, v10, v11, v12, v13);
        uint64_t v15 = *(int *)(a2 + 4);
        unint64_t v16 = v6 + v5;
        if (v6 + v5) {
          goto LABEL_9;
        }
      }
      else
      {
        uint64_t result = appendStringInfoString((uint64_t)v3, "NONE");
        uint64_t v15 = *(int *)(a2 + 4);
        unint64_t v16 = v6 + v5;
        if (v6 + v5)
        {
LABEL_9:
          if (v16 < *(void *)(a2 + 16) + 8 * v15)
          {
            uint64_t result = appendStringInfoString((uint64_t)v3, ", ");
            uint64_t v15 = *(int *)(a2 + 4);
          }
        }
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v15);
  }
  return result;
}

uint64_t deparseColumnDef(uint64_t result, void *a2)
{
  uint64_t v3 = (_DWORD *)result;
  uint64_t v4 = (char *)a2[1];
  if (v4)
  {
    appendStringInfoString(result, v4);
    uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
  }
  uint64_t v5 = a2[2];
  if (v5)
  {
    deparseTypeName(v3, v5);
    uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
  }
  if (a2[4])
  {
    appendStringInfoString((uint64_t)v3, "USING ");
    deparseExpr(v3, a2[4]);
    uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
  }
  uint64_t v6 = a2[12];
  if (v6)
  {
    deparseCreateGenericOptions(v3, v6);
    uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
  }
  uint64_t v7 = a2[11];
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    uint64_t v8 = 0;
    do
    {
      deparseConstraint(v3, *(void *)(*(void *)(v7 + 16) + 8 * v8));
      uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
      ++v8;
    }
    while (v8 < *(int *)(v7 + 4));
  }
  uint64_t v9 = a2[9];
  if (v9) {
    uint64_t result = deparseCollateClause((uint64_t)v3, v9);
  }
  int v10 = v3[2];
  BOOL v11 = __OFSUB__(v10, 1);
  uint64_t v12 = (v10 - 1);
  if ((int)v12 < 0 == v11)
  {
    uint64_t v13 = *(void *)v3;
    if (*(unsigned char *)(*(void *)v3 + v12) == 32)
    {
      v3[2] = v12;
      *(unsigned char *)(v13 + v12) = 0;
    }
  }
  return result;
}

void *deparsePartitionBoundSpec(void *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 5))
  {
    return appendStringInfoString((uint64_t)a1, "DEFAULT");
  }
  uint64_t result = appendStringInfoString((uint64_t)a1, "FOR VALUES ");
  int v11 = *(char *)(a2 + 4);
  switch(v11)
  {
    case 'r':
      appendStringInfoString((uint64_t)a1, "FROM (");
      uint64_t v18 = *(void *)(a2 + 24);
      if (v18 && *(int *)(v18 + 4) >= 1)
      {
        uint64_t v19 = 0;
        uint64_t v20 = 8;
        do
        {
          uint64_t v21 = *(void *)(v18 + 16);
          deparseExpr(a1, *(int **)(v21 + 8 * v19), v12, v13, v14, v15, v16, v17);
          uint64_t v22 = *(int *)(v18 + 4);
          if (v21 + v20) {
            BOOL v23 = v21 + v20 >= (unint64_t)(*(void *)(v18 + 16) + 8 * v22);
          }
          else {
            BOOL v23 = 1;
          }
          if (!v23)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            uint64_t v22 = *(int *)(v18 + 4);
          }
          ++v19;
          v20 += 8;
        }
        while (v19 < v22);
      }
      appendStringInfoString((uint64_t)a1, ") TO (");
      uint64_t v42 = *(void *)(a2 + 32);
      if (v42 && *(int *)(v42 + 4) >= 1)
      {
        uint64_t v43 = 0;
        uint64_t v44 = 8;
        do
        {
          uint64_t v45 = *(void *)(v42 + 16);
          deparseExpr(a1, *(int **)(v45 + 8 * v43), v36, v37, v38, v39, v40, v41);
          uint64_t v46 = *(int *)(v42 + 4);
          if (v45 + v44) {
            BOOL v47 = v45 + v44 >= (unint64_t)(*(void *)(v42 + 16) + 8 * v46);
          }
          else {
            BOOL v47 = 1;
          }
          if (!v47)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            uint64_t v46 = *(int *)(v42 + 4);
          }
          ++v43;
          v44 += 8;
        }
        while (v43 < v46);
      }
      break;
    case 'l':
      appendStringInfoString((uint64_t)a1, "IN (");
      uint64_t v30 = *(void *)(a2 + 16);
      if (v30 && *(int *)(v30 + 4) >= 1)
      {
        uint64_t v31 = 0;
        uint64_t v32 = 8;
        do
        {
          uint64_t v33 = *(void *)(v30 + 16);
          deparseExpr(a1, *(int **)(v33 + 8 * v31), v24, v25, v26, v27, v28, v29);
          uint64_t v34 = *(int *)(v30 + 4);
          if (v33 + v32) {
            BOOL v35 = v33 + v32 >= (unint64_t)(*(void *)(v30 + 16) + 8 * v34);
          }
          else {
            BOOL v35 = 1;
          }
          if (!v35)
          {
            appendStringInfoString((uint64_t)a1, ", ");
            uint64_t v34 = *(int *)(v30 + 4);
          }
          ++v31;
          v32 += 8;
        }
        while (v31 < v34);
      }
      break;
    case 'h':
      return (void *)appendStringInfo((uint64_t)a1, "WITH (MODULUS %d, REMAINDER %d)", v5, v6, v7, v8, v9, v10, *(unsigned int *)(a2 + 8));
    default:
      return result;
  }

  return (void *)appendStringInfoChar((uint64_t)a1, 41);
}

void *deparseCreateGenericOptions(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)result;
    appendStringInfoString((uint64_t)result, "OPTIONS (");
    if (*(int *)(a2 + 4) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a2 + 16);
        uint64_t v7 = *(void *)(v6 + 8 * v4);
        uint64_t v8 = quote_identifier(*(unsigned char **)(v7 + 16));
        appendStringInfoString(v3, v8);
        appendStringInfoChar(v3, 32);
        deparseStringLiteral(v3, *(char **)(*(void *)(v7 + 24) + 8));
        uint64_t v9 = *(int *)(a2 + 4);
        if (v6 + v5) {
          BOOL v10 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v9);
        }
        else {
          BOOL v10 = 1;
        }
        if (!v10)
        {
          appendStringInfoString(v3, ", ");
          uint64_t v9 = *(int *)(a2 + 4);
        }
        ++v4;
        v5 += 8;
      }
      while (v4 < v9);
    }
    return appendStringInfoString(v3, ") ");
  }
  return result;
}

uint64_t deparseDefinition(void *a1, uint64_t a2)
{
  appendStringInfoChar((uint64_t)a1, 40);
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      uint64_t v8 = quote_identifier(*(unsigned char **)(v7 + 16));
      appendStringInfoString((uint64_t)a1, v8);
      if (*(void *)(v7 + 24))
      {
        appendStringInfoString((uint64_t)a1, " = ");
        deparseDefArg(a1, *(void *)(v7 + 24), 0, v9, v10, v11, v12, v13);
      }
      uint64_t v14 = *(int *)(a2 + 4);
      if (v6 + v5) {
        BOOL v15 = v6 + v5 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v14);
      }
      else {
        BOOL v15 = 1;
      }
      if (!v15)
      {
        appendStringInfoString((uint64_t)a1, ", ");
        uint64_t v14 = *(int *)(a2 + 4);
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v14);
  }

  return appendStringInfoChar((uint64_t)a1, 41);
}

unint64_t deparseAlterRoleElem(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const char **)(a2 + 16);
  if (strcmp(v4, "password"))
  {
    if (!strcmp(v4, "connectionlimit")) {
      return appendStringInfo(a1, "CONNECTION LIMIT %d", v5, v6, v7, v8, v9, v10, *(unsigned int *)(*(void *)(a2 + 24) + 8));
    }
    if (strcmp(v4, "validUntil"))
    {
      if (strcmp(v4, "superuser")) {
        goto LABEL_33;
      }
      int v23 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
      if (!v23)
      {
        uint64_t v13 = "NOSUPERUSER";
        goto LABEL_26;
      }
      if (v23 == 1)
      {
        uint64_t v13 = "SUPERUSER";
      }
      else
      {
        if (strcmp(v4, "createrole")) {
          goto LABEL_36;
        }
LABEL_33:
        int v24 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
        if (!v24)
        {
          uint64_t v13 = "NOCREATEROLE";
          goto LABEL_26;
        }
        if (v24 == 1)
        {
          uint64_t v13 = "CREATEROLE";
        }
        else
        {
          if (strcmp(v4, "isreplication")) {
            goto LABEL_39;
          }
LABEL_36:
          int v25 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
          if (!v25)
          {
            uint64_t v13 = "NOREPLICATION";
            goto LABEL_26;
          }
          if (v25 == 1)
          {
            uint64_t v13 = "REPLICATION";
          }
          else
          {
            if (strcmp(v4, "createdb")) {
              goto LABEL_46;
            }
LABEL_39:
            int v26 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
            if (!v26)
            {
              uint64_t v13 = "NOCREATEDB";
              goto LABEL_26;
            }
            if (v26 == 1)
            {
              uint64_t v13 = "CREATEDB";
            }
            else
            {
              if (strcmp(v4, "canlogin")) {
                goto LABEL_59;
              }
LABEL_46:
              int v27 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
              if (!v27)
              {
                uint64_t v13 = "NOLOGIN";
                goto LABEL_26;
              }
              if (v27 == 1)
              {
                uint64_t v13 = "LOGIN";
              }
              else
              {
LABEL_59:
                if (strcmp(v4, "bypassrls")) {
                  goto LABEL_10;
                }
                int v28 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
                if (v28)
                {
                  if (v28 != 1)
                  {
LABEL_10:
                    unint64_t result = strcmp(v4, "inherit");
                    if (result) {
                      return result;
                    }
                    int v12 = *(_DWORD *)(*(void *)(a2 + 24) + 8);
                    if (v12)
                    {
                      if (v12 != 1) {
                        return result;
                      }
                      uint64_t v13 = "INHERIT";
                    }
                    else
                    {
                      uint64_t v13 = "NOINHERIT";
                    }
                    goto LABEL_26;
                  }
                  uint64_t v13 = "BYPASSRLS";
                }
                else
                {
                  uint64_t v13 = "NOBYPASSRLS";
                }
              }
            }
          }
        }
      }
LABEL_26:
      return (unint64_t)appendStringInfoString(a1, v13);
    }
    appendStringInfoString(a1, "VALID UNTIL ");
    uint64_t v20 = *(void *)(a2 + 24);
LABEL_22:
    uint64_t v22 = *(char **)(v20 + 8);
    return deparseStringLiteral(a1, v22);
  }
  unint64_t result = (unint64_t)appendStringInfoString(a1, "PASSWORD ");
  uint64_t v20 = *(void *)(a2 + 24);
  if (!v20)
  {
    uint64_t v13 = "NULL";
    goto LABEL_26;
  }
  if (*(_DWORD *)v20 == 223) {
    goto LABEL_22;
  }
  if (*(_DWORD *)v20 == 348)
  {
    size_t v21 = *(unsigned int *)(v20 + 4);
    if (v21)
    {
      return appendStringInfo(a1, "$%d", v14, v15, v16, v17, v18, v19, v21);
    }
    else
    {
      return appendStringInfoChar(a1, 63);
    }
  }
  return result;
}

uint64_t deparseAnyNameList(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 4);
    if (v3 >= 1)
    {
      uint64_t v4 = result;
      for (uint64_t i = 0; i < v3; ++i)
      {
        while (1)
        {
          uint64_t v6 = *(void *)(a2 + 16);
          uint64_t v7 = (uint64_t *)(v6 + 8 * i);
          uint64_t v8 = *v7;
          if (*v7 && *(int *)(v8 + 4) >= 1)
          {
            uint64_t v9 = 0;
            uint64_t v10 = 8;
            do
            {
              uint64_t v11 = *(void *)(v8 + 16);
              int v12 = quote_identifier(*(unsigned char **)(*(void *)(v11 + 8 * v9) + 8));
              unint64_t result = (uint64_t)appendStringInfoString(v4, v12);
              uint64_t v13 = *(int *)(v8 + 4);
              if (v11 + v10) {
                BOOL v14 = v11 + v10 >= (unint64_t)(*(void *)(v8 + 16) + 8 * v13);
              }
              else {
                BOOL v14 = 1;
              }
              if (!v14)
              {
                unint64_t result = appendStringInfoChar(v4, 46);
                uint64_t v13 = *(int *)(v8 + 4);
              }
              ++v9;
              v10 += 8;
            }
            while (v9 < v13);
            int v3 = *(_DWORD *)(a2 + 4);
            uint64_t v6 = *(void *)(a2 + 16);
          }
          unint64_t v15 = v6 + 8 * v3;
          if (v7 == (uint64_t *)-8 || (unint64_t)(v7 + 1) >= v15) {
            break;
          }
          unint64_t result = (uint64_t)appendStringInfoString(v4, ", ");
          int v3 = *(_DWORD *)(a2 + 4);
          if (++i >= v3) {
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t deparseIntoClause(_DWORD *a1, uint64_t a2)
{
  deparseRangeVar((uint64_t)a1, *(void *)(a2 + 8), 0);
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4 && *(int *)(v4 + 4) >= 1)
  {
    appendStringInfoChar((uint64_t)a1, 40);
    uint64_t v5 = *(void *)(a2 + 16);
    if (v5 && *(int *)(v5 + 4) >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8;
      do
      {
        uint64_t v8 = *(void *)(v5 + 16);
        uint64_t v9 = quote_identifier(*(unsigned char **)(*(void *)(v8 + 8 * v6) + 8));
        appendStringInfoString((uint64_t)a1, v9);
        uint64_t v10 = *(int *)(v5 + 4);
        if (v8 + v7) {
          BOOL v11 = v8 + v7 >= (unint64_t)(*(void *)(v5 + 16) + 8 * v10);
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11)
        {
          appendStringInfoString((uint64_t)a1, ", ");
          uint64_t v10 = *(int *)(v5 + 4);
        }
        ++v6;
        v7 += 8;
      }
      while (v6 < v10);
    }
    appendStringInfoChar((uint64_t)a1, 41);
  }
  uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  if (*(void *)(a2 + 24))
  {
    appendStringInfoString((uint64_t)a1, "USING ");
    uint64_t v13 = quote_identifier(*(unsigned char **)(a2 + 24));
    appendStringInfoString((uint64_t)a1, v13);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  uint64_t v14 = *(void *)(a2 + 32);
  if (v14 && *(int *)(v14 + 4) >= 1)
  {
    appendStringInfoString((uint64_t)a1, "WITH ");
    deparseRelOptions(a1, v14);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  unsigned int v15 = *(_DWORD *)(a2 + 40) - 1;
  if (v15 <= 2) {
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, (&off_1E55D8F28)[v15]);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfoString((uint64_t)a1, "TABLESPACE ");
    uint64_t v16 = quote_identifier(*(unsigned char **)(a2 + 48));
    appendStringInfoString((uint64_t)a1, v16);
    uint64_t result = appendStringInfoChar((uint64_t)a1, 32);
  }
  int v17 = a1[2];
  BOOL v18 = __OFSUB__(v17, 1);
  uint64_t v19 = (v17 - 1);
  if ((int)v19 < 0 == v18)
  {
    uint64_t v20 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v19) == 32)
    {
      a1[2] = v19;
      *(unsigned char *)(v20 + v19) = 0;
    }
  }
  return result;
}

unint64_t deparseOpclassItemList(unint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    int v3 = (_DWORD *)result;
    for (uint64_t i = 0; i < *(int *)(a2 + 4); ++i)
    {
      uint64_t v5 = *(void *)(a2 + 16) + 8 * i;
      uint64_t v6 = *(void *)v5;
      int v7 = *(_DWORD *)(*(void *)v5 + 4);
      switch(v7)
      {
        case 3:
          appendStringInfoString((uint64_t)v3, "STORAGE ");
          uint64_t result = (unint64_t)deparseTypeName(v3, *(void *)(v6 + 40));
          break;
        case 2:
          appendStringInfoString((uint64_t)v3, "FUNCTION ");
          uint64_t result = appendStringInfo((uint64_t)v3, "%d ", v15, v16, v17, v18, v19, v20, *(unsigned int *)(v6 + 16));
          if (*(void *)(v6 + 32))
          {
            appendStringInfoChar((uint64_t)v3, 40);
            uint64_t v21 = *(void *)(v6 + 32);
            if (v21 && *(int *)(v21 + 4) >= 1)
            {
              uint64_t v22 = 0;
              uint64_t v23 = 8;
              do
              {
                uint64_t v24 = *(void *)(v21 + 16);
                deparseTypeName(v3, *(void *)(v24 + 8 * v22));
                uint64_t v25 = *(int *)(v21 + 4);
                if (v24 + v23) {
                  BOOL v26 = v24 + v23 >= (unint64_t)(*(void *)(v21 + 16) + 8 * v25);
                }
                else {
                  BOOL v26 = 1;
                }
                if (!v26)
                {
                  appendStringInfoString((uint64_t)v3, ", ");
                  uint64_t v25 = *(int *)(v21 + 4);
                }
                ++v22;
                v23 += 8;
              }
              while (v22 < v25);
            }
            uint64_t result = (unint64_t)appendStringInfoString((uint64_t)v3, ") ");
          }
          uint64_t v27 = *(void *)(v6 + 8);
          if (v27) {
            uint64_t result = deparseFunctionWithArgtypes((uint64_t)v3, v27);
          }
          goto LABEL_53;
        case 1:
          appendStringInfoString((uint64_t)v3, "OPERATOR ");
          uint64_t result = appendStringInfo((uint64_t)v3, "%d ", v8, v9, v10, v11, v12, v13, *(unsigned int *)(v6 + 16));
          uint64_t v14 = *(void *)(v6 + 8);
          if (v14)
          {
            if (*(void *)(v14 + 16))
            {
              deparseOperatorWithArgtypes(v3, v14);
              goto LABEL_31;
            }
            uint64_t v28 = *(void *)(v14 + 8);
            if (v28)
            {
              int v29 = *(_DWORD *)(v28 + 4);
              if (v29 == 1)
              {
                uint64_t v31 = *(void *)(v28 + 16);
LABEL_30:
                appendStringInfoString((uint64_t)v3, *(char **)(*(void *)v31 + 8));
              }
              else if (v29 == 2)
              {
                uint64_t v30 = quote_identifier(*(unsigned char **)(**(void **)(v28 + 16) + 8));
                appendStringInfoString((uint64_t)v3, v30);
                appendStringInfoChar((uint64_t)v3, 46);
                uint64_t v31 = *(void *)(v28 + 16) + 8 * (*(_DWORD *)(v28 + 4) - 1);
                goto LABEL_30;
              }
            }
LABEL_31:
            uint64_t result = appendStringInfoChar((uint64_t)v3, 32);
          }
          if (*(void *)(v6 + 24))
          {
            uint64_t result = (unint64_t)appendStringInfoString((uint64_t)v3, "FOR ORDER BY ");
            uint64_t v32 = *(void *)(v6 + 24);
            if (v32)
            {
              if (*(int *)(v32 + 4) >= 1)
              {
                uint64_t v33 = 0;
                uint64_t v34 = 8;
                do
                {
                  uint64_t v35 = *(void *)(v32 + 16);
                  uint64_t v36 = quote_identifier(*(unsigned char **)(*(void *)(v35 + 8 * v33) + 8));
                  uint64_t result = (unint64_t)appendStringInfoString((uint64_t)v3, v36);
                  uint64_t v37 = *(int *)(v32 + 4);
                  if (v35 + v34) {
                    BOOL v38 = v35 + v34 >= (unint64_t)(*(void *)(v32 + 16) + 8 * v37);
                  }
                  else {
                    BOOL v38 = 1;
                  }
                  if (!v38)
                  {
                    uint64_t result = appendStringInfoChar((uint64_t)v3, 46);
                    uint64_t v37 = *(int *)(v32 + 4);
                  }
                  ++v33;
                  v34 += 8;
                }
                while (v33 < v37);
              }
            }
          }
          if (*(void *)(v6 + 32))
          {
            appendStringInfoChar((uint64_t)v3, 40);
            uint64_t v39 = *(void *)(v6 + 32);
            if (v39 && *(int *)(v39 + 4) >= 1)
            {
              uint64_t v40 = 0;
              uint64_t v41 = 8;
              do
              {
                uint64_t v42 = *(void *)(v39 + 16);
                deparseTypeName(v3, *(void *)(v42 + 8 * v40));
                uint64_t v43 = *(int *)(v39 + 4);
                if (v42 + v41) {
                  BOOL v44 = v42 + v41 >= (unint64_t)(*(void *)(v39 + 16) + 8 * v43);
                }
                else {
                  BOOL v44 = 1;
                }
                if (!v44)
                {
                  appendStringInfoString((uint64_t)v3, ", ");
                  uint64_t v43 = *(int *)(v39 + 4);
                }
                ++v40;
                v41 += 8;
              }
              while (v40 < v43);
            }
            uint64_t result = appendStringInfoChar((uint64_t)v3, 41);
          }
LABEL_53:
          int v45 = v3[2];
          BOOL v46 = __OFSUB__(v45, 1);
          uint64_t v47 = (v45 - 1);
          if ((int)v47 < 0 == v46)
          {
            uint64_t v48 = *(void *)v3;
            if (*(unsigned char *)(*(void *)v3 + v47) == 32)
            {
              v3[2] = v47;
              *(unsigned char *)(v48 + v47) = 0;
            }
          }
          break;
      }
      if (v5 != -8 && v5 + 8 < (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4))) {
        uint64_t result = (unint64_t)appendStringInfoString((uint64_t)v3, ", ");
      }
    }
  }
  return result;
}

_DWORD *deparseTableRef(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  int v10 = *(_DWORD *)a2;
  switch(*(_DWORD *)a2)
  {
    case 0x169:
      if (*(unsigned char *)(a2 + 4)) {
        appendStringInfoString((uint64_t)result, "LATERAL ");
      }
      appendStringInfoChar((uint64_t)v9, 40);
      deparseSelectStmt(v9, *(void *)(a2 + 8));
      uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 41);
      if (*(void *)(a2 + 16))
      {
        appendStringInfoChar((uint64_t)v9, 32);
        uint64_t v11 = *(void *)(a2 + 16);
        return deparseAlias((uint64_t)v9, v11);
      }
      return result;
    case 0x16A:
      if (*(unsigned char *)(a2 + 4)) {
        appendStringInfoString((uint64_t)result, "LATERAL ");
      }
      if (*(unsigned char *)(a2 + 6))
      {
        appendStringInfoString((uint64_t)v9, "ROWS FROM ");
        appendStringInfoChar((uint64_t)v9, 40);
        uint64_t v18 = *(void *)(a2 + 8);
        if (v18 && *(int *)(v18 + 4) >= 1)
        {
          uint64_t v19 = 0;
          do
          {
            uint64_t v20 = *(void *)(v18 + 16) + 8 * v19;
            uint64_t v21 = *(void *)v20;
            deparseFuncExprWindowless(v9, **(void **)(*(void *)v20 + 16), v12, v13, v14, v15, v16, v17);
            appendStringInfoChar((uint64_t)v9, 32);
            uint64_t v22 = *(void *)(*(void *)(v21 + 16) + 8);
            if (v22 && *(int *)(v22 + 4) >= 1)
            {
              appendStringInfoString((uint64_t)v9, "AS (");
              if (*(int *)(v22 + 4) >= 1)
              {
                uint64_t v23 = 0;
                uint64_t v24 = 8;
                do
                {
                  uint64_t v25 = *(void *)(v22 + 16);
                  deparseColumnDef((uint64_t)v9, *(void **)(v25 + 8 * v23));
                  uint64_t v26 = *(int *)(v22 + 4);
                  if (v25 + v24) {
                    BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(v22 + 16) + 8 * v26);
                  }
                  else {
                    BOOL v27 = 1;
                  }
                  if (!v27)
                  {
                    appendStringInfoString((uint64_t)v9, ", ");
                    uint64_t v26 = *(int *)(v22 + 4);
                  }
                  ++v23;
                  v24 += 8;
                }
                while (v23 < v26);
              }
              appendStringInfoChar((uint64_t)v9, 41);
            }
            if (v20 != -8
              && v20 + 8 < (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
                                            + 8 * *(int *)(*(void *)(a2 + 8) + 4)))
            {
              appendStringInfoString((uint64_t)v9, ", ");
            }
            ++v19;
          }
          while (v19 < *(int *)(v18 + 4));
        }
        appendStringInfoChar((uint64_t)v9, 41);
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(unsigned char *)(a2 + 5)) {
          goto LABEL_77;
        }
      }
      else
      {
        deparseFuncExprWindowless(v9, **(void **)(**(void **)(*(void *)(a2 + 8) + 16) + 16), a3, a4, a5, a6, a7, a8);
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(unsigned char *)(a2 + 5)) {
          goto LABEL_77;
        }
      }
      uint64_t result = appendStringInfoString((uint64_t)v9, "WITH ORDINALITY ");
LABEL_77:
      uint64_t v53 = *(void *)(a2 + 16);
      if (v53)
      {
        deparseAlias((uint64_t)v9, v53);
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
      }
      uint64_t v54 = *(void *)(a2 + 24);
      if (v54 && *(int *)(v54 + 4) >= 1)
      {
        if (!*(void *)(a2 + 16)) {
          appendStringInfoString((uint64_t)v9, "AS ");
        }
        appendStringInfoChar((uint64_t)v9, 40);
        uint64_t v55 = *(void *)(a2 + 24);
        if (v55 && *(int *)(v55 + 4) >= 1)
        {
          uint64_t v56 = 0;
          uint64_t v57 = 8;
          do
          {
            uint64_t v58 = *(void *)(v55 + 16);
            deparseColumnDef((uint64_t)v9, *(void **)(v58 + 8 * v56));
            if (v58 + v57) {
              BOOL v59 = v58 + v57 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
            }
                                                  + 8 * *(int *)(*(void *)(a2 + 24) + 4));
            else {
              BOOL v59 = 1;
            }
            if (!v59) {
              appendStringInfoString((uint64_t)v9, ", ");
            }
            ++v56;
            v57 += 8;
          }
          while (v56 < *(int *)(v55 + 4));
        }
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 41);
      }
      goto LABEL_149;
    case 0x16B:
      deparseRangeVar((uint64_t)result, *(void *)(a2 + 8), 0);
      appendStringInfoString((uint64_t)v9, " TABLESAMPLE ");
      uint64_t v29 = *(void *)(a2 + 16);
      if (v29 && *(int *)(v29 + 4) >= 1)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8;
        do
        {
          uint64_t v32 = *(void *)(v29 + 16);
          uint64_t v33 = quote_identifier(*(unsigned char **)(*(void *)(v32 + 8 * v30) + 8));
          appendStringInfoString((uint64_t)v9, v33);
          uint64_t v34 = *(int *)(v29 + 4);
          if (v32 + v31) {
            BOOL v35 = v32 + v31 >= (unint64_t)(*(void *)(v29 + 16) + 8 * v34);
          }
          else {
            BOOL v35 = 1;
          }
          if (!v35)
          {
            appendStringInfoChar((uint64_t)v9, 46);
            uint64_t v34 = *(int *)(v29 + 4);
          }
          ++v30;
          v31 += 8;
        }
        while (v30 < v34);
      }
      appendStringInfoChar((uint64_t)v9, 40);
      uint64_t v47 = *(void *)(a2 + 24);
      if (v47 && *(int *)(v47 + 4) >= 1)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 8;
        do
        {
          uint64_t v50 = *(void *)(v47 + 16);
          deparseExpr(v9, *(void *)(v50 + 8 * v48));
          uint64_t v51 = *(int *)(v47 + 4);
          if (v50 + v49) {
            BOOL v52 = v50 + v49 >= (unint64_t)(*(void *)(v47 + 16) + 8 * v51);
          }
          else {
            BOOL v52 = 1;
          }
          if (!v52)
          {
            appendStringInfoString((uint64_t)v9, ", ");
            uint64_t v51 = *(int *)(v47 + 4);
          }
          ++v48;
          v49 += 8;
        }
        while (v48 < v51);
      }
      uint64_t result = appendStringInfoString((uint64_t)v9, ") ");
      if (*(void *)(a2 + 32))
      {
        appendStringInfoString((uint64_t)v9, "REPEATABLE (");
        deparseExpr(v9, *(void *)(a2 + 32));
        uint64_t result = appendStringInfoString((uint64_t)v9, ") ");
      }
      goto LABEL_149;
    case 0x16C:
      if (*(unsigned char *)(a2 + 4)) {
        appendStringInfoString((uint64_t)result, "LATERAL ");
      }
      appendStringInfoString((uint64_t)v9, "xmltable(");
      if (*(void *)(a2 + 24))
      {
        appendStringInfoString((uint64_t)v9, "xmlnamespaces(");
        uint64_t v36 = *(void *)(a2 + 24);
        if (v36 && *(int *)(v36 + 4) >= 1)
        {
          uint64_t v37 = 0;
          uint64_t v38 = 8;
          do
          {
            uint64_t v39 = *(void *)(v36 + 16);
            uint64_t v40 = *(void *)(v39 + 8 * v37);
            if (!*(void *)(v40 + 8)) {
              appendStringInfoString((uint64_t)v9, "DEFAULT ");
            }
            deparseExpr(v9, *(void *)(v40 + 24));
            if (*(void *)(v40 + 8))
            {
              appendStringInfoString((uint64_t)v9, " AS ");
              uint64_t v41 = quote_identifier(*(unsigned char **)(v40 + 8));
              appendStringInfoString((uint64_t)v9, v41);
            }
            uint64_t v42 = *(int *)(v36 + 4);
            if (v39 + v38) {
              BOOL v43 = v39 + v38 >= (unint64_t)(*(void *)(v36 + 16) + 8 * v42);
            }
            else {
              BOOL v43 = 1;
            }
            if (!v43)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v42 = *(int *)(v36 + 4);
            }
            ++v37;
            v38 += 8;
          }
          while (v37 < v42);
        }
        appendStringInfoString((uint64_t)v9, "), ");
      }
      appendStringInfoChar((uint64_t)v9, 40);
      deparseExpr(v9, *(void *)(a2 + 16));
      appendStringInfoChar((uint64_t)v9, 41);
      appendStringInfoString((uint64_t)v9, " PASSING ");
      deparseExpr(v9, *(void *)(a2 + 8));
      appendStringInfoString((uint64_t)v9, " COLUMNS ");
      uint64_t v60 = *(void *)(a2 + 32);
      if (v60 && *(int *)(v60 + 4) >= 1)
      {
        uint64_t v61 = 0;
        uint64_t v62 = 8;
        do
        {
          uint64_t v63 = *(void *)(v60 + 16);
          uint64_t v64 = *(void *)(v63 + 8 * v61);
          uint64_t v65 = quote_identifier(*(unsigned char **)(v64 + 8));
          appendStringInfoString((uint64_t)v9, v65);
          appendStringInfoChar((uint64_t)v9, 32);
          uint64_t v66 = "FOR ORDINALITY ";
          if (*(unsigned char *)(v64 + 24)) {
            goto LABEL_103;
          }
          deparseTypeName(v9, *(void *)(v64 + 16));
          appendStringInfoChar((uint64_t)v9, 32);
          if (*(void *)(v64 + 32))
          {
            appendStringInfoString((uint64_t)v9, "PATH ");
            deparseExpr(v9, *(void *)(v64 + 32));
            appendStringInfoChar((uint64_t)v9, 32);
          }
          if (*(void *)(v64 + 40))
          {
            appendStringInfoString((uint64_t)v9, "DEFAULT ");
            deparseExpr(v9, *(void *)(v64 + 40));
            appendStringInfoChar((uint64_t)v9, 32);
          }
          uint64_t v66 = "NOT NULL ";
          if (*(unsigned char *)(v64 + 25)) {
LABEL_103:
          }
            appendStringInfoString((uint64_t)v9, v66);
          int v67 = v9[2];
          BOOL v68 = __OFSUB__(v67, 1);
          uint64_t v69 = (v67 - 1);
          if ((int)v69 < 0 == v68)
          {
            uint64_t v70 = *(void *)v9;
            if (*(unsigned char *)(*(void *)v9 + v69) == 32)
            {
              void v9[2] = v69;
              *(unsigned char *)(v70 + v69) = 0;
            }
          }
          if (v63 + v62
            && v63 + v62 < (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
                                            + 8 * *(int *)(*(void *)(a2 + 32) + 4)))
          {
            appendStringInfoString((uint64_t)v9, ", ");
          }
          ++v61;
          v62 += 8;
        }
        while (v61 < *(int *)(v60 + 4));
      }
      uint64_t result = appendStringInfoString((uint64_t)v9, ") ");
      if (!*(void *)(a2 + 40)) {
        goto LABEL_149;
      }
      appendStringInfoString((uint64_t)v9, "AS ");
      uint64_t v71 = *(void *)(a2 + 40);
      goto LABEL_148;
    default:
      if (v10 != 150)
      {
        if (v10 == 103)
        {
          return (_DWORD *)deparseRangeVar((uint64_t)result, a2, 0);
        }
        return result;
      }
      uint64_t v44 = *(void *)(a2 + 48);
      uint64_t v45 = *(void *)(a2 + 24);
      if (*(_DWORD *)v45 == 150)
      {
        BOOL v46 = *(void *)(v45 + 48) == 0;
        if (!v44) {
          goto LABEL_114;
        }
      }
      else
      {
        BOOL v46 = 0;
        if (!v44) {
          goto LABEL_114;
        }
      }
      appendStringInfoChar((uint64_t)result, 40);
LABEL_114:
      deparseTableRef(v9, *(void *)(a2 + 16));
      appendStringInfoChar((uint64_t)v9, 32);
      if (*(unsigned char *)(a2 + 8)) {
        appendStringInfoString((uint64_t)v9, "NATURAL ");
      }
      uint64_t v72 = "LEFT ";
      switch(*(_DWORD *)(a2 + 4))
      {
        case 0:
          if (!*(unsigned char *)(a2 + 8) && !*(void *)(a2 + 40))
          {
            uint64_t v73 = *(void *)(a2 + 32);
            if (!v73 || !*(_DWORD *)(v73 + 4))
            {
              uint64_t v72 = "CROSS ";
              goto LABEL_127;
            }
          }
          break;
        case 1:
          goto LABEL_127;
        case 2:
          uint64_t v72 = "FULL ";
          goto LABEL_127;
        case 3:
          uint64_t v72 = "RIGHT ";
LABEL_127:
          appendStringInfoString((uint64_t)v9, v72);
          break;
        default:
          break;
      }
      appendStringInfoString((uint64_t)v9, "JOIN ");
      if (v46)
      {
        appendStringInfoChar((uint64_t)v9, 40);
        deparseTableRef(v9, *(void *)(a2 + 24));
        appendStringInfoChar((uint64_t)v9, 41);
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(void *)(a2 + 40)) {
          goto LABEL_133;
        }
      }
      else
      {
        deparseTableRef(v9, *(void *)(a2 + 24));
        uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
        if (!*(void *)(a2 + 40)) {
          goto LABEL_133;
        }
      }
      appendStringInfoString((uint64_t)v9, "ON ");
      deparseExpr(v9, *(void *)(a2 + 40));
      uint64_t result = (_DWORD *)appendStringInfoChar((uint64_t)v9, 32);
LABEL_133:
      uint64_t v74 = *(void *)(a2 + 32);
      if (v74 && *(int *)(v74 + 4) >= 1)
      {
        appendStringInfoString((uint64_t)v9, "USING (");
        uint64_t v75 = *(void *)(a2 + 32);
        if (v75 && *(int *)(v75 + 4) >= 1)
        {
          uint64_t v76 = 0;
          uint64_t v77 = 8;
          do
          {
            uint64_t v78 = *(void *)(v75 + 16);
            size_t v79 = quote_identifier(*(unsigned char **)(*(void *)(v78 + 8 * v76) + 8));
            appendStringInfoString((uint64_t)v9, v79);
            uint64_t v80 = *(int *)(v75 + 4);
            if (v78 + v77) {
              BOOL v81 = v78 + v77 >= (unint64_t)(*(void *)(v75 + 16) + 8 * v80);
            }
            else {
              BOOL v81 = 1;
            }
            if (!v81)
            {
              appendStringInfoString((uint64_t)v9, ", ");
              uint64_t v80 = *(int *)(v75 + 4);
            }
            ++v76;
            v77 += 8;
          }
          while (v76 < v80);
        }
        uint64_t result = appendStringInfoString((uint64_t)v9, ") ");
      }
      if (v44) {
        uint64_t result = appendStringInfoString((uint64_t)v9, ") ");
      }
      uint64_t v71 = *(void *)(a2 + 48);
      if (v71) {
LABEL_148:
      }
        uint64_t result = deparseAlias((uint64_t)v9, v71);
LABEL_149:
      int v82 = v9[2];
      BOOL v68 = __OFSUB__(v82, 1);
      uint64_t v83 = (v82 - 1);
      if ((int)v83 < 0 == v68)
      {
        uint64_t v84 = *(void *)v9;
        if (*(unsigned char *)(*(void *)v9 + v83) == 32)
        {
          void v9[2] = v83;
          *(unsigned char *)(v84 + v83) = 0;
        }
      }
      return result;
  }
}

uint64_t deparseWithClause(_DWORD *a1, uint64_t a2)
{
  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "WITH ");
  if (*(unsigned char *)(a2 + 16)) {
    uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, "RECURSIVE ");
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5 && *(int *)(v5 + 4) >= 1)
  {
    uint64_t v6 = 0;
    while (2)
    {
      uint64_t v7 = *(void *)(v5 + 16) + 8 * v6;
      uint64_t v8 = *(void *)v7;
      uint64_t v9 = quote_identifier(*(unsigned char **)(*(void *)v7 + 8));
      appendStringInfoString((uint64_t)a1, v9);
      uint64_t v10 = *(void *)(v8 + 16);
      if (v10 && *(int *)(v10 + 4) >= 1)
      {
        appendStringInfoChar((uint64_t)a1, 40);
        uint64_t v11 = *(void *)(v8 + 16);
        if (v11 && *(int *)(v11 + 4) >= 1)
        {
          uint64_t v12 = 0;
          uint64_t v13 = 8;
          do
          {
            uint64_t v14 = *(void *)(v11 + 16);
            uint64_t v15 = quote_identifier(*(unsigned char **)(*(void *)(v14 + 8 * v12) + 8));
            appendStringInfoString((uint64_t)a1, v15);
            uint64_t v16 = *(int *)(v11 + 4);
            if (v14 + v13) {
              BOOL v17 = v14 + v13 >= (unint64_t)(*(void *)(v11 + 16) + 8 * v16);
            }
            else {
              BOOL v17 = 1;
            }
            if (!v17)
            {
              appendStringInfoString((uint64_t)a1, ", ");
              uint64_t v16 = *(int *)(v11 + 4);
            }
            ++v12;
            v13 += 8;
          }
          while (v12 < v16);
        }
        appendStringInfoChar((uint64_t)a1, 41);
      }
      appendStringInfoChar((uint64_t)a1, 32);
      appendStringInfoString((uint64_t)a1, "AS ");
      int v18 = *(_DWORD *)(v8 + 24);
      if (v18 == 1)
      {
        uint64_t v19 = "MATERIALIZED ";
      }
      else
      {
        if (v18 != 2)
        {
LABEL_24:
          appendStringInfoChar((uint64_t)a1, 40);
          uint64_t v20 = *(uint64_t **)(v8 + 32);
          switch(*(_DWORD *)v20)
          {
            case 0xE9:
              deparseInsertStmt(a1, (uint64_t)v20);
              uint64_t result = appendStringInfoChar((uint64_t)a1, 41);
              unint64_t v21 = v7 + 8;
              if (v7 != -8) {
                goto LABEL_31;
              }
              goto LABEL_6;
            case 0xEA:
              deparseDeleteStmt(a1, v20);
              uint64_t result = appendStringInfoChar((uint64_t)a1, 41);
              unint64_t v21 = v7 + 8;
              if (v7 != -8) {
                goto LABEL_31;
              }
              goto LABEL_6;
            case 0xEB:
              deparseUpdateStmt(a1, v20);
              goto LABEL_30;
            case 0xEC:
              deparseSelectStmt(a1, v20);
              uint64_t result = appendStringInfoChar((uint64_t)a1, 41);
              unint64_t v21 = v7 + 8;
              if (v7 == -8) {
                goto LABEL_6;
              }
              goto LABEL_31;
            default:
LABEL_30:
              uint64_t result = appendStringInfoChar((uint64_t)a1, 41);
              unint64_t v21 = v7 + 8;
              if (v7 != -8)
              {
LABEL_31:
                if (v21 < *(void *)(*(void *)(a2 + 8) + 16) + 8 * *(int *)(*(void *)(a2 + 8) + 4)) {
                  uint64_t result = (uint64_t)appendStringInfoString((uint64_t)a1, ", ");
                }
              }
LABEL_6:
              if (++v6 < *(int *)(v5 + 4)) {
                continue;
              }
              goto LABEL_35;
          }
        }
        uint64_t v19 = "NOT MATERIALIZED ";
      }
      break;
    }
    appendStringInfoString((uint64_t)a1, v19);
    goto LABEL_24;
  }
LABEL_35:
  int v22 = a1[2];
  BOOL v23 = __OFSUB__(v22, 1);
  uint64_t v24 = (v22 - 1);
  if ((int)v24 < 0 == v23)
  {
    uint64_t v25 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v24) == 32)
    {
      a1[2] = v24;
      *(unsigned char *)(v25 + v24) = 0;
    }
  }
  return result;
}

uint64_t deparseTargetList(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      uint64_t v8 = *(void *)(v7 + 24);
      if (!v8) {
        deparseTargetList_cold_1();
      }
      if (*(_DWORD *)v8 == 347)
      {
        uint64_t v9 = **(void **)(*(void *)(v8 + 8) + 16);
        if (*(_DWORD *)v9 == 223)
        {
          uint64_t v10 = quote_identifier(*(unsigned char **)(v9 + 8));
          appendStringInfoString(v3, v10);
        }
        else if (*(_DWORD *)v9 == 351)
        {
          appendStringInfoChar(v3, 42);
        }
        uint64_t result = deparseOptIndirection(v3, *(void *)(v8 + 8), 1);
        if (!*(void *)(v7 + 8)) {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t result = deparseExpr(v3, *(void *)(v7 + 24));
        if (!*(void *)(v7 + 8)) {
          goto LABEL_15;
        }
      }
      appendStringInfoString(v3, " AS ");
      uint64_t v11 = quote_identifier(*(unsigned char **)(v7 + 8));
      uint64_t result = (uint64_t)appendStringInfoString(v3, v11);
LABEL_15:
      if (v6 + v5)
      {
        if (v6 + v5 < (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4))) {
          uint64_t result = (uint64_t)appendStringInfoString(v3, ", ");
        }
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }
  return result;
}

uint64_t deparseAccessPriv(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)(a2 + 8);
  if (v4)
  {
    if (!strcmp(v4, "select"))
    {
      uint64_t v5 = "select";
    }
    else if (!strcmp(v4, "references"))
    {
      uint64_t v5 = "references";
    }
    else if (!strcmp(v4, "create"))
    {
      uint64_t v5 = "create";
    }
    else
    {
      uint64_t v5 = quote_identifier(v4);
    }
  }
  else
  {
    uint64_t v5 = "ALL";
  }
  appendStringInfoString(a1, v5);
  uint64_t result = appendStringInfoChar(a1, 32);
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    appendStringInfoChar(a1, 40);
    uint64_t v8 = *(void *)(a2 + 16);
    if (v8 && *(int *)(v8 + 4) >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8;
      do
      {
        uint64_t v11 = *(void *)(v8 + 16);
        uint64_t v12 = quote_identifier(*(unsigned char **)(*(void *)(v11 + 8 * v9) + 8));
        appendStringInfoString(a1, v12);
        uint64_t v13 = *(int *)(v8 + 4);
        if (v11 + v10) {
          BOOL v14 = v11 + v10 >= (unint64_t)(*(void *)(v8 + 16) + 8 * v13);
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14)
        {
          appendStringInfoString(a1, ", ");
          uint64_t v13 = *(int *)(v8 + 4);
        }
        ++v9;
        v10 += 8;
      }
      while (v9 < v13);
    }
    uint64_t result = appendStringInfoChar(a1, 41);
  }
  int v15 = *(_DWORD *)(a1 + 8);
  BOOL v16 = __OFSUB__(v15, 1);
  uint64_t v17 = (v15 - 1);
  if ((int)v17 < 0 == v16)
  {
    uint64_t v18 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v17) == 32)
    {
      *(_DWORD *)(a1 + 8) = v17;
      *(unsigned char *)(v18 + v17) = 0;
    }
  }
  return result;
}

uint64_t deparseSetClauseList(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    int v4 = 0;
    for (uint64_t i = 0; i < *(int *)(a2 + 4); ++i)
    {
      if (v4 >= 1)
      {
        --v4;
      }
      else
      {
        uint64_t v6 = *(void *)(a2 + 16);
        if (i) {
          appendStringInfoString(v3, ", ");
        }
        uint64_t v7 = (uint64_t *)(v6 + 8 * i);
        uint64_t v8 = *v7;
        uint64_t v9 = *(void *)(*v7 + 24);
        if (*(_DWORD *)v9 == 356)
        {
          appendStringInfoString(v3, "(");
          unint64_t v10 = ((unint64_t)v7 - *(void *)(a2 + 16)) >> 3;
          if (*(_DWORD *)(a2 + 4) > (int)v10)
          {
            while (1)
            {
              uint64_t v11 = *(void *)(a2 + 16) + 8 * (int)v10;
              uint64_t v12 = *(void *)v11;
              uint64_t v13 = quote_identifier(*(unsigned char **)(*(void *)v11 + 8));
              appendStringInfoString(v3, v13);
              uint64_t v14 = *(void *)(v12 + 16);
              if (v14)
              {
                if (*(int *)(v14 + 4) >= 1) {
                  break;
                }
              }
LABEL_30:
              if (*(_DWORD *)(v9 + 20) - 1 != v10)
              {
                uint64_t v23 = *(int *)(a2 + 4);
                if (v11 != -8 && v11 + 8 < (unint64_t)(*(void *)(a2 + 16) + 8 * v23))
                {
                  appendStringInfoString(v3, ", ");
                  LODWORD(v23) = *(_DWORD *)(a2 + 4);
                }
                LODWORD(v10) = v10 + 1;
                if ((int)v23 > (int)v10) {
                  continue;
                }
              }
              goto LABEL_11;
            }
            int v15 = 0;
            while (2)
            {
              uint64_t v18 = *(void *)(v14 + 16);
              uint64_t v19 = *(int **)(v18 + 8 * v15);
              int v20 = *v19;
              if (*v19 == 352)
              {
                appendStringInfoChar(v3, 91);
                uint64_t v21 = *((void *)v19 + 1);
                if (v21) {
                  deparseExpr(v3, v21);
                }
                if (*((unsigned char *)v19 + 4)) {
                  appendStringInfoChar(v3, 58);
                }
                uint64_t v22 = *((void *)v19 + 2);
                if (v22) {
                  deparseExpr(v3, v22);
                }
                appendStringInfoChar(v3, 93);
              }
              else
              {
                if (v20 == 351)
                {
                  uint64_t v16 = v3;
                  uint64_t v17 = ".*";
                  goto LABEL_17;
                }
                if (v20 == 223)
                {
                  appendStringInfoChar(v3, 46);
                  uint64_t v17 = quote_identifier(*(unsigned char **)(*(void *)(v18 + 8 * v15) + 8));
                  uint64_t v16 = v3;
LABEL_17:
                  appendStringInfoString(v16, v17);
                }
              }
              if (*(_DWORD *)(v14 + 4) <= ++v15) {
                goto LABEL_30;
              }
              continue;
            }
          }
LABEL_11:
          appendStringInfoString(v3, ") = ");
          uint64_t result = deparseExpr(v3, *(void *)(v9 + 8));
          int v4 = *(_DWORD *)(v9 + 20) - 1;
        }
        else
        {
          uint64_t v25 = quote_identifier(*(unsigned char **)(v8 + 8));
          appendStringInfoString(v3, v25);
          deparseOptIndirection(v3, *(void *)(v8 + 16), 0);
          appendStringInfoString(v3, " = ");
          uint64_t result = deparseExpr(v3, *(void *)(v8 + 24));
        }
      }
    }
  }
  return result;
}

_DWORD *deparseRuleActionStmt(_DWORD *result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  switch(*(_DWORD *)a2)
  {
    case 0xE9:
      uint64_t result = (_DWORD *)deparseInsertStmt(result, a2);
      break;
    case 0xEA:
      uint64_t result = (_DWORD *)deparseDeleteStmt(result, (uint64_t *)a2);
      break;
    case 0xEB:
      uint64_t result = (_DWORD *)deparseUpdateStmt(result, (uint64_t *)a2);
      break;
    case 0xEC:
      uint64_t result = (_DWORD *)deparseSelectStmt(result, a2);
      break;
    case 0x103:
      appendStringInfoString((uint64_t)result, "NOTIFY ");
      int v4 = quote_identifier(*(unsigned char **)(a2 + 8));
      uint64_t result = appendStringInfoString(v3, v4);
      if (*(void *)(a2 + 16))
      {
        appendStringInfoString(v3, ", ");
        uint64_t v5 = *(char **)(a2 + 16);
        uint64_t result = (_DWORD *)deparseStringLiteral(v3, v5);
      }
      break;
    default:
      return result;
  }
  return result;
}

void *deparseGroupingSet(void *result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  switch(*(_DWORD *)(a2 + 4))
  {
    case 0:
      return appendStringInfoString((uint64_t)result, "()");
    case 2:
      appendStringInfoString((uint64_t)result, "ROLLUP (");
      uint64_t v4 = *(void *)(a2 + 8);
      if (v4 && *(int *)(v4 + 4) >= 1)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 8;
        do
        {
          uint64_t v7 = *(void *)(v4 + 16);
          deparseExpr(v3, *(void *)(v7 + 8 * v5));
          uint64_t v8 = *(int *)(v4 + 4);
          if (v7 + v6) {
            BOOL v9 = v7 + v6 >= (unint64_t)(*(void *)(v4 + 16) + 8 * v8);
          }
          else {
            BOOL v9 = 1;
          }
          if (!v9)
          {
            appendStringInfoString(v3, ", ");
            uint64_t v8 = *(int *)(v4 + 4);
          }
          ++v5;
          v6 += 8;
        }
        while (v5 < v8);
      }
      goto LABEL_35;
    case 3:
      appendStringInfoString((uint64_t)result, "CUBE (");
      uint64_t v10 = *(void *)(a2 + 8);
      if (v10 && *(int *)(v10 + 4) >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 8;
        do
        {
          uint64_t v13 = *(void *)(v10 + 16);
          deparseExpr(v3, *(void *)(v13 + 8 * v11));
          uint64_t v14 = *(int *)(v10 + 4);
          if (v13 + v12) {
            BOOL v15 = v13 + v12 >= (unint64_t)(*(void *)(v10 + 16) + 8 * v14);
          }
          else {
            BOOL v15 = 1;
          }
          if (!v15)
          {
            appendStringInfoString(v3, ", ");
            uint64_t v14 = *(int *)(v10 + 4);
          }
          ++v11;
          v12 += 8;
        }
        while (v11 < v14);
      }
      goto LABEL_35;
    case 4:
      appendStringInfoString((uint64_t)result, "GROUPING SETS (");
      uint64_t v16 = *(void *)(a2 + 8);
      if (v16 && *(int *)(v16 + 4) >= 1)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 8;
        do
        {
          uint64_t v19 = *(void *)(v16 + 16);
          int v20 = *(_DWORD **)(v19 + 8 * v17);
          if (*v20 == 376) {
            deparseGroupingSet(v3);
          }
          else {
            deparseExpr(v3, v20);
          }
          uint64_t v21 = *(int *)(v16 + 4);
          if (v19 + v18) {
            BOOL v22 = v19 + v18 >= (unint64_t)(*(void *)(v16 + 16) + 8 * v21);
          }
          else {
            BOOL v22 = 1;
          }
          if (!v22)
          {
            appendStringInfoString(v3, ", ");
            uint64_t v21 = *(int *)(v16 + 4);
          }
          ++v17;
          v18 += 8;
        }
        while (v17 < v21);
      }
LABEL_35:
      uint64_t result = (void *)appendStringInfoChar(v3, 41);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t deparseTransactionModeList(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 4) >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 16);
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      uint64_t v8 = *(const char **)(v7 + 16);
      if (!strcmp(v8, "transaction_isolation"))
      {
        uint64_t v11 = *(const char **)(*(void *)(v7 + 24) + 16);
        appendStringInfoString(v3, "ISOLATION LEVEL ");
        if (!strcmp(v11, "read uncommitted"))
        {
          uint64_t v10 = "READ UNCOMMITTED";
          goto LABEL_24;
        }
        if (!strcmp(v11, "read committed"))
        {
          uint64_t v10 = "READ COMMITTED";
          goto LABEL_24;
        }
        if (!strcmp(v11, "repeatable read"))
        {
          uint64_t v10 = "REPEATABLE READ";
          goto LABEL_24;
        }
        uint64_t result = strcmp(v11, "serializable");
        if (!result)
        {
          uint64_t v10 = "SERIALIZABLE";
          goto LABEL_24;
        }
      }
      else
      {
        if (!strcmp(v8, "transaction_read_only"))
        {
          int v12 = *(_DWORD *)(*(void *)(v7 + 24) + 16);
          if (v12 == 1)
          {
            uint64_t v10 = "READ ONLY";
            goto LABEL_24;
          }
          if (!v12)
          {
            uint64_t v10 = "READ WRITE";
            goto LABEL_24;
          }
        }
        uint64_t result = strcmp(v8, "transaction_deferrable");
        if (!result)
        {
          int v9 = *(_DWORD *)(*(void *)(v7 + 24) + 16);
          if (v9 == 1)
          {
            uint64_t v10 = "DEFERRABLE";
            goto LABEL_24;
          }
          if (!v9)
          {
            uint64_t v10 = "NOT DEFERRABLE";
LABEL_24:
            uint64_t result = (uint64_t)appendStringInfoString(v3, v10);
          }
        }
      }
      if (v6 + v5)
      {
        if (v6 + v5 < (unint64_t)(*(void *)(a2 + 16) + 8 * *(int *)(a2 + 4))) {
          uint64_t result = (uint64_t)appendStringInfoString(v3, ", ");
        }
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < *(int *)(a2 + 4));
  }
  return result;
}

void pg_query_deparse_protobuf_cold_1()
{
}

void pg_query_deparse_protobuf_cold_2()
{
  OUTLINED_FUNCTION_0_17();
  errmsg_internal("deparse: unsupported top-level node type: %u", *v0);
  errfinish("src/pg_query_deparse.c", 9904, (uint64_t)"deparseStmt");
  __break(1u);
}

void deparseSelectStmt_cold_1()
{
  OUTLINED_FUNCTION_0_17();
  errmsg_internal("deparse: unpermitted node type in c_expr: %d", *v0);
  errfinish("src/pg_query_deparse.c", 375, (uint64_t)"deparseCExpr");
  __break(1u);
}

void deparseExpr_cold_1()
{
  OUTLINED_FUNCTION_0_17();
  errmsg_internal("deparse: unpermitted node type in a_expr/b_expr: %d", *v0);
  errfinish("src/pg_query_deparse.c", 325, (uint64_t)"deparseExpr");
  __break(1u);
}

void deparseValue_cold_1()
{
  OUTLINED_FUNCTION_0_17();
  errmsg_internal("deparse: unrecognized value node type: %d", *v0);
  errfinish("src/pg_query_deparse.c", 9432, (uint64_t)"deparseValue");
  __break(1u);
}

void deparseTargetList_cold_1()
{
}

uint64_t pg_query_nodes_to_json(uint64_t a1)
{
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  initStringInfo((uint64_t)&v42);
  if (a1)
  {
    appendStringInfoString((uint64_t)&v42, "{");
    appendStringInfo((uint64_t)&v42, "\"version\":%d,", v8, v9, v10, v11, v12, v13, 0x1FBD3uLL);
    appendStringInfoString((uint64_t)&v42, "\"stmts\":");
    appendStringInfoChar((uint64_t)&v42, 91);
    if (*(int *)(a1 + 4) >= 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 8;
      do
      {
        uint64_t v16 = *(void *)(a1 + 16);
        appendStringInfoChar((uint64_t)&v42, 123);
        uint64_t v23 = *(void *)(v16 + 8 * v14);
        if (*(void *)(v23 + 8))
        {
          appendStringInfo((uint64_t)&v42, "\"stmt\":", v17, v18, v19, v20, v21, v22, v39);
          _outNode((int *)&v42, *(unsigned int **)(v23 + 8), v24, v25, v26, v27, v28, v29, v40);
          appendStringInfo((uint64_t)&v42, ",", v30, v31, v32, v33, v34, v35, v41);
        }
        if (*(_DWORD *)(v23 + 16)) {
          appendStringInfo((uint64_t)&v42, "\"stmt_location\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(v23 + 16));
        }
        if (*(_DWORD *)(v23 + 20)) {
          appendStringInfo((uint64_t)&v42, "\"stmt_len\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(v23 + 20));
        }
        uint64_t v36 = (v43 - 1);
        if ((int)v43 >= 1 && *(unsigned char *)(v42 + v36) == 44)
        {
          LODWORD(v43) = v43 - 1;
          *(unsigned char *)(v42 + v36) = 0;
        }
        appendStringInfoChar((uint64_t)&v42, 125);
        uint64_t v37 = *(int *)(a1 + 4);
        if (v16 + v15 && v16 + v15 < (unint64_t)(*(void *)(a1 + 16) + 8 * v37))
        {
          appendStringInfoString((uint64_t)&v42, ",");
          uint64_t v37 = *(int *)(a1 + 4);
        }
        ++v14;
        v15 += 8;
      }
      while (v14 < v37);
    }
    appendStringInfoChar((uint64_t)&v42, 93);
    appendStringInfoString((uint64_t)&v42, "}");
  }
  else
  {
    appendStringInfo((uint64_t)&v42, "{\"version\":%d,\"stmts\":[]}", v2, v3, v4, v5, v6, v7, 0x1FBD3uLL);
  }
  return v42;
}

uint64_t _outRawStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"stmt\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(void *)(a2 + 8));
    uint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16)) {
    uint64_t result = appendStringInfo(v9, "\"stmt_location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"stmt_len\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

void *_outNode(int *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (a2)
  {
    appendStringInfoChar((uint64_t)a1, 123);
    switch(*a2)
    {
      case 0x66u:
        appendStringInfoString((uint64_t)a1, "\"Alias\":{");
        _outAlias((uint64_t)a1, (uint64_t)a2, v11, v12, v13, v14, v15, v16, v1357);
        goto LABEL_243;
      case 0x67u:
        appendStringInfoString((uint64_t)a1, "\"RangeVar\":{");
        _outRangeVar((uint64_t)a1, (uint64_t)a2, v24, v25, v26, v27, v28, v29);
        goto LABEL_243;
      case 0x68u:
        appendStringInfoString((uint64_t)a1, "\"TableFunc\":{");
        _outTableFunc((uint64_t)a1, (uint64_t)a2, v30, v31, v32, v33, v34, v35);
        goto LABEL_243;
      case 0x69u:
        uint64_t v36 = "\"Expr\":{";
        goto LABEL_193;
      case 0x6Au:
        appendStringInfoString((uint64_t)a1, "\"Var\":{");
        _outVar((uint64_t)a1, (uint64_t)a2, v37, v38, v39, v40, v41, v42);
        goto LABEL_243;
      case 0x6Cu:
        appendStringInfoString((uint64_t)a1, "\"Param\":{");
        _outParam((uint64_t)a1, (uint64_t)a2, v45, v46, v47, v48, v49, v50);
        goto LABEL_243;
      case 0x6Du:
        appendStringInfoString((uint64_t)a1, "\"Aggref\":{");
        _outAggref((uint64_t)a1, (uint64_t)a2, v51, v52, v53, v54, v55, v56);
        goto LABEL_243;
      case 0x6Eu:
        appendStringInfoString((uint64_t)a1, "\"GroupingFunc\":{");
        _outGroupingFunc((uint64_t)a1, (uint64_t)a2, v57, v58, v59, v60, v61, v62);
        goto LABEL_243;
      case 0x6Fu:
        appendStringInfoString((uint64_t)a1, "\"WindowFunc\":{");
        _outWindowFunc((uint64_t)a1, (uint64_t)a2, v63, v64, v65, v66, v67, v68);
        goto LABEL_243;
      case 0x70u:
        appendStringInfoString((uint64_t)a1, "\"SubscriptingRef\":{");
        _outSubscriptingRef((uint64_t)a1, (uint64_t)a2, v69, v70, v71, v72, v73, v74, v1357);
        goto LABEL_243;
      case 0x71u:
        appendStringInfoString((uint64_t)a1, "\"FuncExpr\":{");
        _outFuncExpr((uint64_t)a1, (uint64_t)a2, v75, v76, v77, v78, v79, v80);
        goto LABEL_243;
      case 0x72u:
        appendStringInfoString((uint64_t)a1, "\"NamedArgExpr\":{");
        _outNamedArgExpr((uint64_t)a1, (uint64_t)a2, v81, v82, v83, v84, v85, v86);
        goto LABEL_243;
      case 0x73u:
        appendStringInfoString((uint64_t)a1, "\"OpExpr\":{");
        _outOpExpr((uint64_t)a1, (uint64_t)a2, v87, v88, v89, v90, v91, v92);
        goto LABEL_243;
      case 0x74u:
        appendStringInfoString((uint64_t)a1, "\"DistinctExpr\":{");
        _outOpExpr((uint64_t)a1, (uint64_t)a2, v93, v94, v95, v96, v97, v98);
        goto LABEL_243;
      case 0x75u:
        appendStringInfoString((uint64_t)a1, "\"NullIfExpr\":{");
        _outOpExpr((uint64_t)a1, (uint64_t)a2, v99, v100, v101, v102, v103, v104);
        goto LABEL_243;
      case 0x76u:
        appendStringInfoString((uint64_t)a1, "\"ScalarArrayOpExpr\":{");
        _outScalarArrayOpExpr((uint64_t)a1, (uint64_t)a2, v105, v106, v107, v108, v109, v110);
        goto LABEL_243;
      case 0x77u:
        appendStringInfoString((uint64_t)a1, "\"BoolExpr\":{");
        _outBoolExpr((uint64_t)a1, (uint64_t)a2, v111, v112, v113, v114, v115, v116);
        goto LABEL_243;
      case 0x78u:
        appendStringInfoString((uint64_t)a1, "\"SubLink\":{");
        _outSubLink((uint64_t)a1, (uint64_t)a2, v117, v118, v119, v120, v121, v122);
        goto LABEL_243;
      case 0x79u:
        appendStringInfoString((uint64_t)a1, "\"SubPlan\":{");
        _outSubPlan(a1, (uint64_t)a2, v123, v124, v125, v126, v127, v128);
        goto LABEL_243;
      case 0x7Au:
        appendStringInfoString((uint64_t)a1, "\"AlternativeSubPlan\":{");
        _outAlternativeSubPlan((unint64_t)a1, (uint64_t)a2, v129, v130, v131, v132, v133, v134, v1357);
        goto LABEL_243;
      case 0x7Bu:
        appendStringInfoString((uint64_t)a1, "\"FieldSelect\":{");
        _outFieldSelect((uint64_t)a1, (uint64_t)a2, v135, v136, v137, v138, v139, v140);
        goto LABEL_243;
      case 0x7Cu:
        appendStringInfoString((uint64_t)a1, "\"FieldStore\":{");
        _outFieldStore((uint64_t)a1, (uint64_t)a2, v141, v142, v143, v144, v145, v146);
        goto LABEL_243;
      case 0x7Du:
        appendStringInfoString((uint64_t)a1, "\"RelabelType\":{");
        _outRelabelType((uint64_t)a1, (uint64_t)a2, v147, v148, v149, v150, v151, v152);
        goto LABEL_243;
      case 0x7Eu:
        appendStringInfoString((uint64_t)a1, "\"CoerceViaIO\":{");
        _outCoerceViaIO((uint64_t)a1, (uint64_t)a2, v153, v154, v155, v156, v157, v158);
        goto LABEL_243;
      case 0x7Fu:
        appendStringInfoString((uint64_t)a1, "\"ArrayCoerceExpr\":{");
        _outArrayCoerceExpr((uint64_t)a1, (uint64_t)a2, v159, v160, v161, v162, v163, v164);
        goto LABEL_243;
      case 0x80u:
        appendStringInfoString((uint64_t)a1, "\"ConvertRowtypeExpr\":{");
        _outConvertRowtypeExpr((uint64_t)a1, (uint64_t)a2, v165, v166, v167, v168, v169, v170);
        goto LABEL_243;
      case 0x81u:
        appendStringInfoString((uint64_t)a1, "\"CollateExpr\":{");
        _outCollateExpr((uint64_t)a1, (uint64_t)a2, v171, v172, v173, v174, v175, v176);
        goto LABEL_243;
      case 0x82u:
        appendStringInfoString((uint64_t)a1, "\"CaseExpr\":{");
        _outCaseExpr((uint64_t)a1, (uint64_t)a2, v177, v178, v179, v180, v181, v182);
        goto LABEL_243;
      case 0x83u:
        appendStringInfoString((uint64_t)a1, "\"CaseWhen\":{");
        _outCaseWhen((uint64_t)a1, (uint64_t)a2, v183, v184, v185, v186, v187, v188);
        goto LABEL_243;
      case 0x84u:
        appendStringInfoString((uint64_t)a1, "\"CaseTestExpr\":{");
        _outCaseTestExpr((uint64_t)a1, a2, v189, v190, v191, v192, v193, v194);
        goto LABEL_243;
      case 0x85u:
        appendStringInfoString((uint64_t)a1, "\"ArrayExpr\":{");
        _outArrayExpr((uint64_t)a1, (uint64_t)a2, v195, v196, v197, v198, v199, v200);
        goto LABEL_243;
      case 0x86u:
        appendStringInfoString((uint64_t)a1, "\"RowExpr\":{");
        _outRowExpr((uint64_t)a1, (uint64_t)a2, v201, v202, v203, v204, v205, v206);
        goto LABEL_243;
      case 0x87u:
        appendStringInfoString((uint64_t)a1, "\"RowCompareExpr\":{");
        _outRowCompareExpr((uint64_t)a1, (uint64_t)a2, v207, v208, v209, v210, v211, v212, v1357);
        goto LABEL_243;
      case 0x88u:
        appendStringInfoString((uint64_t)a1, "\"CoalesceExpr\":{");
        _outCoalesceExpr((uint64_t)a1, (uint64_t)a2, v213, v214, v215, v216, v217, v218);
        goto LABEL_243;
      case 0x89u:
        appendStringInfoString((uint64_t)a1, "\"MinMaxExpr\":{");
        _outMinMaxExpr((uint64_t)a1, (uint64_t)a2, v219, v220, v221, v222, v223, v224);
        goto LABEL_243;
      case 0x8Au:
        appendStringInfoString((uint64_t)a1, "\"SQLValueFunction\":{");
        _outSQLValueFunction((uint64_t)a1, (uint64_t)a2, v225, v226, v227, v228, v229, v230);
        goto LABEL_243;
      case 0x8Bu:
        appendStringInfoString((uint64_t)a1, "\"XmlExpr\":{");
        _outXmlExpr(a1, (uint64_t)a2, v231, v232, v233, v234, v235, v236);
        goto LABEL_243;
      case 0x8Cu:
        appendStringInfoString((uint64_t)a1, "\"NullTest\":{");
        _outNullTest((uint64_t)a1, (uint64_t)a2, v237, v238, v239, v240, v241, v242);
        goto LABEL_243;
      case 0x8Du:
        appendStringInfoString((uint64_t)a1, "\"BooleanTest\":{");
        _outBooleanTest((uint64_t)a1, (uint64_t)a2, v243, v244, v245, v246, v247, v248);
        goto LABEL_243;
      case 0x8Eu:
        appendStringInfoString((uint64_t)a1, "\"CoerceToDomain\":{");
        _outCoerceToDomain((uint64_t)a1, (uint64_t)a2, v249, v250, v251, v252, v253, v254);
        goto LABEL_243;
      case 0x8Fu:
        appendStringInfoString((uint64_t)a1, "\"CoerceToDomainValue\":{");
        _outCoerceToDomainValue((uint64_t)a1, a2, v255, v256, v257, v258, v259, v260);
        goto LABEL_243;
      case 0x90u:
        appendStringInfoString((uint64_t)a1, "\"SetToDefault\":{");
        _outCoerceToDomainValue((uint64_t)a1, a2, v261, v262, v263, v264, v265, v266);
        goto LABEL_243;
      case 0x91u:
        appendStringInfoString((uint64_t)a1, "\"CurrentOfExpr\":{");
        _outCurrentOfExpr((uint64_t)a1, (uint64_t)a2, v267, v268, v269, v270, v271, v272);
        goto LABEL_243;
      case 0x92u:
        appendStringInfoString((uint64_t)a1, "\"NextValueExpr\":{");
        _outNextValueExpr((uint64_t)a1, (uint64_t)a2, v273, v274, v275, v276, v277, v278);
        goto LABEL_243;
      case 0x93u:
        appendStringInfoString((uint64_t)a1, "\"InferenceElem\":{");
        _outInferenceElem((uint64_t)a1, (uint64_t)a2, v279, v280, v281, v282, v283, v284);
        goto LABEL_243;
      case 0x94u:
        appendStringInfoString((uint64_t)a1, "\"TargetEntry\":{");
        _outTargetEntry((uint64_t)a1, (uint64_t)a2, v285, v286, v287, v288, v289, v290);
        goto LABEL_243;
      case 0x95u:
        appendStringInfoString((uint64_t)a1, "\"RangeTblRef\":{");
        if (a2[1]) {
          appendStringInfo((uint64_t)a1, "\"rtindex\":%d,", v17, v18, v19, v20, v21, v22, a2[1]);
        }
        goto LABEL_243;
      case 0x96u:
        appendStringInfoString((uint64_t)a1, "\"JoinExpr\":{");
        _outJoinExpr((uint64_t)a1, (uint64_t)a2, v291, v292, v293, v294, v295, v296);
        goto LABEL_243;
      case 0x97u:
        appendStringInfoString((uint64_t)a1, "\"FromExpr\":{");
        _outFromExpr((uint64_t)a1, (uint64_t)a2, v297, v298, v299, v300, v301, v302, v1357);
        goto LABEL_243;
      case 0x98u:
        appendStringInfoString((uint64_t)a1, "\"OnConflictExpr\":{");
        _outOnConflictExpr((uint64_t)a1, (uint64_t)a2, v303, v304, v305, v306, v307, v308, v1357);
        goto LABEL_243;
      case 0x99u:
        appendStringInfoString((uint64_t)a1, "\"IntoClause\":{");
        _outIntoClause(a1, (uint64_t)a2, v309, v310, v311, v312, v313, v314);
        goto LABEL_243;
      case 0xDDu:
        appendStringInfoString((uint64_t)a1, "\"Integer\":{");
        appendStringInfo((uint64_t)a1, "\"ival\":%d,", v315, v316, v317, v318, v319, v320, a2[2]);
        goto LABEL_243;
      case 0xDEu:
        appendStringInfoString((uint64_t)a1, "\"Float\":{");
        _outFloat(a1, (uint64_t)a2, v321, v322, v323, v324, v325, v326, v1357);
        goto LABEL_243;
      case 0xDFu:
        appendStringInfoString((uint64_t)a1, "\"String\":{");
        _outFloat(a1, (uint64_t)a2, v327, v328, v329, v330, v331, v332, v1357);
        goto LABEL_243;
      case 0xE0u:
        appendStringInfoString((uint64_t)a1, "\"BitString\":{");
        _outFloat(a1, (uint64_t)a2, v333, v334, v335, v336, v337, v338, v1357);
        goto LABEL_243;
      case 0xE1u:
        uint64_t v36 = "\"Null\":{";
        goto LABEL_193;
      case 0xE2u:
        appendStringInfoString((uint64_t)a1, "\"List\":{");
        _outList((uint64_t)a1, (uint64_t)a2, v339, v340, v341, v342, v343, v344, v1357);
        goto LABEL_243;
      case 0xE3u:
        appendStringInfoString((uint64_t)a1, "\"IntList\":{");
        _outIntList((uint64_t)a1, (uint64_t)a2, v345, v346, v347, v348, v349, v350, v1357);
        goto LABEL_243;
      case 0xE4u:
        appendStringInfoString((uint64_t)a1, "\"OidList\":{");
        _outOidList((uint64_t)a1, (uint64_t)a2, v351, v352, v353, v354, v355, v356, v1357);
        goto LABEL_243;
      case 0xE6u:
        appendStringInfoString((uint64_t)a1, "\"RawStmt\":{");
        _outRawStmt((uint64_t)a1, (uint64_t)a2, v357, v358, v359, v360, v361, v362);
        goto LABEL_243;
      case 0xE7u:
        appendStringInfoString((uint64_t)a1, "\"Query\":{");
        _outQuery((uint64_t)a1, (uint64_t)a2, v363, v364, v365, v366, v367, v368);
        goto LABEL_243;
      case 0xE9u:
        appendStringInfoString((uint64_t)a1, "\"InsertStmt\":{");
        _outInsertStmt((uint64_t)a1, (uint64_t)a2, v369, v370, v371, v372, v373, v374);
        goto LABEL_243;
      case 0xEAu:
        appendStringInfoString((uint64_t)a1, "\"DeleteStmt\":{");
        _outDeleteStmt((uint64_t)a1, (uint64_t *)a2, v375, v376, v377, v378, v379, v380, v1357);
        goto LABEL_243;
      case 0xEBu:
        appendStringInfoString((uint64_t)a1, "\"UpdateStmt\":{");
        _outUpdateStmt((uint64_t)a1, (uint64_t *)a2, v381, v382, v383, v384, v385, v386, v1357);
        goto LABEL_243;
      case 0xECu:
        appendStringInfoString((uint64_t)a1, "\"SelectStmt\":{");
        _outSelectStmt(a1, (uint64_t)a2, v387, v388, v389, v390, v391, v392, v1357);
        goto LABEL_243;
      case 0xEDu:
        appendStringInfoString((uint64_t)a1, "\"AlterTableStmt\":{");
        _outAlterTableStmt((uint64_t)a1, (uint64_t)a2, v393, v394, v395, v396, v397, v398);
        goto LABEL_243;
      case 0xEEu:
        appendStringInfoString((uint64_t)a1, "\"AlterTableCmd\":{");
        _outAlterTableCmd(a1, (uint64_t)a2, v399, v400, v401, v402, v403, v404);
        goto LABEL_243;
      case 0xEFu:
        appendStringInfoString((uint64_t)a1, "\"AlterDomainStmt\":{");
        _outAlterDomainStmt(a1, (uint64_t)a2, v405, v406, v407, v408, v409, v410);
        goto LABEL_243;
      case 0xF0u:
        appendStringInfoString((uint64_t)a1, "\"SetOperationStmt\":{");
        _outSetOperationStmt((uint64_t)a1, (uint64_t)a2, v411, v412, v413, v414, v415, v416, v1357);
        goto LABEL_243;
      case 0xF1u:
        appendStringInfoString((uint64_t)a1, "\"GrantStmt\":{");
        _outGrantStmt((uint64_t)a1, (uint64_t)a2, v417, v418, v419, v420, v421, v422);
        goto LABEL_243;
      case 0xF2u:
        appendStringInfoString((uint64_t)a1, "\"GrantRoleStmt\":{");
        _outGrantRoleStmt(a1, (uint64_t)a2, v423, v424, v425, v426, v427, v428);
        goto LABEL_243;
      case 0xF3u:
        appendStringInfoString((uint64_t)a1, "\"AlterDefaultPrivilegesStmt\":{");
        _outAlterDefaultPrivilegesStmt((uint64_t)a1, (uint64_t)a2, v429, v430, v431, v432, v433, v434, v1357);
        goto LABEL_243;
      case 0xF4u:
        appendStringInfoString((uint64_t)a1, "\"ClosePortalStmt\":{");
        _outClosePortalStmt((unint64_t)a1, (uint64_t)a2, v435, v436, v437, v438, v439, v440, v1357);
        goto LABEL_243;
      case 0xF5u:
        appendStringInfoString((uint64_t)a1, "\"ClusterStmt\":{");
        _outClusterStmt((uint64_t)a1, (uint64_t)a2, v441, v442, v443, v444, v445, v446);
        goto LABEL_243;
      case 0xF6u:
        appendStringInfoString((uint64_t)a1, "\"CopyStmt\":{");
        _outCopyStmt((uint64_t)a1, (uint64_t)a2, v447, v448, v449, v450, v451, v452, v1357);
        goto LABEL_243;
      case 0xF7u:
        appendStringInfoString((uint64_t)a1, "\"CreateStmt\":{");
        _outCreateStmt(a1, (uint64_t)a2, v453, v454, v455, v456, v457, v458);
        goto LABEL_243;
      case 0xF8u:
        appendStringInfoString((uint64_t)a1, "\"DefineStmt\":{");
        _outDefineStmt((uint64_t)a1, (uint64_t)a2, v459, v460, v461, v462, v463, v464);
        goto LABEL_243;
      case 0xF9u:
        appendStringInfoString((uint64_t)a1, "\"DropStmt\":{");
        _outDropStmt((uint64_t)a1, (uint64_t)a2, v465, v466, v467, v468, v469, v470);
        goto LABEL_243;
      case 0xFAu:
        appendStringInfoString((uint64_t)a1, "\"TruncateStmt\":{");
        _outTruncateStmt((uint64_t)a1, (uint64_t)a2, v471, v472, v473, v474, v475, v476);
        goto LABEL_243;
      case 0xFBu:
        appendStringInfoString((uint64_t)a1, "\"CommentStmt\":{");
        _outCommentStmt(a1, (uint64_t)a2, v477, v478, v479, v480, v481, v482, v1357);
        goto LABEL_243;
      case 0xFCu:
        appendStringInfoString((uint64_t)a1, "\"FetchStmt\":{");
        _outFetchStmt(a1, (uint64_t)a2, v483, v484, v485, v486, v487, v488);
        goto LABEL_243;
      case 0xFDu:
        appendStringInfoString((uint64_t)a1, "\"IndexStmt\":{");
        _outIndexStmt((uint64_t)a1, (uint64_t)a2, v489, v490, v491, v492, v493, v494);
        goto LABEL_243;
      case 0xFEu:
        appendStringInfoString((uint64_t)a1, "\"CreateFunctionStmt\":{");
        _outCreateFunctionStmt((uint64_t)a1, (uint64_t)a2, v495, v496, v497, v498, v499, v500, v1357);
        goto LABEL_243;
      case 0xFFu:
        appendStringInfoString((uint64_t)a1, "\"AlterFunctionStmt\":{");
        _outAlterFunctionStmt((uint64_t)a1, (uint64_t)a2, v501, v502, v503, v504, v505, v506, v1357);
        goto LABEL_243;
      case 0x100u:
        appendStringInfoString((uint64_t)a1, "\"DoStmt\":{");
        _outDoStmt((unint64_t)a1, (uint64_t)a2, v507, v508, v509, v510, v511, v512, v1357);
        goto LABEL_243;
      case 0x101u:
        appendStringInfoString((uint64_t)a1, "\"RenameStmt\":{");
        _outRenameStmt(a1, (uint64_t)a2, v513, v514, v515, v516, v517, v518);
        goto LABEL_243;
      case 0x102u:
        appendStringInfoString((uint64_t)a1, "\"RuleStmt\":{");
        _outRuleStmt(a1, (uint64_t)a2, v519, v520, v521, v522, v523, v524);
        goto LABEL_243;
      case 0x103u:
        appendStringInfoString((uint64_t)a1, "\"NotifyStmt\":{");
        _outNotifyStmt((uint64_t)a1, (uint64_t)a2, v525, v526, v527, v528, v529, v530, v1357);
        goto LABEL_243;
      case 0x104u:
        appendStringInfoString((uint64_t)a1, "\"ListenStmt\":{");
        _outListenStmt((unint64_t)a1, (uint64_t)a2, v531, v532, v533, v534, v535, v536, v1357);
        goto LABEL_243;
      case 0x105u:
        appendStringInfoString((uint64_t)a1, "\"UnlistenStmt\":{");
        _outListenStmt((unint64_t)a1, (uint64_t)a2, v537, v538, v539, v540, v541, v542, v1357);
        goto LABEL_243;
      case 0x106u:
        appendStringInfoString((uint64_t)a1, "\"TransactionStmt\":{");
        _outTransactionStmt(a1, (uint64_t)a2, v543, v544, v545, v546, v547, v548);
        goto LABEL_243;
      case 0x107u:
        appendStringInfoString((uint64_t)a1, "\"ViewStmt\":{");
        _outViewStmt((uint64_t)a1, (uint64_t)a2, v549, v550, v551, v552, v553, v554);
        goto LABEL_243;
      case 0x108u:
        appendStringInfoString((uint64_t)a1, "\"LoadStmt\":{");
        _outLoadStmt((unint64_t)a1, (uint64_t)a2, v555, v556, v557, v558, v559, v560, v1357);
        goto LABEL_243;
      case 0x109u:
        appendStringInfoString((uint64_t)a1, "\"CreateDomainStmt\":{");
        _outCreateDomainStmt((uint64_t)a1, a2, v561, v562, v563, v564, v565, v566, v1357);
        goto LABEL_243;
      case 0x10Au:
        appendStringInfoString((uint64_t)a1, "\"CreatedbStmt\":{");
        _outCreatedbStmt((uint64_t)a1, (uint64_t)a2, v567, v568, v569, v570, v571, v572, v1357);
        goto LABEL_243;
      case 0x10Bu:
        appendStringInfoString((uint64_t)a1, "\"DropdbStmt\":{");
        _outDropdbStmt((uint64_t)a1, (uint64_t)a2, v573, v574, v575, v576, v577, v578, v1357);
        goto LABEL_243;
      case 0x10Cu:
        appendStringInfoString((uint64_t)a1, "\"VacuumStmt\":{");
        _outVacuumStmt((uint64_t)a1, (uint64_t)a2, v579, v580, v581, v582, v583, v584);
        goto LABEL_243;
      case 0x10Du:
        appendStringInfoString((uint64_t)a1, "\"ExplainStmt\":{");
        _outExplainStmt((uint64_t)a1, (uint64_t)a2, v585, v586, v587, v588, v589, v590, v1357);
        goto LABEL_243;
      case 0x10Eu:
        appendStringInfoString((uint64_t)a1, "\"CreateTableAsStmt\":{");
        _outCreateTableAsStmt(a1, (uint64_t)a2, v591, v592, v593, v594, v595, v596);
        goto LABEL_243;
      case 0x10Fu:
        appendStringInfoString((uint64_t)a1, "\"CreateSeqStmt\":{");
        _outCreateSeqStmt((uint64_t)a1, (uint64_t)a2, v597, v598, v599, v600, v601, v602);
        goto LABEL_243;
      case 0x110u:
        appendStringInfoString((uint64_t)a1, "\"AlterSeqStmt\":{");
        _outAlterSeqStmt((uint64_t)a1, (uint64_t)a2, v603, v604, v605, v606, v607, v608);
        goto LABEL_243;
      case 0x111u:
        appendStringInfoString((uint64_t)a1, "\"VariableSetStmt\":{");
        _outVariableSetStmt(a1, (uint64_t)a2, v609, v610, v611, v612, v613, v614);
        goto LABEL_243;
      case 0x112u:
        appendStringInfoString((uint64_t)a1, "\"VariableShowStmt\":{");
        _outVariableShowStmt((unint64_t)a1, (uint64_t)a2, v615, v616, v617, v618, v619, v620, v1357);
        goto LABEL_243;
      case 0x113u:
        appendStringInfoString((uint64_t)a1, "\"DiscardStmt\":{");
        _outDiscardStmt((uint64_t)a1, a2[1], v621, v622, v623, v624, v625, v626);
        goto LABEL_243;
      case 0x114u:
        appendStringInfoString((uint64_t)a1, "\"CreateTrigStmt\":{");
        _outCreateTrigStmt((uint64_t)a1, (uint64_t)a2, v627, v628, v629, v630, v631, v632, v1357);
        goto LABEL_243;
      case 0x115u:
        appendStringInfoString((uint64_t)a1, "\"CreatePLangStmt\":{");
        _outCreatePLangStmt((uint64_t)a1, (uint64_t)a2, v633, v634, v635, v636, v637, v638);
        goto LABEL_243;
      case 0x116u:
        appendStringInfoString((uint64_t)a1, "\"CreateRoleStmt\":{");
        _outCreateRoleStmt(a1, (uint64_t)a2, v639, v640, v641, v642, v643, v644, v1357);
        goto LABEL_243;
      case 0x117u:
        appendStringInfoString((uint64_t)a1, "\"AlterRoleStmt\":{");
        _outAlterRoleStmt((uint64_t)a1, (uint64_t)a2, v645, v646, v647, v648, v649, v650);
        goto LABEL_243;
      case 0x118u:
        appendStringInfoString((uint64_t)a1, "\"DropRoleStmt\":{");
        _outDropRoleStmt((uint64_t)a1, (uint64_t)a2, v651, v652, v653, v654, v655, v656);
        goto LABEL_243;
      case 0x119u:
        appendStringInfoString((uint64_t)a1, "\"LockStmt\":{");
        _outLockStmt((uint64_t)a1, (uint64_t)a2, v657, v658, v659, v660, v661, v662);
        goto LABEL_243;
      case 0x11Au:
        appendStringInfoString((uint64_t)a1, "\"ConstraintsSetStmt\":{");
        _outConstraintsSetStmt((uint64_t)a1, (uint64_t)a2, v663, v664, v665, v666, v667, v668);
        goto LABEL_243;
      case 0x11Bu:
        appendStringInfoString((uint64_t)a1, "\"ReindexStmt\":{");
        _outReindexStmt(a1, (uint64_t)a2, v669, v670, v671, v672, v673, v674);
        goto LABEL_243;
      case 0x11Cu:
        uint64_t v36 = "\"CheckPointStmt\":{";
        goto LABEL_193;
      case 0x11Du:
        appendStringInfoString((uint64_t)a1, "\"CreateSchemaStmt\":{");
        _outCreateSchemaStmt((uint64_t)a1, (uint64_t)a2, v675, v676, v677, v678, v679, v680);
        goto LABEL_243;
      case 0x11Eu:
        appendStringInfoString((uint64_t)a1, "\"AlterDatabaseStmt\":{");
        _outCreatedbStmt((uint64_t)a1, (uint64_t)a2, v681, v682, v683, v684, v685, v686, v1357);
        goto LABEL_243;
      case 0x11Fu:
        appendStringInfoString((uint64_t)a1, "\"AlterDatabaseSetStmt\":{");
        _outAlterDatabaseSetStmt((uint64_t)a1, (uint64_t)a2, v687, v688, v689, v690, v691, v692, v1357);
        goto LABEL_243;
      case 0x120u:
        appendStringInfoString((uint64_t)a1, "\"AlterRoleSetStmt\":{");
        _outAlterRoleSetStmt((uint64_t)a1, (uint64_t)a2, v693, v694, v695, v696, v697, v698, v1357);
        goto LABEL_243;
      case 0x121u:
        appendStringInfoString((uint64_t)a1, "\"CreateConversionStmt\":{");
        _outCreateConversionStmt((uint64_t)a1, (uint64_t)a2, v699, v700, v701, v702, v703, v704);
        goto LABEL_243;
      case 0x122u:
        appendStringInfoString((uint64_t)a1, "\"CreateCastStmt\":{");
        _outCreateCastStmt((uint64_t)a1, (uint64_t)a2, v705, v706, v707, v708, v709, v710);
        goto LABEL_243;
      case 0x123u:
        appendStringInfoString((uint64_t)a1, "\"CreateOpClassStmt\":{");
        _outCreateOpClassStmt((uint64_t)a1, (uint64_t)a2, v711, v712, v713, v714, v715, v716);
        goto LABEL_243;
      case 0x124u:
        appendStringInfoString((uint64_t)a1, "\"CreateOpFamilyStmt\":{");
        _outCreateOpFamilyStmt((uint64_t)a1, (uint64_t)a2, v717, v718, v719, v720, v721, v722, v1357);
        goto LABEL_243;
      case 0x125u:
        appendStringInfoString((uint64_t)a1, "\"AlterOpFamilyStmt\":{");
        _outAlterOpFamilyStmt((uint64_t)a1, (uint64_t)a2, v723, v724, v725, v726, v727, v728, v1357);
        goto LABEL_243;
      case 0x126u:
        appendStringInfoString((uint64_t)a1, "\"PrepareStmt\":{");
        _outPrepareStmt((uint64_t)a1, (uint64_t)a2, v729, v730, v731, v732, v733, v734, v1357);
        goto LABEL_243;
      case 0x127u:
        appendStringInfoString((uint64_t)a1, "\"ExecuteStmt\":{");
        _outExecuteStmt((uint64_t)a1, (uint64_t)a2, v735, v736, v737, v738, v739, v740, v1357);
        goto LABEL_243;
      case 0x128u:
        appendStringInfoString((uint64_t)a1, "\"DeallocateStmt\":{");
        _outVariableShowStmt((unint64_t)a1, (uint64_t)a2, v741, v742, v743, v744, v745, v746, v1357);
        goto LABEL_243;
      case 0x129u:
        appendStringInfoString((uint64_t)a1, "\"DeclareCursorStmt\":{");
        _outDeclareCursorStmt((uint64_t)a1, (uint64_t)a2, v747, v748, v749, v750, v751, v752, v1357);
        goto LABEL_243;
      case 0x12Au:
        appendStringInfoString((uint64_t)a1, "\"CreateTableSpaceStmt\":{");
        _outCreateTableSpaceStmt((uint64_t)a1, (uint64_t)a2, v753, v754, v755, v756, v757, v758, v1357);
        goto LABEL_243;
      case 0x12Bu:
        appendStringInfoString((uint64_t)a1, "\"DropTableSpaceStmt\":{");
        _outDropTableSpaceStmt((uint64_t)a1, (uint64_t)a2, v759, v760, v761, v762, v763, v764);
        goto LABEL_243;
      case 0x12Cu:
        appendStringInfoString((uint64_t)a1, "\"AlterObjectDependsStmt\":{");
        _outAlterObjectDependsStmt((uint64_t)a1, (uint64_t)a2, v765, v766, v767, v768, v769, v770);
        goto LABEL_243;
      case 0x12Du:
        appendStringInfoString((uint64_t)a1, "\"AlterObjectSchemaStmt\":{");
        _outAlterObjectSchemaStmt(a1, (uint64_t)a2, v771, v772, v773, v774, v775, v776);
        goto LABEL_243;
      case 0x12Eu:
        appendStringInfoString((uint64_t)a1, "\"AlterOwnerStmt\":{");
        _outAlterOwnerStmt(a1, (uint64_t)a2, v777, v778, v779, v780, v781, v782, v1357);
        goto LABEL_243;
      case 0x12Fu:
        appendStringInfoString((uint64_t)a1, "\"AlterOperatorStmt\":{");
        _outAlterOperatorStmt((uint64_t)a1, (uint64_t)a2, v783, v784, v785, v786, v787, v788, v1357);
        goto LABEL_243;
      case 0x130u:
        appendStringInfoString((uint64_t)a1, "\"AlterTypeStmt\":{");
        _outAlterTypeStmt((uint64_t)a1, (uint64_t)a2, v789, v790, v791, v792, v793, v794, v1357);
        goto LABEL_243;
      case 0x131u:
        appendStringInfoString((uint64_t)a1, "\"DropOwnedStmt\":{");
        _outDropOwnedStmt((uint64_t)a1, (uint64_t)a2, v795, v796, v797, v798, v799, v800);
        goto LABEL_243;
      case 0x132u:
        appendStringInfoString((uint64_t)a1, "\"ReassignOwnedStmt\":{");
        _outReassignOwnedStmt((uint64_t)a1, (uint64_t)a2, v801, v802, v803, v804, v805, v806, v1357);
        goto LABEL_243;
      case 0x133u:
        appendStringInfoString((uint64_t)a1, "\"CompositeTypeStmt\":{");
        _outCompositeTypeStmt((uint64_t)a1, (uint64_t)a2, v807, v808, v809, v810, v811, v812, v1357);
        goto LABEL_243;
      case 0x134u:
        appendStringInfoString((uint64_t)a1, "\"CreateEnumStmt\":{");
        _outCreateEnumStmt((uint64_t)a1, (uint64_t)a2, v813, v814, v815, v816, v817, v818, v1357);
        goto LABEL_243;
      case 0x135u:
        appendStringInfoString((uint64_t)a1, "\"CreateRangeStmt\":{");
        _outCreateRangeStmt((uint64_t)a1, (uint64_t)a2, v819, v820, v821, v822, v823, v824, v1357);
        goto LABEL_243;
      case 0x136u:
        appendStringInfoString((uint64_t)a1, "\"AlterEnumStmt\":{");
        _outAlterEnumStmt((uint64_t)a1, (uint64_t)a2, v825, v826, v827, v828, v829, v830);
        goto LABEL_243;
      case 0x137u:
        appendStringInfoString((uint64_t)a1, "\"AlterTSDictionaryStmt\":{");
        _outAlterTSDictionaryStmt((uint64_t)a1, (uint64_t)a2, v831, v832, v833, v834, v835, v836, v1357);
        goto LABEL_243;
      case 0x138u:
        appendStringInfoString((uint64_t)a1, "\"AlterTSConfigurationStmt\":{");
        _outAlterTSConfigurationStmt((uint64_t)a1, (uint64_t)a2, v837, v838, v839, v840, v841, v842);
        goto LABEL_243;
      case 0x139u:
        appendStringInfoString((uint64_t)a1, "\"CreateFdwStmt\":{");
        _outCreateFdwStmt((uint64_t)a1, (uint64_t)a2, v843, v844, v845, v846, v847, v848, v1357);
        goto LABEL_243;
      case 0x13Au:
        appendStringInfoString((uint64_t)a1, "\"AlterFdwStmt\":{");
        _outCreateFdwStmt((uint64_t)a1, (uint64_t)a2, v849, v850, v851, v852, v853, v854, v1357);
        goto LABEL_243;
      case 0x13Bu:
        appendStringInfoString((uint64_t)a1, "\"CreateForeignServerStmt\":{");
        _outCreateForeignServerStmt((uint64_t)a1, (uint64_t)a2, v855, v856, v857, v858, v859, v860, v1357);
        goto LABEL_243;
      case 0x13Cu:
        appendStringInfoString((uint64_t)a1, "\"AlterForeignServerStmt\":{");
        _outAlterForeignServerStmt((uint64_t)a1, (uint64_t)a2, v861, v862, v863, v864, v865, v866);
        goto LABEL_243;
      case 0x13Du:
        appendStringInfoString((uint64_t)a1, "\"CreateUserMappingStmt\":{");
        _outCreateUserMappingStmt((uint64_t)a1, (uint64_t)a2, v867, v868, v869, v870, v871, v872, v1357);
        goto LABEL_243;
      case 0x13Eu:
        appendStringInfoString((uint64_t)a1, "\"AlterUserMappingStmt\":{");
        _outAlterUserMappingStmt((uint64_t)a1, (uint64_t)a2, v873, v874, v875, v876, v877, v878, v1357);
        goto LABEL_243;
      case 0x13Fu:
        appendStringInfoString((uint64_t)a1, "\"DropUserMappingStmt\":{");
        _outDropUserMappingStmt((uint64_t)a1, (uint64_t)a2, v879, v880, v881, v882, v883, v884);
        goto LABEL_243;
      case 0x140u:
        appendStringInfoString((uint64_t)a1, "\"AlterTableSpaceOptionsStmt\":{");
        _outAlterTableSpaceOptionsStmt((uint64_t)a1, (uint64_t)a2, v885, v886, v887, v888, v889, v890);
        goto LABEL_243;
      case 0x141u:
        appendStringInfoString((uint64_t)a1, "\"AlterTableMoveAllStmt\":{");
        _outAlterTableMoveAllStmt(a1, (uint64_t)a2, v891, v892, v893, v894, v895, v896);
        goto LABEL_243;
      case 0x142u:
        appendStringInfoString((uint64_t)a1, "\"SecLabelStmt\":{");
        _outSecLabelStmt(a1, (uint64_t)a2, v897, v898, v899, v900, v901, v902, v1357);
        goto LABEL_243;
      case 0x143u:
        appendStringInfoString((uint64_t)a1, "\"CreateForeignTableStmt\":{");
        _outCreateForeignTableStmt(a1, (uint64_t)a2, v903, v904, v905, v906, v907, v908, v1357);
        goto LABEL_243;
      case 0x144u:
        appendStringInfoString((uint64_t)a1, "\"ImportForeignSchemaStmt\":{");
        _outImportForeignSchemaStmt(a1, (uint64_t)a2, v909, v910, v911, v912, v913, v914, v1357);
        goto LABEL_243;
      case 0x145u:
        appendStringInfoString((uint64_t)a1, "\"CreateExtensionStmt\":{");
        _outCreateExtensionStmt((uint64_t)a1, (uint64_t)a2, v915, v916, v917, v918, v919, v920, v1357);
        goto LABEL_243;
      case 0x146u:
        appendStringInfoString((uint64_t)a1, "\"AlterExtensionStmt\":{");
        _outAlterExtensionStmt((uint64_t)a1, (uint64_t)a2, v921, v922, v923, v924, v925, v926, v1357);
        goto LABEL_243;
      case 0x147u:
        appendStringInfoString((uint64_t)a1, "\"AlterExtensionContentsStmt\":{");
        _outAlterExtensionContentsStmt(a1, (uint64_t)a2, v927, v928, v929, v930, v931, v932, v1357);
        goto LABEL_243;
      case 0x148u:
        appendStringInfoString((uint64_t)a1, "\"CreateEventTrigStmt\":{");
        _outCreateEventTrigStmt((uint64_t)a1, (uint64_t)a2, v933, v934, v935, v936, v937, v938, v1357);
        goto LABEL_243;
      case 0x149u:
        appendStringInfoString((uint64_t)a1, "\"AlterEventTrigStmt\":{");
        _outAlterEventTrigStmt((uint64_t)a1, (uint64_t)a2, v939, v940, v941, v942, v943, v944);
        goto LABEL_243;
      case 0x14Au:
        appendStringInfoString((uint64_t)a1, "\"RefreshMatViewStmt\":{");
        _outRefreshMatViewStmt((uint64_t)a1, (uint64_t)a2, v945, v946, v947, v948, v949, v950, v1357);
        goto LABEL_243;
      case 0x14Bu:
        appendStringInfoString((uint64_t)a1, "\"ReplicaIdentityStmt\":{");
        _outReplicaIdentityStmt((uint64_t)a1, (uint64_t)a2, v951, v952, v953, v954, v955, v956, v1357);
        goto LABEL_243;
      case 0x14Cu:
        appendStringInfoString((uint64_t)a1, "\"AlterSystemStmt\":{");
        _outAlterSystemStmt((unint64_t)a1, (uint64_t)a2, v957, v958, v959, v960, v961, v962, v1357);
        goto LABEL_243;
      case 0x14Du:
        appendStringInfoString((uint64_t)a1, "\"CreatePolicyStmt\":{");
        _outCreatePolicyStmt((uint64_t)a1, (uint64_t)a2, v963, v964, v965, v966, v967, v968, v1357);
        goto LABEL_243;
      case 0x14Eu:
        appendStringInfoString((uint64_t)a1, "\"AlterPolicyStmt\":{");
        _outAlterPolicyStmt((uint64_t)a1, (uint64_t)a2, v969, v970, v971, v972, v973, v974, v1357);
        goto LABEL_243;
      case 0x14Fu:
        appendStringInfoString((uint64_t)a1, "\"CreateTransformStmt\":{");
        _outCreateTransformStmt((uint64_t)a1, (uint64_t)a2, v975, v976, v977, v978, v979, v980, v1357);
        goto LABEL_243;
      case 0x150u:
        appendStringInfoString((uint64_t)a1, "\"CreateAmStmt\":{");
        _outCreateAmStmt((uint64_t)a1, (uint64_t)a2, v981, v982, v983, v984, v985, v986);
        goto LABEL_243;
      case 0x151u:
        appendStringInfoString((uint64_t)a1, "\"CreatePublicationStmt\":{");
        _outCreatePublicationStmt((uint64_t)a1, (uint64_t)a2, v987, v988, v989, v990, v991, v992);
        goto LABEL_243;
      case 0x152u:
        appendStringInfoString((uint64_t)a1, "\"AlterPublicationStmt\":{");
        _outAlterPublicationStmt(a1, (uint64_t)a2, v993, v994, v995, v996, v997, v998);
        goto LABEL_243;
      case 0x153u:
        appendStringInfoString((uint64_t)a1, "\"CreateSubscriptionStmt\":{");
        _outCreateSubscriptionStmt((uint64_t)a1, (uint64_t)a2, v999, v1000, v1001, v1002, v1003, v1004, v1357);
        goto LABEL_243;
      case 0x154u:
        appendStringInfoString((uint64_t)a1, "\"AlterSubscriptionStmt\":{");
        _outAlterSubscriptionStmt(a1, (uint64_t)a2, v1005, v1006, v1007, v1008, v1009, v1010, v1357);
        goto LABEL_243;
      case 0x155u:
        appendStringInfoString((uint64_t)a1, "\"DropSubscriptionStmt\":{");
        _outDropSubscriptionStmt(a1, (uint64_t)a2, v1011, v1012, v1013, v1014, v1015, v1016);
        goto LABEL_243;
      case 0x156u:
        appendStringInfoString((uint64_t)a1, "\"CreateStatsStmt\":{");
        _outCreateStatsStmt((uint64_t)a1, (uint64_t)a2, v1017, v1018, v1019, v1020, v1021, v1022);
        goto LABEL_243;
      case 0x157u:
        appendStringInfoString((uint64_t)a1, "\"AlterCollationStmt\":{");
        _outAlterCollationStmt((unint64_t)a1, (uint64_t)a2, v1023, v1024, v1025, v1026, v1027, v1028, v1357);
        goto LABEL_243;
      case 0x158u:
        appendStringInfoString((uint64_t)a1, "\"CallStmt\":{");
        _outCallStmt((uint64_t)a1, (uint64_t)a2, v1029, v1030, v1031, v1032, v1033, v1034, v1357);
        goto LABEL_243;
      case 0x159u:
        appendStringInfoString((uint64_t)a1, "\"AlterStatsStmt\":{");
        _outAlterStatsStmt((uint64_t)a1, (uint64_t)a2, v1035, v1036, v1037, v1038, v1039, v1040);
        goto LABEL_243;
      case 0x15Au:
        appendStringInfoString((uint64_t)a1, "\"A_Expr\":{");
        _outAExpr((uint64_t)a1, (uint64_t)a2, v1041, v1042, v1043, v1044, v1045, v1046);
        goto LABEL_243;
      case 0x15Bu:
        appendStringInfoString((uint64_t)a1, "\"ColumnRef\":{");
        _outColumnRef((uint64_t)a1, (uint64_t)a2, v1047, v1048, v1049, v1050, v1051, v1052);
        goto LABEL_243;
      case 0x15Cu:
        appendStringInfoString((uint64_t)a1, "\"ParamRef\":{");
        _outParamRef((uint64_t)a1, (uint64_t)a2, v1053, v1054, v1055, v1056, v1057, v1058);
        goto LABEL_243;
      case 0x15Du:
        appendStringInfoString((uint64_t)a1, "\"A_Const\":{");
        _outAConst((uint64_t)a1, (uint64_t)a2, v1059, v1060, v1061, v1062, v1063, v1064);
        goto LABEL_243;
      case 0x15Eu:
        appendStringInfoString((uint64_t)a1, "\"FuncCall\":{");
        _outFuncCall((uint64_t)a1, (uint64_t)a2, v1065, v1066, v1067, v1068, v1069, v1070);
        goto LABEL_243;
      case 0x15Fu:
        uint64_t v36 = "\"A_Star\":{";
LABEL_193:
        appendStringInfoString((uint64_t)a1, v36);
        goto LABEL_243;
      case 0x160u:
        appendStringInfoString((uint64_t)a1, "\"A_Indices\":{");
        _outAIndices((uint64_t)a1, (uint64_t)a2, v1071, v1072, v1073, v1074, v1075, v1076, v1357);
        goto LABEL_243;
      case 0x161u:
        appendStringInfoString((uint64_t)a1, "\"A_Indirection\":{");
        _outAIndirection((uint64_t)a1, (uint64_t)a2, v1077, v1078, v1079, v1080, v1081, v1082, v1357);
        goto LABEL_243;
      case 0x162u:
        appendStringInfoString((uint64_t)a1, "\"A_ArrayExpr\":{");
        _outAArrayExpr((uint64_t)a1, (uint64_t)a2, v1083, v1084, v1085, v1086, v1087, v1088);
        goto LABEL_243;
      case 0x163u:
        appendStringInfoString((uint64_t)a1, "\"ResTarget\":{");
        _outResTarget((uint64_t)a1, (uint64_t)a2, v1089, v1090, v1091, v1092, v1093, v1094);
        goto LABEL_243;
      case 0x164u:
        appendStringInfoString((uint64_t)a1, "\"MultiAssignRef\":{");
        _outMultiAssignRef((uint64_t)a1, (uint64_t)a2, v1095, v1096, v1097, v1098, v1099, v1100);
        goto LABEL_243;
      case 0x165u:
        appendStringInfoString((uint64_t)a1, "\"TypeCast\":{");
        _outTypeCast((uint64_t)a1, (uint64_t)a2, v1101, v1102, v1103, v1104, v1105, v1106);
        goto LABEL_243;
      case 0x166u:
        appendStringInfoString((uint64_t)a1, "\"CollateClause\":{");
        _outCollateClause((uint64_t)a1, (uint64_t)a2, v1107, v1108, v1109, v1110, v1111, v1112);
        goto LABEL_243;
      case 0x167u:
        appendStringInfoString((uint64_t)a1, "\"SortBy\":{");
        _outSortBy((uint64_t)a1, (uint64_t)a2, v1113, v1114, v1115, v1116, v1117, v1118);
        goto LABEL_243;
      case 0x168u:
        appendStringInfoString((uint64_t)a1, "\"WindowDef\":{");
        _outWindowDef((uint64_t)a1, (uint64_t)a2, v1119, v1120, v1121, v1122, v1123, v1124);
        goto LABEL_243;
      case 0x169u:
        appendStringInfoString((uint64_t)a1, "\"RangeSubselect\":{");
        _outRangeSubselect((uint64_t)a1, (uint64_t)a2, v1125, v1126, v1127, v1128, v1129, v1130, v1357);
        goto LABEL_243;
      case 0x16Au:
        appendStringInfoString((uint64_t)a1, "\"RangeFunction\":{");
        _outRangeFunction((uint64_t)a1, (uint64_t)a2, v1131, v1132, v1133, v1134, v1135, v1136, v1357);
        goto LABEL_243;
      case 0x16Bu:
        appendStringInfoString((uint64_t)a1, "\"RangeTableSample\":{");
        _outRangeTableSample((uint64_t)a1, (uint64_t)a2, v1137, v1138, v1139, v1140, v1141, v1142);
        goto LABEL_243;
      case 0x16Cu:
        appendStringInfoString((uint64_t)a1, "\"RangeTableFunc\":{");
        _outRangeTableFunc((uint64_t)a1, (uint64_t)a2, v1143, v1144, v1145, v1146, v1147, v1148);
        goto LABEL_243;
      case 0x16Du:
        appendStringInfoString((uint64_t)a1, "\"RangeTableFuncCol\":{");
        _outRangeTableFuncCol((uint64_t)a1, (uint64_t)a2, v1149, v1150, v1151, v1152, v1153, v1154);
        goto LABEL_243;
      case 0x16Eu:
        appendStringInfoString((uint64_t)a1, "\"TypeName\":{");
        _outTypeName((uint64_t)a1, (uint64_t)a2, v1155, v1156, v1157, v1158, v1159, v1160);
        goto LABEL_243;
      case 0x16Fu:
        appendStringInfoString((uint64_t)a1, "\"ColumnDef\":{");
        _outColumnDef((uint64_t)a1, (uint64_t)a2, v1161, v1162, v1163, v1164, v1165, v1166);
        goto LABEL_243;
      case 0x170u:
        appendStringInfoString((uint64_t)a1, "\"IndexElem\":{");
        _outIndexElem(a1, (uint64_t)a2, v1167, v1168, v1169, v1170, v1171, v1172);
        goto LABEL_243;
      case 0x171u:
        appendStringInfoString((uint64_t)a1, "\"Constraint\":{");
        _outConstraint(a1, (uint64_t)a2, v1173, v1174, v1175, v1176, v1177, v1178);
        goto LABEL_243;
      case 0x172u:
        appendStringInfoString((uint64_t)a1, "\"DefElem\":{");
        _outDefElem(a1, (uint64_t)a2, v1179, v1180, v1181, v1182, v1183, v1184);
        goto LABEL_243;
      case 0x173u:
        appendStringInfoString((uint64_t)a1, "\"RangeTblEntry\":{");
        _outRangeTblEntry(a1, (uint64_t)a2, v1185, v1186, v1187, v1188, v1189, v1190, v1357);
        goto LABEL_243;
      case 0x174u:
        appendStringInfoString((uint64_t)a1, "\"RangeTblFunction\":{");
        _outRangeTblFunction((uint64_t)a1, (uint64_t)a2, v1191, v1192, v1193, v1194, v1195, v1196, v1357);
        goto LABEL_243;
      case 0x175u:
        appendStringInfoString((uint64_t)a1, "\"TableSampleClause\":{");
        _outTableSampleClause((uint64_t)a1, (uint64_t)a2, v1197, v1198, v1199, v1200, v1201, v1202, v1357);
        goto LABEL_243;
      case 0x176u:
        appendStringInfoString((uint64_t)a1, "\"WithCheckOption\":{");
        _outWithCheckOption(a1, (uint64_t)a2, v1203, v1204, v1205, v1206, v1207, v1208);
        goto LABEL_243;
      case 0x177u:
        appendStringInfoString((uint64_t)a1, "\"SortGroupClause\":{");
        _outSortGroupClause((uint64_t)a1, (uint64_t)a2, v1209, v1210, v1211, v1212, v1213, v1214);
        goto LABEL_243;
      case 0x178u:
        appendStringInfoString((uint64_t)a1, "\"GroupingSet\":{");
        _outGroupingSet((uint64_t)a1, (uint64_t)a2, v1215, v1216, v1217, v1218, v1219, v1220);
        goto LABEL_243;
      case 0x179u:
        appendStringInfoString((uint64_t)a1, "\"WindowClause\":{");
        _outWindowClause((uint64_t)a1, (uint64_t)a2, v1221, v1222, v1223, v1224, v1225, v1226);
        goto LABEL_243;
      case 0x17Au:
        appendStringInfoString((uint64_t)a1, "\"ObjectWithArgs\":{");
        _outObjectWithArgs((uint64_t)a1, (uint64_t)a2, v1227, v1228, v1229, v1230, v1231, v1232);
        goto LABEL_243;
      case 0x17Bu:
        appendStringInfoString((uint64_t)a1, "\"AccessPriv\":{");
        _outAccessPriv((uint64_t)a1, (uint64_t)a2, v1233, v1234, v1235, v1236, v1237, v1238, v1357);
        goto LABEL_243;
      case 0x17Cu:
        appendStringInfoString((uint64_t)a1, "\"CreateOpClassItem\":{");
        _outCreateOpClassItem((uint64_t)a1, (uint64_t)a2, v1239, v1240, v1241, v1242, v1243, v1244, v1357);
        goto LABEL_243;
      case 0x17Du:
        appendStringInfoString((uint64_t)a1, "\"TableLikeClause\":{");
        _outTableLikeClause((uint64_t)a1, (uint64_t)a2, v1245, v1246, v1247, v1248, v1249, v1250);
        goto LABEL_243;
      case 0x17Eu:
        appendStringInfoString((uint64_t)a1, "\"FunctionParameter\":{");
        _outFunctionParameter(a1, (uint64_t)a2, v1251, v1252, v1253, v1254, v1255, v1256, v1357);
        goto LABEL_243;
      case 0x17Fu:
        appendStringInfoString((uint64_t)a1, "\"LockingClause\":{");
        _outLockingClause((uint64_t)a1, (uint64_t)a2, v1257, v1258, v1259, v1260, v1261, v1262);
        goto LABEL_243;
      case 0x180u:
        appendStringInfoString((uint64_t)a1, "\"RowMarkClause\":{");
        _outRowMarkClause((uint64_t)a1, (uint64_t)a2, v1263, v1264, v1265, v1266, v1267, v1268);
        goto LABEL_243;
      case 0x181u:
        appendStringInfoString((uint64_t)a1, "\"XmlSerialize\":{");
        _outXmlSerialize((uint64_t)a1, (uint64_t)a2, v1269, v1270, v1271, v1272, v1273, v1274);
        goto LABEL_243;
      case 0x182u:
        appendStringInfoString((uint64_t)a1, "\"WithClause\":{");
        _outWithClause((uint64_t)a1, (uint64_t)a2, v1275, v1276, v1277, v1278, v1279, v1280);
        goto LABEL_243;
      case 0x183u:
        appendStringInfoString((uint64_t)a1, "\"InferClause\":{");
        _outInferClause((uint64_t)a1, (uint64_t)a2, v1281, v1282, v1283, v1284, v1285, v1286);
        goto LABEL_243;
      case 0x184u:
        appendStringInfoString((uint64_t)a1, "\"OnConflictClause\":{");
        _outOnConflictClause((uint64_t)a1, (uint64_t)a2, v1287, v1288, v1289, v1290, v1291, v1292);
        goto LABEL_243;
      case 0x185u:
        appendStringInfoString((uint64_t)a1, "\"CommonTableExpr\":{");
        _outCommonTableExpr(a1, (uint64_t)a2, v1293, v1294, v1295, v1296, v1297, v1298, v1357);
        goto LABEL_243;
      case 0x186u:
        appendStringInfoString((uint64_t)a1, "\"RoleSpec\":{");
        _outRoleSpec(a1, (uint64_t)a2, v1299, v1300, v1301, v1302, v1303, v1304);
        goto LABEL_243;
      case 0x187u:
        appendStringInfoString((uint64_t)a1, "\"TriggerTransition\":{");
        _outTriggerTransition((uint64_t)a1, (uint64_t)a2, v1305, v1306, v1307, v1308, v1309, v1310);
        goto LABEL_243;
      case 0x188u:
        appendStringInfoString((uint64_t)a1, "\"PartitionElem\":{");
        _outPartitionElem((uint64_t)a1, (uint64_t)a2, v1311, v1312, v1313, v1314, v1315, v1316);
        goto LABEL_243;
      case 0x189u:
        appendStringInfoString((uint64_t)a1, "\"PartitionSpec\":{");
        _outPartitionSpec((uint64_t)a1, (uint64_t)a2, v1317, v1318, v1319, v1320, v1321, v1322);
        goto LABEL_243;
      case 0x18Au:
        appendStringInfoString((uint64_t)a1, "\"PartitionBoundSpec\":{");
        _outPartitionBoundSpec((uint64_t)a1, (uint64_t)a2, v1323, v1324, v1325, v1326, v1327, v1328);
        goto LABEL_243;
      case 0x18Bu:
        appendStringInfoString((uint64_t)a1, "\"PartitionRangeDatum\":{");
        _outPartitionRangeDatum((uint64_t)a1, (uint64_t)a2, v1329, v1330, v1331, v1332, v1333, v1334);
        goto LABEL_243;
      case 0x18Cu:
        appendStringInfoString((uint64_t)a1, "\"PartitionCmd\":{");
        _outPartitionCmd((uint64_t)a1, (uint64_t)a2, v1335, v1336, v1337, v1338, v1339, v1340, v1357);
        goto LABEL_243;
      case 0x18Du:
        appendStringInfoString((uint64_t)a1, "\"VacuumRelation\":{");
        _outVacuumRelation((uint64_t)a1, (uint64_t)a2, v1341, v1342, v1343, v1344, v1345, v1346, v1357);
        goto LABEL_243;
      case 0x19Au:
        appendStringInfoString((uint64_t)a1, "\"InlineCodeBlock\":{");
        _outInlineCodeBlock((uint64_t)a1, (uint64_t)a2, v1347, v1348, v1349, v1350, v1351, v1352);
        goto LABEL_243;
      case 0x1A0u:
        appendStringInfoString((uint64_t)a1, "\"CallContext\":{");
        if (*((unsigned char *)a2 + 4)) {
          appendStringInfo((uint64_t)a1, "\"atomic\":%s,", v17, v18, v19, v20, v21, v22, (size_t)"true");
        }
LABEL_243:
        int v1353 = a1[2];
        BOOL v1354 = __OFSUB__(v1353, 1);
        uint64_t v1355 = (v1353 - 1);
        if ((int)v1355 < 0 == v1354)
        {
          uint64_t v1356 = *(void *)a1;
          if (*(unsigned char *)(*(void *)a1 + v1355) == 44)
          {
            a1[2] = v1355;
            *(unsigned char *)(v1356 + v1355) = 0;
          }
        }
        uint64_t v43 = "}}";
        uint64_t v44 = (uint64_t)a1;
        break;
      default:
        if (errstart(19, 0))
        {
          errmsg_internal("could not dump unrecognized node type: %d", *a2);
          errfinish("src/pg_query_outfuncs_json.c", 252, (uint64_t)"_outNode");
        }
        uint64_t v43 = "}";
        uint64_t v44 = (uint64_t)a1;
        break;
    }
    return (void *)appendStringInfo(v44, v43, v17, v18, v19, v20, v21, v22, a9);
  }
  else
  {
    return appendStringInfoString((uint64_t)a1, "null");
  }
}

unint64_t _outFloat(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  appendStringInfo((uint64_t)a1, "\"str\":", a3, a4, a5, a6, a7, a8, v24);
  _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);

  return appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, a9);
}

unint64_t _outList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v24);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 8;
    do
    {
      uint64_t v13 = *(void *)(a2 + 16);
      uint64_t v14 = *(void *)(v13 + 8 * v11);
      if (v14) {
        _outNode(a1, v14);
      }
      else {
        appendStringInfoString(a1, "{}");
      }
      uint64_t v15 = *(int *)(a2 + 4);
      if (v13 + v12) {
        BOOL v16 = v13 + v12 >= (unint64_t)(*(void *)(a2 + 16) + 8 * v15);
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        appendStringInfoString(a1, ",");
        uint64_t v15 = *(int *)(a2 + 4);
      }
      ++v11;
      v12 += 8;
    }
    while (v11 < v15);
  }
  appendStringInfoChar(a1, 93);

  return appendStringInfo(a1, ",", v17, v18, v19, v20, v21, v22, a9);
}

unint64_t _outIntList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v31);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      uint64_t v19 = (unsigned int *)(*(void *)(a2 + 16) + v17);
      unsigned int v21 = *v19;
      unint64_t v20 = (unint64_t)(v19 + 2);
      appendStringInfo(a1, "%d", v11, v12, v13, v14, v15, v16, v21);
      uint64_t v22 = *(int *)(a2 + 4);
      if (v20) {
        BOOL v23 = v20 >= *(void *)(a2 + 16) + 8 * v22;
      }
      else {
        BOOL v23 = 1;
      }
      if (!v23)
      {
        appendStringInfoString(a1, ",");
        uint64_t v22 = *(int *)(a2 + 4);
      }
      ++v18;
      v17 += 8;
    }
    while (v18 < v22);
  }
  appendStringInfoChar(a1, 93);

  return appendStringInfo(a1, ",", v24, v25, v26, v27, v28, v29, a9);
}

unint64_t _outOidList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  appendStringInfo(a1, "\"items\":", a3, a4, a5, a6, a7, a8, v31);
  appendStringInfoChar(a1, 91);
  if (*(int *)(a2 + 4) >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      uint64_t v19 = (unsigned int *)(*(void *)(a2 + 16) + v17);
      unsigned int v21 = *v19;
      unint64_t v20 = (unint64_t)(v19 + 2);
      appendStringInfo(a1, "%u", v11, v12, v13, v14, v15, v16, v21);
      uint64_t v22 = *(int *)(a2 + 4);
      if (v20) {
        BOOL v23 = v20 >= *(void *)(a2 + 16) + 8 * v22;
      }
      else {
        BOOL v23 = 1;
      }
      if (!v23)
      {
        appendStringInfoString(a1, ",");
        uint64_t v22 = *(int *)(a2 + 4);
      }
      ++v18;
      v17 += 8;
    }
    while (v18 < v22);
  }
  appendStringInfoChar(a1, 93);

  return appendStringInfo(a1, ",", v24, v25, v26, v27, v28, v29, a9);
}

uint64_t _outAlias(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"aliasname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    uint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"colnames\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outRangeVar(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"catalogname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    uint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v63);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"schemaname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    uint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v64);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"relname\":", a3, a4, a5, a6, a7, a8, v62);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    uint64_t result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v65);
  }
  if (*(unsigned char *)(a2 + 32)) {
    uint64_t result = appendStringInfo((uint64_t)v9, "\"inh\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 33)) {
    uint64_t result = appendStringInfo((uint64_t)v9, "\"relpersistence\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 33));
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"alias\":{", a3, a4, a5, a6, a7, a8, v62);
    _outAlias((uint64_t)v9, *(void *)(a2 + 40), v46, v47, v48, v49, v50, v51, v66);
    int v58 = v9[2];
    BOOL v59 = __OFSUB__(v58, 1);
    uint64_t v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      uint64_t v61 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v60) == 44)
      {
        void v9[2] = v60;
        *(unsigned char *)(v61 + v6errstart(20, 0) = 0;
      }
    }
    uint64_t result = appendStringInfo((uint64_t)v9, "},", v52, v53, v54, v55, v56, v57, v67);
  }
  if (*(_DWORD *)(a2 + 48)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  }
  return result;
}

unint64_t _outTableFunc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"ns_uris\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v138);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"ns_names\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(a1, v32);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(a1, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo(a1, "],", v22, v23, v24, v25, v26, v27, v139);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"docexpr\":", a3, a4, a5, a6, a7, a8, v137);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo(a1, ",", v34, v35, v36, v37, v38, v39, v140);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"rowexpr\":", a3, a4, a5, a6, a7, a8, v137);
    _outNode(a1, *(void *)(a2 + 32));
    appendStringInfo(a1, ",", v40, v41, v42, v43, v44, v45, v141);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"colnames\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v52 = *(void *)(a2 + 40);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(a1, v56);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString(a1, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    appendStringInfo(a1, "],", v46, v47, v48, v49, v50, v51, v142);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"coltypes\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v64 = *(void *)(a2 + 48);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      uint64_t v65 = 0;
      uint64_t v66 = 8;
      do
      {
        uint64_t v67 = *(void *)(v64 + 16);
        uint64_t v68 = *(void *)(v67 + 8 * v65);
        if (v68) {
          _outNode(a1, v68);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v67 + v66) {
          BOOL v69 = v67 + v66 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v69 = 1;
        }
        if (!v69) {
          appendStringInfoString(a1, ",");
        }
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo(a1, "],", v58, v59, v60, v61, v62, v63, v143);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo(a1, "\"coltypmods\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v76 = *(void *)(a2 + 56);
    if (v76 && *(int *)(v76 + 4) >= 1)
    {
      uint64_t v77 = 0;
      uint64_t v78 = 8;
      do
      {
        uint64_t v79 = *(void *)(v76 + 16);
        uint64_t v80 = *(void *)(v79 + 8 * v77);
        if (v80) {
          _outNode(a1, v80);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v79 + v78) {
          BOOL v81 = v79 + v78 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v81 = 1;
        }
        if (!v81) {
          appendStringInfoString(a1, ",");
        }
        ++v77;
        v78 += 8;
      }
      while (v77 < *(int *)(v76 + 4));
    }
    appendStringInfo(a1, "],", v70, v71, v72, v73, v74, v75, v144);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo(a1, "\"colcollations\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v88 = *(void *)(a2 + 64);
    if (v88 && *(int *)(v88 + 4) >= 1)
    {
      uint64_t v89 = 0;
      uint64_t v90 = 8;
      do
      {
        uint64_t v91 = *(void *)(v88 + 16);
        uint64_t v92 = *(void *)(v91 + 8 * v89);
        if (v92) {
          _outNode(a1, v92);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v91 + v90) {
          BOOL v93 = v91 + v90 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v93 = 1;
        }
        if (!v93) {
          appendStringInfoString(a1, ",");
        }
        ++v89;
        v90 += 8;
      }
      while (v89 < *(int *)(v88 + 4));
    }
    appendStringInfo(a1, "],", v82, v83, v84, v85, v86, v87, v145);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo(a1, "\"colexprs\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v100 = *(void *)(a2 + 72);
    if (v100 && *(int *)(v100 + 4) >= 1)
    {
      uint64_t v101 = 0;
      uint64_t v102 = 8;
      do
      {
        uint64_t v103 = *(void *)(v100 + 16);
        uint64_t v104 = *(void *)(v103 + 8 * v101);
        if (v104) {
          _outNode(a1, v104);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v103 + v102) {
          BOOL v105 = v103 + v102 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v105 = 1;
        }
        if (!v105) {
          appendStringInfoString(a1, ",");
        }
        ++v101;
        v102 += 8;
      }
      while (v101 < *(int *)(v100 + 4));
    }
    appendStringInfo(a1, "],", v94, v95, v96, v97, v98, v99, v146);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo(a1, "\"coldefexprs\":", a3, a4, a5, a6, a7, a8, v137);
    appendStringInfoChar(a1, 91);
    uint64_t v112 = *(void *)(a2 + 80);
    if (v112 && *(int *)(v112 + 4) >= 1)
    {
      uint64_t v113 = 0;
      uint64_t v114 = 8;
      do
      {
        uint64_t v115 = *(void *)(v112 + 16);
        uint64_t v116 = *(void *)(v115 + 8 * v113);
        if (v116) {
          _outNode(a1, v116);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v115 + v114) {
          BOOL v117 = v115 + v114 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v117 = 1;
        }
        if (!v117) {
          appendStringInfoString(a1, ",");
        }
        ++v113;
        v114 += 8;
      }
      while (v113 < *(int *)(v112 + 4));
    }
    appendStringInfo(a1, "],", v106, v107, v108, v109, v110, v111, v147);
  }
  unint64_t result = bms_is_empty(*(unsigned int **)(a2 + 88));
  if ((result & 1) == 0)
  {
    appendStringInfo(a1, "\"notnulls\":[", v119, v120, v121, v122, v123, v124, v137);
    uint64_t member = bms_next_member(*(int **)(a2 + 88), 0);
    if ((member & 0x80000000) == 0)
    {
      uint64_t v132 = member;
      do
      {
        appendStringInfo(a1, "%d,", v126, v127, v128, v129, v130, v131, v132);
        uint64_t v132 = bms_next_member(*(int **)(a2 + 88), v132);
      }
      while ((v132 & 0x80000000) == 0);
    }
    int v133 = *(_DWORD *)(a1 + 8);
    BOOL v134 = __OFSUB__(v133, 1);
    uint64_t v135 = (v133 - 1);
    if ((int)v135 < 0 == v134)
    {
      uint64_t v136 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v135) == 44)
      {
        *(_DWORD *)(a1 + 8) = v135;
        *(unsigned char *)(v136 + v135) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "],", v126, v127, v128, v129, v130, v131, v148);
  }
  if (*(_DWORD *)(a2 + 96)) {
    unint64_t result = appendStringInfo(a1, "\"ordinalitycol\":%d,", v119, v120, v121, v122, v123, v124, *(unsigned int *)(a2 + 96));
  }
  if (*(_DWORD *)(a2 + 100)) {
    return appendStringInfo(a1, "\"location\":%d,", v119, v120, v121, v122, v123, v124, *(unsigned int *)(a2 + 100));
  }
  return result;
}

uint64_t _outVar(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"varno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_WORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"varattno\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"vartype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"vartypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo(v9, "\"varcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"varlevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(_DWORD *)(a2 + 28)) {
    unint64_t result = appendStringInfo(v9, "\"varnosyn\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  }
  if (*(_WORD *)(a2 + 32)) {
    unint64_t result = appendStringInfo(v9, "\"varattnosyn\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 32));
  }
  if (*(_DWORD *)(a2 + 36)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  }
  return result;
}

unint64_t _outParam(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D8F40)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"paramkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"paramid\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(a1, "\"paramtype\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(a1, "\"paramtypmod\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo(a1, "\"paramcollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  }
  return result;
}

unint64_t _outAggref(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a2 + 4)) {
    appendStringInfo(a1, "\"aggfnoid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    appendStringInfo(a1, "\"aggtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    appendStringInfo(a1, "\"aggcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    appendStringInfo(a1, "\"aggtranstype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"aggargtypes\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v86);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"aggdirectargs\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    uint64_t v28 = *(void *)(a2 + 32);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(a1, v32);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(a1, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo(a1, "],", v22, v23, v24, v25, v26, v27, v87);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"args\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    uint64_t v40 = *(void *)(a2 + 40);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(a1, v44);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(a1, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    appendStringInfo(a1, "],", v34, v35, v36, v37, v38, v39, v88);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"aggorder\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    uint64_t v52 = *(void *)(a2 + 48);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(a1, v56);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString(a1, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    appendStringInfo(a1, "],", v46, v47, v48, v49, v50, v51, v89);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo(a1, "\"aggdistinct\":", a3, a4, a5, a6, a7, a8, v85);
    appendStringInfoChar(a1, 91);
    uint64_t v64 = *(void *)(a2 + 56);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      uint64_t v65 = 0;
      uint64_t v66 = 8;
      do
      {
        uint64_t v67 = *(void *)(v64 + 16);
        uint64_t v68 = *(void *)(v67 + 8 * v65);
        if (v68) {
          _outNode(a1, v68);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v67 + v66) {
          BOOL v69 = v67 + v66 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v69 = 1;
        }
        if (!v69) {
          appendStringInfoString(a1, ",");
        }
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo(a1, "],", v58, v59, v60, v61, v62, v63, v90);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo(a1, "\"aggfilter\":", a3, a4, a5, a6, a7, a8, v85);
    _outNode(a1, *(void *)(a2 + 64));
    appendStringInfo(a1, ",", v70, v71, v72, v73, v74, v75, v91);
  }
  if (*(unsigned char *)(a2 + 72)) {
    appendStringInfo(a1, "\"aggstar\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 73)) {
    appendStringInfo(a1, "\"aggvariadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 74)) {
    appendStringInfo(a1, "\"aggkind\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 74));
  }
  if (*(_DWORD *)(a2 + 76)) {
    appendStringInfo(a1, "\"agglevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 76));
  }
  int v76 = *(_DWORD *)(a2 + 80);
  if (v76)
  {
    if (v76 == 9)
    {
      uint64_t v77 = "AGGSPLIT_FINAL_DESERIAL";
    }
    else if (v76 == 6)
    {
      uint64_t v77 = "AGGSPLIT_INITIAL_SERIAL";
    }
    else
    {
      uint64_t v77 = 0;
    }
  }
  else
  {
    uint64_t v77 = "AGGSPLIT_SIMPLE";
  }
  unint64_t result = appendStringInfo(a1, "\"aggsplit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v77);
  if (*(_DWORD *)(a2 + 84)) {
    return appendStringInfo(a1, "\"location\":%d,", v79, v80, v81, v82, v83, v84, *(unsigned int *)(a2 + 84));
  }
  return result;
}

uint64_t _outGroupingFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"args\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"refs\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"cols\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 32)) {
    unint64_t result = appendStringInfo(v9, "\"agglevelsup\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  if (*(_DWORD *)(a2 + 36)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  }
  return result;
}

uint64_t _outWindowFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"winfnoid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"wintype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"wincollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v28);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"aggfilter\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo(v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 40)) {
    unint64_t result = appendStringInfo(v9, "\"winref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  if (*(unsigned char *)(a2 + 44)) {
    unint64_t result = appendStringInfo(v9, "\"winstar\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 45)) {
    unint64_t result = appendStringInfo(v9, "\"winagg\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 48)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  }
  return result;
}

uint64_t _outSubscriptingRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"refcontainertype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v10, "\"refelemtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v10, "\"reftypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v10, "\"refcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v10, "\"refupperindexpr\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 24);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v48);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v10, "\"reflowerindexpr\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 32);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, v49);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(v10, "\"refexpr\":", a3, a4, a5, a6, a7, a8, v47);
    _outNode(v10, *(void *)(a2 + 40));
    unint64_t result = appendStringInfo(v10, ",", v35, v36, v37, v38, v39, v40, v50);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(v10, "\"refassgnexpr\":", a3, a4, a5, a6, a7, a8, v47);
    _outNode(v10, *(void *)(a2 + 48));
    return appendStringInfo(v10, ",", v41, v42, v43, v44, v45, v46, a9);
  }
  return result;
}

unint64_t _outFuncExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a2 + 4)) {
    appendStringInfo(a1, "\"funcid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    appendStringInfo(a1, "\"funcresulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(unsigned char *)(a2 + 12)) {
    appendStringInfo(a1, "\"funcretset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 13)) {
    appendStringInfo(a1, "\"funcvariadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  uint64_t v10 = *(int *)(a2 + 16);
  if (v10 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D90D0)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"funcformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo(a1, "\"funccollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(a1, "\"inputcollid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 32);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 40));
  }
  return result;
}

uint64_t _outNamedArgExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"name\":", a3, a4, a5, a6, a7, a8, v28);
    _outToken(v9, *(char **)(a2 + 16), v16, v17, v18, v19, v20, v21);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"argnumber\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(_DWORD *)(a2 + 28)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  }
  return result;
}

uint64_t _outOpExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"opno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"opfuncid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"opresulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"opretset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo(v9, "\"opcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 32);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  return result;
}

uint64_t _outScalarArrayOpExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"opno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"opfuncid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(unsigned char *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"useOr\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 24);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outBoolExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D8F60)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"BOOLop\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  return result;
}

unint64_t _outSubLink(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 7) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D8F78)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"subLinkType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"subLinkId\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"testexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v44);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"operName\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar(a1, 91);
    uint64_t v31 = *(void *)(a2 + 24);
    if (v31 && *(int *)(v31 + 4) >= 1)
    {
      uint64_t v32 = 0;
      uint64_t v33 = 8;
      do
      {
        uint64_t v34 = *(void *)(v31 + 16);
        uint64_t v35 = *(void *)(v34 + 8 * v32);
        if (v35) {
          _outNode(a1, v35);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v34 + v33) {
          BOOL v36 = v34 + v33 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v36 = 1;
        }
        if (!v36) {
          appendStringInfoString(a1, ",");
        }
        ++v32;
        v33 += 8;
      }
      while (v32 < *(int *)(v31 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v25, v26, v27, v28, v29, v30, v45);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"subselect\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo(a1, ",", v37, v38, v39, v40, v41, v42, v46);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 40));
  }
  return result;
}

unint64_t _outSubPlan(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 7) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D8F78)[v10];
  }
  appendStringInfo((uint64_t)a1, "\"subLinkType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"testexpr\":", v12, v13, v14, v15, v16, v17, v91);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo((uint64_t)a1, ",", v18, v19, v20, v21, v22, v23, v92);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"paramIds\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v30 = *(void *)(a2 + 16);
    if (v30 && *(int *)(v30 + 4) >= 1)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 8;
      do
      {
        uint64_t v33 = *(void *)(v30 + 16);
        uint64_t v34 = *(void *)(v33 + 8 * v31);
        if (v34) {
          _outNode(a1, v34);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v33 + v32) {
          BOOL v35 = v33 + v32 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v35 = 1;
        }
        if (!v35) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v31;
        v32 += 8;
      }
      while (v31 < *(int *)(v30 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v24, v25, v26, v27, v28, v29, v93);
  }
  if (*(_DWORD *)(a2 + 24)) {
    appendStringInfo((uint64_t)a1, "\"plan_id\":%d,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 24));
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"plan_name\":", v12, v13, v14, v15, v16, v17, v91);
    _outToken(a1, *(char **)(a2 + 32), v36, v37, v38, v39, v40, v41);
    appendStringInfo((uint64_t)a1, ",", v42, v43, v44, v45, v46, v47, v94);
  }
  if (*(_DWORD *)(a2 + 40)) {
    appendStringInfo((uint64_t)a1, "\"firstColType\":%u,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 40));
  }
  if (*(_DWORD *)(a2 + 44)) {
    appendStringInfo((uint64_t)a1, "\"firstColTypmod\":%d,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 44));
  }
  if (*(_DWORD *)(a2 + 48)) {
    appendStringInfo((uint64_t)a1, "\"firstColCollation\":%u,", v12, v13, v14, v15, v16, v17, *(unsigned int *)(a2 + 48));
  }
  if (*(unsigned char *)(a2 + 52)) {
    appendStringInfo((uint64_t)a1, "\"useHashTable\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 53)) {
    appendStringInfo((uint64_t)a1, "\"unknownEqFalse\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 54)) {
    appendStringInfo((uint64_t)a1, "\"parallel_safe\":%s,", v12, v13, v14, v15, v16, v17, (size_t)"true");
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"setParam\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v54 = *(void *)(a2 + 56);
    if (v54 && *(int *)(v54 + 4) >= 1)
    {
      uint64_t v55 = 0;
      uint64_t v56 = 8;
      do
      {
        uint64_t v57 = *(void *)(v54 + 16);
        uint64_t v58 = *(void *)(v57 + 8 * v55);
        if (v58) {
          _outNode(a1, v58);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v57 + v56) {
          BOOL v59 = v57 + v56 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v59 = 1;
        }
        if (!v59) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v55;
        v56 += 8;
      }
      while (v55 < *(int *)(v54 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v48, v49, v50, v51, v52, v53, v95);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"parParam\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v66 = *(void *)(a2 + 64);
    if (v66 && *(int *)(v66 + 4) >= 1)
    {
      uint64_t v67 = 0;
      uint64_t v68 = 8;
      do
      {
        uint64_t v69 = *(void *)(v66 + 16);
        uint64_t v70 = *(void *)(v69 + 8 * v67);
        if (v70) {
          _outNode(a1, v70);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v69 + v68) {
          BOOL v71 = v69 + v68 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v71 = 1;
        }
        if (!v71) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v67;
        v68 += 8;
      }
      while (v67 < *(int *)(v66 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v60, v61, v62, v63, v64, v65, v96);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v12, v13, v14, v15, v16, v17, v91);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v78 = *(void *)(a2 + 72);
    if (v78 && *(int *)(v78 + 4) >= 1)
    {
      uint64_t v79 = 0;
      uint64_t v80 = 8;
      do
      {
        uint64_t v81 = *(void *)(v78 + 16);
        uint64_t v82 = *(void *)(v81 + 8 * v79);
        if (v82) {
          _outNode(a1, v82);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v81 + v80) {
          BOOL v83 = v81 + v80 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v83 = 1;
        }
        if (!v83) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v79;
        v80 += 8;
      }
      while (v79 < *(int *)(v78 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v72, v73, v74, v75, v76, v77, v97);
  }
  appendStringInfo((uint64_t)a1, "\"startup_cost\":%f,", v12, v13, v14, v15, v16, v17, *(void *)(a2 + 80));
  return appendStringInfo((uint64_t)a1, "\"per_call_cost\":%f,", v84, v85, v86, v87, v88, v89, *(void *)(a2 + 88));
}

unint64_t _outAlternativeSubPlan(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = result;
    appendStringInfo(result, "\"subplans\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

uint64_t _outFieldSelect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_WORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"fieldnum\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo(v9, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(_DWORD *)(a2 + 28)) {
    return appendStringInfo(v9, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  }
  return result;
}

uint64_t _outFieldStore(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v41);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"newvals\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(v9, 91);
    uint64_t v22 = *(void *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 8;
      do
      {
        uint64_t v25 = *(void *)(v22 + 16);
        uint64_t v26 = *(void *)(v25 + 8 * v23);
        if (v26) {
          _outNode(v9, v26);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v25 + v24) {
          BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v27 = 1;
        }
        if (!v27) {
          appendStringInfoString(v9, ",");
        }
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v42);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"fieldnums\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(v9, 91);
    uint64_t v34 = *(void *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      uint64_t v35 = 0;
      uint64_t v36 = 8;
      do
      {
        uint64_t v37 = *(void *)(v34 + 16);
        uint64_t v38 = *(void *)(v37 + 8 * v35);
        if (v38) {
          _outNode(v9, v38);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v37 + v36) {
          BOOL v39 = v37 + v36 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v39 = 1;
        }
        if (!v39) {
          appendStringInfoString(v9, ",");
        }
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v28, v29, v30, v31, v32, v33, v43);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(v9, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outRelabelType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  uint64_t v16 = *(int *)(a2 + 28);
  if (v16 > 2) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D90D0)[v16];
  }
  unint64_t result = appendStringInfo(a1, "\"relabelformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outCoerceViaIO(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  uint64_t v16 = *(int *)(a2 + 24);
  if (v16 > 2) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D90D0)[v16];
  }
  unint64_t result = appendStringInfo(a1, "\"coerceformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 28)) {
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 28));
  }
  return result;
}

unint64_t _outArrayCoerceExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v31);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v32);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"elemexpr\":", a3, a4, a5, a6, a7, a8, v31);
    _outNode(a1, *(void *)(a2 + 16));
    appendStringInfo(a1, ",", v16, v17, v18, v19, v20, v21, v33);
  }
  if (*(_DWORD *)(a2 + 24)) {
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(_DWORD *)(a2 + 28)) {
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  }
  if (*(_DWORD *)(a2 + 32)) {
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  uint64_t v22 = *(int *)(a2 + 36);
  if (v22 > 2) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (&off_1E55D90D0)[v22];
  }
  unint64_t result = appendStringInfo(a1, "\"coerceformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(a1, "\"location\":%d,", v25, v26, v27, v28, v29, v30, *(unsigned int *)(a2 + 40));
  }
  return result;
}

unint64_t _outConvertRowtypeExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  uint64_t v16 = *(int *)(a2 + 20);
  if (v16 > 2) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D90D0)[v16];
  }
  unint64_t result = appendStringInfo(a1, "\"convertformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outCollateExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"collOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

uint64_t _outCaseExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"casetype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"casecollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"arg\":", a3, a4, a5, a6, a7, a8, v34);
    _outNode(v9, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    uint64_t v22 = *(void *)(a2 + 24);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 8;
      do
      {
        uint64_t v25 = *(void *)(v22 + 16);
        uint64_t v26 = *(void *)(v25 + 8 * v23);
        if (v26) {
          _outNode(v9, v26);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v25 + v24) {
          BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v27 = 1;
        }
        if (!v27) {
          appendStringInfoString(v9, ",");
        }
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v36);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"defresult\":", a3, a4, a5, a6, a7, a8, v34);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo(v9, ",", v28, v29, v30, v31, v32, v33, v37);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  return result;
}

uint64_t _outCaseWhen(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v22);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"result\":", a3, a4, a5, a6, a7, a8, v22);
    _outNode(v9, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(v9, ",", v16, v17, v18, v19, v20, v21, v24);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outCaseTestExpr(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (a2[1]) {
    unint64_t result = appendStringInfo(result, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, a2[1]);
  }
  if (a2[2]) {
    unint64_t result = appendStringInfo(v9, "\"typeMod\":%d,", a3, a4, a5, a6, a7, a8, a2[2]);
  }
  if (a2[3]) {
    return appendStringInfo(v9, "\"collation\":%u,", a3, a4, a5, a6, a7, a8, a2[3]);
  }
  return result;
}

uint64_t _outArrayExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"array_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"array_collid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"element_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"elements\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"multidims\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 28)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 28));
  }
  return result;
}

unint64_t _outRowExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"args\":", a3, a4, a5, a6, a7, a8, v43);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v44);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"row_typeid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  uint64_t v22 = *(int *)(a2 + 20);
  if (v22 > 2) {
    size_t v23 = 0;
  }
  else {
    size_t v23 = (&off_1E55D90D0)[v22];
  }
  unint64_t result = appendStringInfo(a1, "\"row_format\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"colnames\":", v25, v26, v27, v28, v29, v30, v45);
    appendStringInfoChar(a1, 91);
    uint64_t v37 = *(void *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString(a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v46);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v25, v26, v27, v28, v29, v30, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outRowCompareExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  unsigned int v11 = *(_DWORD *)(a2 + 4) - 1;
  if (v11 > 5) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D8FB8)[v11];
  }
  unint64_t result = appendStringInfo(a1, "\"rctype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"opnos\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v26 = *(void *)(a2 + 8);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 8;
      do
      {
        uint64_t v29 = *(void *)(v26 + 16);
        uint64_t v30 = *(void *)(v29 + 8 * v27);
        if (v30) {
          _outNode(a1, v30);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v29 + v28) {
          BOOL v31 = v29 + v28 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v31 = 1;
        }
        if (!v31) {
          appendStringInfoString(a1, ",");
        }
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v81);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"opfamilies\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v38 = *(void *)(a2 + 16);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      uint64_t v39 = 0;
      uint64_t v40 = 8;
      do
      {
        uint64_t v41 = *(void *)(v38 + 16);
        uint64_t v42 = *(void *)(v41 + 8 * v39);
        if (v42) {
          _outNode(a1, v42);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v41 + v40) {
          BOOL v43 = v41 + v40 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v43 = 1;
        }
        if (!v43) {
          appendStringInfoString(a1, ",");
        }
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v82);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"inputcollids\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v50 = *(void *)(a2 + 24);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 8;
      do
      {
        uint64_t v53 = *(void *)(v50 + 16);
        uint64_t v54 = *(void *)(v53 + 8 * v51);
        if (v54) {
          _outNode(a1, v54);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v53 + v52) {
          BOOL v55 = v53 + v52 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString(a1, ",");
        }
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v83);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"largs\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v62 = *(void *)(a2 + 32);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      uint64_t v63 = 0;
      uint64_t v64 = 8;
      do
      {
        uint64_t v65 = *(void *)(v62 + 16);
        uint64_t v66 = *(void *)(v65 + 8 * v63);
        if (v66) {
          _outNode(a1, v66);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v65 + v64) {
          BOOL v67 = v65 + v64 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString(a1, ",");
        }
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, v84);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"rargs\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v74 = *(void *)(a2 + 40);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      uint64_t v75 = 0;
      uint64_t v76 = 8;
      do
      {
        uint64_t v77 = *(void *)(v74 + 16);
        uint64_t v78 = *(void *)(v77 + 8 * v75);
        if (v78) {
          _outNode(a1, v78);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v77 + v76) {
          BOOL v79 = v77 + v76 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v79 = 1;
        }
        if (!v79) {
          appendStringInfoString(a1, ",");
        }
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo(a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

uint64_t _outCoalesceExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"coalescetype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"coalescecollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

unint64_t _outMinMaxExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a2 + 4)) {
    appendStringInfo(a1, "\"minmaxtype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    appendStringInfo(a1, "\"minmaxcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    appendStringInfo(a1, "\"inputcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  int v10 = *(_DWORD *)(a2 + 16);
  uint64_t v11 = "IS_LEAST";
  if (v10 != 1) {
    uint64_t v11 = 0;
  }
  if (v10) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = "IS_GREATEST";
  }
  unint64_t result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"args\":", v14, v15, v16, v17, v18, v19, v32);
    appendStringInfoChar(a1, 91);
    uint64_t v26 = *(void *)(a2 + 24);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 8;
      do
      {
        uint64_t v29 = *(void *)(v26 + 16);
        uint64_t v30 = *(void *)(v29 + 8 * v27);
        if (v30) {
          _outNode(a1, v30);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v29 + v28) {
          BOOL v31 = v29 + v28 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v31 = 1;
        }
        if (!v31) {
          appendStringInfoString(a1, ",");
        }
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v33);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outSQLValueFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0xE) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D8FE8)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"type\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(a1, "\"typmod\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  return result;
}

unint64_t _outXmlExpr(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 7) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9060)[v10];
  }
  appendStringInfo((uint64_t)a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v12, v13, v14, v15, v16, v17, v76);
    _outToken(a1, *(char **)(a2 + 8), v18, v19, v20, v21, v22, v23);
    appendStringInfo((uint64_t)a1, ",", v24, v25, v26, v27, v28, v29, v77);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"named_args\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v36 = *(void *)(a2 + 16);
    if (v36 && *(int *)(v36 + 4) >= 1)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 8;
      do
      {
        uint64_t v39 = *(void *)(v36 + 16);
        uint64_t v40 = *(void *)(v39 + 8 * v37);
        if (v40) {
          _outNode(a1, v40);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v39 + v38) {
          BOOL v41 = v39 + v38 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v41 = 1;
        }
        if (!v41) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v37;
        v38 += 8;
      }
      while (v37 < *(int *)(v36 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v30, v31, v32, v33, v34, v35, v78);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"arg_names\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v48 = *(void *)(a2 + 24);
    if (v48 && *(int *)(v48 + 4) >= 1)
    {
      uint64_t v49 = 0;
      uint64_t v50 = 8;
      do
      {
        uint64_t v51 = *(void *)(v48 + 16);
        uint64_t v52 = *(void *)(v51 + 8 * v49);
        if (v52) {
          _outNode(a1, v52);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v51 + v50) {
          BOOL v53 = v51 + v50 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v53 = 1;
        }
        if (!v53) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v49;
        v50 += 8;
      }
      while (v49 < *(int *)(v48 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v42, v43, v44, v45, v46, v47, v79);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v12, v13, v14, v15, v16, v17, v76);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v60 = *(void *)(a2 + 32);
    if (v60 && *(int *)(v60 + 4) >= 1)
    {
      uint64_t v61 = 0;
      uint64_t v62 = 8;
      do
      {
        uint64_t v63 = *(void *)(v60 + 16);
        uint64_t v64 = *(void *)(v63 + 8 * v61);
        if (v64) {
          _outNode(a1, v64);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v63 + v62) {
          BOOL v65 = v63 + v62 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v65 = 1;
        }
        if (!v65) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v61;
        v62 += 8;
      }
      while (v61 < *(int *)(v60 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v54, v55, v56, v57, v58, v59, v80);
  }
  int v66 = *(_DWORD *)(a2 + 40);
  BOOL v67 = "XMLOPTION_CONTENT";
  if (v66 != 1) {
    BOOL v67 = 0;
  }
  if (v66) {
    uint64_t v68 = v67;
  }
  else {
    uint64_t v68 = "XMLOPTION_DOCUMENT";
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"xmloption\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v68);
  if (*(_DWORD *)(a2 + 44)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"type\":%u,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 44));
  }
  if (*(_DWORD *)(a2 + 48)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"typmod\":%d,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 48));
  }
  if (*(_DWORD *)(a2 + 52)) {
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v70, v71, v72, v73, v74, v75, *(unsigned int *)(a2 + 52));
  }
  return result;
}

unint64_t _outNullTest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v26);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v27);
  }
  int v16 = *(_DWORD *)(a2 + 16);
  uint64_t v17 = "IS_NOT_NULL";
  if (v16 != 1) {
    uint64_t v17 = 0;
  }
  if (v16) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = "IS_NULL";
  }
  unint64_t result = appendStringInfo(a1, "\"nulltesttype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v18);
  if (*(unsigned char *)(a2 + 20)) {
    unint64_t result = appendStringInfo(a1, "\"argisrow\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(a1, "\"location\":%d,", v20, v21, v22, v23, v24, v25, *(unsigned int *)(a2 + 24));
  }
  return result;
}

unint64_t _outBooleanTest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  uint64_t v16 = *(int *)(a2 + 16);
  if (v16 > 5) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D90A0)[v16];
  }
  unint64_t result = appendStringInfo(a1, "\"BOOLtesttype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 20));
  }
  return result;
}

unint64_t _outCoerceToDomain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v25);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v26);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"resulttype\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    appendStringInfo(a1, "\"resulttypmod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  if (*(_DWORD *)(a2 + 24)) {
    appendStringInfo(a1, "\"resultcollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  uint64_t v16 = *(int *)(a2 + 28);
  if (v16 > 2) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D90D0)[v16];
  }
  unint64_t result = appendStringInfo(a1, "\"coercionformat\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v19, v20, v21, v22, v23, v24, *(unsigned int *)(a2 + 32));
  }
  return result;
}

uint64_t _outCoerceToDomainValue(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (a2[1]) {
    unint64_t result = appendStringInfo(result, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, a2[1]);
  }
  if (a2[2]) {
    unint64_t result = appendStringInfo(v9, "\"typeMod\":%d,", a3, a4, a5, a6, a7, a8, a2[2]);
  }
  if (a2[3]) {
    unint64_t result = appendStringInfo(v9, "\"collation\":%u,", a3, a4, a5, a6, a7, a8, a2[3]);
  }
  if (a2[4]) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, a2[4]);
  }
  return result;
}

uint64_t _outCurrentOfExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"cvarno\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v9, "\"cursor_name\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo((uint64_t)v9, "\"cursor_param\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outNextValueExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"seqid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    return appendStringInfo(v9, "\"typeId\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  return result;
}

uint64_t _outInferenceElem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"infercollid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"inferopclass\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

uint64_t _outTargetEntry(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"expr\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(_WORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"resno\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"resname\":", a3, a4, a5, a6, a7, a8, v28);
    _outToken(v9, *(char **)(a2 + 24), v16, v17, v18, v19, v20, v21);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v30);
  }
  if (*(_DWORD *)(a2 + 32)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"ressortgroupref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  if (*(_DWORD *)(a2 + 36)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"resorigtbl\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 36));
  }
  if (*(_WORD *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"resorigcol\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 40));
  }
  if (*(unsigned char *)(a2 + 42)) {
    return appendStringInfo((uint64_t)v9, "\"resjunk\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outJoinExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 7) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D98A0)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"jointype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(unsigned char *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"isNatural\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"larg\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v66);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rarg\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo(a1, ",", v25, v26, v27, v28, v29, v30, v67);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"usingClause\":", v13, v14, v15, v16, v17, v18, v65);
    appendStringInfoChar(a1, 91);
    uint64_t v37 = *(void *)(a2 + 32);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString(a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v68);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"quals\":", v13, v14, v15, v16, v17, v18, v65);
    _outNode(a1, *(void *)(a2 + 40));
    unint64_t result = appendStringInfo(a1, ",", v43, v44, v45, v46, v47, v48, v69);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"alias\":{", v13, v14, v15, v16, v17, v18, v65);
    _outAlias(a1, *(void *)(a2 + 48), v49, v50, v51, v52, v53, v54, v70);
    int v61 = *(_DWORD *)(a1 + 8);
    BOOL v62 = __OFSUB__(v61, 1);
    uint64_t v63 = (v61 - 1);
    if ((int)v63 < 0 == v62)
    {
      uint64_t v64 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v63) == 44)
      {
        *(_DWORD *)(a1 + 8) = v63;
        *(unsigned char *)(v64 + v63) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "},", v55, v56, v57, v58, v59, v60, v71);
  }
  if (*(_DWORD *)(a2 + 56)) {
    return appendStringInfo(a1, "\"rtindex\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 56));
  }
  return result;
}

uint64_t _outFromExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"fromlist\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"quals\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(void *)(a2 + 16));
    return appendStringInfo(v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outOnConflictExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 2) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9968)[v11];
  }
  unint64_t result = appendStringInfo(a1, "\"action\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"arbiterElems\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    uint64_t v26 = *(void *)(a2 + 8);
    if (v26 && *(int *)(v26 + 4) >= 1)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 8;
      do
      {
        uint64_t v29 = *(void *)(v26 + 16);
        uint64_t v30 = *(void *)(v29 + 8 * v27);
        if (v30) {
          _outNode(a1, v30);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v29 + v28) {
          BOOL v31 = v29 + v28 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v31 = 1;
        }
        if (!v31) {
          appendStringInfoString(a1, ",");
        }
        ++v27;
        v28 += 8;
      }
      while (v27 < *(int *)(v26 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v20, v21, v22, v23, v24, v25, v69);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"arbiterWhere\":", v14, v15, v16, v17, v18, v19, v68);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v32, v33, v34, v35, v36, v37, v70);
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(a1, "\"constraint\":%u,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 24));
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"onConflictSet\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    uint64_t v44 = *(void *)(a2 + 32);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      uint64_t v45 = 0;
      uint64_t v46 = 8;
      do
      {
        uint64_t v47 = *(void *)(v44 + 16);
        uint64_t v48 = *(void *)(v47 + 8 * v45);
        if (v48) {
          _outNode(a1, v48);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v47 + v46) {
          BOOL v49 = v47 + v46 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v49 = 1;
        }
        if (!v49) {
          appendStringInfoString(a1, ",");
        }
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v38, v39, v40, v41, v42, v43, v71);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"onConflictWhere\":", v14, v15, v16, v17, v18, v19, v68);
    _outNode(a1, *(void *)(a2 + 40));
    unint64_t result = appendStringInfo(a1, ",", v50, v51, v52, v53, v54, v55, v72);
  }
  if (*(_DWORD *)(a2 + 48)) {
    unint64_t result = appendStringInfo(a1, "\"exclRelIndex\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 48));
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo(a1, "\"exclRelTlist\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar(a1, 91);
    uint64_t v62 = *(void *)(a2 + 56);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      uint64_t v63 = 0;
      uint64_t v64 = 8;
      do
      {
        uint64_t v65 = *(void *)(v62 + 16);
        uint64_t v66 = *(void *)(v65 + 8 * v63);
        if (v66) {
          _outNode(a1, v66);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v65 + v64) {
          BOOL v67 = v65 + v64 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString(a1, ",");
        }
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    return appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, a9);
  }
  return result;
}

unint64_t _outIntoClause(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"rel\":{", a3, a4, a5, a6, a7, a8, v89);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = a1[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v90);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"colNames\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v26, v27, v28, v29, v30, v31, v91);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"accessMethod\":", a3, a4, a5, a6, a7, a8, v89);
    _outToken(a1, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, v92);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v56 = *(void *)(a2 + 32);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 8;
      do
      {
        uint64_t v59 = *(void *)(v56 + 16);
        uint64_t v60 = *(void *)(v59 + 8 * v57);
        if (v60) {
          _outNode(a1, v60);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v59 + v58) {
          BOOL v61 = v59 + v58 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v61 = 1;
        }
        if (!v61) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v50, v51, v52, v53, v54, v55, v93);
  }
  uint64_t v62 = *(int *)(a2 + 40);
  if (v62 > 3) {
    uint64_t v63 = 0;
  }
  else {
    uint64_t v63 = (&off_1E55D9390)[v62];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"onCommit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v63);
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"tableSpaceName\":", v65, v66, v67, v68, v69, v70, v94);
    _outToken(a1, *(char **)(a2 + 48), v71, v72, v73, v74, v75, v76);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v77, v78, v79, v80, v81, v82, v95);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"viewQuery\":", v65, v66, v67, v68, v69, v70, v94);
    _outNode(a1, *(void *)(a2 + 56));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v83, v84, v85, v86, v87, v88, v96);
  }
  if (*(unsigned char *)(a2 + 64)) {
    return appendStringInfo((uint64_t)a1, "\"skipData\":%s,", v65, v66, v67, v68, v69, v70, (size_t)"true");
  }
  return result;
}

unint64_t _outQuery(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 6) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D93D0)[v10];
  }
  appendStringInfo(a1, "\"commandType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  uint64_t v18 = *(int *)(a2 + 8);
  if (v18 > 4) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (&off_1E55D90E8)[v18];
  }
  appendStringInfo(a1, "\"querySource\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(unsigned char *)(a2 + 24)) {
    appendStringInfo(a1, "\"canSetTag\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"utilityStmt\":", v20, v21, v22, v23, v24, v25, v248);
    _outNode(a1, *(void *)(a2 + 32));
    appendStringInfo(a1, ",", v26, v27, v28, v29, v30, v31, v249);
  }
  if (*(_DWORD *)(a2 + 40)) {
    appendStringInfo(a1, "\"resultRelation\":%d,", v20, v21, v22, v23, v24, v25, *(unsigned int *)(a2 + 40));
  }
  if (*(unsigned char *)(a2 + 44)) {
    appendStringInfo(a1, "\"hasAggs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 45)) {
    appendStringInfo(a1, "\"hasWindowFuncs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 46)) {
    appendStringInfo(a1, "\"hasTargetSRFs\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 47)) {
    appendStringInfo(a1, "\"hasSubLinks\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 48)) {
    appendStringInfo(a1, "\"hasDistinctOn\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 49)) {
    appendStringInfo(a1, "\"hasRecursive\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 50)) {
    appendStringInfo(a1, "\"hasModifyingCTE\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 51)) {
    appendStringInfo(a1, "\"hasForUpdate\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 52)) {
    appendStringInfo(a1, "\"hasRowSecurity\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo(a1, "\"cteList\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    uint64_t v38 = *(void *)(a2 + 56);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      uint64_t v39 = 0;
      uint64_t v40 = 8;
      do
      {
        uint64_t v41 = *(void *)(v38 + 16);
        uint64_t v42 = *(void *)(v41 + 8 * v39);
        if (v42) {
          _outNode(a1, v42);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v41 + v40) {
          BOOL v43 = v41 + v40 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v43 = 1;
        }
        if (!v43) {
          appendStringInfoString(a1, ",");
        }
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v250);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo(a1, "\"rtable\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    uint64_t v50 = *(void *)(a2 + 64);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 8;
      do
      {
        uint64_t v53 = *(void *)(v50 + 16);
        uint64_t v54 = *(void *)(v53 + 8 * v51);
        if (v54) {
          _outNode(a1, v54);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v53 + v52) {
          BOOL v55 = v53 + v52 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString(a1, ",");
        }
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v251);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo(a1, "\"jointree\":{", v20, v21, v22, v23, v24, v25, v248);
    _outFromExpr(a1, *(void *)(a2 + 72), v56, v57, v58, v59, v60, v61, v252);
    int v68 = *(_DWORD *)(a1 + 8);
    BOOL v69 = __OFSUB__(v68, 1);
    uint64_t v70 = (v68 - 1);
    if ((int)v70 < 0 == v69)
    {
      uint64_t v71 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v70) == 44)
      {
        *(_DWORD *)(a1 + 8) = v70;
        *(unsigned char *)(v71 + v7errstart(20, 0) = 0;
      }
    }
    appendStringInfo(a1, "},", v62, v63, v64, v65, v66, v67, v253);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo(a1, "\"targetList\":", v20, v21, v22, v23, v24, v25, v248);
    appendStringInfoChar(a1, 91);
    uint64_t v78 = *(void *)(a2 + 80);
    if (v78 && *(int *)(v78 + 4) >= 1)
    {
      uint64_t v79 = 0;
      uint64_t v80 = 8;
      do
      {
        uint64_t v81 = *(void *)(v78 + 16);
        uint64_t v82 = *(void *)(v81 + 8 * v79);
        if (v82) {
          _outNode(a1, v82);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v81 + v80) {
          BOOL v83 = v81 + v80 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v83 = 1;
        }
        if (!v83) {
          appendStringInfoString(a1, ",");
        }
        ++v79;
        v80 += 8;
      }
      while (v79 < *(int *)(v78 + 4));
    }
    appendStringInfo(a1, "],", v72, v73, v74, v75, v76, v77, v254);
  }
  uint64_t v84 = *(int *)(a2 + 88);
  if (v84 > 2) {
    uint64_t v85 = 0;
  }
  else {
    uint64_t v85 = (&off_1E55D9110)[v84];
  }
  appendStringInfo(a1, "\"override\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v85);
  if (*(void *)(a2 + 96))
  {
    appendStringInfo(a1, "\"onConflict\":{", v86, v87, v88, v89, v90, v91, v255);
    _outOnConflictExpr(a1, *(void *)(a2 + 96), v92, v93, v94, v95, v96, v97, v256);
    int v104 = *(_DWORD *)(a1 + 8);
    BOOL v69 = __OFSUB__(v104, 1);
    uint64_t v105 = (v104 - 1);
    if ((int)v105 < 0 == v69)
    {
      uint64_t v106 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v105) == 44)
      {
        *(_DWORD *)(a1 + 8) = v105;
        *(unsigned char *)(v106 + v105) = 0;
      }
    }
    appendStringInfo(a1, "},", v98, v99, v100, v101, v102, v103, v257);
  }
  if (*(void *)(a2 + 104))
  {
    appendStringInfo(a1, "\"returningList\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v113 = *(void *)(a2 + 104);
    if (v113 && *(int *)(v113 + 4) >= 1)
    {
      uint64_t v114 = 0;
      uint64_t v115 = 8;
      do
      {
        uint64_t v116 = *(void *)(v113 + 16);
        uint64_t v117 = *(void *)(v116 + 8 * v114);
        if (v117) {
          _outNode(a1, v117);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v116 + v115) {
          BOOL v118 = v116 + v115 >= (unint64_t)(*(void *)(*(void *)(a2 + 104) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 104) + 4));
        else {
          BOOL v118 = 1;
        }
        if (!v118) {
          appendStringInfoString(a1, ",");
        }
        ++v114;
        v115 += 8;
      }
      while (v114 < *(int *)(v113 + 4));
    }
    appendStringInfo(a1, "],", v107, v108, v109, v110, v111, v112, v258);
  }
  if (*(void *)(a2 + 112))
  {
    appendStringInfo(a1, "\"groupClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v125 = *(void *)(a2 + 112);
    if (v125 && *(int *)(v125 + 4) >= 1)
    {
      uint64_t v126 = 0;
      uint64_t v127 = 8;
      do
      {
        uint64_t v128 = *(void *)(v125 + 16);
        uint64_t v129 = *(void *)(v128 + 8 * v126);
        if (v129) {
          _outNode(a1, v129);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v128 + v127) {
          BOOL v130 = v128 + v127 >= (unint64_t)(*(void *)(*(void *)(a2 + 112) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 112) + 4));
        else {
          BOOL v130 = 1;
        }
        if (!v130) {
          appendStringInfoString(a1, ",");
        }
        ++v126;
        v127 += 8;
      }
      while (v126 < *(int *)(v125 + 4));
    }
    appendStringInfo(a1, "],", v119, v120, v121, v122, v123, v124, v259);
  }
  if (*(void *)(a2 + 120))
  {
    appendStringInfo(a1, "\"groupingSets\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v137 = *(void *)(a2 + 120);
    if (v137 && *(int *)(v137 + 4) >= 1)
    {
      uint64_t v138 = 0;
      uint64_t v139 = 8;
      do
      {
        uint64_t v140 = *(void *)(v137 + 16);
        uint64_t v141 = *(void *)(v140 + 8 * v138);
        if (v141) {
          _outNode(a1, v141);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v140 + v139) {
          BOOL v142 = v140 + v139 >= (unint64_t)(*(void *)(*(void *)(a2 + 120) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 120) + 4));
        else {
          BOOL v142 = 1;
        }
        if (!v142) {
          appendStringInfoString(a1, ",");
        }
        ++v138;
        v139 += 8;
      }
      while (v138 < *(int *)(v137 + 4));
    }
    appendStringInfo(a1, "],", v131, v132, v133, v134, v135, v136, v260);
  }
  if (*(void *)(a2 + 128))
  {
    appendStringInfo(a1, "\"havingQual\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(void *)(a2 + 128));
    appendStringInfo(a1, ",", v143, v144, v145, v146, v147, v148, v261);
  }
  if (*(void *)(a2 + 136))
  {
    appendStringInfo(a1, "\"windowClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v155 = *(void *)(a2 + 136);
    if (v155 && *(int *)(v155 + 4) >= 1)
    {
      uint64_t v156 = 0;
      uint64_t v157 = 8;
      do
      {
        uint64_t v158 = *(void *)(v155 + 16);
        uint64_t v159 = *(void *)(v158 + 8 * v156);
        if (v159) {
          _outNode(a1, v159);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v158 + v157) {
          BOOL v160 = v158 + v157 >= (unint64_t)(*(void *)(*(void *)(a2 + 136) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 136) + 4));
        else {
          BOOL v160 = 1;
        }
        if (!v160) {
          appendStringInfoString(a1, ",");
        }
        ++v156;
        v157 += 8;
      }
      while (v156 < *(int *)(v155 + 4));
    }
    appendStringInfo(a1, "],", v149, v150, v151, v152, v153, v154, v262);
  }
  if (*(void *)(a2 + 144))
  {
    appendStringInfo(a1, "\"distinctClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v167 = *(void *)(a2 + 144);
    if (v167 && *(int *)(v167 + 4) >= 1)
    {
      uint64_t v168 = 0;
      uint64_t v169 = 8;
      do
      {
        uint64_t v170 = *(void *)(v167 + 16);
        uint64_t v171 = *(void *)(v170 + 8 * v168);
        if (v171) {
          _outNode(a1, v171);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v170 + v169) {
          BOOL v172 = v170 + v169 >= (unint64_t)(*(void *)(*(void *)(a2 + 144) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 144) + 4));
        else {
          BOOL v172 = 1;
        }
        if (!v172) {
          appendStringInfoString(a1, ",");
        }
        ++v168;
        v169 += 8;
      }
      while (v168 < *(int *)(v167 + 4));
    }
    appendStringInfo(a1, "],", v161, v162, v163, v164, v165, v166, v263);
  }
  if (*(void *)(a2 + 152))
  {
    appendStringInfo(a1, "\"sortClause\":", v86, v87, v88, v89, v90, v91, v255);
    appendStringInfoChar(a1, 91);
    uint64_t v179 = *(void *)(a2 + 152);
    if (v179 && *(int *)(v179 + 4) >= 1)
    {
      uint64_t v180 = 0;
      uint64_t v181 = 8;
      do
      {
        uint64_t v182 = *(void *)(v179 + 16);
        uint64_t v183 = *(void *)(v182 + 8 * v180);
        if (v183) {
          _outNode(a1, v183);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v182 + v181) {
          BOOL v184 = v182 + v181 >= (unint64_t)(*(void *)(*(void *)(a2 + 152) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 152) + 4));
        else {
          BOOL v184 = 1;
        }
        if (!v184) {
          appendStringInfoString(a1, ",");
        }
        ++v180;
        v181 += 8;
      }
      while (v180 < *(int *)(v179 + 4));
    }
    appendStringInfo(a1, "],", v173, v174, v175, v176, v177, v178, v264);
  }
  if (*(void *)(a2 + 160))
  {
    appendStringInfo(a1, "\"limitOffset\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(void *)(a2 + 160));
    appendStringInfo(a1, ",", v185, v186, v187, v188, v189, v190, v265);
  }
  if (*(void *)(a2 + 168))
  {
    appendStringInfo(a1, "\"limitCount\":", v86, v87, v88, v89, v90, v91, v255);
    _outNode(a1, *(void *)(a2 + 168));
    appendStringInfo(a1, ",", v191, v192, v193, v194, v195, v196, v266);
  }
  uint64_t v197 = *(int *)(a2 + 176);
  if (v197 > 2) {
    uint64_t v198 = 0;
  }
  else {
    uint64_t v198 = (&off_1E55D9128)[v197];
  }
  unint64_t result = appendStringInfo(a1, "\"limitOption\":\"%s\",", v86, v87, v88, v89, v90, v91, (size_t)v198);
  if (*(void *)(a2 + 184))
  {
    appendStringInfo(a1, "\"rowMarks\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    uint64_t v212 = *(void *)(a2 + 184);
    if (v212 && *(int *)(v212 + 4) >= 1)
    {
      uint64_t v213 = 0;
      uint64_t v214 = 8;
      do
      {
        uint64_t v215 = *(void *)(v212 + 16);
        uint64_t v216 = *(void *)(v215 + 8 * v213);
        if (v216) {
          _outNode(a1, v216);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v215 + v214) {
          BOOL v217 = v215 + v214 >= (unint64_t)(*(void *)(*(void *)(a2 + 184) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 184) + 4));
        else {
          BOOL v217 = 1;
        }
        if (!v217) {
          appendStringInfoString(a1, ",");
        }
        ++v213;
        v214 += 8;
      }
      while (v213 < *(int *)(v212 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v206, v207, v208, v209, v210, v211, v268);
  }
  if (*(void *)(a2 + 192))
  {
    appendStringInfo(a1, "\"setOperations\":", v200, v201, v202, v203, v204, v205, v267);
    _outNode(a1, *(void *)(a2 + 192));
    unint64_t result = appendStringInfo(a1, ",", v218, v219, v220, v221, v222, v223, v269);
  }
  if (*(void *)(a2 + 200))
  {
    appendStringInfo(a1, "\"constraintDeps\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    uint64_t v230 = *(void *)(a2 + 200);
    if (v230 && *(int *)(v230 + 4) >= 1)
    {
      uint64_t v231 = 0;
      uint64_t v232 = 8;
      do
      {
        uint64_t v233 = *(void *)(v230 + 16);
        uint64_t v234 = *(void *)(v233 + 8 * v231);
        if (v234) {
          _outNode(a1, v234);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v233 + v232) {
          BOOL v235 = v233 + v232 >= (unint64_t)(*(void *)(*(void *)(a2 + 200) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 200) + 4));
        else {
          BOOL v235 = 1;
        }
        if (!v235) {
          appendStringInfoString(a1, ",");
        }
        ++v231;
        v232 += 8;
      }
      while (v231 < *(int *)(v230 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v224, v225, v226, v227, v228, v229, v270);
  }
  if (*(void *)(a2 + 208))
  {
    appendStringInfo(a1, "\"withCheckOptions\":", v200, v201, v202, v203, v204, v205, v267);
    appendStringInfoChar(a1, 91);
    uint64_t v242 = *(void *)(a2 + 208);
    if (v242 && *(int *)(v242 + 4) >= 1)
    {
      uint64_t v243 = 0;
      uint64_t v244 = 8;
      do
      {
        uint64_t v245 = *(void *)(v242 + 16);
        uint64_t v246 = *(void *)(v245 + 8 * v243);
        if (v246) {
          _outNode(a1, v246);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v245 + v244) {
          BOOL v247 = v245 + v244 >= (unint64_t)(*(void *)(*(void *)(a2 + 208) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 208) + 4));
        else {
          BOOL v247 = 1;
        }
        if (!v247) {
          appendStringInfoString(a1, ",");
        }
        ++v243;
        v244 += 8;
      }
      while (v243 < *(int *)(v242 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v236, v237, v238, v239, v240, v241, v271);
  }
  if (*(_DWORD *)(a2 + 216)) {
    unint64_t result = appendStringInfo(a1, "\"stmt_location\":%d,", v200, v201, v202, v203, v204, v205, *(unsigned int *)(a2 + 216));
  }
  if (*(_DWORD *)(a2 + 220)) {
    return appendStringInfo(a1, "\"stmt_len\":%d,", v200, v201, v202, v203, v204, v205, *(unsigned int *)(a2 + 220));
  }
  return result;
}

unint64_t _outInsertStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v89);
    _outRangeVar(a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v90);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"cols\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar(a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v91);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"selectStmt\":", a3, a4, a5, a6, a7, a8, v89);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo(a1, ",", v38, v39, v40, v41, v42, v43, v92);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"onConflictClause\":{", a3, a4, a5, a6, a7, a8, v89);
    _outOnConflictClause(a1, *(void *)(a2 + 32), v44, v45, v46, v47, v48, v49);
    int v56 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v56, 1);
    uint64_t v57 = (v56 - 1);
    if ((int)v57 < 0 == v23)
    {
      uint64_t v58 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v57) == 44)
      {
        *(_DWORD *)(a1 + 8) = v57;
        *(unsigned char *)(v58 + v57) = 0;
      }
    }
    appendStringInfo(a1, "},", v50, v51, v52, v53, v54, v55, v93);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"returningList\":", a3, a4, a5, a6, a7, a8, v89);
    appendStringInfoChar(a1, 91);
    uint64_t v65 = *(void *)(a2 + 40);
    if (v65 && *(int *)(v65 + 4) >= 1)
    {
      uint64_t v66 = 0;
      uint64_t v67 = 8;
      do
      {
        uint64_t v68 = *(void *)(v65 + 16);
        uint64_t v69 = *(void *)(v68 + 8 * v66);
        if (v69) {
          _outNode(a1, v69);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v68 + v67) {
          BOOL v70 = v68 + v67 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v70 = 1;
        }
        if (!v70) {
          appendStringInfoString(a1, ",");
        }
        ++v66;
        v67 += 8;
      }
      while (v66 < *(int *)(v65 + 4));
    }
    appendStringInfo(a1, "],", v59, v60, v61, v62, v63, v64, v94);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v89);
    _outWithClause(a1, *(void *)(a2 + 48), v71, v72, v73, v74, v75, v76);
    int v83 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v83, 1);
    uint64_t v84 = (v83 - 1);
    if ((int)v84 < 0 == v23)
    {
      uint64_t v85 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v84) == 44)
      {
        *(_DWORD *)(a1 + 8) = v84;
        *(unsigned char *)(v85 + v84) = 0;
      }
    }
    appendStringInfo(a1, "},", v77, v78, v79, v80, v81, v82, v95);
  }
  uint64_t v86 = *(int *)(a2 + 56);
  if (v86 > 2) {
    uint64_t v87 = 0;
  }
  else {
    uint64_t v87 = (&off_1E55D9110)[v86];
  }
  return appendStringInfo(a1, "\"override\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v87);
}

uint64_t _outDeleteStmt(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v72);
    _outRangeVar(v10, a2[1], v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v73);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"usingClause\":", a3, a4, a5, a6, a7, a8, v72);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = a2[2];
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(a2[2] + 16) + 8 * *(int *)(a2[2] + 4));
        }
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v74);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v72);
    _outNode(v10, a2[3]);
    unint64_t result = appendStringInfo(v10, ",", v39, v40, v41, v42, v43, v44, v75);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"returningList\":", a3, a4, a5, a6, a7, a8, v72);
    appendStringInfoChar(v10, 91);
    uint64_t v51 = a2[4];
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      uint64_t v52 = 0;
      uint64_t v53 = 8;
      do
      {
        uint64_t v54 = *(void *)(v51 + 16);
        uint64_t v55 = *(void *)(v54 + 8 * v52);
        if (v55) {
          _outNode(v10, v55);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v54 + v53) {
          BOOL v56 = v54 + v53 >= (unint64_t)(*(void *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        }
        else {
          BOOL v56 = 1;
        }
        if (!v56) {
          appendStringInfoString(v10, ",");
        }
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v45, v46, v47, v48, v49, v50, v76);
  }
  if (a2[5])
  {
    appendStringInfo(v10, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v72);
    _outWithClause(v10, a2[5], v57, v58, v59, v60, v61, v62);
    int v69 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v69, 1);
    uint64_t v70 = (v69 - 1);
    if ((int)v70 < 0 == v24)
    {
      uint64_t v71 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v70) == 44)
      {
        *(_DWORD *)(v10 + 8) = v70;
        *(unsigned char *)(v71 + v7errstart(20, 0) = 0;
      }
    }
    return appendStringInfo(v10, "},", v63, v64, v65, v66, v67, v68, a9);
  }
  return result;
}

uint64_t _outUpdateStmt(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v84);
    _outRangeVar(v10, a2[1], v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v85);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"targetList\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = a2[2];
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(a2[2] + 16) + 8 * *(int *)(a2[2] + 4));
        }
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v86);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v84);
    _outNode(v10, a2[3]);
    unint64_t result = appendStringInfo(v10, ",", v39, v40, v41, v42, v43, v44, v87);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"fromClause\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    uint64_t v51 = a2[4];
    if (v51 && *(int *)(v51 + 4) >= 1)
    {
      uint64_t v52 = 0;
      uint64_t v53 = 8;
      do
      {
        uint64_t v54 = *(void *)(v51 + 16);
        uint64_t v55 = *(void *)(v54 + 8 * v52);
        if (v55) {
          _outNode(v10, v55);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v54 + v53) {
          BOOL v56 = v54 + v53 >= (unint64_t)(*(void *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        }
        else {
          BOOL v56 = 1;
        }
        if (!v56) {
          appendStringInfoString(v10, ",");
        }
        ++v52;
        v53 += 8;
      }
      while (v52 < *(int *)(v51 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v45, v46, v47, v48, v49, v50, v88);
  }
  if (a2[5])
  {
    appendStringInfo(v10, "\"returningList\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(v10, 91);
    uint64_t v63 = a2[5];
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      uint64_t v64 = 0;
      uint64_t v65 = 8;
      do
      {
        uint64_t v66 = *(void *)(v63 + 16);
        uint64_t v67 = *(void *)(v66 + 8 * v64);
        if (v67) {
          _outNode(v10, v67);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v66 + v65) {
          BOOL v68 = v66 + v65 >= (unint64_t)(*(void *)(a2[5] + 16) + 8 * *(int *)(a2[5] + 4));
        }
        else {
          BOOL v68 = 1;
        }
        if (!v68) {
          appendStringInfoString(v10, ",");
        }
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v57, v58, v59, v60, v61, v62, v89);
  }
  if (a2[6])
  {
    appendStringInfo(v10, "\"withClause\":{", a3, a4, a5, a6, a7, a8, v84);
    _outWithClause(v10, a2[6], v69, v70, v71, v72, v73, v74);
    int v81 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v81, 1);
    uint64_t v82 = (v81 - 1);
    if ((int)v82 < 0 == v24)
    {
      uint64_t v83 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v82) == 44)
      {
        *(_DWORD *)(v10 + 8) = v82;
        *(unsigned char *)(v83 + v82) = 0;
      }
    }
    return appendStringInfo(v10, "},", v75, v76, v77, v78, v79, v80, a9);
  }
  return result;
}

unint64_t _outSelectStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"distinctClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(a1, v21);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v11, v12, v13, v14, v15, v16, v198);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"intoClause\":{", a3, a4, a5, a6, a7, a8, v197);
    _outIntoClause(a1, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = a1[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v37) == 44)
      {
        a1[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v29, v30, v31, v32, v33, v34, v199);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"targetList\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v45 = *(void *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(a1, v49);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v39, v40, v41, v42, v43, v44, v200);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"fromClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v57 = *(void *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 8;
      do
      {
        uint64_t v60 = *(void *)(v57 + 16);
        uint64_t v61 = *(void *)(v60 + 8 * v58);
        if (v61) {
          _outNode(a1, v61);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v60 + v59) {
          BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v62 = 1;
        }
        if (!v62) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v51, v52, v53, v54, v55, v56, v201);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(void *)(a2 + 40));
    appendStringInfo((uint64_t)a1, ",", v63, v64, v65, v66, v67, v68, v202);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"groupClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v75 = *(void *)(a2 + 48);
    if (v75 && *(int *)(v75 + 4) >= 1)
    {
      uint64_t v76 = 0;
      uint64_t v77 = 8;
      do
      {
        uint64_t v78 = *(void *)(v75 + 16);
        uint64_t v79 = *(void *)(v78 + 8 * v76);
        if (v79) {
          _outNode(a1, v79);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v78 + v77) {
          BOOL v80 = v78 + v77 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v80 = 1;
        }
        if (!v80) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v76;
        v77 += 8;
      }
      while (v76 < *(int *)(v75 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v69, v70, v71, v72, v73, v74, v203);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"havingClause\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(void *)(a2 + 56));
    appendStringInfo((uint64_t)a1, ",", v81, v82, v83, v84, v85, v86, v204);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"windowClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v93 = *(void *)(a2 + 64);
    if (v93 && *(int *)(v93 + 4) >= 1)
    {
      uint64_t v94 = 0;
      uint64_t v95 = 8;
      do
      {
        uint64_t v96 = *(void *)(v93 + 16);
        uint64_t v97 = *(void *)(v96 + 8 * v94);
        if (v97) {
          _outNode(a1, v97);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v96 + v95) {
          BOOL v98 = v96 + v95 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v98 = 1;
        }
        if (!v98) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v94;
        v95 += 8;
      }
      while (v94 < *(int *)(v93 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v87, v88, v89, v90, v91, v92, v205);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"valuesLists\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v105 = *(void *)(a2 + 72);
    if (v105 && *(int *)(v105 + 4) >= 1)
    {
      uint64_t v106 = 0;
      uint64_t v107 = 8;
      do
      {
        uint64_t v108 = *(void *)(v105 + 16);
        uint64_t v109 = *(void *)(v108 + 8 * v106);
        if (v109) {
          _outNode(a1, v109);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v108 + v107) {
          BOOL v110 = v108 + v107 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v110 = 1;
        }
        if (!v110) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v106;
        v107 += 8;
      }
      while (v106 < *(int *)(v105 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v99, v100, v101, v102, v103, v104, v206);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"sortClause\":", a3, a4, a5, a6, a7, a8, v197);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v117 = *(void *)(a2 + 80);
    if (v117 && *(int *)(v117 + 4) >= 1)
    {
      uint64_t v118 = 0;
      uint64_t v119 = 8;
      do
      {
        uint64_t v120 = *(void *)(v117 + 16);
        uint64_t v121 = *(void *)(v120 + 8 * v118);
        if (v121) {
          _outNode(a1, v121);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v120 + v119) {
          BOOL v122 = v120 + v119 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v122 = 1;
        }
        if (!v122) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v118;
        v119 += 8;
      }
      while (v118 < *(int *)(v117 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v111, v112, v113, v114, v115, v116, v207);
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"limitOffset\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(void *)(a2 + 88));
    appendStringInfo((uint64_t)a1, ",", v123, v124, v125, v126, v127, v128, v208);
  }
  if (*(void *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"limitCount\":", a3, a4, a5, a6, a7, a8, v197);
    _outNode(a1, *(void *)(a2 + 96));
    appendStringInfo((uint64_t)a1, ",", v129, v130, v131, v132, v133, v134, v209);
  }
  uint64_t v135 = *(int *)(a2 + 104);
  if (v135 > 2) {
    uint64_t v136 = 0;
  }
  else {
    uint64_t v136 = (&off_1E55D9128)[v135];
  }
  appendStringInfo((uint64_t)a1, "\"limitOption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v136);
  if (*(void *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"lockingClause\":", v137, v138, v139, v140, v141, v142, v210);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v149 = *(void *)(a2 + 112);
    if (v149 && *(int *)(v149 + 4) >= 1)
    {
      uint64_t v150 = 0;
      uint64_t v151 = 8;
      do
      {
        uint64_t v152 = *(void *)(v149 + 16);
        uint64_t v153 = *(void *)(v152 + 8 * v150);
        if (v153) {
          _outNode(a1, v153);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v152 + v151) {
          BOOL v154 = v152 + v151 >= (unint64_t)(*(void *)(*(void *)(a2 + 112) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 112) + 4));
        else {
          BOOL v154 = 1;
        }
        if (!v154) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v150;
        v151 += 8;
      }
      while (v150 < *(int *)(v149 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v143, v144, v145, v146, v147, v148, v211);
  }
  if (*(void *)(a2 + 120))
  {
    appendStringInfo((uint64_t)a1, "\"withClause\":{", v137, v138, v139, v140, v141, v142, v210);
    _outWithClause((uint64_t)a1, *(void *)(a2 + 120), v155, v156, v157, v158, v159, v160);
    int v167 = a1[2];
    BOOL v36 = __OFSUB__(v167, 1);
    uint64_t v168 = (v167 - 1);
    if ((int)v168 < 0 == v36)
    {
      uint64_t v169 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v168) == 44)
      {
        a1[2] = v168;
        *(unsigned char *)(v169 + v168) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v161, v162, v163, v164, v165, v166, v212);
  }
  uint64_t v170 = *(int *)(a2 + 128);
  if (v170 > 3) {
    uint64_t v171 = 0;
  }
  else {
    uint64_t v171 = (&off_1E55D9358)[v170];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"op\":\"%s\",", v137, v138, v139, v140, v141, v142, (size_t)v171);
  if (*(unsigned char *)(a2 + 132)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"all\":%s,", v173, v174, v175, v176, v177, v178, (size_t)"true");
  }
  if (*(void *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"larg\":{", v173, v174, v175, v176, v177, v178, v213);
    _outSelectStmt(a1, *(void *)(a2 + 136));
    int v185 = a1[2];
    BOOL v36 = __OFSUB__(v185, 1);
    uint64_t v186 = (v185 - 1);
    if ((int)v186 < 0 == v36)
    {
      uint64_t v187 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v186) == 44)
      {
        a1[2] = v186;
        *(unsigned char *)(v187 + v186) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "},", v179, v180, v181, v182, v183, v184, v214);
  }
  if (*(void *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"rarg\":{", v173, v174, v175, v176, v177, v178, v213);
    _outSelectStmt(a1, *(void *)(a2 + 144));
    int v194 = a1[2];
    BOOL v36 = __OFSUB__(v194, 1);
    uint64_t v195 = (v194 - 1);
    if ((int)v195 < 0 == v36)
    {
      uint64_t v196 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v195) == 44)
      {
        a1[2] = v195;
        *(unsigned char *)(v196 + v195) = 0;
      }
    }
    return appendStringInfo((uint64_t)a1, "},", v188, v189, v190, v191, v192, v193, a9);
  }
  return result;
}

unint64_t _outAlterTableStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v47);
    _outRangeVar(a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v48);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"cmds\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar(a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v49);
  }
  uint64_t v38 = *(int *)(a2 + 24);
  if (v38 > 0x31) {
    uint64_t v39 = 0;
  }
  else {
    uint64_t v39 = (&off_1E55D9558)[v38];
  }
  unint64_t result = appendStringInfo(a1, "\"relkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v39);
  if (*(unsigned char *)(a2 + 28)) {
    return appendStringInfo(a1, "\"missing_ok\":%s,", v41, v42, v43, v44, v45, v46, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterTableCmd(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0x42) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9140)[v10];
  }
  appendStringInfo((uint64_t)a1, "\"subtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v12, v13, v14, v15, v16, v17, v62);
    _outToken(a1, *(char **)(a2 + 8), v18, v19, v20, v21, v22, v23);
    appendStringInfo((uint64_t)a1, ",", v24, v25, v26, v27, v28, v29, v63);
  }
  if (*(_WORD *)(a2 + 16)) {
    appendStringInfo((uint64_t)a1, "\"num\":%d,", v12, v13, v14, v15, v16, v17, *(__int16 *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newowner\":{", v12, v13, v14, v15, v16, v17, v62);
    _outRoleSpec(a1, *(void *)(a2 + 24), v30, v31, v32, v33, v34, v35);
    int v42 = a1[2];
    BOOL v43 = __OFSUB__(v42, 1);
    uint64_t v44 = (v42 - 1);
    if ((int)v44 < 0 == v43)
    {
      uint64_t v45 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v44) == 44)
      {
        a1[2] = v44;
        *(unsigned char *)(v45 + v44) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v36, v37, v38, v39, v40, v41, v64);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"def\":", v12, v13, v14, v15, v16, v17, v62);
    _outNode(a1, *(void *)(a2 + 32));
    appendStringInfo((uint64_t)a1, ",", v46, v47, v48, v49, v50, v51, v65);
  }
  int v52 = *(_DWORD *)(a2 + 40);
  uint64_t v53 = "DROP_CASCADE";
  if (v52 != 1) {
    uint64_t v53 = 0;
  }
  if (v52) {
    uint64_t v54 = v53;
  }
  else {
    uint64_t v54 = "DROP_RESTRICT";
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v54);
  if (*(unsigned char *)(a2 + 44)) {
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v56, v57, v58, v59, v60, v61, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterDomainStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a2 + 4)) {
    appendStringInfo((uint64_t)a1, "\"subtype\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"typeName\":", a3, a4, a5, a6, a7, a8, v50);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v10, v11, v12, v13, v14, v15, v51);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(a1, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    appendStringInfo((uint64_t)a1, ",", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"def\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v53);
  }
  int v40 = *(_DWORD *)(a2 + 32);
  uint64_t v41 = "DROP_CASCADE";
  if (v40 != 1) {
    uint64_t v41 = 0;
  }
  if (v40) {
    int v42 = v41;
  }
  else {
    int v42 = "DROP_RESTRICT";
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v42);
  if (*(unsigned char *)(a2 + 36)) {
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v44, v45, v46, v47, v48, v49, (size_t)"true");
  }
  return result;
}

unint64_t _outSetOperationStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 3) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9358)[v11];
  }
  unint64_t result = appendStringInfo(a1, "\"op\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(unsigned char *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"all\":%s,", v14, v15, v16, v17, v18, v19, (size_t)"true");
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"larg\":", v14, v15, v16, v17, v18, v19, v80);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v20, v21, v22, v23, v24, v25, v81);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rarg\":", v14, v15, v16, v17, v18, v19, v80);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo(a1, ",", v26, v27, v28, v29, v30, v31, v82);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"colTypes\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v38 = *(void *)(a2 + 32);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      uint64_t v39 = 0;
      uint64_t v40 = 8;
      do
      {
        uint64_t v41 = *(void *)(v38 + 16);
        uint64_t v42 = *(void *)(v41 + 8 * v39);
        if (v42) {
          _outNode(a1, v42);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v41 + v40) {
          BOOL v43 = v41 + v40 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v43 = 1;
        }
        if (!v43) {
          appendStringInfoString(a1, ",");
        }
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v32, v33, v34, v35, v36, v37, v83);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"colTypmods\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v50 = *(void *)(a2 + 40);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 8;
      do
      {
        uint64_t v53 = *(void *)(v50 + 16);
        uint64_t v54 = *(void *)(v53 + 8 * v51);
        if (v54) {
          _outNode(a1, v54);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v53 + v52) {
          BOOL v55 = v53 + v52 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString(a1, ",");
        }
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v84);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"colCollations\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v62 = *(void *)(a2 + 48);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      uint64_t v63 = 0;
      uint64_t v64 = 8;
      do
      {
        uint64_t v65 = *(void *)(v62 + 16);
        uint64_t v66 = *(void *)(v65 + 8 * v63);
        if (v66) {
          _outNode(a1, v66);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v65 + v64) {
          BOOL v67 = v65 + v64 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString(a1, ",");
        }
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v56, v57, v58, v59, v60, v61, v85);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo(a1, "\"groupClauses\":", v14, v15, v16, v17, v18, v19, v80);
    appendStringInfoChar(a1, 91);
    uint64_t v74 = *(void *)(a2 + 56);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      uint64_t v75 = 0;
      uint64_t v76 = 8;
      do
      {
        uint64_t v77 = *(void *)(v74 + 16);
        uint64_t v78 = *(void *)(v77 + 8 * v75);
        if (v78) {
          _outNode(a1, v78);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v77 + v76) {
          BOOL v79 = v77 + v76 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v79 = 1;
        }
        if (!v79) {
          appendStringInfoString(a1, ",");
        }
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo(a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

unint64_t _outGrantStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a2 + 4)) {
    appendStringInfo(a1, "\"is_grant\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  uint64_t v10 = *(int *)(a2 + 8);
  if (v10 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9378)[v10];
  }
  appendStringInfo(a1, "\"targtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  uint64_t v18 = *(int *)(a2 + 12);
  if (v18 > 0x31) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (&off_1E55D9558)[v18];
  }
  appendStringInfo(a1, "\"objtype\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"objects\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v67);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"privileges\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    uint64_t v44 = *(void *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      uint64_t v45 = 0;
      uint64_t v46 = 8;
      do
      {
        uint64_t v47 = *(void *)(v44 + 16);
        uint64_t v48 = *(void *)(v47 + 8 * v45);
        if (v48) {
          _outNode(a1, v48);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v47 + v46) {
          BOOL v49 = v47 + v46 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v49 = 1;
        }
        if (!v49) {
          appendStringInfoString(a1, ",");
        }
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    appendStringInfo(a1, "],", v38, v39, v40, v41, v42, v43, v68);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"grantees\":", v20, v21, v22, v23, v24, v25, v66);
    appendStringInfoChar(a1, 91);
    uint64_t v56 = *(void *)(a2 + 32);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 8;
      do
      {
        uint64_t v59 = *(void *)(v56 + 16);
        uint64_t v60 = *(void *)(v59 + 8 * v57);
        if (v60) {
          _outNode(a1, v60);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v59 + v58) {
          BOOL v61 = v59 + v58 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v61 = 1;
        }
        if (!v61) {
          appendStringInfoString(a1, ",");
        }
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    appendStringInfo(a1, "],", v50, v51, v52, v53, v54, v55, v69);
  }
  if (*(unsigned char *)(a2 + 40)) {
    appendStringInfo(a1, "\"grant_option\":%s,", v20, v21, v22, v23, v24, v25, (size_t)"true");
  }
  int v62 = *(_DWORD *)(a2 + 44);
  uint64_t v63 = "DROP_CASCADE";
  if (v62 != 1) {
    uint64_t v63 = 0;
  }
  if (v62) {
    uint64_t v64 = v63;
  }
  else {
    uint64_t v64 = "DROP_RESTRICT";
  }
  return appendStringInfo(a1, "\"behavior\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v64);
}

unint64_t _outGrantRoleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"granted_roles\":", a3, a4, a5, a6, a7, a8, v54);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v10, v11, v12, v13, v14, v15, v55);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"grantee_roles\":", a3, a4, a5, a6, a7, a8, v54);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(a1, v32);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v22, v23, v24, v25, v26, v27, v56);
  }
  if (*(unsigned char *)(a2 + 24)) {
    appendStringInfo((uint64_t)a1, "\"is_grant\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 25)) {
    appendStringInfo((uint64_t)a1, "\"admin_opt\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"grantor\":{", a3, a4, a5, a6, a7, a8, v54);
    _outRoleSpec(a1, *(void *)(a2 + 32), v34, v35, v36, v37, v38, v39);
    int v46 = a1[2];
    BOOL v47 = __OFSUB__(v46, 1);
    uint64_t v48 = (v46 - 1);
    if ((int)v48 < 0 == v47)
    {
      uint64_t v49 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v48) == 44)
      {
        a1[2] = v48;
        *(unsigned char *)(v49 + v48) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v40, v41, v42, v43, v44, v45, v57);
  }
  int v50 = *(_DWORD *)(a2 + 40);
  uint64_t v51 = "DROP_CASCADE";
  if (v50 != 1) {
    uint64_t v51 = 0;
  }
  if (v50) {
    uint64_t v52 = v51;
  }
  else {
    uint64_t v52 = "DROP_RESTRICT";
  }
  return appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v52);
}

uint64_t _outAlterDefaultPrivilegesStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"options\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v40);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"action\":{", a3, a4, a5, a6, a7, a8, v39);
    _outGrantStmt(v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = *(_DWORD *)(v10 + 8);
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

unint64_t _outClosePortalStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = (int *)result;
    appendStringInfo(result, "\"portalname\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outClusterStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar((uint64_t)v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = v9[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        void v9[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"indexname\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(v9, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v32, v33, v34, v35, v36, v37, v40);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"options\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outCopyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v75);
    _outRangeVar((uint64_t)v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v76);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v27, v28, v29, v30, v31, v32, v77);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"attlist\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v39 = *(void *)(a2 + 24);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      uint64_t v40 = 0;
      uint64_t v41 = 8;
      do
      {
        uint64_t v42 = *(void *)(v39 + 16);
        uint64_t v43 = *(void *)(v42 + 8 * v40);
        if (v43) {
          _outNode(v10, v43);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v42 + v41) {
          BOOL v44 = v42 + v41 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v44 = 1;
        }
        if (!v44) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v40;
        v41 += 8;
      }
      while (v40 < *(int *)(v39 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v33, v34, v35, v36, v37, v38, v78);
  }
  if (*(unsigned char *)(a2 + 32)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"is_from\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 33)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"is_program\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"filename\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 40), v45, v46, v47, v48, v49, v50);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v51, v52, v53, v54, v55, v56, v79);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v63 = *(void *)(a2 + 48);
    if (v63 && *(int *)(v63 + 4) >= 1)
    {
      uint64_t v64 = 0;
      uint64_t v65 = 8;
      do
      {
        uint64_t v66 = *(void *)(v63 + 16);
        uint64_t v67 = *(void *)(v66 + 8 * v64);
        if (v67) {
          _outNode(v10, v67);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v66 + v65) {
          BOOL v68 = v66 + v65 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v68 = 1;
        }
        if (!v68) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v64;
        v65 += 8;
      }
      while (v64 < *(int *)(v63 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v57, v58, v59, v60, v61, v62, v80);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(void *)(a2 + 56));
    return appendStringInfo((uint64_t)v10, ",", v69, v70, v71, v72, v73, v74, a9);
  }
  return result;
}

unint64_t _outCreateStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v152);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = a1[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v153);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"tableElts\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v26, v27, v28, v29, v30, v31, v154);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"inhRelations\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v44 = *(void *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      uint64_t v45 = 0;
      uint64_t v46 = 8;
      do
      {
        uint64_t v47 = *(void *)(v44 + 16);
        uint64_t v48 = *(void *)(v47 + 8 * v45);
        if (v48) {
          _outNode(a1, v48);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v47 + v46) {
          BOOL v49 = v47 + v46 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v49 = 1;
        }
        if (!v49) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v38, v39, v40, v41, v42, v43, v155);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"partbound\":{", a3, a4, a5, a6, a7, a8, v152);
    _outPartitionBoundSpec((uint64_t)a1, *(void *)(a2 + 32), v50, v51, v52, v53, v54, v55);
    int v62 = a1[2];
    BOOL v23 = __OFSUB__(v62, 1);
    uint64_t v63 = (v62 - 1);
    if ((int)v63 < 0 == v23)
    {
      uint64_t v64 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v63) == 44)
      {
        a1[2] = v63;
        *(unsigned char *)(v64 + v63) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v56, v57, v58, v59, v60, v61, v156);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"partspec\":{", a3, a4, a5, a6, a7, a8, v152);
    _outPartitionSpec((uint64_t)a1, *(void *)(a2 + 40), v65, v66, v67, v68, v69, v70);
    int v77 = a1[2];
    BOOL v23 = __OFSUB__(v77, 1);
    uint64_t v78 = (v77 - 1);
    if ((int)v78 < 0 == v23)
    {
      uint64_t v79 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v78) == 44)
      {
        a1[2] = v78;
        *(unsigned char *)(v79 + v78) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v71, v72, v73, v74, v75, v76, v157);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"ofTypename\":{", a3, a4, a5, a6, a7, a8, v152);
    _outTypeName((uint64_t)a1, *(void *)(a2 + 48), v80, v81, v82, v83, v84, v85);
    int v92 = a1[2];
    BOOL v23 = __OFSUB__(v92, 1);
    uint64_t v93 = (v92 - 1);
    if ((int)v93 < 0 == v23)
    {
      uint64_t v94 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v93) == 44)
      {
        a1[2] = v93;
        *(unsigned char *)(v94 + v93) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v86, v87, v88, v89, v90, v91, v158);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"constraints\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v101 = *(void *)(a2 + 56);
    if (v101 && *(int *)(v101 + 4) >= 1)
    {
      uint64_t v102 = 0;
      uint64_t v103 = 8;
      do
      {
        uint64_t v104 = *(void *)(v101 + 16);
        uint64_t v105 = *(void *)(v104 + 8 * v102);
        if (v105) {
          _outNode(a1, v105);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v104 + v103) {
          BOOL v106 = v104 + v103 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v106 = 1;
        }
        if (!v106) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v102;
        v103 += 8;
      }
      while (v102 < *(int *)(v101 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v95, v96, v97, v98, v99, v100, v159);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v152);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v113 = *(void *)(a2 + 64);
    if (v113 && *(int *)(v113 + 4) >= 1)
    {
      uint64_t v114 = 0;
      uint64_t v115 = 8;
      do
      {
        uint64_t v116 = *(void *)(v113 + 16);
        uint64_t v117 = *(void *)(v116 + 8 * v114);
        if (v117) {
          _outNode(a1, v117);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v116 + v115) {
          BOOL v118 = v116 + v115 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v118 = 1;
        }
        if (!v118) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v114;
        v115 += 8;
      }
      while (v114 < *(int *)(v113 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v107, v108, v109, v110, v111, v112, v160);
  }
  uint64_t v119 = *(int *)(a2 + 72);
  if (v119 > 3) {
    uint64_t v120 = 0;
  }
  else {
    uint64_t v120 = (&off_1E55D9390)[v119];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"oncommit\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v120);
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"tablespacename\":", v122, v123, v124, v125, v126, v127, v161);
    _outToken(a1, *(char **)(a2 + 80), v128, v129, v130, v131, v132, v133);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v134, v135, v136, v137, v138, v139, v162);
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"accessMethod\":", v122, v123, v124, v125, v126, v127, v161);
    _outToken(a1, *(char **)(a2 + 88), v140, v141, v142, v143, v144, v145);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v146, v147, v148, v149, v150, v151, v163);
  }
  if (*(unsigned char *)(a2 + 96)) {
    return appendStringInfo((uint64_t)a1, "\"if_not_exists\":%s,", v122, v123, v124, v125, v126, v127, (size_t)"true");
  }
  return result;
}

unint64_t _outDefineStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0x31) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9558)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(unsigned char *)(a2 + 8)) {
    unint64_t result = appendStringInfo(a1, "\"oldstyle\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"defnames\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 16);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"args\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v37 = *(void *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString(a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v57);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"definition\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v49 = *(void *)(a2 + 32);
    if (v49 && *(int *)(v49 + 4) >= 1)
    {
      uint64_t v50 = 0;
      uint64_t v51 = 8;
      do
      {
        uint64_t v52 = *(void *)(v49 + 16);
        uint64_t v53 = *(void *)(v52 + 8 * v50);
        if (v53) {
          _outNode(a1, v53);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v52 + v51) {
          BOOL v54 = v52 + v51 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v54 = 1;
        }
        if (!v54) {
          appendStringInfoString(a1, ",");
        }
        ++v50;
        v51 += 8;
      }
      while (v50 < *(int *)(v49 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v43, v44, v45, v46, v47, v48, v58);
  }
  if (*(unsigned char *)(a2 + 40)) {
    unint64_t result = appendStringInfo(a1, "\"if_not_exists\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 41)) {
    return appendStringInfo(a1, "\"replace\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outDropStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"objects\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v41);
  }
  uint64_t v22 = *(int *)(a2 + 16);
  if (v22 > 0x31) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (&off_1E55D9558)[v22];
  }
  appendStringInfo(a1, "\"removeType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  int v30 = *(_DWORD *)(a2 + 20);
  uint64_t v31 = "DROP_CASCADE";
  if (v30 != 1) {
    uint64_t v31 = 0;
  }
  if (v30) {
    uint64_t v32 = v31;
  }
  else {
    uint64_t v32 = "DROP_RESTRICT";
  }
  unint64_t result = appendStringInfo(a1, "\"behavior\":\"%s\",", v24, v25, v26, v27, v28, v29, (size_t)v32);
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo(a1, "\"missing_ok\":%s,", v34, v35, v36, v37, v38, v39, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 25)) {
    return appendStringInfo(a1, "\"concurrent\":%s,", v34, v35, v36, v37, v38, v39, (size_t)"true");
  }
  return result;
}

unint64_t _outTruncateStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relations\":", a3, a4, a5, a6, a7, a8, v26);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v27);
  }
  if (*(unsigned char *)(a2 + 16)) {
    appendStringInfo(a1, "\"restart_seqs\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  int v22 = *(_DWORD *)(a2 + 20);
  uint64_t v23 = "DROP_CASCADE";
  if (v22 != 1) {
    uint64_t v23 = 0;
  }
  if (v22) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = "DROP_RESTRICT";
  }
  return appendStringInfo(a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

unint64_t _outCommentStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 0x31) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9558)[v11];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v38);
    _outNode(a1, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v20, v21, v22, v23, v24, v25, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"comment\":", v14, v15, v16, v17, v18, v19, v38);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    return appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

unint64_t _outFetchStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D93B0)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"direction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"howMany\":%ld,", v13, v14, v15, v16, v17, v18, *(void *)(a2 + 8));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"portalname\":", v13, v14, v15, v16, v17, v18, v31);
    _outToken(a1, *(char **)(a2 + 16), v19, v20, v21, v22, v23, v24);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v32);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo((uint64_t)a1, "\"ismove\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

uint64_t _outIndexStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"idxname\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v129);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"relation\":{", a3, a4, a5, a6, a7, a8, v128);
    _outRangeVar((uint64_t)v9, *(void *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    int v34 = v9[2];
    BOOL v35 = __OFSUB__(v34, 1);
    uint64_t v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      uint64_t v37 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v36) == 44)
      {
        void v9[2] = v36;
        *(unsigned char *)(v37 + v36) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v130);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"accessMethod\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v131);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"tableSpace\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 32), v50, v51, v52, v53, v54, v55);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v56, v57, v58, v59, v60, v61, v132);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"indexParams\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v68 = *(void *)(a2 + 40);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      uint64_t v69 = 0;
      uint64_t v70 = 8;
      do
      {
        uint64_t v71 = *(void *)(v68 + 16);
        uint64_t v72 = *(void *)(v71 + 8 * v69);
        if (v72) {
          _outNode(v9, v72);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v71 + v70) {
          BOOL v73 = v71 + v70 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v73 = 1;
        }
        if (!v73) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v62, v63, v64, v65, v66, v67, v133);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"indexIncludingParams\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v80 = *(void *)(a2 + 48);
    if (v80 && *(int *)(v80 + 4) >= 1)
    {
      uint64_t v81 = 0;
      uint64_t v82 = 8;
      do
      {
        uint64_t v83 = *(void *)(v80 + 16);
        uint64_t v84 = *(void *)(v83 + 8 * v81);
        if (v84) {
          _outNode(v9, v84);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v83 + v82) {
          BOOL v85 = v83 + v82 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v85 = 1;
        }
        if (!v85) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v81;
        v82 += 8;
      }
      while (v81 < *(int *)(v80 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v74, v75, v76, v77, v78, v79, v134);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v92 = *(void *)(a2 + 56);
    if (v92 && *(int *)(v92 + 4) >= 1)
    {
      uint64_t v93 = 0;
      uint64_t v94 = 8;
      do
      {
        uint64_t v95 = *(void *)(v92 + 16);
        uint64_t v96 = *(void *)(v95 + 8 * v93);
        if (v96) {
          _outNode(v9, v96);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v95 + v94) {
          BOOL v97 = v95 + v94 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v97 = 1;
        }
        if (!v97) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v93;
        v94 += 8;
      }
      while (v93 < *(int *)(v92 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v86, v87, v88, v89, v90, v91, v135);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)v9, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v128);
    _outNode(v9, *(void *)(a2 + 64));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v98, v99, v100, v101, v102, v103, v136);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v9, "\"excludeOpNames\":", a3, a4, a5, a6, a7, a8, v128);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v110 = *(void *)(a2 + 72);
    if (v110 && *(int *)(v110 + 4) >= 1)
    {
      uint64_t v111 = 0;
      uint64_t v112 = 8;
      do
      {
        uint64_t v113 = *(void *)(v110 + 16);
        uint64_t v114 = *(void *)(v113 + 8 * v111);
        if (v114) {
          _outNode(v9, v114);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v113 + v112) {
          BOOL v115 = v113 + v112 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v115 = 1;
        }
        if (!v115) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v111;
        v112 += 8;
      }
      while (v111 < *(int *)(v110 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v104, v105, v106, v107, v108, v109, v137);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)v9, "\"idxcomment\":", a3, a4, a5, a6, a7, a8, v128);
    _outToken(v9, *(char **)(a2 + 80), v116, v117, v118, v119, v120, v121);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v122, v123, v124, v125, v126, v127, v138);
  }
  if (*(_DWORD *)(a2 + 88)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"indexOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 88));
  }
  if (*(_DWORD *)(a2 + 92)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"oldNode\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 92));
  }
  if (*(_DWORD *)(a2 + 96)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"oldCreateSubid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 96));
  }
  if (*(_DWORD *)(a2 + 100)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"oldFirstRelfilenodeSubid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 100));
  }
  if (*(unsigned char *)(a2 + 104)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"unique\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 105)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"primary\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 106)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"isconstraint\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 107)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"deferrable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 108)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"initdeferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 109)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"transformed\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 110)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"concurrent\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 111)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 112)) {
    return appendStringInfo((uint64_t)v9, "\"reset_default_tblspc\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateFunctionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"is_procedure\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 5)) {
    unint64_t result = appendStringInfo(v10, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v64);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"parameters\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, v65);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v10, "\"returnType\":{", a3, a4, a5, a6, a7, a8, v63);
    _outTypeName(v10, *(void *)(a2 + 24), v35, v36, v37, v38, v39, v40);
    int v47 = *(_DWORD *)(v10 + 8);
    BOOL v48 = __OFSUB__(v47, 1);
    uint64_t v49 = (v47 - 1);
    if ((int)v49 < 0 == v48)
    {
      uint64_t v50 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v49) == 44)
      {
        *(_DWORD *)(v10 + 8) = v49;
        *(unsigned char *)(v50 + v49) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v41, v42, v43, v44, v45, v46, v66);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar(v10, 91);
    uint64_t v57 = *(void *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 8;
      do
      {
        uint64_t v60 = *(void *)(v57 + 16);
        uint64_t v61 = *(void *)(v60 + 8 * v58);
        if (v61) {
          _outNode(v10, v61);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v60 + v59) {
          BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v62 = 1;
        }
        if (!v62) {
          appendStringInfoString(v10, ",");
        }
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    return appendStringInfo(v10, "],", v51, v52, v53, v54, v55, v56, a9);
  }
  return result;
}

unint64_t _outAlterFunctionStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 0x31) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9558)[v11];
  }
  unint64_t result = appendStringInfo(a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"func\":{", v14, v15, v16, v17, v18, v19, v48);
    _outObjectWithArgs(a1, *(void *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    int v32 = *(_DWORD *)(a1 + 8);
    BOOL v33 = __OFSUB__(v32, 1);
    uint64_t v34 = (v32 - 1);
    if ((int)v34 < 0 == v33)
    {
      uint64_t v35 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v34) == 44)
      {
        *(_DWORD *)(a1 + 8) = v34;
        *(unsigned char *)(v35 + v34) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "},", v26, v27, v28, v29, v30, v31, v49);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"actions\":", v14, v15, v16, v17, v18, v19, v48);
    appendStringInfoChar(a1, 91);
    uint64_t v42 = *(void *)(a2 + 16);
    if (v42 && *(int *)(v42 + 4) >= 1)
    {
      uint64_t v43 = 0;
      uint64_t v44 = 8;
      do
      {
        uint64_t v45 = *(void *)(v42 + 16);
        uint64_t v46 = *(void *)(v45 + 8 * v43);
        if (v46) {
          _outNode(a1, v46);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v45 + v44) {
          BOOL v47 = v45 + v44 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v47 = 1;
        }
        if (!v47) {
          appendStringInfoString(a1, ",");
        }
        ++v43;
        v44 += 8;
      }
      while (v43 < *(int *)(v42 + 4));
    }
    return appendStringInfo(a1, "],", v36, v37, v38, v39, v40, v41, a9);
  }
  return result;
}

unint64_t _outDoStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = result;
    appendStringInfo(result, "\"args\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

unint64_t _outRenameStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0x31) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9558)[v10];
  }
  appendStringInfo((uint64_t)a1, "\"renameType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  uint64_t v18 = *(int *)(a2 + 8);
  if (v18 > 0x31) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (&off_1E55D9558)[v18];
  }
  appendStringInfo((uint64_t)a1, "\"relationType\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v20, v21, v22, v23, v24, v25, v82);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    int v38 = a1[2];
    BOOL v39 = __OFSUB__(v38, 1);
    uint64_t v40 = (v38 - 1);
    if ((int)v40 < 0 == v39)
    {
      uint64_t v41 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v40) == 44)
      {
        a1[2] = v40;
        *(unsigned char *)(v41 + v4errstart(20, 0) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v32, v33, v34, v35, v36, v37, v83);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v20, v21, v22, v23, v24, v25, v82);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v42, v43, v44, v45, v46, v47, v84);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", v20, v21, v22, v23, v24, v25, v82);
    _outToken(a1, *(char **)(a2 + 32), v48, v49, v50, v51, v52, v53);
    appendStringInfo((uint64_t)a1, ",", v54, v55, v56, v57, v58, v59, v85);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"newname\":", v20, v21, v22, v23, v24, v25, v82);
    _outToken(a1, *(char **)(a2 + 40), v60, v61, v62, v63, v64, v65);
    appendStringInfo((uint64_t)a1, ",", v66, v67, v68, v69, v70, v71, v86);
  }
  int v72 = *(_DWORD *)(a2 + 48);
  BOOL v73 = "DROP_CASCADE";
  if (v72 != 1) {
    BOOL v73 = 0;
  }
  if (v72) {
    uint64_t v74 = v73;
  }
  else {
    uint64_t v74 = "DROP_RESTRICT";
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", v20, v21, v22, v23, v24, v25, (size_t)v74);
  if (*(unsigned char *)(a2 + 52)) {
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v76, v77, v78, v79, v80, v81, (size_t)"true");
  }
  return result;
}

unint64_t _outRuleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", a3, a4, a5, a6, a7, a8, v65);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = a1[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        a1[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v16, v17, v18, v19, v20, v21, v66);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"rulename\":", a3, a4, a5, a6, a7, a8, v65);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, v67);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v65);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v38, v39, v40, v41, v42, v43, v68);
  }
  uint64_t v44 = *(int *)(a2 + 32);
  if (v44 > 6) {
    uint64_t v45 = 0;
  }
  else {
    uint64_t v45 = (&off_1E55D93D0)[v44];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"event\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v45);
  if (*(unsigned char *)(a2 + 36)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"instead\":%s,", v47, v48, v49, v50, v51, v52, (size_t)"true");
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"actions\":", v47, v48, v49, v50, v51, v52, v69);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v59 = *(void *)(a2 + 40);
    if (v59 && *(int *)(v59 + 4) >= 1)
    {
      uint64_t v60 = 0;
      uint64_t v61 = 8;
      do
      {
        uint64_t v62 = *(void *)(v59 + 16);
        uint64_t v63 = *(void *)(v62 + 8 * v60);
        if (v63) {
          _outNode(a1, v63);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v62 + v61) {
          BOOL v64 = v62 + v61 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v64 = 1;
        }
        if (!v64) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v60;
        v61 += 8;
      }
      while (v60 < *(int *)(v59 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v53, v54, v55, v56, v57, v58, v70);
  }
  if (*(unsigned char *)(a2 + 48)) {
    return appendStringInfo((uint64_t)a1, "\"replace\":%s,", v47, v48, v49, v50, v51, v52, (size_t)"true");
  }
  return result;
}

uint64_t _outNotifyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"conditionname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"payload\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    return appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

unint64_t _outListenStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = (int *)result;
    appendStringInfo(result, "\"conditionname\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outTransactionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9408)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v25 = *(void *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"savepoint_name\":", v13, v14, v15, v16, v17, v18, v55);
    _outToken(a1, *(char **)(a2 + 16), v31, v32, v33, v34, v35, v36);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v37, v38, v39, v40, v41, v42, v57);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"gid\":", v13, v14, v15, v16, v17, v18, v55);
    _outToken(a1, *(char **)(a2 + 24), v43, v44, v45, v46, v47, v48);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v49, v50, v51, v52, v53, v54, v58);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)a1, "\"chain\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outViewStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"view\":{", a3, a4, a5, a6, a7, a8, v59);
    _outRangeVar(a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v60);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"aliases\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar(a1, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(a1, v36);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(a1, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    appendStringInfo(a1, "],", v26, v27, v28, v29, v30, v31, v61);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"query\":", a3, a4, a5, a6, a7, a8, v59);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo(a1, ",", v38, v39, v40, v41, v42, v43, v62);
  }
  if (*(unsigned char *)(a2 + 32)) {
    appendStringInfo(a1, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"options\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar(a1, 91);
    uint64_t v50 = *(void *)(a2 + 40);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 8;
      do
      {
        uint64_t v53 = *(void *)(v50 + 16);
        uint64_t v54 = *(void *)(v53 + 8 * v51);
        if (v54) {
          _outNode(a1, v54);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v53 + v52) {
          BOOL v55 = v53 + v52 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString(a1, ",");
        }
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    appendStringInfo(a1, "],", v44, v45, v46, v47, v48, v49, v63);
  }
  uint64_t v56 = *(int *)(a2 + 48);
  if (v56 > 2) {
    size_t v57 = 0;
  }
  else {
    size_t v57 = (&off_1E55D9458)[v56];
  }
  return appendStringInfo(a1, "\"withCheckOption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v57);
}

unint64_t _outLoadStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = (int *)result;
    appendStringInfo(result, "\"filename\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outCreateDomainStmt(uint64_t result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (a2[1])
  {
    appendStringInfo(result, "\"domainname\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = a2[1];
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(a2[1] + 16) + 8 * *(int *)(a2[1] + 4));
        }
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v67);
  }
  if (a2[2])
  {
    appendStringInfo(v10, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v66);
    _outTypeName(v10, a2[2], v23, v24, v25, v26, v27, v28);
    int v35 = *(_DWORD *)(v10 + 8);
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, v68);
  }
  if (a2[3])
  {
    appendStringInfo(v10, "\"collClause\":{", a3, a4, a5, a6, a7, a8, v66);
    _outCollateClause(v10, a2[3], v39, v40, v41, v42, v43, v44);
    int v51 = *(_DWORD *)(v10 + 8);
    BOOL v36 = __OFSUB__(v51, 1);
    uint64_t v52 = (v51 - 1);
    if ((int)v52 < 0 == v36)
    {
      uint64_t v53 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v52) == 44)
      {
        *(_DWORD *)(v10 + 8) = v52;
        *(unsigned char *)(v53 + v52) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v45, v46, v47, v48, v49, v50, v69);
  }
  if (a2[4])
  {
    appendStringInfo(v10, "\"constraints\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    uint64_t v60 = a2[4];
    if (v60 && *(int *)(v60 + 4) >= 1)
    {
      uint64_t v61 = 0;
      uint64_t v62 = 8;
      do
      {
        uint64_t v63 = *(void *)(v60 + 16);
        uint64_t v64 = *(void *)(v63 + 8 * v61);
        if (v64) {
          _outNode(v10, v64);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v63 + v62) {
          BOOL v65 = v63 + v62 >= (unint64_t)(*(void *)(a2[4] + 16) + 8 * *(int *)(a2[4] + 4));
        }
        else {
          BOOL v65 = 1;
        }
        if (!v65) {
          appendStringInfoString(v10, ",");
        }
        ++v61;
        v62 += 8;
      }
      while (v61 < *(int *)(v60 + 4));
    }
    return appendStringInfo(v10, "],", v54, v55, v56, v57, v58, v59, a9);
  }
  return result;
}

uint64_t _outCreatedbStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outDropdbStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 24);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outVacuumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"options\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"rels\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo(v9, "\"is_vacuumcmd\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outExplainStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"query\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    uint64_t v23 = *(void *)(a2 + 16);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 8;
      do
      {
        uint64_t v26 = *(void *)(v23 + 16);
        uint64_t v27 = *(void *)(v26 + 8 * v24);
        if (v27) {
          _outNode(v10, v27);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v26 + v25) {
          BOOL v28 = v26 + v25 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v28 = 1;
        }
        if (!v28) {
          appendStringInfoString(v10, ",");
        }
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    return appendStringInfo(v10, "],", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outCreateTableAsStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"query\":", a3, a4, a5, a6, a7, a8, v41);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo((uint64_t)a1, ",", v10, v11, v12, v13, v14, v15, v42);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"into\":{", a3, a4, a5, a6, a7, a8, v41);
    _outIntoClause(a1, *(void *)(a2 + 16), v16, v17, v18, v19, v20, v21);
    int v28 = a1[2];
    BOOL v29 = __OFSUB__(v28, 1);
    uint64_t v30 = (v28 - 1);
    if ((int)v30 < 0 == v29)
    {
      uint64_t v31 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v30) == 44)
      {
        a1[2] = v30;
        *(unsigned char *)(v31 + v3errstart(20, 0) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v22, v23, v24, v25, v26, v27, v43);
  }
  uint64_t v32 = *(int *)(a2 + 24);
  if (v32 > 0x31) {
    BOOL v33 = 0;
  }
  else {
    BOOL v33 = (&off_1E55D9558)[v32];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"relkind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v33);
  if (*(unsigned char *)(a2 + 28)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"is_select_into\":%s,", v35, v36, v37, v38, v39, v40, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 29)) {
    return appendStringInfo((uint64_t)a1, "\"if_not_exists\":%s,", v35, v36, v37, v38, v39, v40, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateSeqStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"sequence\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar(v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(v9 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar(v9, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(v9, v36);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(v9, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"ownerId\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(unsigned char *)(a2 + 28)) {
    unint64_t result = appendStringInfo(v9, "\"for_identity\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 29)) {
    return appendStringInfo(v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outAlterSeqStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"sequence\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRangeVar(v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(v9 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar(v9, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(v9, v36);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString(v9, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo(v9, "\"for_identity\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 25)) {
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outVariableSetStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9470)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v13, v14, v15, v16, v17, v18, v43);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v44);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"args\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v37 = *(void *)(a2 + 16);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v31, v32, v33, v34, v35, v36, v45);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo((uint64_t)a1, "\"is_local\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outVariableShowStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = (int *)result;
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outDiscardStmt(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 > 3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = (&off_1E55D94A0)[a2];
  }
  return appendStringInfo(a1, "\"target\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v8);
}

uint64_t _outCreateTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v108);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v109);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"relation\":{", a3, a4, a5, a6, a7, a8, v108);
    _outRangeVar((uint64_t)v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v110);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v45 = *(void *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, v111);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"args\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v57 = *(void *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 8;
      do
      {
        uint64_t v60 = *(void *)(v57 + 16);
        uint64_t v61 = *(void *)(v60 + 8 * v58);
        if (v61) {
          _outNode(v10, v61);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v60 + v59) {
          BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v62 = 1;
        }
        if (!v62) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, v112);
  }
  if (*(unsigned char *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"row\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_WORD *)(a2 + 42)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"timing\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 42));
  }
  if (*(_WORD *)(a2 + 44)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"events\":%d,", a3, a4, a5, a6, a7, a8, *(__int16 *)(a2 + 44));
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"columns\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v69 = *(void *)(a2 + 48);
    if (v69 && *(int *)(v69 + 4) >= 1)
    {
      uint64_t v70 = 0;
      uint64_t v71 = 8;
      do
      {
        uint64_t v72 = *(void *)(v69 + 16);
        uint64_t v73 = *(void *)(v72 + 8 * v70);
        if (v73) {
          _outNode(v10, v73);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v72 + v71) {
          BOOL v74 = v72 + v71 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v74 = 1;
        }
        if (!v74) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v70;
        v71 += 8;
      }
      while (v70 < *(int *)(v69 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v63, v64, v65, v66, v67, v68, v113);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"whenClause\":", a3, a4, a5, a6, a7, a8, v108);
    _outNode(v10, *(void *)(a2 + 56));
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v75, v76, v77, v78, v79, v80, v114);
  }
  if (*(unsigned char *)(a2 + 64)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"isconstraint\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v10, "\"transitionRels\":", a3, a4, a5, a6, a7, a8, v108);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v87 = *(void *)(a2 + 72);
    if (v87 && *(int *)(v87 + 4) >= 1)
    {
      uint64_t v88 = 0;
      uint64_t v89 = 8;
      do
      {
        uint64_t v90 = *(void *)(v87 + 16);
        uint64_t v91 = *(void *)(v90 + 8 * v88);
        if (v91) {
          _outNode(v10, v91);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v90 + v89) {
          BOOL v92 = v90 + v89 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v92 = 1;
        }
        if (!v92) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v88;
        v89 += 8;
      }
      while (v88 < *(int *)(v87 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v81, v82, v83, v84, v85, v86, v115);
  }
  if (*(unsigned char *)(a2 + 80)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"deferrable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 81)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"initdeferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfo((uint64_t)v10, "\"constrrel\":{", a3, a4, a5, a6, a7, a8, v108);
    _outRangeVar((uint64_t)v10, *(void *)(a2 + 88), v93, v94, v95, v96, v97, v98);
    int v105 = v10[2];
    BOOL v36 = __OFSUB__(v105, 1);
    uint64_t v106 = (v105 - 1);
    if ((int)v106 < 0 == v36)
    {
      uint64_t v107 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v106) == 44)
      {
        void v10[2] = v106;
        *(unsigned char *)(v107 + v106) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v99, v100, v101, v102, v103, v104, a9);
  }
  return result;
}

uint64_t _outCreatePLangStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v9, "\"plname\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v59);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"plhandler\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v60);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"plinline\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v61);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"plvalidator\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(v9, v56);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v62);
  }
  if (*(unsigned char *)(a2 + 40)) {
    return appendStringInfo((uint64_t)v9, "\"pltrusted\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outCreateRoleStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 2) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D94C0)[v11];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"stmt_type\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"role\":", v14, v15, v16, v17, v18, v19, v44);
    _outToken(a1, *(char **)(a2 + 8), v20, v21, v22, v23, v24, v25);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v26, v27, v28, v29, v30, v31, v45);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v14, v15, v16, v17, v18, v19, v44);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v38 = *(void *)(a2 + 16);
    if (v38 && *(int *)(v38 + 4) >= 1)
    {
      uint64_t v39 = 0;
      uint64_t v40 = 8;
      do
      {
        uint64_t v41 = *(void *)(v38 + 16);
        uint64_t v42 = *(void *)(v41 + 8 * v39);
        if (v42) {
          _outNode(a1, v42);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v41 + v40) {
          BOOL v43 = v41 + v40 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v43 = 1;
        }
        if (!v43) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v39;
        v40 += 8;
      }
      while (v39 < *(int *)(v38 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

uint64_t _outAlterRoleStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"role\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRoleSpec(v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = v9[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        void v9[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v38);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v32 = *(void *)(a2 + 16);
    if (v32 && *(int *)(v32 + 4) >= 1)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 8;
      do
      {
        uint64_t v35 = *(void *)(v32 + 16);
        uint64_t v36 = *(void *)(v35 + 8 * v33);
        if (v36) {
          _outNode(v9, v36);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v35 + v34) {
          BOOL v37 = v35 + v34 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v37 = 1;
        }
        if (!v37) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v33;
        v34 += 8;
      }
      while (v33 < *(int *)(v32 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v26, v27, v28, v29, v30, v31, v40);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"action\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outDropRoleStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"roles\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outLockStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relations\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"mode\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(unsigned char *)(a2 + 20)) {
    return appendStringInfo(v9, "\"nowait\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outConstraintsSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"constraints\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    return appendStringInfo(v9, "\"deferred\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outReindexStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 4) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D94D8)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v47);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    int v31 = a1[2];
    BOOL v32 = __OFSUB__(v31, 1);
    uint64_t v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      uint64_t v34 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(unsigned char *)(v34 + v33) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v48);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", v13, v14, v15, v16, v17, v18, v47);
    _outToken(a1, *(char **)(a2 + 16), v35, v36, v37, v38, v39, v40);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v41, v42, v43, v44, v45, v46, v49);
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"options\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 24));
  }
  if (*(unsigned char *)(a2 + 28)) {
    return appendStringInfo((uint64_t)a1, "\"concurrent\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateSchemaStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"schemaname\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v51);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"authrole\":{", a3, a4, a5, a6, a7, a8, v50);
    _outRoleSpec(v9, *(void *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    int v34 = v9[2];
    BOOL v35 = __OFSUB__(v34, 1);
    uint64_t v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      uint64_t v37 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v36) == 44)
      {
        void v9[2] = v36;
        *(unsigned char *)(v37 + v36) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"schemaElts\":", a3, a4, a5, a6, a7, a8, v50);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v44 = *(void *)(a2 + 24);
    if (v44 && *(int *)(v44 + 4) >= 1)
    {
      uint64_t v45 = 0;
      uint64_t v46 = 8;
      do
      {
        uint64_t v47 = *(void *)(v44 + 16);
        uint64_t v48 = *(void *)(v47 + 8 * v45);
        if (v48) {
          _outNode(v9, v48);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v47 + v46) {
          BOOL v49 = v47 + v46 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v49 = 1;
        }
        if (!v49) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v45;
        v46 += 8;
      }
      while (v45 < *(int *)(v44 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v38, v39, v40, v41, v42, v43, v53);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outAlterDatabaseSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"dbname\":", a3, a4, a5, a6, a7, a8, v39);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v39);
    _outVariableSetStmt(v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outAlterRoleSetStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"role\":{", a3, a4, a5, a6, a7, a8, v54);
    _outRoleSpec(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v55);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"database\":", a3, a4, a5, a6, a7, a8, v54);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v56);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v54);
    _outVariableSetStmt(v10, *(void *)(a2 + 24), v39, v40, v41, v42, v43, v44);
    int v51 = v10[2];
    BOOL v24 = __OFSUB__(v51, 1);
    uint64_t v52 = (v51 - 1);
    if ((int)v52 < 0 == v24)
    {
      uint64_t v53 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v52) == 44)
      {
        void v10[2] = v52;
        *(unsigned char *)(v53 + v52) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v45, v46, v47, v48, v49, v50, a9);
  }
  return result;
}

uint64_t _outCreateConversionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"conversion_name\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v59);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"for_encoding_name\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v60);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"to_encoding_name\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"func_name\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(v9, v56);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v62);
  }
  if (*(unsigned char *)(a2 + 40)) {
    return appendStringInfo((uint64_t)v9, "\"def\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outCreateCastStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"sourcetype\":{", a3, a4, a5, a6, a7, a8, v65);
    _outTypeName(a1, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v24) == 44)
      {
        *(_DWORD *)(a1 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    appendStringInfo(a1, "},", v16, v17, v18, v19, v20, v21, v66);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"targettype\":{", a3, a4, a5, a6, a7, a8, v65);
    _outTypeName(a1, *(void *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    int v38 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v38, 1);
    uint64_t v39 = (v38 - 1);
    if ((int)v39 < 0 == v23)
    {
      uint64_t v40 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v39) == 44)
      {
        *(_DWORD *)(a1 + 8) = v39;
        *(unsigned char *)(v40 + v39) = 0;
      }
    }
    appendStringInfo(a1, "},", v32, v33, v34, v35, v36, v37, v67);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"func\":{", a3, a4, a5, a6, a7, a8, v65);
    _outObjectWithArgs(a1, *(void *)(a2 + 24), v41, v42, v43, v44, v45, v46);
    int v53 = *(_DWORD *)(a1 + 8);
    BOOL v23 = __OFSUB__(v53, 1);
    uint64_t v54 = (v53 - 1);
    if ((int)v54 < 0 == v23)
    {
      uint64_t v55 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v54) == 44)
      {
        *(_DWORD *)(a1 + 8) = v54;
        *(unsigned char *)(v55 + v54) = 0;
      }
    }
    appendStringInfo(a1, "},", v47, v48, v49, v50, v51, v52, v68);
  }
  uint64_t v56 = *(int *)(a2 + 32);
  if (v56 > 2) {
    BOOL v57 = 0;
  }
  else {
    BOOL v57 = (&off_1E55D9500)[v56];
  }
  unint64_t result = appendStringInfo(a1, "\"context\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v57);
  if (*(unsigned char *)(a2 + 36)) {
    return appendStringInfo(a1, "\"inout\":%s,", v59, v60, v61, v62, v63, v64, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateOpClassStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"opclassname\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v75);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v76);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"amname\":", a3, a4, a5, a6, a7, a8, v74);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v77);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"datatype\":{", a3, a4, a5, a6, a7, a8, v74);
    _outTypeName((uint64_t)v9, *(void *)(a2 + 32), v46, v47, v48, v49, v50, v51);
    int v58 = v9[2];
    BOOL v59 = __OFSUB__(v58, 1);
    uint64_t v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      uint64_t v61 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v60) == 44)
      {
        void v9[2] = v60;
        *(unsigned char *)(v61 + v6errstart(20, 0) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v52, v53, v54, v55, v56, v57, v78);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"items\":", a3, a4, a5, a6, a7, a8, v74);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v68 = *(void *)(a2 + 40);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      uint64_t v69 = 0;
      uint64_t v70 = 8;
      do
      {
        uint64_t v71 = *(void *)(v68 + 16);
        uint64_t v72 = *(void *)(v71 + 8 * v69);
        if (v72) {
          _outNode(v9, v72);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v71 + v70) {
          BOOL v73 = v71 + v70 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v73 = 1;
        }
        if (!v73) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v62, v63, v64, v65, v66, v67, v79);
  }
  if (*(unsigned char *)(a2 + 48)) {
    return appendStringInfo((uint64_t)v9, "\"isDefault\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateOpFamilyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"amname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    return appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outAlterOpFamilyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"opfamilyname\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v48);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"amname\":", a3, a4, a5, a6, a7, a8, v47);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v49);
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"isDrop\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"items\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v41 = *(void *)(a2 + 32);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 8;
      do
      {
        uint64_t v44 = *(void *)(v41 + 16);
        uint64_t v45 = *(void *)(v44 + 8 * v42);
        if (v45) {
          _outNode(v10, v45);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v44 + v43) {
          BOOL v46 = v44 + v43 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v46 = 1;
        }
        if (!v46) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outPrepareStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v41);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v42);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"argtypes\":", a3, a4, a5, a6, a7, a8, v41);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, v43);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v41);
    _outNode(v10, *(void *)(a2 + 24));
    return appendStringInfo((uint64_t)v10, ",", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outExecuteStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"params\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outDeclareCursorStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"portalname\":", a3, a4, a5, a6, a7, a8, v29);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v30);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"options\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"query\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(void *)(a2 + 24));
    return appendStringInfo((uint64_t)v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateTableSpaceStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v64);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"owner\":{", a3, a4, a5, a6, a7, a8, v63);
    _outRoleSpec(v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v65);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"location\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 24), v39, v40, v41, v42, v43, v44);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v45, v46, v47, v48, v49, v50, v66);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v57 = *(void *)(a2 + 32);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 8;
      do
      {
        uint64_t v60 = *(void *)(v57 + 16);
        uint64_t v61 = *(void *)(v60 + 8 * v58);
        if (v61) {
          _outNode(v10, v61);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v60 + v59) {
          BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v62 = 1;
        }
        if (!v62) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, a9);
  }
  return result;
}

uint64_t _outDropTableSpaceStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    return appendStringInfo((uint64_t)v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterObjectDependsStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0x31) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9558)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v47);
    _outRangeVar(a1, *(void *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    int v31 = *(_DWORD *)(a1 + 8);
    BOOL v32 = __OFSUB__(v31, 1);
    uint64_t v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      uint64_t v34 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v33) == 44)
      {
        *(_DWORD *)(a1 + 8) = v33;
        *(unsigned char *)(v34 + v33) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "},", v25, v26, v27, v28, v29, v30, v48);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"object\":", v13, v14, v15, v16, v17, v18, v47);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v35, v36, v37, v38, v39, v40, v49);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"extname\":", v13, v14, v15, v16, v17, v18, v47);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo(a1, ",", v41, v42, v43, v44, v45, v46, v50);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo(a1, "\"remove\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterObjectSchemaStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0x31) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9558)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v13, v14, v15, v16, v17, v18, v53);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    int v31 = a1[2];
    BOOL v32 = __OFSUB__(v31, 1);
    uint64_t v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      uint64_t v34 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(unsigned char *)(v34 + v33) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v54);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v13, v14, v15, v16, v17, v18, v53);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v35, v36, v37, v38, v39, v40, v55);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newschema\":", v13, v14, v15, v16, v17, v18, v53);
    _outToken(a1, *(char **)(a2 + 24), v41, v42, v43, v44, v45, v46);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v47, v48, v49, v50, v51, v52, v56);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterOwnerStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 0x31) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9558)[v11];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objectType\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relation\":{", v14, v15, v16, v17, v18, v19, v57);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 8), v20, v21, v22, v23, v24, v25);
    int v32 = a1[2];
    BOOL v33 = __OFSUB__(v32, 1);
    uint64_t v34 = (v32 - 1);
    if ((int)v34 < 0 == v33)
    {
      uint64_t v35 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v34) == 44)
      {
        a1[2] = v34;
        *(unsigned char *)(v35 + v34) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "},", v26, v27, v28, v29, v30, v31, v58);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v57);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v36, v37, v38, v39, v40, v41, v59);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"newowner\":{", v14, v15, v16, v17, v18, v19, v57);
    _outRoleSpec(a1, *(void *)(a2 + 24), v42, v43, v44, v45, v46, v47);
    int v54 = a1[2];
    BOOL v33 = __OFSUB__(v54, 1);
    uint64_t v55 = (v54 - 1);
    if ((int)v55 < 0 == v33)
    {
      uint64_t v56 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v55) == 44)
      {
        a1[2] = v55;
        *(unsigned char *)(v56 + v55) = 0;
      }
    }
    return appendStringInfo((uint64_t)a1, "},", v48, v49, v50, v51, v52, v53, a9);
  }
  return result;
}

uint64_t _outAlterOperatorStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"opername\":{", a3, a4, a5, a6, a7, a8, v39);
    _outObjectWithArgs(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = *(void *)(a2 + 16);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outAlterTypeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outDropOwnedStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"roles\":", a3, a4, a5, a6, a7, a8, v26);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v27);
  }
  int v22 = *(_DWORD *)(a2 + 16);
  uint64_t v23 = "DROP_CASCADE";
  if (v22 != 1) {
    uint64_t v23 = 0;
  }
  if (v22) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = "DROP_RESTRICT";
  }
  return appendStringInfo(a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

uint64_t _outReassignOwnedStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"roles\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v11, v12, v13, v14, v15, v16, v40);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"newrole\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRoleSpec(v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, a9);
  }
  return result;
}

uint64_t _outCompositeTypeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"typevar\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRangeVar(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"coldeflist\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = *(void *)(a2 + 16);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outCreateEnumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"vals\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateRangeStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"params\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outAlterEnumStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"typeName\":", a3, a4, a5, a6, a7, a8, v58);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v59);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"oldVal\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v60);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"newVal\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 24), v34, v35, v36, v37, v38, v39);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"newValNeighbor\":", a3, a4, a5, a6, a7, a8, v58);
    _outToken(v9, *(char **)(a2 + 32), v46, v47, v48, v49, v50, v51);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v52, v53, v54, v55, v56, v57, v62);
  }
  if (*(unsigned char *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"newValIsAfter\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 41)) {
    return appendStringInfo((uint64_t)v9, "\"skipIfNewValExists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outAlterTSDictionaryStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"dictname\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar(v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString(v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo(v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outAlterTSConfigurationStmt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 4) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9518)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"cfgname\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v56);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"tokentype\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v37 = *(void *)(a2 + 16);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString(a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v31, v32, v33, v34, v35, v36, v57);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"dicts\":", v13, v14, v15, v16, v17, v18, v55);
    appendStringInfoChar(a1, 91);
    uint64_t v49 = *(void *)(a2 + 24);
    if (v49 && *(int *)(v49 + 4) >= 1)
    {
      uint64_t v50 = 0;
      uint64_t v51 = 8;
      do
      {
        uint64_t v52 = *(void *)(v49 + 16);
        uint64_t v53 = *(void *)(v52 + 8 * v50);
        if (v53) {
          _outNode(a1, v53);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v52 + v51) {
          BOOL v54 = v52 + v51 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v54 = 1;
        }
        if (!v54) {
          appendStringInfoString(a1, ",");
        }
        ++v50;
        v51 += 8;
      }
      while (v50 < *(int *)(v49 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v43, v44, v45, v46, v47, v48, v58);
  }
  if (*(unsigned char *)(a2 + 32)) {
    unint64_t result = appendStringInfo(a1, "\"override\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 33)) {
    unint64_t result = appendStringInfo(a1, "\"replace\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 34)) {
    return appendStringInfo(a1, "\"missing_ok\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateFdwStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"fdwname\":", a3, a4, a5, a6, a7, a8, v47);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v48);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"func_options\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, v49);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v47);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v41 = *(void *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 8;
      do
      {
        uint64_t v44 = *(void *)(v41 + 16);
        uint64_t v45 = *(void *)(v44 + 8 * v42);
        if (v45) {
          _outNode(v10, v45);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v44 + v43) {
          BOOL v46 = v44 + v43 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v46 = 1;
        }
        if (!v46) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, a9);
  }
  return result;
}

uint64_t _outCreateForeignServerStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"servername\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v72);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servertype\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v73);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"version\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 24), v35, v36, v37, v38, v39, v40);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v41, v42, v43, v44, v45, v46, v74);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"fdwname\":", a3, a4, a5, a6, a7, a8, v71);
    _outToken(v10, *(char **)(a2 + 32), v47, v48, v49, v50, v51, v52);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v53, v54, v55, v56, v57, v58, v75);
  }
  if (*(unsigned char *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v71);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v65 = *(void *)(a2 + 48);
    if (v65 && *(int *)(v65 + 4) >= 1)
    {
      uint64_t v66 = 0;
      uint64_t v67 = 8;
      do
      {
        uint64_t v68 = *(void *)(v65 + 16);
        uint64_t v69 = *(void *)(v68 + 8 * v66);
        if (v69) {
          _outNode(v10, v69);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v68 + v67) {
          BOOL v70 = v68 + v67 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v70 = 1;
        }
        if (!v70) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v66;
        v67 += 8;
      }
      while (v66 < *(int *)(v65 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v59, v60, v61, v62, v63, v64, a9);
  }
  return result;
}

uint64_t _outAlterForeignServerStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"servername\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v47);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"version\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v48);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)v9, "\"has_version\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outCreateUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v51);
    _outRoleSpec(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v52);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servername\":", a3, a4, a5, a6, a7, a8, v51);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v53);
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v45 = *(void *)(a2 + 32);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outAlterUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v51);
    _outRoleSpec(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v52);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"servername\":", a3, a4, a5, a6, a7, a8, v51);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v53);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v45 = *(void *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outDropUserMappingStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"user\":{", a3, a4, a5, a6, a7, a8, v38);
    _outRoleSpec(v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = v9[2];
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        void v9[2] = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v16, v17, v18, v19, v20, v21, v39);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"servername\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(v9, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v32, v33, v34, v35, v36, v37, v40);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outAlterTableSpaceOptionsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"tablespacename\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"isReset\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterTableMoveAllStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"orig_tablespacename\":", a3, a4, a5, a6, a7, a8, v55);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v56);
  }
  uint64_t v22 = *(int *)(a2 + 16);
  if (v22 > 0x31) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (&off_1E55D9558)[v22];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"roles\":", v25, v26, v27, v28, v29, v30, v57);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v37 = *(void *)(a2 + 24);
    if (v37 && *(int *)(v37 + 4) >= 1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 8;
      do
      {
        uint64_t v40 = *(void *)(v37 + 16);
        uint64_t v41 = *(void *)(v40 + 8 * v38);
        if (v41) {
          _outNode(a1, v41);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v40 + v39) {
          BOOL v42 = v40 + v39 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v42 = 1;
        }
        if (!v42) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v38;
        v39 += 8;
      }
      while (v38 < *(int *)(v37 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v31, v32, v33, v34, v35, v36, v58);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"new_tablespacename\":", v25, v26, v27, v28, v29, v30, v57);
    _outToken(a1, *(char **)(a2 + 32), v43, v44, v45, v46, v47, v48);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v49, v50, v51, v52, v53, v54, v59);
  }
  if (*(unsigned char *)(a2 + 40)) {
    return appendStringInfo((uint64_t)a1, "\"nowait\":%s,", v25, v26, v27, v28, v29, v30, (size_t)"true");
  }
  return result;
}

unint64_t _outSecLabelStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 0x31) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9558)[v11];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v14, v15, v16, v17, v18, v19, v50);
    _outNode(a1, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v20, v21, v22, v23, v24, v25, v51);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"provider\":", v14, v15, v16, v17, v18, v19, v50);
    _outToken(a1, *(char **)(a2 + 16), v26, v27, v28, v29, v30, v31);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, v52);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"label\":", v14, v15, v16, v17, v18, v19, v50);
    _outToken(a1, *(char **)(a2 + 24), v38, v39, v40, v41, v42, v43);
    return appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, a9);
  }
  return result;
}

unint64_t _outCreateForeignTableStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  appendStringInfo((uint64_t)a1, "\"base\":{", a3, a4, a5, a6, a7, a8, v58);
  _outCreateStmt(a1, a2, v11, v12, v13, v14, v15, v16);
  int v23 = a1[2];
  BOOL v24 = __OFSUB__(v23, 1);
  uint64_t v25 = (v23 - 1);
  if ((int)v25 < 0 == v24)
  {
    uint64_t v26 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v25) == 44)
    {
      a1[2] = v25;
      *(unsigned char *)(v26 + v25) = 0;
    }
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "},", v17, v18, v19, v20, v21, v22, v59);
  if (*(void *)(a2 + 104))
  {
    appendStringInfo((uint64_t)a1, "\"servername\":", v28, v29, v30, v31, v32, v33, v60);
    _outToken(a1, *(char **)(a2 + 104), v34, v35, v36, v37, v38, v39);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v40, v41, v42, v43, v44, v45, v61);
  }
  if (*(void *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v28, v29, v30, v31, v32, v33, v60);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v52 = *(void *)(a2 + 112);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(a1, v56);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 112) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 112) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v46, v47, v48, v49, v50, v51, a9);
  }
  return result;
}

unint64_t _outImportForeignSchemaStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"server_name\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v81);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"remote_schema\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    appendStringInfo((uint64_t)a1, ",", v29, v30, v31, v32, v33, v34, v82);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"local_schema\":", a3, a4, a5, a6, a7, a8, v80);
    _outToken(a1, *(char **)(a2 + 24), v35, v36, v37, v38, v39, v40);
    appendStringInfo((uint64_t)a1, ",", v41, v42, v43, v44, v45, v46, v83);
  }
  uint64_t v47 = *(int *)(a2 + 32);
  if (v47 > 2) {
    uint64_t v48 = 0;
  }
  else {
    uint64_t v48 = (&off_1E55D9540)[v47];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"list_type\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v48);
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"table_list\":", v50, v51, v52, v53, v54, v55, v84);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v62 = *(void *)(a2 + 40);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      uint64_t v63 = 0;
      uint64_t v64 = 8;
      do
      {
        uint64_t v65 = *(void *)(v62 + 16);
        uint64_t v66 = *(void *)(v65 + 8 * v63);
        if (v66) {
          _outNode(a1, v66);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v65 + v64) {
          BOOL v67 = v65 + v64 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v56, v57, v58, v59, v60, v61, v85);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v50, v51, v52, v53, v54, v55, v84);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v74 = *(void *)(a2 + 48);
    if (v74 && *(int *)(v74 + 4) >= 1)
    {
      uint64_t v75 = 0;
      uint64_t v76 = 8;
      do
      {
        uint64_t v77 = *(void *)(v74 + 16);
        uint64_t v78 = *(void *)(v77 + 8 * v75);
        if (v78) {
          _outNode(a1, v78);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v77 + v76) {
          BOOL v79 = v77 + v76 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v79 = 1;
        }
        if (!v79) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v75;
        v76 += 8;
      }
      while (v75 < *(int *)(v74 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v68, v69, v70, v71, v72, v73, a9);
  }
  return result;
}

uint64_t _outCreateExtensionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"extname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 24);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outAlterExtensionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"extname\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outAlterExtensionContentsStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"extname\":", a3, a4, a5, a6, a7, a8, v38);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v39);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo((uint64_t)a1, "\"action\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  uint64_t v23 = *(int *)(a2 + 20);
  if (v23 > 0x31) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = (&off_1E55D9558)[v23];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"objtype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"object\":", v26, v27, v28, v29, v30, v31, v40);
    _outNode(a1, *(void *)(a2 + 24));
    return appendStringInfo((uint64_t)a1, ",", v32, v33, v34, v35, v36, v37, a9);
  }
  return result;
}

uint64_t _outCreateEventTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v60);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"eventname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v61);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"whenclause\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v41 = *(void *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 8;
      do
      {
        uint64_t v44 = *(void *)(v41 + 16);
        uint64_t v45 = *(void *)(v44 + 8 * v42);
        if (v45) {
          _outNode(v10, v45);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v44 + v43) {
          BOOL v46 = v44 + v43 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v46 = 1;
        }
        if (!v46) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, v62);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"funcname\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v53 = *(void *)(a2 + 32);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      uint64_t v54 = 0;
      uint64_t v55 = 8;
      do
      {
        uint64_t v56 = *(void *)(v53 + 16);
        uint64_t v57 = *(void *)(v56 + 8 * v54);
        if (v57) {
          _outNode(v10, v57);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v56 + v55) {
          BOOL v58 = v56 + v55 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v58 = 1;
        }
        if (!v58) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v54;
        v55 += 8;
      }
      while (v54 < *(int *)(v53 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

uint64_t _outAlterEventTrigStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"trigname\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    return appendStringInfo((uint64_t)v9, "\"tgenabled\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 16));
  }
  return result;
}

uint64_t _outRefreshMatViewStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"concurrent\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 5)) {
    unint64_t result = appendStringInfo(v10, "\"skipData\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"relation\":{", a3, a4, a5, a6, a7, a8, v27);
    _outRangeVar(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    return appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outReplicaIdentityStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"identity_type\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v10, "\"name\":", a3, a4, a5, a6, a7, a8, v23);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    return appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

unint64_t _outAlterSystemStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = (int *)result;
    appendStringInfo(result, "\"setstmt\":{", a3, a4, a5, a6, a7, a8, v27);
    _outVariableSetStmt(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outCreatePolicyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"policy_name\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v76);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"table\":{", a3, a4, a5, a6, a7, a8, v75);
    _outRangeVar((uint64_t)v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v77);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"cmd_name\":", a3, a4, a5, a6, a7, a8, v75);
    _outToken(v10, *(char **)(a2 + 24), v39, v40, v41, v42, v43, v44);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v45, v46, v47, v48, v49, v50, v78);
  }
  if (*(unsigned char *)(a2 + 32)) {
    unint64_t result = appendStringInfo((uint64_t)v10, "\"permissive\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"roles\":", a3, a4, a5, a6, a7, a8, v75);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v57 = *(void *)(a2 + 40);
    if (v57 && *(int *)(v57 + 4) >= 1)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 8;
      do
      {
        uint64_t v60 = *(void *)(v57 + 16);
        uint64_t v61 = *(void *)(v60 + 8 * v58);
        if (v61) {
          _outNode(v10, v61);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v60 + v59) {
          BOOL v62 = v60 + v59 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v62 = 1;
        }
        if (!v62) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v58;
        v59 += 8;
      }
      while (v58 < *(int *)(v57 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v51, v52, v53, v54, v55, v56, v79);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v10, "\"qual\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(void *)(a2 + 48));
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v63, v64, v65, v66, v67, v68, v80);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v10, "\"with_check\":", a3, a4, a5, a6, a7, a8, v75);
    _outNode(v10, *(void *)(a2 + 56));
    return appendStringInfo((uint64_t)v10, ",", v69, v70, v71, v72, v73, v74, a9);
  }
  return result;
}

uint64_t _outAlterPolicyStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"policy_name\":", a3, a4, a5, a6, a7, a8, v63);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v64);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"table\":{", a3, a4, a5, a6, a7, a8, v63);
    _outRangeVar((uint64_t)v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = v10[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        void v10[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v29, v30, v31, v32, v33, v34, v65);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"roles\":", a3, a4, a5, a6, a7, a8, v63);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v45 = *(void *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v39, v40, v41, v42, v43, v44, v66);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"qual\":", a3, a4, a5, a6, a7, a8, v63);
    _outNode(v10, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v51, v52, v53, v54, v55, v56, v67);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v10, "\"with_check\":", a3, a4, a5, a6, a7, a8, v63);
    _outNode(v10, *(void *)(a2 + 40));
    return appendStringInfo((uint64_t)v10, ",", v57, v58, v59, v60, v61, v62, a9);
  }
  return result;
}

uint64_t _outCreateTransformStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"replace\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)v10, "\"type_name\":{", a3, a4, a5, a6, a7, a8, v69);
    _outTypeName((uint64_t)v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = v10[2];
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        void v10[2] = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v17, v18, v19, v20, v21, v22, v70);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"lang\":", a3, a4, a5, a6, a7, a8, v69);
    _outToken(v10, *(char **)(a2 + 16), v27, v28, v29, v30, v31, v32);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v33, v34, v35, v36, v37, v38, v71);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"fromsql\":{", a3, a4, a5, a6, a7, a8, v69);
    _outObjectWithArgs((uint64_t)v10, *(void *)(a2 + 24), v39, v40, v41, v42, v43, v44);
    int v51 = v10[2];
    BOOL v24 = __OFSUB__(v51, 1);
    uint64_t v52 = (v51 - 1);
    if ((int)v52 < 0 == v24)
    {
      uint64_t v53 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v52) == 44)
      {
        void v10[2] = v52;
        *(unsigned char *)(v53 + v52) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "},", v45, v46, v47, v48, v49, v50, v72);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"tosql\":{", a3, a4, a5, a6, a7, a8, v69);
    _outObjectWithArgs((uint64_t)v10, *(void *)(a2 + 32), v54, v55, v56, v57, v58, v59);
    int v66 = v10[2];
    BOOL v24 = __OFSUB__(v66, 1);
    uint64_t v67 = (v66 - 1);
    if ((int)v67 < 0 == v24)
    {
      uint64_t v68 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v67) == 44)
      {
        void v10[2] = v67;
        *(unsigned char *)(v68 + v67) = 0;
      }
    }
    return appendStringInfo((uint64_t)v10, "},", v60, v61, v62, v63, v64, v65, a9);
  }
  return result;
}

uint64_t _outCreateAmStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"amname\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"handler_name\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"amtype\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 24));
  }
  return result;
}

uint64_t _outCreatePublicationStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"pubname\":", a3, a4, a5, a6, a7, a8, v46);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v47);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"options\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"tables\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)v9, "\"for_all_tables\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterPublicationStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"pubname\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v50);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", a3, a4, a5, a6, a7, a8, v49);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(a1, v32);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v22, v23, v24, v25, v26, v27, v51);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"tables\":", a3, a4, a5, a6, a7, a8, v49);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(a1, v44);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v34, v35, v36, v37, v38, v39, v52);
  }
  if (*(unsigned char *)(a2 + 32)) {
    appendStringInfo((uint64_t)a1, "\"for_all_tables\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  uint64_t v46 = *(int *)(a2 + 36);
  if (v46 > 3) {
    size_t v47 = 0;
  }
  else {
    size_t v47 = (&off_1E55D9838)[v46];
  }
  return appendStringInfo((uint64_t)a1, "\"tableAction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v47);
}

uint64_t _outCreateSubscriptionStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"subname\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v60);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"conninfo\":", a3, a4, a5, a6, a7, a8, v59);
    _outToken(v10, *(char **)(a2 + 16), v23, v24, v25, v26, v27, v28);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v29, v30, v31, v32, v33, v34, v61);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v10, "\"publication\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v41 = *(void *)(a2 + 24);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 8;
      do
      {
        uint64_t v44 = *(void *)(v41 + 16);
        uint64_t v45 = *(void *)(v44 + 8 * v42);
        if (v45) {
          _outNode(v10, v45);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v44 + v43) {
          BOOL v46 = v44 + v43 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v46 = 1;
        }
        if (!v46) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v10, "],", v35, v36, v37, v38, v39, v40, v62);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v10, "\"options\":", a3, a4, a5, a6, a7, a8, v59);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v53 = *(void *)(a2 + 32);
    if (v53 && *(int *)(v53 + 4) >= 1)
    {
      uint64_t v54 = 0;
      uint64_t v55 = 8;
      do
      {
        uint64_t v56 = *(void *)(v53 + 16);
        uint64_t v57 = *(void *)(v56 + 8 * v54);
        if (v57) {
          _outNode(v10, v57);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v56 + v55) {
          BOOL v58 = v56 + v55 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v58 = 1;
        }
        if (!v58) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v54;
        v55 += 8;
      }
      while (v54 < *(int *)(v53 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

unint64_t _outAlterSubscriptionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 4) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D96E8)[v11];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", v14, v15, v16, v17, v18, v19, v68);
    _outToken(a1, *(char **)(a2 + 8), v20, v21, v22, v23, v24, v25);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v26, v27, v28, v29, v30, v31, v69);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"conninfo\":", v14, v15, v16, v17, v18, v19, v68);
    _outToken(a1, *(char **)(a2 + 16), v32, v33, v34, v35, v36, v37);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v38, v39, v40, v41, v42, v43, v70);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"publication\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v50 = *(void *)(a2 + 24);
    if (v50 && *(int *)(v50 + 4) >= 1)
    {
      uint64_t v51 = 0;
      uint64_t v52 = 8;
      do
      {
        uint64_t v53 = *(void *)(v50 + 16);
        uint64_t v54 = *(void *)(v53 + 8 * v51);
        if (v54) {
          _outNode(a1, v54);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v53 + v52) {
          BOOL v55 = v53 + v52 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v55 = 1;
        }
        if (!v55) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v51;
        v52 += 8;
      }
      while (v51 < *(int *)(v50 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v44, v45, v46, v47, v48, v49, v71);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v14, v15, v16, v17, v18, v19, v68);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v62 = *(void *)(a2 + 32);
    if (v62 && *(int *)(v62 + 4) >= 1)
    {
      uint64_t v63 = 0;
      uint64_t v64 = 8;
      do
      {
        uint64_t v65 = *(void *)(v62 + 16);
        uint64_t v66 = *(void *)(v65 + 8 * v63);
        if (v66) {
          _outNode(a1, v66);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v65 + v64) {
          BOOL v67 = v65 + v64 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v67 = 1;
        }
        if (!v67) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v63;
        v64 += 8;
      }
      while (v63 < *(int *)(v62 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v56, v57, v58, v59, v60, v61, a9);
  }
  return result;
}

unint64_t _outDropSubscriptionStmt(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"subname\":", a3, a4, a5, a6, a7, a8, v26);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v27);
  }
  if (*(unsigned char *)(a2 + 16)) {
    appendStringInfo((uint64_t)a1, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  int v22 = *(_DWORD *)(a2 + 20);
  uint64_t v23 = "DROP_CASCADE";
  if (v22 != 1) {
    uint64_t v23 = 0;
  }
  if (v22) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = "DROP_RESTRICT";
  }
  return appendStringInfo((uint64_t)a1, "\"behavior\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v24);
}

uint64_t _outCreateStatsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"defnames\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v71);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"stat_types\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v72);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"exprs\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"relations\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(v9, v56);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"stxcomment\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 40), v58, v59, v60, v61, v62, v63);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v75);
  }
  if (*(unsigned char *)(a2 + 48)) {
    return appendStringInfo((uint64_t)v9, "\"if_not_exists\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outAlterCollationStmt(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v10 = result;
    appendStringInfo(result, "\"collname\":", a3, a4, a5, a6, a7, a8, v23);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    return appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, a9);
  }
  return result;
}

uint64_t _outCallStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"funccall\":{", a3, a4, a5, a6, a7, a8, v42);
    _outFuncCall(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v43);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"funcexpr\":{", a3, a4, a5, a6, a7, a8, v42);
    _outFuncExpr(v10, *(void *)(a2 + 16), v27, v28, v29, v30, v31, v32);
    int v39 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v39, 1);
    uint64_t v40 = (v39 - 1);
    if ((int)v40 < 0 == v24)
    {
      uint64_t v41 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v40) == 44)
      {
        *(_DWORD *)(v10 + 8) = v40;
        *(unsigned char *)(v41 + v4errstart(20, 0) = 0;
      }
    }
    return appendStringInfo(v10, "},", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t _outAlterStatsStmt(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"defnames\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"stxstattarget\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(unsigned char *)(a2 + 20)) {
    return appendStringInfo(v9, "\"missing_ok\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outAExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0xF) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9710)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"name\":", v13, v14, v15, v16, v17, v18, v43);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v44);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"lexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(a1, ",", v31, v32, v33, v34, v35, v36, v45);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"rexpr\":", v13, v14, v15, v16, v17, v18, v43);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo(a1, ",", v37, v38, v39, v40, v41, v42, v46);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 32));
  }
  return result;
}

uint64_t _outColumnRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"fields\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outParamRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"number\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  return result;
}

unint64_t _outAConst(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  appendStringInfo(a1, "\"val\":", a3, a4, a5, a6, a7, a8, v23);
  _outNode(a1, a2 + 8);
  unint64_t result = appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v24);
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(a1, "\"location\":%d,", v17, v18, v19, v20, v21, v22, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outFuncCall(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"funcname\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v69);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v70);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"agg_order\":", a3, a4, a5, a6, a7, a8, v68);
    appendStringInfoChar(v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v71);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"agg_filter\":", a3, a4, a5, a6, a7, a8, v68);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo(v9, ",", v46, v47, v48, v49, v50, v51, v72);
  }
  if (*(unsigned char *)(a2 + 40)) {
    unint64_t result = appendStringInfo(v9, "\"agg_within_group\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 41)) {
    unint64_t result = appendStringInfo(v9, "\"agg_star\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 42)) {
    unint64_t result = appendStringInfo(v9, "\"agg_distinct\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 43)) {
    unint64_t result = appendStringInfo(v9, "\"func_variadic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(v9, "\"over\":{", a3, a4, a5, a6, a7, a8, v68);
    _outWindowDef(v9, *(void *)(a2 + 48), v52, v53, v54, v55, v56, v57);
    int v64 = *(_DWORD *)(v9 + 8);
    BOOL v65 = __OFSUB__(v64, 1);
    uint64_t v66 = (v64 - 1);
    if ((int)v66 < 0 == v65)
    {
      uint64_t v67 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v66) == 44)
      {
        *(_DWORD *)(v9 + 8) = v66;
        *(unsigned char *)(v67 + v66) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v58, v59, v60, v61, v62, v63, v73);
  }
  if (*(_DWORD *)(a2 + 56)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 56));
  }
  return result;
}

uint64_t _outAIndices(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"is_slice\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"lidx\":", a3, a4, a5, a6, a7, a8, v23);
    _outNode(v10, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v24);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"uidx\":", a3, a4, a5, a6, a7, a8, v23);
    _outNode(v10, *(void *)(a2 + 16));
    return appendStringInfo(v10, ",", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outAIndirection(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"indirection\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    uint64_t v23 = *(void *)(a2 + 16);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 8;
      do
      {
        uint64_t v26 = *(void *)(v23 + 16);
        uint64_t v27 = *(void *)(v26 + 8 * v24);
        if (v27) {
          _outNode(v10, v27);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v26 + v25) {
          BOOL v28 = v26 + v25 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v28 = 1;
        }
        if (!v28) {
          appendStringInfoString(v10, ",");
        }
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    return appendStringInfo(v10, "],", v17, v18, v19, v20, v21, v22, a9);
  }
  return result;
}

uint64_t _outAArrayExpr(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"elements\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outResTarget(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v40);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v41);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"indirection\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v42);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"val\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v34, v35, v36, v37, v38, v39, v43);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  return result;
}

uint64_t _outMultiAssignRef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"source\":", a3, a4, a5, a6, a7, a8, v16);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v17);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"colno\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"ncolumns\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

uint64_t _outTypeCast(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v32);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v33);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v32);
    _outTypeName(v9, *(void *)(a2 + 16), v16, v17, v18, v19, v20, v21);
    int v28 = *(_DWORD *)(v9 + 8);
    BOOL v29 = __OFSUB__(v28, 1);
    uint64_t v30 = (v28 - 1);
    if ((int)v30 < 0 == v29)
    {
      uint64_t v31 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v30) == 44)
      {
        *(_DWORD *)(v9 + 8) = v30;
        *(unsigned char *)(v31 + v3errstart(20, 0) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v22, v23, v24, v25, v26, v27, v34);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outCollateClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"arg\":", a3, a4, a5, a6, a7, a8, v28);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v29);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"collname\":", a3, a4, a5, a6, a7, a8, v28);
    appendStringInfoChar(v9, 91);
    uint64_t v22 = *(void *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 8;
      do
      {
        uint64_t v25 = *(void *)(v22 + 16);
        uint64_t v26 = *(void *)(v25 + 8 * v23);
        if (v26) {
          _outNode(v9, v26);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v25 + v24) {
          BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v27 = 1;
        }
        if (!v27) {
          appendStringInfoString(v9, ",");
        }
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v30);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

unint64_t _outSortBy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"node\":", a3, a4, a5, a6, a7, a8, v45);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v10, v11, v12, v13, v14, v15, v46);
  }
  uint64_t v16 = *(int *)(a2 + 16);
  if (v16 > 3) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = (&off_1E55D9790)[v16];
  }
  appendStringInfo(a1, "\"sortby_dir\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v17);
  uint64_t v24 = *(int *)(a2 + 20);
  if (v24 > 2) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = (&off_1E55D97B0)[v24];
  }
  unint64_t result = appendStringInfo(a1, "\"sortby_nulls\":\"%s\",", v18, v19, v20, v21, v22, v23, (size_t)v25);
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"useOp\":", v27, v28, v29, v30, v31, v32, v47);
    appendStringInfoChar(a1, 91);
    uint64_t v39 = *(void *)(a2 + 24);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      uint64_t v40 = 0;
      uint64_t v41 = 8;
      do
      {
        uint64_t v42 = *(void *)(v39 + 16);
        uint64_t v43 = *(void *)(v42 + 8 * v40);
        if (v43) {
          _outNode(a1, v43);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v42 + v41) {
          BOOL v44 = v42 + v41 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v44 = 1;
        }
        if (!v44) {
          appendStringInfoString(a1, ",");
        }
        ++v40;
        v41 += 8;
      }
      while (v40 < *(int *)(v39 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v33, v34, v35, v36, v37, v38, v48);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v27, v28, v29, v30, v31, v32, *(unsigned int *)(a2 + 32));
  }
  return result;
}

uint64_t _outWindowDef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v71);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"refname\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v72);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"partitionClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"orderClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(v9, v56);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(_DWORD *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"frameOptions\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"startOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(void *)(a2 + 48));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v58, v59, v60, v61, v62, v63, v75);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"endOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(void *)(a2 + 56));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v76);
  }
  if (*(_DWORD *)(a2 + 64)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 64));
  }
  return result;
}

uint64_t _outRangeSubselect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"subquery\":", a3, a4, a5, a6, a7, a8, v33);
    _outNode(v10, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v10, ",", v11, v12, v13, v14, v15, v16, v34);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"alias\":{", a3, a4, a5, a6, a7, a8, v33);
    _outAlias(v10, *(void *)(a2 + 16), v17, v18, v19, v20, v21, v22, v35);
    int v29 = *(_DWORD *)(v10 + 8);
    BOOL v30 = __OFSUB__(v29, 1);
    uint64_t v31 = (v29 - 1);
    if ((int)v31 < 0 == v30)
    {
      uint64_t v32 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v31) == 44)
      {
        *(_DWORD *)(v10 + 8) = v31;
        *(unsigned char *)(v32 + v31) = 0;
      }
    }
    return appendStringInfo(v10, "},", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outRangeFunction(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 5)) {
    unint64_t result = appendStringInfo(v10, "\"ordinality\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 6)) {
    unint64_t result = appendStringInfo(v10, "\"is_rowsfrom\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"functions\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v52);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"alias\":{", a3, a4, a5, a6, a7, a8, v51);
    _outAlias(v10, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28, v53);
    int v35 = *(_DWORD *)(v10 + 8);
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v37) == 44)
      {
        *(_DWORD *)(v10 + 8) = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v29, v30, v31, v32, v33, v34, v54);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v10, "\"coldeflist\":", a3, a4, a5, a6, a7, a8, v51);
    appendStringInfoChar(v10, 91);
    uint64_t v45 = *(void *)(a2 + 24);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString(v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    return appendStringInfo(v10, "],", v39, v40, v41, v42, v43, v44, a9);
  }
  return result;
}

uint64_t _outRangeTableSample(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":", a3, a4, a5, a6, a7, a8, v46);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"method\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v22 = *(void *)(a2 + 16);
    if (v22 && *(int *)(v22 + 4) >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 8;
      do
      {
        uint64_t v25 = *(void *)(v22 + 16);
        uint64_t v26 = *(void *)(v25 + 8 * v23);
        if (v26) {
          _outNode(v9, v26);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v25 + v24) {
          BOOL v27 = v25 + v24 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v27 = 1;
        }
        if (!v27) {
          appendStringInfoString(v9, ",");
        }
        ++v23;
        v24 += 8;
      }
      while (v23 < *(int *)(v22 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v16, v17, v18, v19, v20, v21, v48);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"args\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v34 = *(void *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      uint64_t v35 = 0;
      uint64_t v36 = 8;
      do
      {
        uint64_t v37 = *(void *)(v34 + 16);
        uint64_t v38 = *(void *)(v37 + 8 * v35);
        if (v38) {
          _outNode(v9, v38);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v37 + v36) {
          BOOL v39 = v37 + v36 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v39 = 1;
        }
        if (!v39) {
          appendStringInfoString(v9, ",");
        }
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v28, v29, v30, v31, v32, v33, v49);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"repeatable\":", a3, a4, a5, a6, a7, a8, v46);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo(v9, ",", v40, v41, v42, v43, v44, v45, v50);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  return result;
}

uint64_t _outRangeTableFunc(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"lateral\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v9, "\"docexpr\":", a3, a4, a5, a6, a7, a8, v62);
    _outNode(v9, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(v9, ",", v10, v11, v12, v13, v14, v15, v63);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"rowexpr\":", a3, a4, a5, a6, a7, a8, v62);
    _outNode(v9, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo(v9, ",", v16, v17, v18, v19, v20, v21, v64);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"namespaces\":", a3, a4, a5, a6, a7, a8, v62);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v65);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"columns\":", a3, a4, a5, a6, a7, a8, v62);
    appendStringInfoChar(v9, 91);
    uint64_t v40 = *(void *)(a2 + 32);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v66);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(v9, "\"alias\":{", a3, a4, a5, a6, a7, a8, v62);
    _outAlias(v9, *(void *)(a2 + 40), v46, v47, v48, v49, v50, v51, v67);
    int v58 = *(_DWORD *)(v9 + 8);
    BOOL v59 = __OFSUB__(v58, 1);
    uint64_t v60 = (v58 - 1);
    if ((int)v60 < 0 == v59)
    {
      uint64_t v61 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v60) == 44)
      {
        *(_DWORD *)(v9 + 8) = v60;
        *(unsigned char *)(v61 + v6errstart(20, 0) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v52, v53, v54, v55, v56, v57, v68);
  }
  if (*(_DWORD *)(a2 + 48)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  }
  return result;
}

uint64_t _outRangeTableFuncCol(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"colname\":", a3, a4, a5, a6, a7, a8, v50);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v51);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v50);
    _outTypeName((uint64_t)v9, *(void *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    int v34 = v9[2];
    BOOL v35 = __OFSUB__(v34, 1);
    uint64_t v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      uint64_t v37 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v36) == 44)
      {
        void v9[2] = v36;
        *(unsigned char *)(v37 + v36) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v52);
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"for_ordinality\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 25)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"is_not_null\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"colexpr\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v38, v39, v40, v41, v42, v43, v53);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"coldefexpr\":", a3, a4, a5, a6, a7, a8, v50);
    _outNode(v9, *(void *)(a2 + 40));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v54);
  }
  if (*(_DWORD *)(a2 + 48)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  }
  return result;
}

uint64_t _outTypeName(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"names\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"typeOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(unsigned char *)(a2 + 20)) {
    unint64_t result = appendStringInfo(v9, "\"setof\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 21)) {
    unint64_t result = appendStringInfo(v9, "\"pct_type\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"typmods\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(_DWORD *)(a2 + 32)) {
    unint64_t result = appendStringInfo(v9, "\"typemod\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(v9, "\"arrayBounds\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v40 = *(void *)(a2 + 40);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 48)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 48));
  }
  return result;
}

uint64_t _outColumnDef(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"colname\":", a3, a4, a5, a6, a7, a8, v104);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v105);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"typeName\":{", a3, a4, a5, a6, a7, a8, v104);
    _outTypeName((uint64_t)v9, *(void *)(a2 + 16), v22, v23, v24, v25, v26, v27);
    int v34 = v9[2];
    BOOL v35 = __OFSUB__(v34, 1);
    uint64_t v36 = (v34 - 1);
    if ((int)v36 < 0 == v35)
    {
      uint64_t v37 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v36) == 44)
      {
        void v9[2] = v36;
        *(unsigned char *)(v37 + v36) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v28, v29, v30, v31, v32, v33, v106);
  }
  if (*(_DWORD *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"inhcount\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  if (*(unsigned char *)(a2 + 28)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"is_local\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 29)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"is_not_null\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 30)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"is_from_type\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 31)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"storage\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 31));
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"raw_default\":", a3, a4, a5, a6, a7, a8, v104);
    _outNode(v9, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v38, v39, v40, v41, v42, v43, v107);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)v9, "\"cooked_default\":", a3, a4, a5, a6, a7, a8, v104);
    _outNode(v9, *(void *)(a2 + 40));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v44, v45, v46, v47, v48, v49, v108);
  }
  if (*(unsigned char *)(a2 + 48)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"identity\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 48));
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"identitySequence\":{", a3, a4, a5, a6, a7, a8, v104);
    _outRangeVar((uint64_t)v9, *(void *)(a2 + 56), v50, v51, v52, v53, v54, v55);
    int v62 = v9[2];
    BOOL v35 = __OFSUB__(v62, 1);
    uint64_t v63 = (v62 - 1);
    if ((int)v63 < 0 == v35)
    {
      uint64_t v64 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v63) == 44)
      {
        void v9[2] = v63;
        *(unsigned char *)(v64 + v63) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v56, v57, v58, v59, v60, v61, v109);
  }
  if (*(unsigned char *)(a2 + 64)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"generated\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 64));
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)v9, "\"collClause\":{", a3, a4, a5, a6, a7, a8, v104);
    _outCollateClause((uint64_t)v9, *(void *)(a2 + 72), v65, v66, v67, v68, v69, v70);
    int v77 = v9[2];
    BOOL v35 = __OFSUB__(v77, 1);
    uint64_t v78 = (v77 - 1);
    if ((int)v78 < 0 == v35)
    {
      uint64_t v79 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v78) == 44)
      {
        void v9[2] = v78;
        *(unsigned char *)(v79 + v78) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "},", v71, v72, v73, v74, v75, v76, v110);
  }
  if (*(_DWORD *)(a2 + 80)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"collOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 80));
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfo((uint64_t)v9, "\"constraints\":", a3, a4, a5, a6, a7, a8, v104);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v86 = *(void *)(a2 + 88);
    if (v86 && *(int *)(v86 + 4) >= 1)
    {
      uint64_t v87 = 0;
      uint64_t v88 = 8;
      do
      {
        uint64_t v89 = *(void *)(v86 + 16);
        uint64_t v90 = *(void *)(v89 + 8 * v87);
        if (v90) {
          _outNode(v9, v90);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v89 + v88) {
          BOOL v91 = v89 + v88 >= (unint64_t)(*(void *)(*(void *)(a2 + 88) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 88) + 4));
        else {
          BOOL v91 = 1;
        }
        if (!v91) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v87;
        v88 += 8;
      }
      while (v87 < *(int *)(v86 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v80, v81, v82, v83, v84, v85, v111);
  }
  if (*(void *)(a2 + 96))
  {
    appendStringInfo((uint64_t)v9, "\"fdwoptions\":", a3, a4, a5, a6, a7, a8, v104);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v98 = *(void *)(a2 + 96);
    if (v98 && *(int *)(v98 + 4) >= 1)
    {
      uint64_t v99 = 0;
      uint64_t v100 = 8;
      do
      {
        uint64_t v101 = *(void *)(v98 + 16);
        uint64_t v102 = *(void *)(v101 + 8 * v99);
        if (v102) {
          _outNode(v9, v102);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v101 + v100) {
          BOOL v103 = v101 + v100 >= (unint64_t)(*(void *)(*(void *)(a2 + 96) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 96) + 4));
        else {
          BOOL v103 = 1;
        }
        if (!v103) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v99;
        v100 += 8;
      }
      while (v99 < *(int *)(v98 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v92, v93, v94, v95, v96, v97, v112);
  }
  if (*(_DWORD *)(a2 + 104)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 104));
  }
  return result;
}

unint64_t _outIndexElem(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v87);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v88);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"expr\":", a3, a4, a5, a6, a7, a8, v87);
    _outNode(a1, *(void *)(a2 + 16));
    appendStringInfo((uint64_t)a1, ",", v22, v23, v24, v25, v26, v27, v89);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"indexcolname\":", a3, a4, a5, a6, a7, a8, v87);
    _outToken(a1, *(char **)(a2 + 24), v28, v29, v30, v31, v32, v33);
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v90);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"collation\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v46 = *(void *)(a2 + 32);
    if (v46 && *(int *)(v46 + 4) >= 1)
    {
      uint64_t v47 = 0;
      uint64_t v48 = 8;
      do
      {
        uint64_t v49 = *(void *)(v46 + 16);
        uint64_t v50 = *(void *)(v49 + 8 * v47);
        if (v50) {
          _outNode(a1, v50);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v49 + v48) {
          BOOL v51 = v49 + v48 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v51 = 1;
        }
        if (!v51) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v47;
        v48 += 8;
      }
      while (v47 < *(int *)(v46 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v40, v41, v42, v43, v44, v45, v91);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"opclass\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v58 = *(void *)(a2 + 40);
    if (v58 && *(int *)(v58 + 4) >= 1)
    {
      uint64_t v59 = 0;
      uint64_t v60 = 8;
      do
      {
        uint64_t v61 = *(void *)(v58 + 16);
        uint64_t v62 = *(void *)(v61 + 8 * v59);
        if (v62) {
          _outNode(a1, v62);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v61 + v60) {
          BOOL v63 = v61 + v60 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v63 = 1;
        }
        if (!v63) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v59;
        v60 += 8;
      }
      while (v59 < *(int *)(v58 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v52, v53, v54, v55, v56, v57, v92);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)a1, "\"opclassopts\":", a3, a4, a5, a6, a7, a8, v87);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v70 = *(void *)(a2 + 48);
    if (v70 && *(int *)(v70 + 4) >= 1)
    {
      uint64_t v71 = 0;
      uint64_t v72 = 8;
      do
      {
        uint64_t v73 = *(void *)(v70 + 16);
        uint64_t v74 = *(void *)(v73 + 8 * v71);
        if (v74) {
          _outNode(a1, v74);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v73 + v72) {
          BOOL v75 = v73 + v72 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v75 = 1;
        }
        if (!v75) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v71;
        v72 += 8;
      }
      while (v71 < *(int *)(v70 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v64, v65, v66, v67, v68, v69, v93);
  }
  uint64_t v76 = *(int *)(a2 + 56);
  if (v76 > 3) {
    int v77 = 0;
  }
  else {
    int v77 = (&off_1E55D9790)[v76];
  }
  appendStringInfo((uint64_t)a1, "\"ordering\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v77);
  uint64_t v84 = *(int *)(a2 + 60);
  if (v84 > 2) {
    uint64_t v85 = 0;
  }
  else {
    uint64_t v85 = (&off_1E55D97B0)[v84];
  }
  return appendStringInfo((uint64_t)a1, "\"nulls_ordering\":\"%s\",", v78, v79, v80, v81, v82, v83, (size_t)v85);
}

unint64_t _outConstraint(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 0xD) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D97C8)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"contype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"conname\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v192);
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"deferrable\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 17)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"initdeferred\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 20)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 20));
  }
  if (*(unsigned char *)(a2 + 24)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"is_no_inherit\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"raw_expr\":", v13, v14, v15, v16, v17, v18, v191);
    _outNode(a1, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v31, v32, v33, v34, v35, v36, v193);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo((uint64_t)a1, "\"cooked_expr\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 40), v37, v38, v39, v40, v41, v42);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v43, v44, v45, v46, v47, v48, v194);
  }
  if (*(unsigned char *)(a2 + 48)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"generated_when\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 48));
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"keys\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v55 = *(void *)(a2 + 56);
    if (v55 && *(int *)(v55 + 4) >= 1)
    {
      uint64_t v56 = 0;
      uint64_t v57 = 8;
      do
      {
        uint64_t v58 = *(void *)(v55 + 16);
        uint64_t v59 = *(void *)(v58 + 8 * v56);
        if (v59) {
          _outNode(a1, v59);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v58 + v57) {
          BOOL v60 = v58 + v57 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v60 = 1;
        }
        if (!v60) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v56;
        v57 += 8;
      }
      while (v56 < *(int *)(v55 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v49, v50, v51, v52, v53, v54, v195);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"including\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v67 = *(void *)(a2 + 64);
    if (v67 && *(int *)(v67 + 4) >= 1)
    {
      uint64_t v68 = 0;
      uint64_t v69 = 8;
      do
      {
        uint64_t v70 = *(void *)(v67 + 16);
        uint64_t v71 = *(void *)(v70 + 8 * v68);
        if (v71) {
          _outNode(a1, v71);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v70 + v69) {
          BOOL v72 = v70 + v69 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v72 = 1;
        }
        if (!v72) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v68;
        v69 += 8;
      }
      while (v68 < *(int *)(v67 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v61, v62, v63, v64, v65, v66, v196);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"exclusions\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v79 = *(void *)(a2 + 72);
    if (v79 && *(int *)(v79 + 4) >= 1)
    {
      uint64_t v80 = 0;
      uint64_t v81 = 8;
      do
      {
        uint64_t v82 = *(void *)(v79 + 16);
        uint64_t v83 = *(void *)(v82 + 8 * v80);
        if (v83) {
          _outNode(a1, v83);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v82 + v81) {
          BOOL v84 = v82 + v81 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v84 = 1;
        }
        if (!v84) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v80;
        v81 += 8;
      }
      while (v80 < *(int *)(v79 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v73, v74, v75, v76, v77, v78, v197);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"options\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v91 = *(void *)(a2 + 80);
    if (v91 && *(int *)(v91 + 4) >= 1)
    {
      uint64_t v92 = 0;
      uint64_t v93 = 8;
      do
      {
        uint64_t v94 = *(void *)(v91 + 16);
        uint64_t v95 = *(void *)(v94 + 8 * v92);
        if (v95) {
          _outNode(a1, v95);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v94 + v93) {
          BOOL v96 = v94 + v93 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v96 = 1;
        }
        if (!v96) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v92;
        v93 += 8;
      }
      while (v92 < *(int *)(v91 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v85, v86, v87, v88, v89, v90, v198);
  }
  if (*(void *)(a2 + 88))
  {
    appendStringInfo((uint64_t)a1, "\"indexname\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 88), v97, v98, v99, v100, v101, v102);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v103, v104, v105, v106, v107, v108, v199);
  }
  if (*(void *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"indexspace\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 96), v109, v110, v111, v112, v113, v114);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v115, v116, v117, v118, v119, v120, v200);
  }
  if (*(unsigned char *)(a2 + 104)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"reset_default_tblspc\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(void *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"access_method\":", v13, v14, v15, v16, v17, v18, v191);
    _outToken(a1, *(char **)(a2 + 112), v121, v122, v123, v124, v125, v126);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v127, v128, v129, v130, v131, v132, v201);
  }
  if (*(void *)(a2 + 120))
  {
    appendStringInfo((uint64_t)a1, "\"where_clause\":", v13, v14, v15, v16, v17, v18, v191);
    _outNode(a1, *(void *)(a2 + 120));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v133, v134, v135, v136, v137, v138, v202);
  }
  if (*(void *)(a2 + 128))
  {
    appendStringInfo((uint64_t)a1, "\"pktable\":{", v13, v14, v15, v16, v17, v18, v191);
    _outRangeVar((uint64_t)a1, *(void *)(a2 + 128), v139, v140, v141, v142, v143, v144);
    int v151 = a1[2];
    BOOL v152 = __OFSUB__(v151, 1);
    uint64_t v153 = (v151 - 1);
    if ((int)v153 < 0 == v152)
    {
      uint64_t v154 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v153) == 44)
      {
        a1[2] = v153;
        *(unsigned char *)(v154 + v153) = 0;
      }
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "},", v145, v146, v147, v148, v149, v150, v203);
  }
  if (*(void *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"fk_attrs\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v161 = *(void *)(a2 + 136);
    if (v161 && *(int *)(v161 + 4) >= 1)
    {
      uint64_t v162 = 0;
      uint64_t v163 = 8;
      do
      {
        uint64_t v164 = *(void *)(v161 + 16);
        uint64_t v165 = *(void *)(v164 + 8 * v162);
        if (v165) {
          _outNode(a1, v165);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v164 + v163) {
          BOOL v166 = v164 + v163 >= (unint64_t)(*(void *)(*(void *)(a2 + 136) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 136) + 4));
        else {
          BOOL v166 = 1;
        }
        if (!v166) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v162;
        v163 += 8;
      }
      while (v162 < *(int *)(v161 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v155, v156, v157, v158, v159, v160, v204);
  }
  if (*(void *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"pk_attrs\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v173 = *(void *)(a2 + 144);
    if (v173 && *(int *)(v173 + 4) >= 1)
    {
      uint64_t v174 = 0;
      uint64_t v175 = 8;
      do
      {
        uint64_t v176 = *(void *)(v173 + 16);
        uint64_t v177 = *(void *)(v176 + 8 * v174);
        if (v177) {
          _outNode(a1, v177);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v176 + v175) {
          BOOL v178 = v176 + v175 >= (unint64_t)(*(void *)(*(void *)(a2 + 144) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 144) + 4));
        else {
          BOOL v178 = 1;
        }
        if (!v178) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v174;
        v175 += 8;
      }
      while (v174 < *(int *)(v173 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v167, v168, v169, v170, v171, v172, v205);
  }
  if (*(unsigned char *)(a2 + 152)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"fk_matchtype\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 152));
  }
  if (*(unsigned char *)(a2 + 153)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"fk_upd_action\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 153));
  }
  if (*(unsigned char *)(a2 + 154)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"fk_del_action\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 154));
  }
  if (*(void *)(a2 + 160))
  {
    appendStringInfo((uint64_t)a1, "\"old_conpfeqop\":", v13, v14, v15, v16, v17, v18, v191);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v185 = *(void *)(a2 + 160);
    if (v185 && *(int *)(v185 + 4) >= 1)
    {
      uint64_t v186 = 0;
      uint64_t v187 = 8;
      do
      {
        uint64_t v188 = *(void *)(v185 + 16);
        uint64_t v189 = *(void *)(v188 + 8 * v186);
        if (v189) {
          _outNode(a1, v189);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v188 + v187) {
          BOOL v190 = v188 + v187 >= (unint64_t)(*(void *)(*(void *)(a2 + 160) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 160) + 4));
        else {
          BOOL v190 = 1;
        }
        if (!v190) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v186;
        v187 += 8;
      }
      while (v186 < *(int *)(v185 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v179, v180, v181, v182, v183, v184, v206);
  }
  if (*(_DWORD *)(a2 + 168)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"old_pktable_oid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 168));
  }
  if (*(unsigned char *)(a2 + 172)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"skip_validation\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 173)) {
    return appendStringInfo((uint64_t)a1, "\"initially_valid\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

unint64_t _outDefElem(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"defnamespace\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    appendStringInfo((uint64_t)a1, ",", v16, v17, v18, v19, v20, v21, v50);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"defname\":", a3, a4, a5, a6, a7, a8, v49);
    _outToken(a1, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    appendStringInfo((uint64_t)a1, ",", v28, v29, v30, v31, v32, v33, v51);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"arg\":", a3, a4, a5, a6, a7, a8, v49);
    _outNode(a1, *(void *)(a2 + 24));
    appendStringInfo((uint64_t)a1, ",", v34, v35, v36, v37, v38, v39, v52);
  }
  uint64_t v40 = *(int *)(a2 + 32);
  if (v40 > 3) {
    uint64_t v41 = 0;
  }
  else {
    uint64_t v41 = (&off_1E55D9838)[v40];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"defaction\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v41);
  if (*(_DWORD *)(a2 + 36)) {
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v43, v44, v45, v46, v47, v48, *(unsigned int *)(a2 + 36));
  }
  return result;
}

unint64_t _outRangeTblEntry(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v11 = *(int *)(a2 + 4);
  if (v11 > 8) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (&off_1E55D9858)[v11];
  }
  appendStringInfo((uint64_t)a1, "\"rtekind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(_DWORD *)(a2 + 8)) {
    appendStringInfo((uint64_t)a1, "\"relid\":%u,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 8));
  }
  if (*(unsigned char *)(a2 + 12)) {
    appendStringInfo((uint64_t)a1, "\"relkind\":\"%c\",", v13, v14, v15, v16, v17, v18, *(char *)(a2 + 12));
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo((uint64_t)a1, "\"rellockmode\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"tablesample\":{", v13, v14, v15, v16, v17, v18, v310);
    _outTableSampleClause((uint64_t)a1, *(void *)(a2 + 24), v19, v20, v21, v22, v23, v24, v311);
    int v31 = a1[2];
    BOOL v32 = __OFSUB__(v31, 1);
    uint64_t v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      uint64_t v34 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v33) == 44)
      {
        a1[2] = v33;
        *(unsigned char *)(v34 + v33) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v25, v26, v27, v28, v29, v30, v312);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"subquery\":{", v13, v14, v15, v16, v17, v18, v310);
    _outQuery((uint64_t)a1, *(void *)(a2 + 32), v35, v36, v37, v38, v39, v40);
    int v47 = a1[2];
    BOOL v32 = __OFSUB__(v47, 1);
    uint64_t v48 = (v47 - 1);
    if ((int)v48 < 0 == v32)
    {
      uint64_t v49 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v48) == 44)
      {
        a1[2] = v48;
        *(unsigned char *)(v49 + v48) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v41, v42, v43, v44, v45, v46, v313);
  }
  if (*(unsigned char *)(a2 + 40)) {
    appendStringInfo((uint64_t)a1, "\"security_barrier\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  uint64_t v50 = *(int *)(a2 + 44);
  if (v50 > 7) {
    size_t v51 = 0;
  }
  else {
    size_t v51 = (&off_1E55D98A0)[v50];
  }
  appendStringInfo((uint64_t)a1, "\"jointype\":\"%s\",", v13, v14, v15, v16, v17, v18, (size_t)v51);
  if (*(_DWORD *)(a2 + 48)) {
    appendStringInfo((uint64_t)a1, "\"joinmergedcols\":%d,", v52, v53, v54, v55, v56, v57, *(unsigned int *)(a2 + 48));
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"joinaliasvars\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v64 = *(void *)(a2 + 56);
    if (v64 && *(int *)(v64 + 4) >= 1)
    {
      uint64_t v65 = 0;
      uint64_t v66 = 8;
      do
      {
        uint64_t v67 = *(void *)(v64 + 16);
        uint64_t v68 = *(void *)(v67 + 8 * v65);
        if (v68) {
          _outNode(a1, v68);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v67 + v66) {
          BOOL v69 = v67 + v66 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v69 = 1;
        }
        if (!v69) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v65;
        v66 += 8;
      }
      while (v65 < *(int *)(v64 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v58, v59, v60, v61, v62, v63, v315);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"joinleftcols\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v76 = *(void *)(a2 + 64);
    if (v76 && *(int *)(v76 + 4) >= 1)
    {
      uint64_t v77 = 0;
      uint64_t v78 = 8;
      do
      {
        uint64_t v79 = *(void *)(v76 + 16);
        uint64_t v80 = *(void *)(v79 + 8 * v77);
        if (v80) {
          _outNode(a1, v80);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v79 + v78) {
          BOOL v81 = v79 + v78 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v81 = 1;
        }
        if (!v81) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v77;
        v78 += 8;
      }
      while (v77 < *(int *)(v76 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v70, v71, v72, v73, v74, v75, v316);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"joinrightcols\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v88 = *(void *)(a2 + 72);
    if (v88 && *(int *)(v88 + 4) >= 1)
    {
      uint64_t v89 = 0;
      uint64_t v90 = 8;
      do
      {
        uint64_t v91 = *(void *)(v88 + 16);
        uint64_t v92 = *(void *)(v91 + 8 * v89);
        if (v92) {
          _outNode(a1, v92);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v91 + v90) {
          BOOL v93 = v91 + v90 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v93 = 1;
        }
        if (!v93) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v89;
        v90 += 8;
      }
      while (v89 < *(int *)(v88 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v82, v83, v84, v85, v86, v87, v317);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"functions\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v100 = *(void *)(a2 + 80);
    if (v100 && *(int *)(v100 + 4) >= 1)
    {
      uint64_t v101 = 0;
      uint64_t v102 = 8;
      do
      {
        uint64_t v103 = *(void *)(v100 + 16);
        uint64_t v104 = *(void *)(v103 + 8 * v101);
        if (v104) {
          _outNode(a1, v104);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v103 + v102) {
          BOOL v105 = v103 + v102 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v105 = 1;
        }
        if (!v105) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v101;
        v102 += 8;
      }
      while (v101 < *(int *)(v100 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v94, v95, v96, v97, v98, v99, v318);
  }
  if (*(unsigned char *)(a2 + 88)) {
    appendStringInfo((uint64_t)a1, "\"funcordinality\":%s,", v52, v53, v54, v55, v56, v57, (size_t)"true");
  }
  if (*(void *)(a2 + 96))
  {
    appendStringInfo((uint64_t)a1, "\"tablefunc\":{", v52, v53, v54, v55, v56, v57, v314);
    _outTableFunc((uint64_t)a1, *(void *)(a2 + 96), v106, v107, v108, v109, v110, v111);
    int v118 = a1[2];
    BOOL v32 = __OFSUB__(v118, 1);
    uint64_t v119 = (v118 - 1);
    if ((int)v119 < 0 == v32)
    {
      uint64_t v120 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v119) == 44)
      {
        a1[2] = v119;
        *(unsigned char *)(v120 + v119) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v112, v113, v114, v115, v116, v117, v319);
  }
  if (*(void *)(a2 + 104))
  {
    appendStringInfo((uint64_t)a1, "\"values_lists\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v127 = *(void *)(a2 + 104);
    if (v127 && *(int *)(v127 + 4) >= 1)
    {
      uint64_t v128 = 0;
      uint64_t v129 = 8;
      do
      {
        uint64_t v130 = *(void *)(v127 + 16);
        uint64_t v131 = *(void *)(v130 + 8 * v128);
        if (v131) {
          _outNode(a1, v131);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v130 + v129) {
          BOOL v132 = v130 + v129 >= (unint64_t)(*(void *)(*(void *)(a2 + 104) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 104) + 4));
        else {
          BOOL v132 = 1;
        }
        if (!v132) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v128;
        v129 += 8;
      }
      while (v128 < *(int *)(v127 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v121, v122, v123, v124, v125, v126, v320);
  }
  if (*(void *)(a2 + 112))
  {
    appendStringInfo((uint64_t)a1, "\"ctename\":", v52, v53, v54, v55, v56, v57, v314);
    _outToken(a1, *(char **)(a2 + 112), v133, v134, v135, v136, v137, v138);
    appendStringInfo((uint64_t)a1, ",", v139, v140, v141, v142, v143, v144, v321);
  }
  if (*(_DWORD *)(a2 + 120)) {
    appendStringInfo((uint64_t)a1, "\"ctelevelsup\":%u,", v52, v53, v54, v55, v56, v57, *(unsigned int *)(a2 + 120));
  }
  if (*(unsigned char *)(a2 + 124)) {
    appendStringInfo((uint64_t)a1, "\"self_reference\":%s,", v52, v53, v54, v55, v56, v57, (size_t)"true");
  }
  if (*(void *)(a2 + 128))
  {
    appendStringInfo((uint64_t)a1, "\"coltypes\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v151 = *(void *)(a2 + 128);
    if (v151 && *(int *)(v151 + 4) >= 1)
    {
      uint64_t v152 = 0;
      uint64_t v153 = 8;
      do
      {
        uint64_t v154 = *(void *)(v151 + 16);
        uint64_t v155 = *(void *)(v154 + 8 * v152);
        if (v155) {
          _outNode(a1, v155);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v154 + v153) {
          BOOL v156 = v154 + v153 >= (unint64_t)(*(void *)(*(void *)(a2 + 128) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 128) + 4));
        else {
          BOOL v156 = 1;
        }
        if (!v156) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v152;
        v153 += 8;
      }
      while (v152 < *(int *)(v151 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v145, v146, v147, v148, v149, v150, v322);
  }
  if (*(void *)(a2 + 136))
  {
    appendStringInfo((uint64_t)a1, "\"coltypmods\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v163 = *(void *)(a2 + 136);
    if (v163 && *(int *)(v163 + 4) >= 1)
    {
      uint64_t v164 = 0;
      uint64_t v165 = 8;
      do
      {
        uint64_t v166 = *(void *)(v163 + 16);
        uint64_t v167 = *(void *)(v166 + 8 * v164);
        if (v167) {
          _outNode(a1, v167);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v166 + v165) {
          BOOL v168 = v166 + v165 >= (unint64_t)(*(void *)(*(void *)(a2 + 136) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 136) + 4));
        else {
          BOOL v168 = 1;
        }
        if (!v168) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v164;
        v165 += 8;
      }
      while (v164 < *(int *)(v163 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v157, v158, v159, v160, v161, v162, v323);
  }
  if (*(void *)(a2 + 144))
  {
    appendStringInfo((uint64_t)a1, "\"colcollations\":", v52, v53, v54, v55, v56, v57, v314);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v175 = *(void *)(a2 + 144);
    if (v175 && *(int *)(v175 + 4) >= 1)
    {
      uint64_t v176 = 0;
      uint64_t v177 = 8;
      do
      {
        uint64_t v178 = *(void *)(v175 + 16);
        uint64_t v179 = *(void *)(v178 + 8 * v176);
        if (v179) {
          _outNode(a1, v179);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v178 + v177) {
          BOOL v180 = v178 + v177 >= (unint64_t)(*(void *)(*(void *)(a2 + 144) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 144) + 4));
        else {
          BOOL v180 = 1;
        }
        if (!v180) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v176;
        v177 += 8;
      }
      while (v176 < *(int *)(v175 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v169, v170, v171, v172, v173, v174, v324);
  }
  if (*(void *)(a2 + 152))
  {
    appendStringInfo((uint64_t)a1, "\"enrname\":", v52, v53, v54, v55, v56, v57, v314);
    _outToken(a1, *(char **)(a2 + 152), v181, v182, v183, v184, v185, v186);
    appendStringInfo((uint64_t)a1, ",", v187, v188, v189, v190, v191, v192, v325);
  }
  appendStringInfo((uint64_t)a1, "\"enrtuples\":%f,", v52, v53, v54, v55, v56, v57, *(void *)(a2 + 160));
  if (*(void *)(a2 + 168))
  {
    appendStringInfo((uint64_t)a1, "\"alias\":{", v193, v194, v195, v196, v197, v198, v326);
    _outAlias((uint64_t)a1, *(void *)(a2 + 168), v199, v200, v201, v202, v203, v204, v327);
    int v211 = a1[2];
    BOOL v32 = __OFSUB__(v211, 1);
    uint64_t v212 = (v211 - 1);
    if ((int)v212 < 0 == v32)
    {
      uint64_t v213 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v212) == 44)
      {
        a1[2] = v212;
        *(unsigned char *)(v213 + v212) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v205, v206, v207, v208, v209, v210, v328);
  }
  if (*(void *)(a2 + 176))
  {
    appendStringInfo((uint64_t)a1, "\"eref\":{", v193, v194, v195, v196, v197, v198, v326);
    _outAlias((uint64_t)a1, *(void *)(a2 + 176), v214, v215, v216, v217, v218, v219, v329);
    int v226 = a1[2];
    BOOL v32 = __OFSUB__(v226, 1);
    uint64_t v227 = (v226 - 1);
    if ((int)v227 < 0 == v32)
    {
      uint64_t v228 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v227) == 44)
      {
        a1[2] = v227;
        *(unsigned char *)(v228 + v227) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v220, v221, v222, v223, v224, v225, v330);
  }
  if (*(unsigned char *)(a2 + 184)) {
    appendStringInfo((uint64_t)a1, "\"lateral\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 185)) {
    appendStringInfo((uint64_t)a1, "\"inh\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 186)) {
    appendStringInfo((uint64_t)a1, "\"inFromCl\":%s,", v193, v194, v195, v196, v197, v198, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 188)) {
    appendStringInfo((uint64_t)a1, "\"requiredPerms\":%u,", v193, v194, v195, v196, v197, v198, *(unsigned int *)(a2 + 188));
  }
  if (*(_DWORD *)(a2 + 192)) {
    appendStringInfo((uint64_t)a1, "\"checkAsUser\":%u,", v193, v194, v195, v196, v197, v198, *(unsigned int *)(a2 + 192));
  }
  if (bms_is_empty(*(unsigned int **)(a2 + 200)))
  {
    if (bms_is_empty(*(unsigned int **)(a2 + 208))) {
      goto LABEL_176;
    }
  }
  else
  {
    appendStringInfo((uint64_t)a1, "\"selectedCols\":[", v229, v230, v231, v232, v233, v234, v326);
    uint64_t member = bms_next_member(*(int **)(a2 + 200), 0);
    if ((member & 0x80000000) == 0)
    {
      uint64_t v273 = member;
      do
      {
        appendStringInfo((uint64_t)a1, "%d,", v267, v268, v269, v270, v271, v272, v273);
        uint64_t v273 = bms_next_member(*(int **)(a2 + 200), v273);
      }
      while ((v273 & 0x80000000) == 0);
    }
    int v274 = a1[2];
    BOOL v32 = __OFSUB__(v274, 1);
    uint64_t v275 = (v274 - 1);
    if ((int)v275 < 0 == v32)
    {
      uint64_t v276 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v275) == 44)
      {
        a1[2] = v275;
        *(unsigned char *)(v276 + v275) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "],", v267, v268, v269, v270, v271, v272, v331);
    if (bms_is_empty(*(unsigned int **)(a2 + 208)))
    {
LABEL_176:
      if (bms_is_empty(*(unsigned int **)(a2 + 216))) {
        goto LABEL_177;
      }
      goto LABEL_208;
    }
  }
  appendStringInfo((uint64_t)a1, "\"insertedCols\":[", v235, v236, v237, v238, v239, v240, v326);
  uint64_t v277 = bms_next_member(*(int **)(a2 + 208), 0);
  if ((v277 & 0x80000000) == 0)
  {
    uint64_t v284 = v277;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v278, v279, v280, v281, v282, v283, v284);
      uint64_t v284 = bms_next_member(*(int **)(a2 + 208), v284);
    }
    while ((v284 & 0x80000000) == 0);
  }
  int v285 = a1[2];
  BOOL v32 = __OFSUB__(v285, 1);
  uint64_t v286 = (v285 - 1);
  if ((int)v286 < 0 == v32)
  {
    uint64_t v287 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v286) == 44)
    {
      a1[2] = v286;
      *(unsigned char *)(v287 + v286) = 0;
    }
  }
  appendStringInfo((uint64_t)a1, "],", v278, v279, v280, v281, v282, v283, v332);
  if (bms_is_empty(*(unsigned int **)(a2 + 216)))
  {
LABEL_177:
    unint64_t result = bms_is_empty(*(unsigned int **)(a2 + 224));
    if (result) {
      goto LABEL_178;
    }
    goto LABEL_215;
  }
LABEL_208:
  appendStringInfo((uint64_t)a1, "\"updatedCols\":[", v241, v242, v243, v244, v245, v246, v326);
  uint64_t v288 = bms_next_member(*(int **)(a2 + 216), 0);
  if ((v288 & 0x80000000) == 0)
  {
    uint64_t v295 = v288;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v289, v290, v291, v292, v293, v294, v295);
      uint64_t v295 = bms_next_member(*(int **)(a2 + 216), v295);
    }
    while ((v295 & 0x80000000) == 0);
  }
  int v296 = a1[2];
  BOOL v32 = __OFSUB__(v296, 1);
  uint64_t v297 = (v296 - 1);
  if ((int)v297 < 0 == v32)
  {
    uint64_t v298 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v297) == 44)
    {
      a1[2] = v297;
      *(unsigned char *)(v298 + v297) = 0;
    }
  }
  appendStringInfo((uint64_t)a1, "],", v289, v290, v291, v292, v293, v294, v333);
  unint64_t result = bms_is_empty(*(unsigned int **)(a2 + 224));
  if (result)
  {
LABEL_178:
    if (!*(void *)(a2 + 232)) {
      return result;
    }
    goto LABEL_179;
  }
LABEL_215:
  appendStringInfo((uint64_t)a1, "\"extraUpdatedCols\":[", v248, v249, v250, v251, v252, v253, v326);
  uint64_t v299 = bms_next_member(*(int **)(a2 + 224), 0);
  if ((v299 & 0x80000000) == 0)
  {
    uint64_t v306 = v299;
    do
    {
      appendStringInfo((uint64_t)a1, "%d,", v300, v301, v302, v303, v304, v305, v306);
      uint64_t v306 = bms_next_member(*(int **)(a2 + 224), v306);
    }
    while ((v306 & 0x80000000) == 0);
  }
  int v307 = a1[2];
  BOOL v32 = __OFSUB__(v307, 1);
  uint64_t v308 = (v307 - 1);
  if ((int)v308 < 0 == v32)
  {
    uint64_t v309 = *(void *)a1;
    if (*(unsigned char *)(*(void *)a1 + v308) == 44)
    {
      a1[2] = v308;
      *(unsigned char *)(v309 + v308) = 0;
    }
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "],", v300, v301, v302, v303, v304, v305, v334);
  if (*(void *)(a2 + 232))
  {
LABEL_179:
    appendStringInfo((uint64_t)a1, "\"securityQuals\":", v248, v249, v250, v251, v252, v253, v326);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v260 = *(void *)(a2 + 232);
    if (v260 && *(int *)(v260 + 4) >= 1)
    {
      uint64_t v261 = 0;
      uint64_t v262 = 8;
      do
      {
        uint64_t v263 = *(void *)(v260 + 16);
        uint64_t v264 = *(void *)(v263 + 8 * v261);
        if (v264) {
          _outNode(a1, v264);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v263 + v262) {
          BOOL v265 = v263 + v262 >= (unint64_t)(*(void *)(*(void *)(a2 + 232) + 16)
        }
                                                 + 8 * *(int *)(*(void *)(a2 + 232) + 4));
        else {
          BOOL v265 = 1;
        }
        if (!v265) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v261;
        v262 += 8;
      }
      while (v261 < *(int *)(v260 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v254, v255, v256, v257, v258, v259, a9);
  }
  return result;
}

unint64_t _outRangeTblFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"funcexpr\":", a3, a4, a5, a6, a7, a8, v84);
    _outNode(a1, *(void *)(a2 + 8));
    appendStringInfo(a1, ",", v11, v12, v13, v14, v15, v16, v85);
  }
  if (*(_DWORD *)(a2 + 16)) {
    appendStringInfo(a1, "\"funccolcount\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"funccolnames\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    uint64_t v23 = *(void *)(a2 + 24);
    if (v23 && *(int *)(v23 + 4) >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 8;
      do
      {
        uint64_t v26 = *(void *)(v23 + 16);
        uint64_t v27 = *(void *)(v26 + 8 * v24);
        if (v27) {
          _outNode(a1, v27);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v26 + v25) {
          BOOL v28 = v26 + v25 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v28 = 1;
        }
        if (!v28) {
          appendStringInfoString(a1, ",");
        }
        ++v24;
        v25 += 8;
      }
      while (v24 < *(int *)(v23 + 4));
    }
    appendStringInfo(a1, "],", v17, v18, v19, v20, v21, v22, v86);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(a1, "\"funccoltypes\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    uint64_t v35 = *(void *)(a2 + 32);
    if (v35 && *(int *)(v35 + 4) >= 1)
    {
      uint64_t v36 = 0;
      uint64_t v37 = 8;
      do
      {
        uint64_t v38 = *(void *)(v35 + 16);
        uint64_t v39 = *(void *)(v38 + 8 * v36);
        if (v39) {
          _outNode(a1, v39);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v38 + v37) {
          BOOL v40 = v38 + v37 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v40 = 1;
        }
        if (!v40) {
          appendStringInfoString(a1, ",");
        }
        ++v36;
        v37 += 8;
      }
      while (v36 < *(int *)(v35 + 4));
    }
    appendStringInfo(a1, "],", v29, v30, v31, v32, v33, v34, v87);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(a1, "\"funccoltypmods\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    uint64_t v47 = *(void *)(a2 + 40);
    if (v47 && *(int *)(v47 + 4) >= 1)
    {
      uint64_t v48 = 0;
      uint64_t v49 = 8;
      do
      {
        uint64_t v50 = *(void *)(v47 + 16);
        uint64_t v51 = *(void *)(v50 + 8 * v48);
        if (v51) {
          _outNode(a1, v51);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v50 + v49) {
          BOOL v52 = v50 + v49 >= (unint64_t)(*(void *)(*(void *)(a2 + 40) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 40) + 4));
        else {
          BOOL v52 = 1;
        }
        if (!v52) {
          appendStringInfoString(a1, ",");
        }
        ++v48;
        v49 += 8;
      }
      while (v48 < *(int *)(v47 + 4));
    }
    appendStringInfo(a1, "],", v41, v42, v43, v44, v45, v46, v88);
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo(a1, "\"funccolcollations\":", a3, a4, a5, a6, a7, a8, v84);
    appendStringInfoChar(a1, 91);
    uint64_t v59 = *(void *)(a2 + 48);
    if (v59 && *(int *)(v59 + 4) >= 1)
    {
      uint64_t v60 = 0;
      uint64_t v61 = 8;
      do
      {
        uint64_t v62 = *(void *)(v59 + 16);
        uint64_t v63 = *(void *)(v62 + 8 * v60);
        if (v63) {
          _outNode(a1, v63);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v62 + v61) {
          BOOL v64 = v62 + v61 >= (unint64_t)(*(void *)(*(void *)(a2 + 48) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 48) + 4));
        else {
          BOOL v64 = 1;
        }
        if (!v64) {
          appendStringInfoString(a1, ",");
        }
        ++v60;
        v61 += 8;
      }
      while (v60 < *(int *)(v59 + 4));
    }
    appendStringInfo(a1, "],", v53, v54, v55, v56, v57, v58, v89);
  }
  unint64_t result = bms_is_empty(*(unsigned int **)(a2 + 56));
  if ((result & 1) == 0)
  {
    appendStringInfo(a1, "\"funcparams\":[", v66, v67, v68, v69, v70, v71, v84);
    uint64_t member = bms_next_member(*(int **)(a2 + 56), 0);
    if ((member & 0x80000000) == 0)
    {
      uint64_t v79 = member;
      do
      {
        appendStringInfo(a1, "%d,", v73, v74, v75, v76, v77, v78, v79);
        uint64_t v79 = bms_next_member(*(int **)(a2 + 56), v79);
      }
      while ((v79 & 0x80000000) == 0);
    }
    int v80 = *(_DWORD *)(a1 + 8);
    BOOL v81 = __OFSUB__(v80, 1);
    uint64_t v82 = (v80 - 1);
    if ((int)v82 < 0 == v81)
    {
      uint64_t v83 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v82) == 44)
      {
        *(_DWORD *)(a1 + 8) = v82;
        *(unsigned char *)(v83 + v82) = 0;
      }
    }
    return appendStringInfo(a1, "],", v73, v74, v75, v76, v77, v78, a9);
  }
  return result;
}

uint64_t _outTableSampleClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"tsmhandler\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"args\":", a3, a4, a5, a6, a7, a8, v29);
    appendStringInfoChar(v10, 91);
    uint64_t v17 = *(void *)(a2 + 8);
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 8;
      do
      {
        uint64_t v20 = *(void *)(v17 + 16);
        uint64_t v21 = *(void *)(v20 + 8 * v18);
        if (v21) {
          _outNode(v10, v21);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v20 + v19) {
          BOOL v22 = v20 + v19 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v22 = 1;
        }
        if (!v22) {
          appendStringInfoString(v10, ",");
        }
        ++v18;
        v19 += 8;
      }
      while (v18 < *(int *)(v17 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v11, v12, v13, v14, v15, v16, v30);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"repeatable\":", a3, a4, a5, a6, a7, a8, v29);
    _outNode(v10, *(void *)(a2 + 16));
    return appendStringInfo(v10, ",", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

unint64_t _outWithCheckOption(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D98E0)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"relname\":", v13, v14, v15, v16, v17, v18, v49);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v50);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"polname\":", v13, v14, v15, v16, v17, v18, v49);
    _outToken(a1, *(char **)(a2 + 16), v31, v32, v33, v34, v35, v36);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v37, v38, v39, v40, v41, v42, v51);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)a1, "\"qual\":", v13, v14, v15, v16, v17, v18, v49);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v43, v44, v45, v46, v47, v48, v52);
  }
  if (*(unsigned char *)(a2 + 32)) {
    return appendStringInfo((uint64_t)a1, "\"cascaded\":%s,", v13, v14, v15, v16, v17, v18, (size_t)"true");
  }
  return result;
}

uint64_t _outSortGroupClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"tleSortGroupRef\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"eqop\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"sortop\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"nulls_first\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 17)) {
    return appendStringInfo(v9, "\"hashable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

unint64_t _outGroupingSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 4) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9900)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"content\":", v13, v14, v15, v16, v17, v18, v31);
    appendStringInfoChar(a1, 91);
    uint64_t v25 = *(void *)(a2 + 8);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 8;
      do
      {
        uint64_t v28 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(v28 + 8 * v26);
        if (v29) {
          _outNode(a1, v29);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v28 + v27) {
          BOOL v30 = v28 + v27 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v30 = 1;
        }
        if (!v30) {
          appendStringInfoString(a1, ",");
        }
        ++v26;
        v27 += 8;
      }
      while (v26 < *(int *)(v25 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v19, v20, v21, v22, v23, v24, v32);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outWindowClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v71);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"refname\":", a3, a4, a5, a6, a7, a8, v70);
    _outToken(v9, *(char **)(a2 + 16), v22, v23, v24, v25, v26, v27);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v28, v29, v30, v31, v32, v33, v72);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"partitionClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v40 = *(void *)(a2 + 24);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v34, v35, v36, v37, v38, v39, v73);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"orderClause\":", a3, a4, a5, a6, a7, a8, v70);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52 && *(int *)(v52 + 4) >= 1)
    {
      uint64_t v53 = 0;
      uint64_t v54 = 8;
      do
      {
        uint64_t v55 = *(void *)(v52 + 16);
        uint64_t v56 = *(void *)(v55 + 8 * v53);
        if (v56) {
          _outNode(v9, v56);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v55 + v54) {
          BOOL v57 = v55 + v54 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v57 = 1;
        }
        if (!v57) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v53;
        v54 += 8;
      }
      while (v53 < *(int *)(v52 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v46, v47, v48, v49, v50, v51, v74);
  }
  if (*(_DWORD *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"frameOptions\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  if (*(void *)(a2 + 48))
  {
    appendStringInfo((uint64_t)v9, "\"startOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(void *)(a2 + 48));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v58, v59, v60, v61, v62, v63, v75);
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)v9, "\"endOffset\":", a3, a4, a5, a6, a7, a8, v70);
    _outNode(v9, *(void *)(a2 + 56));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v64, v65, v66, v67, v68, v69, v76);
  }
  if (*(_DWORD *)(a2 + 64)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"startInRangeFunc\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 64));
  }
  if (*(_DWORD *)(a2 + 68)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"endInRangeFunc\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 68));
  }
  if (*(_DWORD *)(a2 + 72)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"inRangeColl\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 72));
  }
  if (*(unsigned char *)(a2 + 76)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"inRangeAsc\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 77)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"inRangeNullsFirst\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 80)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"winref\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 80));
  }
  if (*(unsigned char *)(a2 + 84)) {
    return appendStringInfo((uint64_t)v9, "\"copiedOrder\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outObjectWithArgs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"objname\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v35);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"objargs\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(unsigned char *)(a2 + 24)) {
    return appendStringInfo(v9, "\"args_unspecified\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outAccessPriv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"priv_name\":", a3, a4, a5, a6, a7, a8, v35);
    _outToken(v10, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    unint64_t result = appendStringInfo((uint64_t)v10, ",", v17, v18, v19, v20, v21, v22, v36);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v10, "\"cols\":", a3, a4, a5, a6, a7, a8, v35);
    appendStringInfoChar((uint64_t)v10, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(v10, v33);
        }
        else {
          appendStringInfoString((uint64_t)v10, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)v10, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    return appendStringInfo((uint64_t)v10, "],", v23, v24, v25, v26, v27, v28, a9);
  }
  return result;
}

uint64_t _outCreateOpClassItem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(_DWORD *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"itemtype\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(v10, "\"name\":{", a3, a4, a5, a6, a7, a8, v66);
    _outObjectWithArgs(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v67);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v10, "\"number\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v10, "\"order_family\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = *(void *)(a2 + 24);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, v68);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v10, "\"class_args\":", a3, a4, a5, a6, a7, a8, v66);
    appendStringInfoChar(v10, 91);
    uint64_t v45 = *(void *)(a2 + 32);
    if (v45 && *(int *)(v45 + 4) >= 1)
    {
      uint64_t v46 = 0;
      uint64_t v47 = 8;
      do
      {
        uint64_t v48 = *(void *)(v45 + 16);
        uint64_t v49 = *(void *)(v48 + 8 * v46);
        if (v49) {
          _outNode(v10, v49);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v48 + v47) {
          BOOL v50 = v48 + v47 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v50 = 1;
        }
        if (!v50) {
          appendStringInfoString(v10, ",");
        }
        ++v46;
        v47 += 8;
      }
      while (v46 < *(int *)(v45 + 4));
    }
    unint64_t result = appendStringInfo(v10, "],", v39, v40, v41, v42, v43, v44, v69);
  }
  if (*(void *)(a2 + 40))
  {
    appendStringInfo(v10, "\"storedtype\":{", a3, a4, a5, a6, a7, a8, v66);
    _outTypeName(v10, *(void *)(a2 + 40), v51, v52, v53, v54, v55, v56);
    int v63 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v63, 1);
    uint64_t v64 = (v63 - 1);
    if ((int)v64 < 0 == v24)
    {
      uint64_t v65 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v64) == 44)
      {
        *(_DWORD *)(v10 + 8) = v64;
        *(unsigned char *)(v65 + v64) = 0;
      }
    }
    return appendStringInfo(v10, "},", v57, v58, v59, v60, v61, v62, a9);
  }
  return result;
}

uint64_t _outTableLikeClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v26);
    _outRangeVar(v9, *(void *)(a2 + 8), v10, v11, v12, v13, v14, v15);
    int v22 = *(_DWORD *)(v9 + 8);
    BOOL v23 = __OFSUB__(v22, 1);
    uint64_t v24 = (v22 - 1);
    if ((int)v24 < 0 == v23)
    {
      uint64_t v25 = *(void *)v9;
      if (*(unsigned char *)(*(void *)v9 + v24) == 44)
      {
        *(_DWORD *)(v9 + 8) = v24;
        *(unsigned char *)(v25 + v24) = 0;
      }
    }
    unint64_t result = appendStringInfo(v9, "},", v16, v17, v18, v19, v20, v21, v27);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"options\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"relationOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

unint64_t _outFunctionParameter(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"name\":", a3, a4, a5, a6, a7, a8, v53);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v54);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"argType\":{", a3, a4, a5, a6, a7, a8, v53);
    _outTypeName((uint64_t)a1, *(void *)(a2 + 16), v23, v24, v25, v26, v27, v28);
    int v35 = a1[2];
    BOOL v36 = __OFSUB__(v35, 1);
    uint64_t v37 = (v35 - 1);
    if ((int)v37 < 0 == v36)
    {
      uint64_t v38 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v37) == 44)
      {
        a1[2] = v37;
        *(unsigned char *)(v38 + v37) = 0;
      }
    }
    appendStringInfo((uint64_t)a1, "},", v29, v30, v31, v32, v33, v34, v55);
  }
  uint64_t v39 = "FUNC_PARAM_IN";
  switch(*(_DWORD *)(a2 + 24))
  {
    case 'b':
      uint64_t v39 = "FUNC_PARAM_INOUT";
      break;
    case 'i':
      break;
    case 'o':
      uint64_t v39 = "FUNC_PARAM_OUT";
      break;
    case 't':
      uint64_t v39 = "FUNC_PARAM_TABLE";
      break;
    case 'v':
      uint64_t v39 = "FUNC_PARAM_VARIADIC";
      break;
    default:
      uint64_t v39 = 0;
      break;
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"mode\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v39);
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"defexpr\":", v41, v42, v43, v44, v45, v46, v56);
    _outNode(a1, *(void *)(a2 + 32));
    return appendStringInfo((uint64_t)a1, ",", v47, v48, v49, v50, v51, v52, a9);
  }
  return result;
}

unint64_t _outLockingClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"lockedRels\":", a3, a4, a5, a6, a7, a8, v33);
    appendStringInfoChar(a1, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(a1, v20);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(a1, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    appendStringInfo(a1, "],", v10, v11, v12, v13, v14, v15, v34);
  }
  uint64_t v22 = *(int *)(a2 + 16);
  if (v22 > 4) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = (&off_1E55D9928)[v22];
  }
  appendStringInfo(a1, "\"strength\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v23);
  uint64_t v30 = *(int *)(a2 + 20);
  if (v30 > 2) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = (&off_1E55D9950)[v30];
  }
  return appendStringInfo(a1, "\"waitPolicy\":\"%s\",", v24, v25, v26, v27, v28, v29, (size_t)v31);
}

unint64_t _outRowMarkClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a2 + 4)) {
    appendStringInfo(a1, "\"rti\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 4));
  }
  uint64_t v10 = *(int *)(a2 + 8);
  if (v10 > 4) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9928)[v10];
  }
  appendStringInfo(a1, "\"strength\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  uint64_t v18 = *(int *)(a2 + 12);
  if (v18 > 2) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (&off_1E55D9950)[v18];
  }
  unint64_t result = appendStringInfo(a1, "\"waitPolicy\":\"%s\",", v12, v13, v14, v15, v16, v17, (size_t)v19);
  if (*(unsigned char *)(a2 + 16)) {
    return appendStringInfo(a1, "\"pushedDown\":%s,", v21, v22, v23, v24, v25, v26, (size_t)"true");
  }
  return result;
}

unint64_t _outXmlSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD *)(a2 + 4);
  uint64_t v11 = "XMLOPTION_CONTENT";
  if (v10 != 1) {
    uint64_t v11 = 0;
  }
  if (v10) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = "XMLOPTION_DOCUMENT";
  }
  unint64_t result = appendStringInfo(a1, "\"xmloption\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v12);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"expr\":", v14, v15, v16, v17, v18, v19, v42);
    _outNode(a1, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(a1, ",", v20, v21, v22, v23, v24, v25, v43);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"typeName\":{", v14, v15, v16, v17, v18, v19, v42);
    _outTypeName(a1, *(void *)(a2 + 16), v26, v27, v28, v29, v30, v31);
    int v38 = *(_DWORD *)(a1 + 8);
    BOOL v39 = __OFSUB__(v38, 1);
    uint64_t v40 = (v38 - 1);
    if ((int)v40 < 0 == v39)
    {
      uint64_t v41 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v40) == 44)
      {
        *(_DWORD *)(a1 + 8) = v40;
        *(unsigned char *)(v41 + v4errstart(20, 0) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "},", v32, v33, v34, v35, v36, v37, v44);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo(a1, "\"location\":%d,", v14, v15, v16, v17, v18, v19, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outWithClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"ctes\":", a3, a4, a5, a6, a7, a8, v22);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v9, "\"recursive\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 20)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 20));
  }
  return result;
}

uint64_t _outInferClause(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"indexElems\":", a3, a4, a5, a6, a7, a8, v40);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 8) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 8) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v10, v11, v12, v13, v14, v15, v41);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"whereClause\":", a3, a4, a5, a6, a7, a8, v40);
    _outNode(v9, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v42);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"conname\":", a3, a4, a5, a6, a7, a8, v40);
    _outToken(v9, *(char **)(a2 + 24), v28, v29, v30, v31, v32, v33);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v34, v35, v36, v37, v38, v39, v43);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outOnConflictClause(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9968)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"action\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"infer\":{", v13, v14, v15, v16, v17, v18, v53);
    _outInferClause(a1, *(void *)(a2 + 8), v19, v20, v21, v22, v23, v24);
    int v31 = *(_DWORD *)(a1 + 8);
    BOOL v32 = __OFSUB__(v31, 1);
    uint64_t v33 = (v31 - 1);
    if ((int)v33 < 0 == v32)
    {
      uint64_t v34 = *(void *)a1;
      if (*(unsigned char *)(*(void *)a1 + v33) == 44)
      {
        *(_DWORD *)(a1 + 8) = v33;
        *(unsigned char *)(v34 + v33) = 0;
      }
    }
    unint64_t result = appendStringInfo(a1, "},", v25, v26, v27, v28, v29, v30, v54);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(a1, "\"targetList\":", v13, v14, v15, v16, v17, v18, v53);
    appendStringInfoChar(a1, 91);
    uint64_t v41 = *(void *)(a2 + 16);
    if (v41 && *(int *)(v41 + 4) >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 8;
      do
      {
        uint64_t v44 = *(void *)(v41 + 16);
        uint64_t v45 = *(void *)(v44 + 8 * v42);
        if (v45) {
          _outNode(a1, v45);
        }
        else {
          appendStringInfoString(a1, "{}");
        }
        if (v44 + v43) {
          BOOL v46 = v44 + v43 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v46 = 1;
        }
        if (!v46) {
          appendStringInfoString(a1, ",");
        }
        ++v42;
        v43 += 8;
      }
      while (v42 < *(int *)(v41 + 4));
    }
    unint64_t result = appendStringInfo(a1, "],", v35, v36, v37, v38, v39, v40, v55);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(a1, "\"whereClause\":", v13, v14, v15, v16, v17, v18, v53);
    _outNode(a1, *(void *)(a2 + 24));
    unint64_t result = appendStringInfo(a1, ",", v47, v48, v49, v50, v51, v52, v56);
  }
  if (*(_DWORD *)(a2 + 32)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 32));
  }
  return result;
}

unint64_t _outCommonTableExpr(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"ctename\":", a3, a4, a5, a6, a7, a8, v98);
    _outToken(a1, *(char **)(a2 + 8), v11, v12, v13, v14, v15, v16);
    appendStringInfo((uint64_t)a1, ",", v17, v18, v19, v20, v21, v22, v99);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)a1, "\"aliascolnames\":", a3, a4, a5, a6, a7, a8, v98);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v29 = *(void *)(a2 + 16);
    if (v29 && *(int *)(v29 + 4) >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 8;
      do
      {
        uint64_t v32 = *(void *)(v29 + 16);
        uint64_t v33 = *(void *)(v32 + 8 * v30);
        if (v33) {
          _outNode(a1, v33);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v32 + v31) {
          BOOL v34 = v32 + v31 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v34 = 1;
        }
        if (!v34) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v30;
        v31 += 8;
      }
      while (v30 < *(int *)(v29 + 4));
    }
    appendStringInfo((uint64_t)a1, "],", v23, v24, v25, v26, v27, v28, v100);
  }
  uint64_t v35 = *(int *)(a2 + 24);
  if (v35 > 2) {
    uint64_t v36 = 0;
  }
  else {
    uint64_t v36 = (&off_1E55D9980)[v35];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"ctematerialized\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v36);
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)a1, "\"ctequery\":", v38, v39, v40, v41, v42, v43, v101);
    _outNode(a1, *(void *)(a2 + 32));
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v44, v45, v46, v47, v48, v49, v102);
  }
  if (*(_DWORD *)(a2 + 40)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"location\":%d,", v38, v39, v40, v41, v42, v43, *(unsigned int *)(a2 + 40));
  }
  if (*(unsigned char *)(a2 + 44)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"cterecursive\":%s,", v38, v39, v40, v41, v42, v43, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 48)) {
    unint64_t result = appendStringInfo((uint64_t)a1, "\"cterefcount\":%d,", v38, v39, v40, v41, v42, v43, *(unsigned int *)(a2 + 48));
  }
  if (*(void *)(a2 + 56))
  {
    appendStringInfo((uint64_t)a1, "\"ctecolnames\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v56 = *(void *)(a2 + 56);
    if (v56 && *(int *)(v56 + 4) >= 1)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 8;
      do
      {
        uint64_t v59 = *(void *)(v56 + 16);
        uint64_t v60 = *(void *)(v59 + 8 * v57);
        if (v60) {
          _outNode(a1, v60);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v59 + v58) {
          BOOL v61 = v59 + v58 >= (unint64_t)(*(void *)(*(void *)(a2 + 56) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 56) + 4));
        else {
          BOOL v61 = 1;
        }
        if (!v61) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v57;
        v58 += 8;
      }
      while (v57 < *(int *)(v56 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v50, v51, v52, v53, v54, v55, v103);
  }
  if (*(void *)(a2 + 64))
  {
    appendStringInfo((uint64_t)a1, "\"ctecoltypes\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v68 = *(void *)(a2 + 64);
    if (v68 && *(int *)(v68 + 4) >= 1)
    {
      uint64_t v69 = 0;
      uint64_t v70 = 8;
      do
      {
        uint64_t v71 = *(void *)(v68 + 16);
        uint64_t v72 = *(void *)(v71 + 8 * v69);
        if (v72) {
          _outNode(a1, v72);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v71 + v70) {
          BOOL v73 = v71 + v70 >= (unint64_t)(*(void *)(*(void *)(a2 + 64) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 64) + 4));
        else {
          BOOL v73 = 1;
        }
        if (!v73) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v69;
        v70 += 8;
      }
      while (v69 < *(int *)(v68 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v62, v63, v64, v65, v66, v67, v104);
  }
  if (*(void *)(a2 + 72))
  {
    appendStringInfo((uint64_t)a1, "\"ctecoltypmods\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v80 = *(void *)(a2 + 72);
    if (v80 && *(int *)(v80 + 4) >= 1)
    {
      uint64_t v81 = 0;
      uint64_t v82 = 8;
      do
      {
        uint64_t v83 = *(void *)(v80 + 16);
        uint64_t v84 = *(void *)(v83 + 8 * v81);
        if (v84) {
          _outNode(a1, v84);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v83 + v82) {
          BOOL v85 = v83 + v82 >= (unint64_t)(*(void *)(*(void *)(a2 + 72) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 72) + 4));
        else {
          BOOL v85 = 1;
        }
        if (!v85) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v81;
        v82 += 8;
      }
      while (v81 < *(int *)(v80 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)a1, "],", v74, v75, v76, v77, v78, v79, v105);
  }
  if (*(void *)(a2 + 80))
  {
    appendStringInfo((uint64_t)a1, "\"ctecolcollations\":", v38, v39, v40, v41, v42, v43, v101);
    appendStringInfoChar((uint64_t)a1, 91);
    uint64_t v92 = *(void *)(a2 + 80);
    if (v92 && *(int *)(v92 + 4) >= 1)
    {
      uint64_t v93 = 0;
      uint64_t v94 = 8;
      do
      {
        uint64_t v95 = *(void *)(v92 + 16);
        uint64_t v96 = *(void *)(v95 + 8 * v93);
        if (v96) {
          _outNode(a1, v96);
        }
        else {
          appendStringInfoString((uint64_t)a1, "{}");
        }
        if (v95 + v94) {
          BOOL v97 = v95 + v94 >= (unint64_t)(*(void *)(*(void *)(a2 + 80) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 80) + 4));
        else {
          BOOL v97 = 1;
        }
        if (!v97) {
          appendStringInfoString((uint64_t)a1, ",");
        }
        ++v93;
        v94 += 8;
      }
      while (v93 < *(int *)(v92 + 4));
    }
    return appendStringInfo((uint64_t)a1, "],", v86, v87, v88, v89, v90, v91, a9);
  }
  return result;
}

unint64_t _outRoleSpec(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(int *)(a2 + 4);
  if (v10 > 3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D9998)[v10];
  }
  unint64_t result = appendStringInfo((uint64_t)a1, "\"roletype\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo((uint64_t)a1, "\"rolename\":", v13, v14, v15, v16, v17, v18, v31);
    _outToken(a1, *(char **)(a2 + 8), v19, v20, v21, v22, v23, v24);
    unint64_t result = appendStringInfo((uint64_t)a1, ",", v25, v26, v27, v28, v29, v30, v32);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo((uint64_t)a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outTriggerTransition(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(unsigned char *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"isNew\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 17)) {
    return appendStringInfo((uint64_t)v9, "\"isTable\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

uint64_t _outPartitionElem(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":", a3, a4, a5, a6, a7, a8, v52);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v53);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"expr\":", a3, a4, a5, a6, a7, a8, v52);
    _outNode(v9, *(void *)(a2 + 16));
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v22, v23, v24, v25, v26, v27, v54);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo((uint64_t)v9, "\"collation\":", a3, a4, a5, a6, a7, a8, v52);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v34 = *(void *)(a2 + 24);
    if (v34 && *(int *)(v34 + 4) >= 1)
    {
      uint64_t v35 = 0;
      uint64_t v36 = 8;
      do
      {
        uint64_t v37 = *(void *)(v34 + 16);
        uint64_t v38 = *(void *)(v37 + 8 * v35);
        if (v38) {
          _outNode(v9, v38);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v37 + v36) {
          BOOL v39 = v37 + v36 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v39 = 1;
        }
        if (!v39) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v35;
        v36 += 8;
      }
      while (v35 < *(int *)(v34 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v28, v29, v30, v31, v32, v33, v55);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo((uint64_t)v9, "\"opclass\":", a3, a4, a5, a6, a7, a8, v52);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v46 = *(void *)(a2 + 32);
    if (v46 && *(int *)(v46 + 4) >= 1)
    {
      uint64_t v47 = 0;
      uint64_t v48 = 8;
      do
      {
        uint64_t v49 = *(void *)(v46 + 16);
        uint64_t v50 = *(void *)(v49 + 8 * v47);
        if (v50) {
          _outNode(v9, v50);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v49 + v48) {
          BOOL v51 = v49 + v48 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v51 = 1;
        }
        if (!v51) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v47;
        v48 += 8;
      }
      while (v47 < *(int *)(v46 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v40, v41, v42, v43, v44, v45, v56);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  return result;
}

uint64_t _outPartitionSpec(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"strategy\":", a3, a4, a5, a6, a7, a8, v34);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v35);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo((uint64_t)v9, "\"partParams\":", a3, a4, a5, a6, a7, a8, v34);
    appendStringInfoChar((uint64_t)v9, 91);
    uint64_t v28 = *(void *)(a2 + 16);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString((uint64_t)v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString((uint64_t)v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo((uint64_t)v9, "],", v22, v23, v24, v25, v26, v27, v36);
  }
  if (*(_DWORD *)(a2 + 24)) {
    return appendStringInfo((uint64_t)v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 24));
  }
  return result;
}

uint64_t _outPartitionBoundSpec(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(unsigned char *)(a2 + 4)) {
    unint64_t result = appendStringInfo(result, "\"strategy\":\"%c\",", a3, a4, a5, a6, a7, a8, *(char *)(a2 + 4));
  }
  if (*(unsigned char *)(a2 + 5)) {
    unint64_t result = appendStringInfo(v9, "\"is_default\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(_DWORD *)(a2 + 8)) {
    unint64_t result = appendStringInfo(v9, "\"modulus\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 8));
  }
  if (*(_DWORD *)(a2 + 12)) {
    unint64_t result = appendStringInfo(v9, "\"remainder\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 12));
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v9, "\"listdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v16 = *(void *)(a2 + 16);
    if (v16 && *(int *)(v16 + 4) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8;
      do
      {
        uint64_t v19 = *(void *)(v16 + 16);
        uint64_t v20 = *(void *)(v19 + 8 * v17);
        if (v20) {
          _outNode(v9, v20);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v19 + v18) {
          BOOL v21 = v19 + v18 >= (unint64_t)(*(void *)(*(void *)(a2 + 16) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 16) + 4));
        else {
          BOOL v21 = 1;
        }
        if (!v21) {
          appendStringInfoString(v9, ",");
        }
        ++v17;
        v18 += 8;
      }
      while (v17 < *(int *)(v16 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v10, v11, v12, v13, v14, v15, v47);
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v9, "\"lowerdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v28 = *(void *)(a2 + 24);
    if (v28 && *(int *)(v28 + 4) >= 1)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8;
      do
      {
        uint64_t v31 = *(void *)(v28 + 16);
        uint64_t v32 = *(void *)(v31 + 8 * v29);
        if (v32) {
          _outNode(v9, v32);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v31 + v30) {
          BOOL v33 = v31 + v30 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v33 = 1;
        }
        if (!v33) {
          appendStringInfoString(v9, ",");
        }
        ++v29;
        v30 += 8;
      }
      while (v29 < *(int *)(v28 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v22, v23, v24, v25, v26, v27, v48);
  }
  if (*(void *)(a2 + 32))
  {
    appendStringInfo(v9, "\"upperdatums\":", a3, a4, a5, a6, a7, a8, v46);
    appendStringInfoChar(v9, 91);
    uint64_t v40 = *(void *)(a2 + 32);
    if (v40 && *(int *)(v40 + 4) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 8;
      do
      {
        uint64_t v43 = *(void *)(v40 + 16);
        uint64_t v44 = *(void *)(v43 + 8 * v41);
        if (v44) {
          _outNode(v9, v44);
        }
        else {
          appendStringInfoString(v9, "{}");
        }
        if (v43 + v42) {
          BOOL v45 = v43 + v42 >= (unint64_t)(*(void *)(*(void *)(a2 + 32) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 32) + 4));
        else {
          BOOL v45 = 1;
        }
        if (!v45) {
          appendStringInfoString(v9, ",");
        }
        ++v41;
        v42 += 8;
      }
      while (v41 < *(int *)(v40 + 4));
    }
    unint64_t result = appendStringInfo(v9, "],", v34, v35, v36, v37, v38, v39, v49);
  }
  if (*(_DWORD *)(a2 + 40)) {
    return appendStringInfo(v9, "\"location\":%d,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 40));
  }
  return result;
}

unint64_t _outPartitionRangeDatum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a2 + 4) + 1;
  if (v10 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (&off_1E55D99B8)[v10];
  }
  unint64_t result = appendStringInfo(a1, "\"kind\":\"%s\",", a3, a4, a5, a6, a7, a8, (size_t)v11);
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(a1, "\"value\":", v13, v14, v15, v16, v17, v18, v25);
    _outNode(a1, *(void *)(a2 + 8));
    unint64_t result = appendStringInfo(a1, ",", v19, v20, v21, v22, v23, v24, v26);
  }
  if (*(_DWORD *)(a2 + 16)) {
    return appendStringInfo(a1, "\"location\":%d,", v13, v14, v15, v16, v17, v18, *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t _outPartitionCmd(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"name\":{", a3, a4, a5, a6, a7, a8, v42);
    _outRangeVar(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v43);
  }
  if (*(void *)(a2 + 16))
  {
    appendStringInfo(v10, "\"bound\":{", a3, a4, a5, a6, a7, a8, v42);
    _outPartitionBoundSpec(v10, *(void *)(a2 + 16), v27, v28, v29, v30, v31, v32);
    int v39 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v39, 1);
    uint64_t v40 = (v39 - 1);
    if ((int)v40 < 0 == v24)
    {
      uint64_t v41 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v40) == 44)
      {
        *(_DWORD *)(v10 + 8) = v40;
        *(unsigned char *)(v41 + v4errstart(20, 0) = 0;
      }
    }
    return appendStringInfo(v10, "},", v33, v34, v35, v36, v37, v38, a9);
  }
  return result;
}

uint64_t _outVacuumRelation(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, size_t a9)
{
  uint64_t v10 = result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"relation\":{", a3, a4, a5, a6, a7, a8, v39);
    _outRangeVar(v10, *(void *)(a2 + 8), v11, v12, v13, v14, v15, v16);
    int v23 = *(_DWORD *)(v10 + 8);
    BOOL v24 = __OFSUB__(v23, 1);
    uint64_t v25 = (v23 - 1);
    if ((int)v25 < 0 == v24)
    {
      uint64_t v26 = *(void *)v10;
      if (*(unsigned char *)(*(void *)v10 + v25) == 44)
      {
        *(_DWORD *)(v10 + 8) = v25;
        *(unsigned char *)(v26 + v25) = 0;
      }
    }
    unint64_t result = appendStringInfo(v10, "},", v17, v18, v19, v20, v21, v22, v40);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo(v10, "\"oid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(void *)(a2 + 24))
  {
    appendStringInfo(v10, "\"va_cols\":", a3, a4, a5, a6, a7, a8, v39);
    appendStringInfoChar(v10, 91);
    uint64_t v33 = *(void *)(a2 + 24);
    if (v33 && *(int *)(v33 + 4) >= 1)
    {
      uint64_t v34 = 0;
      uint64_t v35 = 8;
      do
      {
        uint64_t v36 = *(void *)(v33 + 16);
        uint64_t v37 = *(void *)(v36 + 8 * v34);
        if (v37) {
          _outNode(v10, v37);
        }
        else {
          appendStringInfoString(v10, "{}");
        }
        if (v36 + v35) {
          BOOL v38 = v36 + v35 >= (unint64_t)(*(void *)(*(void *)(a2 + 24) + 16)
        }
                                              + 8 * *(int *)(*(void *)(a2 + 24) + 4));
        else {
          BOOL v38 = 1;
        }
        if (!v38) {
          appendStringInfoString(v10, ",");
        }
        ++v34;
        v35 += 8;
      }
      while (v34 < *(int *)(v33 + 4));
    }
    return appendStringInfo(v10, "],", v27, v28, v29, v30, v31, v32, a9);
  }
  return result;
}

uint64_t _outInlineCodeBlock(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (int *)result;
  if (*(void *)(a2 + 8))
  {
    appendStringInfo(result, "\"source_text\":", a3, a4, a5, a6, a7, a8, v22);
    _outToken(v9, *(char **)(a2 + 8), v10, v11, v12, v13, v14, v15);
    unint64_t result = appendStringInfo((uint64_t)v9, ",", v16, v17, v18, v19, v20, v21, v23);
  }
  if (*(_DWORD *)(a2 + 16)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"langOid\":%u,", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a2 + 16));
  }
  if (*(unsigned char *)(a2 + 20)) {
    unint64_t result = appendStringInfo((uint64_t)v9, "\"langIsTrusted\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  if (*(unsigned char *)(a2 + 21)) {
    return appendStringInfo((uint64_t)v9, "\"atomic\":%s,", a3, a4, a5, a6, a7, a8, (size_t)"true");
  }
  return result;
}

int *_outToken(int *result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t)result;
  if (a2)
  {
    uint64_t v10 = result[2];
    if ((int)v10 + 1 >= result[3])
    {
      unint64_t result = (int *)appendStringInfoChar((uint64_t)result, 34);
      char v13 = *a2;
      if (!*a2) {
        goto LABEL_27;
      }
    }
    else
    {
      *(unsigned char *)(*(void *)result + v1errstart(20, 0) = 34;
      uint64_t v11 = *(void *)result;
      int v12 = result[2] + 1;
      result[2] = v12;
      *(unsigned char *)(v11 + v12) = 0;
      char v13 = *a2;
      if (!*a2)
      {
LABEL_27:
        uint64_t v21 = *(int *)(v8 + 8);
        if ((int)v21 + 1 >= *(_DWORD *)(v8 + 12))
        {
          return (int *)appendStringInfoChar(v8, 34);
        }
        else
        {
          *(unsigned char *)(*(void *)v8 + v21) = 34;
          uint64_t v22 = *(void *)v8;
          int v23 = *(_DWORD *)(v8 + 8) + 1;
          *(_DWORD *)(v8 + 8) = v23;
          *(unsigned char *)(v22 + v23) = 0;
        }
        return result;
      }
    }
    uint64_t v14 = a2 + 1;
    while (2)
    {
      switch(v13)
      {
        case 8:
          uint64_t v15 = v8;
          uint64_t v16 = "\\b";
          goto LABEL_11;
        case 9:
          uint64_t v15 = v8;
          uint64_t v16 = "\\t";
          goto LABEL_11;
        case 10:
          uint64_t v15 = v8;
          uint64_t v16 = "\\n";
          goto LABEL_11;
        case 11:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
          goto LABEL_17;
        case 12:
          uint64_t v15 = v8;
          uint64_t v16 = "\\f";
          goto LABEL_11;
        case 13:
          uint64_t v15 = v8;
          uint64_t v16 = "\\r";
          goto LABEL_11;
        case 34:
          uint64_t v15 = v8;
          uint64_t v16 = "\\\"";
          goto LABEL_11;
        default:
          if (v13 == 92)
          {
            uint64_t v15 = v8;
            uint64_t v16 = "\\\\"";
LABEL_11:
            unint64_t result = (int *)appendStringInfoString(v15, v16);
          }
          else
          {
LABEL_17:
            if (v13 < 0x20u || (v13 | 2) == 0x3E)
            {
              unint64_t result = (int *)appendStringInfo(v8, "\\u%04x", a3, a4, a5, a6, a7, a8, v13);
            }
            else
            {
              uint64_t v18 = *(int *)(v8 + 8);
              if ((int)v18 + 1 >= *(_DWORD *)(v8 + 12))
              {
                unint64_t result = (int *)appendStringInfoChar(v8, v13);
              }
              else
              {
                *(unsigned char *)(*(void *)v8 + v18) = v13;
                uint64_t v19 = *(void *)v8;
                int v20 = *(_DWORD *)(v8 + 8) + 1;
                *(_DWORD *)(v8 + 8) = v20;
                *(unsigned char *)(v19 + v2errstart(20, 0) = 0;
              }
            }
          }
          char v17 = *v14++;
          char v13 = v17;
          if (v17) {
            continue;
          }
          goto LABEL_27;
      }
    }
  }

  return (int *)appendStringInfoString((uint64_t)result, "null");
}

size_t pg_query_nodes_to_protobuf(uint64_t a1)
{
  long long v19 = xmmword_1E55D99D0;
  long long v20 = unk_1E55D99E0;
  long long v21 = xmmword_1E55D99F0;
  DWORD2(v2errstart(20, 0) = 130003;
  if (a1)
  {
    *(void *)&long long v21 = *(int *)(a1 + 4);
    uint64_t v2 = palloc(8 * v21);
    *((void *)&v21 + 1) = v2;
    if (*(int *)(a1 + 4) >= 1)
    {
      uint64_t v3 = v2;
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(void *)(a1 + 16);
        uint64_t v6 = palloc(0x28uLL);
        *(void *)(v3 + 8 * v4) = v6;
        pg_query__raw_stmt__init(v6);
        uint64_t v7 = *(void *)(v3 + 8 * v4);
        uint64_t v8 = *(void *)(v5 + 8 * v4);
        if (*(void *)(v8 + 8))
        {
          uint64_t v9 = palloc(0x28uLL);
          pg_query__node__init(v9);
          *(void *)(v7 + 24) = v9;
          _outNode_0(v9, *(unsigned int **)(v8 + 8), v10, v11, v12, v13, v14, v15);
        }
        *(_DWORD *)(v7 + 32) = *(_DWORD *)(v8 + 16);
        *(_DWORD *)(v7 + 36) = *(_DWORD *)(v8 + 20);
        ++v4;
      }
      while (v4 < *(int *)(a1 + 4));
    }
  }
  else
  {
    long long v21 = 0uLL;
  }
  size_t packed_size = pg_query__parse_result__get_packed_size((void **)&v19);
  char v17 = malloc_type_malloc(packed_size, 0x100004077774924uLL);
  pg_query__parse_result__pack((void **)&v19, (uint64_t)v17);
  return packed_size;
}

uint64_t _outRawStmt_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 24) = v4;
    unint64_t result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 32) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 36) = *(_DWORD *)(a2 + 20);
  return result;
}

void _outNode_0(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    switch(*a2)
    {
      case 0x66u:
        uint64_t v10 = (_OWORD *)palloc(0x30uLL);
        pg_query__alias__init(v10);
        _outAlias_0(v10, (uint64_t)a2);
        *(void *)(a1 + 32) = v10;
        int v11 = 1;
        goto LABEL_90;
      case 0x67u:
        uint64_t v12 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_var__init(v12);
        _outRangeVar_0((uint64_t)v12, (uint64_t)a2);
        *(void *)(a1 + 32) = v12;
        int v11 = 2;
        goto LABEL_90;
      case 0x68u:
        uint64_t v13 = (_OWORD *)palloc(0xC0uLL);
        pg_query__table_func__init(v13);
        _outTableFunc_0((uint64_t)v13, (uint64_t)a2);
        *(void *)(a1 + 32) = v13;
        int v11 = 3;
        goto LABEL_90;
      case 0x69u:
        uint64_t v14 = palloc(0x18uLL);
        pg_query__expr__init(v14);
        *(void *)(a1 + 32) = v14;
        int v11 = 4;
        goto LABEL_90;
      case 0x6Au:
        uint64_t v15 = (_DWORD *)palloc(0x48uLL);
        pg_query__var__init((uint64_t)v15);
        _outVar_0(v15, (uint64_t)a2);
        *(void *)(a1 + 32) = v15;
        int v11 = 5;
        goto LABEL_90;
      case 0x6Cu:
        uint64_t v16 = (_DWORD *)palloc(0x38uLL);
        pg_query__param__init((uint64_t)v16);
        _outParam_0(v16, a2);
        *(void *)(a1 + 32) = v16;
        int v11 = 6;
        goto LABEL_90;
      case 0x6Du:
        char v17 = (_OWORD *)palloc(0xB0uLL);
        pg_query__aggref__init(v17);
        _outAggref_0((uint64_t)v17, (uint64_t)a2);
        *(void *)(a1 + 32) = v17;
        int v11 = 7;
        goto LABEL_90;
      case 0x6Eu:
        uint64_t v18 = palloc(0x58uLL);
        pg_query__grouping_func__init(v18);
        _outGroupingFunc_0(v18, (uint64_t)a2);
        *(void *)(a1 + 32) = v18;
        int v11 = 8;
        goto LABEL_90;
      case 0x6Fu:
        uint64_t v19 = palloc(0x58uLL);
        pg_query__window_func__init(v19);
        _outWindowFunc_0(v19, (uint64_t)a2);
        *(void *)(a1 + 32) = v19;
        int v11 = 9;
        goto LABEL_90;
      case 0x70u:
        long long v20 = (_OWORD *)palloc(0x60uLL);
        pg_query__subscripting_ref__init(v20);
        _outSubscriptingRef_0((uint64_t)v20, (uint64_t)a2);
        *(void *)(a1 + 32) = v20;
        int v11 = 10;
        goto LABEL_90;
      case 0x71u:
        uint64_t v21 = palloc(0x58uLL);
        pg_query__func_expr__init(v21);
        _outFuncExpr_0(v21, (uint64_t)a2);
        *(void *)(a1 + 32) = v21;
        int v11 = 11;
        goto LABEL_90;
      case 0x72u:
        uint64_t v22 = palloc(0x38uLL);
        pg_query__named_arg_expr__init(v22);
        _outNamedArgExpr_0(v22, (uint64_t)a2);
        *(void *)(a1 + 32) = v22;
        int v11 = 12;
        goto LABEL_90;
      case 0x73u:
        int v23 = (_OWORD *)palloc(0x50uLL);
        pg_query__op_expr__init(v23);
        _outOpExpr_0((uint64_t)v23, (uint64_t)a2);
        *(void *)(a1 + 32) = v23;
        int v11 = 13;
        goto LABEL_90;
      case 0x74u:
        BOOL v24 = (_OWORD *)palloc(0x50uLL);
        pg_query__distinct_expr__init(v24);
        _outOpExpr_0((uint64_t)v24, (uint64_t)a2);
        *(void *)(a1 + 32) = v24;
        int v11 = 14;
        goto LABEL_90;
      case 0x75u:
        uint64_t v25 = (_OWORD *)palloc(0x50uLL);
        pg_query__null_if_expr__init(v25);
        _outOpExpr_0((uint64_t)v25, (uint64_t)a2);
        *(void *)(a1 + 32) = v25;
        int v11 = 15;
        goto LABEL_90;
      case 0x76u:
        uint64_t v26 = palloc(0x48uLL);
        pg_query__scalar_array_op_expr__init(v26);
        _outScalarArrayOpExpr_0(v26, (uint64_t)a2);
        *(void *)(a1 + 32) = v26;
        int v11 = 16;
        goto LABEL_90;
      case 0x77u:
        uint64_t v27 = (_OWORD *)palloc(0x40uLL);
        pg_query__BOOL_expr__init(v27);
        _outBoolExpr_0((uint64_t)v27, (uint64_t)a2);
        *(void *)(a1 + 32) = v27;
        int v11 = 17;
        goto LABEL_90;
      case 0x78u:
        uint64_t v28 = (_OWORD *)palloc(0x50uLL);
        pg_query__sub_link__init(v28);
        _outSubLink_0((uint64_t)v28, (uint64_t)a2);
        *(void *)(a1 + 32) = v28;
        int v11 = 18;
        goto LABEL_90;
      case 0x79u:
        uint64_t v29 = palloc(0xA8uLL);
        pg_query__sub_plan__init(v29);
        _outSubPlan_0(v29, (uint64_t)a2);
        *(void *)(a1 + 32) = v29;
        int v11 = 19;
        goto LABEL_90;
      case 0x7Au:
        uint64_t v30 = (_OWORD *)palloc(0x30uLL);
        pg_query__alternative_sub_plan__init(v30);
        _outAlternativeSubPlan_0((uint64_t)v30, (uint64_t)a2);
        *(void *)(a1 + 32) = v30;
        int v11 = 20;
        goto LABEL_90;
      case 0x7Bu:
        uint64_t v31 = palloc(0x38uLL);
        pg_query__field_select__init(v31);
        _outFieldSelect_0(v31, (uint64_t)a2);
        *(void *)(a1 + 32) = v31;
        int v11 = 21;
        goto LABEL_90;
      case 0x7Cu:
        uint64_t v32 = (_OWORD *)palloc(0x50uLL);
        pg_query__field_store__init(v32);
        _outFieldStore_0((uint64_t)v32, (uint64_t)a2);
        *(void *)(a1 + 32) = v32;
        int v11 = 22;
        goto LABEL_90;
      case 0x7Du:
        uint64_t v33 = (_OWORD *)palloc(0x40uLL);
        pg_query__relabel_type__init(v33);
        _outRelabelType_0((uint64_t)v33, (uint64_t)a2);
        *(void *)(a1 + 32) = v33;
        int v11 = 23;
        goto LABEL_90;
      case 0x7Eu:
        uint64_t v34 = palloc(0x38uLL);
        pg_query__coerce_via_io__init(v34);
        _outCoerceViaIO_0(v34, (uint64_t)a2);
        *(void *)(a1 + 32) = v34;
        int v11 = 24;
        goto LABEL_90;
      case 0x7Fu:
        uint64_t v35 = palloc(0x48uLL);
        pg_query__array_coerce_expr__init(v35);
        _outArrayCoerceExpr_0(v35, (uint64_t)a2);
        *(void *)(a1 + 32) = v35;
        int v11 = 25;
        goto LABEL_90;
      case 0x80u:
        uint64_t v36 = palloc(0x38uLL);
        pg_query__convert_rowtype_expr__init(v36);
        _outConvertRowtypeExpr_0(v36, (uint64_t)a2);
        *(void *)(a1 + 32) = v36;
        int v11 = 26;
        goto LABEL_90;
      case 0x81u:
        uint64_t v37 = (_OWORD *)palloc(0x30uLL);
        pg_query__collate_expr__init(v37);
        _outCollateExpr_0((uint64_t)v37, (uint64_t)a2);
        *(void *)(a1 + 32) = v37;
        int v11 = 27;
        goto LABEL_90;
      case 0x82u:
        BOOL v38 = (_OWORD *)palloc(0x50uLL);
        pg_query__case_expr__init(v38);
        _outCaseExpr_0((uint64_t)v38, (uint64_t)a2);
        *(void *)(a1 + 32) = v38;
        int v11 = 28;
        goto LABEL_90;
      case 0x83u:
        uint64_t v39 = palloc(0x38uLL);
        pg_query__case_when__init(v39);
        _outCaseWhen_0(v39, (uint64_t)a2);
        *(void *)(a1 + 32) = v39;
        int v11 = 29;
        goto LABEL_90;
      case 0x84u:
        uint64_t v40 = palloc(0x30uLL);
        pg_query__case_test_expr__init((_OWORD *)v40);
        *(_DWORD *)(v40 + 32) = a2[1];
        *(_DWORD *)(v40 + 36) = a2[2];
        *(_DWORD *)(v40 + 4errstart(20, 0) = a2[3];
        *(void *)(a1 + 32) = v40;
        int v11 = 30;
        goto LABEL_90;
      case 0x85u:
        uint64_t v41 = palloc(0x48uLL);
        pg_query__array_expr__init(v41);
        _outArrayExpr_0(v41, (uint64_t)a2);
        *(void *)(a1 + 32) = v41;
        int v11 = 31;
        goto LABEL_90;
      case 0x86u:
        size_t v42 = (_OWORD *)palloc(0x50uLL);
        pg_query__row_expr__init(v42);
        _outRowExpr_0((uint64_t)v42, (uint64_t)a2);
        *(void *)(a1 + 32) = v42;
        int v11 = 32;
        goto LABEL_90;
      case 0x87u:
        uint64_t v43 = palloc(0x78uLL);
        pg_query__row_compare_expr__init(v43);
        _outRowCompareExpr_0(v43, (uint64_t)a2);
        *(void *)(a1 + 32) = v43;
        int v11 = 33;
        goto LABEL_90;
      case 0x88u:
        uint64_t v44 = (_OWORD *)palloc(0x40uLL);
        pg_query__coalesce_expr__init(v44);
        _outCoalesceExpr_0((uint64_t)v44, (uint64_t)a2);
        *(void *)(a1 + 32) = v44;
        int v11 = 34;
        goto LABEL_90;
      case 0x89u:
        uint64_t v45 = palloc(0x48uLL);
        pg_query__min_max_expr__init(v45);
        _outMinMaxExpr_0(v45, (uint64_t)a2);
        *(void *)(a1 + 32) = v45;
        int v11 = 35;
        goto LABEL_90;
      case 0x8Au:
        size_t v46 = (_OWORD *)palloc(0x30uLL);
        pg_query__sqlvalue_function__init(v46);
        _outSQLValueFunction_0(v46, a2);
        *(void *)(a1 + 32) = v46;
        int v11 = 36;
        goto LABEL_90;
      case 0x8Bu:
        size_t v47 = (_OWORD *)palloc(0x70uLL);
        pg_query__xml_expr__init(v47);
        _outXmlExpr_0((uint64_t)v47, (uint64_t)a2);
        *(void *)(a1 + 32) = v47;
        int v11 = 37;
        goto LABEL_90;
      case 0x8Cu:
        uint64_t v48 = palloc(0x38uLL);
        pg_query__null_test__init(v48);
        _outNullTest_0(v48, (uint64_t)a2);
        *(void *)(a1 + 32) = v48;
        int v11 = 38;
        goto LABEL_90;
      case 0x8Du:
        size_t v49 = (_OWORD *)palloc(0x30uLL);
        pg_query__BOOLean_test__init(v49);
        _outBooleanTest_0((uint64_t)v49, (uint64_t)a2);
        *(void *)(a1 + 32) = v49;
        int v11 = 39;
        goto LABEL_90;
      case 0x8Eu:
        uint64_t v50 = (_OWORD *)palloc(0x40uLL);
        pg_query__coerce_to_domain__init(v50);
        _outRelabelType_0((uint64_t)v50, (uint64_t)a2);
        *(void *)(a1 + 32) = v50;
        int v11 = 40;
        goto LABEL_90;
      case 0x8Fu:
        uint64_t v51 = palloc(0x30uLL);
        pg_query__coerce_to_domain_value__init((_OWORD *)v51);
        *(_DWORD *)(v51 + 32) = a2[1];
        *(_DWORD *)(v51 + 36) = a2[2];
        *(_DWORD *)(v51 + 4errstart(20, 0) = a2[3];
        *(_DWORD *)(v51 + 44) = a2[4];
        *(void *)(a1 + 32) = v51;
        int v11 = 41;
        goto LABEL_90;
      case 0x90u:
        uint64_t v52 = palloc(0x30uLL);
        pg_query__set_to_default__init((_OWORD *)v52);
        *(_DWORD *)(v52 + 32) = a2[1];
        *(_DWORD *)(v52 + 36) = a2[2];
        *(_DWORD *)(v52 + 4errstart(20, 0) = a2[3];
        *(_DWORD *)(v52 + 44) = a2[4];
        *(void *)(a1 + 32) = v52;
        int v11 = 42;
        goto LABEL_90;
      case 0x91u:
        uint64_t v53 = palloc(0x38uLL);
        pg_query__current_of_expr__init(v53);
        *(_DWORD *)(v53 + 32) = a2[1];
        size_t v54 = (const char *)*((void *)a2 + 1);
        if (v54) {
          *(void *)(v53 + 4errstart(20, 0) = pstrdup(v54);
        }
        *(_DWORD *)(v53 + 48) = a2[4];
        *(void *)(a1 + 32) = v53;
        int v11 = 43;
        goto LABEL_90;
      case 0x92u:
        uint64_t v55 = palloc(0x28uLL);
        pg_query__next_value_expr__init(v55);
        *(_DWORD *)(v55 + 32) = a2[1];
        *(_DWORD *)(v55 + 36) = a2[2];
        *(void *)(a1 + 32) = v55;
        int v11 = 44;
        goto LABEL_90;
      case 0x93u:
        size_t v56 = (_OWORD *)palloc(0x30uLL);
        pg_query__inference_elem__init(v56);
        _outCollateExpr_0((uint64_t)v56, (uint64_t)a2);
        *(void *)(a1 + 32) = v56;
        int v11 = 45;
        goto LABEL_90;
      case 0x94u:
        uint64_t v57 = palloc(0x48uLL);
        pg_query__target_entry__init(v57);
        _outTargetEntry_0(v57, (uint64_t)a2);
        *(void *)(a1 + 32) = v57;
        int v11 = 46;
        goto LABEL_90;
      case 0x95u:
        uint64_t v58 = palloc(0x20uLL);
        pg_query__range_tbl_ref__init((_OWORD *)v58);
        *(_DWORD *)(v58 + 24) = a2[1];
        *(void *)(a1 + 32) = v58;
        int v11 = 47;
        goto LABEL_90;
      case 0x96u:
        uint64_t v59 = palloc(0x58uLL);
        pg_query__join_expr__init(v59);
        _outJoinExpr_0(v59, (uint64_t)a2);
        *(void *)(a1 + 32) = v59;
        int v11 = 48;
        goto LABEL_90;
      case 0x97u:
        uint64_t v60 = (_OWORD *)palloc(0x30uLL);
        pg_query__from_expr__init(v60);
        _outFromExpr_0((uint64_t)v60, (uint64_t)a2);
        *(void *)(a1 + 32) = v60;
        int v11 = 49;
        goto LABEL_90;
      case 0x98u:
        BOOL v61 = (_OWORD *)palloc(0x70uLL);
        pg_query__on_conflict_expr__init(v61);
        _outOnConflictExpr_0((uint64_t)v61, (uint64_t)a2);
        *(void *)(a1 + 32) = v61;
        int v11 = 50;
        goto LABEL_90;
      case 0x99u:
        uint64_t v62 = palloc(0x68uLL);
        pg_query__into_clause__init(v62);
        _outIntoClause_0(v62, (uint64_t)a2);
        *(void *)(a1 + 32) = v62;
        int v11 = 51;
        goto LABEL_90;
      case 0xDDu:
        uint64_t v63 = palloc(0x20uLL);
        pg_query__integer__init((_OWORD *)v63);
        *(_DWORD *)(v63 + 24) = a2[2];
        *(void *)(a1 + 32) = v63;
        int v11 = 221;
        goto LABEL_90;
      case 0xDEu:
        uint64_t v64 = palloc(0x20uLL);
        pg_query__float__init((_OWORD *)v64);
        *(void *)(v64 + 24) = *((void *)a2 + 1);
        *(void *)(a1 + 32) = v64;
        int v11 = 222;
        goto LABEL_90;
      case 0xDFu:
        uint64_t v65 = palloc(0x20uLL);
        pg_query__string__init((_OWORD *)v65);
        *(void *)(v65 + 24) = *((void *)a2 + 1);
        *(void *)(a1 + 32) = v65;
        int v11 = 223;
        goto LABEL_90;
      case 0xE0u:
        uint64_t v66 = palloc(0x20uLL);
        pg_query__bit_string__init((_OWORD *)v66);
        *(void *)(v66 + 24) = *((void *)a2 + 1);
        *(void *)(a1 + 32) = v66;
        int v11 = 224;
        goto LABEL_90;
      case 0xE1u:
        uint64_t v67 = palloc(0x18uLL);
        pg_query__null__init(v67);
        *(void *)(a1 + 32) = v67;
        int v11 = 225;
        goto LABEL_90;
      case 0xE2u:
        uint64_t v68 = palloc(0x28uLL);
        pg_query__list__init(v68);
        _outList_0(v68, (uint64_t)a2);
        *(void *)(a1 + 32) = v68;
        int v11 = 226;
        goto LABEL_90;
      case 0xE3u:
        uint64_t v69 = palloc(0x28uLL);
        pg_query__int_list__init(v69);
        _outList_0(v69, (uint64_t)a2);
        *(void *)(a1 + 32) = v69;
        int v11 = 227;
        goto LABEL_90;
      case 0xE4u:
        uint64_t v70 = palloc(0x28uLL);
        pg_query__oid_list__init(v70);
        _outList_0(v70, (uint64_t)a2);
        *(void *)(a1 + 32) = v70;
        int v11 = 228;
        goto LABEL_90;
      case 0xE6u:
        uint64_t v71 = palloc(0x28uLL);
        pg_query__raw_stmt__init(v71);
        _outRawStmt_0(v71, (uint64_t)a2);
        *(void *)(a1 + 32) = v71;
        int v11 = 52;
        goto LABEL_90;
      case 0xE7u:
        uint64_t v72 = (_DWORD *)palloc(0x160uLL);
        pg_query__query__init(v72);
        _outQuery_0(v72, (uint64_t)a2);
        *(void *)(a1 + 32) = v72;
        int v11 = 53;
        goto LABEL_90;
      case 0xE9u:
        BOOL v73 = (_OWORD *)palloc(0x60uLL);
        pg_query__insert_stmt__init(v73);
        _outInsertStmt_0((uint64_t)v73, (uint64_t)a2);
        *(void *)(a1 + 32) = v73;
        int v11 = 54;
        goto LABEL_90;
      case 0xEAu:
        uint64_t v74 = (_OWORD *)palloc(0x50uLL);
        pg_query__delete_stmt__init(v74);
        _outDeleteStmt_0((uint64_t)v74, (uint64_t *)a2);
        *(void *)(a1 + 32) = v74;
        int v11 = 55;
        goto LABEL_90;
      case 0xEBu:
        uint64_t v75 = (_OWORD *)palloc(0x60uLL);
        pg_query__update_stmt__init(v75);
        _outUpdateStmt_0((uint64_t)v75, (uint64_t *)a2);
        *(void *)(a1 + 32) = v75;
        int v11 = 56;
        goto LABEL_90;
      case 0xECu:
        uint64_t v76 = palloc(0xE8uLL);
        pg_query__select_stmt__init(v76);
        _outSelectStmt_0(v76, (uint64_t)a2);
        *(void *)(a1 + 32) = v76;
        int v11 = 57;
        goto LABEL_90;
      case 0xEDu:
        uint64_t v77 = palloc(0x38uLL);
        pg_query__alter_table_stmt__init(v77);
        _outAlterTableStmt_0(v77, (uint64_t)a2);
        *(void *)(a1 + 32) = v77;
        int v11 = 58;
        goto LABEL_90;
      case 0xEEu:
        uint64_t v78 = palloc(0x48uLL);
        pg_query__alter_table_cmd__init(v78);
        _outAlterTableCmd_0(v78, (uint64_t)a2);
        *(void *)(a1 + 32) = v78;
        int v11 = 59;
        goto LABEL_90;
      case 0xEFu:
        uint64_t v79 = palloc(0x48uLL);
        pg_query__alter_domain_stmt__init(v79);
        _outAlterDomainStmt_0(v79, (uint64_t)a2);
        *(void *)(a1 + 32) = v79;
        int v11 = 60;
        goto LABEL_90;
      case 0xF0u:
        uint64_t v80 = (_OWORD *)palloc(0x70uLL);
        pg_query__set_operation_stmt__init(v80);
        _outSetOperationStmt_0((uint64_t)v80, (uint64_t)a2);
        *(void *)(a1 + 32) = v80;
        int v11 = 61;
        goto LABEL_90;
      case 0xF1u:
        uint64_t v81 = (_OWORD *)palloc(0x60uLL);
        pg_query__grant_stmt__init(v81);
        _outGrantStmt_0((uint64_t)v81, (uint64_t)a2);
        *(void *)(a1 + 32) = v81;
        int v11 = 62;
        goto LABEL_90;
      case 0xF2u:
        uint64_t v82 = (_OWORD *)palloc(0x50uLL);
        pg_query__grant_role_stmt__init(v82);
        _outGrantRoleStmt_0((uint64_t)v82, (uint64_t)a2);
        *(void *)(a1 + 32) = v82;
        int v11 = 63;
        goto LABEL_90;
      case 0xF3u:
        uint64_t v83 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_default_privileges_stmt__init(v83);
        _outAlterDefaultPrivilegesStmt_0((uint64_t)v83, (uint64_t)a2);
        *(void *)(a1 + 32) = v83;
        int v11 = 64;
        goto LABEL_90;
      case 0xF4u:
        uint64_t v84 = palloc(0x20uLL);
        pg_query__close_portal_stmt__init((_OWORD *)v84);
        BOOL v85 = (const char *)*((void *)a2 + 1);
        if (v85) {
          *(void *)(v84 + 24) = pstrdup(v85);
        }
        *(void *)(a1 + 32) = v84;
        int v11 = 65;
        goto LABEL_90;
      case 0xF5u:
        uint64_t v86 = (_OWORD *)palloc(0x30uLL);
        pg_query__cluster_stmt__init(v86);
        _outClusterStmt_0((uint64_t)v86, (uint64_t)a2);
        *(void *)(a1 + 32) = v86;
        int v11 = 66;
        goto LABEL_90;
      case 0xF6u:
        uint64_t v87 = (_OWORD *)palloc(0x60uLL);
        pg_query__copy_stmt__init(v87);
        _outCopyStmt_0((uint64_t)v87, (uint64_t)a2);
        *(void *)(a1 + 32) = v87;
        int v11 = 67;
        goto LABEL_90;
      case 0xF7u:
        uint64_t v88 = palloc(0x98uLL);
        pg_query__create_stmt__init(v88);
        _outCreateStmt_0(v88, (uint64_t)a2);
        *(void *)(a1 + 32) = v88;
        int v11 = 68;
        goto LABEL_90;
      case 0xF8u:
        uint64_t v89 = palloc(0x58uLL);
        pg_query__define_stmt__init(v89);
        _outDefineStmt_0(v89, (uint64_t)a2);
        *(void *)(a1 + 32) = v89;
        int v11 = 69;
        goto LABEL_90;
      case 0xF9u:
        uint64_t v90 = palloc(0x38uLL);
        pg_query__drop_stmt__init(v90);
        _outDropStmt_0(v90, (uint64_t)a2);
        *(void *)(a1 + 32) = v90;
        int v11 = 70;
        goto LABEL_90;
      case 0xFAu:
        uint64_t v91 = (_OWORD *)palloc(0x30uLL);
        pg_query__truncate_stmt__init(v91);
        _outTruncateStmt_0((uint64_t)v91, (uint64_t)a2);
        *(void *)(a1 + 32) = v91;
        int v11 = 71;
LABEL_90:
        *(_DWORD *)(a1 + 24) = v11;
        break;
      case 0xFBu:
        uint64_t v92 = (_OWORD *)palloc(0x30uLL);
        pg_query__comment_stmt__init(v92);
        _outCommentStmt_0((uint64_t)v92, (uint64_t)a2);
        *(void *)(a1 + 32) = v92;
        *(_DWORD *)(a1 + 24) = 72;
        break;
      case 0xFCu:
        uint64_t v93 = palloc(0x38uLL);
        pg_query__fetch_stmt__init(v93);
        _outFetchStmt_0(v93, (uint64_t)a2);
        *(void *)(a1 + 32) = v93;
        *(_DWORD *)(a1 + 24) = 73;
        break;
      case 0xFDu:
        uint64_t v94 = (_OWORD *)palloc(0xC0uLL);
        pg_query__index_stmt__init(v94);
        _outIndexStmt_0((uint64_t)v94, (uint64_t)a2);
        *(void *)(a1 + 32) = v94;
        *(_DWORD *)(a1 + 24) = 74;
        break;
      case 0xFEu:
        uint64_t v95 = palloc(0x58uLL);
        pg_query__create_function_stmt__init(v95);
        _outCreateFunctionStmt_0(v95, (uint64_t)a2);
        *(void *)(a1 + 32) = v95;
        *(_DWORD *)(a1 + 24) = 75;
        break;
      case 0xFFu:
        uint64_t v96 = palloc(0x38uLL);
        pg_query__alter_function_stmt__init(v96);
        _outAlterFunctionStmt_0(v96, (uint64_t)a2);
        *(void *)(a1 + 32) = v96;
        *(_DWORD *)(a1 + 24) = 76;
        break;
      case 0x100u:
        uint64_t v97 = palloc(0x28uLL);
        pg_query__do_stmt__init(v97);
        _outDoStmt_0(v97, (uint64_t)a2);
        *(void *)(a1 + 32) = v97;
        *(_DWORD *)(a1 + 24) = 77;
        break;
      case 0x101u:
        uint64_t v98 = palloc(0x48uLL);
        pg_query__rename_stmt__init(v98);
        _outRenameStmt_0(v98, (uint64_t)a2);
        *(void *)(a1 + 32) = v98;
        *(_DWORD *)(a1 + 24) = 78;
        break;
      case 0x102u:
        size_t v99 = (_OWORD *)palloc(0x50uLL);
        pg_query__rule_stmt__init(v99);
        _outRuleStmt_0((uint64_t)v99, (uint64_t)a2);
        *(void *)(a1 + 32) = v99;
        *(_DWORD *)(a1 + 24) = 79;
        break;
      case 0x103u:
        uint64_t v100 = palloc(0x28uLL);
        pg_query__notify_stmt__init(v100);
        _outNotifyStmt_0(v100, (uint64_t)a2);
        *(void *)(a1 + 32) = v100;
        *(_DWORD *)(a1 + 24) = 80;
        break;
      case 0x104u:
        uint64_t v101 = palloc(0x20uLL);
        pg_query__listen_stmt__init((_OWORD *)v101);
        size_t v102 = (const char *)*((void *)a2 + 1);
        if (v102) {
          *(void *)(v101 + 24) = pstrdup(v102);
        }
        *(void *)(a1 + 32) = v101;
        *(_DWORD *)(a1 + 24) = 81;
        break;
      case 0x105u:
        uint64_t v103 = palloc(0x20uLL);
        pg_query__unlisten_stmt__init((_OWORD *)v103);
        size_t v104 = (const char *)*((void *)a2 + 1);
        if (v104) {
          *(void *)(v103 + 24) = pstrdup(v104);
        }
        *(void *)(a1 + 32) = v103;
        *(_DWORD *)(a1 + 24) = 82;
        break;
      case 0x106u:
        uint64_t v105 = palloc(0x48uLL);
        pg_query__transaction_stmt__init(v105);
        _outTransactionStmt_0(v105, (uint64_t)a2);
        *(void *)(a1 + 32) = v105;
        *(_DWORD *)(a1 + 24) = 83;
        break;
      case 0x107u:
        uint64_t v106 = palloc(0x58uLL);
        pg_query__view_stmt__init(v106);
        _outViewStmt_0(v106, (uint64_t)a2);
        *(void *)(a1 + 32) = v106;
        *(_DWORD *)(a1 + 24) = 84;
        break;
      case 0x108u:
        uint64_t v107 = palloc(0x20uLL);
        pg_query__load_stmt__init((_OWORD *)v107);
        uint64_t v108 = (const char *)*((void *)a2 + 1);
        if (v108) {
          *(void *)(v107 + 24) = pstrdup(v108);
        }
        *(void *)(a1 + 32) = v107;
        *(_DWORD *)(a1 + 24) = 85;
        break;
      case 0x109u:
        uint64_t v109 = palloc(0x48uLL);
        pg_query__create_domain_stmt__init(v109);
        _outCreateDomainStmt_0(v109, a2);
        *(void *)(a1 + 32) = v109;
        *(_DWORD *)(a1 + 24) = 86;
        break;
      case 0x10Au:
        uint64_t v110 = (_OWORD *)palloc(0x30uLL);
        pg_query__createdb_stmt__init(v110);
        _outAlias_0(v110, (uint64_t)a2);
        *(void *)(a1 + 32) = v110;
        *(_DWORD *)(a1 + 24) = 87;
        break;
      case 0x10Bu:
        uint64_t v111 = palloc(0x38uLL);
        pg_query__dropdb_stmt__init(v111);
        _outDropdbStmt_0(v111, (uint64_t)a2);
        *(void *)(a1 + 32) = v111;
        *(_DWORD *)(a1 + 24) = 88;
        break;
      case 0x10Cu:
        uint64_t v112 = (_OWORD *)palloc(0x40uLL);
        pg_query__vacuum_stmt__init(v112);
        _outVacuumStmt_0((uint64_t)v112, (uint64_t)a2);
        *(void *)(a1 + 32) = v112;
        *(_DWORD *)(a1 + 24) = 89;
        break;
      case 0x10Du:
        uint64_t v113 = (_OWORD *)palloc(0x30uLL);
        pg_query__explain_stmt__init(v113);
        _outExplainStmt_0((uint64_t)v113, (uint64_t)a2);
        *(void *)(a1 + 32) = v113;
        *(_DWORD *)(a1 + 24) = 90;
        break;
      case 0x10Eu:
        uint64_t v114 = (const char *)palloc(0x38uLL);
        pg_query__create_table_as_stmt__init((uint64_t)v114);
        _outCreateTableAsStmt_0(v114, (uint64_t)a2);
        *(void *)(a1 + 32) = v114;
        *(_DWORD *)(a1 + 24) = 91;
        break;
      case 0x10Fu:
        uint64_t v115 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_seq_stmt__init(v115);
        _outCreateSeqStmt_0((uint64_t)v115, (uint64_t)a2);
        *(void *)(a1 + 32) = v115;
        *(_DWORD *)(a1 + 24) = 92;
        break;
      case 0x110u:
        uint64_t v116 = palloc(0x38uLL);
        pg_query__alter_seq_stmt__init(v116);
        _outAlterSeqStmt_0(v116, (uint64_t)a2);
        *(void *)(a1 + 32) = v116;
        *(_DWORD *)(a1 + 24) = 93;
        break;
      case 0x111u:
        uint64_t v117 = (_OWORD *)palloc(0x40uLL);
        pg_query__variable_set_stmt__init(v117);
        _outVariableSetStmt_0((uint64_t)v117, (uint64_t)a2);
        *(void *)(a1 + 32) = v117;
        *(_DWORD *)(a1 + 24) = 94;
        break;
      case 0x112u:
        uint64_t v118 = palloc(0x20uLL);
        pg_query__variable_show_stmt__init((_OWORD *)v118);
        uint64_t v119 = (const char *)*((void *)a2 + 1);
        if (v119) {
          *(void *)(v118 + 24) = pstrdup(v119);
        }
        *(void *)(a1 + 32) = v118;
        *(_DWORD *)(a1 + 24) = 95;
        break;
      case 0x113u:
        uint64_t v120 = palloc(0x20uLL);
        pg_query__discard_stmt__init((_OWORD *)v120);
        unsigned int v121 = a2[1];
        if (v121 < 4) {
          int v122 = v121 + 1;
        }
        else {
          int v122 = -1;
        }
        *(_DWORD *)(v120 + 24) = v122;
        *(void *)(a1 + 32) = v120;
        *(_DWORD *)(a1 + 24) = 96;
        break;
      case 0x114u:
        uint64_t v123 = palloc(0x98uLL);
        pg_query__create_trig_stmt__init(v123);
        _outCreateTrigStmt_0(v123, (uint64_t)a2);
        *(void *)(a1 + 32) = v123;
        *(_DWORD *)(a1 + 24) = 97;
        break;
      case 0x115u:
        uint64_t v124 = (_OWORD *)palloc(0x60uLL);
        pg_query__create_plang_stmt__init(v124);
        _outCreatePLangStmt_0((uint64_t)v124, (uint64_t)a2);
        *(void *)(a1 + 32) = v124;
        *(_DWORD *)(a1 + 24) = 98;
        break;
      case 0x116u:
        uint64_t v125 = palloc(0x38uLL);
        pg_query__create_role_stmt__init(v125);
        _outCreateRoleStmt_0(v125, (uint64_t)a2);
        *(void *)(a1 + 32) = v125;
        *(_DWORD *)(a1 + 24) = 99;
        break;
      case 0x117u:
        uint64_t v126 = (const char *)palloc(0x38uLL);
        pg_query__alter_role_stmt__init((uint64_t)v126);
        _outAlterRoleStmt_0(v126, (uint64_t)a2);
        *(void *)(a1 + 32) = v126;
        *(_DWORD *)(a1 + 24) = 100;
        break;
      case 0x118u:
        uint64_t v127 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_role_stmt__init(v127);
        _outDropRoleStmt_0((uint64_t)v127, (uint64_t)a2);
        *(void *)(a1 + 32) = v127;
        *(_DWORD *)(a1 + 24) = 101;
        break;
      case 0x119u:
        uint64_t v128 = (_OWORD *)palloc(0x30uLL);
        pg_query__lock_stmt__init(v128);
        _outLockStmt_0((uint64_t)v128, (uint64_t)a2);
        *(void *)(a1 + 32) = v128;
        *(_DWORD *)(a1 + 24) = 102;
        break;
      case 0x11Au:
        uint64_t v129 = (_OWORD *)palloc(0x30uLL);
        pg_query__constraints_set_stmt__init(v129);
        _outDropRoleStmt_0((uint64_t)v129, (uint64_t)a2);
        *(void *)(a1 + 32) = v129;
        *(_DWORD *)(a1 + 24) = 103;
        break;
      case 0x11Bu:
        uint64_t v130 = palloc(0x38uLL);
        pg_query__reindex_stmt__init(v130);
        _outReindexStmt_0(v130, (uint64_t)a2);
        *(void *)(a1 + 32) = v130;
        *(_DWORD *)(a1 + 24) = 104;
        break;
      case 0x11Cu:
        uint64_t v131 = palloc(0x18uLL);
        pg_query__check_point_stmt__init(v131);
        *(void *)(a1 + 32) = v131;
        *(_DWORD *)(a1 + 24) = 105;
        break;
      case 0x11Du:
        BOOL v132 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_schema_stmt__init(v132);
        _outCreateSchemaStmt_0((uint64_t)v132, (uint64_t)a2);
        *(void *)(a1 + 32) = v132;
        *(_DWORD *)(a1 + 24) = 106;
        break;
      case 0x11Eu:
        uint64_t v133 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_database_stmt__init(v133);
        _outAlias_0(v133, (uint64_t)a2);
        *(void *)(a1 + 32) = v133;
        *(_DWORD *)(a1 + 24) = 107;
        break;
      case 0x11Fu:
        uint64_t v134 = palloc(0x28uLL);
        pg_query__alter_database_set_stmt__init(v134);
        _outAlterDatabaseSetStmt_0(v134, (uint64_t)a2);
        *(void *)(a1 + 32) = v134;
        *(_DWORD *)(a1 + 24) = 108;
        break;
      case 0x120u:
        uint64_t v135 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_role_set_stmt__init(v135);
        _outAlterRoleSetStmt_0(v135, a2);
        *(void *)(a1 + 32) = v135;
        *(_DWORD *)(a1 + 24) = 109;
        break;
      case 0x121u:
        uint64_t v136 = (_OWORD *)palloc(0x50uLL);
        pg_query__create_conversion_stmt__init(v136);
        _outCreateConversionStmt_0((uint64_t)v136, (uint64_t)a2);
        *(void *)(a1 + 32) = v136;
        *(_DWORD *)(a1 + 24) = 110;
        break;
      case 0x122u:
        uint64_t v137 = palloc(0x38uLL);
        pg_query__create_cast_stmt__init(v137);
        _outCreateCastStmt_0(v137, (uint64_t)a2);
        *(void *)(a1 + 32) = v137;
        *(_DWORD *)(a1 + 24) = 111;
        break;
      case 0x123u:
        uint64_t v138 = (_OWORD *)palloc(0x60uLL);
        pg_query__create_op_class_stmt__init(v138);
        _outCreateOpClassStmt_0((uint64_t)v138, (uint64_t)a2);
        *(void *)(a1 + 32) = v138;
        *(_DWORD *)(a1 + 24) = 112;
        break;
      case 0x124u:
        uint64_t v139 = (_OWORD *)palloc(0x30uLL);
        pg_query__create_op_family_stmt__init(v139);
        _outCreateOpFamilyStmt_0(v139, (uint64_t)a2);
        *(void *)(a1 + 32) = v139;
        *(_DWORD *)(a1 + 24) = 113;
        break;
      case 0x125u:
        uint64_t v140 = palloc(0x48uLL);
        pg_query__alter_op_family_stmt__init(v140);
        _outAlterOpFamilyStmt_0(v140, (uint64_t)a2);
        *(void *)(a1 + 32) = v140;
        *(_DWORD *)(a1 + 24) = 114;
        break;
      case 0x126u:
        uint64_t v141 = (void *)palloc(0x38uLL);
        pg_query__prepare_stmt__init((uint64_t)v141);
        _outPrepareStmt_0(v141, a2);
        *(void *)(a1 + 32) = v141;
        *(_DWORD *)(a1 + 24) = 115;
        break;
      case 0x127u:
        uint64_t v142 = (_OWORD *)palloc(0x30uLL);
        pg_query__execute_stmt__init(v142);
        _outAlias_0(v142, (uint64_t)a2);
        *(void *)(a1 + 32) = v142;
        *(_DWORD *)(a1 + 24) = 116;
        break;
      case 0x128u:
        uint64_t v143 = palloc(0x20uLL);
        pg_query__deallocate_stmt__init((_OWORD *)v143);
        uint64_t v144 = (const char *)*((void *)a2 + 1);
        if (v144) {
          *(void *)(v143 + 24) = pstrdup(v144);
        }
        *(void *)(a1 + 32) = v143;
        *(_DWORD *)(a1 + 24) = 117;
        break;
      case 0x129u:
        uint64_t v145 = (_OWORD *)palloc(0x30uLL);
        pg_query__declare_cursor_stmt__init(v145);
        _outDeclareCursorStmt_0((uint64_t)v145, (uint64_t)a2);
        *(void *)(a1 + 32) = v145;
        *(_DWORD *)(a1 + 24) = 118;
        break;
      case 0x12Au:
        uint64_t v146 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_table_space_stmt__init(v146);
        _outCreateTableSpaceStmt_0(v146, a2);
        *(void *)(a1 + 32) = v146;
        *(_DWORD *)(a1 + 24) = 119;
        break;
      case 0x12Bu:
        uint64_t v147 = palloc(0x28uLL);
        pg_query__drop_table_space_stmt__init(v147);
        uint64_t v148 = (const char *)*((void *)a2 + 1);
        if (v148) {
          *(void *)(v147 + 24) = pstrdup(v148);
        }
        *(_DWORD *)(v147 + 32) = *((unsigned __int8 *)a2 + 16);
        *(void *)(a1 + 32) = v147;
        *(_DWORD *)(a1 + 24) = 120;
        break;
      case 0x12Cu:
        uint64_t v149 = (char *)palloc(0x40uLL);
        pg_query__alter_object_depends_stmt__init(v149);
        _outAlterObjectDependsStmt_0(v149, (uint64_t)a2);
        *(void *)(a1 + 32) = v149;
        *(_DWORD *)(a1 + 24) = 121;
        break;
      case 0x12Du:
        uint64_t v150 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_object_schema_stmt__init(v150);
        _outAlterObjectSchemaStmt_0((uint64_t)v150, (uint64_t)a2);
        *(void *)(a1 + 32) = v150;
        *(_DWORD *)(a1 + 24) = 122;
        break;
      case 0x12Eu:
        uint64_t v151 = (void *)palloc(0x38uLL);
        pg_query__alter_owner_stmt__init((uint64_t)v151);
        _outAlterOwnerStmt_0(v151, (uint64_t)a2);
        *(void *)(a1 + 32) = v151;
        *(_DWORD *)(a1 + 24) = 123;
        break;
      case 0x12Fu:
        uint64_t v152 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_operator_stmt__init(v152);
        _outAlterOperatorStmt_0((uint64_t)v152, (uint64_t)a2);
        *(void *)(a1 + 32) = v152;
        *(_DWORD *)(a1 + 24) = 124;
        break;
      case 0x130u:
        uint64_t v153 = palloc(0x38uLL);
        pg_query__alter_type_stmt__init(v153);
        _outAlterTypeStmt_0(v153, (uint64_t)a2);
        *(void *)(a1 + 32) = v153;
        *(_DWORD *)(a1 + 24) = 125;
        break;
      case 0x131u:
        uint64_t v154 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_owned_stmt__init(v154);
        _outDropOwnedStmt_0((uint64_t)v154, (uint64_t)a2);
        *(void *)(a1 + 32) = v154;
        *(_DWORD *)(a1 + 24) = 126;
        break;
      case 0x132u:
        uint64_t v155 = (_OWORD *)palloc(0x30uLL);
        pg_query__reassign_owned_stmt__init(v155);
        _outReassignOwnedStmt_0((uint64_t)v155, (uint64_t)a2);
        *(void *)(a1 + 32) = v155;
        *(_DWORD *)(a1 + 24) = 127;
        break;
      case 0x133u:
        BOOL v156 = (_OWORD *)palloc(0x30uLL);
        pg_query__composite_type_stmt__init(v156);
        _outCompositeTypeStmt_0((uint64_t)v156, (uint64_t)a2);
        *(void *)(a1 + 32) = v156;
        *(_DWORD *)(a1 + 24) = 128;
        break;
      case 0x134u:
        uint64_t v157 = palloc(0x38uLL);
        pg_query__create_enum_stmt__init(v157);
        _outAlterTypeStmt_0(v157, (uint64_t)a2);
        *(void *)(a1 + 32) = v157;
        *(_DWORD *)(a1 + 24) = 129;
        break;
      case 0x135u:
        uint64_t v158 = palloc(0x38uLL);
        pg_query__create_range_stmt__init(v158);
        _outAlterTypeStmt_0(v158, (uint64_t)a2);
        *(void *)(a1 + 32) = v158;
        *(_DWORD *)(a1 + 24) = 130;
        break;
      case 0x136u:
        uint64_t v159 = palloc(0x48uLL);
        pg_query__alter_enum_stmt__init(v159);
        _outAlterEnumStmt_0(v159, (uint64_t)a2);
        *(void *)(a1 + 32) = v159;
        *(_DWORD *)(a1 + 24) = 131;
        break;
      case 0x137u:
        uint64_t v160 = palloc(0x38uLL);
        pg_query__alter_tsdictionary_stmt__init(v160);
        _outAlterTypeStmt_0(v160, (uint64_t)a2);
        *(void *)(a1 + 32) = v160;
        *(_DWORD *)(a1 + 24) = 132;
        break;
      case 0x138u:
        uint64_t v161 = (_OWORD *)palloc(0x60uLL);
        pg_query__alter_tsconfiguration_stmt__init(v161);
        _outAlterTSConfigurationStmt_0((uint64_t)v161, (uint64_t)a2);
        *(void *)(a1 + 32) = v161;
        *(_DWORD *)(a1 + 24) = 133;
        break;
      case 0x139u:
        uint64_t v162 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_fdw_stmt__init(v162);
        _outCreateFdwStmt_0(v162, a2);
        *(void *)(a1 + 32) = v162;
        *(_DWORD *)(a1 + 24) = 134;
        break;
      case 0x13Au:
        uint64_t v163 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_fdw_stmt__init(v163);
        _outCreateFdwStmt_0(v163, a2);
        *(void *)(a1 + 32) = v163;
        *(_DWORD *)(a1 + 24) = 135;
        break;
      case 0x13Bu:
        uint64_t v164 = (_OWORD *)palloc(0x50uLL);
        pg_query__create_foreign_server_stmt__init(v164);
        _outCreateForeignServerStmt_0((uint64_t)v164, (uint64_t)a2);
        *(void *)(a1 + 32) = v164;
        *(_DWORD *)(a1 + 24) = 136;
        break;
      case 0x13Cu:
        uint64_t v165 = (_OWORD *)palloc(0x40uLL);
        pg_query__alter_foreign_server_stmt__init(v165);
        _outAlterForeignServerStmt_0((uint64_t)v165, (uint64_t)a2);
        *(void *)(a1 + 32) = v165;
        *(_DWORD *)(a1 + 24) = 137;
        break;
      case 0x13Du:
        uint64_t v166 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_user_mapping_stmt__init(v166);
        _outCreateUserMappingStmt_0((uint64_t)v166, (uint64_t)a2);
        *(void *)(a1 + 32) = v166;
        *(_DWORD *)(a1 + 24) = 138;
        break;
      case 0x13Eu:
        uint64_t v167 = (void *)palloc(0x38uLL);
        pg_query__alter_user_mapping_stmt__init((uint64_t)v167);
        _outAlterUserMappingStmt_0(v167, a2);
        *(void *)(a1 + 32) = v167;
        *(_DWORD *)(a1 + 24) = 139;
        break;
      case 0x13Fu:
        BOOL v168 = (_OWORD *)palloc(0x30uLL);
        pg_query__drop_user_mapping_stmt__init(v168);
        _outDropUserMappingStmt_0((uint64_t)v168, (uint64_t)a2);
        *(void *)(a1 + 32) = v168;
        *(_DWORD *)(a1 + 24) = 140;
        break;
      case 0x140u:
        uint64_t v169 = palloc(0x38uLL);
        pg_query__alter_table_space_options_stmt__init(v169);
        _outAlterTableSpaceOptionsStmt_0(v169, (uint64_t)a2);
        *(void *)(a1 + 32) = v169;
        *(_DWORD *)(a1 + 24) = 141;
        break;
      case 0x141u:
        uint64_t v170 = palloc(0x48uLL);
        pg_query__alter_table_move_all_stmt__init(v170);
        _outAlterTableMoveAllStmt_0(v170, (uint64_t)a2);
        *(void *)(a1 + 32) = v170;
        *(_DWORD *)(a1 + 24) = 142;
        break;
      case 0x142u:
        uint64_t v171 = palloc(0x38uLL);
        pg_query__sec_label_stmt__init(v171);
        _outSecLabelStmt_0(v171, (uint64_t)a2);
        *(void *)(a1 + 32) = v171;
        *(_DWORD *)(a1 + 24) = 143;
        break;
      case 0x143u:
        uint64_t v172 = (void *)palloc(0x38uLL);
        pg_query__create_foreign_table_stmt__init((uint64_t)v172);
        _outCreateForeignTableStmt_0(v172, (uint64_t)a2);
        *(void *)(a1 + 32) = v172;
        *(_DWORD *)(a1 + 24) = 144;
        break;
      case 0x144u:
        uint64_t v173 = palloc(0x58uLL);
        pg_query__import_foreign_schema_stmt__init(v173);
        _outImportForeignSchemaStmt_0(v173, (uint64_t)a2);
        *(void *)(a1 + 32) = v173;
        *(_DWORD *)(a1 + 24) = 145;
        break;
      case 0x145u:
        uint64_t v174 = palloc(0x38uLL);
        pg_query__create_extension_stmt__init(v174);
        _outDropdbStmt_0(v174, (uint64_t)a2);
        *(void *)(a1 + 32) = v174;
        *(_DWORD *)(a1 + 24) = 146;
        break;
      case 0x146u:
        uint64_t v175 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_extension_stmt__init(v175);
        _outAlias_0(v175, (uint64_t)a2);
        *(void *)(a1 + 32) = v175;
        *(_DWORD *)(a1 + 24) = 147;
        break;
      case 0x147u:
        uint64_t v176 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_extension_contents_stmt__init(v176);
        _outAlterExtensionContentsStmt_0((uint64_t)v176, (uint64_t)a2);
        *(void *)(a1 + 32) = v176;
        *(_DWORD *)(a1 + 24) = 148;
        break;
      case 0x148u:
        uint64_t v177 = (void *)palloc(0x48uLL);
        pg_query__create_event_trig_stmt__init((uint64_t)v177);
        _outCreateEventTrigStmt_0(v177, a2);
        *(void *)(a1 + 32) = v177;
        *(_DWORD *)(a1 + 24) = 149;
        break;
      case 0x149u:
        uint64_t v178 = palloc(0x28uLL);
        pg_query__alter_event_trig_stmt__init(v178);
        _outAlterEventTrigStmt_0(v178, (uint64_t)a2);
        *(void *)(a1 + 32) = v178;
        *(_DWORD *)(a1 + 24) = 150;
        break;
      case 0x14Au:
        uint64_t v179 = (char *)palloc(0x28uLL);
        pg_query__refresh_mat_view_stmt__init((uint64_t)v179);
        _outRefreshMatViewStmt_0(v179, (uint64_t)a2);
        *(void *)(a1 + 32) = v179;
        *(_DWORD *)(a1 + 24) = 151;
        break;
      case 0x14Bu:
        uint64_t v180 = palloc(0x28uLL);
        pg_query__replica_identity_stmt__init(v180);
        _outReplicaIdentityStmt_0(v180, (uint64_t)a2);
        *(void *)(a1 + 32) = v180;
        *(_DWORD *)(a1 + 24) = 152;
        break;
      case 0x14Cu:
        uint64_t v181 = (char *)palloc(0x20uLL);
        pg_query__alter_system_stmt__init(v181);
        _outAlterSystemStmt_0(v181, (uint64_t)a2);
        *(void *)(a1 + 32) = v181;
        *(_DWORD *)(a1 + 24) = 153;
        break;
      case 0x14Du:
        uint64_t v182 = palloc(0x58uLL);
        pg_query__create_policy_stmt__init(v182);
        _outCreatePolicyStmt_0(v182, (uint64_t)a2);
        *(void *)(a1 + 32) = v182;
        *(_DWORD *)(a1 + 24) = 154;
        break;
      case 0x14Eu:
        uint64_t v183 = (void *)palloc(0x48uLL);
        pg_query__alter_policy_stmt__init((uint64_t)v183);
        _outAlterPolicyStmt_0(v183, a2);
        *(void *)(a1 + 32) = v183;
        *(_DWORD *)(a1 + 24) = 155;
        break;
      case 0x14Fu:
        uint64_t v184 = (_OWORD *)palloc(0x40uLL);
        pg_query__create_transform_stmt__init(v184);
        _outCreateTransformStmt_0((uint64_t)v184, (uint64_t)a2);
        *(void *)(a1 + 32) = v184;
        *(_DWORD *)(a1 + 24) = 156;
        break;
      case 0x150u:
        uint64_t v185 = (void *)palloc(0x38uLL);
        pg_query__create_am_stmt__init((uint64_t)v185);
        _outCreateAmStmt_0(v185, (uint64_t)a2);
        *(void *)(a1 + 32) = v185;
        *(_DWORD *)(a1 + 24) = 157;
        break;
      case 0x151u:
        uint64_t v186 = palloc(0x48uLL);
        pg_query__create_publication_stmt__init(v186);
        _outCreatePublicationStmt_0(v186, (uint64_t)a2);
        *(void *)(a1 + 32) = v186;
        *(_DWORD *)(a1 + 24) = 158;
        break;
      case 0x152u:
        uint64_t v187 = palloc(0x48uLL);
        pg_query__alter_publication_stmt__init(v187);
        _outAlterPublicationStmt_0(v187, (uint64_t)a2);
        *(void *)(a1 + 32) = v187;
        *(_DWORD *)(a1 + 24) = 159;
        break;
      case 0x153u:
        uint64_t v188 = (void *)palloc(0x48uLL);
        pg_query__create_subscription_stmt__init((uint64_t)v188);
        _outCreateEventTrigStmt_0(v188, a2);
        *(void *)(a1 + 32) = v188;
        *(_DWORD *)(a1 + 24) = 160;
        break;
      case 0x154u:
        uint64_t v189 = (_OWORD *)palloc(0x50uLL);
        pg_query__alter_subscription_stmt__init(v189);
        _outAlterSubscriptionStmt_0((uint64_t)v189, (uint64_t)a2);
        *(void *)(a1 + 32) = v189;
        *(_DWORD *)(a1 + 24) = 161;
        break;
      case 0x155u:
        uint64_t v190 = palloc(0x28uLL);
        pg_query__drop_subscription_stmt__init(v190);
        _outDropSubscriptionStmt_0(v190, (uint64_t)a2);
        *(void *)(a1 + 32) = v190;
        *(_DWORD *)(a1 + 24) = 162;
        break;
      case 0x156u:
        uint64_t v191 = palloc(0x68uLL);
        pg_query__create_stats_stmt__init(v191);
        _outCreateStatsStmt_0(v191, (uint64_t)a2);
        *(void *)(a1 + 32) = v191;
        *(_DWORD *)(a1 + 24) = 163;
        break;
      case 0x157u:
        uint64_t v192 = palloc(0x28uLL);
        pg_query__alter_collation_stmt__init(v192);
        _outDoStmt_0(v192, (uint64_t)a2);
        *(void *)(a1 + 32) = v192;
        *(_DWORD *)(a1 + 24) = 164;
        break;
      case 0x158u:
        uint64_t v193 = palloc(0x28uLL);
        pg_query__call_stmt__init(v193);
        _outCallStmt_0(v193, (uint64_t)a2);
        *(void *)(a1 + 32) = v193;
        *(_DWORD *)(a1 + 24) = 165;
        break;
      case 0x159u:
        uint64_t v194 = (_OWORD *)palloc(0x30uLL);
        pg_query__alter_stats_stmt__init(v194);
        _outLockStmt_0((uint64_t)v194, (uint64_t)a2);
        *(void *)(a1 + 32) = v194;
        *(_DWORD *)(a1 + 24) = 166;
        break;
      case 0x15Au:
        uint64_t v195 = palloc(0x48uLL);
        pg_query__a__expr__init(v195);
        _outAExpr_0(v195, (uint64_t)a2);
        *(void *)(a1 + 32) = v195;
        *(_DWORD *)(a1 + 24) = 167;
        break;
      case 0x15Bu:
        uint64_t v196 = (_OWORD *)palloc(0x30uLL);
        pg_query__column_ref__init(v196);
        _outColumnRef_0((uint64_t)v196, (uint64_t)a2);
        *(void *)(a1 + 32) = v196;
        *(_DWORD *)(a1 + 24) = 168;
        break;
      case 0x15Cu:
        uint64_t v197 = palloc(0x20uLL);
        pg_query__param_ref__init((_OWORD *)v197);
        *(_DWORD *)(v197 + 24) = a2[1];
        *(_DWORD *)(v197 + 28) = a2[2];
        *(void *)(a1 + 32) = v197;
        *(_DWORD *)(a1 + 24) = 169;
        break;
      case 0x15Du:
        uint64_t v198 = palloc(0x28uLL);
        pg_query__a__const__init(v198);
        _outAConst_0(v198, (uint64_t)a2);
        *(void *)(a1 + 32) = v198;
        *(_DWORD *)(a1 + 24) = 170;
        break;
      case 0x15Eu:
        uint64_t v199 = (_OWORD *)palloc(0x70uLL);
        pg_query__func_call__init(v199);
        _outFuncCall_0((uint64_t)v199, (uint64_t)a2);
        *(void *)(a1 + 32) = v199;
        *(_DWORD *)(a1 + 24) = 171;
        break;
      case 0x15Fu:
        uint64_t v200 = palloc(0x18uLL);
        pg_query__a__star__init(v200);
        *(void *)(a1 + 32) = v200;
        *(_DWORD *)(a1 + 24) = 172;
        break;
      case 0x160u:
        uint64_t v201 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__indices__init(v201);
        _outAIndices_0((uint64_t)v201, (uint64_t)a2);
        *(void *)(a1 + 32) = v201;
        *(_DWORD *)(a1 + 24) = 173;
        break;
      case 0x161u:
        uint64_t v202 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__indirection__init(v202);
        _outExplainStmt_0((uint64_t)v202, (uint64_t)a2);
        *(void *)(a1 + 32) = v202;
        *(_DWORD *)(a1 + 24) = 174;
        break;
      case 0x162u:
        uint64_t v203 = (_OWORD *)palloc(0x30uLL);
        pg_query__a__array_expr__init(v203);
        _outColumnRef_0((uint64_t)v203, (uint64_t)a2);
        *(void *)(a1 + 32) = v203;
        *(_DWORD *)(a1 + 24) = 175;
        break;
      case 0x163u:
        uint64_t v204 = (_OWORD *)palloc(0x40uLL);
        pg_query__res_target__init(v204);
        _outResTarget_0((uint64_t)v204, (uint64_t)a2);
        *(void *)(a1 + 32) = v204;
        *(_DWORD *)(a1 + 24) = 176;
        break;
      case 0x164u:
        uint64_t v205 = palloc(0x28uLL);
        pg_query__multi_assign_ref__init(v205);
        _outRawStmt_0(v205, (uint64_t)a2);
        *(void *)(a1 + 32) = v205;
        *(_DWORD *)(a1 + 24) = 177;
        break;
      case 0x165u:
        uint64_t v206 = (_OWORD *)palloc(0x30uLL);
        pg_query__type_cast__init(v206);
        _outTypeCast_0((uint64_t)v206, (uint64_t)a2);
        *(void *)(a1 + 32) = v206;
        *(_DWORD *)(a1 + 24) = 178;
        break;
      case 0x166u:
        uint64_t v207 = palloc(0x38uLL);
        pg_query__collate_clause__init(v207);
        _outCollateClause_0(v207, (uint64_t)a2);
        *(void *)(a1 + 32) = v207;
        *(_DWORD *)(a1 + 24) = 179;
        break;
      case 0x167u:
        uint64_t v208 = (_OWORD *)palloc(0x40uLL);
        pg_query__sort_by__init(v208);
        _outSortBy_0((uint64_t)v208, (uint64_t)a2);
        *(void *)(a1 + 32) = v208;
        *(_DWORD *)(a1 + 24) = 180;
        break;
      case 0x168u:
        uint64_t v209 = palloc(0x68uLL);
        pg_query__window_def__init(v209);
        _outWindowDef_0(v209, (uint64_t)a2);
        *(void *)(a1 + 32) = v209;
        *(_DWORD *)(a1 + 24) = 181;
        break;
      case 0x169u:
        uint64_t v210 = (char *)palloc(0x30uLL);
        pg_query__range_subselect__init(v210);
        _outRangeSubselect_0(v210, (uint64_t)a2);
        *(void *)(a1 + 32) = v210;
        *(_DWORD *)(a1 + 24) = 182;
        break;
      case 0x16Au:
        int v211 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_function__init(v211);
        _outRangeFunction_0((uint64_t)v211, (uint64_t)a2);
        *(void *)(a1 + 32) = v211;
        *(_DWORD *)(a1 + 24) = 183;
        break;
      case 0x16Bu:
        uint64_t v212 = (_OWORD *)palloc(0x50uLL);
        pg_query__range_table_sample__init(v212);
        _outRangeTableSample_0((uint64_t)v212, (uint64_t)a2);
        *(void *)(a1 + 32) = v212;
        *(_DWORD *)(a1 + 24) = 184;
        break;
      case 0x16Cu:
        uint64_t v213 = (_OWORD *)palloc(0x60uLL);
        pg_query__range_table_func__init(v213);
        _outRangeTableFunc_0((uint64_t)v213, (uint64_t)a2);
        *(void *)(a1 + 32) = v213;
        *(_DWORD *)(a1 + 24) = 185;
        break;
      case 0x16Du:
        uint64_t v214 = palloc(0x48uLL);
        pg_query__range_table_func_col__init(v214);
        _outRangeTableFuncCol_0(v214, (uint64_t)a2);
        *(void *)(a1 + 32) = v214;
        *(_DWORD *)(a1 + 24) = 186;
        break;
      case 0x16Eu:
        uint64_t v215 = palloc(0x68uLL);
        pg_query__type_name__init(v215);
        _outTypeName_0(v215, (uint64_t)a2);
        *(void *)(a1 + 32) = v215;
        *(_DWORD *)(a1 + 24) = 187;
        break;
      case 0x16Fu:
        uint64_t v216 = (_OWORD *)palloc(0xA0uLL);
        pg_query__column_def__init(v216);
        _outColumnDef_0((uint64_t)v216, (uint64_t)a2);
        *(void *)(a1 + 32) = v216;
        *(_DWORD *)(a1 + 24) = 188;
        break;
      case 0x170u:
        uint64_t v217 = palloc(0x68uLL);
        pg_query__index_elem__init(v217);
        _outIndexElem_0(v217, (uint64_t)a2);
        *(void *)(a1 + 32) = v217;
        *(_DWORD *)(a1 + 24) = 189;
        break;
      case 0x171u:
        uint64_t v218 = (void *)palloc(0x118uLL);
        pg_query__constraint__init(v218);
        _outConstraint_0((uint64_t)v218, (uint64_t)a2);
        *(void *)(a1 + 32) = v218;
        *(_DWORD *)(a1 + 24) = 190;
        break;
      case 0x172u:
        uint64_t v219 = palloc(0x38uLL);
        pg_query__def_elem__init(v219);
        _outDefElem_0(v219, (uint64_t)a2);
        *(void *)(a1 + 32) = v219;
        *(_DWORD *)(a1 + 24) = 191;
        break;
      case 0x173u:
        uint64_t v220 = (void *)palloc(0x178uLL);
        pg_query__range_tbl_entry__init(v220);
        _outRangeTblEntry_0((uint64_t)v220, (uint64_t)a2);
        *(void *)(a1 + 32) = v220;
        *(_DWORD *)(a1 + 24) = 192;
        break;
      case 0x174u:
        uint64_t v221 = palloc(0x78uLL);
        pg_query__range_tbl_function__init(v221);
        _outRangeTblFunction_0(v221, (uint64_t)a2);
        *(void *)(a1 + 32) = v221;
        *(_DWORD *)(a1 + 24) = 193;
        break;
      case 0x175u:
        uint64_t v222 = palloc(0x38uLL);
        pg_query__table_sample_clause__init(v222);
        _outTableSampleClause_0(v222, (uint64_t)a2);
        *(void *)(a1 + 32) = v222;
        *(_DWORD *)(a1 + 24) = 194;
        break;
      case 0x176u:
        uint64_t v223 = (_OWORD *)palloc(0x40uLL);
        pg_query__with_check_option__init(v223);
        _outWithCheckOption_0((uint64_t)v223, (uint64_t)a2);
        *(void *)(a1 + 32) = v223;
        *(_DWORD *)(a1 + 24) = 195;
        break;
      case 0x177u:
        uint64_t v224 = palloc(0x30uLL);
        pg_query__sort_group_clause__init((_OWORD *)v224);
        *(_DWORD *)(v224 + 24) = a2[1];
        *(_DWORD *)(v224 + 28) = a2[2];
        *(_DWORD *)(v224 + 32) = a2[3];
        *(_DWORD *)(v224 + 36) = *((unsigned __int8 *)a2 + 16);
        *(_DWORD *)(v224 + 4errstart(20, 0) = *((unsigned __int8 *)a2 + 17);
        *(void *)(a1 + 32) = v224;
        *(_DWORD *)(a1 + 24) = 196;
        break;
      case 0x178u:
        uint64_t v225 = palloc(0x38uLL);
        pg_query__grouping_set__init(v225);
        _outGroupingSet_0(v225, (uint64_t)a2);
        *(void *)(a1 + 32) = v225;
        *(_DWORD *)(a1 + 24) = 197;
        break;
      case 0x179u:
        int v226 = (_OWORD *)palloc(0x80uLL);
        pg_query__window_clause__init(v226);
        _outWindowClause_0((uint64_t)v226, (uint64_t)a2);
        *(void *)(a1 + 32) = v226;
        *(_DWORD *)(a1 + 24) = 198;
        break;
      case 0x17Au:
        uint64_t v227 = (_OWORD *)palloc(0x40uLL);
        pg_query__object_with_args__init(v227);
        _outVacuumStmt_0((uint64_t)v227, (uint64_t)a2);
        *(void *)(a1 + 32) = v227;
        *(_DWORD *)(a1 + 24) = 199;
        break;
      case 0x17Bu:
        uint64_t v228 = (_OWORD *)palloc(0x30uLL);
        pg_query__access_priv__init(v228);
        _outAlias_0(v228, (uint64_t)a2);
        *(void *)(a1 + 32) = v228;
        *(_DWORD *)(a1 + 24) = 200;
        break;
      case 0x17Cu:
        uint64_t v229 = palloc(0x58uLL);
        pg_query__create_op_class_item__init(v229);
        _outCreateOpClassItem_0(v229, (uint64_t)a2);
        *(void *)(a1 + 32) = v229;
        *(_DWORD *)(a1 + 24) = 201;
        break;
      case 0x17Du:
        uint64_t v230 = (char *)palloc(0x28uLL);
        pg_query__table_like_clause__init((uint64_t)v230);
        _outTableLikeClause_0(v230, (uint64_t)a2);
        *(void *)(a1 + 32) = v230;
        *(_DWORD *)(a1 + 24) = 202;
        break;
      case 0x17Eu:
        uint64_t v231 = palloc(0x38uLL);
        pg_query__function_parameter__init(v231);
        _outFunctionParameter_0(v231, (uint64_t)a2);
        *(void *)(a1 + 32) = v231;
        *(_DWORD *)(a1 + 24) = 203;
        break;
      case 0x17Fu:
        uint64_t v232 = (_OWORD *)palloc(0x30uLL);
        pg_query__locking_clause__init(v232);
        _outLockingClause_0((uint64_t)v232, (uint64_t)a2);
        *(void *)(a1 + 32) = v232;
        *(_DWORD *)(a1 + 24) = 204;
        break;
      case 0x180u:
        uint64_t v233 = (_DWORD *)palloc(0x28uLL);
        pg_query__row_mark_clause__init((uint64_t)v233);
        _outRowMarkClause_0(v233, (uint64_t)a2);
        *(void *)(a1 + 32) = v233;
        *(_DWORD *)(a1 + 24) = 205;
        break;
      case 0x181u:
        uint64_t v234 = palloc(0x38uLL);
        pg_query__xml_serialize__init(v234);
        _outXmlSerialize_0(v234, (uint64_t)a2);
        *(void *)(a1 + 32) = v234;
        *(_DWORD *)(a1 + 24) = 206;
        break;
      case 0x182u:
        uint64_t v235 = (_OWORD *)palloc(0x30uLL);
        pg_query__with_clause__init(v235);
        _outWithClause_0((uint64_t)v235, (uint64_t)a2);
        *(void *)(a1 + 32) = v235;
        *(_DWORD *)(a1 + 24) = 207;
        break;
      case 0x183u:
        uint64_t v236 = (_OWORD *)palloc(0x40uLL);
        pg_query__infer_clause__init(v236);
        _outInferClause_0((uint64_t)v236, (uint64_t)a2);
        *(void *)(a1 + 32) = v236;
        *(_DWORD *)(a1 + 24) = 208;
        break;
      case 0x184u:
        uint64_t v237 = palloc(0x48uLL);
        pg_query__on_conflict_clause__init(v237);
        _outOnConflictClause_0(v237, (uint64_t)a2);
        *(void *)(a1 + 32) = v237;
        *(_DWORD *)(a1 + 24) = 209;
        break;
      case 0x185u:
        uint64_t v238 = (_OWORD *)palloc(0x90uLL);
        pg_query__common_table_expr__init(v238);
        _outCommonTableExpr_0((uint64_t)v238, (uint64_t)a2);
        *(void *)(a1 + 32) = v238;
        *(_DWORD *)(a1 + 24) = 210;
        break;
      case 0x186u:
        uint64_t v239 = (_OWORD *)palloc(0x30uLL);
        pg_query__role_spec__init(v239);
        _outRoleSpec_0((uint64_t)v239, (uint64_t)a2);
        *(void *)(a1 + 32) = v239;
        *(_DWORD *)(a1 + 24) = 211;
        break;
      case 0x187u:
        uint64_t v240 = palloc(0x28uLL);
        pg_query__trigger_transition__init(v240);
        uint64_t v241 = (const char *)*((void *)a2 + 1);
        if (v241) {
          *(void *)(v240 + 24) = pstrdup(v241);
        }
        *(_DWORD *)(v240 + 32) = *((unsigned __int8 *)a2 + 16);
        *(_DWORD *)(v240 + 36) = *((unsigned __int8 *)a2 + 17);
        *(void *)(a1 + 32) = v240;
        *(_DWORD *)(a1 + 24) = 212;
        break;
      case 0x188u:
        uint64_t v242 = (_OWORD *)palloc(0x50uLL);
        pg_query__partition_elem__init(v242);
        _outPartitionElem_0((uint64_t)v242, (uint64_t)a2);
        *(void *)(a1 + 32) = v242;
        *(_DWORD *)(a1 + 24) = 213;
        break;
      case 0x189u:
        uint64_t v243 = palloc(0x38uLL);
        pg_query__partition_spec__init(v243);
        _outPartitionSpec_0(v243, (uint64_t)a2);
        *(void *)(a1 + 32) = v243;
        *(_DWORD *)(a1 + 24) = 214;
        break;
      case 0x18Au:
        uint64_t v244 = (unsigned char *)palloc(0x68uLL);
        pg_query__partition_bound_spec__init((uint64_t)v244);
        _outPartitionBoundSpec_0(v244, (uint64_t)a2);
        *(void *)(a1 + 32) = v244;
        *(_DWORD *)(a1 + 24) = 215;
        break;
      case 0x18Bu:
        uint64_t v245 = (_OWORD *)palloc(0x30uLL);
        pg_query__partition_range_datum__init(v245);
        _outPartitionRangeDatum_0((uint64_t)v245, (uint64_t)a2);
        *(void *)(a1 + 32) = v245;
        *(_DWORD *)(a1 + 24) = 216;
        break;
      case 0x18Cu:
        uint64_t v246 = (char *)palloc(0x28uLL);
        pg_query__partition_cmd__init((uint64_t)v246);
        _outPartitionCmd_0(v246, (uint64_t)a2);
        *(void *)(a1 + 32) = v246;
        *(_DWORD *)(a1 + 24) = 217;
        break;
      case 0x18Du:
        uint64_t v247 = palloc(0x38uLL);
        pg_query__vacuum_relation__init(v247);
        _outVacuumRelation_0(v247, (uint64_t)a2);
        *(void *)(a1 + 32) = v247;
        *(_DWORD *)(a1 + 24) = 218;
        break;
      case 0x19Au:
        uint64_t v248 = (_OWORD *)palloc(0x30uLL);
        pg_query__inline_code_block__init(v248);
        _outInlineCodeBlock_0((uint64_t)v248, (uint64_t)a2);
        *(void *)(a1 + 32) = v248;
        *(_DWORD *)(a1 + 24) = 219;
        break;
      case 0x1A0u:
        uint64_t v249 = palloc(0x20uLL);
        pg_query__call_context__init((_OWORD *)v249);
        *(_DWORD *)(v249 + 24) = *((unsigned __int8 *)a2 + 4);
        *(void *)(a1 + 32) = v249;
        *(_DWORD *)(a1 + 24) = 220;
        break;
      default:
        pg_printf("could not dump unrecognized node type: %d", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a2);
        if (errstart(19, 0))
        {
          errmsg_internal("could not dump unrecognized node type: %d", *a2);
          errfinish("src/pg_query_outfuncs_protobuf.c", 198, (uint64_t)"_outNode");
        }
        break;
    }
  }
}

uint64_t _outList_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a2 + 4);
  *(void *)(a1 + 24) = v4;
  uint64_t result = palloc(8 * v4);
  *(void *)(a1 + 32) = result;
  if (*(int *)(a2 + 4) >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(a2 + 16);
      *(void *)(*(void *)(a1 + 32) + 8 * v6) = palloc(0x28uLL);
      double node__init = pg_query__node__init(*(void *)(*(void *)(a1 + 32) + 8 * v6));
      uint64_t result = _outNode_0(*(void *)(*(void *)(a1 + 32) + 8 * v6), *(void *)(v7 + 8 * v6), node__init);
      ++v6;
    }
    while (v6 < *(int *)(a2 + 4));
  }
  return result;
}

const char *_outAlias_0(void *a1, uint64_t a2)
{
  uint64_t result = *(const char **)(a2 + 8);
  if (result)
  {
    uint64_t result = (const char *)pstrdup(result);
    a1[3] = result;
  }
  uint64_t v5 = *(void *)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = *(int *)(v5 + 4);
    a1[4] = v6;
    uint64_t result = (const char *)palloc(8 * v6);
    a1[5] = result;
    if (a1[4])
    {
      unint64_t v7 = 0;
      int v8 = 1;
      do
      {
        uint64_t v9 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v9);
        *(void *)(a1[5] + 8 * v7) = v9;
        uint64_t result = (const char *)_outNode_0(*(void *)(a1[5] + 8 * v7), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v7), node__init);
        unint64_t v7 = v8++;
      }
      while (a1[4] > v7);
    }
  }
  return result;
}

char *_outRangeVar_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const char **)(a2 + 8);
  if (v4) {
    *(void *)(a1 + 24) = pstrdup(v4);
  }
  uint64_t v5 = *(const char **)(a2 + 16);
  if (v5) {
    *(void *)(a1 + 32) = pstrdup(v5);
  }
  uint64_t result = *(char **)(a2 + 24);
  if (result)
  {
    uint64_t result = (char *)pstrdup(result);
    *(void *)(a1 + 4errstart(20, 0) = result;
  }
  *(_DWORD *)(a1 + 48) = *(unsigned __int8 *)(a2 + 32);
  if (*(unsigned char *)(a2 + 33))
  {
    uint64_t result = (char *)palloc(2uLL);
    *(void *)(a1 + 56) = result;
    *uint64_t result = *(unsigned char *)(a2 + 33);
    *(unsigned char *)(*(void *)(a1 + 56) + 1) = 0;
  }
  if (*(void *)(a2 + 40))
  {
    unint64_t v7 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v7);
    uint64_t result = (char *)_outAlias_0(v7, *(void *)(a2 + 40));
    *(void *)(a1 + 64) = v7;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t _outTableFunc_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(a1 + 24) = v5;
    *(void *)(a1 + 32) = palloc(8 * v5);
    if (*(void *)(a1 + 24))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(a1 + 32) + 8 * v6) = v8;
        _outNode_0(*(void *)(*(void *)(a1 + 32) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(a1 + 24) > v6);
    }
  }
  uint64_t v10 = *(void *)(a2 + 16);
  if (v10)
  {
    uint64_t v11 = *(int *)(v10 + 4);
    *(void *)(a1 + 4errstart(20, 0) = v11;
    *(void *)(a1 + 48) = palloc(8 * v11);
    if (*(void *)(a1 + 40))
    {
      unint64_t v12 = 0;
      int v13 = 1;
      do
      {
        uint64_t v14 = palloc(0x28uLL);
        double v15 = pg_query__node__init(v14);
        *(void *)(*(void *)(a1 + 48) + 8 * v12) = v14;
        _outNode_0(*(void *)(*(void *)(a1 + 48) + 8 * v12), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v12), v15);
        unint64_t v12 = v13++;
      }
      while (*(void *)(a1 + 40) > v12);
    }
  }
  if (*(void *)(a2 + 24))
  {
    uint64_t v16 = palloc(0x28uLL);
    double v17 = pg_query__node__init(v16);
    *(void *)(a1 + 56) = v16;
    _outNode_0(v16, *(void *)(a2 + 24), v17);
  }
  if (*(void *)(a2 + 32))
  {
    uint64_t v18 = palloc(0x28uLL);
    double v19 = pg_query__node__init(v18);
    *(void *)(a1 + 64) = v18;
    _outNode_0(v18, *(void *)(a2 + 32), v19);
  }
  uint64_t v20 = *(void *)(a2 + 40);
  if (v20)
  {
    uint64_t v21 = *(int *)(v20 + 4);
    *(void *)(a1 + 72) = v21;
    *(void *)(a1 + 8errstart(20, 0) = palloc(8 * v21);
    if (*(void *)(a1 + 72))
    {
      unint64_t v22 = 0;
      int v23 = 1;
      do
      {
        uint64_t v24 = palloc(0x28uLL);
        double v25 = pg_query__node__init(v24);
        *(void *)(*(void *)(a1 + 80) + 8 * v22) = v24;
        _outNode_0(*(void *)(*(void *)(a1 + 80) + 8 * v22), *(void *)(*(void *)(*(void *)(a2 + 40) + 16) + 8 * v22), v25);
        unint64_t v22 = v23++;
      }
      while (*(void *)(a1 + 72) > v22);
    }
  }
  uint64_t v26 = *(void *)(a2 + 48);
  if (v26)
  {
    uint64_t v27 = *(int *)(v26 + 4);
    *(void *)(a1 + 88) = v27;
    *(void *)(a1 + 96) = palloc(8 * v27);
    if (*(void *)(a1 + 88))
    {
      unint64_t v28 = 0;
      int v29 = 1;
      do
      {
        uint64_t v30 = palloc(0x28uLL);
        double v31 = pg_query__node__init(v30);
        *(void *)(*(void *)(a1 + 96) + 8 * v28) = v30;
        _outNode_0(*(void *)(*(void *)(a1 + 96) + 8 * v28), *(void *)(*(void *)(*(void *)(a2 + 48) + 16) + 8 * v28), v31);
        unint64_t v28 = v29++;
      }
      while (*(void *)(a1 + 88) > v28);
    }
  }
  uint64_t v32 = *(void *)(a2 + 56);
  if (v32)
  {
    uint64_t v33 = *(int *)(v32 + 4);
    *(void *)(a1 + 104) = v33;
    *(void *)(a1 + 112) = palloc(8 * v33);
    if (*(void *)(a1 + 104))
    {
      unint64_t v34 = 0;
      int v35 = 1;
      do
      {
        uint64_t v36 = palloc(0x28uLL);
        double v37 = pg_query__node__init(v36);
        *(void *)(*(void *)(a1 + 112) + 8 * v34) = v36;
        _outNode_0(*(void *)(*(void *)(a1 + 112) + 8 * v34), *(void *)(*(void *)(*(void *)(a2 + 56) + 16) + 8 * v34), v37);
        unint64_t v34 = v35++;
      }
      while (*(void *)(a1 + 104) > v34);
    }
  }
  uint64_t v38 = *(void *)(a2 + 64);
  if (v38)
  {
    uint64_t v39 = *(int *)(v38 + 4);
    *(void *)(a1 + 12errstart(20, 0) = v39;
    *(void *)(a1 + 128) = palloc(8 * v39);
    if (*(void *)(a1 + 120))
    {
      unint64_t v40 = 0;
      int v41 = 1;
      do
      {
        uint64_t v42 = palloc(0x28uLL);
        double v43 = pg_query__node__init(v42);
        *(void *)(*(void *)(a1 + 128) + 8 * v4errstart(20, 0) = v42;
        _outNode_0(*(void *)(*(void *)(a1 + 128) + 8 * v40), *(void *)(*(void *)(*(void *)(a2 + 64) + 16) + 8 * v40), v43);
        unint64_t v40 = v41++;
      }
      while (*(void *)(a1 + 120) > v40);
    }
  }
  uint64_t v44 = *(void *)(a2 + 72);
  if (v44)
  {
    uint64_t v45 = *(int *)(v44 + 4);
    *(void *)(a1 + 136) = v45;
    *(void *)(a1 + 144) = palloc(8 * v45);
    if (*(void *)(a1 + 136))
    {
      unint64_t v46 = 0;
      int v47 = 1;
      do
      {
        uint64_t v48 = palloc(0x28uLL);
        double v49 = pg_query__node__init(v48);
        *(void *)(*(void *)(a1 + 144) + 8 * v46) = v48;
        _outNode_0(*(void *)(*(void *)(a1 + 144) + 8 * v46), *(void *)(*(void *)(*(void *)(a2 + 72) + 16) + 8 * v46), v49);
        unint64_t v46 = v47++;
      }
      while (*(void *)(a1 + 136) > v46);
    }
  }
  uint64_t v50 = *(void *)(a2 + 80);
  if (v50)
  {
    uint64_t v51 = *(int *)(v50 + 4);
    *(void *)(a1 + 152) = v51;
    *(void *)(a1 + 16errstart(20, 0) = palloc(8 * v51);
    if (*(void *)(a1 + 152))
    {
      unint64_t v52 = 0;
      int v53 = 1;
      do
      {
        uint64_t v54 = palloc(0x28uLL);
        double v55 = pg_query__node__init(v54);
        *(void *)(*(void *)(a1 + 160) + 8 * v52) = v54;
        _outNode_0(*(void *)(*(void *)(a1 + 160) + 8 * v52), *(void *)(*(void *)(*(void *)(a2 + 80) + 16) + 8 * v52), v55);
        unint64_t v52 = v53++;
      }
      while (*(void *)(a1 + 152) > v52);
    }
  }
  uint64_t result = bms_is_empty(*(unsigned int **)(a2 + 88));
  if ((result & 1) == 0)
  {
    int v57 = bms_num_members(*(unsigned int **)(a2 + 88));
    *(void *)(a1 + 168) = v57;
    *(void *)(a1 + 176) = palloc(8 * v57);
    uint64_t result = bms_first_member(*(_DWORD **)(a2 + 88));
    if ((result & 0x80000000) == 0)
    {
      int v58 = 0;
      do
      {
        int v59 = v58 + 1;
        *(void *)(*(void *)(a1 + 176) + 8 * v58) = result;
        uint64_t result = bms_first_member(*(_DWORD **)(a2 + 88));
        int v58 = v59;
      }
      while ((result & 0x80000000) == 0);
    }
  }
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 100);
  return result;
}

_DWORD *_outVar_0(_DWORD *result, uint64_t a2)
{
  result[8] = *(_DWORD *)(a2 + 4);
  result[9] = *(__int16 *)(a2 + 8);
  result[10] = *(_DWORD *)(a2 + 12);
  result[11] = *(_DWORD *)(a2 + 16);
  result[12] = *(_DWORD *)(a2 + 20);
  result[13] = *(_DWORD *)(a2 + 24);
  result[14] = *(_DWORD *)(a2 + 28);
  result[15] = *(__int16 *)(a2 + 32);
  result[16] = *(_DWORD *)(a2 + 36);
  return result;
}

_DWORD *_outParam_0(_DWORD *result, _DWORD *a2)
{
  unsigned int v2 = a2[1];
  if (v2 < 4) {
    int v3 = v2 + 1;
  }
  else {
    int v3 = -1;
  }
  result[8] = v3;
  result[9] = a2[2];
  result[10] = a2[3];
  result[11] = a2[4];
  result[12] = a2[5];
  result[13] = a2[6];
  return result;
}

uint64_t _outAggref_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 20);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 56) = v5;
    uint64_t result = palloc(8 * v5);
    *(void *)(v3 + 64) = result;
    if (*(void *)(v3 + 56))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 64) + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 64) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 56) > v6);
    }
  }
  uint64_t v10 = *(void *)(a2 + 32);
  if (v10)
  {
    uint64_t v11 = *(int *)(v10 + 4);
    *(void *)(v3 + 72) = v11;
    uint64_t result = palloc(8 * v11);
    *(void *)(v3 + 8errstart(20, 0) = result;
    if (*(void *)(v3 + 72))
    {
      unint64_t v12 = 0;
      int v13 = 1;
      do
      {
        uint64_t v14 = palloc(0x28uLL);
        double v15 = pg_query__node__init(v14);
        *(void *)(*(void *)(v3 + 80) + 8 * v12) = v14;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 80) + 8 * v12), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v12), v15);
        unint64_t v12 = v13++;
      }
      while (*(void *)(v3 + 72) > v12);
    }
  }
  uint64_t v16 = *(void *)(a2 + 40);
  if (v16)
  {
    uint64_t v17 = *(int *)(v16 + 4);
    *(void *)(v3 + 88) = v17;
    uint64_t result = palloc(8 * v17);
    *(void *)(v3 + 96) = result;
    if (*(void *)(v3 + 88))
    {
      unint64_t v18 = 0;
      int v19 = 1;
      do
      {
        uint64_t v20 = palloc(0x28uLL);
        double v21 = pg_query__node__init(v20);
        *(void *)(*(void *)(v3 + 96) + 8 * v18) = v20;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 96) + 8 * v18), *(void *)(*(void *)(*(void *)(a2 + 40) + 16) + 8 * v18), v21);
        unint64_t v18 = v19++;
      }
      while (*(void *)(v3 + 88) > v18);
    }
  }
  uint64_t v22 = *(void *)(a2 + 48);
  if (v22)
  {
    uint64_t v23 = *(int *)(v22 + 4);
    *(void *)(v3 + 104) = v23;
    uint64_t result = palloc(8 * v23);
    *(void *)(v3 + 112) = result;
    if (*(void *)(v3 + 104))
    {
      unint64_t v24 = 0;
      int v25 = 1;
      do
      {
        uint64_t v26 = palloc(0x28uLL);
        double v27 = pg_query__node__init(v26);
        *(void *)(*(void *)(v3 + 112) + 8 * v24) = v26;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 112) + 8 * v24), *(void *)(*(void *)(*(void *)(a2 + 48) + 16) + 8 * v24), v27);
        unint64_t v24 = v25++;
      }
      while (*(void *)(v3 + 104) > v24);
    }
  }
  uint64_t v28 = *(void *)(a2 + 56);
  if (v28)
  {
    uint64_t v29 = *(int *)(v28 + 4);
    *(void *)(v3 + 12errstart(20, 0) = v29;
    uint64_t result = palloc(8 * v29);
    *(void *)(v3 + 128) = result;
    if (*(void *)(v3 + 120))
    {
      unint64_t v30 = 0;
      int v31 = 1;
      do
      {
        uint64_t v32 = palloc(0x28uLL);
        double v33 = pg_query__node__init(v32);
        *(void *)(*(void *)(v3 + 128) + 8 * v3errstart(20, 0) = v32;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 128) + 8 * v30), *(void *)(*(void *)(*(void *)(a2 + 56) + 16) + 8 * v30), v33);
        unint64_t v30 = v31++;
      }
      while (*(void *)(v3 + 120) > v30);
    }
  }
  if (*(void *)(a2 + 64))
  {
    uint64_t v34 = palloc(0x28uLL);
    double v35 = pg_query__node__init(v34);
    *(void *)(v3 + 136) = v34;
    uint64_t result = _outNode_0(v34, *(void *)(a2 + 64), v35);
  }
  *(_DWORD *)(v3 + 144) = *(unsigned __int8 *)(a2 + 72);
  *(_DWORD *)(v3 + 148) = *(unsigned __int8 *)(a2 + 73);
  if (*(unsigned char *)(a2 + 74))
  {
    uint64_t result = palloc(2uLL);
    *(void *)(v3 + 152) = result;
    *(unsigned char *)uint64_t result = *(unsigned char *)(a2 + 74);
    *(unsigned char *)(*(void *)(v3 + 152) + 1) = 0;
  }
  *(_DWORD *)(v3 + 16errstart(20, 0) = *(_DWORD *)(a2 + 76);
  int v36 = *(_DWORD *)(a2 + 80);
  if (v36)
  {
    if (v36 == 9)
    {
      int v37 = 3;
    }
    else if (v36 == 6)
    {
      int v37 = 2;
    }
    else
    {
      int v37 = -1;
    }
  }
  else
  {
    int v37 = 1;
  }
  *(_DWORD *)(v3 + 164) = v37;
  *(_DWORD *)(v3 + 168) = *(_DWORD *)(a2 + 84);
  return result;
}

uint64_t _outGroupingFunc_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 32) = v5;
    uint64_t result = palloc(8 * v5);
    *(void *)(v3 + 4errstart(20, 0) = result;
    if (*(void *)(v3 + 32))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 40) + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 40) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 32) > v6);
    }
  }
  uint64_t v10 = *(void *)(a2 + 16);
  if (v10)
  {
    uint64_t v11 = *(int *)(v10 + 4);
    *(void *)(v3 + 48) = v11;
    uint64_t result = palloc(8 * v11);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v12 = 0;
      int v13 = 1;
      do
      {
        uint64_t v14 = palloc(0x28uLL);
        double v15 = pg_query__node__init(v14);
        *(void *)(*(void *)(v3 + 56) + 8 * v12) = v14;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v12), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v12), v15);
        unint64_t v12 = v13++;
      }
      while (*(void *)(v3 + 48) > v12);
    }
  }
  uint64_t v16 = *(void *)(a2 + 24);
  if (v16)
  {
    uint64_t v17 = *(int *)(v16 + 4);
    *(void *)(v3 + 64) = v17;
    uint64_t result = palloc(8 * v17);
    *(void *)(v3 + 72) = result;
    if (*(void *)(v3 + 64))
    {
      unint64_t v18 = 0;
      int v19 = 1;
      do
      {
        uint64_t v20 = palloc(0x28uLL);
        double v21 = pg_query__node__init(v20);
        *(void *)(*(void *)(v3 + 72) + 8 * v18) = v20;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 72) + 8 * v18), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v18), v21);
        unint64_t v18 = v19++;
      }
      while (*(void *)(v3 + 64) > v18);
    }
  }
  *(_DWORD *)(v3 + 8errstart(20, 0) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(v3 + 84) = *(_DWORD *)(a2 + 36);
  return result;
}

uint64_t _outWindowFunc_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 48) = v5;
    uint64_t result = palloc(8 * v5);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 56) + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 48) > v6);
    }
  }
  if (*(void *)(a2 + 32))
  {
    uint64_t v10 = palloc(0x28uLL);
    double v11 = pg_query__node__init(v10);
    *(void *)(v3 + 64) = v10;
    uint64_t result = _outNode_0(v10, *(void *)(a2 + 32), v11);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(v3 + 76) = *(unsigned __int8 *)(a2 + 44);
  *(_DWORD *)(v3 + 8errstart(20, 0) = *(unsigned __int8 *)(a2 + 45);
  *(_DWORD *)(v3 + 84) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t _outSubscriptingRef_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (void *)result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 48) = v5;
    uint64_t result = palloc(8 * v5);
    v3[7] = result;
    if (v3[6])
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(v3[7] + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(v3[7] + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (v3[6] > v6);
    }
  }
  uint64_t v10 = *(void *)(a2 + 32);
  if (v10)
  {
    uint64_t v11 = *(int *)(v10 + 4);
    v3[8] = v11;
    uint64_t result = palloc(8 * v11);
    v3[9] = result;
    if (v3[8])
    {
      unint64_t v12 = 0;
      int v13 = 1;
      do
      {
        uint64_t v14 = palloc(0x28uLL);
        double v15 = pg_query__node__init(v14);
        *(void *)(v3[9] + 8 * v12) = v14;
        uint64_t result = _outNode_0(*(void *)(v3[9] + 8 * v12), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v12), v15);
        unint64_t v12 = v13++;
      }
      while (v3[8] > v12);
    }
  }
  if (*(void *)(a2 + 40))
  {
    uint64_t v16 = palloc(0x28uLL);
    double v17 = pg_query__node__init(v16);
    v3[10] = v16;
    uint64_t result = _outNode_0(v16, *(void *)(a2 + 40), v17);
  }
  if (*(void *)(a2 + 48))
  {
    uint64_t v18 = palloc(0x28uLL);
    double v19 = pg_query__node__init(v18);
    v3[11] = v18;
    uint64_t v20 = *(void *)(a2 + 48);
    return _outNode_0(v18, v20, v19);
  }
  return result;
}

uint64_t _outFuncExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(unsigned __int8 *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(unsigned __int8 *)(a2 + 13);
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  if (v4 < 3) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(result + 48) = v5;
  *(_DWORD *)(result + 52) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = *(int *)(v6 + 4);
    *(void *)(result + 64) = v7;
    uint64_t result = palloc(8 * v7);
    *(void *)(v3 + 72) = result;
    if (*(void *)(v3 + 64))
    {
      unint64_t v8 = 0;
      int v9 = 1;
      do
      {
        uint64_t v10 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v10);
        *(void *)(*(void *)(v3 + 72) + 8 * v8) = v10;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 72) + 8 * v8), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v8), node__init);
        unint64_t v8 = v9++;
      }
      while (*(void *)(v3 + 64) > v8);
    }
  }
  *(_DWORD *)(v3 + 8errstart(20, 0) = *(_DWORD *)(a2 + 40);
  return result;
}

const char *_outNamedArgExpr_0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(a1 + 32) = v4;
    _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  uint64_t result = *(const char **)(a2 + 16);
  if (result)
  {
    uint64_t result = (const char *)pstrdup(result);
    *(void *)(a1 + 4errstart(20, 0) = result;
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outOpExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(unsigned __int8 *)(a2 + 16);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(result + 52) = *(_DWORD *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 56) = v5;
    uint64_t result = palloc(8 * v5);
    *(void *)(v3 + 64) = result;
    if (*(void *)(v3 + 56))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 64) + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 64) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 56) > v6);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outScalarArrayOpExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(unsigned __int8 *)(a2 + 12);
  *(_DWORD *)(result + 44) = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 48) = v5;
    uint64_t result = palloc(8 * v5);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 56) + 8 * v6) = v8;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 48) > v6);
    }
  }
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outBoolExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 3) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(result + 32) = v5;
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = *(int *)(v6 + 4);
    *(void *)(result + 4errstart(20, 0) = v7;
    uint64_t result = palloc(8 * v7);
    *(void *)(v3 + 48) = result;
    if (*(void *)(v3 + 40))
    {
      unint64_t v8 = 0;
      int v9 = 1;
      do
      {
        uint64_t v10 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v10);
        *(void *)(*(void *)(v3 + 48) + 8 * v8) = v10;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 48) + 8 * v8), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v8), node__init);
        unint64_t v8 = v9++;
      }
      while (*(void *)(v3 + 40) > v8);
    }
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 16);
  return result;
}

uint64_t _outSubLink_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(result + 32) = v5;
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v6);
    *(void *)(v3 + 4errstart(20, 0) = v6;
    uint64_t result = _outNode_0(v6, *(void *)(a2 + 16), node__init);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    uint64_t v9 = *(int *)(v8 + 4);
    *(void *)(v3 + 48) = v9;
    uint64_t result = palloc(8 * v9);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v10 = 0;
      int v11 = 1;
      do
      {
        uint64_t v12 = palloc(0x28uLL);
        double v13 = pg_query__node__init(v12);
        *(void *)(*(void *)(v3 + 56) + 8 * v1errstart(20, 0) = v12;
        uint64_t result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v10), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v10), v13);
        unint64_t v10 = v11++;
      }
      while (*(void *)(v3 + 48) > v10);
    }
  }
  if (*(void *)(a2 + 32))
  {
    uint64_t v14 = palloc(0x28uLL);
    double v15 = pg_query__node__init(v14);
    *(void *)(v3 + 64) = v14;
    uint64_t result = _outNode_0(v14, *(void *)(a2 + 32), v15);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

double _outSubPlan_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(a1 + 32) = v5;
  if (*(void *)(a2 + 8))
  {
    uint64_t v6 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v6);
    *(void *)(a1 + 4errstart(20, 0) = v6;
    _outNode_0(v6, *(void *)(a2 + 8), node__init);
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (v8)
  {
    uint64_t v9 = *(int *)(v8 + 4);
    *(void *)(a1 + 48) = v9;
    *(void *)(a1 + 56) = palloc(8 * v9);
    if (*(void *)(a1 + 48))
    {
      unint64_t v10 = 0;
      int v11 = 1;
      do
      {
        uint64_t v12 = palloc(0x28uLL);
        double v13 = pg_query__node__init(v12);
        *(void *)(*(void *)(a1 + 56) + 8 * v1errstart(20, 0) = v12;
        _outNode_0(*(void *)(*(void *)(a1 + 56) + 8 * v10), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v10), v13);
        unint64_t v10 = v11++;
      }
      while (*(void *)(a1 + 48) > v10);
    }
  }
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 24);
  uint64_t v14 = *(const char **)(a2 + 32);
  if (v14) {
    *(void *)(a1 + 72) = pstrdup(v14);
  }
  *(_DWORD *)(a1 + 8errstart(20, 0) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 92) = *(unsigned __int8 *)(a2 + 52);
  *(_DWORD *)(a1 + 96) = *(unsigned __int8 *)(a2 + 53);
  *(_DWORD *)(a1 + 10errstart(20, 0) = *(unsigned __int8 *)(a2 + 54);
  uint64_t v15 = *(void *)(a2 + 56);
  if (v15)
  {
    uint64_t v16 = *(int *)(v15 + 4);
    *(void *)(a1 + 104) = v16;
    *(void *)(a1 + 112) = palloc(8 * v16);
    if (*(void *)(a1 + 104))
    {
      unint64_t v17 = 0;
      int v18 = 1;
      do
      {
        uint64_t v19 = palloc(0x28uLL);
        double v20 = pg_query__node__init(v19);
        *(void *)(*(void *)(a1 + 112) + 8 * v17) = v19;
        _outNode_0(*(void *)(*(void *)(a1 + 112) + 8 * v17), *(void *)(*(void *)(*(void *)(a2 + 56) + 16) + 8 * v17), v20);
        unint64_t v17 = v18++;
      }
      while (*(void *)(a1 + 104) > v17);
    }
  }
  uint64_t v21 = *(void *)(a2 + 64);
  if (v21)
  {
    uint64_t v22 = *(int *)(v21 + 4);
    *(void *)(a1 + 12errstart(20, 0) = v22;
    *(void *)(a1 + 128) = palloc(8 * v22);
    if (*(void *)(a1 + 120))
    {
      unint64_t v23 = 0;
      int v24 = 1;
      do
      {
        uint64_t v25 = palloc(0x28uLL);
        double v26 = pg_query__node__init(v25);
        *(void *)(*(void *)(a1 + 128) + 8 * v23) = v25;
        _outNode_0(*(void *)(*(void *)(a1 + 128) + 8 * v23), *(void *)(*(void *)(*(void *)(a2 + 64) + 16) + 8 * v23), v26);
        unint64_t v23 = v24++;
      }
      while (*(void *)(a1 + 120) > v23);
    }
  }
  uint64_t v27 = *(void *)(a2 + 72);
  if (v27)
  {
    uint64_t v28 = *(int *)(v27 + 4);
    *(void *)(a1 + 136) = v28;
    *(void *)(a1 + 144) = palloc(8 * v28);
    if (*(void *)(a1 + 136))
    {
      unint64_t v29 = 0;
      int v30 = 1;
      do
      {
        uint64_t v31 = palloc(0x28uLL);
        double v32 = pg_query__node__init(v31);
        *(void *)(*(void *)(a1 + 144) + 8 * v29) = v31;
        _outNode_0(*(void *)(*(void *)(a1 + 144) + 8 * v29), *(void *)(*(void *)(*(void *)(a2 + 72) + 16) + 8 * v29), v32);
        unint64_t v29 = v30++;
      }
      while (*(void *)(a1 + 136) > v29);
    }
  }
  *(void *)(a1 + 152) = *(void *)(a2 + 80);
  double result = *(double *)(a2 + 88);
  *(double *)(a1 + 16errstart(20, 0) = result;
  return result;
}

uint64_t _outAlternativeSubPlan_0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(int *)(v2 + 4);
    *(void *)(result + 32) = v5;
    double result = palloc(8 * v5);
    *(void *)(v4 + 4errstart(20, 0) = result;
    if (*(void *)(v4 + 32))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v4 + 40) + 8 * v6) = v8;
        double result = _outNode_0(*(void *)(*(void *)(v4 + 40) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v4 + 32) > v6);
    }
  }
  return result;
}

uint64_t _outFieldSelect_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = *(__int16 *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outFieldStore_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6)
  {
    uint64_t v7 = *(int *)(v6 + 4);
    *(void *)(v3 + 4errstart(20, 0) = v7;
    double result = palloc(8 * v7);
    *(void *)(v3 + 48) = result;
    if (*(void *)(v3 + 40))
    {
      unint64_t v8 = 0;
      int v9 = 1;
      do
      {
        uint64_t v10 = palloc(0x28uLL);
        double v11 = pg_query__node__init(v10);
        *(void *)(*(void *)(v3 + 48) + 8 * v8) = v10;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 48) + 8 * v8), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v8), v11);
        unint64_t v8 = v9++;
      }
      while (*(void *)(v3 + 40) > v8);
    }
  }
  uint64_t v12 = *(void *)(a2 + 24);
  if (v12)
  {
    uint64_t v13 = *(int *)(v12 + 4);
    *(void *)(v3 + 56) = v13;
    double result = palloc(8 * v13);
    *(void *)(v3 + 64) = result;
    if (*(void *)(v3 + 56))
    {
      unint64_t v14 = 0;
      int v15 = 1;
      do
      {
        uint64_t v16 = palloc(0x28uLL);
        double v17 = pg_query__node__init(v16);
        *(void *)(*(void *)(v3 + 64) + 8 * v14) = v16;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 64) + 8 * v14), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v14), v17);
        unint64_t v14 = v15++;
      }
      while (*(void *)(v3 + 56) > v14);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outRelabelType_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  unsigned int v6 = *(_DWORD *)(a2 + 28);
  if (v6 < 3) {
    int v7 = v6 + 1;
  }
  else {
    int v7 = -1;
  }
  *(_DWORD *)(v3 + 52) = v7;
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outCoerceViaIO_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  unsigned int v6 = *(_DWORD *)(a2 + 24);
  if (v6 < 3) {
    int v7 = v6 + 1;
  }
  else {
    int v7 = -1;
  }
  *(_DWORD *)(v3 + 48) = v7;
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outArrayCoerceExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = palloc(0x28uLL);
    double v7 = pg_query__node__init(v6);
    *(void *)(v3 + 4errstart(20, 0) = v6;
    double result = _outNode_0(v6, *(void *)(a2 + 16), v7);
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 52) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 32);
  unsigned int v8 = *(_DWORD *)(a2 + 36);
  if (v8 < 3) {
    int v9 = v8 + 1;
  }
  else {
    int v9 = -1;
  }
  *(_DWORD *)(v3 + 6errstart(20, 0) = v9;
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outConvertRowtypeExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = *(_DWORD *)(a2 + 16);
  unsigned int v6 = *(_DWORD *)(a2 + 20);
  if (v6 < 3) {
    int v7 = v6 + 1;
  }
  else {
    int v7 = -1;
  }
  *(_DWORD *)(v3 + 44) = v7;
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outCollateExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  return result;
}

uint64_t _outCaseExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  if (*(void *)(a2 + 16))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 4errstart(20, 0) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 16), node__init);
  }
  uint64_t v6 = *(void *)(a2 + 24);
  if (v6)
  {
    uint64_t v7 = *(int *)(v6 + 4);
    *(void *)(v3 + 48) = v7;
    double result = palloc(8 * v7);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v8 = 0;
      int v9 = 1;
      do
      {
        uint64_t v10 = palloc(0x28uLL);
        double v11 = pg_query__node__init(v10);
        *(void *)(*(void *)(v3 + 56) + 8 * v8) = v10;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v8), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v8), v11);
        unint64_t v8 = v9++;
      }
      while (*(void *)(v3 + 48) > v8);
    }
  }
  if (*(void *)(a2 + 32))
  {
    uint64_t v12 = palloc(0x28uLL);
    double v13 = pg_query__node__init(v12);
    *(void *)(v3 + 64) = v12;
    double result = _outNode_0(v12, *(void *)(a2 + 32), v13);
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 40);
  return result;
}

uint64_t _outCaseWhen_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = palloc(0x28uLL);
    double v7 = pg_query__node__init(v6);
    *(void *)(v3 + 4errstart(20, 0) = v6;
    double result = _outNode_0(v6, *(void *)(a2 + 16), v7);
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outArrayExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 48) = v5;
    double result = palloc(8 * v5);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 56) + 8 * v6) = v8;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 48) > v6);
    }
  }
  *(_DWORD *)(v3 + 64) = *(unsigned __int8 *)(a2 + 24);
  *(_DWORD *)(v3 + 68) = *(_DWORD *)(a2 + 28);
  return result;
}

uint64_t _outRowExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 32) = v5;
    double result = palloc(8 * v5);
    *(void *)(v3 + 4errstart(20, 0) = result;
    if (*(void *)(v3 + 32))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 40) + 8 * v6) = v8;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 40) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 32) > v6);
    }
  }
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 16);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  if (v10 < 3) {
    int v11 = v10 + 1;
  }
  else {
    int v11 = -1;
  }
  *(_DWORD *)(v3 + 52) = v11;
  uint64_t v12 = *(void *)(a2 + 24);
  if (v12)
  {
    uint64_t v13 = *(int *)(v12 + 4);
    *(void *)(v3 + 56) = v13;
    double result = palloc(8 * v13);
    *(void *)(v3 + 64) = result;
    if (*(void *)(v3 + 56))
    {
      unint64_t v14 = 0;
      int v15 = 1;
      do
      {
        uint64_t v16 = palloc(0x28uLL);
        double v17 = pg_query__node__init(v16);
        *(void *)(*(void *)(v3 + 64) + 8 * v14) = v16;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 64) + 8 * v14), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v14), v17);
        unint64_t v14 = v15++;
      }
      while (*(void *)(v3 + 56) > v14);
    }
  }
  *(_DWORD *)(v3 + 72) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t _outRowCompareExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (void *)result;
  int v4 = *(_DWORD *)(a2 + 4);
  if ((v4 - 1) >= 6) {
    int v4 = -1;
  }
  *(_DWORD *)(result + 32) = v4;
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5)
  {
    uint64_t v6 = *(int *)(v5 + 4);
    *(void *)(result + 4errstart(20, 0) = v6;
    double result = palloc(8 * v6);
    v3[6] = result;
    if (v3[5])
    {
      unint64_t v7 = 0;
      int v8 = 1;
      do
      {
        uint64_t v9 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v9);
        *(void *)(v3[6] + 8 * v7) = v9;
        double result = _outNode_0(*(void *)(v3[6] + 8 * v7), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v7), node__init);
        unint64_t v7 = v8++;
      }
      while (v3[5] > v7);
    }
  }
  uint64_t v11 = *(void *)(a2 + 16);
  if (v11)
  {
    uint64_t v12 = *(int *)(v11 + 4);
    v3[7] = v12;
    double result = palloc(8 * v12);
    v3[8] = result;
    if (v3[7])
    {
      unint64_t v13 = 0;
      int v14 = 1;
      do
      {
        uint64_t v15 = palloc(0x28uLL);
        double v16 = pg_query__node__init(v15);
        *(void *)(v3[8] + 8 * v13) = v15;
        double result = _outNode_0(*(void *)(v3[8] + 8 * v13), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v13), v16);
        unint64_t v13 = v14++;
      }
      while (v3[7] > v13);
    }
  }
  uint64_t v17 = *(void *)(a2 + 24);
  if (v17)
  {
    uint64_t v18 = *(int *)(v17 + 4);
    v3[9] = v18;
    double result = palloc(8 * v18);
    v3[10] = result;
    if (v3[9])
    {
      unint64_t v19 = 0;
      int v20 = 1;
      do
      {
        uint64_t v21 = palloc(0x28uLL);
        double v22 = pg_query__node__init(v21);
        *(void *)(v3[10] + 8 * v19) = v21;
        double result = _outNode_0(*(void *)(v3[10] + 8 * v19), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v19), v22);
        unint64_t v19 = v20++;
      }
      while (v3[9] > v19);
    }
  }
  uint64_t v23 = *(void *)(a2 + 32);
  if (v23)
  {
    uint64_t v24 = *(int *)(v23 + 4);
    v3[11] = v24;
    double result = palloc(8 * v24);
    v3[12] = result;
    if (v3[11])
    {
      unint64_t v25 = 0;
      int v26 = 1;
      do
      {
        uint64_t v27 = palloc(0x28uLL);
        double v28 = pg_query__node__init(v27);
        *(void *)(v3[12] + 8 * v25) = v27;
        double result = _outNode_0(*(void *)(v3[12] + 8 * v25), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v25), v28);
        unint64_t v25 = v26++;
      }
      while (v3[11] > v25);
    }
  }
  uint64_t v29 = *(void *)(a2 + 40);
  if (v29)
  {
    uint64_t v30 = *(int *)(v29 + 4);
    v3[13] = v30;
    double result = palloc(8 * v30);
    v3[14] = result;
    if (v3[13])
    {
      unint64_t v31 = 0;
      int v32 = 1;
      do
      {
        uint64_t v33 = palloc(0x28uLL);
        double v34 = pg_query__node__init(v33);
        *(void *)(v3[14] + 8 * v31) = v33;
        double result = _outNode_0(*(void *)(v3[14] + 8 * v31), *(void *)(*(void *)(*(void *)(a2 + 40) + 16) + 8 * v31), v34);
        unint64_t v31 = v32++;
      }
      while (v3[13] > v31);
    }
  }
  return result;
}

uint64_t _outCoalesceExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 16);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 4errstart(20, 0) = v5;
    double result = palloc(8 * v5);
    *(void *)(v3 + 48) = result;
    if (*(void *)(v3 + 40))
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(*(void *)(v3 + 48) + 8 * v6) = v8;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 48) + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (*(void *)(v3 + 40) > v6);
    }
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outMinMaxExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 4errstart(20, 0) = *(_DWORD *)(a2 + 12);
  int v4 = *(_DWORD *)(a2 + 16);
  if (v4 == 1) {
    int v5 = 2;
  }
  else {
    int v5 = -1;
  }
  if (v4) {
    int v6 = v5;
  }
  else {
    int v6 = 1;
  }
  *(_DWORD *)(result + 44) = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  if (v7)
  {
    uint64_t v8 = *(int *)(v7 + 4);
    *(void *)(result + 48) = v8;
    double result = palloc(8 * v8);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v9 = 0;
      int v10 = 1;
      do
      {
        uint64_t v11 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v11);
        *(void *)(*(void *)(v3 + 56) + 8 * v9) = v11;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v9), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v9), node__init);
        unint64_t v9 = v10++;
      }
      while (*(void *)(v3 + 48) > v9);
    }
  }
  *(_DWORD *)(v3 + 64) = *(_DWORD *)(a2 + 32);
  return result;
}

_DWORD *_outSQLValueFunction_0(_DWORD *result, _DWORD *a2)
{
  unsigned int v2 = a2[1];
  if (v2 < 0xF) {
    int v3 = v2 + 1;
  }
  else {
    int v3 = -1;
  }
  result[8] = v3;
  result[9] = a2[2];
  result[10] = a2[3];
  result[11] = a2[4];
  return result;
}

const char *_outXmlExpr_0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(a1 + 32) = v5;
  double result = *(const char **)(a2 + 8);
  if (result)
  {
    double result = (const char *)pstrdup(result);
    *(void *)(a1 + 4errstart(20, 0) = result;
  }
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7)
  {
    uint64_t v8 = *(int *)(v7 + 4);
    *(void *)(a1 + 48) = v8;
    double result = (const char *)palloc(8 * v8);
    *(void *)(a1 + 56) = result;
    if (*(void *)(a1 + 48))
    {
      unint64_t v9 = 0;
      int v10 = 1;
      do
      {
        uint64_t v11 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v11);
        *(void *)(*(void *)(a1 + 56) + 8 * v9) = v11;
        double result = (const char *)_outNode_0(*(void *)(*(void *)(a1 + 56) + 8 * v9), *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 8 * v9), node__init);
        unint64_t v9 = v10++;
      }
      while (*(void *)(a1 + 48) > v9);
    }
  }
  uint64_t v13 = *(void *)(a2 + 24);
  if (v13)
  {
    uint64_t v14 = *(int *)(v13 + 4);
    *(void *)(a1 + 64) = v14;
    double result = (const char *)palloc(8 * v14);
    *(void *)(a1 + 72) = result;
    if (*(void *)(a1 + 64))
    {
      unint64_t v15 = 0;
      int v16 = 1;
      do
      {
        uint64_t v17 = palloc(0x28uLL);
        double v18 = pg_query__node__init(v17);
        *(void *)(*(void *)(a1 + 72) + 8 * v15) = v17;
        double result = (const char *)_outNode_0(*(void *)(*(void *)(a1 + 72) + 8 * v15), *(void *)(*(void *)(*(void *)(a2 + 24) + 16) + 8 * v15), v18);
        unint64_t v15 = v16++;
      }
      while (*(void *)(a1 + 64) > v15);
    }
  }
  uint64_t v19 = *(void *)(a2 + 32);
  if (v19)
  {
    uint64_t v20 = *(int *)(v19 + 4);
    *(void *)(a1 + 8errstart(20, 0) = v20;
    double result = (const char *)palloc(8 * v20);
    *(void *)(a1 + 88) = result;
    if (*(void *)(a1 + 80))
    {
      unint64_t v21 = 0;
      int v22 = 1;
      do
      {
        uint64_t v23 = palloc(0x28uLL);
        double v24 = pg_query__node__init(v23);
        *(void *)(*(void *)(a1 + 88) + 8 * v21) = v23;
        double result = (const char *)_outNode_0(*(void *)(*(void *)(a1 + 88) + 8 * v21), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v21), v24);
        unint64_t v21 = v22++;
      }
      while (*(void *)(a1 + 80) > v21);
    }
  }
  int v25 = *(_DWORD *)(a2 + 40);
  if (v25 == 1) {
    int v26 = 2;
  }
  else {
    int v26 = -1;
  }
  if (v25) {
    int v27 = v26;
  }
  else {
    int v27 = 1;
  }
  *(_DWORD *)(a1 + 96) = v27;
  *(_DWORD *)(a1 + 10errstart(20, 0) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a2 + 52);
  return result;
}

uint64_t _outNullTest_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  int v6 = *(_DWORD *)(a2 + 16);
  if (v6 == 1) {
    int v7 = 2;
  }
  else {
    int v7 = -1;
  }
  if (v6) {
    int v8 = v7;
  }
  else {
    int v8 = 1;
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = v8;
  *(_DWORD *)(v3 + 44) = *(unsigned __int8 *)(a2 + 20);
  *(_DWORD *)(v3 + 48) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t _outBooleanTest_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(v3 + 32) = v4;
    double result = _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (v6 < 6) {
    int v7 = v6 + 1;
  }
  else {
    int v7 = -1;
  }
  *(_DWORD *)(v3 + 4errstart(20, 0) = v7;
  *(_DWORD *)(v3 + 44) = *(_DWORD *)(a2 + 20);
  return result;
}

const char *_outTargetEntry_0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8))
  {
    uint64_t v4 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v4);
    *(void *)(a1 + 32) = v4;
    _outNode_0(v4, *(void *)(a2 + 8), node__init);
  }
  *(_DWORD *)(a1 + 4errstart(20, 0) = *(__int16 *)(a2 + 16);
  double result = *(const char **)(a2 + 24);
  if (result)
  {
    double result = (const char *)pstrdup(result);
    *(void *)(a1 + 48) = result;
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 6errstart(20, 0) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 64) = *(__int16 *)(a2 + 40);
  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a2 + 42);
  return result;
}

uint64_t _outJoinExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 8) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(result + 24) = v5;
  *(_DWORD *)(result + 28) = *(unsigned __int8 *)(a2 + 8);
  if (*(void *)(a2 + 16))
  {
    uint64_t v6 = palloc(0x28uLL);
    double node__init = pg_query__node__init(v6);
    *(void *)(v3 + 32) = v6;
    double result = _outNode_0(v6, *(void *)(a2 + 16), node__init);
  }
  if (*(void *)(a2 + 24))
  {
    uint64_t v8 = palloc(0x28uLL);
    double v9 = pg_query__node__init(v8);
    *(void *)(v3 + 4errstart(20, 0) = v8;
    double result = _outNode_0(v8, *(void *)(a2 + 24), v9);
  }
  uint64_t v10 = *(void *)(a2 + 32);
  if (v10)
  {
    uint64_t v11 = *(int *)(v10 + 4);
    *(void *)(v3 + 48) = v11;
    double result = palloc(8 * v11);
    *(void *)(v3 + 56) = result;
    if (*(void *)(v3 + 48))
    {
      unint64_t v12 = 0;
      int v13 = 1;
      do
      {
        uint64_t v14 = palloc(0x28uLL);
        double v15 = pg_query__node__init(v14);
        *(void *)(*(void *)(v3 + 56) + 8 * v12) = v14;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 56) + 8 * v12), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v12), v15);
        unint64_t v12 = v13++;
      }
      while (*(void *)(v3 + 48) > v12);
    }
  }
  if (*(void *)(a2 + 40))
  {
    uint64_t v16 = palloc(0x28uLL);
    double v17 = pg_query__node__init(v16);
    *(void *)(v3 + 64) = v16;
    double result = _outNode_0(v16, *(void *)(a2 + 40), v17);
  }
  if (*(void *)(a2 + 48))
  {
    double v18 = (_OWORD *)palloc(0x30uLL);
    pg_query__alias__init(v18);
    double result = (uint64_t)_outAlias_0(v18, *(void *)(a2 + 48));
    *(void *)(v3 + 72) = v18;
  }
  *(_DWORD *)(v3 + 8errstart(20, 0) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t _outFromExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (void *)result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    uint64_t v5 = *(int *)(v4 + 4);
    *(void *)(result + 24) = v5;
    double result = palloc(8 * v5);
    v3[4] = result;
    if (v3[3])
    {
      unint64_t v6 = 0;
      int v7 = 1;
      do
      {
        uint64_t v8 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v8);
        *(void *)(v3[4] + 8 * v6) = v8;
        double result = _outNode_0(*(void *)(v3[4] + 8 * v6), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v6), node__init);
        unint64_t v6 = v7++;
      }
      while (v3[3] > v6);
    }
  }
  if (*(void *)(a2 + 16))
  {
    uint64_t v10 = palloc(0x28uLL);
    double v11 = pg_query__node__init(v10);
    v3[5] = v10;
    uint64_t v12 = *(void *)(a2 + 16);
    return _outNode_0(v10, v12, v11);
  }
  return result;
}

uint64_t _outOnConflictExpr_0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 < 3) {
    int v5 = v4 + 1;
  }
  else {
    int v5 = -1;
  }
  *(_DWORD *)(result + 24) = v5;
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = *(int *)(v6 + 4);
    *(void *)(result + 32) = v7;
    double result = palloc(8 * v7);
    *(void *)(v3 + 4errstart(20, 0) = result;
    if (*(void *)(v3 + 32))
    {
      unint64_t v8 = 0;
      int v9 = 1;
      do
      {
        uint64_t v10 = palloc(0x28uLL);
        double node__init = pg_query__node__init(v10);
        *(void *)(*(void *)(v3 + 40) + 8 * v8) = v10;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 40) + 8 * v8), *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 8 * v8), node__init);
        unint64_t v8 = v9++;
      }
      while (*(void *)(v3 + 32) > v8);
    }
  }
  if (*(void *)(a2 + 16))
  {
    uint64_t v12 = palloc(0x28uLL);
    double v13 = pg_query__node__init(v12);
    *(void *)(v3 + 48) = v12;
    double result = _outNode_0(v12, *(void *)(a2 + 16), v13);
  }
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 24);
  uint64_t v14 = *(void *)(a2 + 32);
  if (v14)
  {
    uint64_t v15 = *(int *)(v14 + 4);
    *(void *)(v3 + 64) = v15;
    double result = palloc(8 * v15);
    *(void *)(v3 + 72) = result;
    if (*(void *)(v3 + 64))
    {
      unint64_t v16 = 0;
      int v17 = 1;
      do
      {
        uint64_t v18 = palloc(0x28uLL);
        double v19 = pg_query__node__init(v18);
        *(void *)(*(void *)(v3 + 72) + 8 * v16) = v18;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 72) + 8 * v16), *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 8 * v16), v19);
        unint64_t v16 = v17++;
      }
      while (*(void *)(v3 + 64) > v16);
    }
  }
  if (*(void *)(a2 + 40))
  {
    uint64_t v20 = palloc(0x28uLL);
    double v21 = pg_query__node__init(v20);
    *(void *)(v3 + 8errstart(20, 0) = v20;
    double result = _outNode_0(v20, *(void *)(a2 + 40), v21);
  }
  *(_DWORD *)(v3 + 88) = *(_DWORD *)(a2 + 48);
  uint64_t v22 = *(void *)(a2 + 56);
  if (v22)
  {
    uint64_t v23 = *(int *)(v22 + 4);
    *(void *)(v3 + 96) = v23;
    double result = palloc(8 * v23);
    *(void *)(v3 + 104) = result;
    if (*(void *)(v3 + 96))
    {
      unint64_t v24 = 0;
      int v25 = 1;
      do
      {
        uint64_t v26 = palloc(0x28uLL);
        double v27 = pg_query__node__init(v26);
        *(void *)(*(void *)(v3 + 104) + 8 * v24) = v26;
        double result = _outNode_0(*(void *)(*(void *)(v3 + 104) + 8 * v24), *(void *)(*(void *)(*(void *)(a2 + 56) + 16) + 8 * v24), v27);
        unint64_t v24 = v25++;
      }
      while (*(void *)(v3 + 96) > v24);
    }
  }
  return result;
}