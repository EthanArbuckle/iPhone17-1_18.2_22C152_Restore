void PKPhysicsShape::createAsCircle(PKPhysicsShape *this, float a2, const CGPoint *a3)
{
  operator new();
}

id valueWithCGPoint(CGPoint a1)
{
  CGPoint v3 = a1;
  v1 = [MEMORY[0x263F08D40] valueWithBytes:&v3 objCType:"{CGPoint=dd}"];

  return v1;
}

void sub_213557EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t b2ChainShape::GetVertex(b2ChainShape *this, int a2)
{
  if (a2 < 0 || (uint64_t v2 = *((void *)this + 2), (int)((unint64_t)(*((void *)this + 3) - v2) >> 3) <= a2)) {
    b2ChainShape::GetVertex();
  }
  return v2 + 8 * a2;
}

void *QuadTree::visitLeaves(void **a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  QuadTreeNode::visitLeaves(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](v4);
}

void sub_213557FF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_2135585E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<b2Vec2>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<b2Vec2>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<PKPoint>::reserve(void **a1, unint64_t a2)
{
  v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void sub_213558B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }

  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

void sub_2135591B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213559D08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void addCircleBody(PKPhysicsBody *a1, float a2, const CGPoint *a3)
{
}

void sub_21355A070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void addEdge(PKPhysicsBody *a1, const CGPoint *a2, const CGPoint *a3)
{
  uint64_t v3 = a1;
  v3->_dynamicType = 1;
  v3->_bodyDef.type = 1;
  operator new();
}

void sub_21355A2BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t addPolygonFromPath(void *a1, uint64_t a2)
{
  id v5 = a1;
  unint64_t v6 = *(void *)(*(void *)a2 + 16) - *(void *)(*(void *)a2 + 8);
  v7 = (float *)malloc_type_malloc((uint64_t)(v6 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v6 >> 3) >= 1)
  {
    int v8 = 0;
    uint64_t v9 = (v6 >> 3);
    v10 = (float *)(*(void *)(*(void *)a2 + 8) + 4);
    do
    {
      float v11 = *(v10 - 1);
      float v12 = *v10;
      float v13 = PKGet_INV_PTM_RATIO();
      float v14 = PKGet_INV_PTM_RATIO();
      float v15 = v11 * v13;
      float v16 = v12 * v14;
      if (v8 < 1
        || (float)((float)((float)(v16 - v2) * (float)(v16 - v2)) + (float)((float)(v15 - v3) * (float)(v15 - v3))) > 1.4211e-14)
      {
        v17 = &v7[2 * v8];
        float *v17 = v15;
        v17[1] = v16;
        ++v8;
        float v2 = v16;
        float v3 = v11 * v13;
      }
      v10 += 2;
      --v9;
    }
    while (v9);
    if (v8 > 1)
    {
      float v18 = *v7;
      float v19 = v7[1];
      if ((float)((float)((float)(v7[2 * (v8 - 1) + 1] - v19) * (float)(v7[2 * (v8 - 1) + 1] - v19))
                 + (float)((float)(v7[2 * (v8 - 1)] - *v7) * (float)(v7[2 * (v8 - 1)] - *v7))) <= 1.4211e-14)
      {
        unint64_t v20 = v8;
        do
        {
          int v8 = v20 - 1;
          if (v20 < 3) {
            break;
          }
          float v21 = (float)((float)(v7[2 * (v20 - 2) + 1] - v19)
                      * (float)(v7[2 * (v20 - 2) + 1] - v19))
              + (float)((float)(v7[2 * (v20 - 2)] - v18) * (float)(v7[2 * (v20 - 2)] - v18));
          --v20;
        }
        while (v21 <= 1.4211e-14);
      }
      if (v8 > 2)
      {
        if ((float)((float)((float)(v7[2] - v18) * (float)(v7[5] - v7[3]))
                   - (float)((float)(v7[3] - v19) * (float)(v7[4] - v7[2]))) < 0.0)
        {
          uint64_t v23 = v8 >> 1;
          int v24 = v8 - 1;
          v25 = v7;
          do
          {
            uint64_t v26 = *(void *)v25;
            *(void *)v25 = *(void *)&v7[2 * v24];
            v25 += 2;
            *(void *)&v7[2 * v24--] = v26;
            --v23;
          }
          while (v23);
        }
        operator new();
      }
    }
  }
  free(v7);

  return 0;
}

void sub_21355A69C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void addEdgeChain(void *a1, void *a2)
{
  id v23 = a1;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  v7 = (std::__shared_weak_count *)*((void *)v23 + 22);
  *((void *)v23 + 21) = v6;
  *((void *)v23 + 22) = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  *((_DWORD *)v23 + 28) = 1;
  *((_DWORD *)v23 + 9) = 1;
  unint64_t v8 = *(void *)(*a2 + 16) - *(void *)(*a2 + 8);
  uint64_t v9 = (float *)malloc_type_malloc((uint64_t)(v8 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v8 >> 3) >= 1)
  {
    int v10 = 0;
    uint64_t v11 = (v8 >> 3);
    float v12 = (float *)(*(void *)(*a2 + 8) + 4);
    do
    {
      float v13 = *(v12 - 1);
      float v14 = *v12;
      float v15 = PKGet_INV_PTM_RATIO();
      float v16 = PKGet_INV_PTM_RATIO();
      float v17 = v13 * v15;
      float v18 = v14 * v16;
      if (v10 < 1
        || (float)((float)((float)(v18 - v2) * (float)(v18 - v2)) + (float)((float)(v17 - v3) * (float)(v17 - v3))) > 1.4211e-14)
      {
        float v19 = &v9[2 * v10];
        *float v19 = v17;
        v19[1] = v18;
        ++v10;
        float v2 = v18;
        float v3 = v13 * v15;
      }
      v12 += 2;
      --v11;
    }
    while (v11);
    if (v10 > 1)
    {
      float v20 = v9[1];
      if ((float)((float)((float)(v9[2 * (v10 - 1) + 1] - v20) * (float)(v9[2 * (v10 - 1) + 1] - v20))
                 + (float)((float)(v9[2 * (v10 - 1)] - *v9) * (float)(v9[2 * (v10 - 1)] - *v9))) <= 1.4211e-14)
      {
        unint64_t v21 = v10;
        do
        {
          if (v21 < 3) {
            break;
          }
          float v22 = (float)((float)(v9[2 * (v21 - 2) + 1] - v20)
                      * (float)(v9[2 * (v21 - 2) + 1] - v20))
              + (float)((float)(v9[2 * (v21 - 2)] - *v9) * (float)(v9[2 * (v21 - 2)] - *v9));
          --v21;
        }
        while (v22 <= 1.4211e-14);
      }
    }
  }
  operator new();
}

void sub_21355AA2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_21355ACCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355ADFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355B11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_21355B1D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355B26C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void addRectangle(PKPhysicsBody *a1, const CGSize *a2, const CGPoint *a3, float a4)
{
  *((double *)a1 + 32) = a4;
  operator new();
}

void sub_21355B518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355B57C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355B618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }

  _Unwind_Resume(a1);
}

void sub_21355B6BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }

  _Unwind_Resume(a1);
}

void sub_21355B760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }

  _Unwind_Resume(a1);
}

void addEdgeLoop(void *a1, uint64_t a2)
{
  uint64_t v5 = a1;
  v5[28] = 1;
  v5[9] = 1;
  unint64_t v6 = *(void *)(*(void *)a2 + 16) - *(void *)(*(void *)a2 + 8);
  v7 = (float *)malloc_type_malloc((uint64_t)(v6 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v6 >> 3) >= 1)
  {
    int v8 = 0;
    uint64_t v9 = (v6 >> 3);
    int v10 = (float *)(*(void *)(*(void *)a2 + 8) + 4);
    do
    {
      float v11 = *(v10 - 1);
      float v12 = *v10;
      float v13 = PKGet_INV_PTM_RATIO();
      float v14 = PKGet_INV_PTM_RATIO();
      float v15 = v11 * v13;
      float v16 = v12 * v14;
      if (v8 < 1
        || (float)((float)((float)(v16 - v2) * (float)(v16 - v2)) + (float)((float)(v15 - v3) * (float)(v15 - v3))) > 1.4211e-14)
      {
        float v17 = &v7[2 * v8];
        float *v17 = v15;
        v17[1] = v16;
        ++v8;
        float v2 = v16;
        float v3 = v11 * v13;
      }
      v10 += 2;
      --v9;
    }
    while (v9);
    if (v8 > 1)
    {
      float v18 = v7[1];
      if ((float)((float)((float)(v7[2 * (v8 - 1) + 1] - v18) * (float)(v7[2 * (v8 - 1) + 1] - v18))
                 + (float)((float)(v7[2 * (v8 - 1)] - *v7) * (float)(v7[2 * (v8 - 1)] - *v7))) <= 1.4211e-14)
      {
        unint64_t v19 = v8;
        do
        {
          if (v19 < 3) {
            break;
          }
          float v20 = (float)((float)(v7[2 * (v19 - 2) + 1] - v18)
                      * (float)(v7[2 * (v19 - 2) + 1] - v18))
              + (float)((float)(v7[2 * (v19 - 2)] - *v7) * (float)(v7[2 * (v19 - 2)] - *v7));
          --v19;
        }
        while (v20 <= 1.4211e-14);
      }
    }
  }
  operator new();
}

void sub_21355BACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_21355BD2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355BDF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355C1A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21355D154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355DDBC(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  _Unwind_Resume(a1);
}

void sub_21355DFC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355E088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355E27C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void __clang_call_terminate(void *a1)
{
}

void *std::vector<PKPoint>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<PKPoint>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_21355E468(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<PKPoint>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  }
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void std::vector<PKPoint>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_2641AF890, MEMORY[0x263F8C060]);
}

void sub_21355E560(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

void *std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void sub_21355E8B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void std::vector<b2Vec2>::__append(char **a1, unint64_t a2)
{
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (a2 <= (v5 - v6) >> 3)
  {
    a1[1] = &v6[8 * a2];
  }
  else
  {
    v7 = *a1;
    uint64_t v8 = v6 - *a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - v7;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      float v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v4, v12);
      v7 = *a1;
      unint64_t v6 = a1[1];
    }
    else
    {
      float v13 = 0;
    }
    float v14 = &v13[8 * v10];
    float v15 = &v13[8 * v12];
    float v16 = &v14[8 * a2];
    if (v6 != v7)
    {
      do
      {
        uint64_t v17 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v14 - 1) = v17;
        v14 -= 8;
      }
      while (v6 != v7);
      v7 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

uint64_t std::allocate_shared[abi:ne180100]<PKPath,std::allocator<PKPath>,PKPath&,void>@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x40uLL);
  uint64_t result = std::__shared_ptr_emplace<PKPath>::__shared_ptr_emplace[abi:ne180100]<PKPath&,std::allocator<PKPath>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_21355EAA8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<PKPath>::__shared_ptr_emplace[abi:ne180100]<PKPath&,std::allocator<PKPath>,0>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = &unk_26C3F4398;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 32) = 0;
  std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>((void *)(a1 + 32), *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3);
  *(void *)(a1 + 56) = 0;
  return a1;
}

void sub_21355EB2C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKPath>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4398;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKPath>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4398;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

void std::__shared_ptr_emplace<PKPath>::__on_zero_shared(uint64_t a1)
{
}

void *std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<PKPoint>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21355EC20(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void PKPath::~PKPath(PKPath *this)
{
  uint64_t v2 = (const CGPath *)*((void *)this + 4);
  if (v2) {
    CGPathRelease(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

void std::shared_ptr<PKPath>::shared_ptr[abi:ne180100]<PKPath,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_21355ECF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<PKPath>::reset[abi:ne180100]((PKPath **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

PKPath *std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(PKPath **)(a1 + 24);
  if (result)
  {
    PKPath::~PKPath(result);
    JUMPOUT(0x21668C8E0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

PKPath *std::unique_ptr<PKPath>::reset[abi:ne180100](PKPath **a1, PKPath *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    PKPath::~PKPath(result);
    JUMPOUT(0x21668C8E0);
  }
  return result;
}

char *std::vector<PKPoint>::__assign_with_size[abi:ne180100]<PKPoint*,PKPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<PKPoint>::__vallocate[abi:ne180100](v7, v11);
    float v13 = (char *)v7[1];
    unint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      float v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v12 = (void **)(result + 8);
  float v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  float v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    float v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  float *v12 = &v9[v17];
  return result;
}

void sub_21355F00C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 math::transpose@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v2 = *(_OWORD *)(a1 + 4);
  long long v3 = *(_OWORD *)(a1 + 8);
  long long v4 = *(_OWORD *)(a1 + 12);
  long long v5 = *(_OWORD *)(a1 + 40);
  result.n128_u32[1] = HIDWORD(*(void *)(a1 + 12));
  DWORD1(v2) = *(void *)(a1 + 20);
  DWORD1(v3) = HIDWORD(v4);
  DWORD1(v4) = *(_DWORD *)(a1 + 28);
  result.n128_u32[2] = *(_DWORD *)(a1 + 32);
  DWORD2(v2) = *(_DWORD *)(a1 + 36);
  DWORD2(v4) = HIDWORD(*(void *)(a1 + 40));
  result.n128_u32[3] = *(_DWORD *)(a1 + 48);
  HIDWORD(v2) = *(_DWORD *)(a1 + 52);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v2;
  *((void *)&v3 + 1) = v5;
  HIDWORD(v4) = *(_DWORD *)(a1 + 60);
  *(_OWORD *)(a2 + 32) = v3;
  *(_OWORD *)(a2 + 48) = v4;
  return result;
}

__n128 math::invert@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float v2 = *(float *)(a1 + 12);
  if (v2 != 0.0
    || (float v3 = *(float *)(a1 + 28), v3 != 0.0)
    || ((v4 = *(float *)(a1 + 44), v4 == 0.0) ? (BOOL v5 = *(float *)(a1 + 60) == 1.0) : (BOOL v5 = 0), !v5))
  {
LABEL_7:
    long long v6 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(_OWORD *)(a2 + 16) = v6;
    __n128 result = *(__n128 *)(a1 + 32);
    long long v8 = *(_OWORD *)(a1 + 48);
    *(__n128 *)(a2 + 32) = result;
    *(_OWORD *)(a2 + 48) = v8;
    return result;
  }
  float v10 = *(float *)(a1 + 36);
  float v9 = *(float *)(a1 + 40);
  float v12 = *(float *)(a1 + 20);
  float v11 = *(float *)(a1 + 24);
  float v13 = *(float *)(a1 + 32);
  float v14 = *(float *)(a1 + 16);
  *(float *)&unsigned int v15 = (float)(v12 * v9) - (float)(v11 * v10);
  float v16 = (float)(v11 * v13) - (float)(v14 * v9);
  *(float *)&unsigned int v17 = (float)(v14 * v10) - (float)(v12 * v13);
  float v19 = *(float *)(a1 + 4);
  float v18 = *(float *)(a1 + 8);
  float v20 = *(float *)a1;
  *(float *)&unsigned int v21 = (float)(v18 * v10) - (float)(v19 * v9);
  *(float *)&unsigned int v22 = (float)(*(float *)a1 * v9) - (float)(v18 * v13);
  *(float *)&unsigned int v23 = (float)(v19 * v13) - (float)(*(float *)a1 * v10);
  *(float *)&unsigned int v24 = (float)(v19 * v11) - (float)(v18 * v12);
  *(float *)&unsigned int v25 = (float)(v18 * v14) - (float)(*(float *)a1 * v11);
  float v26 = -(float)(v19 * v14);
  *(void *)&long long v27 = __PAIR64__(v21, v15);
  *(float *)&unsigned int v28 = v26 + (float)(*(float *)a1 * v12);
  *((void *)&v27 + 1) = v24;
  v29.n128_u64[0] = __PAIR64__(v22, LODWORD(v16));
  v29.n128_u64[1] = v25;
  *(void *)&long long v30 = __PAIR64__(v23, v17);
  long long vars0 = v27;
  __n128 v41 = v29;
  *((void *)&v30 + 1) = v28;
  long long v42 = v30;
  float v31 = (float)((float)(v14 * *(float *)&v21) + (float)(v20 * *(float *)&v15)) + (float)(v13 * *(float *)&v24);
  float v32 = fabsf(v31);
  uint64_t v33 = 0;
  if (v32 < 1.0)
  {
    float v34 = v32 * 8.5071e37;
    v35 = &vars0;
LABEL_10:
    uint64_t v36 = 0;
    while (1)
    {
      float v37 = *(float *)((char *)v35 + v36);
      if (v34 <= fabsf(v37)) {
        goto LABEL_7;
      }
      *(float *)((char *)v35 + v36) = v37 / v31;
      v36 += 4;
      if (v36 == 12)
      {
        ++v33;
        ++v35;
        if (v33 != 3) {
          goto LABEL_10;
        }
        goto LABEL_19;
      }
    }
  }
  v38 = &vars0;
  do
  {
    for (uint64_t i = 0; i != 12; i += 4)
      *(float *)((char *)v38 + i) = *(float *)((char *)v38 + i) / v31;
    ++v33;
    ++v38;
  }
  while (v33 != 3);
LABEL_19:
  *((float *)&vars0 + 3) = (float)((float)-(float)(v3 * *((float *)&vars0 + 1)) - (float)(v2 * *(float *)&vars0))
                         - (float)(v4 * *((float *)&vars0 + 2));
  v41.n128_f32[3] = (float)((float)-(float)(v3 * v29.n128_f32[1]) - (float)(v2 * v16)) - (float)(v4 * v29.n128_f32[2]);
  *((float *)&v42 + 3) = (float)((float)-(float)(v3 * *((float *)&v42 + 1)) - (float)(v2 * *(float *)&v42))
                       - (float)(v4 * *((float *)&v42 + 2));
  __n128 result = v41;
  *(_OWORD *)(a2 + 32) = v42;
  *(_OWORD *)(a2 + 48) = xmmword_21359A700;
  *(_OWORD *)a2 = vars0;
  *(__n128 *)(a2 + 16) = v41;
  return result;
}

void sub_21355F394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_21355F4B0(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_21355F62C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355F860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355F90C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355FA00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355FB58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355FC3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21355FF64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135600B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356043C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560660(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_2135606FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356089C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560AFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560BA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560C38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560D20(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_213560EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213560FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561078(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135612DC(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_2135613A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135616D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135618FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135619C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561BBC(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_213561C48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213561F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_213561FE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

#error "213562178: call analysis failed (funcsize=20)"

#error "2135621E8: call analysis failed (funcsize=27)"

#error "213562264: call analysis failed (funcsize=30)"

void sub_2135623CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562574(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  _Unwind_Resume(a1);
}

void sub_2135626A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135627A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562814(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135628E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PKPhysicsFieldUserInvokeBatchBlockWith(void *a1, uint64_t a2, uint64_t a3)
{
  long long v6 = a1;
  if (v6)
  {
    uint64_t v5 = v6[10];
    if (v5) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 16))(v5, a2, a3);
    }
  }
}

void sub_213562A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t PKPhysicsFieldUserInvokeBlockWith(void *a1, uint64_t a2, uint64_t a3)
{
  float v4 = a1;
  if (v4)
  {
    uint64_t v7 = v4[11];
    if (v7)
    {
      v5.n128_u64[0] = **(void **)a3;
      v5.n128_u32[2] = *(_DWORD *)(*(void *)a3 + 8);
      uint64_t v8 = *(void *)(a3 + 16);
      v6.n128_u64[0] = *(void *)v8;
      v6.n128_u32[2] = *(_DWORD *)(v8 + 8);
      __n128 v9 = ((__n128 (*)(__n128, __n128, float, float, double))*(void *)(v7 + 16))(v5, v6, **(float **)(a3 + 32), **(float **)(a3 + 48), *(double *)(a3 + 64));
      uint64_t v10 = *(void *)(a3 + 72);
      *(void *)uint64_t v10 = v9.n128_u64[0];
      *(_DWORD *)(v10 + 8) = v9.n128_u32[2];
    }
  }

  return MEMORY[0x270F9A758]();
}

void sub_213562AFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_213562BE0(_Unwind_Exception *a1)
{
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }

  _Unwind_Resume(a1);
}

void sub_213562C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562D0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213562F28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_213563010(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135630D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213563198(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _ZNSt3__115allocate_sharedB8ne180100I12PKCFieldDragNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI12PKCFieldDragNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563210(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI12PKCFieldDragNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F40F8;
  PKCFieldDrag::PKCFieldDrag((PKCFieldDrag *)(a1 + 8));
}

void sub_21356326C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldDrag>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F40F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldDrag>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F40F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldDrag>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I14PKCFieldVortexNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI14PKCFieldVortexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563354(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI14PKCFieldVortexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4210;
  PKCFieldVortex::PKCFieldVortex((PKCFieldVortex *)(a1 + 8));
}

void sub_2135633B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldVortex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4210;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldVortex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4210;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldVortex>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I21PKCFieldLinearGravityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x180uLL);
  _ZNSt3__120__shared_ptr_emplaceI21PKCFieldLinearGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563498(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI21PKCFieldLinearGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4328;
  PKCFieldLinearGravity::PKCFieldLinearGravity((PKCFieldLinearGravity *)(a1 + 8));
}

void sub_2135634F4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldLinearGravity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4328;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldLinearGravity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4328;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldLinearGravity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I21PKCFieldRadialGravityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI21PKCFieldRadialGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_2135635DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI21PKCFieldRadialGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4360;
  PKCFieldRadialGravity::PKCFieldRadialGravity((PKCFieldRadialGravity *)(a1 + 8));
}

void sub_213563638(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldRadialGravity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4360;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldRadialGravity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4360;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldRadialGravity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void std::allocate_shared[abi:ne180100]<PKCFieldUser,std::allocator<PKCFieldUser>,void *,void>(uint64_t a1, void **a2)
{
  float v3 = operator new(0x140uLL);
  std::__shared_ptr_emplace<PKCFieldUser>::__shared_ptr_emplace[abi:ne180100]<void *,std::allocator<PKCFieldUser>,0>(v3, a2);
}

void sub_213563730(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldUser>::__shared_ptr_emplace[abi:ne180100]<void *,std::allocator<PKCFieldUser>,0>(void *a1, void **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4130;
  PKCFieldUser::PKCFieldUser((PKCFieldUser *)(a1 + 8), *a2);
}

void sub_213563790(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldUser>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4130;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldUser>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4130;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldUser>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I16PKCFieldVelocityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x180uLL);
  _ZNSt3__120__shared_ptr_emplaceI16PKCFieldVelocityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563878(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI16PKCFieldVelocityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F42B8;
  PKCFieldVelocity::PKCFieldVelocity((PKCFieldVelocity *)(a1 + 8));
}

void sub_2135638D4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldVelocity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F42B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldVelocity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F42B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldVelocity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I13PKCFieldNoiseNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI13PKCFieldNoiseNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_2135639BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI13PKCFieldNoiseNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4168;
  PKCFieldNoise::PKCFieldNoise((PKCFieldNoise *)(a1 + 8));
}

void sub_213563A18(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldNoise>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4168;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldNoise>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4168;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldNoise>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I18PKCFieldTurbulenceNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI18PKCFieldTurbulenceNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563B00(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI18PKCFieldTurbulenceNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F42F0;
  PKCFieldTurbulence::PKCFieldTurbulence((PKCFieldTurbulence *)(a1 + 8));
}

void sub_213563B5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldTurbulence>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F42F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldTurbulence>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F42F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldTurbulence>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I14PKCFieldSpringNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI14PKCFieldSpringNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563C44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI14PKCFieldSpringNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F41D8;
  PKCFieldSpring::PKCFieldSpring((PKCFieldSpring *)(a1 + 8));
}

void sub_213563CA0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldSpring>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F41D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldSpring>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F41D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldSpring>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I16PKCFieldMagneticNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI16PKCFieldMagneticNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563D88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI16PKCFieldMagneticNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4280;
  PKCFieldMagnetic::PKCFieldMagnetic((PKCFieldMagnetic *)(a1 + 8));
}

void sub_213563DE4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldMagnetic>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldMagnetic>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4280;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldMagnetic>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

void _ZNSt3__115allocate_sharedB8ne180100I16PKCFieldElectricNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  v0 = operator new(0x140uLL);
  _ZNSt3__120__shared_ptr_emplaceI16PKCFieldElectricNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v0);
}

void sub_213563ECC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__120__shared_ptr_emplaceI16PKCFieldElectricNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C3F4248;
  PKCFieldElectric::PKCFieldElectric((PKCFieldElectric *)(a1 + 8));
}

void sub_213563F28(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldElectric>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4248;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldElectric>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4248;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

uint64_t std::__shared_ptr_emplace<PKCFieldElectric>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 64))();
}

PKDebugDrawPacket *PKDebugDrawPacket::clear(PKDebugDrawPacket *this)
{
  this->_linePoints.__end_ = this->_linePoints.__begin_;
  this->_colors.__end_ = this->_colors.__begin_;
  return this;
}

void sub_21356418C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PKQueryHandler::~PKQueryHandler((id *)va);

  _Unwind_Resume(a1);
}

void PKQueryHandler::~PKQueryHandler(id *this)
{
  *this = &unk_26C3F3808;

  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 3));
}

{
  uint64_t vars8;

  *this = &unk_26C3F3808;

  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 3));

  JUMPOUT(0x21668C8E0);
}

void sub_213564394(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PKQueryHandler::~PKQueryHandler((id *)va);

  _Unwind_Resume(a1);
}

void sub_2135644F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PKRayCastHandler::~PKRayCastHandler((PKRayCastHandler *)&a9);

  _Unwind_Resume(a1);
}

void PKRayCastHandler::issueCallbacks(PKRayCastHandler *this)
{
  float v2 = (char *)this + 16;
  __n128 v5 = PKRayCastItemSortInline;
  std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(*((void *)this + 3), (uint64_t)this + 16, *((void *)this + 4), (unsigned int (**)(id *, id *))&v5);
  for (uint64_t i = *((void *)this + 3); (char *)i != v2; uint64_t i = *(void *)(i + 8))
  {
    id v4 = *(id *)(i + 16);
    (*(void (**)(double, double, double, double))(*((void *)this + 1) + 16))(*(double *)(i + 24), *(double *)(i + 32), *(double *)(i + 40), *(double *)(i + 48));
  }
}

void sub_2135645C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PKRayCastHandler::~PKRayCastHandler(PKRayCastHandler *this)
{
  *(void *)this = &unk_26C3F3B18;
  std::__list_imp<PKRayCastItem>::clear((uint64_t *)this + 2);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C3F3B18;
  std::__list_imp<PKRayCastItem>::clear((uint64_t *)this + 2);

  JUMPOUT(0x21668C8E0);
}

void sub_21356470C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_213564864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

void sub_2135649A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

void sub_213564BC8(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10B0C40B6F99122);
  _Unwind_Resume(a1);
}

void sub_213564C48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213564CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_213565018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213565130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)PKPhysicsWorld;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_2135651D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356550C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356560C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_21356574C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_213565CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_213565E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_213565F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_213566104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21356639C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135664C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_213566570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_213566624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }

  _Unwind_Resume(a1);
}

void sub_21356683C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PKCAether::Evaluator::~Evaluator(PKCAether::Evaluator *this)
{
  float v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  float v3 = (void **)this;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_2135669A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void sub_213566AA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void sub_213566D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213567308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  _Unwind_Resume(a1);
}

void PKDebugDraw::DrawSolidPolygon(uint64_t a1, int *a2, int a3, int *a4)
{
  unint64_t v8 = 2 * a3;
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), v8);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(void *)(a1 + 16) + 24), v8);
  int v10 = *a4;
  int v9 = a4[1];
  uint64_t v11 = (a3 - 1);
  int v12 = a4[2];
  if (a3 >= 2)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(void *)&a2[2 * v13];
      uint64_t v15 = *(void *)(a1 + 16);
      float v16 = *(void **)(v15 + 8);
      unint64_t v17 = *(void *)(v15 + 16);
      if ((unint64_t)v16 >= v17)
      {
        float v19 = *(void **)v15;
        uint64_t v20 = ((uint64_t)v16 - *(void *)v15) >> 3;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61) {
          goto LABEL_133;
        }
        uint64_t v22 = v17 - (void)v19;
        if (v22 >> 2 > v21) {
          unint64_t v21 = v22 >> 2;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23)
        {
          unsigned int v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v15 + 16, v23);
          float v19 = *(void **)v15;
          float v16 = *(void **)(v15 + 8);
        }
        else
        {
          unsigned int v24 = 0;
        }
        unsigned int v25 = &v24[8 * v20];
        *(void *)unsigned int v25 = v14;
        float v18 = v25 + 8;
        if (v16 != v19)
        {
          do
          {
            uint64_t v26 = *--v16;
            *((void *)v25 - 1) = v26;
            v25 -= 8;
          }
          while (v16 != v19);
          float v19 = *(void **)v15;
        }
        *(void *)uint64_t v15 = v25;
        *(void *)(v15 + 8) = v18;
        *(void *)(v15 + 16) = &v24[8 * v23];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *float v16 = v14;
        float v18 = v16 + 1;
      }
      *(void *)(v15 + 8) = v18;
      ++v13;
      uint64_t v27 = *(void *)&a2[2 * v13];
      uint64_t v28 = *(void *)(a1 + 16);
      __n128 v29 = *(void **)(v28 + 8);
      unint64_t v30 = *(void *)(v28 + 16);
      if ((unint64_t)v29 >= v30)
      {
        float v32 = *(void **)v28;
        uint64_t v33 = ((uint64_t)v29 - *(void *)v28) >> 3;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61) {
          goto LABEL_133;
        }
        uint64_t v35 = v30 - (void)v32;
        if (v35 >> 2 > v34) {
          unint64_t v34 = v35 >> 2;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          float v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v28 + 16, v36);
          float v32 = *(void **)v28;
          __n128 v29 = *(void **)(v28 + 8);
        }
        else
        {
          float v37 = 0;
        }
        v38 = &v37[8 * v33];
        *(void *)v38 = v27;
        float v31 = v38 + 8;
        if (v29 != v32)
        {
          do
          {
            uint64_t v39 = *--v29;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          while (v29 != v32);
          float v32 = *(void **)v28;
        }
        *(void *)uint64_t v28 = v38;
        *(void *)(v28 + 8) = v31;
        *(void *)(v28 + 16) = &v37[8 * v36];
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        *__n128 v29 = v27;
        float v31 = v29 + 1;
      }
      *(void *)(v28 + 8) = v31;
      v40 = *(void **)(a1 + 16);
      __n128 v41 = (char *)v40[4];
      unint64_t v42 = v40[5];
      if ((unint64_t)v41 >= v42)
      {
        v44 = (char *)v40[3];
        uint64_t v45 = (v41 - v44) >> 4;
        unint64_t v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 60) {
          goto LABEL_134;
        }
        uint64_t v47 = v42 - (void)v44;
        if (v47 >> 3 > v46) {
          unint64_t v46 = v47 >> 3;
        }
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v48 = v46;
        }
        if (v48)
        {
          v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v40 + 5), v48);
          v44 = (char *)v40[3];
          __n128 v41 = (char *)v40[4];
        }
        else
        {
          v49 = 0;
        }
        v50 = &v49[16 * v45];
        *(_DWORD *)v50 = v10;
        *((_DWORD *)v50 + 1) = v9;
        *((_DWORD *)v50 + 2) = v12;
        *((_DWORD *)v50 + 3) = 1065353216;
        v51 = v50;
        if (v41 != v44)
        {
          do
          {
            *((_OWORD *)v51 - 1) = *((_OWORD *)v41 - 1);
            v51 -= 16;
            v41 -= 16;
          }
          while (v41 != v44);
          v44 = (char *)v40[3];
        }
        v43 = v50 + 16;
        v40[3] = v51;
        v40[4] = v50 + 16;
        v40[5] = &v49[16 * v48];
        if (v44) {
          operator delete(v44);
        }
      }
      else
      {
        *(_DWORD *)__n128 v41 = v10;
        *((_DWORD *)v41 + 1) = v9;
        *((_DWORD *)v41 + 2) = v12;
        v43 = v41 + 16;
        *((_DWORD *)v41 + 3) = 1065353216;
      }
      v40[4] = v43;
      v52 = *(void **)(a1 + 16);
      v53 = (char *)v52[4];
      unint64_t v54 = v52[5];
      if ((unint64_t)v53 >= v54)
      {
        v56 = (char *)v52[3];
        uint64_t v57 = (v53 - v56) >> 4;
        unint64_t v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 60) {
LABEL_134:
        }
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        uint64_t v59 = v54 - (void)v56;
        if (v59 >> 3 > v58) {
          unint64_t v58 = v59 >> 3;
        }
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v60 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v60 = v58;
        }
        if (v60)
        {
          v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v52 + 5), v60);
          v56 = (char *)v52[3];
          v53 = (char *)v52[4];
        }
        else
        {
          v61 = 0;
        }
        v62 = &v61[16 * v57];
        *(_DWORD *)v62 = v10;
        *((_DWORD *)v62 + 1) = v9;
        *((_DWORD *)v62 + 2) = v12;
        *((_DWORD *)v62 + 3) = 1065353216;
        v63 = v62;
        if (v53 != v56)
        {
          do
          {
            *((_OWORD *)v63 - 1) = *((_OWORD *)v53 - 1);
            v63 -= 16;
            v53 -= 16;
          }
          while (v53 != v56);
          v56 = (char *)v52[3];
        }
        v55 = v62 + 16;
        v52[3] = v63;
        v52[4] = v62 + 16;
        v52[5] = &v61[16 * v60];
        if (v56) {
          operator delete(v56);
        }
      }
      else
      {
        *(_DWORD *)v53 = v10;
        *((_DWORD *)v53 + 1) = v9;
        *((_DWORD *)v53 + 2) = v12;
        v55 = v53 + 16;
        *((_DWORD *)v53 + 3) = 1065353216;
      }
      v52[4] = v55;
    }
    while (v13 != v11);
  }
  uint64_t v64 = *(void *)&a2[2 * (int)v11];
  uint64_t v65 = *(void *)(a1 + 16);
  v66 = *(void **)(v65 + 8);
  unint64_t v67 = *(void *)(v65 + 16);
  if ((unint64_t)v66 >= v67)
  {
    v69 = *(void **)v65;
    uint64_t v70 = ((uint64_t)v66 - *(void *)v65) >> 3;
    unint64_t v71 = v70 + 1;
    if ((unint64_t)(v70 + 1) >> 61) {
LABEL_133:
    }
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    uint64_t v72 = v67 - (void)v69;
    if (v72 >> 2 > v71) {
      unint64_t v71 = v72 >> 2;
    }
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v73 = v71;
    }
    if (v73)
    {
      v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v65 + 16, v73);
      v69 = *(void **)v65;
      v66 = *(void **)(v65 + 8);
    }
    else
    {
      v74 = 0;
    }
    v75 = &v74[8 * v70];
    v76 = &v74[8 * v73];
    *(void *)v75 = v64;
    v68 = v75 + 8;
    if (v66 != v69)
    {
      do
      {
        uint64_t v77 = *--v66;
        *((void *)v75 - 1) = v77;
        v75 -= 8;
      }
      while (v66 != v69);
      v69 = *(void **)v65;
    }
    *(void *)uint64_t v65 = v75;
    *(void *)(v65 + 8) = v68;
    *(void *)(v65 + 16) = v76;
    if (v69) {
      operator delete(v69);
    }
  }
  else
  {
    void *v66 = v64;
    v68 = v66 + 1;
  }
  *(void *)(v65 + 8) = v68;
  int v79 = *a2;
  int v78 = a2[1];
  uint64_t v80 = *(void *)(a1 + 16);
  v81 = *(_DWORD **)(v80 + 8);
  unint64_t v82 = *(void *)(v80 + 16);
  if ((unint64_t)v81 >= v82)
  {
    v84 = *(_DWORD **)v80;
    uint64_t v85 = ((uint64_t)v81 - *(void *)v80) >> 3;
    unint64_t v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v87 = v82 - (void)v84;
    if (v87 >> 2 > v86) {
      unint64_t v86 = v87 >> 2;
    }
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v88 = v86;
    }
    if (v88)
    {
      v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v80 + 16, v88);
      v84 = *(_DWORD **)v80;
      v81 = *(_DWORD **)(v80 + 8);
    }
    else
    {
      v89 = 0;
    }
    v90 = &v89[8 * v85];
    v91 = &v89[8 * v88];
    *(_DWORD *)v90 = v79;
    *((_DWORD *)v90 + 1) = v78;
    v83 = v90 + 8;
    if (v81 != v84)
    {
      do
      {
        uint64_t v92 = *((void *)v81 - 1);
        v81 -= 2;
        *((void *)v90 - 1) = v92;
        v90 -= 8;
      }
      while (v81 != v84);
      v84 = *(_DWORD **)v80;
    }
    *(void *)uint64_t v80 = v90;
    *(void *)(v80 + 8) = v83;
    *(void *)(v80 + 16) = v91;
    if (v84) {
      operator delete(v84);
    }
  }
  else
  {
    _DWORD *v81 = v79;
    v81[1] = v78;
    v83 = v81 + 2;
  }
  *(void *)(v80 + 8) = v83;
  v93 = *(void **)(a1 + 16);
  v94 = (char *)v93[4];
  unint64_t v95 = v93[5];
  if ((unint64_t)v94 >= v95)
  {
    v97 = (char *)v93[3];
    uint64_t v98 = (v94 - v97) >> 4;
    unint64_t v99 = v98 + 1;
    if ((unint64_t)(v98 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v100 = v95 - (void)v97;
    if (v100 >> 3 > v99) {
      unint64_t v99 = v100 >> 3;
    }
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v101 = v99;
    }
    if (v101)
    {
      v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v93 + 5), v101);
      v97 = (char *)v93[3];
      v94 = (char *)v93[4];
    }
    else
    {
      v102 = 0;
    }
    v103 = &v102[16 * v98];
    v104 = &v102[16 * v101];
    *(_DWORD *)v103 = v10;
    *((_DWORD *)v103 + 1) = v9;
    *((_DWORD *)v103 + 2) = v12;
    *((_DWORD *)v103 + 3) = 1065353216;
    v96 = v103 + 16;
    if (v94 != v97)
    {
      do
      {
        *((_OWORD *)v103 - 1) = *((_OWORD *)v94 - 1);
        v103 -= 16;
        v94 -= 16;
      }
      while (v94 != v97);
      v97 = (char *)v93[3];
    }
    v93[3] = v103;
    v93[4] = v96;
    v93[5] = v104;
    if (v97) {
      operator delete(v97);
    }
  }
  else
  {
    *(_DWORD *)v94 = v10;
    *((_DWORD *)v94 + 1) = v9;
    *((_DWORD *)v94 + 2) = v12;
    *((_DWORD *)v94 + 3) = 1065353216;
    v96 = v94 + 16;
  }
  v93[4] = v96;
  v105 = *(void **)(a1 + 16);
  v106 = (char *)v105[4];
  unint64_t v107 = v105[5];
  if ((unint64_t)v106 >= v107)
  {
    v109 = (char *)v105[3];
    uint64_t v110 = (v106 - v109) >> 4;
    unint64_t v111 = v110 + 1;
    if ((unint64_t)(v110 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v112 = v107 - (void)v109;
    if (v112 >> 3 > v111) {
      unint64_t v111 = v112 >> 3;
    }
    if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v113 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v113 = v111;
    }
    if (v113)
    {
      v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v105 + 5), v113);
      v109 = (char *)v105[3];
      v106 = (char *)v105[4];
    }
    else
    {
      v114 = 0;
    }
    v115 = &v114[16 * v110];
    v116 = &v114[16 * v113];
    *(_DWORD *)v115 = v10;
    *((_DWORD *)v115 + 1) = v9;
    *((_DWORD *)v115 + 2) = v12;
    *((_DWORD *)v115 + 3) = 1065353216;
    v108 = v115 + 16;
    if (v106 != v109)
    {
      do
      {
        *((_OWORD *)v115 - 1) = *((_OWORD *)v106 - 1);
        v115 -= 16;
        v106 -= 16;
      }
      while (v106 != v109);
      v109 = (char *)v105[3];
    }
    v105[3] = v115;
    v105[4] = v108;
    v105[5] = v116;
    if (v109) {
      operator delete(v109);
    }
  }
  else
  {
    *(_DWORD *)v106 = v10;
    *((_DWORD *)v106 + 1) = v9;
    *((_DWORD *)v106 + 2) = v12;
    *((_DWORD *)v106 + 3) = 1065353216;
    v108 = v106 + 16;
  }
  v105[4] = v108;
}

void sub_213567C58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213567D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL PKQueryHandler::ReportFixture(PKQueryHandler *this, id *a2)
{
  unsigned __int8 v9 = 0;
  if (*((unsigned char *)this + 16)
    && !(*(unsigned int (**)(id, uint64_t, char *))(*(void *)a2[4] + 32))(a2[4], (uint64_t)a2[3] + 32, (char *)this + 8))
  {
    int v6 = 0;
  }
  else
  {
    id v4 = a2[9];
    if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v5 = v4;
      id v8 = v5;
      if (!std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>((void *)this + 3, &v8))
      {
        id v8 = v5;
        std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__emplace_unique_key_args<void *,void *>((uint64_t)this + 24, &v8, &v8);
        (*(void (**)(void))(*((void *)this + 8) + 16))();
      }

      int v6 = v9;
    }
    else
    {
      int v6 = 0;
    }
  }
  return v6 == 0;
}

void sub_213567F08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  id v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__emplace_unique_key_args<void *,void *>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  *uint64_t i = 0;
  i[1] = v8;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_213568258(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            void *v7 = *v11;
            void *v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint8x8_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table(uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

float PKRayCastHandler::ReportFixture(PKRayCastHandler *this, id *a2, const b2Vec2 *a3, const b2Vec2 *a4, float a5)
{
  id v8 = a2[9];
  if (v8)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v9 = v8;
      float x = a3->x;
      float v11 = PKGet_PTM_RATIO();
      float y = a3->y;
      float v13 = PKGet_PTM_RATIO();
      float v14 = a4->x;
      float v15 = PKGet_PTM_RATIO();
      float v16 = a4->y;
      float v17 = PKGet_PTM_RATIO();
      float v18 = x * v11;
      double v19 = (float)(x * v11);
      float v20 = y * v13;
      double v21 = (float)(y * v13);
      double v22 = (float)(v16 * v17);
      double v23 = (float)((float)((float)(v20 - *((float *)this + 11)) * (float)(v20 - *((float *)this + 11)))
                  + (float)((float)(v18 - *((float *)this + 10)) * (float)(v18 - *((float *)this + 10))));
      id v24 = v9;
      v26[0] = v24;
      v26[1] = *(id *)&v19;
      v26[2] = *(id *)&v21;
      *(double *)&v26[3] = (float)(v14 * v15);
      v26[4] = *(id *)&v22;
      v26[5] = *(id *)&v23;
      std::list<PKRayCastItem>::push_back((uint64_t *)this + 2, (uint64_t)v26);
    }
  }

  return 1.0;
}

void sub_2135686A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

__n128 std::list<PKRayCastItem>::push_back(uint64_t *a1, uint64_t a2)
{
  int8x8_t v4 = (char *)operator new(0x40uLL);
  id v5 = *(id *)a2;
  *((void *)v4 + 1) = a1;
  *((void *)v4 + 2) = v5;
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v4 + 40) = result;
  *((void *)v4 + 7) = *(void *)(a2 + 40);
  uint64_t v7 = *a1;
  *(void *)int8x8_t v4 = *a1;
  *(void *)(v7 + 8) = v4;
  *a1 = (uint64_t)v4;
  ++a1[2];
  return result;
}

BOOL PKRayCastItemSortInline(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(double *)(a1 + 40) <= *(double *)(a2 + 40);

  return v3;
}

uint64_t std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int (**a4)(id *, id *))
{
  uint64_t v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      id v8 = *a4;
      id v9 = *(uint64_t **)a2;
      id v10 = *(id *)(*(void *)a2 + 16);
      long long v11 = *(_OWORD *)(v9 + 3);
      long long v95 = *(_OWORD *)(v9 + 5);
      uint64_t v12 = v9[7];
      id v93 = v10;
      uint64_t v96 = v12;
      long long v94 = v11;
      id v13 = *(id *)(v4 + 16);
      long long v14 = *(_OWORD *)(v4 + 24);
      long long v91 = *(_OWORD *)(v4 + 40);
      uint64_t v15 = *(void *)(v4 + 56);
      id v89 = v13;
      uint64_t v92 = v15;
      long long v90 = v14;
      if (v8(&v93, &v89))
      {
        uint64_t v16 = *v9;
        *(void *)(v16 + 8) = v9[1];
        *(void *)v9[1] = v16;
        uint64_t v17 = *(void *)v4;
        *(void *)(v17 + 8) = v9;
        uint64_t *v9 = v17;
        *(void *)uint64_t v4 = v9;
        v9[1] = v4;
        return (uint64_t)v9;
      }
    }
    else
    {
      unint64_t v19 = a3 >> 1;
      unint64_t v20 = (a3 >> 1) + 1;
      uint64_t v21 = a1;
      do
      {
        uint64_t v21 = *(void *)(v21 + 8);
        --v20;
      }
      while (v20 > 1);
      uint64_t v22 = std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(a1, v21, a3 >> 1, a4);
      uint64_t v4 = std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(v21, a2, a3 - v19, a4);
      double v23 = *a4;
      id v24 = *(id *)(v4 + 16);
      long long v25 = *(_OWORD *)(v4 + 24);
      long long v87 = *(_OWORD *)(v4 + 40);
      uint64_t v26 = *(void *)(v4 + 56);
      id v85 = v24;
      uint64_t v88 = v26;
      long long v86 = v25;
      id v27 = *(id *)(v22 + 16);
      long long v28 = *(_OWORD *)(v22 + 24);
      long long v83 = *(_OWORD *)(v22 + 40);
      uint64_t v29 = *(void *)(v22 + 56);
      id v81 = v27;
      uint64_t v84 = v29;
      long long v82 = v28;
      if (v23(&v85, &v81))
      {
        uint64_t v30 = *(void *)(v4 + 8);
        if (v30 == a2)
        {
LABEL_12:
          uint64_t v30 = a2;
        }
        else
        {
          while (1)
          {
            float v31 = *a4;
            id v77 = *(id *)(v30 + 16);
            long long v32 = *(_OWORD *)(v30 + 24);
            long long v33 = *(_OWORD *)(v30 + 40);
            uint64_t v80 = *(void *)(v30 + 56);
            long long v78 = v32;
            long long v79 = v33;
            id v73 = *(id *)(v22 + 16);
            long long v34 = *(_OWORD *)(v22 + 24);
            long long v35 = *(_OWORD *)(v22 + 40);
            uint64_t v76 = *(void *)(v22 + 56);
            long long v74 = v34;
            long long v75 = v35;
            if (!v31(&v77, &v73)) {
              break;
            }
            uint64_t v30 = *(void *)(v30 + 8);
            if (v30 == a2) {
              goto LABEL_12;
            }
          }
        }
        uint64_t v36 = *(void *)v30;
        uint64_t v37 = *(void *)v4;
        *(void *)(v37 + 8) = *(void *)(*(void *)v30 + 8);
        **(void **)(v36 + 8) = v37;
        uint64_t v38 = *(void *)v22;
        uint64_t v39 = *(uint64_t **)(v22 + 8);
        *(void *)(v38 + 8) = v4;
        *(void *)uint64_t v4 = v38;
        *(void *)uint64_t v22 = v36;
        *(void *)(v36 + 8) = v22;
      }
      else
      {
        uint64_t v39 = *(uint64_t **)(v22 + 8);
        uint64_t v30 = v4;
        uint64_t v4 = v22;
      }
      if (v39 != (uint64_t *)v30 && v30 != a2)
      {
        uint64_t v40 = v30;
        do
        {
          uint64_t v56 = v40;
          __n128 v41 = *a4;
          id v69 = *(id *)(v30 + 16);
          long long v42 = *(_OWORD *)(v30 + 24);
          long long v43 = *(_OWORD *)(v30 + 40);
          uint64_t v72 = *(void *)(v30 + 56);
          long long v70 = v42;
          long long v71 = v43;
          id v65 = (id)v39[2];
          long long v44 = *(_OWORD *)(v39 + 3);
          long long v45 = *(_OWORD *)(v39 + 5);
          uint64_t v68 = v39[7];
          long long v66 = v44;
          long long v67 = v45;
          if (v41(&v69, &v65))
          {
            uint64_t v46 = *(void *)(v30 + 8);
            if (v46 == a2)
            {
              uint64_t v46 = a2;
            }
            else
            {
              while (1)
              {
                uint64_t v47 = *a4;
                id v61 = *(id *)(v46 + 16);
                long long v48 = *(_OWORD *)(v46 + 24);
                long long v49 = *(_OWORD *)(v46 + 40);
                uint64_t v64 = *(void *)(v46 + 56);
                long long v62 = v48;
                long long v63 = v49;
                id v57 = (id)v39[2];
                long long v50 = *(_OWORD *)(v39 + 3);
                long long v51 = *(_OWORD *)(v39 + 5);
                uint64_t v60 = v39[7];
                long long v58 = v50;
                long long v59 = v51;
                if (!v47(&v61, &v57)) {
                  break;
                }
                uint64_t v46 = *(void *)(v46 + 8);
                if (v46 == a2)
                {
                  uint64_t v46 = a2;
                  break;
                }
              }
            }
            uint64_t v52 = *(void *)v46;
            uint64_t v53 = *(void *)v30;
            *(void *)(v53 + 8) = *(void *)(*(void *)v46 + 8);
            **(void **)(v52 + 8) = v53;
            uint64_t v40 = v56;
            if (v56 == v30) {
              uint64_t v40 = v46;
            }
            uint64_t v55 = *v39;
            unint64_t v54 = (uint64_t *)v39[1];
            *(void *)(v55 + 8) = v30;
            *(void *)uint64_t v30 = v55;
            *uint64_t v39 = v52;
            *(void *)(v52 + 8) = v39;
            uint64_t v39 = v54;
            uint64_t v30 = v46;
          }
          else
          {
            uint64_t v39 = (uint64_t *)v39[1];
            uint64_t v40 = v56;
          }
        }
        while (v39 != (uint64_t *)v40 && v30 != a2);
      }
    }
  }
  return v4;
}

void std::__list_imp<PKRayCastItem>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    BOOL v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        id v5 = (uint64_t *)v3[1];

        operator delete(v3);
        BOOL v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)v2);
    BOOL v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<PKCField>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

void PKContactListener::~PKContactListener(PKContactListener *this)
{
  this->_vptr$b2ContactListener = (void **)&unk_26C3F3BC0;
  p_contactDelegate = &this->_contactDelegate;
  objc_storeWeak((id *)&this->_contactDelegate, 0);
  contacts = this->_contacts;
  this->_contacts = 0;

  objc_destroyWeak((id *)p_contactDelegate);
}

{
  uint64_t vars8;

  PKContactListener::~PKContactListener(this);

  JUMPOUT(0x21668C8E0);
}

void PKContactListener::BeginContact(PKContactListener *this, b2Contact *a2)
{
}

void PKContactListener::EndContact(PKContactListener *this, b2Contact *a2)
{
}

uint64_t PKContactListener::flushContacts(PKContactListener *this)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v1 = [(NSMutableDictionary *)this->_contacts allValues];
  uint64_t v2 = [v1 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v16;
    p_contactDelegate = &this->_contactDelegate;
    do
    {
      for (uint64_t i = 0; i != v2; ++i)
      {
        if (*(void *)v16 != v3) {
          objc_enumerationMutation(v1);
        }
        uint64_t v6 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        if ([v6 didBegin])
        {
          id WeakRetained = objc_loadWeakRetained((id *)p_contactDelegate);
          char v8 = objc_opt_respondsToSelector();

          if (v8)
          {
            id v9 = objc_loadWeakRetained((id *)p_contactDelegate);
            [v9 didBeginContact:v6];
          }
        }
        if ([v6 didEnd])
        {
          id v10 = objc_loadWeakRetained((id *)p_contactDelegate);
          char v11 = objc_opt_respondsToSelector();

          if (v11)
          {
            id v12 = objc_loadWeakRetained((id *)p_contactDelegate);
            [v12 didEndContact:v6];
          }
        }
      }
      uint64_t v2 = [v1 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v2);
  }

  return [(NSMutableDictionary *)this->_contacts removeAllObjects];
}

void sub_213568ED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PKContactListener::reportContact(uint64_t a1, uint64_t a2, float *a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));

  if (a2 && WeakRetained && (*(unsigned char *)(a2 + 9) || a3 || *(unsigned char *)(a2 + 8)))
  {
    uint64_t v7 = *(void *)(a2 + 88);
    id v8 = *(id *)(*(void *)(a2 + 80) + 72);
    id v9 = *(id *)(v7 + 72);
    id v10 = *(void **)(a1 + 8);
    char v11 = [NSNumber numberWithUnsignedLong:a2];
    id v12 = [v10 objectForKey:v11];

    if (!v12)
    {
      id v12 = objc_alloc_init(PKPhysicsContact);
      [(PKPhysicsContact *)v12 setBodyA:v8];
      [(PKPhysicsContact *)v12 setBodyB:v9];
      [(PKPhysicsContact *)v12 setCollisionImpulse:0.0];
      id v13 = *(void **)(a1 + 8);
      long long v14 = [NSNumber numberWithUnsignedLong:a2];
      [v13 setObject:v12 forKey:v14];
    }
    *(float *)&double v15 = b2WorldManifold::Initialize((uint64_t)v23, a2 + 104, (float *)(*(void *)(*(void *)(a2 + 80) + 24) + 32), (float *)(*(void *)(*(void *)(a2 + 88) + 24) + 32), *(float *)(*(void *)(*(void *)(a2 + 80) + 32) + 12), *(float *)(*(void *)(*(void *)(a2 + 88) + 32) + 12));
    uint64_t v16 = *(unsigned int *)(a2 + 164);
    if ((int)v16 >= 1)
    {
      [(PKPhysicsContact *)v12 collisionImpulse];
      float v18 = v17 * PKGet_INV_PTM_RATIO();
      float v19 = v23[2];
      float v20 = v24;
      if (a3)
      {
        uint64_t v21 = &v24;
        do
        {
          if (*a3 > v18)
          {
            float v19 = *(v21 - 1);
            float v20 = *v21;
            float v18 = *a3;
          }
          ++a3;
          v21 += 2;
          --v16;
        }
        while (v16);
      }
      [(PKPhysicsContact *)v12 setCollisionImpulse:(float)(v18 * PKGet_PTM_RATIO())];
      -[PKPhysicsContact setContactNormal:](v12, "setContactNormal:", v23[0], v23[1]);
      float v22 = PKGet_PTM_RATIO();
      -[PKPhysicsContact setContactPoint:](v12, "setContactPoint:", (float)(v19 * v22), (float)(v20 * PKGet_PTM_RATIO()));
    }
    if (*(unsigned char *)(a2 + 8)) {
      [(PKPhysicsContact *)v12 setDidBegin:1];
    }
    if (*(unsigned char *)(a2 + 9)) {
      [(PKPhysicsContact *)v12 setDidEnd:1];
    }
    *(_WORD *)(a2 + 8) = 0;
  }
}

void sub_213569184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PKContactListener::PKContactListener(PKContactListener *this)
{
  this->_vptr$b2ContactListener = (void **)&unk_26C3F3BC0;
  this->_contacts = 0;
  this->_contactDelegate = 0;
  objc_storeWeak((id *)&this->_contactDelegate, 0);
  uint64_t v2 = [MEMORY[0x263EFF9A0] dictionaryWithCapacity:0];
  contacts = this->_contacts;
  this->_contacts = v2;
}

void sub_213569250(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);

  _Unwind_Resume(a1);
}

void PKDebugDraw::PKDebugDraw(PKDebugDraw *this, PKDebugDrawPacket *a2, int a3, int a4)
{
  b2Draw::b2Draw(this);
  void *v7 = &unk_26C3F32D8;
  v7[2] = a2;
  a2->_linePoints.__end_ = a2->_linePoints.__begin_;
  a2->_colors.__end_ = a2->_colors.__begin_;
  if (a3) {
    int v8 = 3;
  }
  else {
    int v8 = 0;
  }
  if (a4) {
    int v9 = v8 | 0x20;
  }
  else {
    int v9 = v8;
  }
  b2Draw::SetFlags((uint64_t)v7, v9);
}

void PKDebugDraw::~PKDebugDraw(PKDebugDraw *this)
{
}

void PKDebugDraw::DrawPolygon(uint64_t a1, int *a2, int a3, int *a4)
{
  unint64_t v8 = 2 * a3;
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), v8);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(void *)(a1 + 16) + 24), v8);
  int v10 = *a4;
  int v9 = a4[1];
  uint64_t v11 = (a3 - 1);
  int v12 = a4[2];
  if (a3 >= 2)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(void *)&a2[2 * v13];
      uint64_t v15 = *(void *)(a1 + 16);
      uint64_t v16 = *(void **)(v15 + 8);
      unint64_t v17 = *(void *)(v15 + 16);
      if ((unint64_t)v16 >= v17)
      {
        float v19 = *(void **)v15;
        uint64_t v20 = ((uint64_t)v16 - *(void *)v15) >> 3;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61) {
          goto LABEL_133;
        }
        uint64_t v22 = v17 - (void)v19;
        if (v22 >> 2 > v21) {
          unint64_t v21 = v22 >> 2;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23)
        {
          float v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v15 + 16, v23);
          float v19 = *(void **)v15;
          uint64_t v16 = *(void **)(v15 + 8);
        }
        else
        {
          float v24 = 0;
        }
        long long v25 = &v24[8 * v20];
        *(void *)long long v25 = v14;
        float v18 = v25 + 8;
        if (v16 != v19)
        {
          do
          {
            uint64_t v26 = *--v16;
            *((void *)v25 - 1) = v26;
            v25 -= 8;
          }
          while (v16 != v19);
          float v19 = *(void **)v15;
        }
        *(void *)uint64_t v15 = v25;
        *(void *)(v15 + 8) = v18;
        *(void *)(v15 + 16) = &v24[8 * v23];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        *uint64_t v16 = v14;
        float v18 = v16 + 1;
      }
      *(void *)(v15 + 8) = v18;
      ++v13;
      uint64_t v27 = *(void *)&a2[2 * v13];
      uint64_t v28 = *(void *)(a1 + 16);
      uint64_t v29 = *(void **)(v28 + 8);
      unint64_t v30 = *(void *)(v28 + 16);
      if ((unint64_t)v29 >= v30)
      {
        long long v32 = *(void **)v28;
        uint64_t v33 = ((uint64_t)v29 - *(void *)v28) >> 3;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61) {
          goto LABEL_133;
        }
        uint64_t v35 = v30 - (void)v32;
        if (v35 >> 2 > v34) {
          unint64_t v34 = v35 >> 2;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          uint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v28 + 16, v36);
          long long v32 = *(void **)v28;
          uint64_t v29 = *(void **)(v28 + 8);
        }
        else
        {
          uint64_t v37 = 0;
        }
        uint64_t v38 = &v37[8 * v33];
        *(void *)uint64_t v38 = v27;
        float v31 = v38 + 8;
        if (v29 != v32)
        {
          do
          {
            uint64_t v39 = *--v29;
            *((void *)v38 - 1) = v39;
            v38 -= 8;
          }
          while (v29 != v32);
          long long v32 = *(void **)v28;
        }
        *(void *)uint64_t v28 = v38;
        *(void *)(v28 + 8) = v31;
        *(void *)(v28 + 16) = &v37[8 * v36];
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        *uint64_t v29 = v27;
        float v31 = v29 + 1;
      }
      *(void *)(v28 + 8) = v31;
      uint64_t v40 = *(void **)(a1 + 16);
      __n128 v41 = (char *)v40[4];
      unint64_t v42 = v40[5];
      if ((unint64_t)v41 >= v42)
      {
        long long v44 = (char *)v40[3];
        uint64_t v45 = (v41 - v44) >> 4;
        unint64_t v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 60) {
          goto LABEL_134;
        }
        uint64_t v47 = v42 - (void)v44;
        if (v47 >> 3 > v46) {
          unint64_t v46 = v47 >> 3;
        }
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v48 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v48 = v46;
        }
        if (v48)
        {
          long long v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v40 + 5), v48);
          long long v44 = (char *)v40[3];
          __n128 v41 = (char *)v40[4];
        }
        else
        {
          long long v49 = 0;
        }
        long long v50 = &v49[16 * v45];
        *(_DWORD *)long long v50 = v10;
        *((_DWORD *)v50 + 1) = v9;
        *((_DWORD *)v50 + 2) = v12;
        *((_DWORD *)v50 + 3) = 1065353216;
        long long v51 = v50;
        if (v41 != v44)
        {
          do
          {
            *((_OWORD *)v51 - 1) = *((_OWORD *)v41 - 1);
            v51 -= 16;
            v41 -= 16;
          }
          while (v41 != v44);
          long long v44 = (char *)v40[3];
        }
        long long v43 = v50 + 16;
        v40[3] = v51;
        v40[4] = v50 + 16;
        v40[5] = &v49[16 * v48];
        if (v44) {
          operator delete(v44);
        }
      }
      else
      {
        *(_DWORD *)__n128 v41 = v10;
        *((_DWORD *)v41 + 1) = v9;
        *((_DWORD *)v41 + 2) = v12;
        long long v43 = v41 + 16;
        *((_DWORD *)v41 + 3) = 1065353216;
      }
      v40[4] = v43;
      uint64_t v52 = *(void **)(a1 + 16);
      uint64_t v53 = (char *)v52[4];
      unint64_t v54 = v52[5];
      if ((unint64_t)v53 >= v54)
      {
        uint64_t v56 = (char *)v52[3];
        uint64_t v57 = (v53 - v56) >> 4;
        unint64_t v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 60) {
LABEL_134:
        }
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        uint64_t v59 = v54 - (void)v56;
        if (v59 >> 3 > v58) {
          unint64_t v58 = v59 >> 3;
        }
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v60 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v60 = v58;
        }
        if (v60)
        {
          id v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v52 + 5), v60);
          uint64_t v56 = (char *)v52[3];
          uint64_t v53 = (char *)v52[4];
        }
        else
        {
          id v61 = 0;
        }
        long long v62 = &v61[16 * v57];
        *(_DWORD *)long long v62 = v10;
        *((_DWORD *)v62 + 1) = v9;
        *((_DWORD *)v62 + 2) = v12;
        *((_DWORD *)v62 + 3) = 1065353216;
        long long v63 = v62;
        if (v53 != v56)
        {
          do
          {
            *((_OWORD *)v63 - 1) = *((_OWORD *)v53 - 1);
            v63 -= 16;
            v53 -= 16;
          }
          while (v53 != v56);
          uint64_t v56 = (char *)v52[3];
        }
        uint64_t v55 = v62 + 16;
        v52[3] = v63;
        v52[4] = v62 + 16;
        v52[5] = &v61[16 * v60];
        if (v56) {
          operator delete(v56);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v53 = v10;
        *((_DWORD *)v53 + 1) = v9;
        *((_DWORD *)v53 + 2) = v12;
        uint64_t v55 = v53 + 16;
        *((_DWORD *)v53 + 3) = 1065353216;
      }
      v52[4] = v55;
    }
    while (v13 != v11);
  }
  uint64_t v64 = *(void *)&a2[2 * (int)v11];
  uint64_t v65 = *(void *)(a1 + 16);
  long long v66 = *(void **)(v65 + 8);
  unint64_t v67 = *(void *)(v65 + 16);
  if ((unint64_t)v66 >= v67)
  {
    id v69 = *(void **)v65;
    uint64_t v70 = ((uint64_t)v66 - *(void *)v65) >> 3;
    unint64_t v71 = v70 + 1;
    if ((unint64_t)(v70 + 1) >> 61) {
LABEL_133:
    }
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    uint64_t v72 = v67 - (void)v69;
    if (v72 >> 2 > v71) {
      unint64_t v71 = v72 >> 2;
    }
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v73 = v71;
    }
    if (v73)
    {
      long long v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v65 + 16, v73);
      id v69 = *(void **)v65;
      long long v66 = *(void **)(v65 + 8);
    }
    else
    {
      long long v74 = 0;
    }
    long long v75 = &v74[8 * v70];
    uint64_t v76 = &v74[8 * v73];
    *(void *)long long v75 = v64;
    uint64_t v68 = v75 + 8;
    if (v66 != v69)
    {
      do
      {
        uint64_t v77 = *--v66;
        *((void *)v75 - 1) = v77;
        v75 -= 8;
      }
      while (v66 != v69);
      id v69 = *(void **)v65;
    }
    *(void *)uint64_t v65 = v75;
    *(void *)(v65 + 8) = v68;
    *(void *)(v65 + 16) = v76;
    if (v69) {
      operator delete(v69);
    }
  }
  else
  {
    void *v66 = v64;
    uint64_t v68 = v66 + 1;
  }
  *(void *)(v65 + 8) = v68;
  int v79 = *a2;
  int v78 = a2[1];
  uint64_t v80 = *(void *)(a1 + 16);
  id v81 = *(_DWORD **)(v80 + 8);
  unint64_t v82 = *(void *)(v80 + 16);
  if ((unint64_t)v81 >= v82)
  {
    uint64_t v84 = *(_DWORD **)v80;
    uint64_t v85 = ((uint64_t)v81 - *(void *)v80) >> 3;
    unint64_t v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v87 = v82 - (void)v84;
    if (v87 >> 2 > v86) {
      unint64_t v86 = v87 >> 2;
    }
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v88 = v86;
    }
    if (v88)
    {
      id v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v80 + 16, v88);
      uint64_t v84 = *(_DWORD **)v80;
      id v81 = *(_DWORD **)(v80 + 8);
    }
    else
    {
      id v89 = 0;
    }
    long long v90 = &v89[8 * v85];
    long long v91 = &v89[8 * v88];
    *(_DWORD *)long long v90 = v79;
    *((_DWORD *)v90 + 1) = v78;
    long long v83 = v90 + 8;
    if (v81 != v84)
    {
      do
      {
        uint64_t v92 = *((void *)v81 - 1);
        v81 -= 2;
        *((void *)v90 - 1) = v92;
        v90 -= 8;
      }
      while (v81 != v84);
      uint64_t v84 = *(_DWORD **)v80;
    }
    *(void *)uint64_t v80 = v90;
    *(void *)(v80 + 8) = v83;
    *(void *)(v80 + 16) = v91;
    if (v84) {
      operator delete(v84);
    }
  }
  else
  {
    _DWORD *v81 = v79;
    v81[1] = v78;
    long long v83 = v81 + 2;
  }
  *(void *)(v80 + 8) = v83;
  id v93 = *(void **)(a1 + 16);
  long long v94 = (char *)v93[4];
  unint64_t v95 = v93[5];
  if ((unint64_t)v94 >= v95)
  {
    v97 = (char *)v93[3];
    uint64_t v98 = (v94 - v97) >> 4;
    unint64_t v99 = v98 + 1;
    if ((unint64_t)(v98 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v100 = v95 - (void)v97;
    if (v100 >> 3 > v99) {
      unint64_t v99 = v100 >> 3;
    }
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v101 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v101 = v99;
    }
    if (v101)
    {
      v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v93 + 5), v101);
      v97 = (char *)v93[3];
      long long v94 = (char *)v93[4];
    }
    else
    {
      v102 = 0;
    }
    v103 = &v102[16 * v98];
    v104 = &v102[16 * v101];
    *(_DWORD *)v103 = v10;
    *((_DWORD *)v103 + 1) = v9;
    *((_DWORD *)v103 + 2) = v12;
    *((_DWORD *)v103 + 3) = 1065353216;
    uint64_t v96 = v103 + 16;
    if (v94 != v97)
    {
      do
      {
        *((_OWORD *)v103 - 1) = *((_OWORD *)v94 - 1);
        v103 -= 16;
        v94 -= 16;
      }
      while (v94 != v97);
      v97 = (char *)v93[3];
    }
    v93[3] = v103;
    v93[4] = v96;
    v93[5] = v104;
    if (v97) {
      operator delete(v97);
    }
  }
  else
  {
    *(_DWORD *)long long v94 = v10;
    *((_DWORD *)v94 + 1) = v9;
    *((_DWORD *)v94 + 2) = v12;
    *((_DWORD *)v94 + 3) = 1065353216;
    uint64_t v96 = v94 + 16;
  }
  v93[4] = v96;
  v105 = *(void **)(a1 + 16);
  v106 = (char *)v105[4];
  unint64_t v107 = v105[5];
  if ((unint64_t)v106 >= v107)
  {
    v109 = (char *)v105[3];
    uint64_t v110 = (v106 - v109) >> 4;
    unint64_t v111 = v110 + 1;
    if ((unint64_t)(v110 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v112 = v107 - (void)v109;
    if (v112 >> 3 > v111) {
      unint64_t v111 = v112 >> 3;
    }
    if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v113 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v113 = v111;
    }
    if (v113)
    {
      v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v105 + 5), v113);
      v109 = (char *)v105[3];
      v106 = (char *)v105[4];
    }
    else
    {
      v114 = 0;
    }
    v115 = &v114[16 * v110];
    v116 = &v114[16 * v113];
    *(_DWORD *)v115 = v10;
    *((_DWORD *)v115 + 1) = v9;
    *((_DWORD *)v115 + 2) = v12;
    *((_DWORD *)v115 + 3) = 1065353216;
    v108 = v115 + 16;
    if (v106 != v109)
    {
      do
      {
        *((_OWORD *)v115 - 1) = *((_OWORD *)v106 - 1);
        v115 -= 16;
        v106 -= 16;
      }
      while (v106 != v109);
      v109 = (char *)v105[3];
    }
    v105[3] = v115;
    v105[4] = v108;
    v105[5] = v116;
    if (v109) {
      operator delete(v109);
    }
  }
  else
  {
    *(_DWORD *)v106 = v10;
    *((_DWORD *)v106 + 1) = v9;
    *((_DWORD *)v106 + 2) = v12;
    *((_DWORD *)v106 + 3) = 1065353216;
    v108 = v106 + 16;
  }
  v105[4] = v108;
}

void PKDebugDraw::DrawCircle(uint64_t a1, float *a2, int *a3, float a4)
{
  int v7 = *a3;
  int v8 = a3[1];
  int v9 = a3[2];
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x20uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(void *)(a1 + 16) + 24), 0x20uLL);
  float v10 = 0.0;
  int v74 = v8;
  int v75 = v7;
  int v73 = v9;
  do
  {
    __float2 v11 = __sincosf_stret(v10);
    float v13 = *a2;
    float v12 = a2[1];
    float v14 = *a2 + (float)(a4 * v11.__cosval);
    float v15 = a4;
    float v16 = v12 + (float)(a4 * v11.__sinval);
    float v10 = v10 + 0.3927;
    __float2 v17 = __sincosf_stret(v10);
    uint64_t v18 = *(void *)(a1 + 16);
    float v19 = *(float **)(v18 + 8);
    unint64_t v20 = *(void *)(v18 + 16);
    if ((unint64_t)v19 >= v20)
    {
      uint64_t v22 = *(float **)v18;
      uint64_t v23 = ((uint64_t)v19 - *(void *)v18) >> 3;
      unint64_t v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 61) {
        goto LABEL_70;
      }
      uint64_t v25 = v20 - (void)v22;
      if (v25 >> 2 > v24) {
        unint64_t v24 = v25 >> 2;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v24;
      }
      if (v26)
      {
        uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v18 + 16, v26);
        uint64_t v22 = *(float **)v18;
        float v19 = *(float **)(v18 + 8);
      }
      else
      {
        uint64_t v27 = 0;
      }
      uint64_t v28 = (float *)&v27[8 * v23];
      *uint64_t v28 = v14;
      v28[1] = v16;
      uint64_t v29 = v28;
      a4 = v15;
      if (v19 != v22)
      {
        do
        {
          uint64_t v30 = *((void *)v19 - 1);
          v19 -= 2;
          *((void *)v29 - 1) = v30;
          v29 -= 2;
        }
        while (v19 != v22);
        uint64_t v22 = *(float **)v18;
      }
      unint64_t v21 = v28 + 2;
      *(void *)uint64_t v18 = v29;
      *(void *)(v18 + 8) = v28 + 2;
      *(void *)(v18 + 16) = &v27[8 * v26];
      if (v22) {
        operator delete(v22);
      }
    }
    else
    {
      *float v19 = v14;
      v19[1] = v16;
      unint64_t v21 = v19 + 2;
      a4 = v15;
    }
    float v31 = v13 + (float)(a4 * v17.__cosval);
    float v32 = v12 + (float)(a4 * v17.__sinval);
    *(void *)(v18 + 8) = v21;
    uint64_t v33 = *(void *)(a1 + 16);
    unint64_t v34 = *(float **)(v33 + 8);
    unint64_t v35 = *(void *)(v33 + 16);
    if ((unint64_t)v34 >= v35)
    {
      uint64_t v40 = *(float **)v33;
      uint64_t v41 = ((uint64_t)v34 - *(void *)v33) >> 3;
      unint64_t v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61) {
LABEL_70:
      }
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      uint64_t v43 = v35 - (void)v40;
      if (v43 >> 2 > v42) {
        unint64_t v42 = v43 >> 2;
      }
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v42;
      }
      if (v44)
      {
        uint64_t v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v33 + 16, v44);
        uint64_t v40 = *(float **)v33;
        unint64_t v34 = *(float **)(v33 + 8);
      }
      else
      {
        uint64_t v45 = 0;
      }
      unint64_t v46 = (float *)&v45[8 * v41];
      *unint64_t v46 = v31;
      v46[1] = v32;
      uint64_t v47 = v46;
      if (v34 == v40)
      {
        int v38 = v74;
        int v37 = v75;
        int v39 = v73;
      }
      else
      {
        int v38 = v74;
        int v37 = v75;
        int v39 = v73;
        do
        {
          uint64_t v48 = *((void *)v34 - 1);
          v34 -= 2;
          *((void *)v47 - 1) = v48;
          v47 -= 2;
        }
        while (v34 != v40);
        uint64_t v40 = *(float **)v33;
      }
      unint64_t v36 = v46 + 2;
      *(void *)uint64_t v33 = v47;
      *(void *)(v33 + 8) = v46 + 2;
      *(void *)(v33 + 16) = &v45[8 * v44];
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *unint64_t v34 = v31;
      v34[1] = v32;
      unint64_t v36 = v34 + 2;
      int v38 = v74;
      int v37 = v75;
      int v39 = v73;
    }
    *(void *)(v33 + 8) = v36;
    long long v49 = *(void **)(a1 + 16);
    long long v50 = (char *)v49[4];
    unint64_t v51 = v49[5];
    if ((unint64_t)v50 >= v51)
    {
      uint64_t v53 = (char *)v49[3];
      uint64_t v54 = (v50 - v53) >> 4;
      unint64_t v55 = v54 + 1;
      if ((unint64_t)(v54 + 1) >> 60) {
        goto LABEL_71;
      }
      uint64_t v56 = v51 - (void)v53;
      if (v56 >> 3 > v55) {
        unint64_t v55 = v56 >> 3;
      }
      if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v57 = v55;
      }
      if (v57)
      {
        unint64_t v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v49 + 5), v57);
        uint64_t v53 = (char *)v49[3];
        long long v50 = (char *)v49[4];
      }
      else
      {
        unint64_t v58 = 0;
      }
      uint64_t v59 = &v58[16 * v54];
      *(_DWORD *)uint64_t v59 = v37;
      *((_DWORD *)v59 + 1) = v38;
      *((_DWORD *)v59 + 2) = v39;
      *((_DWORD *)v59 + 3) = 1065353216;
      unint64_t v60 = v59;
      if (v50 != v53)
      {
        do
        {
          *((_OWORD *)v60 - 1) = *((_OWORD *)v50 - 1);
          v60 -= 16;
          v50 -= 16;
        }
        while (v50 != v53);
        uint64_t v53 = (char *)v49[3];
      }
      uint64_t v52 = v59 + 16;
      v49[3] = v60;
      v49[4] = v59 + 16;
      v49[5] = &v58[16 * v57];
      if (v53) {
        operator delete(v53);
      }
    }
    else
    {
      *(_DWORD *)long long v50 = v37;
      *((_DWORD *)v50 + 1) = v38;
      *((_DWORD *)v50 + 2) = v39;
      uint64_t v52 = v50 + 16;
      *((_DWORD *)v50 + 3) = 1065353216;
    }
    v49[4] = v52;
    id v61 = *(void **)(a1 + 16);
    long long v62 = (char *)v61[4];
    unint64_t v63 = v61[5];
    if ((unint64_t)v62 >= v63)
    {
      uint64_t v65 = (char *)v61[3];
      uint64_t v66 = (v62 - v65) >> 4;
      unint64_t v67 = v66 + 1;
      if ((unint64_t)(v66 + 1) >> 60) {
LABEL_71:
      }
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      uint64_t v68 = v63 - (void)v65;
      if (v68 >> 3 > v67) {
        unint64_t v67 = v68 >> 3;
      }
      if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v69 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v69 = v67;
      }
      if (v69)
      {
        uint64_t v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v61 + 5), v69);
        uint64_t v65 = (char *)v61[3];
        long long v62 = (char *)v61[4];
      }
      else
      {
        uint64_t v70 = 0;
      }
      unint64_t v71 = &v70[16 * v66];
      *(_DWORD *)unint64_t v71 = v37;
      *((_DWORD *)v71 + 1) = v38;
      *((_DWORD *)v71 + 2) = v39;
      *((_DWORD *)v71 + 3) = 1065353216;
      uint64_t v72 = v71;
      if (v62 != v65)
      {
        do
        {
          *((_OWORD *)v72 - 1) = *((_OWORD *)v62 - 1);
          v72 -= 16;
          v62 -= 16;
        }
        while (v62 != v65);
        uint64_t v65 = (char *)v61[3];
      }
      uint64_t v64 = v71 + 16;
      v61[3] = v72;
      v61[4] = v71 + 16;
      v61[5] = &v70[16 * v69];
      if (v65) {
        operator delete(v65);
      }
    }
    else
    {
      *(_DWORD *)long long v62 = v37;
      *((_DWORD *)v62 + 1) = v38;
      *((_DWORD *)v62 + 2) = v39;
      uint64_t v64 = v62 + 16;
      *((_DWORD *)v62 + 3) = 1065353216;
    }
    v61[4] = v64;
  }
  while (v10 < 6.6758844);
}

void PKDebugDraw::DrawSolidCircle(uint64_t a1, float *a2, float a3, uint64_t a4, int *a5)
{
  int v8 = *a5;
  int v9 = a5[1];
  int v10 = a5[2];
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x20uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(void *)(a1 + 16) + 24), 0x20uLL);
  float v11 = 0.0;
  int v75 = v9;
  int v76 = v8;
  int v74 = v10;
  do
  {
    __float2 v12 = __sincosf_stret(v11);
    float v14 = *a2;
    float v13 = a2[1];
    float v15 = *a2 + (float)(a3 * v12.__cosval);
    float v16 = a3;
    float v17 = v13 + (float)(a3 * v12.__sinval);
    float v11 = v11 + 0.3927;
    __float2 v18 = __sincosf_stret(v11);
    uint64_t v19 = *(void *)(a1 + 16);
    unint64_t v20 = *(float **)(v19 + 8);
    unint64_t v21 = *(void *)(v19 + 16);
    if ((unint64_t)v20 >= v21)
    {
      uint64_t v23 = *(float **)v19;
      uint64_t v24 = ((uint64_t)v20 - *(void *)v19) >> 3;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61) {
        goto LABEL_70;
      }
      uint64_t v26 = v21 - (void)v23;
      if (v26 >> 2 > v25) {
        unint64_t v25 = v26 >> 2;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27)
      {
        uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v19 + 16, v27);
        uint64_t v23 = *(float **)v19;
        unint64_t v20 = *(float **)(v19 + 8);
      }
      else
      {
        uint64_t v28 = 0;
      }
      uint64_t v29 = (float *)&v28[8 * v24];
      *uint64_t v29 = v15;
      v29[1] = v17;
      uint64_t v30 = v29;
      a3 = v16;
      if (v20 != v23)
      {
        do
        {
          uint64_t v31 = *((void *)v20 - 1);
          v20 -= 2;
          *((void *)v30 - 1) = v31;
          v30 -= 2;
        }
        while (v20 != v23);
        uint64_t v23 = *(float **)v19;
      }
      uint64_t v22 = v29 + 2;
      *(void *)uint64_t v19 = v30;
      *(void *)(v19 + 8) = v29 + 2;
      *(void *)(v19 + 16) = &v28[8 * v27];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *unint64_t v20 = v15;
      v20[1] = v17;
      uint64_t v22 = v20 + 2;
      a3 = v16;
    }
    float v32 = v14 + (float)(a3 * v18.__cosval);
    float v33 = v13 + (float)(a3 * v18.__sinval);
    *(void *)(v19 + 8) = v22;
    uint64_t v34 = *(void *)(a1 + 16);
    unint64_t v35 = *(float **)(v34 + 8);
    unint64_t v36 = *(void *)(v34 + 16);
    if ((unint64_t)v35 >= v36)
    {
      uint64_t v41 = *(float **)v34;
      uint64_t v42 = ((uint64_t)v35 - *(void *)v34) >> 3;
      unint64_t v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 61) {
LABEL_70:
      }
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      uint64_t v44 = v36 - (void)v41;
      if (v44 >> 2 > v43) {
        unint64_t v43 = v44 >> 2;
      }
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v45 = v43;
      }
      if (v45)
      {
        unint64_t v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v34 + 16, v45);
        uint64_t v41 = *(float **)v34;
        unint64_t v35 = *(float **)(v34 + 8);
      }
      else
      {
        unint64_t v46 = 0;
      }
      uint64_t v47 = (float *)&v46[8 * v42];
      *uint64_t v47 = v32;
      v47[1] = v33;
      uint64_t v48 = v47;
      if (v35 == v41)
      {
        int v39 = v75;
        int v38 = v76;
        int v40 = v74;
      }
      else
      {
        int v39 = v75;
        int v38 = v76;
        int v40 = v74;
        do
        {
          uint64_t v49 = *((void *)v35 - 1);
          v35 -= 2;
          *((void *)v48 - 1) = v49;
          v48 -= 2;
        }
        while (v35 != v41);
        uint64_t v41 = *(float **)v34;
      }
      int v37 = v47 + 2;
      *(void *)uint64_t v34 = v48;
      *(void *)(v34 + 8) = v47 + 2;
      *(void *)(v34 + 16) = &v46[8 * v45];
      if (v41) {
        operator delete(v41);
      }
    }
    else
    {
      float *v35 = v32;
      v35[1] = v33;
      int v37 = v35 + 2;
      int v39 = v75;
      int v38 = v76;
      int v40 = v74;
    }
    *(void *)(v34 + 8) = v37;
    long long v50 = *(void **)(a1 + 16);
    unint64_t v51 = (char *)v50[4];
    unint64_t v52 = v50[5];
    if ((unint64_t)v51 >= v52)
    {
      uint64_t v54 = (char *)v50[3];
      uint64_t v55 = (v51 - v54) >> 4;
      unint64_t v56 = v55 + 1;
      if ((unint64_t)(v55 + 1) >> 60) {
        goto LABEL_71;
      }
      uint64_t v57 = v52 - (void)v54;
      if (v57 >> 3 > v56) {
        unint64_t v56 = v57 >> 3;
      }
      if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v58 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v58 = v56;
      }
      if (v58)
      {
        uint64_t v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v50 + 5), v58);
        uint64_t v54 = (char *)v50[3];
        unint64_t v51 = (char *)v50[4];
      }
      else
      {
        uint64_t v59 = 0;
      }
      unint64_t v60 = &v59[16 * v55];
      *(_DWORD *)unint64_t v60 = v38;
      *((_DWORD *)v60 + 1) = v39;
      *((_DWORD *)v60 + 2) = v40;
      *((_DWORD *)v60 + 3) = 1065353216;
      id v61 = v60;
      if (v51 != v54)
      {
        do
        {
          *((_OWORD *)v61 - 1) = *((_OWORD *)v51 - 1);
          v61 -= 16;
          v51 -= 16;
        }
        while (v51 != v54);
        uint64_t v54 = (char *)v50[3];
      }
      uint64_t v53 = v60 + 16;
      v50[3] = v61;
      v50[4] = v60 + 16;
      v50[5] = &v59[16 * v58];
      if (v54) {
        operator delete(v54);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v51 = v38;
      *((_DWORD *)v51 + 1) = v39;
      *((_DWORD *)v51 + 2) = v40;
      uint64_t v53 = v51 + 16;
      *((_DWORD *)v51 + 3) = 1065353216;
    }
    v50[4] = v53;
    long long v62 = *(void **)(a1 + 16);
    unint64_t v63 = (char *)v62[4];
    unint64_t v64 = v62[5];
    if ((unint64_t)v63 >= v64)
    {
      uint64_t v66 = (char *)v62[3];
      uint64_t v67 = (v63 - v66) >> 4;
      unint64_t v68 = v67 + 1;
      if ((unint64_t)(v67 + 1) >> 60) {
LABEL_71:
      }
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      uint64_t v69 = v64 - (void)v66;
      if (v69 >> 3 > v68) {
        unint64_t v68 = v69 >> 3;
      }
      if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v70 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v70 = v68;
      }
      if (v70)
      {
        unint64_t v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v62 + 5), v70);
        uint64_t v66 = (char *)v62[3];
        unint64_t v63 = (char *)v62[4];
      }
      else
      {
        unint64_t v71 = 0;
      }
      uint64_t v72 = &v71[16 * v67];
      *(_DWORD *)uint64_t v72 = v38;
      *((_DWORD *)v72 + 1) = v39;
      *((_DWORD *)v72 + 2) = v40;
      *((_DWORD *)v72 + 3) = 1065353216;
      int v73 = v72;
      if (v63 != v66)
      {
        do
        {
          *((_OWORD *)v73 - 1) = *((_OWORD *)v63 - 1);
          v73 -= 16;
          v63 -= 16;
        }
        while (v63 != v66);
        uint64_t v66 = (char *)v62[3];
      }
      uint64_t v65 = v72 + 16;
      v62[3] = v73;
      v62[4] = v72 + 16;
      v62[5] = &v71[16 * v70];
      if (v66) {
        operator delete(v66);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v63 = v38;
      *((_DWORD *)v63 + 1) = v39;
      *((_DWORD *)v63 + 2) = v40;
      uint64_t v65 = v63 + 16;
      *((_DWORD *)v63 + 3) = 1065353216;
    }
    v62[4] = v65;
  }
  while (v11 < 6.6758844);
}

void PKDebugDraw::DrawSegment(uint64_t a1, int *a2, int *a3, int *a4)
{
  int v6 = *a4;
  int v5 = a4[1];
  int v7 = a4[2];
  int v9 = *a2;
  int v8 = a2[1];
  int v11 = *a3;
  int v10 = a3[1];
  uint64_t v12 = *(void *)(a1 + 16);
  float v13 = *(_DWORD **)(v12 + 8);
  unint64_t v14 = *(void *)(v12 + 16);
  if ((unint64_t)v13 >= v14)
  {
    float v16 = *(_DWORD **)v12;
    uint64_t v17 = ((uint64_t)v13 - *(void *)v12) >> 3;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 61) {
      goto LABEL_66;
    }
    uint64_t v19 = v14 - (void)v16;
    if (v19 >> 2 > v18) {
      unint64_t v18 = v19 >> 2;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      unint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v12 + 16, v20);
      float v16 = *(_DWORD **)v12;
      float v13 = *(_DWORD **)(v12 + 8);
    }
    else
    {
      unint64_t v21 = 0;
    }
    uint64_t v22 = &v21[8 * v17];
    uint64_t v23 = &v21[8 * v20];
    *(_DWORD *)uint64_t v22 = v9;
    *((_DWORD *)v22 + 1) = v8;
    float v15 = v22 + 8;
    if (v13 != v16)
    {
      do
      {
        uint64_t v24 = *((void *)v13 - 1);
        v13 -= 2;
        *((void *)v22 - 1) = v24;
        v22 -= 8;
      }
      while (v13 != v16);
      float v16 = *(_DWORD **)v12;
    }
    *(void *)uint64_t v12 = v22;
    *(void *)(v12 + 8) = v15;
    *(void *)(v12 + 16) = v23;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *float v13 = v9;
    v13[1] = v8;
    float v15 = v13 + 2;
  }
  *(void *)(v12 + 8) = v15;
  uint64_t v25 = *(void *)(a1 + 16);
  uint64_t v26 = *(_DWORD **)(v25 + 8);
  unint64_t v27 = *(void *)(v25 + 16);
  if ((unint64_t)v26 < v27)
  {
    *uint64_t v26 = v11;
    v26[1] = v10;
    uint64_t v28 = v26 + 2;
    goto LABEL_33;
  }
  uint64_t v29 = *(_DWORD **)v25;
  uint64_t v30 = ((uint64_t)v26 - *(void *)v25) >> 3;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61) {
LABEL_66:
  }
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  uint64_t v32 = v27 - (void)v29;
  if (v32 >> 2 > v31) {
    unint64_t v31 = v32 >> 2;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v31;
  }
  if (v33)
  {
    uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v25 + 16, v33);
    uint64_t v29 = *(_DWORD **)v25;
    uint64_t v26 = *(_DWORD **)(v25 + 8);
  }
  else
  {
    uint64_t v34 = 0;
  }
  unint64_t v35 = &v34[8 * v30];
  unint64_t v36 = &v34[8 * v33];
  *(_DWORD *)unint64_t v35 = v11;
  *((_DWORD *)v35 + 1) = v10;
  uint64_t v28 = v35 + 8;
  if (v26 != v29)
  {
    do
    {
      uint64_t v37 = *((void *)v26 - 1);
      v26 -= 2;
      *((void *)v35 - 1) = v37;
      v35 -= 8;
    }
    while (v26 != v29);
    uint64_t v29 = *(_DWORD **)v25;
  }
  *(void *)uint64_t v25 = v35;
  *(void *)(v25 + 8) = v28;
  *(void *)(v25 + 16) = v36;
  if (v29) {
    operator delete(v29);
  }
LABEL_33:
  *(void *)(v25 + 8) = v28;
  int v38 = *(void **)(a1 + 16);
  int v39 = (char *)v38[4];
  unint64_t v40 = v38[5];
  if ((unint64_t)v39 >= v40)
  {
    uint64_t v42 = (char *)v38[3];
    uint64_t v43 = (v39 - v42) >> 4;
    unint64_t v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v45 = v40 - (void)v42;
    if (v45 >> 3 > v44) {
      unint64_t v44 = v45 >> 3;
    }
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v46 = v44;
    }
    if (v46)
    {
      uint64_t v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v38 + 5), v46);
      uint64_t v42 = (char *)v38[3];
      int v39 = (char *)v38[4];
    }
    else
    {
      uint64_t v47 = 0;
    }
    uint64_t v48 = &v47[16 * v43];
    uint64_t v49 = &v47[16 * v46];
    *(_DWORD *)uint64_t v48 = v6;
    *((_DWORD *)v48 + 1) = v5;
    *((_DWORD *)v48 + 2) = v7;
    *((_DWORD *)v48 + 3) = 1065353216;
    uint64_t v41 = v48 + 16;
    if (v39 != v42)
    {
      do
      {
        *((_OWORD *)v48 - 1) = *((_OWORD *)v39 - 1);
        v48 -= 16;
        v39 -= 16;
      }
      while (v39 != v42);
      uint64_t v42 = (char *)v38[3];
    }
    v38[3] = v48;
    v38[4] = v41;
    v38[5] = v49;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *(_DWORD *)int v39 = v6;
    *((_DWORD *)v39 + 1) = v5;
    *((_DWORD *)v39 + 2) = v7;
    *((_DWORD *)v39 + 3) = 1065353216;
    uint64_t v41 = v39 + 16;
  }
  v38[4] = v41;
  long long v50 = *(void **)(a1 + 16);
  unint64_t v51 = (char *)v50[4];
  unint64_t v52 = v50[5];
  if ((unint64_t)v51 >= v52)
  {
    uint64_t v54 = (char *)v50[3];
    uint64_t v55 = (v51 - v54) >> 4;
    unint64_t v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v57 = v52 - (void)v54;
    if (v57 >> 3 > v56) {
      unint64_t v56 = v57 >> 3;
    }
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v58 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v58 = v56;
    }
    if (v58)
    {
      uint64_t v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v50 + 5), v58);
      uint64_t v54 = (char *)v50[3];
      unint64_t v51 = (char *)v50[4];
    }
    else
    {
      uint64_t v59 = 0;
    }
    unint64_t v60 = &v59[16 * v55];
    id v61 = &v59[16 * v58];
    *(_DWORD *)unint64_t v60 = v6;
    *((_DWORD *)v60 + 1) = v5;
    *((_DWORD *)v60 + 2) = v7;
    *((_DWORD *)v60 + 3) = 1065353216;
    uint64_t v53 = v60 + 16;
    if (v51 != v54)
    {
      do
      {
        *((_OWORD *)v60 - 1) = *((_OWORD *)v51 - 1);
        v60 -= 16;
        v51 -= 16;
      }
      while (v51 != v54);
      uint64_t v54 = (char *)v50[3];
    }
    v50[3] = v60;
    v50[4] = v53;
    v50[5] = v61;
    if (v54) {
      operator delete(v54);
    }
  }
  else
  {
    *(_DWORD *)unint64_t v51 = v6;
    *((_DWORD *)v51 + 1) = v5;
    *((_DWORD *)v51 + 2) = v7;
    *((_DWORD *)v51 + 3) = 1065353216;
    uint64_t v53 = v51 + 16;
  }
  v50[4] = v53;
}

double PKDebugDraw::FieldRegion(PKDebugDraw *this, b2Vec2 *a2, b2Vec2 *a3, int *a4)
{
  __asm { FMOV            V0.2S, #-1.0 }
  *a2 = _D0;
  __asm { FMOV            V0.2S, #20.0 }
  *(double *)a3 = result;
  *a4 = 120;
  return result;
}

void PKDebugDraw::DrawFieldSample(uint64_t a1, float *a2, float *a3, int *a4)
{
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x1000uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(void *)(a1 + 16) + 24), 0x1000uLL);
  float v8 = *a3;
  float v9 = a3[1];
  if (*a3 > 4.0 || v8 < -4.0 || v9 > 4.0 || v9 < -4.0)
  {
    float v13 = sqrtf((float)(v9 * v9) + (float)(v8 * v8));
    float v8 = (float)(v8 * 4.0) / v13;
    float v9 = (float)(v9 * 4.0) / v13;
  }
  float v14 = *a2;
  float v15 = a2[1];
  int v17 = *a4;
  int v16 = a4[1];
  int v18 = a4[2];
  uint64_t v19 = *(void *)(a1 + 16);
  unint64_t v20 = *(float **)(v19 + 8);
  unint64_t v21 = *(void *)(v19 + 16);
  if ((unint64_t)v20 >= v21)
  {
    uint64_t v23 = *(float **)v19;
    uint64_t v24 = ((uint64_t)v20 - *(void *)v19) >> 3;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61) {
      goto LABEL_78;
    }
    uint64_t v26 = v21 - (void)v23;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v19 + 16, v27);
      uint64_t v23 = *(float **)v19;
      unint64_t v20 = *(float **)(v19 + 8);
    }
    else
    {
      uint64_t v28 = 0;
    }
    uint64_t v29 = (float *)&v28[8 * v24];
    uint64_t v30 = &v28[8 * v27];
    *uint64_t v29 = v14;
    v29[1] = v15;
    uint64_t v22 = v29 + 2;
    if (v20 != v23)
    {
      do
      {
        uint64_t v31 = *((void *)v20 - 1);
        v20 -= 2;
        *((void *)v29 - 1) = v31;
        v29 -= 2;
      }
      while (v20 != v23);
      uint64_t v23 = *(float **)v19;
    }
    *(void *)uint64_t v19 = v29;
    *(void *)(v19 + 8) = v22;
    *(void *)(v19 + 16) = v30;
    if (v23) {
      operator delete(v23);
    }
  }
  else
  {
    *unint64_t v20 = v14;
    v20[1] = v15;
    uint64_t v22 = v20 + 2;
  }
  float v32 = v14 + (float)(v8 * 0.05);
  float v33 = v15 + (float)(v9 * 0.05);
  *(void *)(v19 + 8) = v22;
  uint64_t v34 = *(void *)(a1 + 16);
  unint64_t v35 = *(float **)(v34 + 8);
  unint64_t v36 = *(void *)(v34 + 16);
  if ((unint64_t)v35 < v36)
  {
    float *v35 = v32;
    v35[1] = v33;
    uint64_t v37 = v35 + 2;
    goto LABEL_45;
  }
  int v38 = *(float **)v34;
  uint64_t v39 = ((uint64_t)v35 - *(void *)v34) >> 3;
  unint64_t v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 61) {
LABEL_78:
  }
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  uint64_t v41 = v36 - (void)v38;
  if (v41 >> 2 > v40) {
    unint64_t v40 = v41 >> 2;
  }
  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v42 = v40;
  }
  if (v42)
  {
    uint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v34 + 16, v42);
    int v38 = *(float **)v34;
    unint64_t v35 = *(float **)(v34 + 8);
  }
  else
  {
    uint64_t v43 = 0;
  }
  unint64_t v44 = (float *)&v43[8 * v39];
  uint64_t v45 = &v43[8 * v42];
  float *v44 = v32;
  v44[1] = v33;
  uint64_t v37 = v44 + 2;
  if (v35 != v38)
  {
    do
    {
      uint64_t v46 = *((void *)v35 - 1);
      v35 -= 2;
      *((void *)v44 - 1) = v46;
      v44 -= 2;
    }
    while (v35 != v38);
    int v38 = *(float **)v34;
  }
  *(void *)uint64_t v34 = v44;
  *(void *)(v34 + 8) = v37;
  *(void *)(v34 + 16) = v45;
  if (v38) {
    operator delete(v38);
  }
LABEL_45:
  *(void *)(v34 + 8) = v37;
  uint64_t v47 = *(void **)(a1 + 16);
  uint64_t v48 = (char *)v47[4];
  unint64_t v49 = v47[5];
  if ((unint64_t)v48 >= v49)
  {
    unint64_t v51 = (char *)v47[3];
    uint64_t v52 = (v48 - v51) >> 4;
    unint64_t v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v54 = v49 - (void)v51;
    if (v54 >> 3 > v53) {
      unint64_t v53 = v54 >> 3;
    }
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v55 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55)
    {
      unint64_t v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v47 + 5), v55);
      unint64_t v51 = (char *)v47[3];
      uint64_t v48 = (char *)v47[4];
    }
    else
    {
      unint64_t v56 = 0;
    }
    uint64_t v57 = &v56[16 * v52];
    unint64_t v58 = &v56[16 * v55];
    *(_DWORD *)uint64_t v57 = v17;
    *((_DWORD *)v57 + 1) = v16;
    *((_DWORD *)v57 + 2) = v18;
    *((_DWORD *)v57 + 3) = 1065353216;
    long long v50 = v57 + 16;
    if (v48 != v51)
    {
      do
      {
        *((_OWORD *)v57 - 1) = *((_OWORD *)v48 - 1);
        v57 -= 16;
        v48 -= 16;
      }
      while (v48 != v51);
      unint64_t v51 = (char *)v47[3];
    }
    v47[3] = v57;
    v47[4] = v50;
    v47[5] = v58;
    if (v51) {
      operator delete(v51);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v48 = v17;
    *((_DWORD *)v48 + 1) = v16;
    *((_DWORD *)v48 + 2) = v18;
    *((_DWORD *)v48 + 3) = 1065353216;
    long long v50 = v48 + 16;
  }
  v47[4] = v50;
  uint64_t v59 = *(void **)(a1 + 16);
  unint64_t v60 = (char *)v59[4];
  unint64_t v61 = v59[5];
  if ((unint64_t)v60 >= v61)
  {
    unint64_t v63 = (char *)v59[3];
    uint64_t v64 = (v60 - v63) >> 4;
    unint64_t v65 = v64 + 1;
    if ((unint64_t)(v64 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v66 = v61 - (void)v63;
    if (v66 >> 3 > v65) {
      unint64_t v65 = v66 >> 3;
    }
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v67 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v67 = v65;
    }
    if (v67)
    {
      unint64_t v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v59 + 5), v67);
      unint64_t v63 = (char *)v59[3];
      unint64_t v60 = (char *)v59[4];
    }
    else
    {
      unint64_t v68 = 0;
    }
    uint64_t v69 = &v68[16 * v64];
    unint64_t v70 = &v68[16 * v67];
    *(_DWORD *)uint64_t v69 = v17;
    *((_DWORD *)v69 + 1) = v16;
    *((_DWORD *)v69 + 2) = v18;
    *((_DWORD *)v69 + 3) = 1065353216;
    long long v62 = v69 + 16;
    if (v60 != v63)
    {
      do
      {
        *((_OWORD *)v69 - 1) = *((_OWORD *)v60 - 1);
        v69 -= 16;
        v60 -= 16;
      }
      while (v60 != v63);
      unint64_t v63 = (char *)v59[3];
    }
    v59[3] = v69;
    v59[4] = v62;
    v59[5] = v70;
    if (v63) {
      operator delete(v63);
    }
  }
  else
  {
    *(_DWORD *)unint64_t v60 = v17;
    *((_DWORD *)v60 + 1) = v16;
    *((_DWORD *)v60 + 2) = v18;
    *((_DWORD *)v60 + 3) = 1065353216;
    long long v62 = v60 + 16;
  }
  v59[4] = v62;
}

void std::vector<PKDebugDrawPacket::color4>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v3, a2);
    int v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    float v9 = &v6[16 * v8];
    int v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      int v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

float snoise1(float a1, double a2, int8x8_t a3)
{
  int v3 = (int)a1 - (a1 <= 0.0);
  v4.f32[0] = a1 - (float)v3;
  v4.f32[1] = v4.f32[0] + -1.0;
  __asm { FMOV            V1.2S, #1.0 }
  a3.i8[0] = perm[v3];
  a3.i8[4] = perm[(v3 + 1)];
  int8x8_t v10 = vand_s8(a3, (int8x8_t)0xFF000000FFLL);
  float32x2_t v11 = vadd_f32(vcvt_f32_s32((int32x2_t)(*(void *)&v10 & 0xFFFFFF07FFFFFF07)), _D1);
  float32x2_t v12 = vmls_f32(_D1, v4, v4);
  float32x2_t v13 = vmul_f32(v12, v12);
  return vaddv_f32(vmul_f32(vmul_f32(v13, v13), vmul_f32(v4, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v10 & 0xFFFFFF08FFFFFF08)), (int8x8_t)v11, (int8x8_t)vneg_f32(v11)))))* 0.25;
}

float snoise2(float a1, float a2)
{
  float v2 = (float)(a1 + a2) * 0.366025403;
  int v3 = (int)(float)(v2 + a1) - ((float)(v2 + a1) <= 0.0);
  int v4 = (int)(float)(v2 + a2) - ((float)(v2 + a2) <= 0.0);
  float v5 = (float)(v3 + v4) * 0.211324865;
  float v6 = a1 - (float)((float)v3 - v5);
  float v7 = a2 - (float)((float)v4 - v5);
  BOOL v8 = v6 > v7;
  BOOL v9 = v6 <= v7;
  float v10 = 0.0;
  float v11 = 1.0;
  if (v6 <= v7) {
    float v12 = 0.0;
  }
  else {
    float v12 = 1.0;
  }
  float v13 = (float)(v6 - v12) + 0.211324865;
  if (v6 > v7) {
    float v11 = 0.0;
  }
  float v14 = (float)(v7 - v11) + 0.211324865;
  double v15 = (float)(v6 + -1.0) + 0.42264973;
  double v16 = (float)(v7 + -1.0) + 0.42264973;
  float v17 = (float)(0.5 - (float)(v6 * v6)) - (float)(v7 * v7);
  float v18 = 0.0;
  if (v17 >= 0.0)
  {
    float v19 = (float)(v17 * v17) * (float)(v17 * v17);
    if ((perm[perm[v4] + (unint64_t)v3] & 4) != 0) {
      float v20 = v7;
    }
    else {
      float v20 = v6;
    }
    if ((perm[perm[v4] + (unint64_t)v3] & 4) == 0) {
      float v6 = v7;
    }
    float v21 = -v20;
    if ((perm[perm[v4] + (unint64_t)v3] & 1) == 0) {
      float v21 = v20;
    }
    float v22 = -2.0;
    if ((perm[perm[v4] + (unint64_t)v3] & 2) == 0) {
      float v22 = 2.0;
    }
    float v18 = v19 * (float)(v21 + (float)(v6 * v22));
  }
  float v23 = v15;
  float v25 = (float)(0.5 - (float)(v13 * v13)) - (float)(v14 * v14);
  if (v25 >= 0.0)
  {
    float v26 = (float)(v25 * v25) * (float)(v25 * v25);
    char v27 = perm[v3
             + v8
             + (unint64_t)perm[v4 + (unint64_t)v9]];
    if ((v27 & 4) != 0) {
      float v28 = v14;
    }
    else {
      float v28 = v13;
    }
    if ((v27 & 4) == 0) {
      float v13 = v14;
    }
    float v29 = -v28;
    if ((v27 & 1) == 0) {
      float v29 = v28;
    }
    float v30 = -2.0;
    if ((v27 & 2) == 0) {
      float v30 = 2.0;
    }
    float v10 = v26 * (float)(v29 + (float)(v13 * v30));
  }
  float v24 = v16;
  float v31 = (float)(0.5 - (float)(v23 * v23)) - (float)(v24 * v24);
  float v32 = 0.0;
  if (v31 >= 0.0)
  {
    float v33 = (float)(v31 * v31) * (float)(v31 * v31);
    char v34 = perm[v3 + 1 + (unint64_t)perm[v4 + 1]];
    if ((v34 & 4) != 0) {
      float v35 = v16;
    }
    else {
      float v35 = v23;
    }
    if ((v34 & 4) == 0) {
      float v23 = v16;
    }
    if (v34) {
      float v35 = -v35;
    }
    float v36 = -2.0;
    if ((v34 & 2) == 0) {
      float v36 = 2.0;
    }
    float v32 = v33 * (float)(v35 + (float)(v23 * v36));
  }
  return (float)((float)(v18 + v10) + v32) * 40.0;
}

float snoise3(float a1, float a2, float a3)
{
  float v3 = (float)((float)(a1 + a2) + a3) * 0.333333333;
  int v4 = (int)(float)(v3 + a1) - ((float)(v3 + a1) <= 0.0);
  int v5 = (int)(float)(v3 + a2) - ((float)(v3 + a2) <= 0.0);
  int v6 = (int)(float)(v3 + a3) - ((float)(v3 + a3) <= 0.0);
  float v7 = (float)(v4 + v5 + v6) * 0.166666667;
  float v8 = a1 - (float)((float)v4 - v7);
  float v9 = a2 - (float)((float)v5 - v7);
  float v10 = a3 - (float)((float)v6 - v7);
  if (v8 >= v9)
  {
    int v12 = 0;
    if (v9 < v10)
    {
      int v15 = 0;
      BOOL v11 = v8 >= v10;
      BOOL v14 = v8 < v10;
      BOOL v13 = 1;
      goto LABEL_6;
    }
    BOOL v14 = 0;
    BOOL v16 = 0;
    BOOL v11 = 1;
    BOOL v13 = 1;
  }
  else
  {
    BOOL v11 = 0;
    if (v9 < v10)
    {
      int v12 = 0;
      BOOL v13 = 0;
      BOOL v14 = 1;
      int v15 = 1;
LABEL_6:
      BOOL v16 = 1;
      goto LABEL_10;
    }
    BOOL v14 = 0;
    BOOL v13 = v8 >= v10;
    BOOL v16 = v8 < v10;
    int v12 = 1;
  }
  int v15 = 1;
LABEL_10:
  float v17 = (float)(v8 - (float)v11) + 0.166666667;
  float v18 = (float)(v9 - (float)v12) + 0.166666667;
  float v19 = (float)(v10 - (float)v14) + 0.166666667;
  double v20 = (float)(v8 - (float)v13) + 0.333333334;
  double v21 = (float)(v9 - (float)v15) + 0.333333334;
  double v22 = (float)(v10 - (float)v16) + 0.333333334;
  double v23 = (float)(v8 + -1.0);
  double v24 = (float)(v9 + -1.0);
  double v25 = (float)(v10 + -1.0);
  uint64_t v26 = ((int)(float)(v3 + a3) - ((float)(v3 + a3) <= 0.0));
  float v27 = (float)((float)(0.6 - (float)(v8 * v8)) - (float)(v9 * v9)) - (float)(v10 * v10);
  float v28 = 0.0;
  float v29 = 0.0;
  if (v27 >= 0.0)
  {
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 0xD) == 0xC)
      float v10 = v8;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 0xC) == 0)
      float v10 = v9;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 8) != 0)
      float v8 = v9;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 1) != 0)
      float v8 = -v8;
    float v30 = -v10;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 2) == 0)
      float v30 = v10;
    float v29 = (float)((float)(v27 * v27) * (float)(v27 * v27)) * (float)(v8 + v30);
  }
  double v31 = v23 + 0.500000001;
  double v32 = v24 + 0.500000001;
  double v33 = v25 + 0.500000001;
  float v34 = v20;
  float v35 = v21;
  float v36 = v22;
  float v37 = (float)((float)(0.6 - (float)(v17 * v17)) - (float)(v18 * v18)) - (float)(v19 * v19);
  if (v37 >= 0.0)
  {
    char v38 = perm[v11
             + v4
             + (unint64_t)perm[v12
                                                     + v5
                                                     + (unint64_t)perm[v14
                                                                                             + (unint64_t)v26]]];
    if ((v38 & 0xD) == 0xC) {
      float v19 = v17;
    }
    if ((v38 & 0xC) == 0) {
      float v19 = v18;
    }
    if ((v38 & 8) != 0) {
      float v17 = v18;
    }
    if (v38) {
      float v17 = -v17;
    }
    float v39 = -v19;
    if ((v38 & 2) == 0) {
      float v39 = v19;
    }
    float v28 = (float)((float)(v37 * v37) * (float)(v37 * v37)) * (float)(v17 + v39);
  }
  float v43 = (float)((float)(0.6 - (float)(v34 * v34)) - (float)(v35 * v35)) - (float)(v36 * v36);
  float v44 = 0.0;
  float v45 = 0.0;
  if (v43 >= 0.0)
  {
    char v46 = perm[v13
             + v4
             + (unint64_t)perm[v15
                                                     + v5
                                                     + (unint64_t)perm[v16
                                                                                             + (unint64_t)v26]]];
    if ((v46 & 0xD) == 0xC) {
      float v36 = v34;
    }
    if ((v46 & 0xC) == 0) {
      float v36 = v35;
    }
    if ((v46 & 8) != 0) {
      float v34 = v35;
    }
    if (v46) {
      float v34 = -v34;
    }
    float v47 = -v36;
    if ((v46 & 2) == 0) {
      float v47 = v36;
    }
    float v45 = (float)((float)(v43 * v43) * (float)(v43 * v43)) * (float)(v34 + v47);
  }
  float v40 = v31;
  float v41 = v32;
  float v42 = v33;
  float v48 = (float)((float)(0.6 - (float)(v40 * v40)) - (float)(v41 * v41)) - (float)(v42 * v42);
  if (v48 >= 0.0)
  {
    float v49 = (float)(v48 * v48) * (float)(v48 * v48);
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 0xD) == 0xC)
      float v50 = v31;
    else {
      float v50 = v33;
    }
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 0xC) == 0)
      float v50 = v32;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 8) != 0)
      float v51 = v32;
    else {
      float v51 = v31;
    }
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 1) != 0)
      float v51 = -v51;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 2) != 0)
      float v50 = -v50;
    float v44 = v49 * (float)(v51 + v50);
  }
  return (float)((float)((float)(v29 + v28) + v45) + v44) * 32.0;
}

float snoise4(float a1, float a2, float a3, float a4)
{
  float v4 = (float)((float)((float)(a1 + a2) + a3) + a4) * 0.309016994;
  int v5 = (int)(float)(v4 + a1) - ((float)(v4 + a1) <= 0.0);
  int v6 = (int)(float)(v4 + a2) - ((float)(v4 + a2) <= 0.0);
  int v7 = (int)(float)(v4 + a3) - ((float)(v4 + a3) <= 0.0);
  int v8 = (int)(float)(v4 + a4) - ((float)(v4 + a4) <= 0.0);
  float v9 = (double)(v5 + v6 + v7 + v8) * 0.138196601;
  float v10 = (float)v6 - v9;
  float v11 = (float)v7 - v9;
  float v12 = (float)v8 - v9;
  float v13 = a1 - (float)((float)v5 - v9);
  float v14 = a4 - v12;
  float v15 = a2 - v10;
  BOOL v16 = v13 > (float)(a2 - v10);
  float v17 = a3 - v11;
  uint64_t v18 = (16 * (v13 > (float)(a3 - v11))) | (32 * v16) | (8 * (v15 > v17)) | (4 * (v13 > v14)) | (2 * (v15 > v14)) | (v17 > v14);
  unsigned int v19 = simplex[4 * v18];
  BOOL v20 = v19 > 2;
  unint64_t v21 = (0xC4008C00uLL >> v18) & 1;
  unint64_t v22 = (0xA20000008AuLL >> v18) & 1;
  unint64_t v23 = (0x101000101000101uLL >> v18) & 1;
  float v24 = 0.0;
  float v25 = 1.0;
  if (v19 <= 2) {
    float v26 = 0.0;
  }
  else {
    float v26 = 1.0;
  }
  BOOL v27 = v19 > 1;
  unint64_t v28 = (0xC0000000C5008D88 >> v18) & 1;
  unint64_t v29 = (0xA000A30000888BuLL >> v18) & 1;
  unint64_t v30 = (0x1111000305000503uLL >> v18) & 1;
  if (v19 <= 1) {
    float v31 = 0.0;
  }
  else {
    float v31 = 1.0;
  }
  BOOL v39 = v19 == 0;
  BOOL v32 = v19 != 0;
  if (v39) {
    float v33 = 0.0;
  }
  else {
    float v33 = 1.0;
  }
  BOOL v39 = ((0x2E7FFF7F3AFF7274uLL >> v18) & 1) == 0;
  BOOL v34 = v39;
  if (v39) {
    float v35 = 1.0;
  }
  else {
    float v35 = 0.0;
  }
  BOOL v39 = ((0x7F4EFF5C7FFF7274uLL >> v18) & 1) == 0;
  BOOL v36 = v39;
  unint64_t v37 = 0xAECEFFDCBAFFF2F4 >> v18;
  if (v39) {
    float v38 = 1.0;
  }
  else {
    float v38 = 0.0;
  }
  BOOL v39 = (v37 & 1) == 0;
  float v40 = (float)(v13 - v26) + 0.138196601;
  float v41 = (float)(v15 - (float)(int)v21) + 0.138196601;
  float v42 = (float)(v17 - (float)(int)v22) + 0.138196601;
  float v43 = (float)(v14 - (float)(int)v23) + 0.138196601;
  double v44 = (float)(v13 - v31) + 0.276393202;
  double v45 = (float)(v15 - (float)(int)v28) + 0.276393202;
  double v46 = (float)(v17 - (float)(int)v29) + 0.276393202;
  double v47 = (float)(v14 - (float)(int)v30) + 0.276393202;
  double v48 = (float)(v13 - v33);
  double v49 = (float)(v15 - v35);
  double v50 = (float)(v17 - v38);
  if (!v39) {
    float v25 = 0.0;
  }
  double v51 = (float)(v14 - v25);
  float v52 = v13 + -1.0;
  float v53 = v15 + -1.0;
  float v54 = v17 + -1.0;
  float v55 = v14 + -1.0;
  float v56 = (float)((float)((float)(0.6 - (float)(v13 * v13)) - (float)(v15 * v15)) - (float)(v17 * v17))
      - (float)(v14 * v14);
  float v57 = 0.0;
  if (v56 >= 0.0)
  {
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x1Fu) >= 0x18)
      float v13 = v15;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x10) != 0)
      float v15 = v17;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x18) == 0)
      float v14 = v17;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 1) != 0)
      float v13 = -v13;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 2) != 0)
      float v15 = -v15;
    float v58 = v13 + v15;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 4) != 0)
      float v14 = -v14;
    float v57 = (float)((float)(v56 * v56) * (float)(v56 * v56)) * (float)(v14 + v58);
  }
  double v59 = v48 + 0.414589803;
  double v60 = v49 + 0.414589803;
  double v61 = v50 + 0.414589803;
  double v62 = v51 + 0.414589803;
  float v63 = v44;
  float v64 = v45;
  float v65 = v46;
  float v66 = v47;
  float v67 = (float)((float)((float)(0.6 - (float)(v40 * v40)) - (float)(v41 * v41)) - (float)(v42 * v42))
      - (float)(v43 * v43);
  if (v67 >= 0.0)
  {
    char v68 = perm[v5
             + v20
             + (unint64_t)perm[v21
                                                     + v6
                                                     + (unint64_t)perm[v22
                                                                                             + v7
                                                                                             + (unint64_t)perm[v23 + v8]]]];
    if ((v68 & 0x1Fu) >= 0x18) {
      float v40 = v41;
    }
    if ((v68 & 0x10) != 0) {
      float v41 = v42;
    }
    if ((v68 & 0x18) != 0) {
      float v42 = v43;
    }
    if (v68) {
      float v40 = -v40;
    }
    if ((v68 & 2) != 0) {
      float v41 = -v41;
    }
    float v69 = v40 + v41;
    float v70 = -v42;
    if ((v68 & 4) == 0) {
      float v70 = v42;
    }
    float v24 = (float)((float)(v67 * v67) * (float)(v67 * v67)) * (float)(v70 + v69);
  }
  double v71 = v52 + 0.552786404;
  double v72 = v53 + 0.552786404;
  double v73 = v54 + 0.552786404;
  double v74 = v55 + 0.552786404;
  float v75 = v59;
  float v76 = v60;
  float v77 = v61;
  float v79 = (float)((float)((float)(0.6 - (float)(v63 * v63)) - (float)(v64 * v64)) - (float)(v65 * v65))
      - (float)(v66 * v66);
  float v80 = 0.0;
  float v81 = 0.0;
  if (v79 >= 0.0)
  {
    char v82 = perm[v5
             + v27
             + (unint64_t)perm[v28
                                                     + v6
                                                     + (unint64_t)perm[v29
                                                                                             + v7
                                                                                             + (unint64_t)perm[v30 + v8]]]];
    if ((v82 & 0x1Fu) >= 0x18) {
      float v63 = v64;
    }
    if ((v82 & 0x10) != 0) {
      float v64 = v65;
    }
    if ((v82 & 0x18) != 0) {
      float v65 = v66;
    }
    float v83 = -v63;
    if ((v82 & 1) == 0) {
      float v83 = v63;
    }
    if ((v82 & 2) != 0) {
      float v64 = -v64;
    }
    float v84 = v83 + v64;
    if ((v82 & 4) != 0) {
      float v65 = -v65;
    }
    float v81 = (float)((float)(v79 * v79) * (float)(v79 * v79)) * (float)(v65 + v84);
  }
  float v85 = v71;
  float v86 = v72;
  float v87 = v73;
  float v78 = v62;
  float v89 = (float)((float)((float)(0.6 - (float)(v75 * v75)) - (float)(v76 * v76)) - (float)(v77 * v77))
      - (float)(v78 * v78);
  if (v89 >= 0.0)
  {
    char v90 = perm[v5
             + v32
             + (unint64_t)perm[v6
                                                     + v34
                                                     + (unint64_t)perm[v7
                                                                                             + v36
                                                                                             + (unint64_t)perm[v8 + (unint64_t)v39]]]];
    if ((v90 & 0x1Fu) >= 0x18) {
      float v75 = v60;
    }
    if ((v90 & 0x10) != 0) {
      float v76 = v61;
    }
    if ((v90 & 0x18) != 0) {
      float v77 = v62;
    }
    float v91 = -v75;
    if ((v90 & 1) == 0) {
      float v91 = v75;
    }
    if ((v90 & 2) != 0) {
      float v76 = -v76;
    }
    float v92 = v91 + v76;
    if ((v90 & 4) != 0) {
      float v77 = -v77;
    }
    float v80 = (float)((float)(v89 * v89) * (float)(v89 * v89)) * (float)(v77 + v92);
  }
  float v88 = v74;
  float v93 = (float)((float)((float)(0.6 - (float)(v85 * v85)) - (float)(v86 * v86)) - (float)(v87 * v87))
      - (float)(v88 * v88);
  float v94 = 0.0;
  if (v93 >= 0.0)
  {
    float v95 = (float)(v93 * v93) * (float)(v93 * v93);
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x1Fu) >= 0x18)
      float v96 = v72;
    else {
      float v96 = v85;
    }
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x10) != 0)
      float v86 = v73;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x18) != 0)
      float v87 = v74;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 1) != 0)
      float v96 = -v96;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 2) != 0)
      float v86 = -v86;
    float v97 = v96 + v86;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 4) != 0)
      float v87 = -v87;
    float v94 = v95 * (float)(v87 + v97);
  }
  return (float)((float)((float)((float)(v57 + v24) + v81) + v80) + v94) * 27.0;
}

uint64_t b2CollideCircles(uint64_t result, float *a2, float *a3, float *a4, float *a5)
{
  float v6 = a3[2];
  float v5 = a3[3];
  float v8 = a2[4];
  float v7 = a2[5];
  float v9 = a2[3];
  float v10 = *a3 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  float v11 = (float)((float)(v5 * v7) + (float)(v6 * v8)) + a3[1];
  float v13 = a5[2];
  float v12 = a5[3];
  float v15 = a4[4];
  float v14 = a4[5];
  float v16 = a4[3];
  *(_DWORD *)(result + 60) = 0;
  if ((float)((float)((float)((float)((float)((float)(v12 * v14) + (float)(v13 * v15)) + a5[1]) - v11)
                     * (float)((float)((float)((float)(v12 * v14) + (float)(v13 * v15)) + a5[1]) - v11))
             + (float)((float)((float)(*a5 + (float)((float)(v12 * v15) - (float)(v13 * v14))) - v10)
                     * (float)((float)(*a5 + (float)((float)(v12 * v15) - (float)(v13 * v14))) - v10))) <= (float)((float)(v9 + v16) * (float)(v9 + v16)))
  {
    *(_DWORD *)(result + 56) = 0;
    uint64_t v17 = *((void *)a2 + 2);
    *(void *)(result + 40) = 0;
    *(void *)(result + 48) = v17;
    *(_DWORD *)(result + 60) = 1;
    *(void *)double result = *((void *)a4 + 2);
    *(_DWORD *)(result + 16) = 0;
  }
  return result;
}

float b2CollidePolygonAndCircle(uint64_t a1, uint64_t a2, float *a3, float *a4, float *a5)
{
  float v6 = a5[2];
  float v5 = a5[3];
  float v8 = a4[4];
  float v7 = a4[5];
  float v9 = a4[3];
  float v10 = a5[1];
  float v11 = *a5 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  *(_DWORD *)(a1 + 60) = 0;
  float v12 = v11 - *a3;
  float v13 = (float)((float)((float)(v5 * v7) + (float)(v6 * v8)) + v10) - a3[1];
  float v15 = a3[2];
  float v14 = a3[3];
  float v16 = (float)(v13 * v15) + (float)(v14 * v12);
  float v17 = (float)(v14 * v13) - (float)(v15 * v12);
  float result = *(float *)(a2 + 12) + v9;
  uint64_t v19 = *(void *)(a2 + 16);
  unint64_t v20 = *(void *)(a2 + 24) - v19;
  unint64_t v21 = v20 >> 3;
  uint64_t v22 = *(void *)(a2 + 40);
  if ((int)(v20 >> 3) < 1)
  {
    int v24 = 0;
    BOOL v30 = 1;
LABEL_9:
    if (v24 + 1 < (int)v21) {
      int v31 = v24 + 1;
    }
    else {
      int v31 = 0;
    }
    uint64_t v32 = v24;
    float v33 = (float *)(v19 + 8 * v24);
    float v34 = *v33;
    float v35 = v33[1];
    float v36 = *v33;
    unint64_t v37 = (float *)(v19 + 8 * v31);
    float v38 = *v37;
    float v39 = v37[1];
    if (v30)
    {
      *(void *)(a1 + 56) = 0x100000001;
      *(void *)(a1 + 40) = *(void *)(v22 + 8 * v32);
      float result = (float)(v36 + v38) * 0.5;
      *(float *)(a1 + 48) = result;
      *(float *)(a1 + 52) = (float)(v35 + v39) * 0.5;
    }
    else
    {
      float v40 = v16 - v36;
      float v41 = v17 - v35;
      if ((float)((float)((float)(v17 - v35) * (float)(v39 - v35)) + (float)((float)(v16 - v36) * (float)(v38 - v36))) <= 0.0)
      {
        float v46 = (float)(v41 * v41) + (float)(v40 * v40);
        float result = result * result;
        if (v46 > result) {
          return result;
        }
        *(void *)(a1 + 56) = 0x100000001;
        *(float *)(a1 + 40) = v40;
        *(float *)(a1 + 44) = v41;
        float result = sqrtf(v46);
        if (result >= 0.00000011921)
        {
          float v47 = 1.0 / result;
          float v48 = v40 * v47;
          float result = v41 * v47;
          *(float *)(a1 + 40) = v48;
          *(float *)(a1 + 44) = result;
        }
        *(float *)(a1 + 48) = v34;
        *(float *)(a1 + 52) = v35;
      }
      else
      {
        float v42 = v16 - v38;
        float v43 = v17 - v39;
        if ((float)((float)((float)(v17 - v39) * (float)(v35 - v39)) + (float)((float)(v16 - v38) * (float)(v36 - v38))) <= 0.0)
        {
          float v49 = (float)(v43 * v43) + (float)(v42 * v42);
          float result = result * result;
          if (v49 > result) {
            return result;
          }
          *(void *)(a1 + 56) = 0x100000001;
          *(float *)(a1 + 40) = v42;
          *(float *)(a1 + 44) = v43;
          float result = sqrtf(v49);
          if (result >= 0.00000011921)
          {
            float v50 = 1.0 / result;
            float v51 = v42 * v50;
            float result = v43 * v50;
            *(float *)(a1 + 40) = v51;
            *(float *)(a1 + 44) = result;
          }
          *(float *)(a1 + 48) = v38;
          *(float *)(a1 + 52) = v39;
        }
        else
        {
          float v44 = (float)(v36 + v38) * 0.5;
          double v45 = (float *)(v22 + 8 * v32);
          if ((float)((float)((float)(v17 - (float)((float)(v35 + v39) * 0.5)) * v45[1])
                     + (float)((float)(v16 - v44) * *v45)) > result)
            return result;
          LODWORD(result) = 1;
          *(void *)(a1 + 56) = 0x100000001;
          *(void *)(a1 + 40) = *(void *)v45;
          *(float *)(a1 + 48) = v44;
          *(float *)(a1 + 52) = (float)(v35 + v39) * 0.5;
        }
      }
    }
    *(void *)a1 = *((void *)a4 + 2);
    *(_DWORD *)(a1 + 16) = 0;
    return result;
  }
  uint64_t v23 = 0;
  int v24 = 0;
  uint64_t v25 = (v20 >> 3);
  float v26 = (float *)(v19 + 4);
  BOOL v27 = (float *)(v22 + 4);
  float v28 = -3.4028e38;
  while (1)
  {
    float v29 = (float)((float)(v17 - *v26) * *v27) + (float)(*(v27 - 1) * (float)(v16 - *(v26 - 1)));
    if (v29 > result) {
      return result;
    }
    if (v29 > v28)
    {
      int v24 = v23;
      float v28 = (float)((float)(v17 - *v26) * *v27) + (float)(*(v27 - 1) * (float)(v16 - *(v26 - 1)));
    }
    ++v23;
    v26 += 2;
    v27 += 2;
    if (v25 == v23)
    {
      BOOL v30 = v28 < 0.00000011921;
      goto LABEL_9;
    }
  }
}

uint64_t b2CollideEdgeAndCircle(uint64_t result, uint64_t a2, float *a3, float *a4, float *a5)
{
  *(_DWORD *)(result + 60) = 0;
  float v6 = a5[2];
  float v5 = a5[3];
  float v8 = a4[4];
  float v7 = a4[5];
  float v9 = *a5 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  float v10 = (float)((float)(v5 * v7) + (float)(v6 * v8)) + a5[1];
  float v11 = v9 - *a3;
  float v12 = v10 - a3[1];
  float v14 = a3[2];
  float v13 = a3[3];
  float v15 = (float)(v12 * v14) + (float)(v13 * v11);
  float v16 = (float)(v13 * v12) - (float)(v14 * v11);
  float v17 = *(float *)(a2 + 20);
  float v18 = *(float *)(a2 + 24);
  float v19 = *(float *)(a2 + 28);
  float v20 = *(float *)(a2 + 16);
  float v21 = v18 - v20;
  float v22 = v19 - v17;
  float v23 = v15 - v20;
  float v24 = v16 - v17;
  float v25 = (float)((float)(v16 - v17) * (float)(v19 - v17)) + (float)((float)(v18 - v20) * (float)(v15 - v20));
  float v26 = *(float *)(a2 + 12) + a4[3];
  if (v25 <= 0.0)
  {
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) > (float)(v26 * v26)) {
      return result;
    }
    uint64_t v33 = *(unsigned int *)(a2 + 20);
    float v22 = 0.0;
    if (*(unsigned char *)(a2 + 48))
    {
      if ((float)((float)((float)(v17 - v16) * (float)(v17 - *(float *)(a2 + 36)))
                 + (float)((float)(v20 - *(float *)(a2 + 32)) * (float)(v20 - v15))) > 0.0)
        return result;
    }
    int v35 = 0;
    float v31 = 0.0;
LABEL_19:
    *(_DWORD *)(result + 60) = 1;
    *(float *)(result + 40) = v22;
    *(float *)(result + 44) = v31;
    *(float *)(result + 48) = v20;
    *(void *)(result + 52) = v33;
    *(_DWORD *)(result + 16) = v35;
    *(void *)float result = *((void *)a4 + 2);
    return result;
  }
  float v27 = (float)(v22 * (float)(v19 - v16)) + (float)(v21 * (float)(v18 - v15));
  if (v27 <= 0.0)
  {
    float v36 = v15 - v18;
    float v37 = v16 - v19;
    if ((float)((float)(v37 * v37) + (float)(v36 * v36)) > (float)(v26 * v26)) {
      return result;
    }
    uint64_t v33 = *(unsigned int *)(a2 + 28);
    float v22 = 0.0;
    if (*(unsigned char *)(a2 + 49))
    {
      if ((float)((float)(v37 * (float)(*(float *)(a2 + 44) - v19)) + (float)((float)(*(float *)(a2 + 40) - v18) * v36)) > 0.0) {
        return result;
      }
    }
    int v35 = 1;
    float v31 = 0.0;
    float v20 = *(float *)(a2 + 24);
    goto LABEL_19;
  }
  float v28 = (float)(v22 * v22) + (float)(v21 * v21);
  if (v28 <= 0.0) {
    b2CollideEdgeAndCircle();
  }
  float v29 = 1.0 / v28;
  float v30 = v15 - (float)(v29 * (float)((float)(v27 * v20) + (float)(v25 * v18)));
  if ((float)((float)((float)(v16 - (float)(v29 * (float)((float)(v27 * v17) + (float)(v25 * v19))))
                     * (float)(v16 - (float)(v29 * (float)((float)(v27 * v17) + (float)(v25 * v19)))))
             + (float)(v30 * v30)) <= (float)(v26 * v26))
  {
    if ((float)((float)(v24 * v21) - (float)(v22 * v23)) < 0.0)
    {
      float v31 = -v21;
    }
    else
    {
      float v22 = -v22;
      float v31 = v21;
    }
    float v32 = sqrtf((float)(v31 * v31) + (float)(v22 * v22));
    HIDWORD(v33) = 1;
    LODWORD(v33) = *(_DWORD *)(a2 + 20);
    if (v32 >= 0.00000011921)
    {
      float v34 = 1.0 / v32;
      float v22 = v22 * v34;
      float v31 = v31 * v34;
    }
    int v35 = 0x10000;
    goto LABEL_19;
  }
  return result;
}

uint64_t b2EPCollider::Collide(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3, float *a4, uint64_t a5, float *a6)
{
  uint64_t v148 = *MEMORY[0x263EF8340];
  float v10 = a4[2];
  float v9 = a4[3];
  float v11 = a6[2];
  float v12 = a6[3];
  float32_t v13 = (float)(v9 * v11) - (float)(v10 * v12);
  float32_t v14 = (float)(v11 * v10) + (float)(v9 * v12);
  float v15 = *a6 - *a4;
  float v16 = a6[1] - a4[1];
  float32_t v17 = (float)(v10 * v16) + (float)(v9 * v15);
  float32_t v18 = (float)(v9 * v16) - (float)(v10 * v15);
  a1[6].f32[0] = v17;
  a1[6].f32[1] = v18;
  a1[7].f32[0] = v13;
  a1[7].f32[1] = v14;
  float v19 = *(float *)(a5 + 64);
  float v20 = *(float *)(a5 + 68);
  float v21 = v17 + (float)((float)(v14 * v19) - (float)(v13 * v20));
  float v22 = v18 + (float)((float)(v14 * v20) + (float)(v13 * v19));
  a1[8].f32[0] = v21;
  a1[8].f32[1] = v22;
  float32x2_t v23 = a3[4];
  a1[9] = v23;
  float32x2_t v24 = a3[2];
  a1[10] = v24;
  float32x2_t v25 = a3[3];
  a1[11] = v25;
  float32x2_t v26 = a3[5];
  a1[12] = v26;
  uint64_t v27 = HIDWORD(*(void *)&v25);
  float v28 = v25.f32[0];
  uint64_t v29 = HIDWORD(*(void *)&v24);
  float v30 = v24.f32[0];
  int v31 = a3[6].u8[0];
  float v32 = v28 - v30;
  float v33 = *(float *)&v29;
  float v34 = *(float *)&v27 - *(float *)&v29;
  float v35 = sqrtf((float)(v34 * v34) + (float)(v32 * v32));
  if (v35 >= 0.00000011921)
  {
    float v36 = 1.0 / v35;
    float v32 = v32 * v36;
    float v34 = v34 * v36;
  }
  int v37 = a3[6].u8[1];
  a1[14].f32[0] = v34;
  a1[14].f32[1] = -v32;
  float v38 = (float)(v34 * (float)(v21 - v30)) - (float)(v32 * (float)(v22 - v33));
  if (!v31)
  {
    if (!v37)
    {
      a1[20].i8[4] = v38 >= 0.0;
      if (v38 >= 0.0)
      {
        uint64_t v62 = (uint64_t)a1[14];
        a1[16] = (float32x2_t)v62;
        v63.i64[0] = v62;
        v63.i64[1] = v62;
        float32x4_t v64 = vnegq_f32(v63);
        goto LABEL_78;
      }
      a1[16].f32[0] = -v34;
      a1[16].f32[1] = v32;
      float32x2_t v59 = a1[14];
LABEL_71:
      a1[18] = v59;
      goto LABEL_75;
    }
    v23.i32[0] = 0;
    float v45 = 0.0;
LABEL_14:
    float v49 = v26.f32[0] - v28;
    float v50 = v26.f32[1] - *(float *)&v27;
    float v51 = sqrtf((float)(v50 * v50) + (float)(v49 * v49));
    if (v51 >= 0.00000011921)
    {
      float v52 = 1.0 / v51;
      float v49 = v49 * v52;
      float v50 = v50 * v52;
    }
    a1[15].f32[0] = v50;
    a1[15].f32[1] = -v49;
    float v53 = -v34;
    float v54 = (float)(v32 * v50) - (float)(v34 * v49);
    float v55 = (float)(v50 * (float)(v21 - v28)) - (float)(v49 * (float)(v22 - *(float *)&v27));
    if (!v31)
    {
      if (v54 <= 0.0)
      {
        BOOL v70 = v38 >= 0.0;
        if (v55 < 0.0) {
          BOOL v70 = 0;
        }
        a1[20].i8[4] = v70;
        if (v70)
        {
          float32x2_t v59 = a1[14];
          a1[16] = v59;
          a1[18].i32[0] = v59.i32[0] ^ 0x80000000;
          a1[18].i32[1] = v59.i32[1] ^ 0x80000000;
LABEL_75:
          a1[19] = v59;
          goto LABEL_79;
        }
        a1[16].f32[0] = v53;
        a1[16].f32[1] = v32;
        a1[18].f32[0] = -v50;
        a1[18].f32[1] = v49;
      }
      else
      {
        BOOL v65 = v38 >= 0.0;
        if (v55 >= 0.0) {
          BOOL v65 = 1;
        }
        a1[20].i8[4] = v65;
        if (v65)
        {
          float32x2_t v66 = a1[14];
          float32x2_t v67 = a1[15];
          a1[16] = v66;
          a1[18].i32[0] = v66.i32[0] ^ 0x80000000;
          a1[18].i32[1] = v66.i32[1] ^ 0x80000000;
          a1[19] = v67;
          goto LABEL_79;
        }
        a1[16].f32[0] = v53;
        a1[16].f32[1] = v32;
        a1[18].f32[0] = v53;
        a1[18].f32[1] = v32;
      }
      float32x2_t v59 = a1[14];
      goto LABEL_75;
    }
    if (v54 > 0.0) {
      __int32 v56 = v23.i32[0];
    }
    else {
      __int32 v56 = 0;
    }
    if (v56 == 1)
    {
      BOOL v57 = v45 >= 0.0;
      if (v38 >= 0.0) {
        BOOL v57 = 1;
      }
      if (v55 >= 0.0) {
        BOOL v57 = 1;
      }
      a1[20].i8[4] = v57;
      if (v57)
      {
        float32x2_t v58 = a1[13];
        a1[16] = a1[14];
        float32x2_t v59 = a1[15];
LABEL_64:
        a1[18] = v58;
        goto LABEL_75;
      }
      a1[16].f32[0] = v53;
      a1[16].f32[1] = v32;
      a1[18].f32[0] = v53;
      a1[18].f32[1] = v32;
LABEL_50:
      a1[19].f32[0] = v53;
      a1[19].f32[1] = v32;
      goto LABEL_79;
    }
    if (v23.i32[0])
    {
      if (v45 >= 0.0)
      {
        a1[20].i8[4] = 1;
      }
      else
      {
        BOOL v61 = v38 >= 0.0;
        if (v55 < 0.0) {
          BOOL v61 = 0;
        }
        a1[20].i8[4] = v61;
        if (!v61)
        {
          a1[16].f32[0] = v53;
          a1[16].f32[1] = v32;
          a1[18].f32[0] = -v50;
          a1[18].f32[1] = v49;
          goto LABEL_50;
        }
      }
      float32x2_t v58 = a1[13];
      float32x2_t v59 = a1[14];
      a1[16] = v59;
      goto LABEL_64;
    }
    if (v54 > 0.0)
    {
      if (v55 >= 0.0)
      {
        a1[20].i8[4] = 1;
      }
      else
      {
        BOOL v69 = v45 >= 0.0;
        if (v38 < 0.0) {
          BOOL v69 = 0;
        }
        a1[20].i8[4] = v69;
        if (!v69)
        {
          a1[16].f32[0] = v53;
          a1[16].f32[1] = v32;
          a1[18].f32[0] = v53;
          a1[18].f32[1] = v32;
LABEL_48:
          a1[19] = vneg_f32(a1[13]);
          goto LABEL_79;
        }
      }
      float32x4_t v64 = *(float32x4_t *)a1[14].f32;
      a1[16] = *(float32x2_t *)v64.f32;
LABEL_78:
      *(float32x4_t *)a1[18].f32 = v64;
      goto LABEL_79;
    }
    BOOL v71 = v45 >= 0.0;
    if (v38 < 0.0) {
      BOOL v71 = 0;
    }
    if (v55 < 0.0) {
      BOOL v71 = 0;
    }
    a1[20].i8[4] = v71;
    if (!v71)
    {
      a1[16].f32[0] = v53;
      a1[16].f32[1] = v32;
      a1[18].f32[0] = -v50;
      a1[18].f32[1] = v49;
      goto LABEL_48;
    }
    float32x2_t v59 = a1[14];
    a1[16] = v59;
    goto LABEL_71;
  }
  float v39 = v23.f32[0];
  float v40 = v30 - v23.f32[0];
  float v41 = v33 - v23.f32[1];
  float v42 = sqrtf((float)(v41 * v41) + (float)(v40 * v40));
  if (v42 >= 0.00000011921)
  {
    float v43 = 1.0 / v42;
    float v40 = v40 * v43;
    float v41 = v41 * v43;
  }
  a1[13].f32[0] = v41;
  a1[13].f32[1] = -v40;
  float v44 = (float)(v40 * v34) - (float)(v41 * v32);
  v23.i32[0] = v44 >= 0.0;
  float v45 = (float)(v41 * (float)(v21 - v39)) - (float)(v40 * (float)(v22 - v23.f32[1]));
  if (v37) {
    goto LABEL_14;
  }
  if (v44 < 0.0)
  {
    BOOL v60 = v45 >= 0.0;
    if (v38 < 0.0) {
      BOOL v60 = 0;
    }
    a1[20].i8[4] = v60;
    if (v60)
    {
      float32x2_t v47 = a1[14];
      a1[16] = v47;
      a1[18] = v47;
      goto LABEL_32;
    }
    a1[16].f32[0] = -v34;
    a1[16].f32[1] = v32;
    a1[18] = a1[14];
    goto LABEL_48;
  }
  BOOL v46 = v45 >= 0.0;
  if (v38 >= 0.0) {
    BOOL v46 = 1;
  }
  a1[20].i8[4] = v46;
  if (v46)
  {
    float32x2_t v48 = a1[13];
    float32x2_t v47 = a1[14];
    a1[16] = v47;
    a1[18] = v48;
LABEL_32:
    a1[19].i32[0] = v47.i32[0] ^ 0x80000000;
    a1[19].i32[1] = v47.i32[1] ^ 0x80000000;
    goto LABEL_79;
  }
  a1[16].f32[0] = -v34;
  a1[16].f32[1] = v32;
  float32x2_t v68 = a1[14];
  a1[18] = v68;
  a1[19].i32[0] = v68.i32[0] ^ 0x80000000;
  a1[19].f32[1] = v32;
LABEL_79:
  uint64_t v72 = *(void *)(a5 + 24) - *(void *)(a5 + 16);
  std::vector<b2Vec2>::resize((uint64_t)a1, (int)(v72 >> 3));
  std::vector<b2Vec2>::resize((uint64_t)&a1[3], (int)(v72 >> 3));
  uint64_t v73 = *(void *)(a5 + 16);
  unint64_t v74 = *(void *)(a5 + 24) - v73;
  if ((int)(v74 >> 3) >= 1)
  {
    float v75 = (float32x2_t *)*a1;
    uint64_t v76 = (v74 >> 3);
    float v77 = (float *)(v73 + 4);
    float v78 = (float *)(*(void *)(a5 + 40) + 4);
    float v79 = (float *)(*(void *)&a1[3] + 4);
    do
    {
      float32x2_t v80 = a1[7];
      float32x2_t v81 = (float32x2_t)vrev64_s32((int32x2_t)v80);
      v80.f32[0] = -v80.f32[0];
      *v75++ = vadd_f32(a1[6], vmla_n_f32(vmul_n_f32(v80, *v77), v81, *(v77 - 1)));
      float v82 = *(v78 - 1);
      float v83 = a1[7].f32[0];
      v80.i32[0] = a1[7].i32[1];
      float v84 = (float)(v80.f32[0] * v82) - (float)(v83 * *v78);
      float v85 = (float)(v80.f32[0] * *v78) + (float)(v83 * v82);
      *(v79 - 1) = v84;
      *float v79 = v85;
      v77 += 2;
      v78 += 2;
      v79 += 2;
      --v76;
    }
    while (v76);
  }
  a1[20].i32[0] = 1016296636;
  a2[7].i32[1] = 0;
  uint64_t result = b2EPCollider::ComputeEdgeSeparation((b2EPCollider *)a1);
  uint64_t v88 = result;
  if (result)
  {
    float v89 = v87;
    if (v87 <= 0.018)
    {
      uint64_t result = b2EPCollider::ComputePolygonSeparation((b2EPCollider *)a1);
      if (result)
      {
        if (v90 > 0.018) {
          return result;
        }
        float v91 = (float)(v89 * 0.98) + 0.001;
        if (v91 >= v90) {
          uint64_t v92 = v88;
        }
        else {
          uint64_t v92 = result;
        }
        if (v91 < v90) {
          LODWORD(v88) = result;
        }
      }
      else
      {
        uint64_t v92 = v88;
      }
      if (v88 == 1)
      {
        a2[7].i32[0] = 1;
        float v93 = (float *)a1[3];
        uint64_t v94 = *(void *)&a1[4] - (void)v93;
        unint64_t v95 = v94 >> 3;
        if ((unint64_t)v94 < 9)
        {
          int v96 = 0;
        }
        else
        {
          int v96 = 0;
          float v97 = a1[16].f32[0];
          float v98 = a1[16].f32[1];
          float v100 = *v93;
          float v101 = v93[1];
          unint64_t v99 = v93 + 3;
          float v102 = (float)(v98 * v101) + (float)(v97 * v100);
          uint64_t v103 = 2;
          if (v95 > 2) {
            uint64_t v103 = v95;
          }
          for (uint64_t i = 1; i != v103; ++i)
          {
            float v105 = v98 * *v99;
            if ((float)(v105 + (float)(v97 * *(v99 - 1))) < v102)
            {
              int v96 = i;
              float v102 = v105 + (float)(v97 * *(v99 - 1));
            }
            v99 += 2;
          }
        }
        if (v95 > v96 + 1) {
          int v113 = v96 + 1;
        }
        else {
          int v113 = 0;
        }
        float32x2_t v114 = *a1;
        float32x2_t v140 = *(float32x2_t *)(*(void *)a1 + 8 * v96);
        char v141 = 0;
        char v142 = v96;
        __int16 v143 = 1;
        float32x2_t v144 = *(float32x2_t *)(*(void *)&v114 + 8 * v113);
        char v145 = 0;
        char v146 = v113;
        __int16 v147 = 1;
        if (!a1[20].i8[4])
        {
          uint64_t v131 = 1;
          float32x2_t v111 = a1[10];
          float32x2_t v110 = a1[11];
          float32x2_t v132 = v110;
          float v116 = -a1[14].f32[0];
          float v115 = -a1[14].f32[1];
          v133.f32[0] = v116;
          v133.f32[1] = v115;
          LOBYTE(v106) = 1;
          goto LABEL_113;
        }
        LOBYTE(v106) = 0;
        uint64_t v131 = 0x100000000;
        float32x2_t v110 = a1[10];
        float32x2_t v111 = a1[11];
        float32x2_t v132 = v110;
        float32x2_t v112 = a1[14];
      }
      else
      {
        unint64_t v106 = HIDWORD(v92);
        a2[7].i32[0] = 2;
        float32x2_t v107 = a1[11];
        float32x2_t v140 = a1[10];
        char v141 = 0;
        char v142 = BYTE4(v92);
        __int16 v143 = 256;
        float32x2_t v144 = v107;
        char v145 = 0;
        char v146 = BYTE4(v92);
        __int16 v147 = 256;
        if (HIDWORD(v92) + 1 < (int)((unint64_t)v72 >> 3)) {
          int v108 = HIDWORD(v92) + 1;
        }
        else {
          int v108 = 0;
        }
        LODWORD(v131) = HIDWORD(v92);
        BYTE4(v131) = v108;
        uint64_t v109 = v92 >> 32;
        float32x2_t v110 = *(float32x2_t *)(*(void *)a1 + 8 * (v92 >> 32));
        float32x2_t v132 = v110;
        float32x2_t v111 = *(float32x2_t *)(*(void *)a1 + 8 * v108);
        float32x2_t v112 = *(float32x2_t *)(*(void *)&a1[3] + 8 * v109);
      }
      float32x2_t v133 = v112;
      float v115 = v112.f32[1];
      float v116 = v112.f32[0];
LABEL_113:
      v134[0] = v115;
      v134[1] = -v116;
      float v135 = (float)(v115 * v110.f32[0]) - (float)(v116 * v110.f32[1]);
      v136[0] = -v115;
      v136[1] = v116;
      float v137 = (float)(v116 * v111.f32[1]) - (float)(v115 * v111.f32[0]);
      uint64_t result = b2ClipSegmentToLine((uint64_t)v139, (uint64_t *)&v140, v134, v106, v135);
      if ((int)result >= 2)
      {
        uint64_t result = b2ClipSegmentToLine((uint64_t)v138, v139, v136, SBYTE4(v131), v137);
        if ((int)result >= 2)
        {
          if (v88 == 1)
          {
            float32x2_t v118 = v132;
            a2[5] = v133;
          }
          else
          {
            a2[5] = *(float32x2_t *)(*(void *)(a5 + 40) + 8 * (int)v131);
            float32x2_t v118 = *(float32x2_t *)(*(void *)(a5 + 16) + 8 * (int)v131);
          }
          uint64_t v119 = 0;
          int v120 = 0;
          a2[6] = v118;
          char v121 = 1;
          do
          {
            char v122 = v121;
            v123 = (float *)&v138[3 * v119];
            float v124 = v123[1];
            if ((float)((float)((float)(v124 - v132.f32[1]) * v133.f32[1])
                       + (float)(v133.f32[0] * (float)(*v123 - v132.f32[0]))) <= a1[20].f32[0])
            {
              v125 = (float *)a2 + 5 * v120;
              if (v88 == 1)
              {
                float v126 = *v123 - a1[6].f32[0];
                float v127 = v124 - a1[6].f32[1];
                float v129 = a1[7].f32[0];
                float v128 = a1[7].f32[1];
                float *v125 = (float)(v127 * v129) + (float)(v128 * v126);
                v125[1] = (float)(v128 * v127) - (float)(v129 * v126);
                a2[2].i32[5 * v120] = v138[3 * v119 + 2];
              }
              else
              {
                *(void *)v125 = *(void *)v123;
                v117.i32[0] = v138[3 * v119 + 2];
                int16x8_t v130 = (int16x8_t)vmovl_u8(v117);
                *(int16x4_t *)v130.i8 = vrev32_s16(*(int16x4_t *)v130.i8);
                uint8x8_t v117 = (uint8x8_t)vmovn_s16(v130);
                a2[2].i32[5 * v120] = v117.i32[0];
              }
              ++v120;
            }
            char v121 = 0;
            uint64_t v119 = 1;
          }
          while ((v122 & 1) != 0);
          a2[7].i32[1] = v120;
        }
      }
    }
  }
  return result;
}

uint64_t b2EPCollider::ComputeEdgeSeparation(b2EPCollider *this)
{
  uint64_t v1 = *((void *)this + 1) - *(void *)this;
  if (v1)
  {
    unint64_t v2 = v1 >> 3;
    float v3 = *((float *)this + 20);
    float v4 = *((float *)this + 32);
    if (v2 <= 1) {
      unint64_t v2 = 1;
    }
    float v5 = (float *)(*(void *)this + 4);
    float v6 = 3.4028e38;
    do
    {
      float v7 = (float)(*v5 - *((float *)this + 21)) * *((float *)this + 33);
      if ((float)(v7 + (float)(v4 * (float)(*(v5 - 1) - v3))) < v6) {
        float v6 = v7 + (float)(v4 * (float)(*(v5 - 1) - v3));
      }
      v5 += 2;
      --v2;
    }
    while (v2);
  }
  if (*((unsigned char *)this + 164)) {
    return 1;
  }
  else {
    return 0x100000001;
  }
}

unint64_t b2EPCollider::ComputePolygonSeparation(b2EPCollider *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = v1 - *(void *)this;
  if (v1 == *(void *)this)
  {
    unsigned int v4 = 0;
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v3 = 0;
    unsigned int v4 = 0;
    float v6 = *((float *)this + 32);
    float v5 = *((float *)this + 33);
    unint64_t v7 = v2 >> 3;
    if (v7 <= 1) {
      unint64_t v7 = 1;
    }
    float v8 = (float *)(*(void *)this + 4);
    float v9 = (float *)(*((void *)this + 3) + 4);
    uint64_t v10 = 0xFFFFFFFFLL;
    float v11 = -3.4028e38;
    while (1)
    {
      float v12 = *(v9 - 1);
      float v13 = *(v8 - 1);
      float v14 = (float)-(float)(*v9 * (float)(*v8 - *((float *)this + 21)))
          - (float)(v12 * (float)(v13 - *((float *)this + 20)));
      float v15 = (float)-(float)(*v9 * (float)(*v8 - *((float *)this + 23)))
          - (float)(v12 * (float)(v13 - *((float *)this + 22)));
      if (v14 < v15) {
        float v15 = v14;
      }
      if (v15 > *((float *)this + 40)) {
        break;
      }
      float v16 = -v12;
      float v17 = -*v9;
      if ((float)((float)(v6 * v17) + (float)(v12 * v5)) >= 0.0)
      {
        float v18 = *((float *)this + 38);
        float v19 = *((float *)this + 39);
      }
      else
      {
        float v18 = *((float *)this + 36);
        float v19 = *((float *)this + 37);
      }
      if ((float)((float)((float)(v17 - v19) * v5) + (float)((float)(v16 - v18) * v6)) >= -0.034907)
      {
        if (v15 <= v11)
        {
          uint64_t v10 = v10;
        }
        else
        {
          unsigned int v4 = 2;
          uint64_t v10 = v3;
        }
        if (v15 > v11) {
          float v11 = v15;
        }
      }
      ++v3;
      v8 += 2;
      v9 += 2;
      if (v7 == v3) {
        return v4 | (unint64_t)(v10 << 32);
      }
    }
    unsigned int v4 = 2;
    uint64_t v10 = v3;
  }
  return v4 | (unint64_t)(v10 << 32);
}

void b2CollideEdgeAndPolygon(float32x2_t *a1, float32x2_t *a2, float *a3, uint64_t a4, float *a5)
{
  *(_OWORD *)__p = 0u;
  long long v7 = 0u;
  *(_OWORD *)float v5 = 0u;
  b2EPCollider::Collide((float32x2_t *)v5, a1, a2, a3, a4, a5);
  if (__p[1])
  {
    *(void **)&long long v7 = __p[1];
    operator delete(__p[1]);
  }
  if (v5[0])
  {
    v5[1] = v5[0];
    operator delete(v5[0]);
  }
}

void sub_21356C958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void b2EPCollider::~b2EPCollider(b2EPCollider *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

void b2CollidePolygons(float32x2_t *a1, float *a2, const b2Transform *a3, float *a4, const b2Transform *a5)
{
  float v5 = a5;
  float v6 = a4;
  uint64_t v104 = *MEMORY[0x263EF8340];
  a1[7].i32[1] = 0;
  float v10 = a2[3] + a4[3];
  int v92 = 0;
  float MaxSeparation = b2FindMaxSeparation(&v92, (const b2PolygonShape *)a2, a3, (const b2PolygonShape *)a4, a5);
  if (MaxSeparation <= v10)
  {
    float v12 = MaxSeparation;
    int v91 = 0;
    float v13 = b2FindMaxSeparation(&v91, (const b2PolygonShape *)v6, v5, (const b2PolygonShape *)a2, a3);
    if (v13 <= v10)
    {
      float v14 = v13;
      float v15 = (float)(v12 * 0.98) + 0.001;
      if (v13 > v15)
      {
        float v16 = &v91;
        int v17 = 2;
        p_float var0 = (float *)&a3->var0;
        float v19 = a2;
      }
      else
      {
        float v16 = &v92;
        int v17 = 1;
        p_float var0 = (float *)&v5->var0;
        float v5 = a3;
        float v19 = v6;
        float v6 = a2;
      }
      uint64_t v20 = *v16;
      float var0 = v5->var1.var0;
      float var1 = v5->var1.var1;
      float x = v5->var0.x;
      float y = v5->var0.y;
      float v25 = *p_var0;
      float v26 = p_var0[1];
      float v28 = p_var0[2];
      float v27 = p_var0[3];
      a1[7].i32[0] = v17;
      if ((v20 & 0x80000000) != 0
        || (uint64_t v29 = *((void *)v6 + 2), v30 = (unint64_t)(*((void *)v6 + 3) - v29) >> 3, (int)v20 >= (int)v30))
      {
        b2CollidePolygons();
      }
      uint64_t v31 = *((void *)v19 + 2);
      unint64_t v32 = *((void *)v19 + 3) - v31;
      unint64_t v33 = v32 >> 3;
      float v34 = -v28;
      if ((int)(v32 >> 3) < 1)
      {
        int v36 = 0;
      }
      else
      {
        uint64_t v35 = 0;
        int v36 = 0;
        int v37 = (float *)(*((void *)v6 + 5) + 8 * v20);
        float v38 = v37[1];
        float v39 = (float)(var1 * *v37) - (float)(var0 * v38);
        float v40 = (float)(var1 * v38) + (float)(var0 * *v37);
        float v41 = (float)(v28 * v40) + (float)(v27 * v39);
        float v42 = (float)(v27 * v40) - (float)(v28 * v39);
        float v43 = 3.4028e38;
        uint64_t v44 = *((void *)v19 + 5);
        uint64_t v45 = (v32 >> 3);
        BOOL v46 = (float *)(v44 + 4);
        do
        {
          if ((float)((float)(v42 * *v46) + (float)(v41 * *(v46 - 1))) < v43)
          {
            float v43 = (float)(v42 * *v46) + (float)(v41 * *(v46 - 1));
            int v36 = v35;
          }
          ++v35;
          v46 += 2;
        }
        while (v45 != v35);
      }
      float v47 = -var0;
      if (v36 + 1 < (int)v33) {
        int v48 = v36 + 1;
      }
      else {
        int v48 = 0;
      }
      float v49 = (float *)(v31 + 8 * v36);
      float v50 = v49[1];
      float v51 = v26 + (float)((float)(v27 * v50) + (float)(v28 * *v49));
      *(float *)&uint64_t v95 = v25 + (float)((float)(v50 * v34) + (float)(v27 * *v49));
      *((float *)&v95 + 1) = v51;
      char v96 = v20;
      char v97 = v36;
      __int16 v98 = 1;
      float v52 = (float *)(v31 + 8 * v48);
      float v53 = v52[1];
      float v54 = v26 + (float)((float)(v27 * v53) + (float)(v28 * *v52));
      float v99 = v25 + (float)((float)(v53 * v34) + (float)(v27 * *v52));
      float v100 = v54;
      char v101 = v20;
      char v102 = v48;
      __int16 v103 = 1;
      if ((int)v20 + 1 < (int)v30) {
        int v55 = v20 + 1;
      }
      else {
        int v55 = 0;
      }
      float32x2_t v56 = *(float32x2_t *)(v29 + 8 * (int)v20);
      float32x2_t v89 = *(float32x2_t *)(v29 + 8 * v55);
      float32x2_t v57 = vsub_f32(v89, v56);
      float v58 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v57, v57).i32[1]), v57.f32[0], v57.f32[0]));
      float v85 = v15;
      float v86 = v14;
      float v83 = v26;
      float v84 = v25;
      float v81 = -v28;
      float v82 = v28;
      if (v58 >= 0.00000011921) {
        float32x2_t v57 = vmul_n_f32(v57, 1.0 / v58);
      }
      float v59 = vmuls_lane_f32(v47, v57, 1);
      float v60 = -(float)(v59 + (float)(var1 * v57.f32[0]));
      float v61 = vmlas_n_f32(v59, var1, v57.f32[0]);
      float v62 = vmuls_lane_f32(var1, v57, 1);
      float v63 = -(float)(v62 + (float)(var0 * v57.f32[0]));
      float32x2_t v79 = *(float32x2_t *)(v29 + 8 * (int)v20);
      float32x2_t v80 = v57;
      float v64 = vmlas_n_f32(v62, var0, v57.f32[0]);
      v90[0] = v61;
      v90[1] = v64;
      float v77 = y + vmlas_n_f32(vmuls_lane_f32(var1, v56, 1), var0, v56.f32[0]);
      float v78 = x + vmlas_n_f32(vmuls_lane_f32(v47, v56, 1), var1, v56.f32[0]);
      v93[0] = v60;
      v93[1] = v63;
      float v87 = var0;
      float v88 = y;
      if ((int)b2ClipSegmentToLine((uint64_t)v94, &v95, v93, v20, v10 - (float)((float)(v77 * v64) + (float)(v61 * v78))) >= 2&& (int)b2ClipSegmentToLine((uint64_t)v93, v94, v90, v55, v10+ (float)((float)((float)(v88 + vmlas_n_f32(vmuls_lane_f32(var1, v89, 1), v87, v89.f32[0])) * v64)+ (float)(v61 * (float)(x + vmlas_n_f32(vmuls_lane_f32(v47, v89, 1), var1, v89.f32[0]))))) >= 2)
      {
        uint64_t v65 = 0;
        __int32 v66 = 0;
        a1[5].i32[0] = v80.i32[1];
        a1[5].f32[1] = -v80.f32[0];
        a1[6] = vmul_f32(vadd_f32(v79, v89), (float32x2_t)0x3F0000003F000000);
        char v67 = 1;
        do
        {
          char v68 = v67;
          BOOL v69 = &v93[3 * v65];
          float v70 = *v69;
          float v71 = v69[1];
          if ((float)((float)((float)(v71 * v60) + (float)(v64 * *v69))
                     - (float)((float)(v64 * v78) - (float)(v61 * v77))) <= v10)
          {
            uint64_t v72 = (char *)a1 + 20 * v66;
            float v73 = v70 - v84;
            float v74 = v71 - v83;
            *(float *)uint64_t v72 = (float)(v82 * v74) + (float)(v27 * v73);
            *((float *)v72 + 1) = (float)(v27 * v74) + (float)(v81 * v73);
            float v75 = v93[3 * v65 + 2];
            *((float *)v72 + 4) = v75;
            uint64_t v76 = v72 + 16;
            if (v86 > v85)
            {
              unsigned char *v76 = BYTE1(v75);
              v76[1] = LOBYTE(v75);
              v76[2] = HIBYTE(v75);
              v76[3] = BYTE2(v75);
            }
            ++v66;
          }
          char v67 = 0;
          uint64_t v65 = 1;
        }
        while ((v68 & 1) != 0);
        a1[7].i32[1] = v66;
      }
    }
  }
}

float b2FindMaxSeparation(int *a1, const b2PolygonShape *a2, const b2Transform *a3, const b2PolygonShape *a4, const b2Transform *a5)
{
  unint64_t v9 = *((void *)a2 + 3) - *((void *)a2 + 2);
  unint64_t v10 = v9 >> 3;
  signed int v11 = (v9 >> 3) - 1;
  if ((int)(v9 >> 3) < 1)
  {
    signed int v13 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    signed int v13 = 0;
    float var0 = a5->var1.var0;
    float var1 = a5->var1.var1;
    float v16 = *((float *)a4 + 16);
    float v17 = *((float *)a4 + 17);
    float v18 = a5->var0.x + (float)((float)(var1 * v16) - (float)(var0 * v17));
    float v19 = (float)((float)(var1 * v17) + (float)(var0 * v16)) + a5->var0.y;
    float v21 = a3->var1.var0;
    float v20 = a3->var1.var1;
    float v22 = *((float *)a2 + 16);
    float v23 = *((float *)a2 + 17);
    float v24 = a3->var0.x + (float)((float)(v20 * v22) - (float)(v21 * v23));
    float v25 = (float)(v20 * v23) + (float)(v21 * v22);
    float v26 = -3.4028e38;
    float v27 = v18 - v24;
    float v28 = v19 - (float)(v25 + a3->var0.y);
    float v29 = (float)(v21 * v28) + (float)(v20 * v27);
    float v30 = (float)(v20 * v28) - (float)(v21 * v27);
    uint64_t v31 = (v9 >> 3);
    unint64_t v32 = (float *)(*((void *)a2 + 5) + 4);
    do
    {
      float v33 = v30 * *v32;
      if ((float)(v33 + (float)(*(v32 - 1) * v29)) > v26)
      {
        signed int v13 = v12;
        float v26 = v33 + (float)(*(v32 - 1) * v29);
      }
      ++v12;
      v32 += 2;
    }
    while (v31 != v12);
  }
  float v34 = b2EdgeSeparation(a2, a3, v13, a4, a5);
  if (v13 <= 0) {
    signed int v35 = v11;
  }
  else {
    signed int v35 = v13 - 1;
  }
  float v36 = b2EdgeSeparation(a2, a3, v35, a4, a5);
  if (v13 + 1 < (int)v10) {
    unsigned int v37 = v13 + 1;
  }
  else {
    unsigned int v37 = 0;
  }
  float v38 = b2EdgeSeparation(a2, a3, v37, a4, a5);
  BOOL v39 = v36 > v38 && v36 > v34;
  if (!v39)
  {
    if (v38 <= v34) {
      goto LABEL_28;
    }
    signed int v35 = v37;
    float v36 = v38;
  }
  do
  {
    float v34 = v36;
    signed int v13 = v35;
    if (v39)
    {
      if (v35 <= 0) {
        signed int v35 = v11;
      }
      else {
        --v35;
      }
    }
    else if (v35 + 1 < (int)v10)
    {
      ++v35;
    }
    else
    {
      signed int v35 = 0;
    }
    float v36 = b2EdgeSeparation(a2, a3, v35, a4, a5);
  }
  while (v36 > v34);
LABEL_28:
  *a1 = v13;
  return v34;
}

float b2EdgeSeparation(const b2PolygonShape *a1, const b2Transform *a2, unsigned int a3, const b2PolygonShape *a4, const b2Transform *a5)
{
  if ((a3 & 0x80000000) != 0
    || (uint64_t v5 = *((void *)a1 + 2), (int)((unint64_t)(*((void *)a1 + 3) - v5) >> 3) <= (int)a3))
  {
    b2EdgeSeparation();
  }
  uint64_t v6 = *((void *)a4 + 2);
  unint64_t v7 = *((void *)a4 + 3) - v6;
  float v8 = (float *)(*((void *)a1 + 5) + 8 * a3);
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v11 = v8[1];
  float v12 = (float)(var1 * *v8) - (float)(var0 * v11);
  float v13 = (float)(var1 * v11) + (float)(var0 * *v8);
  float v15 = a5->var1.var0;
  float v14 = a5->var1.var1;
  if ((int)(v7 >> 3) < 1)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v16 = 0;
    LODWORD(v17) = 0;
    float v18 = (float)(v15 * v13) + (float)(v14 * v12);
    uint64_t v19 = (v7 >> 3);
    float v20 = (float *)(v6 + 4);
    float v21 = 3.4028e38;
    do
    {
      float v22 = (float)((float)(v14 * v13) - (float)(v15 * v12)) * *v20;
      if ((float)(v22 + (float)(*(v20 - 1) * v18)) < v21)
      {
        LODWORD(v17) = v16;
        float v21 = v22 + (float)(*(v20 - 1) * v18);
      }
      ++v16;
      v20 += 2;
    }
    while (v19 != v16);
    uint64_t v17 = (int)v17;
  }
  float v23 = (float *)(v5 + 8 * a3);
  return (float)(v13
               * (float)((float)((float)((float)(v14 * *(float *)(v6 + 8 * v17 + 4))
                                       + (float)(v15 * *(float *)(v6 + 8 * v17)))
                               + a5->var0.y)
                       - (float)((float)((float)(var1 * v23[1]) + (float)(var0 * *v23)) + a2->var0.y)))
       + (float)((float)((float)(a5->var0.x
                               + (float)((float)(*(float *)(v6 + 8 * v17 + 4) * (float)-v15)
                                       + (float)(v14 * *(float *)(v6 + 8 * v17))))
                       - (float)(a2->var0.x + (float)((float)(v23[1] * (float)-var0) + (float)(var1 * *v23))))
               * v12);
}

float b2WorldManifold::Initialize(uint64_t a1, uint64_t a2, float *a3, float *a4, float result, float a6)
{
  uint64_t v6 = *(unsigned int *)(a2 + 60);
  if (v6)
  {
    switch(*(_DWORD *)(a2 + 56))
    {
      case 0:
      case 3:
        *(void *)a1 = 0x3F80000000000000;
        float v8 = a3[2];
        float v7 = a3[3];
        float v9 = *(float *)(a2 + 48);
        float v10 = *(float *)(a2 + 52);
        float v11 = *a3 + (float)((float)(v7 * v9) - (float)(v8 * v10));
        float v12 = (float)((float)(v7 * v10) + (float)(v8 * v9)) + a3[1];
        float v14 = a4[2];
        float v13 = a4[3];
        float v15 = *(float *)(a2 + 4);
        float v16 = *a4 + (float)((float)(v13 * *(float *)a2) - (float)(v14 * v15));
        float v17 = (float)((float)(v13 * v15) + (float)(v14 * *(float *)a2)) + a4[1];
        if ((float)((float)((float)(v12 - v17) * (float)(v12 - v17)) + (float)((float)(v11 - v16) * (float)(v11 - v16))) <= 1.4211e-14)
        {
          float v18 = 0.0;
          float v19 = 1.0;
        }
        else
        {
          float v18 = v16 - v11;
          float v19 = v17 - v12;
          *(float *)a1 = v16 - v11;
          *(float *)(a1 + 4) = v17 - v12;
          float v20 = sqrtf((float)(v19 * v19) + (float)(v18 * v18));
          if (v20 >= 0.00000011921)
          {
            float v21 = 1.0 / v20;
            float v18 = v18 * v21;
            float v19 = v19 * v21;
            *(float *)a1 = v18;
            *(float *)(a1 + 4) = v19;
          }
        }
        float v74 = v11 + (float)(v18 * result);
        float v75 = v12 + (float)(v19 * result);
        float v76 = v16 - (float)(v18 * a6);
        float v77 = v17 - (float)(v19 * a6);
        *(float *)(a1 + 8) = (float)(v74 + v76) * 0.5;
        *(float *)(a1 + 12) = (float)(v75 + v77) * 0.5;
        uint64_t result = (float)(v19 * (float)(v77 - v75)) + (float)((float)(v76 - v74) * v18);
        *(float *)(a1 + 24) = result;
        break;
      case 1:
        float v23 = a3[2];
        float v22 = a3[3];
        float v24 = *(float *)(a2 + 40);
        float v25 = *(float *)(a2 + 44);
        float v26 = (float)(v22 * v24) - (float)(v23 * v25);
        float v27 = (float)(v22 * v25) + (float)(v23 * v24);
        *(float *)a1 = v26;
        *(float *)(a1 + 4) = v27;
        if ((int)v6 >= 1)
        {
          float v29 = a3[2];
          float v28 = a3[3];
          float v30 = *(float *)(a2 + 48);
          float v31 = *(float *)(a2 + 52);
          float v32 = *a3 + (float)((float)(v28 * v30) - (float)(v29 * v31));
          float v33 = (float)((float)(v28 * v31) + (float)(v29 * v30)) + a3[1];
          float v34 = v26 * a6;
          float v35 = v27 * a6;
          float v36 = (float *)(a2 + 4);
          unsigned int v37 = (float *)(a1 + 24);
          float v38 = (float *)(a1 + 12);
          do
          {
            float v39 = *(v36 - 1);
            float v41 = a4[2];
            float v40 = a4[3];
            float v42 = *a4 + (float)((float)(v40 * v39) - (float)(v41 * *v36));
            float v43 = (float)((float)(v40 * *v36) + (float)(v41 * v39)) + a4[1];
            float v44 = result - (float)((float)(v27 * (float)(v43 - v33)) + (float)((float)(v42 - v32) * v26));
            float v45 = v42 + (float)(v26 * v44);
            float v46 = v43 + (float)(v27 * v44);
            float v47 = v43 - v35;
            *(v38 - 1) = (float)((float)(v42 - v34) + v45) * 0.5;
            float *v38 = (float)(v47 + v46) * 0.5;
            *v37++ = (float)(v27 * (float)(v47 - v46)) + (float)((float)((float)(v42 - v34) - v45) * v26);
            v36 += 5;
            v38 += 2;
            --v6;
          }
          while (v6);
        }
        break;
      case 2:
        float v49 = a4[2];
        float v48 = a4[3];
        float v50 = *(float *)(a2 + 40);
        float v51 = *(float *)(a2 + 44);
        float v52 = (float)(v48 * v50) - (float)(v49 * v51);
        float v53 = (float)(v48 * v51) + (float)(v49 * v50);
        *(float *)a1 = v52;
        *(float *)(a1 + 4) = v53;
        if ((int)v6 >= 1)
        {
          float v55 = a4[2];
          float v54 = a4[3];
          float v56 = *(float *)(a2 + 48);
          float v57 = *(float *)(a2 + 52);
          float v58 = *a4 + (float)((float)(v54 * v56) - (float)(v55 * v57));
          float v59 = (float)((float)(v54 * v57) + (float)(v55 * v56)) + a4[1];
          float v60 = v52 * result;
          float v61 = v53 * result;
          float v62 = (float *)(a2 + 4);
          float v63 = (float *)(a1 + 24);
          float v64 = (float *)(a1 + 12);
          do
          {
            float v65 = *(v62 - 1);
            float v67 = a3[2];
            float v66 = a3[3];
            float v68 = *a3 + (float)((float)(v66 * v65) - (float)(v67 * *v62));
            float v69 = (float)((float)(v66 * *v62) + (float)(v67 * v65)) + a3[1];
            float v70 = a6 - (float)((float)(v53 * (float)(v69 - v59)) + (float)((float)(v68 - v58) * v52));
            float v71 = v68 + (float)(v52 * v70);
            float v72 = v69 + (float)(v53 * v70);
            float v73 = v69 - v61;
            *(v64 - 1) = (float)((float)(v68 - v60) + v71) * 0.5;
            *float v64 = (float)(v73 + v72) * 0.5;
            *v63++ = (float)(v53 * (float)(v73 - v72)) + (float)((float)((float)(v68 - v60) - v71) * v52);
            v62 += 5;
            v64 += 2;
            --v6;
          }
          while (v6);
        }
        uint64_t result = -v52;
        *(float *)a1 = -v52;
        *(float *)(a1 + 4) = -v53;
        break;
      default:
        return result;
    }
  }
  return result;
}

unint64_t b2GetPointStates(unint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)uint64_t result = 0;
  *a2 = 0;
  *(_DWORD *)(result + 4) = 0;
  a2[1] = 0;
  uint64_t v4 = *(unsigned int *)(a3 + 60);
  uint64_t v5 = *(unsigned int *)(a4 + 60);
  if ((int)v4 >= 1)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      int v7 = *(_DWORD *)(a3 + 20 * i + 16);
      *(_DWORD *)(result + 4 * i) = 3;
      uint64_t v8 = v5;
      float v9 = (int *)(a4 + 16);
      if ((int)v5 >= 1)
      {
        while (1)
        {
          int v10 = *v9;
          v9 += 5;
          if (v10 == v7) {
            break;
          }
          if (!--v8) {
            goto LABEL_8;
          }
        }
        *(_DWORD *)(result + 4 * i) = 2;
      }
LABEL_8:
      ;
    }
  }
  if ((int)v5 >= 1)
  {
    for (uint64_t j = 0; j != v5; ++j)
    {
      int v12 = *(_DWORD *)(a4 + 20 * j + 16);
      a2[j] = 1;
      uint64_t v13 = v4;
      float v14 = (unsigned int *)(a3 + 16);
      if ((int)v4 >= 1)
      {
        while (1)
        {
          unsigned int v15 = *v14;
          v14 += 5;
          uint64_t result = v15;
          if (v15 == v12) {
            break;
          }
          if (!--v13) {
            goto LABEL_16;
          }
        }
        a2[j] = 2;
      }
LABEL_16:
      ;
    }
  }
  return result;
}

uint64_t b2AABB::RayCast(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  uint64_t v3 = 0;
  float32x2_t v23 = *a3;
  float32x2_t v22 = vsub_f32(a3[1], v23);
  uint64_t v4 = a1 + 8;
  char v5 = 1;
  int8x8_t v21 = vbsl_s8((int8x8_t)vcgtz_f32(v22), (int8x8_t)v22, (int8x8_t)vneg_f32(v22));
  float v6 = -3.4028e38;
  float v7 = 3.4028e38;
  do
  {
    char v8 = v5;
    if (*(float *)&v21.i32[v3] >= 0.00000011921)
    {
      float v10 = 1.0 / v22.f32[v3];
      float v11 = v23.f32[v3];
      float v12 = v10 * (float)(*(float *)(a1 + 4 * v3) - v11);
      float v13 = *(float *)(v4 + 4 * v3) - v11;
      float v14 = v10 * v13;
      BOOL v15 = v12 <= (float)(v10 * v13);
      if (v12 <= (float)(v10 * v13)) {
        float v16 = v12;
      }
      else {
        float v16 = v10 * v13;
      }
      if (v15) {
        float v17 = v14;
      }
      else {
        float v17 = v12;
      }
      if (v16 > v6)
      {
        if (v12 <= v14) {
          float v18 = -1.0;
        }
        else {
          float v18 = 1.0;
        }
        uint64_t v20 = 0;
        *((float *)&v20 + v3) = v18;
        float v6 = v16;
      }
      if (v7 >= v17) {
        float v7 = v17;
      }
      if (v6 > v7) {
        return 0;
      }
    }
    else
    {
      float v9 = v23.f32[v3];
      if (v9 < *(float *)(a1 + 4 * v3) || *(float *)(v4 + 4 * v3) < v9) {
        return 0;
      }
    }
    char v5 = 0;
    uint64_t v3 = 1;
  }
  while ((v8 & 1) != 0);
  uint64_t result = 0;
  if (v6 >= 0.0 && a3[2].f32[0] >= v6)
  {
    *(float *)(a2 + 8) = v6;
    *(void *)a2 = v20;
    return 1;
  }
  return result;
}

uint64_t b2ClipSegmentToLine(uint64_t a1, uint64_t *a2, float *a3, __int8 a4, float a5)
{
  float v5 = a3[1];
  float v6 = (float)((float)(v5 * *((float *)a2 + 1)) + (float)(*a3 * *(float *)a2)) - a5;
  float v7 = (float)((float)(v5 * *((float *)a2 + 4)) + (float)(*a3 * *((float *)a2 + 3))) - a5;
  if (v6 <= 0.0)
  {
    uint64_t v9 = *a2;
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
    *(void *)a1 = v9;
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v7 <= 0.0)
  {
    uint64_t v10 = a1 + 12 * v8;
    uint64_t v11 = *(uint64_t *)((char *)a2 + 12);
    uint64_t v8 = (v8 + 1);
    *(_DWORD *)(v10 + 8) = *((_DWORD *)a2 + 5);
    *(void *)uint64_t v10 = v11;
  }
  if ((float)(v6 * v7) < 0.0)
  {
    float v12 = (float32x2_t *)(a1 + 12 * v8);
    float32x2_t *v12 = vadd_f32(*(float32x2_t *)a2, vmul_n_f32(vsub_f32(*(float32x2_t *)((char *)a2 + 12), *(float32x2_t *)a2), v6 / (float)(v6 - v7)));
    v12[1].i8[0] = a4;
    v12[1].i8[1] = *((unsigned char *)a2 + 9);
    v12[1].i16[1] = 256;
    return (v8 + 1);
  }
  return v8;
}

BOOL b2TestOverlap(b2Shape *a1, int a2, b2Shape *a3, int a4, const b2Transform *a5, const b2Transform *a6)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  v19[2] = 0;
  v19[3] = 0;
  b2DistanceProxy::Set((b2DistanceProxy *)v16, a1, a2);
  b2DistanceProxy::Set((b2DistanceProxy *)v19, a3, a4);
  long long v10 = (__int128)*a6;
  long long v20 = (__int128)*a5;
  long long v21 = v10;
  char v22 = 1;
  __int16 v15 = 0;
  b2Distance((uint64_t)v12, (uint64_t)v14, (uint64_t)v16);
  return v13 < 0.0000011921;
}

float b2DistanceProxy::Set(b2DistanceProxy *this, b2Shape *a2, int a3)
{
  switch(*((_DWORD *)a2 + 2))
  {
    case 0:
      *((void *)this + 2) = (char *)a2 + 16;
      goto LABEL_11;
    case 1:
      *((void *)this + 2) = (char *)a2 + 16;
      goto LABEL_14;
    case 2:
      uint64_t v5 = *((void *)a2 + 2);
      uint64_t v6 = *((void *)a2 + 3);
      *((void *)this + 2) = v5;
      float result = *((float *)a2 + 3);
      *((float *)this + 7) = result;
      *((_DWORD *)this + 6) = (unint64_t)(v6 - v5) >> 3;
      return result;
    case 3:
      if (a3 < 0 || (int)((*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3) <= a3) {
        b2DistanceProxy::Set();
      }
      *(void *)this = *(void *)b2ChainShape::GetVertex((b2ChainShape *)a2, a3);
      Vertefloat x = (void *)*((void *)a2 + 2);
      uint64_t v10 = (*((void *)a2 + 3) - (void)Vertex) >> 3;
      if (a3 + 1 >= (int)v10)
      {
        if ((int)v10 <= 0) {
          b2ChainShape::GetVertex();
        }
      }
      else
      {
        Vertefloat x = (void *)b2ChainShape::GetVertex((b2ChainShape *)a2, a3 + 1);
      }
      *((void *)this + 1) = *Vertex;
      *((void *)this + 2) = this;
LABEL_14:
      int v11 = 2;
      break;
    case 4:
      {
        b2DistanceProxy::Set(b2Shape const*,int)::dummfloat y = 0;
      }
      *((void *)this + 2) = &b2DistanceProxy::Set(b2Shape const*,int)::dummy;
LABEL_11:
      int v11 = 1;
      break;
    default:
      b2DistanceProxy::Set();
  }
  *((_DWORD *)this + 6) = v11;
  float result = *((float *)a2 + 3);
  *((float *)this + 7) = result;
  return result;
}

__n128 b2Simplex::Solve2(__n128 *this)
{
  float v1 = this[1].n128_f32[0];
  float v2 = this[1].n128_f32[1];
  uint64_t v3 = (__n128 *)((char *)this + 36);
  float v4 = this[3].n128_f32[1];
  float v5 = this[3].n128_f32[2];
  float v6 = v4 - v1;
  float v7 = v5 - v2;
  float v8 = v2 * (float)(v5 - v2);
  float v9 = v8 + (float)(v1 * (float)(v4 - v1));
  if (v9 >= 0.0)
  {
    this[1].n128_u32[2] = 1065353216;
    this[6].n128_u32[3] = 1;
    this[4].n128_u32[1] = this[2].n128_u32[0];
    __n128 result = *this;
    __n128 v14 = this[1];
    *uint64_t v3 = *this;
    *(__n128 *)((char *)this + 52) = v14;
  }
  else
  {
    float v10 = (float)(v5 * v7) + (float)(v4 * v6);
    if (v10 <= 0.0)
    {
      this[3].n128_u32[3] = 1065353216;
      this[6].n128_u32[3] = 1;
      __n128 result = *v3;
      __n128 v15 = *(__n128 *)((char *)this + 52);
      *this = *v3;
      this[1] = v15;
      this[2].n128_u32[0] = this[4].n128_u32[1];
    }
    else
    {
      float v11 = -(float)(v8 + (float)(v1 * v6));
      float v12 = 1.0 / (float)(v10 - v9);
      this[1].n128_f32[2] = v10 * v12;
      result.n128_f32[0] = v12 * v11;
      this[3].n128_u32[3] = result.n128_u32[0];
      this[6].n128_u32[3] = 2;
    }
  }
  return result;
}

uint64_t b2Simplex::Solve3(uint64_t this)
{
  float v1 = *(float *)(this + 16);
  float v2 = *(float *)(this + 20);
  float v3 = *(float *)(this + 52);
  float v4 = *(float *)(this + 56);
  float v5 = *(float *)(this + 88);
  float v6 = *(float *)(this + 92);
  float v7 = v3 - v1;
  float v8 = v4 - v2;
  float v9 = v2 * (float)(v4 - v2);
  float v10 = v9 + (float)(v1 * (float)(v3 - v1));
  float v11 = v5 - v1;
  float v12 = v6 - v2;
  float v13 = v2 * (float)(v6 - v2);
  float v14 = v13 + (float)(v1 * (float)(v5 - v1));
  if (v10 >= 0.0 && v14 >= 0.0)
  {
    *(_DWORD *)(this + 24) = 1065353216;
    int v15 = 1;
LABEL_8:
    *(_DWORD *)(this + 108) = v15;
    return this;
  }
  float v16 = (float)(v4 * v8) + (float)(v3 * v7);
  float v17 = (float)(v7 * v12) - (float)(v8 * v11);
  float v18 = (float)((float)(v1 * v4) - (float)(v2 * v3)) * v17;
  if (v16 > 0.0 && v10 < 0.0 && v18 <= 0.0)
  {
    float v19 = 1.0 / (float)(v16 - v10);
    *(float *)(this + 24) = v16 * v19;
    *(float *)(this + 60) = v19 * (float)-(float)(v9 + (float)(v1 * v7));
    int v15 = 2;
    goto LABEL_8;
  }
  long long v20 = (_OWORD *)(this + 36);
  long long v21 = (_OWORD *)(this + 72);
  float v22 = (float)(v6 * v12) + (float)(v5 * v11);
  float v23 = v17 * (float)((float)(v5 * v2) - (float)(v6 * v1));
  if (v22 <= 0.0 || v14 >= 0.0 || v23 > 0.0)
  {
    float v26 = v5 - v3;
    float v27 = v4 * (float)(v6 - v4);
    float v28 = v27 + (float)(v3 * (float)(v5 - v3));
    if (v16 > 0.0 || v28 < 0.0)
    {
      float v31 = (float)(v6 * (float)(v6 - v4)) + (float)(v5 * v26);
      if (v22 > 0.0 || v31 > 0.0)
      {
        float v33 = (float)((float)(v3 * v6) - (float)(v4 * v5)) * v17;
        if (v31 <= 0.0 || v28 >= 0.0 || v33 > 0.0)
        {
          float v36 = 1.0 / (float)(v18 + (float)(v33 + v23));
          *(float *)(this + 24) = v33 * v36;
          *(float *)(this + 60) = v23 * v36;
          *(float *)(this + 96) = v18 * v36;
          int v15 = 3;
          goto LABEL_8;
        }
        float v34 = 1.0 / (float)(v31 - v28);
        *(float *)(this + 60) = v31 * v34;
        *(float *)(this + 96) = v34 * (float)-(float)(v27 + (float)(v3 * v26));
        int v32 = 2;
      }
      else
      {
        *(_DWORD *)(this + 96) = 1065353216;
        int v32 = 1;
      }
      *(_DWORD *)(this + 108) = v32;
      long long v35 = *(_OWORD *)(this + 88);
      *(_OWORD *)this = *v21;
      *(_OWORD *)(this + 16) = v35;
      int v30 = *(_DWORD *)(this + 104);
    }
    else
    {
      *(_DWORD *)(this + 60) = 1065353216;
      *(_DWORD *)(this + 108) = 1;
      long long v29 = *(_OWORD *)(this + 52);
      *(_OWORD *)this = *v20;
      *(_OWORD *)(this + 16) = v29;
      int v30 = *(_DWORD *)(this + 68);
    }
    *(_DWORD *)(this + 32) = v30;
  }
  else
  {
    float v24 = 1.0 / (float)(v22 - v14);
    *(float *)(this + 24) = v22 * v24;
    *(float *)(this + 96) = v24 * (float)-(float)(v13 + (float)(v1 * v11));
    *(_DWORD *)(this + 108) = 2;
    long long v25 = *(_OWORD *)(this + 88);
    *long long v20 = *v21;
    *(_OWORD *)(this + 52) = v25;
    *(_DWORD *)(this + 68) = *(_DWORD *)(this + 104);
  }
  return this;
}

int32x4_t b2Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  ++b2_gjkCalls;
  long long v6 = *(_OWORD *)(a3 + 64);
  long long v63 = *(_OWORD *)(a3 + 80);
  long long v64 = v6;
  b2Simplex::ReadCache((b2Simplex *)v60, a2, a3, (float *)&v64, a3 + 32, (float *)&v63);
  b2Simplex::GetClosestPoint((b2Simplex *)v60);
  int v7 = 0;
  int v8 = v62;
  do
  {
    uint64_t v9 = v8;
    if (v8 >= 1)
    {
      float v10 = v65;
      float v11 = v66;
      uint64_t v12 = v8;
      float v13 = (int *)&v61;
      do
      {
        *v11++ = *(v13 - 1);
        int v14 = *v13;
        v13 += 9;
        *v10++ = v14;
        --v12;
      }
      while (v12);
    }
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        b2Simplex::Solve2(v60);
      }
      else
      {
        if (v8 != 3) {
          b2Distance();
        }
        b2Simplex::Solve3((uint64_t)v60);
      }
    }
    if (v62 == 3) {
      break;
    }
    b2Simplex::GetClosestPoint((b2Simplex *)v60);
    float SearchDirection = b2Simplex::GetSearchDirection((b2Simplex *)v60);
    if ((float)((float)(v16 * v16) + (float)(SearchDirection * SearchDirection)) < 1.4211e-14) {
      break;
    }
    int v17 = v62;
    uint64_t v18 = *((void *)&v64 + 1);
    float v19 = *(float **)(a3 + 16);
    uint64_t v20 = *(unsigned int *)(a3 + 24);
    if ((int)v20 <= 1)
    {
      int v21 = 0;
      v60[1].n128_u32[9 * v62 + 3] = 0;
    }
    else
    {
      int v21 = 0;
      float v22 = (float)-(float)(v16 * *((float *)&v64 + 2)) - (float)(*((float *)&v64 + 3) * SearchDirection);
      float v23 = (float)(*((float *)&v64 + 2) * SearchDirection) - (float)(v16 * *((float *)&v64 + 3));
      float v24 = (float)(v23 * v19[1]) + (float)(*v19 * v22);
      long long v25 = v19 + 3;
      for (uint64_t i = 1; i != v20; ++i)
      {
        if ((float)((float)(v23 * *v25) + (float)(*(v25 - 1) * v22)) > v24)
        {
          int v21 = i;
          float v24 = (float)(v23 * *v25) + (float)(*(v25 - 1) * v22);
        }
        v25 += 2;
      }
      v60[1].n128_u32[9 * v62 + 3] = v21;
      if (v21 < 0) {
LABEL_48:
      }
        b2Distance();
    }
    if ((int)v20 <= v21) {
      goto LABEL_48;
    }
    float v27 = &v19[2 * v21];
    float v28 = *v27;
    float v29 = v27[1];
    float v30 = *(float *)&v64 + (float)((float)(v29 * (float)-*(float *)&v18) + (float)(*((float *)&v18 + 1) * *v27));
    float v31 = (float *)v60 + 9 * v17;
    float v32 = (float)((float)(*((float *)&v18 + 1) * v29) + (float)(*(float *)&v18 * v28)) + *((float *)&v64 + 1);
    *float v31 = v30;
    v31[1] = v32;
    uint64_t v33 = *((void *)&v63 + 1);
    float v34 = *(float **)(a3 + 48);
    uint64_t v35 = *(unsigned int *)(a3 + 56);
    if ((int)v35 <= 1)
    {
      int v36 = 0;
      v60[2].n128_u32[9 * v17] = 0;
    }
    else
    {
      int v36 = 0;
      float v37 = (float)(v16 * *((float *)&v63 + 2)) + (float)(*((float *)&v63 + 3) * SearchDirection);
      float v38 = (float)(v16 * *((float *)&v63 + 3)) - (float)(*((float *)&v63 + 2) * SearchDirection);
      float v39 = (float)(v38 * v34[1]) + (float)(*v34 * v37);
      float v40 = v34 + 3;
      for (uint64_t j = 1; j != v35; ++j)
      {
        if ((float)((float)(v38 * *v40) + (float)(*(v40 - 1) * v37)) > v39)
        {
          int v36 = j;
          float v39 = (float)(v38 * *v40) + (float)(*(v40 - 1) * v37);
        }
        v40 += 2;
      }
      v60[2].n128_u32[9 * v17] = v36;
      if (v36 < 0) {
LABEL_49:
      }
        b2Distance();
    }
    if ((int)v35 <= v36) {
      goto LABEL_49;
    }
    float v42 = &v34[2 * v36];
    float v43 = v42[1];
    float v44 = *(float *)&v63 + (float)((float)(v43 * (float)-*(float *)&v33) + (float)(*((float *)&v33 + 1) * *v42));
    float v45 = (float)((float)(*((float *)&v33 + 1) * v43) + (float)(*(float *)&v33 * *v42)) + *((float *)&v63 + 1);
    float v46 = (float *)v60 + 9 * v17;
    v46[2] = v44;
    v46[3] = v45;
    v46[4] = v44 - v30;
    v46[5] = v45 - v32;
    ++v7;
    ++b2_gjkIters;
    float v47 = v65;
    float v48 = (int *)v66;
    do
    {
      int v49 = *v48++;
      if (v21 == v49 && v36 == *v47) {
        goto LABEL_35;
      }
      ++v47;
      --v9;
    }
    while (v9);
    int v8 = v17 + 1;
    int v62 = v17 + 1;
  }
  while (v7 != 20);
LABEL_35:
  int v50 = b2_gjkMaxIters;
  if (b2_gjkMaxIters <= v7) {
    int v50 = v7;
  }
  b2_gjkMaxIters = v50;
  b2Simplex::GetWitnessPoints((uint64_t)v60, (b2Vec2 *)a1, (b2Vec2 *)(a1 + 8));
  *(float *)(a1 + 16) = sqrtf((float)((float)(*(float *)(a1 + 4) - *(float *)(a1 + 12))* (float)(*(float *)(a1 + 4) - *(float *)(a1 + 12)))+ (float)((float)(*(float *)a1 - *(float *)(a1 + 8)) * (float)(*(float *)a1 - *(float *)(a1 + 8))));
  *(_DWORD *)(a1 + 20) = v7;
  b2Simplex::WriteCache((int *)v60, a2);
  if (*(unsigned char *)(a3 + 96))
  {
    result.i32[0] = *(_DWORD *)(a3 + 28);
    float v52 = *(float *)(a3 + 60);
    float v53 = *(float *)(a1 + 16);
    if (v53 <= (float)(*(float *)result.i32 + v52) || v53 <= 0.00000011921)
    {
      *(float32x2_t *)result.i8 = vmul_f32(vadd_f32(*(float32x2_t *)a1, *(float32x2_t *)(a1 + 8)), (float32x2_t)0x3F0000003F000000);
      result.i64[1] = result.i64[0];
      *(int32x4_t *)a1 = result;
      *(_DWORD *)(a1 + 16) = 0;
    }
    else
    {
      *(float *)(a1 + 16) = v53 - (float)(*(float *)result.i32 + v52);
      float32x4_t v55 = *(float32x4_t *)a1;
      *(float32x2_t *)v56.f32 = vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL), *(float32x2_t *)a1);
      float v57 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&v56, *(float32x2_t *)&v56).i32[1]), v56.f32[0], v56.f32[0]));
      if (v57 >= 0.00000011921) {
        *(float32x2_t *)v56.f32 = vmul_n_f32(*(float32x2_t *)v56.f32, 1.0 / v57);
      }
      v56.i64[1] = v56.i64[0];
      *(float *)&result.i32[1] = v52;
      float32x4_t v58 = vmulq_f32((float32x4_t)vzip1q_s32(result, result), v56);
      *(void *)&long long v59 = vaddq_f32(v55, v58).u64[0];
      int32x4_t result = (int32x4_t)vsubq_f32(v55, v58);
      *((void *)&v59 + 1) = result.i64[1];
      *(_OWORD *)a1 = v59;
    }
  }
  return result;
}

void b2Simplex::ReadCache(b2Simplex *this, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  uint64_t v6 = *(unsigned __int16 *)(a2 + 4);
  if (v6 >= 4) {
    b2Simplex::ReadCache();
  }
  *((_DWORD *)this + 27) = v6;
  if (!v6)
  {
LABEL_10:
    *((_DWORD *)this + 7) = 0;
    *((_DWORD *)this + 8) = 0;
    if (*(int *)(a3 + 24) <= 0) {
      b2Distance();
    }
    if (*(int *)(a5 + 24) <= 0) {
      b2Distance();
    }
    float v32 = *(float **)(a3 + 16);
    float v34 = *v32;
    float v33 = v32[1];
    uint64_t v35 = *(float **)(a5 + 16);
    float v36 = *v35;
    float v37 = v35[1];
    float v39 = a4[2];
    float v38 = a4[3];
    float v40 = *a4 + (float)((float)(v38 * v34) - (float)(v39 * v33));
    float v41 = (float)((float)(v33 * v38) + (float)(v39 * v34)) + a4[1];
    *(float *)this = v40;
    *((float *)this + 1) = v41;
    float v43 = a6[2];
    float v42 = a6[3];
    float v44 = *a6 + (float)((float)(v42 * v36) - (float)(v43 * v37));
    float v45 = (float)((float)(v37 * v42) + (float)(v43 * v36)) + a6[1];
    *((float *)this + 2) = v44;
    *((float *)this + 3) = v45;
    *((float *)this + 4) = v44 - v40;
    *((float *)this + 5) = v45 - v41;
    *((_DWORD *)this + 6) = 1065353216;
    *((_DWORD *)this + 27) = 1;
    return;
  }
  uint64_t v12 = 0;
  int v13 = *(_DWORD *)(a3 + 24);
  int v14 = (char *)this + 16;
  do
  {
    uint64_t v15 = *(unsigned __int8 *)(a2 + v12 + 6);
    *((_DWORD *)v14 + 3) = v15;
    unsigned int v16 = *(unsigned __int8 *)(a2 + v12 + 9);
    *((_DWORD *)v14 + 4) = v16;
    if (v13 <= (int)v15) {
      b2Distance();
    }
    if (*(_DWORD *)(a5 + 24) <= (signed int)v16) {
      b2Distance();
    }
    int v17 = (float *)(*(void *)(a3 + 16) + 8 * v15);
    float v18 = v17[1];
    float v19 = (float *)(*(void *)(a5 + 16) + 8 * v16);
    float v20 = *v19;
    float v21 = v19[1];
    float v23 = a4[2];
    float v22 = a4[3];
    float v24 = *a4 + (float)((float)(v22 * *v17) - (float)(v23 * v18));
    float v25 = (float)((float)(v18 * v22) + (float)(v23 * *v17)) + a4[1];
    *((float *)v14 - 4) = v24;
    *((float *)v14 - 3) = v25;
    float v27 = a6[2];
    float v26 = a6[3];
    float v28 = *a6 + (float)((float)(v26 * v20) - (float)(v27 * v21));
    float v29 = (float)((float)(v21 * v26) + (float)(v27 * v20)) + a6[1];
    *((float *)v14 - 2) = v28;
    *((float *)v14 - 1) = v29;
    *(float *)int v14 = v28 - v24;
    *((float *)v14 + 1) = v29 - v25;
    *((_DWORD *)v14 + 2) = 0;
    ++v12;
    v14 += 36;
  }
  while (v6 != v12);
  if (v6 > 1)
  {
    float v30 = *(float *)a2;
    float Metric = b2Simplex::GetMetric(this);
    if (Metric < (float)(v30 * 0.5) || (float)(v30 + v30) < Metric || Metric < 0.00000011921)
    {
      *((_DWORD *)this + 27) = 0;
    }
    else if (*((_DWORD *)this + 27))
    {
      return;
    }
    goto LABEL_10;
  }
}

float32x2_t b2Simplex::GetClosestPoint(b2Simplex *this)
{
  switch(*((_DWORD *)this + 27))
  {
    case 0:
      b2Simplex::GetClosestPoint();
    case 1:
      float32x2_t result = *(float32x2_t *)((char *)this + 16);
      break;
    case 2:
      float32x2_t result = vadd_f32(vmul_n_f32(*(float32x2_t *)((char *)this + 16), *((float *)this + 6)), vmul_n_f32(*(float32x2_t *)((char *)this + 52), *((float *)this + 15)));
      break;
    case 3:
      {
        {
          b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
        }
      }
      float32x2_t result = (float32x2_t)b2Vec2_zero_fn(void)::b2Vec2_zero_init;
      break;
    default:
      b2Simplex::GetClosestPoint();
  }
  return result;
}

float b2Simplex::GetSearchDirection(b2Simplex *this)
{
  int v1 = *((_DWORD *)this + 27);
  if (v1 == 2)
  {
    float v3 = *((float *)this + 5);
    float result = *((float *)this + 14) - v3;
    if ((float)((float)(*((float *)this + 4) * result)
               - (float)((float)(*((float *)this + 13) - *((float *)this + 4)) * v3)) > 0.0)
      return -result;
  }
  else
  {
    if (v1 != 1) {
      b2Simplex::GetSearchDirection();
    }
    return -*((float *)this + 4);
  }
  return result;
}

uint64_t b2Simplex::GetWitnessPoints(uint64_t this, b2Vec2 *a2, b2Vec2 *a3)
{
  switch(*(_DWORD *)(this + 108))
  {
    case 0:
      b2Simplex::GetWitnessPoints();
    case 1:
      *a2 = *(b2Vec2 *)this;
      *a3 = *(b2Vec2 *)(this + 8);
      return this;
    case 2:
      *a2 = (b2Vec2)vadd_f32(vmul_n_f32(*(float32x2_t *)this, *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 36), *(float *)(this + 60)));
      b2Vec2 v3 = (b2Vec2)vadd_f32(vmul_n_f32(*(float32x2_t *)(this + 8), *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 44), *(float *)(this + 60)));
      goto LABEL_5;
    case 3:
      b2Vec2 v3 = (b2Vec2)vadd_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)this, *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 36), *(float *)(this + 60))), vmul_n_f32(*(float32x2_t *)(this + 72), *(float *)(this + 96)));
      *a2 = v3;
LABEL_5:
      *a3 = v3;
      return this;
    default:
      b2Simplex::GetWitnessPoints();
  }
}

void b2Simplex::WriteCache(int *a1, uint64_t a2)
{
  *(float *)a2 = b2Simplex::GetMetric((b2Simplex *)a1);
  int v4 = a1[27];
  *(_WORD *)(a2 + 4) = v4;
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = a1 + 8;
    do
    {
      uint64_t v7 = a2 + v5;
      *(unsigned char *)(v7 + 6) = *(v6 - 1);
      int v8 = *v6;
      v6 += 9;
      *(unsigned char *)(v7 + 9) = v8;
      ++v5;
    }
    while (v5 < a1[27]);
  }
}

float b2Simplex::GetMetric(b2Simplex *this)
{
  switch(*((_DWORD *)this + 27))
  {
    case 0:
      b2Simplex::GetMetric();
    case 1:
      float result = 0.0;
      break;
    case 2:
      float result = sqrtf((float)((float)(*((float *)this + 5) - *((float *)this + 14))* (float)(*((float *)this + 5) - *((float *)this + 14)))+ (float)((float)(*((float *)this + 4) - *((float *)this + 13))* (float)(*((float *)this + 4) - *((float *)this + 13))));
      break;
    case 3:
      float result = (float)((float)(*((float *)this + 13) - *((float *)this + 4))
                     * (float)(*((float *)this + 23) - *((float *)this + 5)))
             - (float)((float)(*((float *)this + 14) - *((float *)this + 5))
                     * (float)(*((float *)this + 22) - *((float *)this + 4)));
      break;
    default:
      b2Simplex::GetMetric();
  }
  return result;
}

void QuadTree::QuadTree(QuadTree *this, float a2, float a3, float a4, float a5, float a6)
{
}

{
  operator new();
}

void QuadTreeNode::QuadTreeNode(QuadTreeNode *this, float a2, float a3, float a4, float a5, float a6)
{
  *((float *)this + 8) = a2;
  *((float *)this + 9) = a3;
  *((float *)this + 10) = a4;
  *((float *)this + 11) = a5;
  *((float *)this + 12) = a6;
  *((unsigned char *)this + 52) = -1;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

{
  *((float *)this + 8) = a2;
  *((float *)this + 9) = a3;
  *((float *)this + 10) = a4;
  *((float *)this + 11) = a5;
  *((float *)this + 12) = a6;
  *((unsigned char *)this + 52) = -1;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

void QuadTree::~QuadTree(QuadTree *this)
{
  int v1 = *(QuadTreeNode ***)this;
  if (v1)
  {
    QuadTreeNode::~QuadTreeNode(v1);
    MEMORY[0x21668C8E0]();
  }
}

uint64_t QuadTree::add(QuadTree *this, float a2, float a3, char a4)
{
  return QuadTreeNode::add(*(void *)this, a2, a3, a4);
}

uint64_t QuadTreeNode::add(uint64_t this, float a2, float a3, char a4)
{
  uint64_t v6 = this;
  float v7 = *(float *)(this + 32);
  float v8 = *(float *)(this + 36) - v7;
  if (v8 > *(float *)(this + 48))
  {
    do
    {
      if ((float)(v7 + (float)(v8 * 0.5)) <= a2) {
        int v9 = 3;
      }
      else {
        int v9 = 2;
      }
      if ((float)(*(float *)(v6 + 40) + (float)((float)(*(float *)(v6 + 44) - *(float *)(v6 + 40)) * 0.5)) <= a3) {
        BOOL v10 = (float)(v7 + (float)(v8 * 0.5)) > a2;
      }
      else {
        BOOL v10 = v9;
      }
      this = *(void *)(v6 + 8 * v10);
      if (!this) {
        operator new();
      }
      float v12 = *(float *)(this + 32);
      float v11 = *(float *)(this + 36);
      float v8 = v11 - v12;
      BOOL v13 = (float)(v11 - v12) > *(float *)(this + 48);
      float v7 = *(float *)(this + 32);
      uint64_t v6 = *(void *)(v6 + 8 * v10);
    }
    while (v13);
  }
  *(unsigned char *)(this + 52) = a4;
  return this;
}

float *QuadTree::addLine(QuadTree *this, float a2, float a3, float a4, float a5, signed __int8 a6)
{
  return QuadTreeNode::addLine(*(float **)this, a2, a3, a4, a5, a6);
}

float *QuadTreeNode::addLine(float *this, float a2, float a3, float a4, float a5, signed __int8 a6)
{
  float v7 = a4;
  uint64_t v10 = (uint64_t)this;
  float v11 = this + 9;
  float v12 = this[9];
  BOOL v13 = this + 8;
  float v14 = this[8];
  float v15 = v12 - v14;
  if ((float)(v12 - v14) <= this[12])
  {
LABEL_95:
    *(unsigned char *)(v10 + 52) = a6;
  }
  else
  {
    float v16 = a5;
    float v107 = a5 - a3;
    float v108 = a4 - a2;
    float v17 = -(float)(a4 - a2);
    float v106 = -(float)(a5 - a3);
    float v18 = 1.0;
    while (1)
    {
      float v19 = *(float *)(v10 + 44);
      float v20 = v14 + (float)(v15 * 0.5);
      float v21 = *(float *)(v10 + 40) + (float)((float)(v19 - *(float *)(v10 + 40)) * 0.5);
      float v22 = v20 - v20;
      float v23 = v21 - v19;
      float v24 = v19 - a3;
      float v104 = v107 * (float)(v20 - v20);
      float v105 = v20 - a2;
      float v25 = v104 + (float)(v17 * (float)(v21 - v19));
      float v103 = (float)(v20 - a2) * v106;
      float v26 = v103 + (float)(v108 * (float)(v19 - a3));
      if ((float)(v26 / v25) <= v18 && (float)(v26 / v25) >= 0.0)
      {
        float v27 = (float)((float)(v22 * v24) - (float)(v23 * v105)) / v25;
        if (v27 >= 0.0 && v27 <= v18) {
          goto LABEL_98;
        }
      }
      float v29 = -v23;
      float v30 = (float)(v107 * (float)(v12 - v12)) + (float)(v17 * v23);
      float v31 = (float)((float)((float)(v12 - a2) * v106) + (float)(v108 * v24)) / v30;
      if (v31 <= v18 && v31 >= 0.0)
      {
        float v32 = (float)((float)((float)(v12 - v12) * v24) + (float)(v29 * (float)(v12 - a2))) / v30;
        if (v32 >= 0.0 && v32 <= v18) {
          goto LABEL_98;
        }
      }
      if ((float v34 = v12 - v20, v35 = (float)(v107 * v34) + (float)(v17 * (float)(v19 - v19)), v36 = v26 / v35, v36 <= v18)
        && v36 >= 0.0
        && (float v37 = (float)((float)(v34 * v24) - (float)((float)(v19 - v19) * v105)) / v35, v37 >= 0.0)
        && v37 <= v18
        || (float v38 = (float)(v107 * v34) + (float)(v17 * (float)(v21 - v21)),
            float v39 = (float)(v103 + (float)(v108 * (float)(v21 - a3))) / v38,
            v39 <= v18)
        && v39 >= 0.0
        && (float v40 = (float)((float)(v34 * (float)(v21 - a3)) - (float)((float)(v21 - v21) * v105)) / v38, v40 >= 0.0)
        && v40 <= v18)
      {
LABEL_98:
        if (!*(void *)v10) {
          operator new();
        }
        this = (float *)QuadTreeNode::addLine(*(QuadTreeNode **)v10, a2, a3, v7, v16, a6);
        float v14 = *v13;
        float v19 = *(float *)(v10 + 44);
        float v23 = v21 - v19;
        float v29 = -(float)(v21 - v19);
        float v24 = v19 - a3;
        float v18 = 1.0;
      }
      float v41 = v14 - a2;
      float v42 = (float)(v107 * (float)(v14 - v14)) + (float)(v17 * v23);
      float v43 = (float)(v14 - a2) * v106;
      float v44 = v43 + (float)(v108 * v24);
      if ((float)(v44 / v42) <= v18 && (float)(v44 / v42) >= 0.0)
      {
        float v45 = (float)((float)((float)(v14 - v14) * v24) + (float)(v29 * v41)) / v42;
        if (v45 >= 0.0 && v45 <= v18) {
          goto LABEL_50;
        }
      }
      float v47 = *v11 - *v11;
      float v48 = *v11 - a2;
      float v49 = (float)(v107 * v47) + (float)(v17 * v23);
      float v50 = (float)((float)(v48 * v106) + (float)(v108 * v24)) / v49;
      if (v50 <= v18 && v50 >= 0.0)
      {
        float v51 = (float)((float)(v24 * v47) + (float)(v29 * v48)) / v49;
        if (v51 >= 0.0 && v51 <= v18) {
          goto LABEL_50;
        }
      }
      float v53 = v20 - v14;
      float v54 = (float)(v107 * v53) + (float)(v17 * (float)(v19 - v19));
      float v55 = v44 / v54;
      if (v55 <= v18 && v55 >= 0.0)
      {
        float v56 = (float)((float)(v53 * v24) - (float)((float)(v19 - v19) * v41)) / v54;
        if (v56 >= 0.0 && v56 <= v18) {
          goto LABEL_50;
        }
      }
      float v57 = v21 - a3;
      float v58 = (float)(v107 * v53) + (float)(v17 * (float)(v21 - v21));
      float v59 = (float)(v43 + (float)(v108 * (float)(v21 - a3))) / v58;
      if (v59 <= v18 && v59 >= 0.0)
      {
        float v60 = (float)((float)(v57 * v53) - (float)((float)(v21 - v21) * v41)) / v58;
        if (v60 >= 0.0 && v60 <= v18)
        {
LABEL_50:
          uint64_t v61 = *(QuadTreeNode **)(v10 + 8);
          if (!v61) {
            operator new();
          }
          this = (float *)QuadTreeNode::addLine(v61, a2, a3, v7, v16, a6);
          float v57 = v21 - a3;
          float v18 = 1.0;
        }
      }
      float v62 = v16;
      float v63 = *(float *)(v10 + 40);
      float v64 = v63 - v21;
      float v65 = v22 * v57;
      float v66 = v104 + (float)(v17 * (float)(v63 - v21));
      float v67 = v103 + (float)(v108 * v57);
      if ((float)(v67 / v66) <= v18 && (float)(v67 / v66) >= 0.0)
      {
        float v68 = (float)(v65 - (float)(v64 * v105)) / v66;
        if (v68 >= 0.0 && v68 <= v18) {
          goto LABEL_72;
        }
      }
      float v70 = *v11;
      float v71 = *v11 - a2;
      float v72 = (float)(v107 * (float)(v70 - v70)) + (float)(v17 * v64);
      float v73 = (float)((float)(v71 * v106) + (float)(v108 * v57)) / v72;
      if (v73 <= v18 && v73 >= 0.0)
      {
        float v74 = (float)((float)(v57 * (float)(v70 - v70)) + (float)((float)-v64 * v71)) / v72;
        if (v74 >= 0.0 && v74 <= v18) {
          goto LABEL_72;
        }
      }
      if ((float v75 = v70 - v20,
            float v76 = v107 * (float)(v70 - v20),
            float v77 = v76 + (float)(v17 * (float)(v21 - v21)),
            (float)(v67 / v77) <= v18)
        && (float)(v67 / v77) >= 0.0
        && (float v78 = (float)((float)(v57 * v75) - (float)((float)(v21 - v21) * v105)) / v77, v78 >= 0.0)
        && v78 <= v18
        || (float v79 = v76 + (float)(v17 * (float)(v63 - v63)),
            float v80 = (float)(v103 + (float)(v108 * (float)(v63 - a3))) / v79,
            v80 <= v18)
        && v80 >= 0.0
        && (float v81 = (float)((float)((float)(v63 - a3) * v75) - (float)((float)(v63 - v63) * v105)) / v79, v81 >= 0.0)
        && v81 <= v18)
      {
LABEL_72:
        float v82 = *(QuadTreeNode **)(v10 + 16);
        if (!v82) {
          operator new();
        }
        this = (float *)QuadTreeNode::addLine(v82, a2, a3, a4, v62, a6);
        float v63 = *(float *)(v10 + 40);
        float v18 = 1.0;
      }
      float v83 = *v13;
      float v84 = *v13 - a2;
      float v85 = v20 - a3;
      float v86 = (float)(v107 * (float)(v83 - v83)) + (float)(v17 * (float)(v63 - v20));
      float v87 = (float)(v84 * v106) + (float)(v108 * (float)(v20 - a3));
      if ((float)(v87 / v86) > v18
        || (float)(v87 / v86) < 0.0
        || (float v88 = (float)((float)(v85 * (float)(v83 - v83)) - (float)((float)(v63 - v20) * v84)) / v86, v88 < 0.0)
        || v88 > v18)
      {
        float v89 = v104 + (float)(v17 * (float)(v63 - v21));
        if ((float)(v67 / v89) > v18
          || (float)(v67 / v89) < 0.0
          || (float v90 = (float)(v65 - (float)((float)(v63 - v21) * v105)) / v89, v90 < 0.0)
          || v90 > v18)
        {
          float v91 = v20 - v83;
          float v92 = (float)(v107 * v91) + (float)(v17 * (float)(v21 - v20));
          float v93 = v87 / v92;
          if (v93 > v18
            || v93 < 0.0
            || (float v94 = (float)((float)(v85 * v91) - (float)((float)(v21 - v20) * v84)) / v92, v94 < 0.0)
            || v94 > v18)
          {
            float v95 = v63 - v63;
            float v96 = v63 - a3;
            float v97 = (float)(v107 * v91) + (float)(v17 * (float)(v63 - v63));
            float v98 = (float)((float)(v84 * v106) + (float)(v108 * v96)) / v97;
            if (v98 > v18) {
              break;
            }
            if (v98 < 0.0) {
              break;
            }
            float v99 = (float)((float)(v91 * v96) - (float)(v95 * v84)) / v97;
            if (v99 < 0.0 || v99 > v18) {
              break;
            }
          }
        }
      }
      float v100 = *(float **)(v10 + 24);
      if (!v100) {
        operator new();
      }
      float v101 = v100[8];
      float v12 = v100[9];
      uint64_t v10 = *(void *)(v10 + 24);
      float v16 = v62;
      float v7 = a4;
      float v11 = (float *)(v10 + 36);
      BOOL v13 = (float *)(v10 + 32);
      float v15 = v12 - v101;
      float v14 = v100[8];
      if ((float)(v12 - v101) <= v100[12]) {
        goto LABEL_95;
      }
    }
  }
  return this;
}

uint64_t QuadTree::find(QuadTree *this, float a2, float a3, QuadTreeNode ***a4)
{
  return QuadTreeNode::find(*(QuadTreeNode ***)this, a2, a3, a4);
}

uint64_t QuadTreeNode::find(QuadTreeNode **this, float a2, float a3, QuadTreeNode ***a4)
{
  *a4 = this;
  if (*((float *)this + 8) > a2
    || *((float *)this + 9) < a2
    || *((float *)this + 10) > a3
    || *((float *)this + 11) < a3)
  {
    return 0;
  }
  int v9 = *this;
  if (!*this)
  {
    uint64_t v10 = this[1];
    if (!v10)
    {
      if (!this[2] && !this[3]) {
        return 1;
      }
      goto LABEL_15;
    }
LABEL_11:
    if (QuadTreeNode::find(v10, a2, a3, (QuadTreeNode **)a4)) {
      return 1;
    }
    goto LABEL_15;
  }
  if (QuadTreeNode::find(v9, a2, a3, (QuadTreeNode **)a4)) {
    return 1;
  }
  uint64_t v10 = this[1];
  if (v10) {
    goto LABEL_11;
  }
LABEL_15:
  float v11 = this[2];
  if (!v11 || (QuadTreeNode::find(v11, a2, a3, (QuadTreeNode **)a4) & 1) == 0)
  {
    float v12 = this[3];
    if (!v12 || (QuadTreeNode::find(v12, a2, a3, (QuadTreeNode **)a4) & 1) == 0) {
      return 0;
    }
  }
  return 1;
}

BOOL QuadTree::intersectPoint(QuadTree *this, float a2, float a3, QuadTreeNode **a4)
{
  float v8 = 0;
  int v9 = 0;
  uint64_t v10 = 0;
  QuadTree::intersectBox((uint64_t *)this, (uint64_t)&v8, a2, a3, a2, a3);
  uint64_t v5 = v8;
  uint64_t v6 = v9;
  if (v9 != v8)
  {
    *a4 = *v8;
LABEL_4:
    int v9 = v5;
    operator delete(v5);
    return v6 != v5;
  }
  if (v9) {
    goto LABEL_4;
  }
  return v6 != v5;
}

void sub_21356F170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL QuadTree::intersectBox(uint64_t *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  QuadTreeNode::intersectBox(*a1, (void **)a2, a3, a4, a5, a6);
  float v7 = *(void **)(a2 + 8);
  if (v7 == *(void **)a2)
  {
    float v8 = *(void **)(a2 + 8);
  }
  else
  {
    printf("--- %lu\n", ((uint64_t)v7 - *(void *)a2) >> 3);
    float v7 = *(void **)a2;
    float v8 = *(void **)(a2 + 8);
  }
  return v8 != v7;
}

uint64_t QuadTreeNode::intersectBox(uint64_t a1, void **a2, float a3, float a4, float a5, float a6)
{
  if (*(float *)(a1 + 32) <= a5)
  {
    uint64_t v14 = a1;
    int v7 = 0;
    while (1)
    {
      if (*(float *)(v14 + 36) < a3 || *(float *)(v14 + 40) > a6 || *(float *)(v14 + 44) < a4) {
        goto LABEL_3;
      }
      if (*(void *)v14) {
        break;
      }
      uint64_t v15 = *(void *)(v14 + 8);
      if (v15) {
        goto LABEL_13;
      }
      if (!*(void *)(v14 + 16) && !*(void *)(v14 + 24))
      {
        unint64_t v17 = (unint64_t)a2[2];
        float v18 = a2[1];
        if ((unint64_t)v18 >= v17)
        {
          uint64_t v20 = ((char *)v18 - (unsigned char *)*a2) >> 3;
          if ((unint64_t)(v20 + 1) >> 61) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v21 = v17 - (void)*a2;
          uint64_t v22 = v21 >> 2;
          if (v21 >> 2 <= (unint64_t)(v20 + 1)) {
            uint64_t v22 = v20 + 1;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v22;
          }
          if (v23) {
            float v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v23);
          }
          else {
            float v24 = 0;
          }
          float v25 = &v24[8 * v20];
          float v26 = &v24[8 * v23];
          *(void *)float v25 = v14;
          float v19 = v25 + 8;
          float v28 = (char *)*a2;
          float v27 = (char *)a2[1];
          if (v27 != *a2)
          {
            do
            {
              uint64_t v29 = *((void *)v27 - 1);
              v27 -= 8;
              *((void *)v25 - 1) = v29;
              v25 -= 8;
            }
            while (v27 != v28);
            float v27 = (char *)*a2;
          }
          *a2 = v25;
          a2[1] = v19;
          a2[2] = v26;
          if (v27) {
            operator delete(v27);
          }
        }
        else
        {
          *float v18 = v14;
          float v19 = v18 + 1;
        }
        a2[1] = v19;
        int v8 = 1;
        return v8 & (v7 ^ 1u);
      }
LABEL_14:
      uint64_t v16 = *(void *)(v14 + 16);
      if (v16) {
        QuadTreeNode::intersectBox(v16, a2, a3, a4, a5, a6);
      }
      uint64_t v14 = *(void *)(v14 + 24);
      if (v14)
      {
        int v7 = 1;
        if (*(float *)(v14 + 32) <= a5) {
          continue;
        }
      }
      goto LABEL_3;
    }
    QuadTreeNode::intersectBox(*(void *)v14, a2, a3, a4, a5, a6);
    uint64_t v15 = *(void *)(v14 + 8);
    if (!v15) {
      goto LABEL_14;
    }
LABEL_13:
    QuadTreeNode::intersectBox(v15, a2, a3, a4, a5, a6);
    goto LABEL_14;
  }
  int v7 = 0;
LABEL_3:
  int v8 = 0;
  return v8 & (v7 ^ 1u);
}

BOOL QuadTree::intersectRay(QuadTree *this, float a2, float a3, float a4, float a5, QuadTreeNode **a6)
{
  return QuadTree::intersectVector(this, a2, a3, a4 - a2, a5 - a3, a6);
}

BOOL QuadTree::intersectVector(QuadTree *this, float a2, float a3, float a4, float a5, QuadTreeNode **a6)
{
  __p = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  BOOL v9 = QuadTreeNode::intersectVector(*(QuadTreeNode **)this, &__p, a2, a3, a4, a5);
  uint64_t v10 = __p;
  if (v9 && (unint64_t)(v21 - (unsigned char *)__p) >= 9)
  {
    float v11 = 0;
    uint64_t v12 = 2;
    if ((unint64_t)((v21 - (unsigned char *)__p) >> 3) > 2) {
      uint64_t v12 = (v21 - (unsigned char *)__p) >> 3;
    }
    BOOL v13 = (float **)((char *)__p + 8);
    uint64_t v14 = v12 - 1;
    do
    {
      uint64_t v16 = *v13++;
      uint64_t v15 = v16;
      float v17 = a2 - (float)((float)(v16[8] + v16[9]) * 0.5);
      float v18 = a3 - (float)((float)(v16[10] + v16[11]) * 0.5);
      if ((float)((float)(v18 * v18) + (float)(v17 * v17)) < 3.4028e38) {
        float v11 = (QuadTreeNode *)v15;
      }
      --v14;
    }
    while (v14);
    *a6 = v11;
    goto LABEL_11;
  }
  *a6 = 0;
  if (v10)
  {
LABEL_11:
    uint64_t v21 = v10;
    operator delete(v10);
  }
  return v9;
}

void sub_21356F4BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL QuadTreeNode::intersectVector(QuadTreeNode *a1, void **a2, float a3, float a4, float a5, float a6)
{
  BOOL result = QuadTreeNode::intersectVectorSelf(a1, a3, a4, a5, a6);
  if (!result) {
    return result;
  }
  if (*(void *)a1)
  {
    if (QuadTreeNode::intersectVectorSelf(*(QuadTreeNode **)a1, a3, a4, a5, a6)) {
      return 1;
    }
    BOOL v13 = (QuadTreeNode *)*((void *)a1 + 1);
    if (!v13) {
      goto LABEL_11;
    }
  }
  else
  {
    BOOL v13 = (QuadTreeNode *)*((void *)a1 + 1);
    if (!v13)
    {
      if (!*((void *)a1 + 2) && !*((void *)a1 + 3))
      {
        unint64_t v16 = (unint64_t)a2[2];
        float v17 = (QuadTreeNode **)a2[1];
        if ((unint64_t)v17 >= v16)
        {
          uint64_t v19 = ((char *)v17 - (unsigned char *)*a2) >> 3;
          if ((unint64_t)(v19 + 1) >> 61) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v20 = v16 - (void)*a2;
          uint64_t v21 = v20 >> 2;
          if (v20 >> 2 <= (unint64_t)(v19 + 1)) {
            uint64_t v21 = v19 + 1;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v21;
          }
          if (v22) {
            unint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v22);
          }
          else {
            unint64_t v23 = 0;
          }
          float v24 = (QuadTreeNode **)&v23[8 * v19];
          float v25 = &v23[8 * v22];
          *float v24 = a1;
          float v18 = v24 + 1;
          float v27 = (char *)*a2;
          float v26 = (char *)a2[1];
          if (v26 != *a2)
          {
            do
            {
              float v28 = (QuadTreeNode *)*((void *)v26 - 1);
              v26 -= 8;
              *--float v24 = v28;
            }
            while (v26 != v27);
            float v26 = (char *)*a2;
          }
          *a2 = v24;
          a2[1] = v18;
          a2[2] = v25;
          if (v26) {
            operator delete(v26);
          }
        }
        else
        {
          float *v17 = a1;
          float v18 = v17 + 1;
        }
        a2[1] = v18;
        return 1;
      }
      goto LABEL_11;
    }
  }
  if (QuadTreeNode::intersectVectorSelf(v13, a3, a4, a5, a6)) {
    return 1;
  }
LABEL_11:
  uint64_t v14 = (QuadTreeNode *)*((void *)a1 + 2);
  if (v14 && QuadTreeNode::intersectVectorSelf(v14, a3, a4, a5, a6)) {
    return 1;
  }
  uint64_t v15 = (QuadTreeNode *)*((void *)a1 + 3);
  if (v15)
  {
    if (QuadTreeNode::intersectVectorSelf(v15, a3, a4, a5, a6)) {
      return 1;
    }
  }
  return 0;
}

float QuadTree::bounds(QuadTree *this, float *a2, float *a3, float *a4, float *a5)
{
  uint64_t v5 = *(float **)this;
  *a2 = *(float *)(*(void *)this + 32);
  *a3 = v5[10];
  *a4 = v5[9];
  float result = v5[11];
  *a5 = result;
  return result;
}

uint64_t QuadTree::leafCount(QuadTree *this)
{
  return 0;
}

uint64_t QuadTreeNode::leafCount(QuadTreeNode *this)
{
  return 0;
}

void QuadTreeNode::~QuadTreeNode(QuadTreeNode **this)
{
  float v2 = *this;
  if (v2)
  {
    QuadTreeNode::~QuadTreeNode(v2);
    MEMORY[0x21668C8E0]();
  }
  b2Vec2 v3 = this[1];
  if (v3)
  {
    QuadTreeNode::~QuadTreeNode(v3);
    MEMORY[0x21668C8E0]();
  }
  int v4 = this[2];
  if (v4)
  {
    QuadTreeNode::~QuadTreeNode(v4);
    MEMORY[0x21668C8E0]();
  }
  uint64_t v5 = this[3];
  if (v5)
  {
    QuadTreeNode::~QuadTreeNode(v5);
    MEMORY[0x21668C8E0]();
  }
}

uint64_t get_line_intersection(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float *a9, float *a10)
{
  uint64_t result = 0;
  float v12 = a3 - a1;
  float v13 = a4 - a2;
  float v14 = a7 - a5;
  float v15 = a8 - a6;
  float v16 = a1 - a5;
  float v17 = a2 - a6;
  float v18 = (float)(v12 * v15) - (float)(v14 * v13);
  float v19 = (float)((float)(v14 * v17) - (float)(v15 * v16)) / v18;
  if (v19 <= 1.0 && v19 >= 0.0)
  {
    float v20 = (float)((float)(v12 * v17) - (float)(v13 * v16)) / v18;
    if (v20 >= 0.0 && v20 <= 1.0)
    {
      if (a9) {
        *a9 = a1 + (float)(v19 * v12);
      }
      if (a10) {
        *a10 = a2 + (float)(v19 * v13);
      }
      return 1;
    }
  }
  return result;
}

void *QuadTreeNode::visitLeaves(void *result, uint64_t a2)
{
  b2Vec2 v3 = result;
  unsigned char v14[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = *result;
  if (*result)
  {
    std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
    QuadTreeNode::visitLeaves(v4, v14);
    uint64_t result = std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](v14);
    uint64_t v5 = v3[1];
    if (!v5) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v5 = result[1];
  if (v5)
  {
LABEL_5:
    std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v13, a2);
    QuadTreeNode::visitLeaves(v5, v13);
    uint64_t result = std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](v13);
LABEL_6:
    uint64_t v6 = v3[2];
    if (v6)
    {
      std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v12, a2);
      QuadTreeNode::visitLeaves(v6, v12);
      uint64_t result = std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](v12);
    }
    uint64_t v7 = v3[3];
    if (v7)
    {
      std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v11, a2);
      QuadTreeNode::visitLeaves(v7, v11);
      return std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](v11);
    }
    return result;
  }
  if (result[2] || result[3]) {
    goto LABEL_6;
  }
  int v8 = *((char *)result + 52);
  float v9 = *((float *)result + 8) + (float)((float)(*((float *)result + 9) - *((float *)result + 8)) * 0.5);
  float v10 = *((float *)result + 10) + (float)((float)(*((float *)result + 11) - *((float *)result + 10)) * 0.5);

  return (void *)std::function<void ()(float,float,int)>::operator()(a2, v8, v9, v10);
}

void sub_21356F990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(float,float,int)>::~__value_func[abi:ne180100](va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(float,float,int)>::operator()(uint64_t a1, int a2, float a3, float a4)
{
  float v8 = a3;
  float v7 = a4;
  int v6 = a2;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *, float *, int *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

BOOL QuadTreeNode::intersectVectorSelf(QuadTreeNode *this, float a2, float a3, float a4, float a5)
{
  float v6 = *((float *)this + 8);
  float v5 = *((float *)this + 9);
  float v8 = *((float *)this + 10);
  float v7 = *((float *)this + 11);
  if (fabsf(a4) >= 0.00000011921)
  {
    BOOL result = 0;
    float v13 = (float)(v6 - a2) / a4;
    float v14 = (float)(v5 - a2) / a4;
    if (v14 >= v13) {
      float v15 = v13;
    }
    else {
      float v15 = v14;
    }
    if (v13 >= v14) {
      float v14 = v13;
    }
    float v11 = fmaxf(v15, -3.4028e38);
    float v10 = fminf(v14, 3.4028e38);
    if (v11 > v10 || v10 < 0.0) {
      return result;
    }
  }
  else
  {
    if (v6 > a2 || v5 < a2) {
      return 0;
    }
    float v10 = 3.4028e38;
    float v11 = -3.4028e38;
  }
  if (fabsf(a5) < 0.00000011921) {
    return v8 <= a3 && v7 >= a3;
  }
  BOOL result = 0;
  float v17 = (float)(v8 - a3) / a5;
  float v18 = (float)(v7 - a3) / a5;
  if (v18 >= v17) {
    float v19 = v17;
  }
  else {
    float v19 = v18;
  }
  if (v17 >= v18) {
    float v18 = v17;
  }
  if (v19 > v11) {
    float v11 = v19;
  }
  if (v18 < v10) {
    float v10 = v18;
  }
  if (v11 <= v10 && v10 >= 0.0) {
    return 1;
  }
  return result;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  JUMPOUT(0x21668C8E0);
}

void b2DynamicTree::b2DynamicTree(b2DynamicTree *this)
{
  *(_DWORD *)this = -1;
  *((void *)this + 2) = 0x1000000000;
  float v2 = b2Alloc(768);
  *((void *)this + 1) = v2;
  bzero(v2, 48 * *((int *)this + 5));
  uint64_t v3 = *((int *)this + 5);
  uint64_t v4 = *((void *)this + 1);
  if ((int)v3 < 2)
  {
    uint64_t v7 = v3 - 1;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      *(_DWORD *)(v4 + v5 + 32) = ++v6;
      uint64_t v4 = *((void *)this + 1);
      *(_DWORD *)(v4 + v5 + 44) = -1;
      uint64_t v7 = *((int *)this + 5) - 1;
      v5 += 48;
    }
    while (v6 < v7);
  }
  *(_DWORD *)(v4 + 48 * v7 + 32) = -1;
  *(_DWORD *)(*((void *)this + 1) + 48 * *((int *)this + 5) - 4) = -1;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
}

void b2DynamicTree::~b2DynamicTree(void **this)
{
}

{
  b2Free(this[1]);
}

double b2DynamicTree::AllocateNode(b2DynamicTree *this)
{
  int v2 = *((_DWORD *)this + 6);
  if (v2 == -1)
  {
    int v4 = *((_DWORD *)this + 4);
    if (v4 != *((_DWORD *)this + 5)) {
      b2DynamicTree::AllocateNode();
    }
    uint64_t v5 = (void *)*((void *)this + 1);
    *((_DWORD *)this + 5) = 2 * v4;
    uint64_t v6 = b2Alloc(96 * v4);
    *((void *)this + 1) = v6;
    memcpy(v6, v5, 48 * *((int *)this + 4));
    b2Free(v5);
    uint64_t v7 = *((int *)this + 4);
    uint64_t v8 = *((int *)this + 5) - 1;
    uint64_t v9 = *((void *)this + 1);
    if ((int)v7 < (int)v8)
    {
      uint64_t v10 = 48 * v7;
      int v11 = v7 + 1;
      do
      {
        ++v7;
        *(_DWORD *)(v9 + v10 + 32) = v11;
        uint64_t v9 = *((void *)this + 1);
        *(_DWORD *)(v9 + v10 + 44) = -1;
        uint64_t v8 = *((int *)this + 5) - 1;
        v10 += 48;
        ++v11;
      }
      while (v7 < v8);
    }
    *(_DWORD *)(v9 + 48 * v8 + 32) = -1;
    uint64_t v3 = *((void *)this + 1);
    int v2 = *((_DWORD *)this + 4);
    *(_DWORD *)(v3 + 48 * *((int *)this + 5) - 4) = -1;
    *((_DWORD *)this + 6) = v2;
  }
  else
  {
    uint64_t v3 = *((void *)this + 1);
  }
  uint64_t v12 = v3 + 48 * v2;
  *((_DWORD *)this + 6) = *(_DWORD *)(v12 + 32);
  *(_DWORD *)(v12 + 32) = -1;
  uint64_t v13 = *((void *)this + 1) + 48 * v2;
  double result = NAN;
  *(void *)(v13 + 36) = -1;
  *(_DWORD *)(v13 + 44) = 0;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = 0;
  ++*((_DWORD *)this + 4);
  return result;
}

uint64_t b2DynamicTree::FreeNode(uint64_t this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(this + 20) <= (signed int)a2) {
    b2DynamicTree::FreeNode();
  }
  if (*(int *)(this + 16) <= 0) {
    b2DynamicTree::FreeNode();
  }
  *(_DWORD *)(*(void *)(this + 8) + 48 * a2 + 32) = *(_DWORD *)(this + 24);
  *(_DWORD *)(*(void *)(this + 8) + 48 * a2 + 44) = -1;
  *(_DWORD *)(this + 24) = a2;
  --*(_DWORD *)(this + 16);
  return this;
}

uint64_t b2DynamicTree::CreateProxyId(b2DynamicTree *a1, float32x2_t *a2)
{
  b2DynamicTree::AllocateNode(a1);
  uint64_t v5 = v4;
  uint64_t v6 = (float32x2_t *)(*((void *)a1 + 1) + 48 * (int)v4);
  float32x2_t *v6 = vadd_f32(*a2, (float32x2_t)vdup_n_s32(0xBDCCCCCD));
  v6[1] = vadd_f32(a2[1], (float32x2_t)vdup_n_s32(0x3DCCCCCDu));
  float32x2_t v7 = *(float32x2_t *)(*(void *)&a2[2] + 24);
  v6[2] = (float32x2_t)a2;
  v6[3] = v7;
  v6[5].i32[1] = 0;
  b2DynamicTree::InsertLeaf(a1, v4);
  return v5;
}

void b2DynamicTree::InsertLeaf(b2DynamicTree *this, int a2)
{
  ++*((_DWORD *)this + 8);
  int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == -1)
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(*((void *)this + 1) + 48 * a2 + 32) = -1;
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    uint64_t v7 = 48 * a2;
    int8x16_t v8 = *(int8x16_t *)(v5 + v7);
    LODWORD(v9) = HIDWORD(*(void *)(v5 + v7));
    LODWORD(v10) = *(void *)(v5 + v7 + 8);
    float32x2_t v11 = (float32x2_t)vextq_s8(v8, v8, 8uLL).u64[0];
    do
    {
      int v12 = v4;
      uint64_t v13 = v4;
      int v4 = *(_DWORD *)(v5 + 48 * v4 + 36);
      if (v4 == -1) {
        break;
      }
      uint64_t v14 = v5 + 48 * (int)v13;
      int v15 = *(_DWORD *)(v14 + 40);
      float v16 = *(float *)(v14 + 8);
      float v17 = *(float *)(v14 + 12);
      float v18 = *(float *)v14;
      float v19 = *(float *)(v14 + 4);
      float v20 = (float)((float)(v16 - *(float *)v14) + (float)(v17 - v19))
          + (float)((float)(v16 - *(float *)v14) + (float)(v17 - v19));
      if (*(float *)v14 >= *(float *)v8.i32) {
        float v18 = *(float *)v8.i32;
      }
      if (v19 >= v9) {
        float v19 = v9;
      }
      if (v16 <= v10) {
        float v16 = v10;
      }
      if (v17 <= *(float *)&v8.i32[3]) {
        float v17 = *(float *)&v8.i32[3];
      }
      float v21 = (float)((float)(v16 - v18) + (float)(v17 - v19)) + (float)((float)(v16 - v18) + (float)(v17 - v19));
      float v22 = v21 + v21;
      float v23 = (float)(v21 - v20) + (float)(v21 - v20);
      uint64_t v24 = v5 + 48 * v4;
      float v25 = *(float *)(v24 + 4);
      if (*(float *)v8.i32 >= *(float *)v24) {
        float v26 = *(float *)v24;
      }
      else {
        float v26 = *(float *)v8.i32;
      }
      if (v9 >= v25) {
        float v27 = *(float *)(v24 + 4);
      }
      else {
        float v27 = v9;
      }
      float v28 = *(float *)(v24 + 8);
      float v29 = *(float *)(v24 + 12);
      if (v10 <= v28) {
        float v30 = *(float *)(v24 + 8);
      }
      else {
        float v30 = v10;
      }
      if (*(float *)&v8.i32[3] <= v29) {
        float v31 = *(float *)(v24 + 12);
      }
      else {
        float v31 = *(float *)&v8.i32[3];
      }
      float v32 = (float)((float)((float)(v30 - v26) + (float)(v31 - v27)) + (float)((float)(v30 - v26) + (float)(v31 - v27)))
          - (float)((float)((float)(v28 - *(float *)v24) + (float)(v29 - v25))
                  + (float)((float)(v28 - *(float *)v24) + (float)(v29 - v25)));
      if (*(_DWORD *)(v24 + 36) == -1) {
        float v32 = (float)((float)(v30 - v26) + (float)(v31 - v27)) + (float)((float)(v30 - v26) + (float)(v31 - v27));
      }
      float v33 = v23 + v32;
      float v34 = (float32x2_t *)(v5 + 48 * v15);
      float32x2_t v35 = v34[1];
      float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v34, *(float32x2_t *)v8.i8), *(int8x8_t *)v8.i8, (int8x8_t)*v34);
      float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v11, v35), (int8x8_t)v11, (int8x8_t)v35);
      float32x2_t v38 = vadd_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)v37, (int32x2_t)v35), (float32x2_t)vzip1_s32((int32x2_t)v36, (int32x2_t)*v34)), vsub_f32((float32x2_t)vzip2_s32((int32x2_t)v37, (int32x2_t)v35), (float32x2_t)vzip2_s32((int32x2_t)v36, (int32x2_t)*v34)));
      float32x2_t v39 = vadd_f32(v38, v38);
      LODWORD(v40) = vsub_f32(v39, (float32x2_t)vdup_lane_s32((int32x2_t)v39, 1)).u32[0];
      v35.f32[0] = vaddv_f32(vsub_f32(v37, v36));
      float v41 = v35.f32[0] + v35.f32[0];
      if (v34[4].i32[1] == -1) {
        float v40 = v41;
      }
      float v42 = v23 + v40;
      if (v33 >= v42) {
        int v4 = v15;
      }
    }
    while (v22 >= v33 || v22 >= v42);
    int v44 = *(_DWORD *)(v5 + 48 * v13 + 32);
    int8x16_t v71 = v8;
    b2DynamicTree::AllocateNode(this);
    *(_DWORD *)(*((void *)this + 1) + 48 * v45 + 32) = v44;
    uint64_t v46 = *((void *)this + 1);
    float v47 = (int8x16_t *)(v46 + 48 * v45);
    float v48 = (int8x16_t *)(v46 + 48 * v13);
    v47[1].i64[0] = 0;
    v47[1].i64[1] = 0;
    v49.i64[0] = v71.i64[0];
    v49.i64[1] = v48->i64[1];
    v50.i64[0] = v48->i64[0];
    v50.i64[1] = v71.i64[1];
    *float v47 = vbslq_s8((int8x16_t)vcgtq_f32(v50, v49), v71, *v48);
    v47[2].i32[3] = v48[2].i32[3] + 1;
    if (v44 == -1)
    {
      uint64_t v54 = v46 + 48 * v45;
      *(_DWORD *)(v54 + 36) = v12;
      *(_DWORD *)(v54 + 40) = a2;
      *(_DWORD *)(v46 + 48 * (int)v13 + 32) = v45;
      *(_DWORD *)(*((void *)this + 1) + 48 * a2 + 32) = v45;
      float v55 = this;
    }
    else
    {
      uint64_t v51 = v46 + 48 * v44;
      int v53 = *(_DWORD *)(v51 + 36);
      float v52 = (_DWORD *)(v51 + 36);
      if (v53 == v12) {
        _DWORD *v52 = v45;
      }
      else {
        *(_DWORD *)(v46 + 48 * v44 + 40) = v45;
      }
      uint64_t v56 = v46 + 48 * v45;
      *(_DWORD *)(v56 + 36) = v12;
      *(_DWORD *)(v56 + 40) = a2;
      *(_DWORD *)(v46 + 48 * (int)v13 + 32) = v45;
      float v55 = (b2DynamicTree *)(*((void *)this + 1) + 48 * a2 + 32);
    }
    *(_DWORD *)float v55 = v45;
    for (uint64_t i = (int8x16_t *)(*((void *)this + 1) + 48 * a2); ; *uint64_t i = vbslq_s8((int8x16_t)vcgtq_f32(v70, v69), v67, v68))
    {
      uint64_t v58 = i[2].u32[0];
      if (v58 == -1) {
        break;
      }
      int v59 = b2DynamicTree::Balance(this, v58);
      uint64_t v60 = *((void *)this + 1);
      uint64_t v61 = v60 + 48 * v59;
      int v62 = *(_DWORD *)(v61 + 36);
      if (v62 == -1) {
        b2DynamicTree::InsertLeaf();
      }
      int v63 = *(_DWORD *)(v61 + 40);
      if (v63 == -1) {
        b2DynamicTree::InsertLeaf();
      }
      float v64 = (int8x16_t *)(v60 + 48 * v62);
      __int32 v65 = v64[2].i32[3];
      float v66 = (int8x16_t *)(v60 + 48 * v63);
      if (v65 <= v66[2].i32[3]) {
        __int32 v65 = v66[2].i32[3];
      }
      uint64_t i = (int8x16_t *)(v60 + 48 * v59);
      int8x16_t v67 = *v64;
      int8x16_t v68 = *v66;
      v69.i64[0] = v64->i64[0];
      v69.i64[1] = v66->i64[1];
      v70.i64[0] = v66->i64[0];
      v70.i64[1] = v64->i64[1];
      i[2].i32[3] = v65 + 1;
    }
  }
}

uint64_t b2DynamicTree::DestroyProxy(b2DynamicTree *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2) {
    b2DynamicTree::DestroyProxy();
  }
  if (*(_DWORD *)(*((void *)this + 1) + 48 * a2 + 36) != -1) {
    b2DynamicTree::DestroyProxy();
  }
  b2DynamicTree::RemoveLeaf(this, a2);

  return b2DynamicTree::FreeNode((uint64_t)this, a2);
}

b2DynamicTree *b2DynamicTree::RemoveLeaf(b2DynamicTree *this, int a2)
{
  int v2 = this;
  if (*(_DWORD *)this == a2)
  {
    *(_DWORD *)this = -1;
  }
  else
  {
    uint64_t v4 = *((void *)this + 1);
    signed int v5 = *(_DWORD *)(v4 + 48 * a2 + 32);
    uint64_t v6 = v4 + 48 * v5;
    uint64_t v8 = *(unsigned int *)(v6 + 32);
    int v7 = *(_DWORD *)(v6 + 36);
    if (v7 == a2) {
      int v7 = *(_DWORD *)(v4 + 48 * v5 + 40);
    }
    if (v8 == -1)
    {
      *(_DWORD *)this = v7;
      *(_DWORD *)(v4 + 48 * v7 + 32) = -1;
      return (b2DynamicTree *)b2DynamicTree::FreeNode((uint64_t)this, v5);
    }
    else
    {
      uint64_t v9 = v4 + 48 * (int)v8;
      int v11 = *(_DWORD *)(v9 + 36);
      float v10 = (_DWORD *)(v9 + 36);
      if (v11 == v5) {
        _DWORD *v10 = v7;
      }
      else {
        *(_DWORD *)(v4 + 48 * (int)v8 + 40) = v7;
      }
      *(_DWORD *)(v4 + 48 * v7 + 32) = v8;
      b2DynamicTree::FreeNode((uint64_t)this, v5);
      do
      {
        this = (b2DynamicTree *)b2DynamicTree::Balance(v2, v8);
        uint64_t v12 = *((void *)v2 + 1);
        uint64_t v13 = (int8x16_t *)(v12 + 48 * (int)this);
        uint64_t v8 = v13[2].u32[0];
        uint64_t v14 = (int8x16_t *)(v12 + 48 * v13[2].i32[1]);
        int v15 = (int8x16_t *)(v12 + 48 * v13[2].i32[2]);
        v16.i64[0] = v14->i64[0];
        v16.i64[1] = v15->i64[1];
        v17.i64[0] = v15->i64[0];
        v17.i64[1] = v14->i64[1];
        *uint64_t v13 = vbslq_s8((int8x16_t)vcgtq_f32(v17, v16), *v14, *v15);
        __int32 v18 = v15[2].i32[3];
        if (v14[2].i32[3] > v18) {
          __int32 v18 = v14[2].i32[3];
        }
        v13[2].i32[3] = v18 + 1;
      }
      while (v8 != -1);
    }
  }
  return this;
}

uint64_t b2DynamicTree::MoveProxy(b2DynamicTree *this, unsigned int a2, float32x4_t *a3, float32x2_t *a4)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2) {
    b2DynamicTree::MoveProxy();
  }
  uint64_t v6 = *((void *)this + 1) + 48 * a2;
  if (*(_DWORD *)(v6 + 36) != -1) {
    b2DynamicTree::MoveProxy();
  }
  if (*(float *)v6 <= a3->f32[0]
    && *(float *)(v6 + 4) <= a3->f32[1]
    && a3->f32[2] <= *(float *)(v6 + 8)
    && a3->f32[3] <= *(float *)(v6 + 12))
  {
    return 0;
  }
  b2DynamicTree::RemoveLeaf(this, a2);
  float32x2_t v10 = vadd_f32(*a4, *a4);
  int16x4_t v11 = (int16x4_t)vcltz_f32(v10);
  v12.i64[0] = 0x8000000080000000;
  *(float32x2_t *)v13.i8 = v10;
  v13.i64[1] = 0x8000000080000000;
  v12.u64[1] = (unint64_t)v10;
  *(float32x4_t *)(*((void *)this + 1) + 48 * a2) = vaddq_f32(vaddq_f32(*a3, (float32x4_t)xmmword_21359AEE0), (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vuzp1_s16(v11, v11)), v13, v12));
  b2DynamicTree::InsertLeaf(this, a2);
  return 1;
}

uint64_t b2DynamicTree::Balance(b2DynamicTree *this, uint64_t a2)
{
  if (a2 == -1) {
    b2DynamicTree::Balance();
  }
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = (float32x2_t *)(v2 + 48 * (int)a2);
  signed int v5 = (int *)&v3[4] + 1;
  uint64_t v4 = v3[4].u32[1];
  if (v3[4].i32[1] != -1)
  {
    uint64_t v6 = v2 + 48 * (int)a2;
    int v8 = *(_DWORD *)(v6 + 44);
    int v7 = (_DWORD *)(v6 + 44);
    if (v8 >= 2)
    {
      if ((v4 & 0x80000000) != 0 || (int v9 = *((_DWORD *)this + 5), (int)v4 >= v9)) {
        b2DynamicTree::Balance();
      }
      uint64_t v10 = v2 + 48 * (int)a2;
      unsigned int v13 = *(_DWORD *)(v10 + 40);
      int16x4_t v11 = (int *)(v10 + 40);
      uint64_t v12 = v13;
      if ((v13 & 0x80000000) != 0 || (int)v12 >= v9) {
        b2DynamicTree::Balance();
      }
      uint64_t v14 = (float32x2_t *)(v2 + 48 * v12);
      float32x4_t v16 = (_DWORD *)&v14[5] + 1;
      __int32 v15 = v14[5].i32[1];
      float32x4_t v17 = (float32x2_t *)(v2 + 48 * v4);
      __int32 v18 = v17[5].i32[1];
      if (v15 - v18 >= 2)
      {
        uint64_t v19 = v2 + 48 * v12;
        int v22 = *(_DWORD *)(v19 + 36);
        float v20 = (_DWORD *)(v19 + 36);
        int v21 = v22;
        if (v22 < 0 || v21 >= v9) {
          b2DynamicTree::Balance();
        }
        float v23 = v20 + 1;
        int v24 = v20[1];
        if (v24 < 0 || v24 >= v9) {
          b2DynamicTree::Balance();
        }
        *float v20 = a2;
        uint64_t v25 = v2 + 48 * (int)a2;
        uint64_t v26 = v2 + 48 * v12;
        *(_DWORD *)(v26 + 32) = *(_DWORD *)(v25 + 32);
        *(_DWORD *)(v25 + 32) = v12;
        int v27 = *(_DWORD *)(v26 + 32);
        if (v27 != -1)
        {
          uint64_t v28 = *((void *)this + 1);
          uint64_t v29 = v28 + 48 * v27;
          int v31 = *(_DWORD *)(v29 + 36);
          float v30 = (_DWORD *)(v29 + 36);
          if (v31 == a2)
          {
            *float v30 = v12;
LABEL_26:
            float v47 = (float32x2_t *)(v2 + 48 * v21);
            float v48 = (float32x2_t *)(v2 + 48 * v24);
            float32x4_t v49 = (__int32 *)&v47[5] + 1;
            __int32 v50 = v47[5].i32[1];
            __int32 v51 = v48[5].i32[1];
            if (v50 <= v51)
            {
              float32x2_t v57 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v47, *v17), (int8x8_t)*v17, (int8x8_t)*v47);
              float32x2_t v58 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v17[1], v47[1]), (int8x8_t)v17[1], (int8x8_t)v47[1]);
              *uint64_t v3 = v57;
              v3[1] = v58;
              float32x2_t v59 = v48[1];
              int8x8_t v60 = vbsl_s8((int8x8_t)vcgt_f32(*v48, v57), (int8x8_t)v57, (int8x8_t)*v48);
              int *v23 = v24;
              int *v11 = v21;
              *(_DWORD *)(v2 + 48 * v21 + 32) = a2;
              *uint64_t v14 = (float32x2_t)v60;
              int8x8_t v56 = vbsl_s8((int8x8_t)vcgt_f32(v58, v59), (int8x8_t)v58, (int8x8_t)v59);
              __int32 v51 = v50;
              float32x4_t v49 = (__int32 *)&v48[5] + 1;
            }
            else
            {
              float32x2_t v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v48, *v17), (int8x8_t)*v17, (int8x8_t)*v48);
              float32x2_t v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v17[1], v48[1]), (int8x8_t)v17[1], (int8x8_t)v48[1]);
              *uint64_t v3 = v52;
              v3[1] = v53;
              float32x2_t v54 = v47[1];
              int8x8_t v55 = vbsl_s8((int8x8_t)vcgt_f32(*v47, v52), (int8x8_t)v52, (int8x8_t)*v47);
              int *v23 = v21;
              int *v11 = v24;
              *(_DWORD *)(v2 + 48 * v24 + 32) = a2;
              *uint64_t v14 = (float32x2_t)v55;
              int8x8_t v56 = vbsl_s8((int8x8_t)vcgt_f32(v53, v54), (int8x8_t)v53, (int8x8_t)v54);
            }
            v14[1].i32[0] = v56.i32[0];
            if (v18 <= v51) {
              __int32 v61 = v51;
            }
            else {
              __int32 v61 = v18;
            }
            uint64_t v4 = v12;
            goto LABEL_42;
          }
          uint64_t v45 = v28 + 48 * v27;
          int v46 = *(_DWORD *)(v45 + 40);
          this = (b2DynamicTree *)(v45 + 40);
          if (v46 != a2) {
            b2DynamicTree::Balance();
          }
        }
        *(_DWORD *)this = v12;
        goto LABEL_26;
      }
      if (v15 - v18 > -2) {
        return a2;
      }
      uint64_t v32 = v2 + 48 * v4;
      int v35 = *(_DWORD *)(v32 + 36);
      float v33 = (_DWORD *)(v32 + 36);
      int v34 = v35;
      if (v35 < 0 || v34 >= v9) {
        b2DynamicTree::Balance();
      }
      float32x2_t v37 = v33 + 1;
      int v36 = v33[1];
      if (v36 < 0 || v36 >= v9) {
        b2DynamicTree::Balance();
      }
      *float v33 = a2;
      uint64_t v38 = v2 + 48 * (int)a2;
      uint64_t v39 = v2 + 48 * v4;
      *(_DWORD *)(v39 + 32) = *(_DWORD *)(v38 + 32);
      *(_DWORD *)(v38 + 32) = v4;
      int v40 = *(_DWORD *)(v39 + 32);
      if (v40 != -1)
      {
        uint64_t v41 = *((void *)this + 1);
        uint64_t v42 = v41 + 48 * v40;
        int v44 = *(_DWORD *)(v42 + 36);
        float v43 = (_DWORD *)(v42 + 36);
        if (v44 == a2)
        {
          _DWORD *v43 = v4;
LABEL_35:
          float v64 = (float32x2_t *)(v2 + 48 * v34);
          __int32 v65 = (float32x2_t *)(v2 + 48 * v36);
          float32x4_t v49 = (__int32 *)&v64[5] + 1;
          __int32 v66 = v64[5].i32[1];
          __int32 v67 = v65[5].i32[1];
          if (v66 <= v67)
          {
            float32x2_t v72 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v64, *v14), (int8x8_t)*v14, (int8x8_t)*v64);
            float32x2_t v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14[1], v64[1]), (int8x8_t)v14[1], (int8x8_t)v64[1]);
            *uint64_t v3 = v72;
            v3[1] = v73;
            float32x2_t v74 = v65[1];
            int8x8_t v75 = vbsl_s8((int8x8_t)vcgt_f32(*v65, v72), (int8x8_t)v72, (int8x8_t)*v65);
            *float32x2_t v37 = v36;
            *signed int v5 = v34;
            *(_DWORD *)(v2 + 48 * v34 + 32) = a2;
            float32x2_t *v17 = (float32x2_t)v75;
            int8x8_t v56 = vbsl_s8((int8x8_t)vcgt_f32(v73, v74), (int8x8_t)v73, (int8x8_t)v74);
            __int32 v67 = v66;
            float32x4_t v49 = (__int32 *)&v65[5] + 1;
          }
          else
          {
            float32x2_t v68 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v65, *v14), (int8x8_t)*v14, (int8x8_t)*v65);
            float32x2_t v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14[1], v65[1]), (int8x8_t)v14[1], (int8x8_t)v65[1]);
            *uint64_t v3 = v68;
            v3[1] = v69;
            float32x2_t v70 = v64[1];
            int8x8_t v71 = vbsl_s8((int8x8_t)vcgt_f32(*v64, v68), (int8x8_t)v68, (int8x8_t)*v64);
            *float32x2_t v37 = v34;
            *signed int v5 = v36;
            *(_DWORD *)(v2 + 48 * v36 + 32) = a2;
            float32x2_t *v17 = (float32x2_t)v71;
            int8x8_t v56 = vbsl_s8((int8x8_t)vcgt_f32(v69, v70), (int8x8_t)v69, (int8x8_t)v70);
          }
          v17[1].i32[0] = v56.i32[0];
          if (v15 <= v67) {
            __int32 v61 = v67;
          }
          else {
            __int32 v61 = v15;
          }
          LODWORD(v12) = v4;
          float32x4_t v16 = (_DWORD *)&v17[5] + 1;
LABEL_42:
          _DWORD *v7 = v61 + 1;
          __int32 v76 = *v49;
          if (v61 + 1 > *v49) {
            __int32 v76 = v61 + 1;
          }
          *(_DWORD *)(v2 + 48 * v12 + 12) = v56.i32[1];
          *float32x4_t v16 = v76 + 1;
          return v4;
        }
        uint64_t v62 = v41 + 48 * v40;
        int v63 = *(_DWORD *)(v62 + 40);
        this = (b2DynamicTree *)(v62 + 40);
        if (v63 != a2) {
          b2DynamicTree::Balance();
        }
      }
      *(_DWORD *)this = v4;
      goto LABEL_35;
    }
  }
  return a2;
}

uint64_t b2DynamicTree::GetHeight(b2DynamicTree *this)
{
  if (*(_DWORD *)this == -1) {
    return 0;
  }
  else {
    return *(unsigned int *)(*((void *)this + 1) + 48 * *(int *)this + 44);
  }
}

double b2DynamicTree::GetAreaRatio(b2DynamicTree *this)
{
  if (*(_DWORD *)this == -1) {
    return 0.0;
  }
  uint64_t v1 = *((void *)this + 1);
  float v2 = (float)(*(float *)(v1 + 48 * *(int *)this + 8) - *(float *)(v1 + 48 * *(int *)this))
     + (float)(*(float *)(v1 + 48 * *(int *)this + 12) - *(float *)(v1 + 48 * *(int *)this + 4));
  float v3 = v2 + v2;
  uint64_t v4 = *((unsigned int *)this + 5);
  float v5 = 0.0;
  if ((int)v4 >= 1)
  {
    do
    {
      if ((*(_DWORD *)(v1 + 44) & 0x80000000) == 0)
      {
        float v6 = (float)(*(float *)(v1 + 8) - *(float *)v1) + (float)(*(float *)(v1 + 12) - *(float *)(v1 + 4));
        float v5 = v5 + (float)(v6 + v6);
      }
      v1 += 48;
      --v4;
    }
    while (v4);
  }
  *(float *)&double result = v5 / v3;
  return result;
}

uint64_t b2DynamicTree::ComputeHeight(b2DynamicTree *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2) {
    b2DynamicTree::ComputeHeight();
  }
  uint64_t v3 = *((void *)this + 1);
  if (*(_DWORD *)(v3 + 48 * a2 + 36) == -1) {
    return 0;
  }
  int v5 = b2DynamicTree::ComputeHeight(this, *(_DWORD *)(v3 + 48 * a2 + 36));
  int v6 = b2DynamicTree::ComputeHeight(this, *(_DWORD *)(v3 + 48 * a2 + 40));
  if (v5 <= v6) {
    int v7 = v6;
  }
  else {
    int v7 = v5;
  }
  return (v7 + 1);
}

uint64_t b2DynamicTree::ComputeHeight(b2DynamicTree *this)
{
  return b2DynamicTree::ComputeHeight(this, *(_DWORD *)this);
}

uint64_t b2DynamicTree::ValidateStructure(uint64_t this, int a2)
{
  if (a2 != -1)
  {
    int v2 = a2;
    for (uint64_t i = this; ; this = b2DynamicTree::ValidateStructure((b2DynamicTree *)i, v7))
    {
      uint64_t v4 = *(void *)(i + 8);
      int v5 = v2;
      if (*(_DWORD *)i == v2 && *(_DWORD *)(v4 + 48 * v2 + 32) != -1) {
        b2DynamicTree::ValidateStructure();
      }
      uint64_t v6 = v4 + 48 * v2;
      int v7 = *(_DWORD *)(v6 + 36);
      int v2 = *(_DWORD *)(v6 + 40);
      if (v7 == -1) {
        break;
      }
      if (v7 < 0 || (int v8 = *(_DWORD *)(i + 20), v7 >= v8)) {
        b2DynamicTree::ValidateStructure();
      }
      if (v2 < 0 || v2 >= v8) {
        b2DynamicTree::ValidateStructure();
      }
      if (*(_DWORD *)(v4 + 48 * v7 + 32) != v5) {
        b2DynamicTree::ValidateStructure();
      }
      if (*(_DWORD *)(v4 + 48 * v2 + 32) != v5) {
        b2DynamicTree::ValidateStructure();
      }
    }
    if (v2 != -1) {
      b2DynamicTree::ValidateStructure();
    }
    if (*(_DWORD *)(v4 + 48 * v5 + 44)) {
      b2DynamicTree::ValidateStructure();
    }
  }
  return this;
}

uint64_t b2DynamicTree::ValidateMetrics(uint64_t this, int a2)
{
  if (a2 != -1)
  {
    uint64_t v2 = this;
    uint64_t v3 = *(void *)(this + 8);
    uint64_t v4 = a2;
    uint64_t v5 = v3 + 48 * a2;
    unsigned int v6 = *(_DWORD *)(v5 + 36);
    __int32 v7 = *(_DWORD *)(v5 + 40);
    if (v6 != -1)
    {
      int v8 = (float32x2_t *)(v3 + 48 * (int)v4);
      do
      {
        if ((v6 & 0x80000000) != 0 || (signed int v9 = *(_DWORD *)(v2 + 20), (int)v6 >= v9)) {
          b2DynamicTree::ValidateMetrics();
        }
        if (v7 < 0 || v7 >= v9) {
          b2DynamicTree::ValidateMetrics();
        }
        int v10 = *(_DWORD *)(v3 + 48 * v6 + 44);
        if (v10 <= *(_DWORD *)(v3 + 48 * v7 + 44)) {
          int v10 = *(_DWORD *)(v3 + 48 * v7 + 44);
        }
        if (*(_DWORD *)(v3 + 48 * v4 + 44) != v10 + 1) {
          b2DynamicTree::ValidateMetrics();
        }
        int16x4_t v11 = (float32x2_t *)(v3 + 48 * v6);
        uint64_t v12 = (float32x2_t *)(v3 + 48 * v7);
        int32x2_t v13 = vceq_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v12, *v11), (int8x8_t)*v11, (int8x8_t)*v12), *v8);
        if ((v13.i32[0] & v13.i32[1] & 1) == 0) {
          b2DynamicTree::ValidateMetrics();
        }
        int32x2_t v14 = vceq_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v11[1], v12[1]), (int8x8_t)v11[1], (int8x8_t)v12[1]), v8[1]);
        if ((v14.i32[0] & v14.i32[1] & 1) == 0) {
          b2DynamicTree::ValidateMetrics();
        }
        this = b2DynamicTree::ValidateMetrics((b2DynamicTree *)v2, v6);
        uint64_t v3 = *(void *)(v2 + 8);
        uint64_t v4 = v7;
        int v8 = (float32x2_t *)(v3 + 48 * v7);
        unsigned int v6 = v8[4].u32[1];
        __int32 v7 = v8[5].i32[0];
      }
      while (v6 != -1);
    }
    if (v7 != -1) {
      b2DynamicTree::ValidateMetrics();
    }
    if (*(_DWORD *)(v3 + 48 * (int)v4 + 44)) {
      b2DynamicTree::ValidateMetrics();
    }
  }
  return this;
}

uint64_t b2DynamicTree::Validate(b2DynamicTree *this)
{
  b2DynamicTree::ValidateStructure((uint64_t)this, *(_DWORD *)this);
  b2DynamicTree::ValidateMetrics((uint64_t)this, *(_DWORD *)this);
  uint64_t v2 = *((unsigned int *)this + 6);
  if (v2 == -1)
  {
    int v3 = 0;
  }
  else
  {
    int v3 = 0;
    do
    {
      if ((v2 & 0x80000000) != 0 || (int)v2 >= *((_DWORD *)this + 5)) {
        b2DynamicTree::Validate();
      }
      ++v3;
      LODWORD(v2) = *(_DWORD *)(*((void *)this + 1) + 48 * v2 + 32);
    }
    while (v2 != -1);
  }
  signed int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == -1) {
    int v5 = 0;
  }
  else {
    int v5 = *(_DWORD *)(*((void *)this + 1) + 48 * v4 + 44);
  }
  uint64_t result = b2DynamicTree::ComputeHeight(this, v4);
  if (v5 != result) {
    b2DynamicTree::Validate();
  }
  if (*((_DWORD *)this + 4) + v3 != *((_DWORD *)this + 5)) {
    b2DynamicTree::Validate();
  }
  return result;
}

uint64_t b2DynamicTree::GetMaxBalance(b2DynamicTree *this)
{
  uint64_t v1 = *((unsigned int *)this + 5);
  if ((int)v1 < 1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = *((void *)this + 1);
  int v5 = (int *)(v4 + 44);
  unsigned int v6 = (int *)(v4 + 44);
  do
  {
    int v7 = *v6;
    v6 += 12;
    if (v7 >= 2)
    {
      int v8 = *(v5 - 2);
      if (v8 == -1) {
        b2DynamicTree::GetMaxBalance();
      }
      int v9 = *(_DWORD *)(v4 + 48 * *(v5 - 1) + 44) - *(_DWORD *)(v4 + 48 * v8 + 44);
      if (v9 < 0) {
        int v9 = -v9;
      }
      if ((int)result <= v9) {
        uint64_t result = v9;
      }
      else {
        uint64_t result = result;
      }
    }
    int v5 = v6;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t b2DynamicTree::RebuildBottomUp(b2DynamicTree *this)
{
  uint64_t v2 = b2Alloc(4 * *((_DWORD *)this + 4));
  int v3 = this;
  uint64_t v4 = v2;
  if (*((int *)this + 5) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    LODWORD(v7) = 0;
    int v34 = this;
    do
    {
      uint64_t v8 = *((void *)v3 + 1);
      if ((*(_DWORD *)(v8 + v5 + 44) & 0x80000000) == 0)
      {
        if (*(_DWORD *)(v8 + v5 + 36) == -1)
        {
          *(_DWORD *)(v8 + v5 + 32) = -1;
          v4[(int)v7] = v6;
          LODWORD(v7) = v7 + 1;
        }
        else
        {
          b2DynamicTree::FreeNode((uint64_t)v3, v6);
          int v3 = this;
        }
      }
      ++v6;
      v5 += 48;
    }
    while (v6 < *((int *)v3 + 5));
    if ((int)v7 >= 2)
    {
      uint64_t v7 = v7;
      do
      {
        uint64_t v9 = 0;
        uint64_t v10 = *((void *)v3 + 1);
        int v11 = -1;
        uint64_t v12 = 0x200000000;
        float v13 = 3.4028e38;
        uint64_t v14 = 1;
        int v15 = -1;
        while (v9 + 1 < v7)
        {
          float32x4_t v16 = (float32x2_t *)(v10 + 48 * (int)v4[v9]);
          float32x2_t v17 = *v16;
          float32x2_t v18 = v16[1];
          uint64_t v19 = v12;
          uint64_t v20 = v14;
          do
          {
            int v21 = (float32x2_t *)(v10 + 48 * (int)v4[v20]);
            float v22 = vaddv_f32(vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v18, v21[1]), (int8x8_t)v18, (int8x8_t)v21[1]), (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v21, v17), (int8x8_t)v17, (int8x8_t)*v21)));
            float v23 = v22 + v22;
            if (v23 < v13)
            {
              int v15 = v20;
              int v11 = v9;
              float v13 = v23;
            }
            ++v20;
            BOOL v24 = v7 <= v19 >> 32;
            v19 += 0x100000000;
          }
          while (!v24);
          ++v14;
          v12 += 0x100000000;
          ++v9;
        }
        __int32 v25 = v4[v11];
        __int32 v26 = v4[v15];
        int v27 = (float32x2_t *)(v10 + 48 * v25);
        uint64_t v28 = (float32x2_t *)(v10 + 48 * v26);
        b2DynamicTree::AllocateNode(v3);
        int v3 = v34;
        __int32 v30 = v27[5].i32[1];
        if (v30 <= v28[5].i32[1]) {
          __int32 v30 = v28[5].i32[1];
        }
        int v31 = (int8x8_t *)(*((void *)v34 + 1) + 48 * v29);
        v31[5].i32[0] = v26;
        v31[5].i32[1] = v30 + 1;
        *int v31 = vbsl_s8((int8x8_t)vcgt_f32(*v28, *v27), (int8x8_t)*v27, (int8x8_t)*v28);
        v31[1] = vbsl_s8((int8x8_t)vcgt_f32(v27[1], v28[1]), (int8x8_t)v27[1], (int8x8_t)v28[1]);
        v31[4].i32[0] = -1;
        v31[4].i32[1] = v25;
        v27[4].i32[0] = v29;
        v28[4].i32[0] = v29;
        v4[v15] = v4[v7 - 1];
        v4[v11] = v29;
        BOOL v24 = v7-- <= 2;
      }
      while (!v24);
    }
  }
  *(_DWORD *)int v3 = *v4;
  uint64_t v32 = v3;
  b2Free(v4);

  return b2DynamicTree::Validate(v32);
}

void b2TimeOfImpact(int *a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  ++b2_toiCalls;
  *a1 = 0;
  float v2 = *(float *)(a2 + 192);
  *((float *)a1 + 1) = v2;
  float32x4_t v3 = *(float32x4_t *)(a2 + 80);
  float32x4_t v63 = *(float32x4_t *)(a2 + 64);
  float32x4_t v64 = v3;
  long long v4 = *(_OWORD *)(a2 + 112);
  float32x4_t v65 = *(float32x4_t *)(a2 + 96);
  long long v66 = v4;
  float32x4_t v5 = *(float32x4_t *)(a2 + 144);
  float32x4_t v59 = *(float32x4_t *)(a2 + 128);
  float32x4_t v60 = v5;
  long long v6 = *(_OWORD *)(a2 + 176);
  float32x4_t v61 = *(float32x4_t *)(a2 + 160);
  long long v62 = v6;
  float v7 = floorf(v64.f32[3] / 6.2832) * 6.2832;
  v64.f32[3] = v64.f32[3] - v7;
  v65.f32[3] = v65.f32[3] - v7;
  float v8 = floorf(v5.f32[3] / 6.2832);
  v60.f32[3] = v5.f32[3] - (float)(v8 * 6.2832);
  v61.f32[3] = v61.f32[3] - (float)(v8 * 6.2832);
  if ((float)((float)(*(float *)(a2 + 28) + *(float *)(a2 + 60)) + -0.0135) >= 0.0045) {
    float v9 = (float)(*(float *)(a2 + 28) + *(float *)(a2 + 60)) + -0.0135;
  }
  else {
    float v9 = 0.0045;
  }
  if (v9 <= 0.001125) {
    b2TimeOfImpact();
  }
  float v38 = v2;
  int v12 = 0;
  uint64_t v13 = a2 + 32;
  __int16 v57 = 0;
  long long v14 = *(_OWORD *)(a2 + 16);
  v48[0] = *(_OWORD *)a2;
  v48[1] = v14;
  long long v16 = *(_OWORD *)(a2 + 32);
  long long v15 = *(_OWORD *)(a2 + 48);
  v48[2] = v16;
  v48[3] = v15;
  char v55 = 0;
  float v40 = v9 + 0.001125;
  float v39 = v9 + -0.001125;
  *(void *)&long long v16 = 0;
  float v17 = 1.0;
  while (2)
  {
    float v41 = v17 - *(float *)&v16;
    long long v44 = v16;
    float32x4_t v37 = vmlaq_n_f32(vmulq_n_f32(v65, *(float *)&v16), v64, v17 - *(float *)&v16);
    __float2 v18 = __sincosf_stret(v37.f32[3]);
    float v19 = v37.f32[0] - (float)((float)(v18.__cosval * v63.f32[0]) - (float)(v18.__sinval * v63.f32[1]));
    float v20 = v37.f32[1] - (float)((float)(v63.f32[1] * v18.__cosval) + (float)(v18.__sinval * v63.f32[0]));
    float32x4_t v42 = vmlaq_n_f32(vmulq_n_f32(v61, *(float *)&v44), v60, v41);
    __float2 v21 = __sincosf_stret(v42.f32[3]);
    float v49 = v19;
    float v50 = v20;
    __float2 v51 = v18;
    float v52 = v42.f32[0] - (float)((float)(v21.__cosval * v59.f32[0]) - (float)(v21.__sinval * v59.f32[1]));
    float v53 = v42.f32[1] - (float)((float)(v59.f32[1] * v21.__cosval) + (float)(v21.__sinval * v59.f32[0]));
    __float2 v54 = v21;
    b2Distance((uint64_t)v46, (uint64_t)v56, (uint64_t)v48);
    if (v47 <= 0.0)
    {
      LODWORD(v16) = 0;
      int v34 = 2;
LABEL_46:
      *a1 = v34;
      a1[1] = v16;
      goto LABEL_41;
    }
    if (v47 < v40)
    {
      int v34 = 3;
      LODWORD(v16) = v44;
      goto LABEL_46;
    }
    b2SeparationFunction::Initialize(v58, (uint64_t)v56, a2, &v63, v13, &v59, *(float *)&v44);
    *(void *)uint64_t v45 = 0;
    b2SeparationFunction::FindMinSeparation((b2SeparationFunction *)v58, &v45[1], v45, v38);
    float v22 = *(float *)&v16;
    if (*(float *)&v16 <= v40)
    {
      int v23 = 0;
      float v43 = v38;
      while (1)
      {
        if (v22 > v39)
        {
          *(float *)&long long v16 = v43;
          goto LABEL_35;
        }
        b2SeparationFunction::Evaluate((b2SeparationFunction *)v58, v45[1], v45[0], *(float *)&v44);
        float v25 = v24;
        if (v24 < v39)
        {
          int v35 = 1;
          float v26 = *(float *)&v44;
          goto LABEL_40;
        }
        float v26 = *(float *)&v44;
        if (v25 <= v40)
        {
          int v35 = 3;
          goto LABEL_40;
        }
        int v27 = 0;
        float v28 = *(float *)&v44;
        float v29 = v43;
        while (1)
        {
          if (v27) {
            float v30 = v28 + (float)((float)((float)(v9 - v25) * (float)(v29 - v28)) / (float)(v22 - v25));
          }
          else {
            float v30 = (float)(v28 + v29) * 0.5;
          }
          b2SeparationFunction::Evaluate((b2SeparationFunction *)v58, v45[1], v45[0], v30);
          float v32 = v31 - v9;
          if ((float)(v31 - v9) <= 0.0) {
            float v32 = -(float)(v31 - v9);
          }
          if (v32 < 0.001125) {
            break;
          }
          if (v31 > v9)
          {
            float v25 = v31;
            float v28 = v30;
          }
          else
          {
            float v22 = v31;
          }
          if (v31 <= v9) {
            float v29 = v30;
          }
          ++v27;
          ++b2_toiRootIters;
          if (v27 == 50) {
            goto LABEL_28;
          }
        }
        float v43 = v30;
LABEL_28:
        int v33 = b2_toiMaxRootIters;
        if (b2_toiMaxRootIters <= v27) {
          int v33 = v27;
        }
        b2_toiMaxRootIters = v33;
        if (v23 == 11) {
          break;
        }
        *(void *)uint64_t v45 = 0;
        b2SeparationFunction::FindMinSeparation((b2SeparationFunction *)v58, &v45[1], v45, v43);
        float v22 = *(float *)&v16;
        ++v23;
        if (*(float *)&v16 > v40) {
          goto LABEL_37;
        }
      }
      long long v16 = v44;
LABEL_35:
      ++v12;
      ++b2_toiIters;
      float v17 = 1.0;
      if (v12 != 20) {
        continue;
      }
      int v34 = 1;
      goto LABEL_46;
    }
    break;
  }
LABEL_37:
  int v35 = 4;
  float v26 = v38;
LABEL_40:
  *a1 = v35;
  *((float *)a1 + 1) = v26;
  ++v12;
  ++b2_toiIters;
LABEL_41:
  int v36 = b2_toiMaxIters;
  if (b2_toiMaxIters <= v12) {
    int v36 = v12;
  }
  b2_toiMaxIters = v36;
}

void b2SeparationFunction::Initialize(float32x4_t *a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, float a7)
{
  a1->i64[0] = a3;
  a1->i64[1] = a5;
  int v7 = *(unsigned __int16 *)(a2 + 4);
  if ((v7 - 3) <= 0xFFFFFFFD) {
    b2SeparationFunction::Initialize();
  }
  float32x4_t v13 = *a4;
  float32x4_t v14 = a4[1];
  float32x4_t v15 = a4[2];
  a1[4].i32[0] = a4[3].i32[0];
  a1[2] = v14;
  a1[3] = v15;
  a1[1] = v13;
  float32x4_t v16 = *a6;
  float32x4_t v17 = a6[1];
  float32x4_t v18 = a6[2];
  a1[8].i32[0] = a6[3].i32[0];
  a1[6] = v17;
  a1[7] = v18;
  a1[5] = v16;
  float v83 = a7;
  float v84 = 1.0 - a7;
  float32x4_t v82 = vmlaq_n_f32(vmulq_n_f32(a1[3], a7), a1[2], 1.0 - a7);
  __float2 v21 = __sincosf_stret(v82.f32[3]);
  float cosval = v21.__cosval;
  LODWORD(v19) = *(void *)&v21;
  float v22 = a1[1].f32[0];
  float v23 = a1[1].f32[1];
  float v24 = -v19;
  float v25 = v82.f32[0] - (float)((float)(cosval * v22) - (float)(v19 * v23));
  float v26 = v82.f32[1] - (float)((float)(v23 * cosval) + (float)(v19 * v22));
  float32x4_t v85 = vmlaq_n_f32(vmulq_n_f32(a1[7], v83), a1[6], v84);
  __float2 v27 = __sincosf_stret(v85.f32[3]);
  float v28 = a1[5].f32[0];
  float v29 = a1[5].f32[1];
  float v30 = -v27.__sinval;
  float v31 = (float)(v27.__cosval * v28) - (float)(v27.__sinval * v29);
  float v32 = (float)(v29 * v27.__cosval) + (float)(v27.__sinval * v28);
  float v33 = v85.f32[0] - v31;
  float v34 = v85.f32[1] - v32;
  if (v7 == 1)
  {
    a1[9].i32[0] = 0;
    uint64_t v35 = *(unsigned __int8 *)(a2 + 6);
    if (*(_DWORD *)(a3 + 24) <= (int)v35) {
      b2Distance();
    }
    uint64_t v36 = *(unsigned __int8 *)(a2 + 9);
    if (*(_DWORD *)(a5 + 24) <= (int)v36) {
      b2Distance();
    }
    float32x4_t v37 = (float *)(*(void *)(a3 + 16) + 8 * v35);
    float v39 = *v37;
    float v38 = v37[1];
    float v40 = (float *)(*(void *)(a5 + 16) + 8 * v36);
    float v41 = v40[1];
    float v42 = (float)(v33 + (float)((float)(v41 * v30) + (float)(v27.__cosval * *v40)))
        - (float)(v25 + (float)((float)(v38 * v24) + (float)(cosval * v39)));
    float v43 = (float)(v34 + (float)((float)(v27.__cosval * v41) + (float)(v27.__sinval * *v40)))
        - (float)(v26 + (float)((float)(cosval * v38) + (float)(v19 * v39)));
    a1[9].f32[3] = v42;
    a1[10].f32[0] = v43;
    float v44 = sqrtf((float)(v43 * v43) + (float)(v42 * v42));
    if (v44 >= 0.00000011921)
    {
      a1[9].f32[3] = v42 * (float)(1.0 / v44);
      a1[10].f32[0] = v43 * (float)(1.0 / v44);
    }
  }
  else
  {
    if (*(unsigned __int8 *)(a2 + 6) == *(unsigned __int8 *)(a2 + 7))
    {
      a1[9].i32[0] = 2;
      uint64_t v45 = *(unsigned __int8 *)(a2 + 9);
      int v46 = *(_DWORD *)(a5 + 24);
      if (v46 <= (int)v45) {
        b2Distance();
      }
      uint64_t v47 = *(unsigned __int8 *)(a2 + 10);
      if (v46 <= (int)v47) {
        b2Distance();
      }
      uint64_t v48 = *(void *)(a5 + 16);
      float v49 = (float *)(v48 + 8 * v45);
      float v50 = *v49;
      float v51 = v49[1];
      float v52 = (float *)(v48 + 8 * v47);
      float v53 = *v52;
      float v54 = v52[1];
      float v55 = *v52 - v50;
      float v56 = v54 - v51;
      float v57 = -v55;
      a1[9].f32[3] = v54 - v51;
      a1[10].f32[0] = -v55;
      float v58 = sqrtf((float)(v55 * v55) + (float)(v56 * v56));
      if (v58 >= 0.00000011921)
      {
        float v59 = 1.0 / v58;
        float v56 = v56 * v59;
        float v57 = v59 * v57;
        a1[9].f32[3] = v56;
        a1[10].f32[0] = v57;
      }
      float v60 = (float)(v50 + v53) * 0.5;
      float v61 = (float)(v51 + v54) * 0.5;
      a1[9].f32[1] = v60;
      a1[9].f32[2] = v61;
      uint64_t v62 = *(unsigned __int8 *)(a2 + 6);
      if (*(_DWORD *)(a3 + 24) <= (int)v62) {
        b2Distance();
      }
      float32x4_t v63 = (float *)(*(void *)(a3 + 16) + 8 * v62);
      float v64 = (float)((float)((float)(v27.__cosval * v57) + (float)(v27.__sinval * v56))
                  * (float)((float)(v26 + (float)((float)(cosval * v63[1]) + (float)(v19 * *v63)))
                          - (float)(v34 + (float)((float)(v27.__cosval * v61) + (float)(v27.__sinval * v60)))))
          + (float)((float)((float)(v25 + (float)((float)(v63[1] * v24) + (float)(cosval * *v63)))
                          - (float)(v33 + (float)((float)(v61 * v30) + (float)(v27.__cosval * v60))))
                  * (float)((float)(v57 * v30) + (float)(v27.__cosval * v56)));
    }
    else
    {
      a1[9].i32[0] = 1;
      uint64_t v65 = *(unsigned __int8 *)(a2 + 6);
      int v66 = *(_DWORD *)(a3 + 24);
      if (v66 <= (int)v65) {
        b2Distance();
      }
      uint64_t v67 = *(unsigned __int8 *)(a2 + 7);
      if (v66 <= (int)v67) {
        b2Distance();
      }
      uint64_t v68 = *(void *)(a3 + 16);
      float32x2_t v69 = (float *)(v68 + 8 * v65);
      float v70 = *v69;
      float v71 = v69[1];
      float32x2_t v72 = (float *)(v68 + 8 * v67);
      float v73 = *v72;
      float v74 = v72[1];
      float v75 = *v72 - v70;
      float v56 = v74 - v71;
      float v57 = -v75;
      a1[9].f32[3] = v74 - v71;
      a1[10].f32[0] = -v75;
      float v76 = sqrtf((float)(v75 * v75) + (float)(v56 * v56));
      if (v76 >= 0.00000011921)
      {
        float v77 = 1.0 / v76;
        float v56 = v56 * v77;
        float v57 = v77 * v57;
        a1[9].f32[3] = v56;
        a1[10].f32[0] = v57;
      }
      float v78 = (float)(v70 + v73) * 0.5;
      float v79 = (float)(v71 + v74) * 0.5;
      a1[9].f32[1] = v78;
      a1[9].f32[2] = v79;
      uint64_t v80 = *(unsigned __int8 *)(a2 + 9);
      if (*(_DWORD *)(a5 + 24) <= (int)v80) {
        b2Distance();
      }
      float v81 = (float *)(*(void *)(a5 + 16) + 8 * v80);
      float v64 = (float)((float)((float)(cosval * v57) + (float)(v19 * v56))
                  * (float)((float)(v34 + (float)((float)(v27.__cosval * v81[1]) + (float)(v27.__sinval * *v81)))
                          - (float)(v26 + (float)((float)(cosval * v79) + (float)(v19 * v78)))))
          + (float)((float)((float)(v33 + (float)((float)(v81[1] * v30) + (float)(v27.__cosval * *v81)))
                          - (float)(v25 + (float)((float)(v79 * v24) + (float)(cosval * v78))))
                  * (float)((float)(v57 * v24) + (float)(cosval * v56)));
    }
    if (v64 < 0.0)
    {
      a1[9].f32[3] = -v56;
      a1[10].f32[0] = -v57;
    }
  }
}

void b2SeparationFunction::FindMinSeparation(b2SeparationFunction *this, int *a2, int *a3, float a4)
{
  float v57 = 1.0 - a4;
  __float2 v7 = __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 48), a4), *(float32x4_t *)(this + 32), 1.0 - a4).i32[3]));
  float v8 = -v7.__sinval;
  __float2 v9 = __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 112), a4), *(float32x4_t *)(this + 96), v57).i32[3]));
  int v10 = *((_DWORD *)this + 36);
  if (v10 == 2)
  {
    float v22 = *((float *)this + 39);
    float v23 = *((float *)this + 40);
    float v24 = (float)(v23 * (float)-v9.__sinval) + (float)(v9.__cosval * v22);
    float v25 = (float)(v9.__cosval * v23) + (float)(v9.__sinval * v22);
    *a3 = -1;
    uint64_t v26 = *(void *)this;
    __float2 v27 = *(float **)(*(void *)this + 16);
    uint64_t v28 = *(unsigned int *)(*(void *)this + 24);
    if ((int)v28 <= 1)
    {
      int v29 = 0;
      *a2 = 0;
    }
    else
    {
      int v29 = 0;
      float v30 = (float)-(float)(v25 * v7.__sinval) - (float)(v7.__cosval * v24);
      float v31 = (float)(v7.__sinval * v24) - (float)(v25 * v7.__cosval);
      float v32 = (float)(v31 * v27[1]) + (float)(*v27 * v30);
      float v33 = v27 + 3;
      for (uint64_t i = 1; i != v28; ++i)
      {
        if ((float)((float)(v31 * *v33) + (float)(*(v33 - 1) * v30)) > v32)
        {
          int v29 = i;
          float v32 = (float)(v31 * *v33) + (float)(*(v33 - 1) * v30);
        }
        v33 += 2;
      }
      *a2 = v29;
      if (v29 < 0) {
        goto LABEL_43;
      }
    }
    if (*(_DWORD *)(v26 + 24) > v29) {
      return;
    }
LABEL_43:
    b2Distance();
  }
  if (v10 == 1)
  {
    float v35 = *((float *)this + 39);
    float v36 = *((float *)this + 40);
    float v37 = (float)(v36 * v8) + (float)(v7.__cosval * v35);
    float v38 = (float)(v7.__cosval * v36) + (float)(v7.__sinval * v35);
    *a2 = -1;
    uint64_t v39 = *((void *)this + 1);
    float v40 = *(float **)(v39 + 16);
    uint64_t v41 = *(unsigned int *)(v39 + 24);
    if ((int)v41 <= 1)
    {
      int v42 = 0;
      *a3 = 0;
    }
    else
    {
      int v42 = 0;
      float v43 = (float)-(float)(v38 * v9.__sinval) - (float)(v9.__cosval * v37);
      float v44 = (float)(v9.__sinval * v37) - (float)(v38 * v9.__cosval);
      float v45 = (float)(v44 * v40[1]) + (float)(*v40 * v43);
      int v46 = v40 + 3;
      for (uint64_t j = 1; j != v41; ++j)
      {
        if ((float)((float)(v44 * *v46) + (float)(*(v46 - 1) * v43)) > v45)
        {
          int v42 = j;
          float v45 = (float)(v44 * *v46) + (float)(*(v46 - 1) * v43);
        }
        v46 += 2;
      }
      *a3 = v42;
      if (v42 < 0) {
        goto LABEL_44;
      }
    }
    if (*(_DWORD *)(v39 + 24) > v42) {
      return;
    }
LABEL_44:
    b2Distance();
  }
  if (v10) {
    b2SeparationFunction::FindMinSeparation();
  }
  float v11 = *((float *)this + 39);
  float v12 = *((float *)this + 40);
  uint64_t v13 = *(void *)this;
  float32x4_t v14 = *(float **)(*(void *)this + 16);
  uint64_t v15 = *(unsigned int *)(*(void *)this + 24);
  if ((int)v15 < 2)
  {
    int v16 = 0;
  }
  else
  {
    int v16 = 0;
    float v17 = (float)(v7.__sinval * v12) + (float)(v7.__cosval * v11);
    float v18 = (float)(v7.__cosval * v12) + (float)(v8 * v11);
    float v19 = (float)(v18 * v14[1]) + (float)(*v14 * v17);
    float v20 = v14 + 3;
    for (uint64_t k = 1; k != v15; ++k)
    {
      if ((float)((float)(v18 * *v20) + (float)(*(v20 - 1) * v17)) > v19)
      {
        int v16 = k;
        float v19 = (float)(v18 * *v20) + (float)(*(v20 - 1) * v17);
      }
      v20 += 2;
    }
  }
  *a2 = v16;
  uint64_t v48 = *((void *)this + 1);
  float v49 = *(float **)(v48 + 16);
  uint64_t v50 = *(unsigned int *)(v48 + 24);
  if ((int)v50 < 2)
  {
    int v51 = 0;
  }
  else
  {
    int v51 = 0;
    float v52 = (float)-(float)(v12 * v9.__sinval) - (float)(v9.__cosval * v11);
    float v53 = (float)(v9.__sinval * v11) - (float)(v12 * v9.__cosval);
    float v54 = (float)(v53 * v49[1]) + (float)(*v49 * v52);
    float v55 = v49 + 3;
    for (uint64_t m = 1; m != v50; ++m)
    {
      if ((float)((float)(v53 * *v55) + (float)(*(v55 - 1) * v52)) > v54)
      {
        int v51 = m;
        float v54 = (float)(v53 * *v55) + (float)(*(v55 - 1) * v52);
      }
      v55 += 2;
    }
  }
  *a3 = v51;
  if (*a2 < 0 || *(_DWORD *)(v13 + 24) <= *a2) {
    b2Distance();
  }
  if (v51 < 0 || *(_DWORD *)(v48 + 24) <= v51) {
    b2Distance();
  }
}

void b2SeparationFunction::Evaluate(b2SeparationFunction *this, int a2, int a3, float a4)
{
  float v8 = 1.0 - a4;
  __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 48), a4), *(float32x4_t *)(this + 32), 1.0 - a4).i32[3]));
  __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 112), a4), *(float32x4_t *)(this + 96), v8).i32[3]));
  int v7 = *((_DWORD *)this + 36);
  if (v7 == 2)
  {
    if (a2 < 0 || *(_DWORD *)(*(void *)this + 24) <= a2) {
      b2Distance();
    }
  }
  else if (v7 == 1)
  {
    if (a3 < 0 || *(_DWORD *)(*((void *)this + 1) + 24) <= a3) {
      b2Distance();
    }
  }
  else
  {
    if (v7) {
      b2SeparationFunction::Evaluate();
    }
    if (a2 < 0 || *(_DWORD *)(*(void *)this + 24) <= a2) {
      b2Distance();
    }
    if (a3 < 0 || *(_DWORD *)(*((void *)this + 1) + 24) <= a3) {
      b2Distance();
    }
  }
}

void b2QuadtreeShape::Clone(b2QuadtreeShape *this)
{
}

uint64_t b2QuadtreeShape::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  float32x4_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v3;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return a1;
}

uint64_t b2QuadtreeShape::GetChildCount(b2QuadtreeShape *this)
{
  return 1;
}

QuadTree *b2QuadtreeShape::TestPoint(b2QuadtreeShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  uint64_t result = (QuadTree *)*((void *)this + 2);
  if (result)
  {
    float v4 = a3->x - a2->var0.x;
    float v5 = a3->y - a2->var0.y;
    float var0 = a2->var1.var0;
    float var1 = a2->var1.var1;
    float v8 = 0;
    return (QuadTree *)QuadTree::intersectPoint(result, (float)(v5 * var0) + (float)(var1 * v4), (float)(var1 * v5) - (float)(var0 * v4), &v8);
  }
  return result;
}

QuadTree *b2QuadtreeShape::ComputeDistance(b2QuadtreeShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float v8 = a3->x - a2->var0.x;
  float v9 = a3->y - a2->var0.y;
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v12 = (float)(v9 * var0) + (float)(var1 * v8);
  float v13 = (float)(var1 * v9) - (float)(var0 * v8);
  uint64_t result = (QuadTree *)*((void *)this + 2);
  if (result
    && (uint64_t v26 = 0,
        uint64_t result = (QuadTree *)QuadTree::find(result, (float)(v9 * var0) + (float)(var1 * v8), v13, (QuadTreeNode ***)&v26), v26))
  {
    float v15 = v12 - (float)((float)(*((float *)v26 + 8) + *((float *)v26 + 9)) * 0.5);
    float v16 = v13 - (float)((float)(*((float *)v26 + 10) + *((float *)v26 + 11)) * 0.5);
    float v17 = sqrtf((float)(v16 * v16) + (float)(v15 * v15));
    float v19 = a2->var1.var0;
    float v18 = a2->var1.var1;
    if (v17 <= 0.00000011921)
    {
      float v16 = v13;
      float v15 = v12;
    }
    a5->float x = (float)(v18 * v15) - (float)(v19 * v16);
    a5->float y = (float)(v16 * v18) + (float)(v19 * v15);
    *a4 = v17;
    float x = a5->x;
    float y = a5->y;
  }
  else
  {
    *a4 = -3.4028e38;
    float v23 = a2->var1.var0;
    float v22 = a2->var1.var1;
    float x = (float)(v22 * v12) - (float)(v23 * v13);
    float y = (float)(v13 * v22) + (float)(v23 * v12);
    a5->float x = x;
    a5->float y = y;
  }
  float v24 = sqrtf((float)(y * y) + (float)(x * x));
  if (v24 >= 0.00000011921)
  {
    float v25 = 1.0 / v24;
    a5->float x = x * v25;
    a5->float y = y * v25;
  }
  return result;
}

uint64_t b2QuadtreeShape::RayCast(uint64_t a1, float *a2, float *a3, float *a4)
{
  float v5 = a4[1];
  float v6 = *a3 - *a4;
  float v7 = a3[1] - v5;
  float v9 = a4[2];
  float v8 = a4[3];
  float v10 = (float)(v7 * v9) + (float)(v8 * v6);
  float v11 = (float)(v8 * v7) - (float)(v9 * v6);
  float v12 = a3[2] - *a4;
  float v13 = a3[3] - v5;
  float v14 = (float)(v9 * v13) + (float)(v8 * v12);
  float v15 = (float)(v8 * v13) - (float)(v9 * v12);
  float v22 = 0;
  QuadTree::intersectRay(*(QuadTree **)(a1 + 16), v10, v11, v14, v15, &v22);
  float v16 = v14 - v10;
  float v17 = v15 - v11;
  *a2 = v14 - v10;
  a2[1] = v15 - v11;
  float v18 = sqrtf((float)(v17 * v17) + (float)(v16 * v16));
  if (v18 >= 0.00000011921)
  {
    *a2 = v16 * (float)(1.0 / v18);
    a2[1] = v17 * (float)(1.0 / v18);
  }
  float v19 = *((float *)v22 + 10) + *((float *)v22 + 11);
  float v20 = v14 - (float)((float)(*((float *)v22 + 8) + *((float *)v22 + 9)) * 0.5);
  a2[2] = v18
        - sqrtf((float)((float)(v15 - (float)(v19 * 0.5)) * (float)(v15 - (float)(v19 * 0.5))) + (float)(v20 * v20));
  return 0;
}

float b2QuadtreeShape::ComputeAABB(uint64_t a1, float *a2, float *a3)
{
  uint64_t v3 = *(QuadTree **)(a1 + 16);
  if (v3)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    QuadTree::bounds(v3, (float *)&v13 + 1, (float *)&v13, (float *)&v12 + 1, (float *)&v12);
    float v7 = a3[2];
    float v6 = a3[3];
    float v8 = (float)((float)(*(float *)&v13 * v6) + (float)(v7 * *((float *)&v13 + 1))) + a3[1];
    *a2 = *a3 + (float)((float)(v6 * *((float *)&v13 + 1)) - (float)(v7 * *(float *)&v13));
    a2[1] = v8;
    float v10 = a3[2];
    float v9 = a3[3];
    float result = (float)((float)(*(float *)&v12 * v9) + (float)(v10 * *((float *)&v12 + 1))) + a3[1];
    a2[2] = *a3 + (float)((float)(v9 * *((float *)&v12 + 1)) - (float)(v10 * *(float *)&v12));
    a2[3] = result;
  }
  return result;
}

uint64_t b2QuadtreeShape::ComputeMass(uint64_t a1, void *a2)
{
  uint64_t result = puts("E");
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void b2QuadtreeShape::~b2QuadtreeShape(b2QuadtreeShape *this)
{
  *(void *)this = &unk_26C3F3960;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_26C3F3960;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x21668C8E0);
}

void setRegionOnField(uint64_t a1, void *a2)
{
}

id getRegionOnField(uint64_t a1)
{
  return **(id **)(a1 + 8);
}

id setRepresentedObjectOnField(uint64_t a1, void *a2)
{
  return objc_storeWeak(*(id **)(a1 + 16), a2);
}

id fieldRepresentedObject(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained(*(id **)(a1 + 16));

  return WeakRetained;
}

void PKCField::PKCField(PKCField *this)
{
  *(void *)this = &unk_26C3F3FD8;
  operator new();
}

void PKCField::PKCField(PKCField *this, const PKCField *a2)
{
  *(void *)this = &unk_26C3F3FD8;
  operator new();
}

void PKCField::~PKCField(PKCField *this)
{
  *(void *)this = &unk_26C3F3FD8;
  --fieldCount;
  float v2 = (id *)*((void *)this + 1);
  if (v2)
  {

    MEMORY[0x21668C8E0](v2, 0x80C40B8603338);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    objc_destroyWeak(*((id **)this + 2));
    MEMORY[0x21668C8E0](v3, 0x80C40B8603338);
  }
}

void PKCField::setTransform(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, long long a10, long long a11, long long a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  a20 = *MEMORY[0x263EF8340];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
  if (*(unsigned char *)(a1 + 245))
  {
    LODWORD(v23) = 1065353216;
    LODWORD(v24) = 0;
    *(_OWORD *)(a1 + 64) = xmmword_21359AF20;
    *(_OWORD *)(a1 + 80) = xmmword_21359A730;
    LODWORD(v25) = 0;
    float32x4_t v26 = (float32x4_t)xmmword_21359A700;
    *(_OWORD *)(a1 + 96) = xmmword_21359AF30;
    *(_OWORD *)(a1 + 112) = xmmword_21359A700;
  }
  else
  {
    float v27 = *a3;
    float v28 = a3[2];
    __float2 v29 = __sincosf_stret(a3[1]);
    __float2 v30 = __sincosf_stret(v27);
    __float2 v31 = __sincosf_stret(v28);
    HIDWORD(v32) = 0;
    *(void *)&long long v32 = __PAIR64__((float)(v31.__cosval * (float)(v29.__sinval * v30.__sinval))- (float)(v29.__cosval * v31.__sinval), (float)(v31.__sinval * (float)(v29.__sinval * v30.__sinval))+ (float)(v29.__cosval * v31.__cosval));
    *((float *)&v32 + 2) = v29.__sinval * v30.__cosval;
    HIDWORD(v33) = 0;
    *(void *)&long long v33 = __PAIR64__(v31.__cosval * v30.__cosval, v31.__sinval * v30.__cosval);
    *((float *)&v33 + 2) = -v30.__sinval;
    HIDWORD(v34) = 0;
    *(void *)&long long v34 = __PAIR64__((float)(v31.__cosval * (float)(v29.__cosval * v30.__sinval))+ (float)(v31.__sinval * v29.__sinval), (float)(v31.__sinval * (float)(v29.__cosval * v30.__sinval))- (float)(v29.__sinval * v31.__cosval));
    long long v66 = v32;
    long long v67 = v33;
    *((float *)&v34 + 2) = v29.__cosval * v30.__cosval;
    long long v68 = v34;
    long long vars0 = xmmword_21359A700;
    math::transpose((uint64_t)&v66, (uint64_t)&a9);
    long long v35 = a10;
    *(_OWORD *)(a1 + 64) = a9;
    *(_OWORD *)(a1 + 80) = v35;
    long long v36 = a12;
    *(_OWORD *)(a1 + 96) = a11;
    *(_OWORD *)(a1 + 112) = v36;
    long long v23 = *(_OWORD *)(a1 + 64);
    long long v24 = *(_OWORD *)(a1 + 80);
    long long v25 = *(_OWORD *)(a1 + 96);
    float32x4_t v26 = *(float32x4_t *)(a1 + 112);
  }
  float v37 = -*(float *)a2;
  float v38 = -*(float *)(a2 + 4);
  float v39 = -*(float *)(a2 + 8);
  long long v66 = xmmword_21359AF20;
  long long v67 = xmmword_21359A730;
  float v40 = a4->f32[1];
  v41.i32[0] = 1.0;
  if (fabsf(a4->f32[0]) <= 0.000030518) {
    float v42 = 1.0;
  }
  else {
    float v42 = 1.0 / a4->f32[0];
  }
  float v43 = fabsf(v40);
  float v44 = 1.0 / v40;
  if (v43 <= 0.000030518) {
    float v44 = 1.0;
  }
  float v45 = a4->f32[2];
  float v46 = fabsf(v45);
  float v47 = 1.0 / v45;
  if (v46 <= 0.000030518) {
    float v48 = 1.0;
  }
  else {
    float v48 = v47;
  }
  LODWORD(v49) = 0;
  *((float *)&v49 + 1) = v44;
  a9 = LODWORD(v42);
  a10 = v49;
  *(void *)&long long v50 = 0;
  *((void *)&v50 + 1) = LODWORD(v48);
  v41.i32[1] = 0;
  v41.i32[2] = 0;
  v41.f32[3] = v37;
  float32x4_t v51 = (float32x4_t)xmmword_21359A730;
  v51.i32[0] = DWORD1(v66);
  a11 = v50;
  a12 = xmmword_21359A700;
  v51.f32[3] = v38;
  float32x4_t v52 = (float32x4_t)xmmword_21359AF30;
  v52.i32[0] = DWORD2(v66);
  v52.f32[3] = v39;
  float32x4_t v53 = (float32x4_t)xmmword_21359A700;
  v53.i32[0] = *(_DWORD *)((unint64_t)&v66 | 0xC);
  float32x4_t v54 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, *(float *)&v23), v51, *(float *)&v24), v52, *(float *)&v25), v53, v26.f32[0]);
  float32x4_t v55 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 68))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 84))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 100))), v53, *(float *)vshrq_n_u64((uint64x2_t)v26, 0x20uLL).i32);
  float32x4_t v56 = vmlaq_laneq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 72))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 88))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 104))), v53, v26, 2);
  LODWORD(v57) = vdupq_lane_s32(*(int32x2_t *)v54.f32, 1).u32[0];
  float32x4_t v58 = vmlaq_laneq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 76))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 92))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 108))), v53, v26, 3);
  *(void *)&long long v59 = vzip1q_s32((int32x4_t)v54, (int32x4_t)v55).u64[0];
  DWORD1(v57) = v55.i32[1];
  *((void *)&v59 + 1) = __PAIR64__(v58.u32[0], v56.u32[0]);
  *((void *)&v57 + 1) = __PAIR64__(v58.u32[1], v56.u32[1]);
  v65[0] = v59;
  v65[1] = v57;
  v55.i32[0] = DWORD1(v59);
  v54.i32[0] = v59;
  v58.i32[0] = *(_DWORD *)((unint64_t)v65 | 0xC);
  int32x4_t v60 = (int32x4_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v54, v42), (float32x4_t)0, v55), (float32x4_t)0, v56), (float32x4_t)0, v58);
  int32x4_t v61 = (int32x4_t)vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 1)), v55, *((float *)&v49 + 1)), v56, *((float *)&a11 + 1)), (float32x4_t)0, v58);
  float32x4_t v62 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 2)), v55, 0.0), v56, *((float *)&a11 + 2)), (float32x4_t)0, v58);
  float32x4_t v63 = vaddq_f32(v58, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 3)), v55, COERCE_FLOAT((unsigned __int128)v49 >> 96)), v56, *((float *)&a11 + 3)));
  *(void *)&long long v57 = vzip1q_s32(v60, v61).u64[0];
  *(void *)&long long v64 = vtrn2q_s32(v60, v61).u64[0];
  v58.i64[0] = vzip2q_s32(v60, v61).u64[0];
  v61.i64[0] = vuzp2q_s32(vuzp2q_s32(v60, v61), v60).u64[0];
  *((void *)&v57 + 1) = __PAIR64__(v63.u32[0], v62.u32[0]);
  *((void *)&v64 + 1) = __PAIR64__(v63.u32[1], v62.u32[1]);
  v58.i64[1] = __PAIR64__(v63.u32[2], v62.u32[2]);
  v61.i64[1] = __PAIR64__(v63.u32[3], v62.u32[3]);
  *(_OWORD *)(a1 + 128) = v57;
  *(_OWORD *)(a1 + 144) = v64;
  *(float32x4_t *)(a1 + 160) = v58;
  *(int32x4_t *)(a1 + 176) = v61;
  *(float *)(a1 + 192) = sqrtf(fabsf(vmulq_lane_f32(*a4, *(float32x2_t *)a4->f32, 1).f32[0]));
}

void *PKCField::hasFiniteRegion(PKCField *this)
{
  uint64_t result = (void *)**((void **)this + 1);
  if (result) {
    return (void *)([result isInfinite] ^ 1);
  }
  return result;
}

void *PKCField::hasEmptyRegion(PKCField *this)
{
  uint64_t result = (void *)**((void **)this + 1);
  if (result) {
    return (void *)[result isEmpty];
  }
  return result;
}

uint64_t PKCField::contains(uint64_t a1, float32x4_t *a2)
{
  if (!*(unsigned char *)(a1 + 244)) {
    return 0;
  }
  uint64_t v3 = **(void ***)(a1 + 8);
  if (!v3) {
    return 1;
  }
  id v5 = v3;
  float32x4_t v12 = *(float32x4_t *)(a1 + 144);
  float32x4_t v13 = *(float32x4_t *)(a1 + 128);
  float32x4_t v11 = *(float32x4_t *)(a1 + 160);
  float32x4_t v14 = *(float32x4_t *)(a1 + 176);
  float32x4_t v15 = *a2;
  float v6 = PKGet_PTM_RATIO();
  float v7 = PKGet_PTM_RATIO();
  float32x2_t v8 = (float32x2_t)vaddq_f32(vaddq_f32(vmulq_n_f32(v13, v15.f32[0]), vmulq_lane_f32(v12, *(float32x2_t *)v15.f32, 1)), vaddq_f32(vmulq_laneq_f32(v11, v15, 2), v14)).u64[0];
  uint64_t v9 = objc_msgSend(v5, "containsPoint:", (float)(v6 * v8.f32[0]), vmuls_lane_f32(v7, v8, 1));

  return v9;
}

void sub_213572C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float PKCField::calculatedFalloff(float32x4_t *a1, float32x4_t a2)
{
  float v2 = a1[12].f32[3];
  if (fabsf(v2) < 0.000030518) {
    return 1.0;
  }
  float32x4_t v4 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
  float32x4_t v5 = vmulq_f32(v4, v4);
  float v6 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0]);
  if (v6 < a1[13].f32[0]) {
    float v6 = a1[13].f32[0];
  }
  return powf(v6, -v2);
}

float PKCField::calculatedLocalFalloff(uint64_t a1, float32x4_t a2)
{
  float v2 = *(float *)(a1 + 204);
  if (fabsf(v2) < 0.000030518) {
    return 1.0;
  }
  float32x4_t v4 = vmulq_f32(a2, a2);
  float v5 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]);
  if (v5 < *(float *)(a1 + 208)) {
    float v5 = *(float *)(a1 + 208);
  }
  return powf(v5, -v2);
}

void PKCField::evalForceVec2(uint64_t a1, uint64_t a2, int a3, int a4, int a5, float32x4_t a6)
{
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    float v10 = *(void (**)(void))(*(void *)a1 + 16);
    v10();
    return;
  }
  float32x4_t v11 = *(float32x2_t **)(a2 + 168);
  uint64_t v33 = *(void *)(a2 + 8);
  uint64_t v36 = *(void *)(a2 + 16);
  uint64_t v37 = *(void *)(a2 + 176);
  uint64_t v29 = *(void *)(a2 + 40);
  a6.i32[0] = *(_DWORD *)(a2 + 272);
  int32x2_t v35 = *(int32x2_t *)a6.f32;
  double v12 = *(double *)(a2 + 256);
  float32x2_t v13 = *(float32x2_t *)(a2 + 264);
  float32x4_t v14 = **(void ***)(a1 + 8);
  if (v14) {
    int v32 = [v14 isInfinite] ^ 1;
  }
  else {
    int v32 = 0;
  }
  if (*(unsigned char *)(a2 + 88)) {
    float v15 = *(float *)(a2 + 64);
  }
  else {
    float v15 = 1.0;
  }
  int v16 = a5;
  if (*(unsigned char *)(a2 + 120))
  {
    float v17 = *(float *)(a2 + 96);
    if (a4) {
      goto LABEL_14;
    }
LABEL_17:
    uint64_t v19 = 0;
    float v18 = 0;
    if (!a5) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  float v17 = 0.0;
  if (!a4) {
    goto LABEL_17;
  }
LABEL_14:
  float v18 = *(unsigned char **)(a2 + 200);
  uint64_t v19 = *(void *)(a2 + 208);
  if (!a5)
  {
LABEL_15:
    float v20 = 0;
    uint64_t v31 = 0;
    goto LABEL_19;
  }
LABEL_18:
  float v20 = *(_DWORD **)(a2 + 136);
  uint64_t v31 = *(void *)(a2 + 144);
LABEL_19:
  if (a3 >= 1)
  {
    uint64_t v21 = 0;
    BOOL v22 = 0;
    float v23 = v12;
    char v28 = *(unsigned char *)(a1 + 200);
    float32x2_t v24 = (float32x2_t)vdup_lane_s32(v35, 0);
    double v25 = v23;
    BOOL v26 = 1;
    do
    {
      if (a4) {
        BOOL v22 = *v18 != 0;
      }
      if (v16)
      {
        BOOL v26 = (*(_DWORD *)(a1 + 240) & *v20) != 0;
        float v20 = (_DWORD *)((char *)v20 + v31);
      }
      if (!v22 && v26)
      {
        *(float32x2_t *)a6.f32 = vmul_n_f32(vadd_f32(v13, *(float32x2_t *)(v33 + v21)), *(float *)v35.i32);
        v38[0] = a6;
        if (!v32 || (v30 = a6, int v27 = PKCField::contains(a1, v38), a6 = v30, v27))
        {
          float32x2_t *v11 = vadd_f32(*v11, vdiv_f32(COERCE_FLOAT32X2_T((*(double (**)(uint64_t, float32x4_t, double, float, float, double))(*(void *)a1 + 40))(a1, a6, COERCE_DOUBLE(vmul_n_f32(*(float32x2_t *)(v29 + v21), *(float *)v35.i32)), v15, v17, v25)), v24));
          if (a4) {
            *float v18 = v28;
          }
        }
        int v16 = a5;
      }
      float32x4_t v11 = (float32x2_t *)((char *)v11 + v37);
      v18 += v19;
      v21 += v36;
      --a3;
    }
    while (a3);
  }
}

void PKCField::evalForceVec2(void **a1, uint64_t a2, int a3, double a4, int32x2_t a5, float32x4_t a6)
{
  uint64_t v9 = (void *)*a1[1];
  if (v9) {
    int v10 = [v9 isInfinite] ^ 1;
  }
  else {
    int v10 = 0;
  }
  if (*(unsigned char *)(a2 + 88)) {
    float v11 = *(float *)(a2 + 64);
  }
  else {
    float v11 = 1.0;
  }
  if (*(unsigned char *)(a2 + 120)) {
    float v12 = *(float *)(a2 + 96);
  }
  else {
    float v12 = 0.0;
  }
  if (a3 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)(a2 + 40);
    float v15 = *(float32x2_t **)(a2 + 168);
    uint64_t v16 = *(void *)(a2 + 176);
    uint64_t v17 = *(void *)(a2 + 8);
    uint64_t v18 = *(void *)(a2 + 16);
    float32x2_t v19 = *(float32x2_t *)(a2 + 264);
    a5.i32[0] = *(_DWORD *)(a2 + 272);
    float v20 = *(double *)(a2 + 256);
    float v26 = *(float *)a5.i32;
    float32x2_t v21 = (float32x2_t)vdup_lane_s32(a5, 0);
    double v22 = v20;
    do
    {
      *(float32x2_t *)a6.f32 = vmul_n_f32(vadd_f32(v19, *(float32x2_t *)(v17 + v13)), v26);
      float32x2_t v23 = *(float32x2_t *)(v14 + v13);
      float32x4_t v27 = a6;
      if (!v10 || (v25 = a6, int v24 = PKCField::contains((uint64_t)a1, &v27), a6 = v25, v24)) {
        *float v15 = vadd_f32(*v15, vdiv_f32(COERCE_FLOAT32X2_T(((double (*)(void **, float32x4_t, double, float, float, double))(*a1)[5])(a1, a6, COERCE_DOUBLE(vmul_n_f32(v23, v26)), v11, v12, v22)), v21));
      }
      float v15 = (float32x2_t *)((char *)v15 + v16);
      v13 += v18;
      --a3;
    }
    while (a3);
  }
}

void PKCFieldLinearGravity::PKCFieldLinearGravity(PKCFieldLinearGravity *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldLinearGravity::evalForce(uint64_t a1, float32x4_t a2, double a3, float a4)
{
  float v4 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  double v5 = 0.0;
  if (fabsf(v4 * a4) >= 0.000030518) {
    *(void *)&double v5 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), COERCE_FLOAT(*(_OWORD *)(a1 + 256))), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)(a1 + 256), 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), *(float32x4_t *)(a1 + 256), 2), vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0))), v4), a4), PKCField::calculatedFalloff((float32x4_t *)a1, a2)).u64[0];
  }
  return v5;
}

__n128 PKCFieldLinearGravity::setGravity(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[16] = *a2;
  return result;
}

void PKCFieldRadialGravity::PKCFieldRadialGravity(PKCFieldRadialGravity *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

void PKCFieldRadialGravity::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  if (fabsf((float)(a1[12].f32[1] * a1[12].f32[0]) * a4) >= 0.000030518)
  {
    float32x4_t v4 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    float32x4_t v5 = vmulq_f32(v4, v4);
    float v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
    if (v6 >= 0.00001)
    {
      float v7 = sqrtf(v6);
      float v8 = a1[12].f32[3];
      if (fabsf(v8) >= 0.000030518)
      {
        float v9 = a1[13].f32[0];
        if (v7 >= v9) {
          float v9 = v7;
        }
        powf(v9, -v8);
      }
    }
  }
}

void PKCFieldSpring::PKCFieldSpring(PKCFieldSpring *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

void PKCFieldSpring::evalForce(float32x4_t *a1, float32x4_t a2)
{
  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    float32x4_t v2 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    float32x4_t v3 = vmulq_f32(v2, v2);
    float v4 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]);
    if (v4 >= 0.00001)
    {
      float v5 = a1[12].f32[3];
      if (fabsf(v5) >= 0.000030518)
      {
        float v6 = a1[13].f32[0];
        if (v4 >= v6) {
          float v6 = v4;
        }
        powf(v6, -v5);
      }
    }
  }
}

void PKCFieldElectric::PKCFieldElectric(PKCFieldElectric *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldElectric::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, float a5)
{
  float v5 = (float)(a1[12].f32[1] * a1[12].f32[0]) * a5;
  double v6 = 0.0;
  if (fabsf(v5) >= 0.000030518)
  {
    float32x4_t v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    float32x4_t v8 = vmulq_f32(v7, v7);
    int32x2_t v9 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u64[0];
    *(float *)v9.i32 = sqrtf(*(float *)v9.i32);
    float32x4_t v10 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(v9, 0));
    float v11 = a1[12].f32[3];
    float v12 = 1.0;
    if (fabsf(v11) >= 0.000030518)
    {
      float v13 = a1[13].f32[0];
      if (*(float *)v9.i32 >= v13) {
        float v13 = *(float *)v9.i32;
      }
      float32x4_t v15 = v10;
      float v12 = powf(v13, -v11);
      float32x4_t v10 = v15;
    }
    *(void *)&double v6 = vmulq_n_f32(v10, v5 * v12).u64[0];
  }
  return v6;
}

void PKCFieldMagnetic::PKCFieldMagnetic(PKCFieldMagnetic *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldMagnetic::evalForce(float32x4_t *a1, float32x4_t a2, float32x4_t a3, double a4, float a5)
{
  float v5 = a1[12].f32[1] * a1[12].f32[0];
  double v6 = 0.0;
  if (fabsf(v5 * a5) >= 0.000030518)
  {
    float32x4_t v7 = a1[4];
    float32x4_t v8 = a1[5];
    float32x4_t v9 = a1[6];
    float32x4_t v10 = a1[7];
    float32x4_t v11 = vmulq_lane_f32(v8, *(float32x2_t *)a3.f32, 1);
    int8x16_t v12 = (int8x16_t)vaddq_f32(vaddq_f32(vmulq_n_f32(v7, a3.f32[0]), v11), vaddq_f32(vmulq_laneq_f32(v9, a3, 2), vmulq_f32(v10, (float32x4_t)0)));
    int8x16_t v13 = (int8x16_t)vaddq_f32(vaddq_f32(vmulq_f32(v7, (float32x4_t)0), vmulq_f32(v8, (float32x4_t)0)), vaddq_f32(v9, v10));
    v10.i32[0] = vextq_s8(v12, v12, 8uLL).u32[0];
    v10.i32[1] = v12.i32[0];
    v14.i32[0] = vextq_s8(v13, v13, 8uLL).u32[0];
    v14.i32[1] = v13.i32[0];
    *(float32x2_t *)v11.f32 = vmla_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 4uLL), vneg_f32(*(float32x2_t *)v10.f32)), v14, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 4uLL));
    v11.i32[2] = vmlas_n_f32((float)-*(float *)&v12.i32[1] * *(float *)v13.i32, *(float *)&v13.i32[1], *(float *)v12.i32);
    *(void *)&double v6 = vmulq_n_f32(v11, v5 * PKCField::calculatedFalloff(a1, a2)).u64[0];
  }
  return v6;
}

void PKCFieldDrag::PKCFieldDrag(PKCFieldDrag *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldDrag::evalForce(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  float v3 = *(float *)(a1 + 192);
  float v4 = *(float *)(a1 + 196);
  double v5 = 0.0;
  if (fabsf(v4 * v3) >= 0.000030518)
  {
    double v5 = 0.0;
    float32x4_t v6 = vsubq_f32(a3, vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), COERCE_FLOAT(*(_OWORD *)(a1 + 224))), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)(a1 + 224), 1)), vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0), vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), *(float32x4_t *)(a1 + 224), 2))));
    float32x4_t v7 = vmulq_f32(v6, v6);
    float v8 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]);
    if (v8 > 0.000030518) {
      *(void *)&double v5 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v6, v8), -v4), v3), PKCField::calculatedFalloff((float32x4_t *)a1, a2)).u64[0];
    }
  }
  return v5;
}

void PKCFieldVortex::PKCFieldVortex(PKCFieldVortex *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldVortex::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4)
{
  float v4 = a1[12].f32[0];
  float v5 = a1[12].f32[1];
  double v6 = 0.0;
  if (fabsf((float)(v5 * v4) * *(float *)&a4) >= 0.000030518)
  {
    float32x4_t v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    float32x4_t v8 = vmulq_f32(v7, v7);
    int32x2_t v9 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u64[0];
    *(float *)v9.i32 = sqrtf(*(float *)v9.i32);
    float32x4_t v10 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(v9, 0));
    float v11 = -(float)(v5 * v4);
    float v12 = a1[12].f32[3];
    float v13 = 1.0;
    if (fabsf(v12) >= 0.000030518)
    {
      float v14 = a1[13].f32[0];
      if (*(float *)v9.i32 >= v14) {
        float v14 = *(float *)v9.i32;
      }
      float32x4_t v17 = v10;
      double v18 = a4;
      float v13 = powf(v14, -v12);
      float32x4_t v10 = v17;
      a4 = v18;
    }
    int32x4_t v15 = (int32x4_t)vmlaq_f32(vmulq_f32(v10, (float32x4_t)xmmword_21359AF40), (float32x4_t)xmmword_21359AF50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL));
    *(void *)&double v6 = vdivq_f32(vmulq_n_f32(vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v15, v15), (int8x16_t)v15, 0xCuLL)), v11 * v13), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0)).u64[0];
  }
  return v6;
}

void PKCFieldTurbulence::PKCFieldTurbulence(PKCFieldTurbulence *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

void PKCFieldNoise::PKCFieldNoise(PKCFieldNoise *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldTurbulence::evalForce(float32x4_t *a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6)
{
  double v6 = 0.0;
  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    float v11 = *(float *)&a4;
    PKCFieldNoise::evalForce(a1, a2, *(double *)a3.i64, a4, 5.87747298e-39, a6);
    float32x4_t v7 = vmulq_f32(a3, a3);
    v7.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]);
    *(void *)&double v6 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v8, v11), v7.f32[0]), v7.f32[0]).u64[0];
  }
  return v6;
}

void PKCFieldNoise::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6)
{
  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    float v8 = a1[15].f32[2];
    float v9 = a1[15].f32[3] * a6;
    float32x4_t v18 = a2;
    float32x4_t v10 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0] + v9), vmulq_n_f32(a1[9], a2.f32[1] + v9)), vaddq_f32(a1[11], vmulq_n_f32(a1[10], a2.f32[2] + v9)));
    float v11 = (float)(1.25 / (float)(v8 + 0.083333)) + -1.0;
    BOOL v12 = v8 <= 0.0;
    float v13 = 14.0;
    if (!v12) {
      float v13 = v11;
    }
    uint64_t v20 = 0;
    int v19 = 0;
    float v14 = v13 * v10.f32[0];
    float v15 = vmuls_lane_f32(v13, *(float32x2_t *)v10.f32, 1);
    float v16 = vmuls_lane_f32(v13, v10, 2);
    __float2 v17 = __sincosf_stret(v9);
    srdnoise3_sincos((float *)&v20 + 1, (float *)&v20, (float *)&v19, v14, v15, v16, v17.__sinval, v17.__cosval);
    PKCField::calculatedFalloff(a1, v18);
  }
}

void PKCFieldNoise::evalForceVec2(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  float v4 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  if (fabsf(v4) >= 0.000030518)
  {
    float v8 = *(float32x2_t **)(a2 + 168);
    uint64_t v9 = *(void *)(a2 + 176);
    a4.n128_u32[0] = *(_DWORD *)(a2 + 272);
    __n128 v35 = a4;
    float32x2_t v10 = *(float32x2_t *)(a2 + 264);
    float v11 = *(double *)(a2 + 256);
    float v12 = *(float *)(a1 + 252) * v11;
    __float2 v15 = __sincosf_stret(v12);
    float cosval = v15.__cosval;
    LODWORD(v13) = *(void *)&v15;
    float v16 = *(float *)(a1 + 248);
    float v17 = (float)(1.25 / (float)(v16 + 0.083333)) + -1.0;
    BOOL v18 = v16 <= 0.0;
    float v19 = 14.0;
    if (!v18) {
      float v19 = v17;
    }
    float v34 = v19;
    float32x2_t v21 = *(float32x2_t **)(a2 + 8);
    uint64_t v20 = *(void *)(a2 + 16);
    double v22 = **(void ***)(a1 + 8);
    if (v22) {
      int v23 = [v22 isInfinite] ^ 1;
    }
    else {
      int v23 = 0;
    }
    float32x4_t v39 = 0uLL;
    float32x4_t v24 = (float32x4_t)v35;
    v24.f32[0] = v4 / v35.n128_f32[0];
    if (fabsf(*(float *)(a1 + 204)) >= 0.000030518)
    {
      if (a3 >= 1)
      {
        float32x2_t v31 = (float32x2_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0).u64[0];
        do
        {
          *(float32x2_t *)v24.f32 = vmul_n_f32(vadd_f32(v10, *v21), v35.n128_f32[0]);
          float32x4_t v37 = v24;
          float32x4_t v38 = v24;
          if (!v23 || (v29 = PKCField::contains(a1, &v38), float32x4_t v24 = v37, v29))
          {
            float32x4_t v30 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v12 + v24.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v12 + v24.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v12 + 0.0)));
            v30.i32[3] = 0;
            float v33 = srdnoise3_sincos_vector(&v39, vmulq_n_f32(v30, v34), v13, cosval);
            *float v8 = vadd_f32(*v8, vmul_n_f32(vmul_f32(v31, vmul_n_f32(*(float32x2_t *)v39.f32, v33)), PKCField::calculatedFalloff((float32x4_t *)a1, v37)));
          }
          float v8 = (float32x2_t *)((char *)v8 + v9);
          float32x2_t v21 = (float32x2_t *)((char *)v21 + v20);
          --a3;
        }
        while (a3);
      }
    }
    else if (a3 >= 1)
    {
      float32x2_t v32 = (float32x2_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0).u64[0];
      do
      {
        v25.i64[1] = v35.n128_i64[1];
        *(float32x2_t *)v25.f32 = vmul_n_f32(vadd_f32(v10, *v21), v35.n128_f32[0]);
        float32x4_t v38 = v25;
        if (!v23 || (v36 = v25.i64[0], int v26 = PKCField::contains(a1, &v38), v25.i64[0] = v36, v26))
        {
          float32x4_t v27 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v12 + v25.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v12 + v25.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v12 + 0.0)));
          v27.i32[3] = 0;
          float v28 = srdnoise3_sincos_vector(&v39, vmulq_n_f32(v27, v34), v13, cosval);
          *float v8 = vadd_f32(*v8, vmul_f32(v32, vmul_n_f32(*(float32x2_t *)v39.f32, v28)));
        }
        float v8 = (float32x2_t *)((char *)v8 + v9);
        float32x2_t v21 = (float32x2_t *)((char *)v21 + v20);
        --a3;
      }
      while (a3);
    }
  }
}

void PKCFieldNoise::evalForceVec2(uint64_t a1, uint64_t a2, int a3, int a4, int a5, __n128 a6)
{
  int v7 = a3;
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    PKCFieldNoise::evalForceVec2(a1, a2, a3, a6);
    return;
  }
  float v10 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  if (fabsf(v10) < 0.000030518) {
    return;
  }
  float v11 = *(float32x2_t **)(a2 + 168);
  uint64_t v44 = *(void *)(a2 + 176);
  a6.n128_u32[0] = *(_DWORD *)(a2 + 272);
  __n128 v40 = a6;
  float32x2_t v12 = *(float32x2_t *)(a2 + 264);
  float v13 = *(double *)(a2 + 256);
  float v14 = *(float *)(a1 + 252) * v13;
  __float2 v15 = __sincosf_stret(v14);
  float v16 = *(float *)(a1 + 248);
  float v17 = (float)(1.25 / (float)(v16 + 0.083333)) + -1.0;
  BOOL v18 = v16 <= 0.0;
  float v19 = 14.0;
  if (!v18) {
    float v19 = v17;
  }
  float v37 = v19;
  uint64_t v20 = *(float32x2_t **)(a2 + 8);
  uint64_t v43 = *(void *)(a2 + 16);
  float32x2_t v21 = **(void ***)(a1 + 8);
  if (v21) {
    int v39 = [v21 isInfinite] ^ 1;
  }
  else {
    int v39 = 0;
  }
  float32x4_t v46 = 0uLL;
  int v22 = a5;
  if (a4)
  {
    float32x4_t v24 = *(unsigned char **)(a2 + 200);
    uint64_t v23 = *(void *)(a2 + 208);
    if (!a5)
    {
LABEL_14:
      float32x4_t v25 = 0;
      uint64_t v38 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v23 = 0;
    float32x4_t v24 = 0;
    if (!a5) {
      goto LABEL_14;
    }
  }
  float32x4_t v25 = *(_DWORD **)(a2 + 136);
  uint64_t v38 = *(void *)(a2 + 144);
LABEL_17:
  if (v7 >= 1)
  {
    BOOL v26 = 0;
    v27.i32[1] = v40.n128_i32[1];
    *(float *)v27.i32 = v10 / v40.n128_f32[0];
    float v28 = fabsf(*(float *)(a1 + 204));
    char v35 = *(unsigned char *)(a1 + 200);
    float32x2_t v36 = (float32x2_t)vdupq_lane_s32(v27, 0).u64[0];
    BOOL v29 = 1;
    do
    {
      if (a4) {
        BOOL v26 = *v24 != 0;
      }
      if (v22)
      {
        BOOL v29 = (*(_DWORD *)(a1 + 240) & *v25) != 0;
        float32x4_t v25 = (_DWORD *)((char *)v25 + v38);
      }
      if (!v26 && v29)
      {
        v30.i64[1] = v40.n128_i64[1];
        *(float32x2_t *)v30.f32 = vmul_n_f32(vadd_f32(v12, *v20), v40.n128_f32[0]);
        float32x4_t v45 = v30;
        float32x4_t v42 = v30;
        if (!v39 || (v31 = PKCField::contains(a1, &v45), v30.i64[0] = v42.i64[0], int v22 = a5, v31))
        {
          float32x4_t v32 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v14 + v30.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v14 + v30.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v14 + 0.0)));
          v32.i32[3] = 0;
          float v33 = srdnoise3_sincos_vector(&v46, vmulq_n_f32(v32, v37), v15.__sinval, v15.__cosval);
          float32x2_t v34 = vmul_f32(v36, vmul_n_f32(*(float32x2_t *)v46.f32, v33));
          if (v28 < 0.000030518) {
            float32x2_t v34 = vmul_n_f32(v34, PKCField::calculatedFalloff((float32x4_t *)a1, v42));
          }
          int v22 = a5;
          if (a4) {
            *float32x4_t v24 = v35;
          }
          float32x2_t *v11 = vadd_f32(v34, *v11);
        }
      }
      v24 += v23;
      float v11 = (float32x2_t *)((char *)v11 + v44);
      uint64_t v20 = (float32x2_t *)((char *)v20 + v43);
      --v7;
    }
    while (v7);
  }
}

void PKCFieldUser::PKCFieldUser(PKCFieldUser *this, void *a2)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldUser::evalForce(uint64_t a1, float32x4_t a2, float32x4_t a3, float a4, float a5, double a6)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  double v6 = 0.0;
  if (fabsf(*(float *)(a1 + 196) * *(float *)(a1 + 192)) >= 0.000030518)
  {
    float32x4_t v8 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), a2.f32[0]), vmulq_lane_f32(*(float32x4_t *)(a1 + 144), *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 160), a2, 2), *(float32x4_t *)(a1 + 176)));
    uint64_t v18 = v8.i64[0];
    __int32 v19 = v8.i32[2];
    v13[0] = &v18;
    v13[1] = 0;
    float32x4_t v9 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), a3.f32[0]), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)a3.f32, 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), a3, 2), vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0)));
    __int32 v17 = v9.i32[2];
    uint64_t v16 = v9.i64[0];
    v13[2] = &v16;
    v13[3] = 0;
    float v11 = a4;
    float v12 = a5;
    v13[6] = &v12;
    v13[7] = 0;
    void v13[4] = &v11;
    v13[5] = 0;
    *(double *)&v13[8] = a6;
    int v15 = 0;
    double v14 = 0.0;
    v13[9] = &v14;
    v13[10] = 0;
    PKPhysicsFieldUserInvokeBatchBlockWith(*(void **)(a1 + 248), 1, (uint64_t)v13);
    PKPhysicsFieldUserInvokeBlockWith(*(void **)(a1 + 248), 1, (uint64_t)v13);
    return v14;
  }
  return v6;
}

void PKCFieldVelocity::PKCFieldVelocity(PKCFieldVelocity *this)
{
}

{
  PKCField::PKCField((PKCField *)this);
}

double PKCFieldVelocity::evalForce()
{
  return 0.0;
}

__n128 PKCFieldVelocity::evalVelocity(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v3 = *(void *)(a1 + 248);
  if (v3)
  {
    float32x4_t v4 = 0uLL;
    _D1 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), a3.f32[0]), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)a3.f32, 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), a3, 2), vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0))).u64[0];
    int v6 = *(_DWORD *)v3;
    int v7 = *(_DWORD *)(v3 + 4);
    if (*(int *)v3 >= 0) {
      int v8 = *(_DWORD *)v3;
    }
    else {
      int v8 = v6 + 1;
    }
    _S4 = (float)v7;
    __asm { FMLA            S2, S4, V1.S[1] }
    int v15 = (int)vmlas_n_f32((float)(v8 >> 1), (float)v6, *(float *)&_D1);
    int v16 = (int)_S2;
    if ((((int)_S2 | v15) & 0x80000000) == 0)
    {
      BOOL v17 = v6 <= v15 || v7 <= v16;
      if (!v17 && *(int *)(v3 + 8) >= 1) {
        float32x4_t v4 = *(float32x4_t *)(*(void *)(v3 + 64) + 16 * (v15 + v6 * v16));
      }
    }
    float32x4_t v18 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v4, PKCField::calculatedFalloff((float32x4_t *)a1, a2)), *(float *)(a1 + 196)), *(float *)(a1 + 192));
    result.n128_u64[0] = (unint64_t)vmul_laneq_f32(*(float32x2_t *)v18.f32, v18, 3);
  }
  else
  {
    return *(__n128 *)(a1 + 224);
  }
  return result;
}

void PKCFieldVelocity::evalVelocityVec2(_DWORD *a1, void *a2, int a3, int a4, int a5)
{
  if (a4)
  {
    int v8 = (unsigned char *)a2[25];
    uint64_t v23 = a2[26];
    if (!a5)
    {
LABEL_3:
      float32x4_t v9 = 0;
      uint64_t v22 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    int v8 = 0;
    uint64_t v23 = 0;
    if (!a5) {
      goto LABEL_3;
    }
  }
  float32x4_t v9 = (_DWORD *)a2[17];
  uint64_t v22 = a2[18];
LABEL_6:
  if (a3 >= 1)
  {
    uint64_t v10 = 0;
    BOOL v11 = 0;
    float v12 = (float32x2_t *)a2[29];
    uint64_t v13 = a2[30];
    uint64_t v14 = a2[2];
    uint64_t v20 = a2[1];
    uint64_t v21 = a2[5];
    float32x2_t v15 = (float32x2_t)a2[33];
    int v16 = (const float *)(a2 + 34);
    BOOL v17 = 1;
    float32x2_t v18 = vld1_dup_f32(v16);
    do
    {
      if (a4) {
        BOOL v11 = *v8 != 0;
      }
      if (a5)
      {
        BOOL v17 = (a1[60] & *v9) != 0;
        float32x4_t v9 = (_DWORD *)((char *)v9 + v22);
      }
      if (!v11 && v17)
      {
        BOOL v24 = v17;
        int v25 = a3;
        *(double *)&float32x2_t v19 = (*(double (**)(_DWORD *, double, double, float, double, double))(*(void *)a1 + 48))(a1, COERCE_DOUBLE(vmul_f32(v18, vadd_f32(v15, *(float32x2_t *)(v20 + v10)))), COERCE_DOUBLE(vmul_f32(v18, *(float32x2_t *)(v21 + v10))), 1.0, 0.0, 0.0);
        BOOL v17 = v24;
        a3 = v25;
        float32x2_t *v12 = vdiv_f32(v19, v18);
      }
      if (a4)
      {
        *int v8 = 1;
        v8 += v23;
      }
      float v12 = (float32x2_t *)((char *)v12 + v13);
      v10 += v14;
      --a3;
    }
    while (a3);
  }
}

void PKCFieldVelocity::setGrid(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  float32x4_t v4 = *(std::__shared_weak_count **)(a1 + 256);
  *(void *)(a1 + 248) = v3;
  *(void *)(a1 + 256) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void PKCAether::PKCAether(PKCAether *this)
{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

void PKCAether::~PKCAether(PKCAether *this)
{
  uint64_t v1 = (void **)((char *)this + 16);
  std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;

  uint64_t v1 = (void **)((char *)this + 16);
  std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

PKCAether::Evaluator *PKCAether::Evaluator::Evaluator(PKCAether::Evaluator *this, uint64_t **a2)
{
  long long v3 = 0uLL;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  if (a2)
  {
    float v5 = (char **)((char *)this + 24);
    unint64_t v6 = PKCAether::fieldCount((PKCAether *)a2);
    std::vector<PKPoint>::reserve((void **)this + 3, v6);
    int v7 = a2[2];
    int v8 = a2[3];
    if (v7 != v8)
    {
      while (1)
      {
        float32x4_t v9 = (std::__shared_weak_count *)v7[1];
        if (v9) {
          break;
        }
LABEL_12:
        v7 += 2;
        if (v7 == v8) {
          goto LABEL_13;
        }
      }
      uint64_t v10 = *v7;
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)&long long v30 = 0;
      BOOL v11 = std::__shared_weak_count::lock(v9);
      *((void *)&v30 + 1) = v11;
      if (v11)
      {
        *(void *)&long long v30 = v10;
        if (!v10) {
          goto LABEL_9;
        }
      }
      else if (!(void)v30)
      {
LABEL_9:
        if (v11) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        }
        std::__shared_weak_count::__release_weak(v9);
        goto LABEL_12;
      }
      std::vector<std::shared_ptr<PKCField>>::push_back[abi:ne180100]((uint64_t *)this, &v30);
      BOOL v11 = (std::__shared_weak_count *)*((void *)&v30 + 1);
      goto LABEL_9;
    }
LABEL_13:
    BOOL v29 = (const PKCAether *)a2;
    float v12 = *(uint64_t **)this;
    uint64_t v13 = (uint64_t *)*((void *)this + 1);
    if (*(uint64_t **)this != v13)
    {
      do
      {
        uint64_t v15 = *v12;
        uint64_t v14 = (std::__shared_weak_count *)v12[1];
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v17 = (void *)*((void *)this + 4);
        unint64_t v16 = *((void *)this + 5);
        if ((unint64_t)v17 >= v16)
        {
          uint64_t v19 = ((char *)v17 - *v5) >> 3;
          if ((unint64_t)(v19 + 1) >> 61) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v20 = v16 - (void)*v5;
          uint64_t v21 = v20 >> 2;
          if (v20 >> 2 <= (unint64_t)(v19 + 1)) {
            uint64_t v21 = v19 + 1;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v21;
          }
          if (v22) {
            uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)this + 40, v22);
          }
          else {
            uint64_t v23 = 0;
          }
          BOOL v24 = &v23[8 * v19];
          *(void *)BOOL v24 = v15;
          float32x2_t v18 = v24 + 8;
          BOOL v26 = (char *)*((void *)this + 3);
          int v25 = (char *)*((void *)this + 4);
          if (v25 != v26)
          {
            do
            {
              uint64_t v27 = *((void *)v25 - 1);
              v25 -= 8;
              *((void *)v24 - 1) = v27;
              v24 -= 8;
            }
            while (v25 != v26);
            int v25 = *v5;
          }
          *((void *)this + 3) = v24;
          *((void *)this + 4) = v18;
          *((void *)this + 5) = &v23[8 * v22];
          if (v25) {
            operator delete(v25);
          }
        }
        else
        {
          void *v17 = v15;
          float32x2_t v18 = v17 + 1;
        }
        *((void *)this + 4) = v18;
        if (v14) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v14);
        }
        v12 += 2;
      }
      while (v12 != v13);
    }
    long long v3 = *(_OWORD *)v29;
  }
  *((_OWORD *)this + 3) = v3;
  return this;
}

void sub_213574A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11)
{
  uint64_t v14 = *v12;
  if (*v12)
  {
    *(void *)(v11 + 32) = v14;
    operator delete(v14);
  }
  a11 = (void **)v11;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&a11);
  _Unwind_Resume(a1);
}

uint64_t PKCAether::fieldCount(PKCAether *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = (long long *)*((void *)this + 3);
  if ((long long *)v1 == v2)
  {
    uint64_t v2 = (long long *)*((void *)this + 2);
  }
  else
  {
    do
    {
      uint64_t v4 = *(void *)(v1 + 8);
      if (!v4 || *(void *)(v4 + 8) == -1)
      {
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>((uint64_t)&v9, (long long *)(v1 + 16), v2, v1);
        uint64_t v2 = v5;
        unint64_t v6 = (long long *)*((void *)this + 3);
        if (v6 != v5)
        {
          do
          {
            int v7 = (std::__shared_weak_count *)*((void *)v6 - 1);
            if (v7) {
              std::__shared_weak_count::__release_weak(v7);
            }
            --v6;
          }
          while (v6 != v2);
        }
        *((void *)this + 3) = v2;
      }
      else
      {
        v1 += 16;
      }
    }
    while ((long long *)v1 != v2);
    uint64_t v1 = *((void *)this + 2);
  }
  return ((uint64_t)v2 - v1) >> 4;
}

void **std::vector<std::shared_ptr<PKCField>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  __n128 result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  int v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<PKCField>>::__swap_out_circular_buffer(a1, v18);
    char v9 = (void *)a1[1];
    __n128 result = std::__split_buffer<std::shared_ptr<PKCField>>::~__split_buffer(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    char v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_213574CB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<PKCField>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t PKCAether::Evaluator::evalVelocity(uint64_t result, int a2, float32x4_t a3, __n128 a4, float a5, float a6, double a7)
{
  float32x4_t v25 = a3;
  int v7 = *(uint64_t **)(result + 24);
  uint64_t v8 = *(uint64_t **)(result + 32);
  if (v7 != v8)
  {
    uint64_t v13 = result;
    do
    {
      uint64_t v14 = *v7;
      if (*(unsigned char *)(*v7 + 244))
      {
        __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 56))(*v7);
        if (result)
        {
          if ((*(_DWORD *)(v14 + 240) & a2) != 0)
          {
            if (*(unsigned char *)(v14 + 200))
            {
              __n128 result = PKCField::contains(v14, &v25);
              if (result)
              {
                uint64_t v21 = *(uint64_t (**)(_DWORD *, __n128, __n128, __n128, __n128, __n128))(*(void *)v14 + 48);
                unint64_t v22 = (_DWORD *)v14;
LABEL_19:
                v15.n128_f32[0] = a5;
                v16.n128_f32[0] = a6;
                v17.n128_f64[0] = a7;
                return v21(v22, (__n128)a3, a4, v15, v16, v17);
              }
            }
          }
        }
      }
      ++v7;
    }
    while (v7 != v8);
    float32x2_t v18 = *(void **)(v13 + 24);
    uint64_t v19 = *(void **)(v13 + 32);
    while (v18 != v19)
    {
      uint64_t v20 = (_DWORD *)*v18;
      if (*(unsigned char *)(*v18 + 244))
      {
        __n128 result = (*(uint64_t (**)(void))(*(void *)v20 + 56))(*v18);
        if (result)
        {
          if ((v20[60] & a2) != 0)
          {
            __n128 result = PKCField::contains((uint64_t)v20, &v25);
            if (result)
            {
              uint64_t v21 = *(uint64_t (**)(_DWORD *, __n128, __n128, __n128, __n128, __n128))(*(void *)v20 + 48);
              unint64_t v22 = v20;
              goto LABEL_19;
            }
          }
        }
      }
      ++v18;
    }
  }
  return result;
}

void PKCAether::Evaluator::evalForce(float32x4_t *a1, int a2, float a3, float32x4_t a4, __n128 a5, double a6, float a7, double a8)
{
  v23.n128_f64[0] = a6;
  float32x4_t v26 = a4;
  uint64_t v12 = (uint64_t *)a1[1].i64[1];
  uint64_t v13 = (uint64_t *)a1[2].i64[0];
  if (v12 == v13)
  {
    __n128 v17 = (uint64_t *)a1[1].i64[1];
LABEL_10:
    float32x4_t v25 = vmulq_n_f32(vmulq_n_f32(a1[3], v23.n128_f32[0]), a3);
    while (v17 != v12)
    {
      float32x2_t v18 = (_DWORD *)*v17;
      if (*(unsigned char *)(*v17 + 244)
        && ((*(uint64_t (**)(uint64_t))(*(void *)v18 + 56))(*v17) & 1) == 0
        && (v18[60] & a2) != 0)
      {
        if (PKCField::contains((uint64_t)v18, &v26))
        {
          *(double *)v19.i64 = (*(double (**)(_DWORD *, float32x4_t, __n128, __n128, float, double))(*(void *)v18 + 40))(v18, a4, a5, v23, a7, a8);
          float32x4_t v25 = vaddq_f32(v25, v19);
        }
      }
      ++v17;
    }
  }
  else
  {
    while (1)
    {
      uint64_t v14 = *v12;
      if (*(unsigned char *)(*v12 + 244))
      {
        if (((*(uint64_t (**)(uint64_t))(*(void *)v14 + 56))(*v12) & 1) == 0
          && (*(_DWORD *)(v14 + 240) & a2) != 0
          && *(unsigned char *)(v14 + 200)
          && (PKCField::contains(v14, &v26) & 1) != 0)
        {
          break;
        }
      }
      if (++v12 == v13)
      {
        __n128 v17 = (uint64_t *)a1[1].i64[1];
        uint64_t v12 = (uint64_t *)a1[2].i64[0];
        goto LABEL_10;
      }
    }
    uint64_t v20 = *(void (**)(uint64_t, __n128, __n128, __n128, __n128, __n128))(*(void *)v14 + 40);
    v15.n128_f32[0] = a7;
    v16.n128_f64[0] = a8;
    v20(v14, (__n128)a4, a5, v23, v15, v16);
  }
}

void PKCAether::Evaluator::evalFieldsVec2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(unsigned __int8 *)(a2 + 152);
  if (*(unsigned char *)(a2 + 152))
  {
    int v6 = *(_DWORD *)(a2 + 128);
    if (!v6) {
      return;
    }
  }
  else
  {
    int v6 = -1;
  }
  uint64_t v65 = 0;
  long long v66 = 0;
  long long v67 = 0;
  __p = 0;
  float32x4_t v63 = 0;
  long long v64 = 0;
  long long v59 = 0;
  int32x4_t v60 = 0;
  int32x4_t v61 = 0;
  int v7 = *(uint64_t **)(a1 + 24);
  for (uint64_t i = *(uint64_t **)(a1 + 32); v7 != i; ++v7)
  {
    uint64_t v9 = *v7;
    if (!*(unsigned char *)(*v7 + 244)) {
      continue;
    }
    if ((*(_DWORD *)(v9 + 240) & v6) == 0) {
      continue;
    }
    uint64_t v10 = **(void ***)(v9 + 8);
    if (v10)
    {
      if ([v10 isEmpty]) {
        continue;
      }
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 56))(v9))
    {
      unint64_t v11 = **(void ***)(v9 + 8);
      if (*(unsigned char *)(v9 + 200))
      {
        if (v11)
        {
          int v12 = [v11 isInfinite] ^ 1;
          if (!v5) {
            goto LABEL_26;
          }
        }
        else
        {
          int v12 = 0;
          if (!v5) {
            goto LABEL_26;
          }
        }
        if (!v12) {
          break;
        }
LABEL_26:
        __n128 v17 = v66;
        if (v66 < (void *)v67) {
          goto LABEL_58;
        }
        uint64_t v18 = ((char *)v66 - (unsigned char *)v65) >> 3;
        if ((unint64_t)(v18 + 1) >> 61) {
          goto LABEL_120;
        }
        unint64_t v19 = (v67 - (unsigned char *)v65) >> 2;
        if (v19 <= v18 + 1) {
          unint64_t v19 = v18 + 1;
        }
        if ((unint64_t)(v67 - (unsigned char *)v65) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        if (v20) {
          uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v67, v20);
        }
        else {
          uint64_t v21 = 0;
        }
        float v33 = &v21[8 * v18];
        *(void *)float v33 = v9;
        float32x4_t v32 = v33 + 8;
        char v35 = (char *)v65;
        float32x2_t v34 = (char *)v66;
        if (v66 != v65)
        {
          do
          {
            uint64_t v36 = *((void *)v34 - 1);
            v34 -= 8;
            *((void *)v33 - 1) = v36;
            v33 -= 8;
          }
          while (v34 != v35);
          goto LABEL_88;
        }
        goto LABEL_89;
      }
      if (v11)
      {
        int v15 = [v11 isInfinite] ^ 1;
        if (!v5) {
          goto LABEL_57;
        }
      }
      else
      {
        int v15 = 0;
        if (!v5) {
          goto LABEL_57;
        }
      }
      if (v15)
      {
LABEL_57:
        __n128 v17 = v66;
        if (v66 < (void *)v67)
        {
LABEL_58:
          void *v17 = v9;
          float32x4_t v32 = v17 + 1;
LABEL_91:
          long long v66 = v32;
          continue;
        }
        uint64_t v37 = ((char *)v66 - (unsigned char *)v65) >> 3;
        if ((unint64_t)(v37 + 1) >> 61) {
LABEL_120:
        }
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        unint64_t v38 = (v67 - (unsigned char *)v65) >> 2;
        if (v38 <= v37 + 1) {
          unint64_t v38 = v37 + 1;
        }
        if ((unint64_t)(v67 - (unsigned char *)v65) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v38;
        }
        if (v20) {
          uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v67, v20);
        }
        else {
          uint64_t v21 = 0;
        }
        float v33 = &v21[8 * v37];
        *(void *)float v33 = v9;
        float32x4_t v32 = v33 + 8;
        float32x4_t v46 = (char *)v65;
        float32x2_t v34 = (char *)v66;
        if (v66 != v65)
        {
          do
          {
            uint64_t v47 = *((void *)v34 - 1);
            v34 -= 8;
            *((void *)v33 - 1) = v47;
            v33 -= 8;
          }
          while (v34 != v46);
LABEL_88:
          float32x2_t v34 = (char *)v65;
        }
LABEL_89:
        uint64_t v65 = v33;
        long long v66 = v32;
        long long v67 = &v21[8 * v20];
        if (v34) {
          operator delete(v34);
        }
        goto LABEL_91;
      }
    }
    else if (*(unsigned char *)(v9 + 200))
    {
      uint64_t v13 = **(void ***)(v9 + 8);
      if (v13)
      {
        int v14 = [v13 isInfinite] ^ 1;
        if (!v5) {
          goto LABEL_37;
        }
      }
      else
      {
        int v14 = 0;
        if (!v5) {
          goto LABEL_37;
        }
      }
      if (v14)
      {
LABEL_37:
        unint64_t v22 = v63;
        if (v63 >= v64)
        {
          uint64_t v28 = (v63 - (unsigned char *)__p) >> 3;
          if ((unint64_t)(v28 + 1) >> 61) {
            goto LABEL_120;
          }
          unint64_t v29 = (v64 - (unsigned char *)__p) >> 2;
          if (v29 <= v28 + 1) {
            unint64_t v29 = v28 + 1;
          }
          if ((unint64_t)(v64 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30) {
            int v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v64, v30);
          }
          else {
            int v31 = 0;
          }
          float32x4_t v42 = &v31[8 * v28];
          *(void *)float32x4_t v42 = v9;
          __n128 v23 = v42 + 8;
          uint64_t v44 = (char *)__p;
          uint64_t v43 = v63;
          if (v63 != __p)
          {
            do
            {
              uint64_t v45 = *((void *)v43 - 1);
              v43 -= 8;
              *((void *)v42 - 1) = v45;
              v42 -= 8;
            }
            while (v43 != v44);
            uint64_t v43 = (char *)__p;
          }
          __p = v42;
          float32x4_t v63 = v23;
          long long v64 = &v31[8 * v30];
          if (v43) {
            operator delete(v43);
          }
        }
        else
        {
          *(void *)float32x4_t v63 = v9;
          __n128 v23 = v22 + 8;
        }
        float32x4_t v63 = v23;
      }
    }
    else
    {
      if (v60 >= v61)
      {
        uint64_t v24 = (v60 - v59) >> 3;
        if ((unint64_t)(v24 + 1) >> 61) {
          goto LABEL_120;
        }
        unint64_t v25 = (v61 - v59) >> 2;
        if (v25 <= v24 + 1) {
          unint64_t v25 = v24 + 1;
        }
        if ((unint64_t)(v61 - v59) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        if (v26) {
          uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v61, v26);
        }
        else {
          uint64_t v27 = 0;
        }
        int v39 = &v27[8 * v24];
        *(void *)int v39 = v9;
        __n128 v16 = v39 + 8;
        __n128 v40 = v60;
        if (v60 != v59)
        {
          do
          {
            uint64_t v41 = *((void *)v40 - 1);
            v40 -= 8;
            *((void *)v39 - 1) = v41;
            v39 -= 8;
          }
          while (v40 != v59);
          __n128 v40 = v59;
        }
        long long v59 = v39;
        int32x4_t v61 = &v27[8 * v26];
        if (v40) {
          operator delete(v40);
        }
      }
      else
      {
        *(void *)int32x4_t v60 = v9;
        __n128 v16 = v60 + 8;
      }
      int32x4_t v60 = v16;
    }
  }
  if ((int)a3 >= 1)
  {
    unint64_t v49 = *(void **)(a2 + 168);
    uint64_t v48 = *(void *)(a2 + 176);
    int v50 = a3;
    do
    {
      void *v49 = 0;
      unint64_t v49 = (void *)((char *)v49 + v48);
      --v50;
    }
    while (v50);
  }
  float32x4_t v52 = v65;
  float32x4_t v51 = v66;
  if (v65 == v66 && __p == v63)
  {
    float32x4_t v58 = v59;
    if (v59 == v60) {
      goto LABEL_110;
    }
    do
    {
      (*(void (**)(void, uint64_t, uint64_t, void, BOOL))(**(void **)v58 + 24))(*(void *)v58, a2, a3, 0, v5 == 0);
      v58 += 8;
    }
    while (v58 != v60);
  }
  else
  {
    if ((int)a3 >= 1)
    {
      float32x4_t v54 = *(unsigned char **)(a2 + 200);
      uint64_t v53 = *(void *)(a2 + 208);
      int v55 = a3;
      do
      {
        *float32x4_t v54 = 0;
        v54 += v53;
        --v55;
      }
      while (v55);
      float32x4_t v52 = v65;
    }
    while (v52 != v51)
    {
      (*(void (**)(void, uint64_t, uint64_t, uint64_t, BOOL))(*(void *)*v52 + 32))(*v52, a2, a3, 1, v5 == 0);
      ++v52;
    }
    float32x4_t v56 = (char *)__p;
    long long v57 = v63;
    while (v56 != v57)
    {
      (*(void (**)(void, uint64_t, uint64_t, uint64_t, BOOL))(**(void **)v56 + 24))(*(void *)v56, a2, a3, 1, v5 == 0);
      v56 += 8;
    }
    float32x4_t v58 = v59;
    if (v59 == v60) {
      goto LABEL_110;
    }
    do
    {
      (*(void (**)(void, uint64_t, uint64_t, uint64_t, BOOL))(**(void **)v58 + 24))(*(void *)v58, a2, a3, 1, v5 == 0);
      v58 += 8;
    }
    while (v58 != v60);
  }
  float32x4_t v58 = v59;
LABEL_110:
  if (v58) {
    operator delete(v58);
  }
  if (__p)
  {
    float32x4_t v63 = (char *)__p;
    operator delete(__p);
  }
  if (v65)
  {
    long long v66 = v65;
    operator delete(v65);
  }
}

void sub_213575680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void PKCAether::addField(uint64_t a1, long long *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a2 + 1);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)a2;
      goto LABEL_6;
    }
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v6 = 0;
LABEL_6:
  uint64_t v8 = *(uint64_t **)(a1 + 16);
  uint64_t v9 = *(uint64_t **)(a1 + 24);
  int v7 = (uint64_t *)(a1 + 16);
  if (v8 != v9)
  {
    while (1)
    {
      uint64_t v10 = (std::__shared_weak_count *)v8[1];
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v8;
      atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      int v12 = std::__shared_weak_count::lock(v10);
      if (!v12) {
        break;
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      std::__shared_weak_count::__release_weak(v10);
      if (v11 == v6) {
        goto LABEL_15;
      }
LABEL_13:
      v8 += 2;
      if (v8 == v9) {
        goto LABEL_14;
      }
    }
    std::__shared_weak_count::__release_weak(v10);
LABEL_12:
    if (!v6) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
LABEL_14:
  std::vector<std::weak_ptr<PKCField>>::push_back[abi:ne180100](v7, a2);
LABEL_15:
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_2135757D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void **std::vector<std::weak_ptr<PKCField>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  __n128 result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  int v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)result, v13);
    int v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)int v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::weak_ptr<PKCField>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    __n128 result = std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_2135758F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void PKCAether::removeField(uint64_t a1, uint64_t *a2)
{
  PKCAether::fieldCount((PKCAether *)a1);
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    unint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *a2;
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
  uint64_t v6 = 0;
LABEL_6:
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7 != *(void *)(a1 + 24))
  {
    do
    {
      uint64_t v8 = *(std::__shared_weak_count **)(v7 + 8);
      if (v8 && (uint64_t v9 = std::__shared_weak_count::lock(v8)) != 0)
      {
        uint64_t v10 = *(void *)v7;
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
        if (v10 == v6) {
          goto LABEL_10;
        }
      }
      else if (!v6)
      {
LABEL_10:
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>((uint64_t)&v15, (long long *)(v7 + 16), *(long long **)(a1 + 24), v7);
        uint64_t v12 = v11;
        for (uint64_t i = *(void *)(a1 + 24); i != v12; i -= 16)
        {
          int v14 = *(std::__shared_weak_count **)(i - 8);
          if (v14) {
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        *(void *)(a1 + 24) = v12;
        continue;
      }
      v7 += 16;
      uint64_t v12 = *(void *)(a1 + 24);
    }
    while (v7 != v12);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_2135759FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void PKCAether::removeAllFields(PKCAether *this)
{
}

double PKCField::evalVelocity()
{
  return 0.0;
}

uint64_t PKCField::isVelocity(PKCField *this)
{
  return 0;
}

void PKCFieldLinearGravity::~PKCFieldLinearGravity(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldLinearGravity::type(PKCFieldLinearGravity *this)
{
  return 1;
}

void PKCFieldRadialGravity::~PKCFieldRadialGravity(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldRadialGravity::type(PKCFieldRadialGravity *this)
{
  return 2;
}

void PKCFieldSpring::~PKCFieldSpring(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldSpring::type(PKCFieldSpring *this)
{
  return 3;
}

void PKCFieldElectric::~PKCFieldElectric(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldElectric::type(PKCFieldElectric *this)
{
  return 5;
}

void PKCFieldMagnetic::~PKCFieldMagnetic(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldMagnetic::type(PKCFieldMagnetic *this)
{
  return 4;
}

void PKCFieldDrag::~PKCFieldDrag(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldDrag::type(PKCFieldDrag *this)
{
  return 6;
}

void PKCFieldVortex::~PKCFieldVortex(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldVortex::type(PKCFieldVortex *this)
{
  return 7;
}

void PKCFieldNoise::~PKCFieldNoise(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldNoise::type(PKCFieldNoise *this)
{
  return 10;
}

void PKCFieldTurbulence::~PKCFieldTurbulence(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldTurbulence::type(PKCFieldTurbulence *this)
{
  return 9;
}

void PKCFieldUser::~PKCFieldUser(PKCField *this)
{
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldUser::type(PKCFieldUser *this)
{
  return 11;
}

void PKCFieldVelocity::~PKCFieldVelocity(PKCField *this)
{
  *(void *)this = &unk_26C3F3AC0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  PKCField::~PKCField(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_26C3F3AC0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  PKCField::~PKCField(this);

  JUMPOUT(0x21668C8E0);
}

uint64_t PKCFieldVelocity::isVelocity(PKCFieldVelocity *this)
{
  return 1;
}

uint64_t PKCFieldVelocity::type(PKCFieldVelocity *this)
{
  return 8;
}

void std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<std::shared_ptr<PKCField>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>,std::reverse_iterator<std::shared_ptr<PKCField>*>,std::reverse_iterator<std::shared_ptr<PKCField>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>,std::reverse_iterator<std::shared_ptr<PKCField>*>,std::reverse_iterator<std::shared_ptr<PKCField>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<PKCField>>,std::reverse_iterator<std::shared_ptr<PKCField>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    long long v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::shared_ptr<PKCField>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<PKCField>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t std::vector<std::weak_ptr<PKCField>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    long long v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::weak_ptr<PKCField>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void b2ChainShape::~b2ChainShape(b2ChainShape *this)
{
  *(void *)this = &unk_26C3F3548;
  uint64_t v2 = (void *)*((void *)this + 2);
  *((void *)this + 3) = v2;
  if (v2) {
    operator delete(v2);
  }
}

{
  void *v2;

  *(void *)this = &unk_26C3F3548;
  uint64_t v2 = (void *)*((void *)this + 2);
  *((void *)this + 3) = v2;
  if (v2) {
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26C3F3548;
  uint64_t v2 = (void *)*((void *)this + 2);
  *((void *)this + 3) = v2;
  if (v2) {
    operator delete(v2);
  }

  JUMPOUT(0x21668C8E0);
}

void *b2ChainShape::CreateLoop(void **this, const b2Vec2 *a2, int a3)
{
  std::vector<b2Vec2>::resize((uint64_t)(this + 2), a3 + 1);
  uint64_t result = memcpy(this[2], a2, 8 * a3);
  *((void *)this[2] + a3) = *(void *)this[2];
  long long v7 = this[2];
  this[5] = (void *)v7[a3 - 1];
  this[6] = (void *)v7[1];
  *((_WORD *)this + 28) = 257;
  return result;
}

void *b2ChainShape::CreateChain(void **this, const b2Vec2 *a2, int a3)
{
  if (a3 <= 1) {
    b2ChainShape::CreateChain();
  }
  std::vector<b2Vec2>::resize((uint64_t)(this + 2), a3);
  uint64_t result = memcpy(this[2], a2, 8 * a3);
  *((_WORD *)this + 28) = 0;
  return result;
}

uint64_t b2ChainShape::SetPrevVertex(uint64_t this, const b2Vec2 *a2)
{
  *(b2Vec2 *)(this + 40) = *a2;
  *(unsigned char *)(this + 56) = 1;
  return this;
}

uint64_t b2ChainShape::SetNextVertex(uint64_t this, const b2Vec2 *a2)
{
  *(b2Vec2 *)(this + 48) = *a2;
  *(unsigned char *)(this + 57) = 1;
  return this;
}

void b2ChainShape::Clone(b2ChainShape *this)
{
}

uint64_t b2ChainShape::GetChildCount(b2ChainShape *this)
{
  return ((*((void *)this + 3) - *((void *)this + 2)) >> 3) - 1;
}

uint64_t b2ChainShape::GetChildEdge(uint64_t this, b2EdgeShape *a2, signed int a3)
{
  if (a3 < 0 || (uint64_t v3 = *(void *)(this + 16), (int)(((unint64_t)(*(void *)(this + 24) - v3) >> 3) - 1) <= a3)) {
    b2ChainShape::GetChildEdge();
  }
  *((_DWORD *)a2 + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 1;
  *((_DWORD *)a2 + 3) = *(_DWORD *)(this + 12);
  *((void *)a2 + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = *(void *)(v3 + 8 * a3);
  *((void *)a2 + 3) = *(void *)(*(void *)(this + 16) + 8 * (a3 + 1));
  if (a3)
  {
    *((void *)a2 + 4) = *(void *)(*(void *)(this + 16) + 8 * (a3 - 1));
    char v4 = 1;
  }
  else
  {
    *((void *)a2 + 4) = *(void *)(this + 40);
    char v4 = *(unsigned char *)(this + 56);
  }
  *((unsigned char *)a2 + 48) = v4;
  uint64_t v5 = *(void *)(this + 16);
  if ((int)(((unint64_t)(*(void *)(this + 24) - v5) >> 3) - 2) <= a3)
  {
    *((void *)a2 + 5) = *(void *)(this + 48);
    char v6 = *(unsigned char *)(this + 57);
  }
  else
  {
    *((void *)a2 + 5) = *(void *)(v5 + 8 * (a3 + 2));
    char v6 = 1;
  }
  *((unsigned char *)a2 + 49) = v6;
  return this;
}

uint64_t b2ChainShape::TestPoint(b2ChainShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  return 0;
}

void b2ChainShape::ComputeDistance(b2ChainShape *this, const b2Transform *a2, float32x2_t *a3, float *a4, b2Vec2 *a5, signed int a6)
{
  v10[0] = &unk_26C3F3338;
  v10[1] = 0x3C1374BC00000001;
  v10[4] = 0;
  v10[5] = 0;
  __int16 v11 = 0;
  b2ChainShape::GetChildEdge((uint64_t)this, (b2EdgeShape *)v10, a6);
  b2EdgeShape::ComputeDistance((b2EdgeShape *)v10, a2, a3, a4, a5);
}

uint64_t b2ChainShape::RayCast(uint64_t a1, float *a2, float *a3, float *a4, int a5)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = (unint64_t)(*(void *)(a1 + 24) - v5) >> 3;
  if ((int)v6 <= a5) {
    b2ChainShape::RayCast();
  }
  v9[0] = &unk_26C3F3338;
  v9[1] = 0x3C1374BC00000001;
  v9[4] = 0;
  v9[5] = 0;
  __int16 v10 = 0;
  if (a5 + 1 == v6) {
    int v7 = 0;
  }
  else {
    int v7 = a5 + 1;
  }
  v9[2] = *(void *)(v5 + 8 * a5);
  v9[3] = *(void *)(v5 + 8 * v7);
  return b2EdgeShape::RayCast((float *)v9, a2, a3, a4);
}

uint64_t b2ChainShape::ComputeAABB(uint64_t result, float *a2, float *a3, int a4)
{
  uint64_t v4 = *(void *)(result + 16);
  unint64_t v5 = (unint64_t)(*(void *)(result + 24) - v4) >> 3;
  if ((int)v5 <= a4) {
    b2ChainShape::ComputeAABB();
  }
  if (a4 + 1 == v5) {
    int v6 = 0;
  }
  else {
    int v6 = a4 + 1;
  }
  int v7 = (float *)(v4 + 8 * a4);
  float v9 = a3[2];
  float v8 = a3[3];
  float v10 = v7[1];
  float v11 = a3[1];
  float v12 = *a3 + (float)((float)(v8 * *v7) - (float)(v9 * v10));
  float v13 = (float)((float)(v8 * v10) + (float)(v9 * *v7)) + v11;
  long long v14 = (float *)(v4 + 8 * v6);
  float v15 = v14[1];
  float v16 = (float)(v8 * *v14) - (float)(v9 * v15);
  float v17 = *a3 + v16;
  float v18 = v11 + (float)((float)(v8 * v15) + (float)(v9 * *v14));
  if (v12 >= v17) {
    float v19 = *a3 + v16;
  }
  else {
    float v19 = v12;
  }
  if (v12 <= v17) {
    float v20 = *a3 + v16;
  }
  else {
    float v20 = v12;
  }
  if (v13 >= v18) {
    float v21 = v18;
  }
  else {
    float v21 = v13;
  }
  *a2 = v19;
  a2[1] = v21;
  if (v13 > v18) {
    float v18 = v13;
  }
  a2[2] = v20;
  a2[3] = v18;
  return result;
}

void b2ChainShape::ComputeMass(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
}

void b2CircleShape::Clone(b2CircleShape *this)
{
}

uint64_t b2CircleShape::GetChildCount(b2CircleShape *this)
{
  return 1;
}

BOOL b2CircleShape::TestPoint(b2CircleShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v6 = *((float *)this + 4);
  float v5 = *((float *)this + 5);
  return (float)((float)((float)(a3->y - (float)(a2->var0.y + (float)((float)(var1 * v5) + (float)(var0 * v6))))
                       * (float)(a3->y - (float)(a2->var0.y + (float)((float)(var1 * v5) + (float)(var0 * v6)))))
               + (float)((float)(a3->x - (float)(a2->var0.x + (float)((float)(var1 * v6) - (float)(var0 * v5))))
                       * (float)(a3->x - (float)(a2->var0.x + (float)((float)(var1 * v6) - (float)(var0 * v5)))))) <= (float)(*((float *)this + 3) * *((float *)this + 3));
}

float b2CircleShape::ComputeDistance(b2CircleShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v8 = *((float *)this + 4);
  float v7 = *((float *)this + 5);
  float v9 = (float)(var1 * v8) - (float)(var0 * v7);
  float v10 = (float)(var1 * v7) + (float)(var0 * v8);
  float v11 = a3->x - (float)(a2->var0.x + v9);
  float v12 = a3->y - (float)(a2->var0.y + v10);
  float v13 = sqrtf((float)(v12 * v12) + (float)(v11 * v11));
  *a4 = v13 - *((float *)this + 3);
  float v14 = 1.0 / v13;
  float result = v12 * v14;
  a5->float x = v11 * v14;
  a5->float y = result;
  return result;
}

uint64_t b2CircleShape::RayCast(float *a1, float *a2, float *a3, float *a4)
{
  float v5 = a4[2];
  float v4 = a4[3];
  float v7 = a1[4];
  float v6 = a1[5];
  float v8 = (float)(v4 * v7) - (float)(v5 * v6);
  float v9 = (float)(v4 * v6) + (float)(v5 * v7);
  float v10 = a3[1];
  float v11 = *a3 - (float)(*a4 + v8);
  float v12 = v10 - (float)(a4[1] + v9);
  float v13 = a3[2] - *a3;
  float v14 = a3[3] - v10;
  float v15 = (float)(v12 * v14) + (float)(v11 * v13);
  float v16 = (float)(v14 * v14) + (float)(v13 * v13);
  float v17 = (float)(v15 * v15)
      - (float)(v16 * (float)((float)((float)(v12 * v12) + (float)(v11 * v11)) - (float)(a1[3] * a1[3])));
  if (v17 < 0.0 || v16 < 0.00000011921) {
    return 0;
  }
  float v19 = v15 + sqrtf(v17);
  if (v19 > 0.0) {
    return 0;
  }
  float v20 = -v19;
  if ((float)(v16 * a3[4]) < v20) {
    return 0;
  }
  float v22 = v20 / v16;
  float v23 = v11 + (float)(v13 * v22);
  float v24 = v12 + (float)(v14 * v22);
  *a2 = v23;
  a2[1] = v24;
  a2[2] = v22;
  float v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  if (v25 >= 0.00000011921)
  {
    float v26 = 1.0 / v25;
    *a2 = v23 * v26;
    a2[1] = v24 * v26;
  }
  return 1;
}

BOOL b2CircleShape::isValidShape(b2CircleShape *this)
{
  return (float)(*((float *)this + 3) * *((float *)this + 3)) > 0.00000011921;
}

float b2CircleShape::ComputeAABB(float *a1, float *a2, float *a3)
{
  float v4 = a3[2];
  float v3 = a3[3];
  float v6 = a1[4];
  float v5 = a1[5];
  float v7 = a1[3];
  float v8 = (float)(v3 * v6) - (float)(v4 * v5);
  float v9 = (float)(v3 * v5) + (float)(v4 * v6);
  float v10 = *a3 + v8;
  float v11 = a3[1] + v9;
  *a2 = v10 - v7;
  a2[1] = v11 - v7;
  float result = v11 + v7;
  a2[2] = v10 + v7;
  a2[3] = result;
  return result;
}

float b2CircleShape::ComputeMass(uint64_t a1, uint64_t a2, float a3)
{
  float v3 = *(float *)(a1 + 12) * (float)((float)(a3 * 3.1416) * *(float *)(a1 + 12));
  *(float *)a2 = v3;
  *(void *)(a2 + 4) = *(void *)(a1 + 16);
  float result = v3
         * (float)((float)((float)(*(float *)(a1 + 20) * *(float *)(a1 + 20))
                         + (float)(*(float *)(a1 + 16) * *(float *)(a1 + 16)))
                 + (float)((float)(*(float *)(a1 + 12) * 0.5) * *(float *)(a1 + 12)));
  *(float *)(a2 + 1std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = result;
  return result;
}

void b2CircleShape::~b2CircleShape(b2CircleShape *this)
{
}

uint64_t b2EdgeShape::Set(uint64_t this, const b2Vec2 *a2, const b2Vec2 *a3)
{
  *(b2Vec2 *)(this + 16) = *a2;
  *(b2Vec2 *)(this + 24) = *a3;
  *(_WORD *)(this + 48) = 0;
  return this;
}

void b2EdgeShape::Clone(b2EdgeShape *this)
{
}

uint64_t b2EdgeShape::GetChildCount(b2EdgeShape *this)
{
  return 1;
}

uint64_t b2EdgeShape::TestPoint(b2EdgeShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  return 0;
}

void b2EdgeShape::ComputeDistance(b2EdgeShape *this, const b2Transform *a2, float32x2_t *a3, float *a4, b2Vec2 *a5)
{
  b2Rot var1 = a2->var1;
  float32x2_t v6 = (float32x2_t)vrev64_s32((int32x2_t)var1);
  var1.float var0 = -var1.var0;
  float32x2_t v7 = vadd_f32((float32x2_t)a2->var0, vmla_n_f32(vmul_n_f32((float32x2_t)var1, *((float *)this + 5)), v6, *((float *)this + 4)));
  float32x2_t v8 = vadd_f32((float32x2_t)a2->var0, vmla_n_f32(vmul_n_f32((float32x2_t)var1, *((float *)this + 7)), v6, *((float *)this + 6)));
  float32x2_t v9 = vsub_f32(*a3, v7);
  float32x2_t v10 = vsub_f32(v8, v7);
  float v11 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v10).i32[1]), v10.f32[0], v9.f32[0]);
  if (v11 > 0.0)
  {
    float v12 = vmuls_lane_f32(v10.f32[1], v10, 1) + (float)(v10.f32[0] * v10.f32[0]);
    if (v11 <= v12) {
      float32x2_t v9 = vsub_f32(v9, vmul_n_f32(v10, v11 / v12));
    }
    else {
      float32x2_t v9 = vsub_f32(*a3, v8);
    }
  }
  float v13 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v9).i32[1]), v9.f32[0], v9.f32[0]));
  *a4 = v13;
  if (v13 <= 0.0)
  {
    {
      float v16 = a5;
      a5 = v16;
      if (v15)
      {
        b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
        a5 = v16;
      }
    }
    b2Vec2 v14 = (b2Vec2)b2Vec2_zero_fn(void)::b2Vec2_zero_init;
  }
  else
  {
    b2Vec2 v14 = (b2Vec2)vmul_n_f32(v9, 1.0 / v13);
  }
  *a5 = v14;
}

uint64_t b2EdgeShape::RayCast(float *a1, float *a2, float *a3, float *a4)
{
  float v4 = a4[1];
  float v5 = *a3 - *a4;
  float v6 = a3[1] - v4;
  float v8 = a4[2];
  float v7 = a4[3];
  float v9 = (float)(v6 * v8) + (float)(v7 * v5);
  float v10 = (float)(v7 * v6) - (float)(v8 * v5);
  float v11 = a3[2] - *a4;
  float v12 = a3[3] - v4;
  float v13 = (float)(v8 * v12) + (float)(v7 * v11);
  float v14 = (float)(v7 * v12) - (float)(v8 * v11);
  float v15 = v13 - v9;
  float v16 = v14 - v10;
  float v17 = a1[4];
  float v18 = a1[5];
  float v19 = a1[6] - v17;
  float v20 = a1[7] - v18;
  float v21 = -v19;
  float v22 = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
  if (v22 >= 0.00000011921)
  {
    float v24 = 1.0 / v22;
    float v23 = v20 * (float)(1.0 / v22);
    float v21 = v24 * v21;
  }
  else
  {
    float v23 = a1[7] - v18;
  }
  float v25 = (float)(v16 * v21) + (float)(v23 * v15);
  if (v25 == 0.0) {
    return 0;
  }
  float v26 = (float)((float)(v18 - v10) * v21) + (float)(v23 * (float)(v17 - v9));
  float v27 = v26 / v25;
  if (v27 < 0.0 || a3[4] < v27) {
    return 0;
  }
  float v29 = (float)(v20 * v20) + (float)(v19 * v19);
  if (v29 == 0.0) {
    return 0;
  }
  float v30 = (float)((float)(v20 * (float)((float)(v10 + (float)(v16 * v27)) - v18))
              + (float)((float)((float)(v9 + (float)(v15 * v27)) - v17) * v19))
      / v29;
  if (v30 < 0.0 || v30 > 1.0) {
    return 0;
  }
  float v33 = -v23;
  if (v26 > 0.0) {
    float v21 = -v21;
  }
  else {
    float v33 = v23;
  }
  *a2 = v33;
  a2[1] = v21;
  a2[2] = v27;
  return 1;
}

float32x4_t b2EdgeShape::ComputeAABB(_DWORD *a1, _OWORD *a2, uint64_t *a3, int32x4_t a4, int32x4_t a5)
{
  a4.i32[0] = a1[4];
  a5.i32[0] = a1[5];
  float v5 = (const float *)(a1 + 3);
  v7.i64[0] = *a3;
  v6.i64[0] = a3[1];
  v8.i64[0] = v6.i64[0];
  v8.i64[1] = v6.i64[0];
  v7.i64[1] = *a3;
  v6.f32[0] = -v6.f32[0];
  v6.i64[1] = v6.i64[0];
  a5.i32[1] = a1[7];
  a4.i32[1] = a1[6];
  float32x4_t v9 = vaddq_f32(vmlaq_f32(vmulq_f32(v6, (float32x4_t)vzip1q_s32(a5, a5)), (float32x4_t)vzip1q_s32(a4, a4), (float32x4_t)vrev64q_s32(v8)), v7);
  float32x4_t v10 = vld1q_dup_f32(v5);
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), v9), (int8x16_t)vdupq_lane_s64(v9.i64[0], 0), (int8x16_t)vdupq_laneq_s64((int64x2_t)v9, 1));
  *(void *)&long long v12 = vsubq_f32(v11, v10).u64[0];
  float32x4_t result = vaddq_f32(v11, v10);
  *((void *)&v12 + 1) = result.i64[1];
  *a2 = v12;
  return result;
}

float32x2_t b2EdgeShape::ComputeMass(float32x2_t *a1, uint64_t a2)
{
  *(_DWORD *)a2 = 0;
  float32x2_t result = vmul_f32(vadd_f32(a1[2], a1[3]), (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)(a2 + 4) = result;
  *(_DWORD *)(a2 + 1std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0;
  return result;
}

void b2EdgeShape::~b2EdgeShape(b2EdgeShape *this)
{
}

void b2PolygonShape::Clone(b2PolygonShape *this)
{
}

double b2PolygonShape::SetAsBox(b2PolygonShape *this, float a2, float a3)
{
  std::vector<b2Vec2>::resize((uint64_t)this + 16, 4uLL);
  std::vector<b2Vec2>::resize((uint64_t)this + 40, 4uLL);
  float32x4_t v6 = (float *)*((void *)this + 2);
  float *v6 = -a2;
  v6[1] = -a3;
  v6[2] = a2;
  v6[3] = -a3;
  v6[4] = a2;
  v6[5] = a3;
  v6[6] = -a2;
  v6[7] = a3;
  float32x4_t v7 = (_OWORD *)*((void *)this + 5);
  double result = -0.0078125;
  _OWORD *v7 = xmmword_21359B0A0;
  v7[1] = xmmword_21359B0B0;
  *((void *)this + 8) = 0;
  return result;
}

void b2PolygonShape::SetAsBox(b2PolygonShape *this, float a2, float a3, const b2Vec2 *a4, float a5)
{
  std::vector<b2Vec2>::resize((uint64_t)this + 16, 4uLL);
  std::vector<b2Vec2>::resize((uint64_t)this + 40, 4uLL);
  float32x4_t v10 = (float *)*((void *)this + 2);
  float *v10 = -a2;
  v10[1] = -a3;
  v10[2] = a2;
  v10[3] = -a3;
  v10[4] = a2;
  v10[5] = a3;
  void v10[6] = -a2;
  v10[7] = a3;
  float32x4_t v11 = (_OWORD *)*((void *)this + 5);
  _OWORD *v11 = xmmword_21359B0A0;
  v11[1] = xmmword_21359B0B0;
  *((b2Vec2 *)this + 8) = *a4;
  float x = a4->x;
  float y = a4->y;
  __float2 v14 = __sincosf_stret(a5);
  unint64_t v15 = *((void *)this + 3) - (void)v10;
  if ((int)(v15 >> 3) >= 1)
  {
    float v16 = -v14.__sinval;
    uint64_t v17 = (v15 >> 3);
    float v18 = v10 + 1;
    float v19 = (float *)v11 + 1;
    do
    {
      float v20 = *(v18 - 1);
      float v21 = x + (float)((float)(*v18 * v16) + (float)(v14.__cosval * v20));
      float v22 = y + (float)((float)(v14.__cosval * *v18) + (float)(v14.__sinval * v20));
      *(v18 - 1) = v21;
      *float v18 = v22;
      float v23 = *(v19 - 1);
      float v24 = (float)(*v19 * v16) + (float)(v14.__cosval * v23);
      float v25 = (float)(v14.__cosval * *v19) + (float)(v14.__sinval * v23);
      *(v19 - 1) = v24;
      *float v19 = v25;
      v18 += 2;
      v19 += 2;
      --v17;
    }
    while (v17);
  }
}

uint64_t b2PolygonShape::GetChildCount(b2PolygonShape *this)
{
  return 1;
}

BOOL b2PolygonShape::isValidShape(b2PolygonShape *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3) - v1;
  if ((int)((unint64_t)v2 >> 3) < 3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = (int)(v2 >> 3);
  uint64_t v6 = ((unint64_t)v2 >> 3);
  float32x4_t v7 = (float *)(v1 + 4);
  float v8 = 0.0;
  do
  {
    uint64_t v9 = v4 + 1;
    if (v4 + 1 < v5) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = 0;
    }
    float v8 = v8
       + (float)((float)((float)(*(v7 - 1) * *(float *)(v1 + 8 * v10 + 4)) - (float)(*v7 * *(float *)(v1 + 8 * v10)))
               * 0.5);
    v7 += 2;
    uint64_t v4 = v9;
  }
  while (v6 != v9);
  return fabsf(v8) > 0.00000011921;
}

BOOL b2PolygonShape::Set(b2PolygonShape *this, const b2Vec2 *a2, int a3)
{
  int64_t v6 = a3;
  std::vector<b2Vec2>::vector(__p, a3);
  std::vector<b2Vec2>::vector(&v36, v6);
  if (a3 >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      *(b2Vec2 *)(*(void *)__p + v7 * 8) = a2[v7];
      ++v7;
    }
    while (a3 != v7);
  }
  uint64_t v8 = *(void *)__p;
  uint64_t v9 = *((void *)this + 4);
  long long v10 = *(_OWORD *)&__p[8];
  long long v11 = *((_OWORD *)this + 1);
  *((void *)this + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = *(void *)__p;
  *(_OWORD *)__p = v11;
  *(_OWORD *)((char *)this + 24) = v10;
  *(void *)&__p[16] = v9;
  if (a3 >= 1)
  {
    int64_t v12 = 0;
    BOOL v13 = 0;
    uint64_t v14 = v36;
    unint64_t v15 = (float *)(v8 + 4);
    while (1)
    {
      int64_t v16 = v12 + 1;
      uint64_t v17 = v12 + 1 < v6 ? v12 + 1 : 0;
      float v18 = (float *)(v8 + 8 * v17);
      float v19 = *v18 - *(v15 - 1);
      v20.f32[0] = v18[1] - *v15;
      if ((float)((float)(v20.f32[0] * v20.f32[0]) + (float)(v19 * v19)) < 1.4211e-14) {
        break;
      }
      float v21 = -v19;
      *(_DWORD *)uint64_t v14 = v20.i32[0];
      *(float *)(v14 + 4) = -v19;
      float v22 = sqrtf((float)(v19 * v19) + (float)(v20.f32[0] * v20.f32[0]));
      if (v22 >= 0.00000011921)
      {
        v20.f32[1] = v21;
        *(float32x2_t *)uint64_t v14 = vmul_n_f32(v20, 1.0 / v22);
      }
      BOOL v13 = v16 >= v6;
      v15 += 2;
      v14 += 8;
      int64_t v12 = v16;
      if (a3 == v16) {
        goto LABEL_15;
      }
    }
    *((void *)this + 3) = v8;
    float32x2_t v34 = (void *)v36;
    if (!(void)v36) {
      goto LABEL_23;
    }
LABEL_22:
    *((void *)&v36 + 1) = v34;
    operator delete(v34);
    goto LABEL_23;
  }
  BOOL v13 = 1;
LABEL_15:
  long long v23 = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)((char *)this + 40) = v36;
  long long v36 = v23;
  uint64_t v24 = *((void *)this + 7);
  *((void *)this + 7) = v37;
  uint64_t v37 = v24;
  if ((int)((unint64_t)(v10 - v8) >> 3) < 3) {
    __assert_rtn("ComputeCentroid", "b2PolygonShape.cpp", 83, "count >= 3");
  }
  uint64_t v25 = 0;
  unint64_t v26 = ((unint64_t)(v10 - v8) >> 3);
  float v27 = 0.0;
  float32x2_t v28 = 0;
  do
  {
    uint64_t v29 = v25 + 1;
    if (v25 + 1 < v26) {
      uint64_t v30 = v25 + 1;
    }
    else {
      uint64_t v30 = 0;
    }
    float32x2_t v31 = *(float32x2_t *)(v8 + 8 * v25);
    float32x2_t v32 = *(float32x2_t *)(v8 + 8 * v30);
    float v33 = vmlas_n_f32((float)-v31.f32[1] * v32.f32[0], v32.f32[1], v31.f32[0]) * 0.5;
    float v27 = v27 + v33;
    float32x2_t v28 = vadd_f32(v28, vmul_n_f32(vadd_f32(vadd_f32(v31, 0), v32), v33 * 0.33333));
    ++v25;
  }
  while (v26 != v29);
  *((float32x2_t *)this + 8) = vmul_n_f32(v28, 1.0 / v27);
  float32x2_t v34 = (void *)v23;
  if ((void)v23) {
    goto LABEL_22;
  }
LABEL_23:
  if (*(void *)__p)
  {
    *(void *)&__p[8] = *(void *)__p;
    operator delete(*(void **)__p);
  }
  return v13;
}

void sub_2135773A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL b2PolygonShape::TestPoint(b2PolygonShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  float v3 = (float *)*((void *)this + 2);
  uint64_t v4 = *((void *)this + 3) - (void)v3;
  if ((int)((unint64_t)v4 >> 3) < 1) {
    return 1;
  }
  float v5 = a3->x - a2->var0.x;
  float v6 = a3->y - a2->var0.y;
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v9 = (float)(v6 * var0) + (float)(var1 * v5);
  float v10 = (float)(var1 * v6) - (float)(var0 * v5);
  long long v11 = (float *)*((void *)this + 5);
  if ((float)((float)((float)(v10 - v3[1]) * v11[1]) + (float)(*v11 * (float)(v9 - *v3))) > 0.0) {
    return 0;
  }
  uint64_t v12 = (int)(v4 >> 3);
  uint64_t v13 = ((unint64_t)v4 >> 3);
  uint64_t v14 = v11 + 3;
  unint64_t v15 = v3 + 3;
  uint64_t v16 = 1;
  do
  {
    uint64_t v17 = v16;
    if (v13 == v16) {
      break;
    }
    float v18 = (float)((float)(v10 - *v15) * *v14) + (float)(*(v14 - 1) * (float)(v9 - *(v15 - 1)));
    ++v16;
    v14 += 2;
    v15 += 2;
  }
  while (v18 <= 0.0);
  return v17 >= v12;
}

float b2PolygonShape::ComputeDistance(b2PolygonShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float v5 = a3->x - a2->var0.x;
  float v6 = a3->y - a2->var0.y;
  float var0 = a2->var1.var0;
  float var1 = a2->var1.var1;
  float v9 = (float)(v6 * var0) + (float)(var1 * v5);
  float v10 = (float)(var1 * v6) - (float)(var0 * v5);
  uint64_t v11 = *((void *)this + 2);
  unint64_t v12 = *((void *)this + 3) - v11;
  if ((int)(v12 >> 3) < 1)
  {
    float v16 = -3.4028e38;
  }
  else
  {
    uint64_t v13 = (v12 >> 3);
    uint64_t v14 = (float *)(*((void *)this + 5) + 4);
    unint64_t v15 = (float *)(v11 + 4);
    float v16 = -3.4028e38;
    uint64_t v17 = v13;
    float v18 = v10;
    float v19 = v9;
    do
    {
      float v20 = *(v14 - 1);
      float v21 = (float)(v10 - *v15) * *v14;
      if ((float)(v21 + (float)(v20 * (float)(v9 - *(v15 - 1)))) > v16)
      {
        float v19 = *(v14 - 1);
        float v18 = *v14;
        float v16 = v21 + (float)(v20 * (float)(v9 - *(v15 - 1)));
      }
      v14 += 2;
      v15 += 2;
      --v17;
    }
    while (v17);
    if (v16 > 0.0)
    {
      float v22 = v16 * v16;
      long long v23 = (float *)(v11 + 4);
      do
      {
        float v24 = v9 - *(v23 - 1);
        float v25 = v10 - *v23;
        if (v22 > (float)((float)(v25 * v25) + (float)(v24 * v24)))
        {
          float v18 = v10 - *v23;
          float v19 = v9 - *(v23 - 1);
          float v22 = (float)(v25 * v25) + (float)(v24 * v24);
        }
        v23 += 2;
        --v13;
      }
      while (v13);
      *a4 = sqrtf(v22);
      float v27 = a2->var1.var0;
      float v26 = a2->var1.var1;
      float result = (float)(v26 * v19) - (float)(v27 * v18);
      float v29 = (float)(v18 * v26) + (float)(v27 * v19);
      a5->float x = result;
      a5->float y = v29;
      float v30 = sqrtf((float)(v29 * v29) + (float)(result * result));
      if (v30 >= 0.00000011921)
      {
        float v31 = 1.0 / v30;
        float result = result * v31;
        a5->float x = result;
        a5->float y = v29 * v31;
      }
      return result;
    }
    float v10 = v18;
    float v9 = v19;
  }
  *a4 = v16;
  float v33 = a2->var1.var0;
  float v32 = a2->var1.var1;
  float v34 = (float)(v32 * v9) - (float)(v33 * v10);
  float result = (float)(v10 * v32) + (float)(v33 * v9);
  a5->float x = v34;
  a5->float y = result;
  float v35 = sqrtf((float)(result * result) + (float)(v34 * v34));
  if (v35 >= 0.00000011921)
  {
    float v36 = 1.0 / v35;
    float result = result * v36;
    a5->float x = v34 * v36;
    a5->float y = result;
  }
  return result;
}

uint64_t b2PolygonShape::RayCast(void *a1, float *a2, float *a3, float *a4)
{
  float v4 = a3[4];
  uint64_t v5 = a1[2];
  unint64_t v6 = a1[3] - v5;
  if ((int)(v6 >> 3) < 1)
  {
    if (v4 >= 0.0) {
      return 0;
    }
LABEL_26:
    b2PolygonShape::RayCast();
  }
  uint64_t v7 = 0;
  float v8 = a4[1];
  float v9 = *a3 - *a4;
  float v10 = a3[1] - v8;
  float v12 = a4[2];
  float v11 = a4[3];
  float v13 = (float)(v10 * v12) + (float)(v11 * v9);
  float v14 = (float)(v11 * v10) - (float)(v12 * v9);
  float v15 = a3[2] - *a4;
  float v16 = a3[3] - v8;
  float v17 = (float)(v12 * v16) + (float)(v11 * v15);
  float v18 = (float)(v11 * v16) - (float)(v12 * v15);
  float v19 = v17 - v13;
  float v20 = v18 - v14;
  uint64_t v21 = (v6 >> 3);
  float v22 = (float *)(a1[5] + 4);
  long long v23 = (float *)(v5 + 4);
  unsigned int v24 = -1;
  float v25 = 0.0;
  float v26 = a3[4];
  do
  {
    float v27 = *(v22 - 1);
    float v28 = (float)((float)(*v23 - v14) * *v22) + (float)(v27 * (float)(*(v23 - 1) - v13));
    float v29 = (float)(v20 * *v22) + (float)(v27 * v19);
    if (v29 == 0.0)
    {
      if (v28 < 0.0) {
        return 0;
      }
    }
    else if (v29 < 0.0 && v28 < (float)(v25 * v29))
    {
      unsigned int v24 = v7;
      float v25 = v28 / v29;
    }
    else if (v29 > 0.0 && v28 < (float)(v26 * v29))
    {
      float v26 = v28 / v29;
    }
    if (v26 < v25) {
      return 0;
    }
    ++v7;
    v22 += 2;
    v23 += 2;
  }
  while (v21 != v7);
  if (v25 < 0.0 || v25 > v4) {
    goto LABEL_26;
  }
  if ((v24 & 0x80000000) == 0)
  {
    a2[2] = v25;
    float v32 = (float *)(a1[5] + 8 * v24);
    float v33 = v32[1];
    float v34 = (float)(v11 * v33) + (float)(v12 * *v32);
    *a2 = (float)(v33 * (float)-v12) + (float)(v11 * *v32);
    a2[1] = v34;
    return 1;
  }
  return 0;
}

float32x4_t b2PolygonShape::ComputeAABB(uint64_t a1, _OWORD *a2, float32x2_t *a3)
{
  float32x2_t v4 = a3[1];
  float32x2_t v3 = (float32x2_t)vrev64_s32((int32x2_t)v4);
  v4.f32[0] = -v4.f32[0];
  uint64_t v5 = *(float **)(a1 + 16);
  *(float32x2_t *)v6.f32 = vadd_f32(*a3, vmla_n_f32(vmul_n_f32(v4, v5[1]), v3, *v5));
  v6.i64[1] = v6.i64[0];
  unint64_t v7 = *(void *)(a1 + 24) - (void)v5;
  if ((int)(v7 >> 3) >= 2)
  {
    float v8 = v5 + 3;
    uint64_t v9 = (v7 >> 3) - 1;
    do
    {
      *(float32x2_t *)v10.f32 = vadd_f32(*a3, vmla_n_f32(vmul_n_f32(v4, *v8), v3, *(v8 - 1)));
      v10.i64[1] = v10.i64[0];
      v11.i32[0] = vmovn_s32(vcgtq_f32(v10, v6)).u32[0];
      v11.i32[1] = vmovn_s32(vcgtq_f32(v6, v10)).i32[1];
      float32x4_t v6 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(v11), (int8x16_t)v6, (int8x16_t)v10);
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  float v12 = (const float *)(a1 + 12);
  float32x4_t v13 = vld1q_dup_f32(v12);
  *(void *)&long long v14 = vsubq_f32(v6, v13).u64[0];
  float32x4_t result = vaddq_f32(v6, v13);
  *((void *)&v14 + 1) = result.i64[1];
  *a2 = v14;
  return result;
}

float b2PolygonShape::ComputeMass(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a1 + 24) - v3;
  if ((int)(v4 >> 3) < 3) {
    b2PolygonShape::ComputeMass();
  }
  uint64_t v5 = (v4 >> 3);
  float32x2_t v6 = 0;
  uint64_t v7 = v5;
  float v8 = *(float32x2_t **)(a1 + 16);
  do
  {
    float32x2_t v9 = *v8++;
    float32x2_t v6 = vadd_f32(v6, v9);
    --v7;
  }
  while (v7);
  float32x2_t v10 = vmul_n_f32(v6, 1.0 / (float)(int)(v4 >> 3));
  uint64_t v11 = (int)((uint64_t)v4 >> 3);
  float32x2_t v12 = 0;
  float v13 = 0.0;
  float v14 = 0.0;
  do
  {
    uint64_t v15 = v7 + 1;
    float32x2_t v16 = *(float32x2_t *)(v3 + 8 * v7);
    if (v7 + 1 < v11) {
      uint64_t v17 = v7 + 1;
    }
    else {
      uint64_t v17 = 0;
    }
    float32x2_t v18 = vsub_f32(v16, v10);
    float32x2_t v19 = vsub_f32(*(float32x2_t *)(v3 + 8 * v17), v10);
    float v20 = vmlas_n_f32((float)-v18.f32[1] * v19.f32[0], v19.f32[1], v18.f32[0]);
    float v13 = v13 + (float)(v20 * 0.5);
    float32x2_t v12 = vadd_f32(v12, vmul_n_f32(vadd_f32(v18, v19), (float)(v20 * 0.5) * 0.33333));
    float v14 = v14 + (float)((float)(v20 * 0.083333) * vaddv_f32(vmla_f32(vmla_f32(vmul_f32(v18, v19), v18, v18), v19, v19)));
    uint64_t v7 = v15;
  }
  while (v5 != v15);
  float v21 = fabsf(v13 * a3);
  *(float *)a2 = v21;
  float32x2_t v22 = vmul_n_f32(v12, 1.0 / v13);
  float32x2_t v23 = vadd_f32(v10, v22);
  *(float32x2_t *)(a2 + 4) = v23;
  float result = (float)(v14 * a3)
         + (float)(v21
                 * (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v23).i32[1]), v23.f32[0], v23.f32[0])
                         - vmlas_n_f32(COERCE_FLOAT(vmul_f32(v22, v22).i32[1]), v22.f32[0], v22.f32[0])));
  *(float *)(a2 + 1std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = result;
  return result;
}

void b2PolygonShape::~b2PolygonShape(b2PolygonShape *this)
{
  *(void *)this = &unk_26C3F3830;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26C3F3830;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }

  JUMPOUT(0x21668C8E0);
}

void *std::vector<b2Vec2>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<PKPoint>::__vallocate[abi:ne180100](a1, a2);
    a1[1] += 8 * a2;
  }
  return a1;
}

void sub_213577A78(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void b2Draw::b2Draw(b2Draw *this)
{
  *(void *)this = &unk_26C3F3F20;
  *((_DWORD *)this + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0;
}

uint64_t b2Draw::SetFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) = a2;
  return this;
}

uint64_t b2Draw::GetFlags(b2Draw *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t b2Draw::AppendFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) |= a2;
  return this;
}

uint64_t b2Draw::ClearFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) &= ~a2;
  return this;
}

float b2Mat33::Solve33(b2Mat33 *this, const b2Vec3 *a2)
{
  float var1 = this->var2.var1;
  float var2 = this->var2.var2;
  float v4 = this->var1.var1;
  float v5 = this->var1.var2;
  float var0 = this->var2.var0;
  float v7 = (float)(v4 * var2) - (float)(v5 * var1);
  float v8 = this->var1.var0;
  float v9 = (float)(v5 * var0) - (float)(v8 * var2);
  float v10 = (float)(v8 * var1) - (float)(v4 * var0);
  float v11 = (float)((float)(this->var0.var1 * v9) + (float)(this->var0.var0 * v7)) + (float)(this->var0.var2 * v10);
  if (v11 != 0.0) {
    float v11 = 1.0 / v11;
  }
  return v11 * (float)((float)((float)(v9 * a2->var1) + (float)(a2->var0 * v7)) + (float)(a2->var2 * v10));
}

float b2Mat33::Solve22(b2Mat33 *this, const b2Vec2 *a2)
{
  float var0 = this->var1.var0;
  float var1 = this->var1.var1;
  float v4 = (float)(this->var0.var0 * var1) - (float)(var0 * this->var0.var1);
  if (v4 != 0.0) {
    float v4 = 1.0 / v4;
  }
  return v4 * (float)((float)(var1 * a2->x) - (float)(var0 * a2->y));
}

float b2Mat33::GetInverse22(b2Mat33 *this, b2Mat33 *a2)
{
  float var0 = this->var0.var0;
  float var1 = this->var0.var1;
  float v4 = this->var1.var0;
  float v5 = this->var1.var1;
  float v6 = (float)(this->var0.var0 * v5) - (float)(v4 * var1);
  if (v6 != 0.0) {
    float v6 = 1.0 / v6;
  }
  a2->var0.float var2 = 0.0;
  a2->var0.float var0 = v5 * v6;
  a2->var0.float var1 = -(float)(v6 * var1);
  float result = var0 * v6;
  a2->var1.float var0 = -(float)(v6 * v4);
  a2->var1.float var1 = result;
  *(void *)&a2->var2.float var1 = 0;
  *(void *)&a2->var1.float var2 = 0;
  return result;
}

float b2Mat33::GetSymInverse33(b2Mat33 *this, b2Mat33 *a2)
{
  float var1 = this->var2.var1;
  float var2 = this->var2.var2;
  float v4 = this->var1.var1;
  float var0 = this->var2.var0;
  float v6 = this->var1.var0;
  float v7 = this->var0.var0;
  float v8 = (float)((float)(this->var0.var1 * (float)((float)(this->var1.var2 * var0) - (float)(v6 * var2)))
             + (float)(this->var0.var0 * (float)((float)(v4 * var2) - (float)(this->var1.var2 * var1))))
     + (float)(this->var0.var2 * (float)((float)(v6 * var1) - (float)(v4 * var0)));
  if (v8 != 0.0) {
    float v8 = 1.0 / v8;
  }
  float v9 = v8 * (float)((float)(var0 * var1) - (float)(v6 * var2));
  a2->var0.float var0 = v8 * (float)((float)(v4 * var2) - (float)(var1 * var1));
  a2->var0.float var1 = v9;
  float v10 = (float)((float)(v6 * var1) - (float)(var0 * v4)) * v8;
  a2->var0.float var2 = v10;
  a2->var1.float var0 = v9;
  float v11 = v8 * (float)((float)(var0 * v6) - (float)(v7 * var1));
  a2->var1.float var1 = v8 * (float)((float)(v7 * var2) - (float)(var0 * var0));
  a2->var1.float var2 = v11;
  a2->var2.float var0 = v10;
  a2->var2.float var1 = v11;
  float result = (float)((float)(v7 * v4) - (float)(v6 * v6)) * v8;
  a2->var2.float var2 = result;
  return result;
}

uint64_t PKCMechanics::Solve(uint64_t result, long long *a2)
{
  uint64_t v2 = *(QuadTree ***)(result + 8);
  uint64_t v3 = *(QuadTree ***)(result + 16);
  if (v2 != v3)
  {
    float v5 = (uint64_t *)result;
    do
    {
      float v6 = *v2++;
      QuadTree::bounds(v6, &v11, &v12, &v13, &v14);
      v7[0] = &unk_26C3F3E80;
      v7[1] = v5;
      long long v8 = *a2;
      uint64_t v9 = *((void *)a2 + 2);
      float v10 = v6;
      float result = b2World::QueryAABB(*v5, (uint64_t)v7, &v11);
    }
    while (v2 != v3);
  }
  return result;
}

void PKCMechanics::addQuadTree(PKCMechanics *this, QuadTree *a2)
{
  unint64_t v6 = *((void *)this + 3);
  float v4 = (char *)this + 24;
  unint64_t v5 = v6;
  float v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = (void **)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    float32x2_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)float32x2_t v16 = a2;
    long long v8 = v16 + 8;
    float32x2_t v19 = (char *)*((void *)this + 1);
    float32x2_t v18 = (char *)*((void *)this + 2);
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      float32x2_t v18 = (char *)*v9;
    }
    *((void *)this + 1) = v16;
    *((void *)this + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = v8;
    *((void *)this + 3) = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    void *v7 = a2;
    long long v8 = v7 + 1;
  }
  *((void *)this + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = v8;
}

void MechanicsCollisionCallback::~MechanicsCollisionCallback(MechanicsCollisionCallback *this)
{
}

uint64_t MechanicsCollisionCallback::ReportFixture(MechanicsCollisionCallback *this, b2Fixture *a2)
{
  uint64_t v4 = *((void *)a2 + 3);
  int v5 = (*(uint64_t (**)(void))(**((void **)a2 + 4) + 24))(*((void *)a2 + 4));
  if (v5 >= 1)
  {
    unint64_t v6 = 0;
    uint64_t v7 = 8;
    uint64_t v8 = v5;
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0x3B9374BCu);
    do
    {
      uint64_t v10 = *((void *)a2 + 6);
      if (v6 >= (*((void *)a2 + 7) - v10) >> 5) {
        MechanicsCollisionCallback::ReportFixture();
      }
      uint64_t v11 = (float *)(v10 + v7);
      float v12 = *(v11 - 2);
      float v13 = *(v11 - 1);
      float v14 = *v11;
      float v15 = v11[1];
      float32x2_t v16 = (uint64_t *)*((void *)this + 5);
      __p = 0;
      float32x2_t v34 = 0;
      uint64_t v35 = 0;
      if (QuadTree::intersectBox(v16, (uint64_t)&__p, v12, v13, v14, v15))
      {
        uint64_t v17 = *(void *)__p;
        float32x2_t v34 = (float32x2_t)__p;
        operator delete(__p);
        v18.i32[0] = *(_DWORD *)(v17 + 32);
        v18.i32[1] = *(_DWORD *)(v17 + 44);
        float32x2_t v19 = vmul_f32(vadd_f32(*(float32x2_t *)(v17 + 36), v18), (float32x2_t)0x3F0000003F000000);
        *(float *)v20.i32 = *((float *)this + 4) * 0.0;
        __p = (void *)vadd_f32(vsub_f32(v19, *(float32x2_t *)(v4 + 48)), *(float32x2_t *)(v4 + 32));
        float32x2_t v34 = vadd_f32(v19, (float32x2_t)vdup_lane_s32(v20, 0));
        LODWORD(v35) = 1065353216;
        if ((*(unsigned int (**)(void, float32x2_t *, void **, uint64_t, unint64_t))(**((void **)a2 + 4) + 48))(*((void *)a2 + 4), &v31, &__p, *((void *)a2 + 3) + 32, v6))
        {
          float32x2_t v21 = vadd_f32(vadd_f32(vmul_n_f32((float32x2_t)__p, 1.0 - v32), vmul_n_f32(v34, v32)), vmul_f32(v31, v9));
          float32x2_t v22 = vmul_n_f32(vsub_f32(v21, v19), *((float *)this + 5));
          float32x2_t v23 = vneg_f32(v22);
          float v24 = sqrtf(vmlas_n_f32(vmuls_lane_f32(v22.f32[1], v22, 1), v22.f32[0], v22.f32[0]));
          if (v24 >= 0.00000011921) {
            float32x2_t v23 = vmul_n_f32(v23, 1.0 / v24);
          }
          float32x2_t v25 = vmul_n_f32(v23, vmlas_n_f32(vmuls_lane_f32((float)(0.0 - v22.f32[1]) * *((float *)this + 4), v23, 1), (float)(0.0 - v22.f32[0]) * *((float *)this + 4), v23.f32[0]));
          float v26 = v25.f32[1];
          BOOL v27 = (v25.i32[0] & 0x7FFFFFFFu) <= 0x7F7FFFFF && (v25.i32[1] & 0x7FFFFFFFu) <= 0x7F7FFFFF;
          if (v27 && *(_DWORD *)(v4 + 20) == 2)
          {
            float32x2_t v29 = v25;
            float32x2_t v30 = v21;
            if ((b2Body::IsAwake((b2Body *)v4) & 1) == 0) {
              b2Body::SetAwake((b2Body *)v4, 1);
            }
            *(float32x2_t *)(v4 + 128) = vadd_f32(vmul_n_f32(v29, *(float *)(v4 + 212)), *(float32x2_t *)(v4 + 128));
            *(float *)(v4 + 136) = *(float *)(v4 + 136)
                                 + (float)(*(float *)(v4 + 224)
                                         * (float)((float)((float)(v30.f32[0] - *(float *)(v4 + 96)) * v26)
                                                 - (float)((float)(v30.f32[1] - *(float *)(v4 + 100)) * v29.f32[0])));
          }
        }
      }
      else if (__p)
      {
        float32x2_t v34 = (float32x2_t)__p;
        operator delete(__p);
      }
      ++v6;
      v7 += 32;
    }
    while (v8 != v6);
  }
  return 1;
}

void sub_213578140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *b2Alloc(int a1)
{
  return malloc_type_malloc(a1, 0x14466031uLL);
}

void b2StackAllocator::b2StackAllocator(b2StackAllocator *this)
{
  *((void *)this + 12800) = 0;
  *((_DWORD *)this + 2560std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0;
  *((_DWORD *)this + 2573std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0;
}

void b2StackAllocator::~b2StackAllocator(b2StackAllocator *this)
{
  if (*((_DWORD *)this + 25600))
  {
    uint64_t v1 = "m_index == 0";
    int v2 = 32;
    goto LABEL_6;
  }
  if (*((_DWORD *)this + 25732))
  {
    uint64_t v1 = "m_entryCount == 0";
    int v2 = 33;
LABEL_6:
    __assert_rtn("~b2StackAllocator", "b2StackAllocator.cpp", v2, v1);
  }
}

char *b2StackAllocator::Allocate(b2StackAllocator *this, int a2)
{
  int v2 = (int *)((char *)this + 102400);
  uint64_t v3 = *((int *)this + 25732);
  if ((int)v3 >= 32) {
    b2StackAllocator::Allocate();
  }
  int v5 = (char *)this + 102416;
  *((_DWORD *)this + 4 * v3 + 25606) = a2;
  uint64_t v6 = *v2;
  if ((int)v6 + a2 <= 102400)
  {
    char v8 = 0;
    float result = (char *)this + v6;
    int *v2 = v6 + a2;
  }
  else
  {
    float result = (char *)b2Alloc(a2);
    char v8 = 1;
  }
  float32x2_t v9 = &v5[16 * v3];
  *(void *)float32x2_t v9 = result;
  v9[12] = v8;
  int v10 = v2[2];
  int v11 = v2[1] + a2;
  if (v10 <= v11) {
    int v10 = v2[1] + a2;
  }
  v2[1] = v11;
  v2[2] = v10;
  ++v2[132];
  return result;
}

void b2StackAllocator::Free(void **this, void *a2)
{
  int v2 = this + 12800;
  uint64_t v3 = *((unsigned int *)this + 25732);
  if ((int)v3 <= 0) {
    b2StackAllocator::Free();
  }
  uint64_t v4 = &this[2 * v3 + 12802];
  if (this[2 * v3 + 12800] != a2) {
    b2StackAllocator::Free();
  }
  if (BYTE4(this[2 * v3 + 12801]))
  {
    b2Free(a2);
    int v5 = *((_DWORD *)v4 - 2);
    LODWORD(v3) = v2[132];
  }
  else
  {
    int v5 = (int)this[2 * v3 + 12801];
    *v2 -= v5;
  }
  v2[1] -= v5;
  v2[132] = v3 - 1;
}

uint64_t b2StackAllocator::GetMaxAllocation(b2StackAllocator *this)
{
  return *((unsigned int *)this + 25602);
}

void b2Timer::b2Timer(b2Timer *this)
{
  gettimeofday(&v3, 0);
  float v2 = (float)v3.tv_usec * 0.001;
  *(void *)this = v3.tv_sec;
  *((void *)this + 1) = (unint64_t)v2;
}

float b2Timer::Reset(b2Timer *this)
{
  gettimeofday(&v3, 0);
  float result = (float)v3.tv_usec * 0.001;
  *(void *)this = v3.tv_sec;
  *((void *)this + 1) = (unint64_t)result;
  return result;
}

float b2Timer::GetMilliseconds(b2Timer *this)
{
  gettimeofday(&v3, 0);
  return (float)((float)(unint64_t)(1000 * (v3.tv_sec - *(void *)this)) + (float)((float)v3.tv_usec * 0.001))
       - (float)*((unint64_t *)this + 1);
}

void b2BodyDef::b2BodyDef(b2BodyDef *this)
{
  this->userData = 0;
  *(_OWORD *)&this->position.float x = 0u;
  *(_OWORD *)&this->linearVelocity.float y = 0u;
  *(void *)((char *)&this->linearDamping + 1) = 0;
  this->type = 0;
  *(_DWORD *)&this->awake = 16777217;
  this->_sk_affectedByGravitfloat y = 1;
  *(_OWORD *)&this->_sk_fieldCategoryBitMasuint64_t k = xmmword_21359B110;
}

void b2Body::b2Body(b2Body *this, const b2BodyDef *a2, b2Body *a3)
{
  float x = a2->position.x;
  BOOL v4 = x > -INFINITY && x < INFINITY;
  if (!v4 || ((y = a2->position.y, y > -INFINITY) ? (BOOL v7 = y < INFINITY) : (BOOL v7 = 0), !v7)) {
    b2Body::b2Body();
  }
  float v8 = a2->linearVelocity.x;
  BOOL v9 = v8 > -INFINITY && v8 < INFINITY;
  if (!v9 || (float v10 = a2->linearVelocity.y, v10 <= -INFINITY) || v10 >= INFINITY) {
    b2Body::b2Body();
  }
  float angle = a2->angle;
  if (angle <= -INFINITY || angle >= INFINITY) {
    b2Body::b2Body();
  }
  angularVelocitfloat y = a2->angularVelocity;
  if (angularVelocity <= -INFINITY || angularVelocity >= INFINITY) {
    b2Body::b2Body();
  }
  float angularDamping = a2->angularDamping;
  if (angularDamping < 0.0 || angularDamping <= -INFINITY || angularDamping >= INFINITY) {
    b2Body::b2Body();
  }
  float linearDamping = a2->linearDamping;
  if (linearDamping < 0.0 || linearDamping <= -INFINITY || linearDamping >= INFINITY) {
    b2Body::b2Body();
  }
  this->float var0 = a2->_sk_affectedByGravity;
  *(_OWORD *)&this->float var1 = *(_OWORD *)&a2->_sk_fieldCategoryBitMask;
  unsigned __int16 v16 = 8 * a2->bullet;
  this->var6 = 8 * a2->bullet;
  if (a2->fixedRotation)
  {
    v16 |= 0x10u;
    this->var6 = v16;
  }
  if (a2->allowSleep)
  {
    v16 |= 4u;
    this->var6 = v16;
  }
  if (a2->awake)
  {
    v16 |= 2u;
    this->var6 = v16;
  }
  if (a2->active) {
    this->var6 = v16 | 0x20;
  }
  this->var17 = a3;
  b2Vec2 position = a2->position;
  this->var8.float var0 = position;
  this->var8.float var1 = (b2Rot)__sincosf_stret(a2->angle);
  this->var9 = this->var8;
  this->var10.float var0 = 0;
  *(b2Vec2 *)&this->var10.var1.var0.float var1 = position;
  *(b2Vec2 *)&this->var10.var2.var0.float var1 = position;
  this->var10.var2.var0.var0.float y = a2->angle;
  this->var11.float x = a2->angle;
  this->var11.float y = 0.0;
  this->var18 = 0;
  *(void *)&this->var19 = 0;
  *(void *)&this->var22 = 0;
  *(void *)&this->var24 = 0;
  *(b2Vec2 *)&this->var14 = a2->linearVelocity;
  *(float *)&this->var15 = a2->angularVelocity;
  *(void **)((char *)&this->var30 + 4) = *(void **)&a2->linearDamping;
  float charge = a2->charge;
  *(b2World **)((char *)&this->var15 + 4) = 0;
  HIDWORD(this->var16) = 0;
  this[1].float var1 = 0;
  int type = a2->type;
  this->var5 = type;
  float v20 = 0.0;
  if (type == 2) {
    float v20 = 1.0;
  }
  this->var26 = v20;
  this->var27 = v20;
  *(void *)&this->var29 = 0;
  this->var28 = charge;
  *(void *)&this[1].float var2 = a2->userData;
  this->var20 = 0;
  LODWORD(this->var21) = 0;
}

void b2Body::SetCategoryBitMask(b2Body *this, unsigned int a2)
{
  this->float var2 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SynchronizeFixtures(b2Body *this)
{
  v6.float var1 = (b2Rot)__sincosf_stret(this->var10.var2.var0.var0.y);
  float x = this->var10.var0.x;
  float y = this->var10.var0.y;
  float v4 = this->var10.var1.var0.var2 - (float)((float)(v6.var1.var1 * y) + (float)(v6.var1.var0 * x));
  v6.var0.float x = this->var10.var1.var0.var1 - (float)((float)(v6.var1.var1 * x) - (float)(v6.var1.var0 * y));
  v6.var0.float y = v4;
  for (uint64_t i = this->var20; i; uint64_t i = i->var2)
    b2Fixture::Synchronize((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &v6, &this->var8);
}

void b2Body::SetCollisionBitMask(b2Body *this, unsigned int a2)
{
  this->var3 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SetIntersectionCallbackBitMask(b2Body *this, unsigned int a2)
{
  this->var4 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SetType(b2Body *this, int a2)
{
  if (((uint64_t)this->var17[443].var18 & 2) != 0) {
    b2Body::SetType();
  }
  if (this->var5 != a2)
  {
    this->var5 = a2;
    b2Body::ResetMassData(this);
    if (!this->var5)
    {
      *(void *)&this->var14 = 0;
      LODWORD(this->var15) = 0;
      *(_OWORD *)&this->var10.var1.var0.float var1 = *(_OWORD *)&this->var10.var2.var0.var1;
      b2Body::SynchronizeFixtures(this);
    }
    unsigned __int16 var6 = this->var6;
    if ((var6 & 2) == 0)
    {
      this->unsigned __int16 var6 = var6 | 2;
      this[1].float var1 = 0;
    }
    this->var16 = 0;
    HIDWORD(this->var15) = 0;
    uint64_t v4 = *(void *)&this->var24;
    if (v4)
    {
      do
      {
        uint64_t v5 = *(void *)(v4 + 24);
        b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, *(b2Contact **)(v4 + 8));
        uint64_t v4 = v5;
      }
      while (v5);
    }
    *(void *)&this->var24 = 0;
    for (uint64_t i = this->var20; i; uint64_t i = i->var2)
    {
      b2Fixture::Refilter((b2Fixture *)i);
      unint64_t v7 = (char *)i[1].var3 - (char *)i[1].var2;
      if ((int)(v7 >> 5) >= 1)
      {
        unint64_t v8 = 0;
        uint64_t v9 = v7 & 0x1FFFFFFFE0;
        do
        {
          b2ContactManager::TouchProxy((b2ContactManager *)&this->var17[443].var19, (int)i[1].var2[v8 / 0x20].var3);
          v8 += 32;
        }
        while (v9 != v8);
      }
    }
  }
}

void b2Body::ResetMassData(b2Body *this)
{
  *(void *)&this->float var26 = 0;
  *(void *)&this->float var29 = 0;
  this->var10.float var0 = 0;
  if (this->var5 > 1u)
  {
    {
      b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
    }
    float v4 = *((float *)&b2Vec2_zero_fn(void)::b2Vec2_zero_init + 1);
    float v3 = *(float *)&b2Vec2_zero_fn(void)::b2Vec2_zero_init;
    for (uint64_t i = this->var20; i; uint64_t i = i->var2)
    {
      if (*(float *)&i->var1 != 0.0)
      {
        (*(void (**)(b2Body *, float *))(*(void *)i[1].var0 + 64))(i[1].var0, v24);
        float v6 = v24[0];
        float v7 = v24[1];
        this->float var26 = v24[0] + this->var26;
        float v3 = v3 + (float)(v6 * v7);
        float v4 = v4 + (float)(v6 * v24[2]);
        this->float var29 = v24[3] + this->var29;
      }
    }
    float var26 = this->var26;
    if (var26 <= 0.0)
    {
      this->float var26 = 1.0;
      float var26 = 1.0;
      float v9 = 1.0;
    }
    else
    {
      float v9 = 1.0 / var26;
      float v3 = v3 * (float)(1.0 / var26);
      float v4 = v4 * (float)(1.0 / var26);
    }
    this->var27 = v9;
    float var29 = this->var29;
    if (var29 <= 0.0 || (this->var6 & 0x10) != 0)
    {
      this->float var29 = 0.0;
      float v12 = 0.0;
    }
    else
    {
      float v11 = var29 - (float)(var26 * (float)((float)(v4 * v4) + (float)(v3 * v3)));
      if (v11 <= 0.00001) {
        float v11 = 0.00001;
      }
      this->float var29 = v11;
      float v12 = 1.0 / v11;
    }
    *(float *)&this->var30 = v12;
    float var0 = this->var8.var1.var0;
    float var1 = this->var8.var1.var1;
    float y = this->var8.var0.y;
    float v16 = this->var8.var0.x + (float)((float)(var1 * v3) - (float)(var0 * v4));
    this->var10.var0.float x = v3;
    this->var10.var0.float y = v4;
    float v17 = (float)((float)(var1 * v4) + (float)(var0 * v3)) + y;
    float v18 = *(float *)&this->var15;
    float32x2_t v19 = (float32x2_t)vrev64_s32(*(int32x2_t *)&this->var10.var2.var0.var1);
    this->var10.var2.var0.float var1 = v16;
    this->var10.var2.var0.float var2 = v17;
    uint64_t v20 = *(void *)&this->var10.var2.var0.var1;
    *(void *)&this->var10.var1.var0.float var1 = v20;
    float32x2_t v21 = vmul_n_f32(vsub_f32((float32x2_t)__PAIR64__(v20, HIDWORD(v20)), v19), v18);
    float32x2_t v22 = *(float32x2_t *)&this->var14;
    LODWORD(v23) = vsub_f32(v22, v21).u32[0];
    HIDWORD(v23) = vadd_f32(v22, v21).i32[1];
    *(void *)&this->var14 = v23;
  }
  else
  {
    b2Vec2 v2 = this->var8.var0;
    *(b2Vec2 *)&this->var10.var1.var0.float var1 = v2;
    *(b2Vec2 *)&this->var10.var2.var0.float var1 = v2;
    this->var10.var2.var0.var0.float y = this->var11.x;
  }
}

b2Body *b2Body::SetAwake(b2Body *this, int a2)
{
  unsigned __int16 var6 = this->var6;
  if (a2)
  {
    if ((var6 & 2) == 0)
    {
      this->unsigned __int16 var6 = var6 | 2;
      this[1].float var1 = 0;
    }
  }
  else
  {
    this->unsigned __int16 var6 = var6 & 0xFFFD;
    this[1].float var1 = 0;
    this->var15 = 0;
    this->var16 = 0;
    *(void *)&this->var14 = 0;
  }
  return this;
}

void b2Body::CreateFixture(b2Body *this, const b2FixtureDef *a2)
{
  if (((uint64_t)this->var17[443].var18 & 2) == 0) {
    operator new();
  }
  b2Body::CreateFixture();
}

void sub_213578C18(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C409E444955);
  _Unwind_Resume(a1);
}

void b2Body::CreateFixture(b2Body *this, b2Shape *a2, float a3)
{
  *(void *)&v8.float var2 = 1045220557;
  __asm { FMOV            V1.2S, #1.0 }
  *(void *)&v8.var5 = _D1;
  v8.float var0 = a2;
  v8.float var1 = 0;
  v8.var4 = a3;
  b2Body::CreateFixture(this, &v8);
}

void b2Body::DestroyFixture(b2Body *this, b2Fixture *a2)
{
  if (((uint64_t)this->var17[443].var18 & 2) != 0) {
    b2Body::DestroyFixture();
  }
  if (*((b2Body **)a2 + 3) != this) {
    b2Body::DestroyFixture();
  }
  if (SLODWORD(this->var21) <= 0) {
    b2Body::DestroyFixture();
  }
  p_var20 = &this->var20;
  var20 = this->var20;
  if (!var20) {
LABEL_25:
  }
    b2Body::DestroyFixture();
  if (var20 != (b2JointEdge *)a2)
  {
    do
    {
      float v6 = var20;
      var20 = var20->var2;
      if (!var20) {
        goto LABEL_25;
      }
    }
    while (var20 != (b2JointEdge *)a2);
    p_var20 = &v6->var2;
  }
  *p_var20 = (b2JointEdge *)*((void *)a2 + 2);
  uint64_t v7 = *(void *)&this->var24;
  while (v7)
  {
    uint64_t v8 = *(void *)(v7 + 8);
    uint64_t v7 = *(void *)(v7 + 24);
    if (*(b2Fixture **)(v8 + 80) == a2 || *(void *)(v8 + 88) == (void)a2) {
      b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, (b2Contact *)v8);
    }
  }
  if ((this->var6 & 0x20) != 0) {
    b2Fixture::DestroyProxies(a2, (b2ContactManager *)&this->var17[443].var19);
  }
  (*(void (**)(b2Fixture *))(*(void *)a2 + 8))(a2);
  --LODWORD(this->var21);

  b2Body::ResetMassData(this);
}

float32x2_t b2Body::SetMassData(uint64_t a1, float *a2, float32x2_t result)
{
  if ((*(unsigned char *)(*(void *)(a1 + 152) + 102936) & 2) != 0) {
    b2Body::SetMassData();
  }
  if (*(_DWORD *)(a1 + 20) == 2)
  {
    *(_DWORD *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 224) = 0;
    float v3 = *a2;
    if (*a2 <= 0.0) {
      float v3 = 1.0;
    }
    *(float *)(a1 + 208) = v3;
    *(float *)(a1 + 21std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 1.0 / v3;
    float v4 = a2[3];
    if (v4 > 0.0 && (*(_WORD *)(a1 + 24) & 0x10) == 0)
    {
      float v5 = v4 - (float)(v3 * (float)((float)(a2[2] * a2[2]) + (float)(a2[1] * a2[1])));
      *(float *)(a1 + 220) = v5;
      if (v5 <= 0.0) {
        b2Body::SetMassData();
      }
      *(float *)(a1 + 224) = 1.0 / v5;
    }
    uint64_t v6 = *(void *)(a2 + 1);
    *(void *)(a1 + 64) = v6;
    float v8 = *(float *)(a1 + 40);
    float v7 = *(float *)(a1 + 44);
    float v9 = *(float *)(a1 + 32) + (float)((float)(v7 * *(float *)&v6) - (float)(v8 * *((float *)&v6 + 1)));
    float v10 = (float)((float)(v7 * *((float *)&v6 + 1)) + (float)(v8 * *(float *)&v6)) + *(float *)(a1 + 36);
    float v11 = *(float *)(a1 + 136);
    float32x2_t v12 = (float32x2_t)vrev64_s32(*(int32x2_t *)(a1 + 96));
    *(float *)(a1 + 96) = v9;
    *(float *)(a1 + 100) = v10;
    uint64_t v13 = *(void *)(a1 + 96);
    *(void *)(a1 + 80) = v13;
    float32x2_t v14 = vmul_n_f32(vsub_f32((float32x2_t)__PAIR64__(v13, HIDWORD(v13)), v12), v11);
    float32x2_t v15 = *(float32x2_t *)(a1 + 128);
    v12.i32[0] = vsub_f32(v15, v14).u32[0];
    float result = vadd_f32(v15, v14);
    v12.i32[1] = result.i32[1];
    *(float32x2_t *)(a1 + 128) = v12;
  }
  return result;
}

float b2Body::GetCharge(b2Body *this)
{
  return this->var28;
}

b2Body *b2Body::SetCharge(b2Body *this, float a2)
{
  this->var28 = a2;
  return this;
}

b2Body *b2Body::SetBullet(b2Body *this, int a2)
{
  if (a2) {
    __int16 v2 = 8;
  }
  else {
    __int16 v2 = 0;
  }
  this->unsigned __int16 var6 = this->var6 & 0xFFF7 | v2;
  return this;
}

uint64_t b2Body::IsBullet(b2Body *this)
{
  return (this->var6 >> 3) & 1;
}

uint64_t b2Body::IsAwake(b2Body *this)
{
  return (this->var6 >> 1) & 1;
}

uint64_t b2Body::IsActive(b2Body *this)
{
  return (this->var6 >> 5) & 1;
}

void b2Body::SetFixedRotation(b2Body *this, int a2)
{
  if (a2) {
    __int16 v2 = 16;
  }
  else {
    __int16 v2 = 0;
  }
  this->unsigned __int16 var6 = this->var6 & 0xFFEF | v2;
  b2Body::ResetMassData(this);
}

uint64_t b2Body::IsFixedRotation(b2Body *this)
{
  return (this->var6 >> 4) & 1;
}

b2Body *b2Body::SetSleepingAllowed(b2Body *this, int a2)
{
  unsigned __int16 var6 = this->var6;
  if (a2)
  {
    this->unsigned __int16 var6 = var6 | 4;
  }
  else
  {
    this->unsigned __int16 var6 = var6 & 0xFFFB;
    if ((var6 & 2) == 0)
    {
      this->unsigned __int16 var6 = var6 & 0xFFF9 | 2;
      this[1].float var1 = 0;
    }
  }
  return this;
}

uint64_t b2Body::IsSleepingAllowed(b2Body *this)
{
  return (this->var6 >> 2) & 1;
}

uint64_t b2Body::ShouldCollide(b2Body *this, const b2Body *a2)
{
  unsigned int var2 = a2->var2;
  if ((var2 & this->var3) != 0
    || (unsigned int v3 = this->var2, (v3 & a2->var3) != 0)
    || (this->var4 & var2) != 0
    || (a2->var4 & v3) != 0)
  {
    if (this->var5 == 2 || a2->var5 == 2)
    {
      uint64_t v4 = *(void *)&this->var22;
      if (!v4) {
        return 1;
      }
      while (*(const b2Body **)v4 != a2 || *(unsigned char *)(*(void *)(v4 + 8) + 113))
      {
        uint64_t v4 = *(void *)(v4 + 24);
        if (!v4) {
          return 1;
        }
      }
    }
  }
  return 0;
}

void b2Body::SetTransform(b2Body *this, const b2Vec2 *a2, float a3)
{
  if (((uint64_t)this->var17[443].var18 & 2) != 0) {
    b2Body::SetTransform();
  }
  __float2 v6 = __sincosf_stret(a3);
  p_var8 = &this->var8;
  if (v6.__cosval != this->var8.var1.var1
    || v6.__sinval != this->var8.var1.var0
    || a2->x != p_var8->var0.x
    || a2->y != this->var8.var0.y)
  {
    this->var8.float var1 = (b2Rot)v6;
    b2Vec2 v8 = *a2;
    this->var8.float var0 = *a2;
    this->var9 = *p_var8;
    float x = this->var10.var0.x;
    float y = this->var10.var0.y;
    this->var10.var2.var0.float var1 = (float)((float)(v6.__cosval * x) - (float)(v6.__sinval * y)) + v8.x;
    this->var10.var2.var0.unsigned int var2 = (float)((float)(v6.__cosval * y) + (float)(v6.__sinval * x)) + v8.y;
    this->var11.float x = a3;
    *(_OWORD *)&this->var10.var1.var0.float var1 = *(_OWORD *)&this->var10.var2.var0.var1;
    for (uint64_t i = this->var20; i; uint64_t i = i->var2)
      b2Fixture::Synchronize((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &this->var8, &this->var8);
  }
}

void b2Body::SetActive(b2Body *this, int a2)
{
  if (((uint64_t)this->var17[443].var18 & 2) != 0) {
    b2Body::SetActive();
  }
  unsigned __int16 var6 = this->var6;
  if (a2 != (var6 & 0x20) >> 5)
  {
    if (a2)
    {
      this->unsigned __int16 var6 = var6 | 0x20;
      for (uint64_t i = this->var20; i; uint64_t i = i->var2)
        b2Fixture::CreateProxies((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &this->var8);
    }
    else
    {
      this->unsigned __int16 var6 = var6 & 0xFFDF;
      for (uint64_t j = this->var20; j; uint64_t j = j->var2)
        b2Fixture::DestroyProxies((b2Fixture *)j, (b2ContactManager *)&this->var17[443].var19);
      uint64_t v6 = *(void *)&this->var24;
      if (v6)
      {
        do
        {
          uint64_t v7 = *(void *)(v6 + 24);
          b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, *(b2Contact **)(v6 + 8));
          uint64_t v6 = v7;
        }
        while (v7);
      }
      *(void *)&this->var24 = 0;
    }
  }
}

void b2ContactManager::b2ContactManager(b2ContactManager *this)
{
  *(_OWORD *)((char *)this + 7std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 2std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 1065353216;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 3std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 1065353216;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 15std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0u;
  *((_DWORD *)this + 4std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 1065353216;
  *(void *)this = &b2ContactManager::b2ContactManager(void)::b2_defaultListener;
  *((_DWORD *)this + std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2) = 0;
}

void b2ContactManager::~b2ContactManager(void **this)
{
}

uint64_t *b2ContactManager::UnBufferMove(b2ContactManager *this, int a2)
{
  int v4 = a2;
  __int16 v2 = (void *)((char *)this + 56);
  float result = std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>((void *)this + 7, &v4);
  if (result) {
    return (uint64_t *)std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(v2, result);
  }
  return result;
}

void *b2ContactManager::MoveProxy(uint64_t a1, unsigned int a2, float32x4_t *a3, float32x2_t *a4)
{
  unsigned int v6 = a2;
  float result = (void *)b2DynamicTree::MoveProxy((b2DynamicTree *)(a1 + 16), a2, a3, a4);
  if (result) {
    return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1 + 56, (int *)&v6, &v6);
  }
  return result;
}

void *b2ContactManager::TouchProxy(b2ContactManager *this, int a2)
{
  int v3 = a2;
  return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 56, &v3, &v3);
}

uint64_t b2ContactManager::CreateProxyId(uint64_t a1, float32x2_t *a2)
{
  unsigned int ProxyId = b2DynamicTree::CreateProxyId((b2DynamicTree *)(a1 + 16), a2);
  ++*(_DWORD *)(a1 + 8);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1 + 56, (int *)&ProxyId, &ProxyId);
  return ProxyId;
}

uint64_t b2ContactManager::DestroyProxy(b2ContactManager *this, unsigned int a2)
{
  b2ContactManager::UnBufferMove(this, a2);
  --*((_DWORD *)this + 2);

  return b2DynamicTree::DestroyProxy((b2ContactManager *)((char *)this + 16), a2);
}

uint64_t b2ContactManager::DestroyContact(b2ContactManager *this, b2Contact *a2)
{
  float32x2_t v15 = a2;
  uint64_t v3 = *(void *)(*((void *)a2 + 10) + 24);
  uint64_t v4 = *(void *)(*((void *)a2 + 11) + 24);
  uint64_t v5 = *(void *)this;
  if (v5 && (*((unsigned char *)a2 + 12) & 2) != 0) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  unsigned int v6 = (void *)((char *)this + 136);
  uint64_t v7 = std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>(v6, &v15);
  if (v7) {
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(v6, v7);
  }
  float v9 = v15;
  uint64_t v10 = *((void *)v15 + 4);
  if (v10) {
    *(void *)(v10 + 24) = *((void *)v15 + 5);
  }
  uint64_t v11 = *((void *)v9 + 5);
  if (v11) {
    *(void *)(v11 + 16) = v10;
  }
  if ((b2Contact *)((char *)v9 + 16) == *(b2Contact **)(v3 + 200)) {
    *(void *)(v3 + 200) = v11;
  }
  uint64_t v12 = *((void *)v9 + 8);
  if (v12) {
    *(void *)(v12 + 24) = *((void *)v9 + 9);
  }
  uint64_t v13 = *((void *)v9 + 9);
  if (v13) {
    *(void *)(v13 + 16) = v12;
  }
  if ((b2Contact *)((char *)v9 + 48) == *(b2Contact **)(v4 + 200)) {
    *(void *)(v4 + 200) = v13;
  }
  return b2Contact::Destroy(v9, v8);
}

void b2ContactManager::Collide(b2ContactManager *this)
{
  float32x2_t v31 = 0;
  float v32 = 0;
  float v33 = 0;
  uint64_t v1 = (void *)*((void *)this + 19);
  if (!v1) {
    return;
  }
  do
  {
    uint64_t v3 = v1[2];
    uint64_t v5 = *(void *)(v3 + 80);
    uint64_t v4 = *(void *)(v3 + 88);
    unsigned int v6 = *(const b2Body **)(v5 + 24);
    uint64_t v7 = *(b2Body **)(v4 + 24);
    if (v6->var5 | v7->var5)
    {
      if (b2Body::ShouldCollide(v7, v6))
      {
        unsigned int v8 = *(_DWORD *)(*(void *)(v5 + 48) + 32 * *(int *)(v3 + 96) + 24);
        if ((v8 & 0x80000000) != 0
          || (int v9 = *((_DWORD *)this + 9), v9 <= (int)v8)
          || (unsigned int v10 = *(_DWORD *)(*(void *)(v4 + 48) + 32 * *(int *)(v3 + 100) + 24), (v10 & 0x80000000) != 0)
          || v9 <= (int)v10)
        {
          __assert_rtn("GetFatAABB", "b2DynamicTree.h", 168, "0 <= proxyId && proxyId < m_nodeCapacity");
        }
        uint64_t v11 = *((void *)this + 3);
        uint64_t v12 = (float *)(v11 + 48 * v8);
        uint64_t v13 = (float *)(v11 + 48 * v10);
        if ((float)(*v13 - v12[2]) <= 0.0
          && (float)(v13[1] - v12[3]) <= 0.0
          && (float)(*v12 - v13[2]) <= 0.0
          && (float)(v12[1] - v13[3]) <= 0.0)
        {
          b2Contact::Update((b2Contact *)v3, *(b2ContactListener **)this);
          goto LABEL_56;
        }
        float32x2_t v14 = v32;
        if (v32 < (b2Contact **)v33) {
          goto LABEL_32;
        }
        uint64_t v25 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v25 + 1) >> 61) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v26 = (v33 - v31) >> 2;
        if (v26 <= v25 + 1) {
          unint64_t v26 = v25 + 1;
        }
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v26;
        }
        if (v17) {
          float v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        }
        else {
          float v18 = 0;
        }
        float32x2_t v22 = &v18[8 * v25];
        *(void *)float32x2_t v22 = v3;
        float32x2_t v21 = (b2Contact **)(v22 + 8);
        uint64_t v23 = (char *)v32;
        if (v32 == (b2Contact **)v31)
        {
LABEL_53:
          float32x2_t v31 = v22;
          float v33 = &v18[8 * v17];
          if (v23) {
            operator delete(v23);
          }
          goto LABEL_55;
        }
        do
        {
          uint64_t v28 = *((void *)v23 - 1);
          v23 -= 8;
          *((void *)v22 - 1) = v28;
          v22 -= 8;
        }
        while (v23 != v31);
LABEL_52:
        uint64_t v23 = v31;
        goto LABEL_53;
      }
      float32x2_t v14 = v32;
      if (v32 >= (b2Contact **)v33)
      {
        uint64_t v19 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v19 + 1) >> 61) {
LABEL_64:
        }
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        unint64_t v20 = (v33 - v31) >> 2;
        if (v20 <= v19 + 1) {
          unint64_t v20 = v19 + 1;
        }
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v20;
        }
        if (v17) {
          float v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        }
        else {
          float v18 = 0;
        }
        float32x2_t v22 = &v18[8 * v19];
        *(void *)float32x2_t v22 = v3;
        float32x2_t v21 = (b2Contact **)(v22 + 8);
        uint64_t v23 = (char *)v32;
        if (v32 == (b2Contact **)v31) {
          goto LABEL_53;
        }
        do
        {
          uint64_t v27 = *((void *)v23 - 1);
          v23 -= 8;
          *((void *)v22 - 1) = v27;
          v22 -= 8;
        }
        while (v23 != v31);
        goto LABEL_52;
      }
    }
    else
    {
      float32x2_t v14 = v32;
      if (v32 >= (b2Contact **)v33)
      {
        uint64_t v15 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v15 + 1) >> 61) {
          goto LABEL_64;
        }
        unint64_t v16 = (v33 - v31) >> 2;
        if (v16 <= v15 + 1) {
          unint64_t v16 = v15 + 1;
        }
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v17) {
          float v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        }
        else {
          float v18 = 0;
        }
        float32x2_t v22 = &v18[8 * v15];
        *(void *)float32x2_t v22 = v3;
        float32x2_t v21 = (b2Contact **)(v22 + 8);
        uint64_t v23 = (char *)v32;
        if (v32 == (b2Contact **)v31) {
          goto LABEL_53;
        }
        do
        {
          uint64_t v24 = *((void *)v23 - 1);
          v23 -= 8;
          *((void *)v22 - 1) = v24;
          v22 -= 8;
        }
        while (v23 != v31);
        goto LABEL_52;
      }
    }
LABEL_32:
    *float32x2_t v14 = (b2Contact *)v3;
    float32x2_t v21 = v14 + 1;
LABEL_55:
    float v32 = v21;
LABEL_56:
    uint64_t v1 = (void *)*v1;
  }
  while (v1);
  float32x2_t v30 = (b2Contact **)v31;
  float32x2_t v29 = v32;
  if (v31 != (char *)v32)
  {
    do
      b2ContactManager::DestroyContact(this, *v30++);
    while (v30 != v32);
    float32x2_t v29 = v31;
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_213579854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

b2Body *b2ContactManager::AddPair(b2Body *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(b2Body ***)(a2 + 16);
  uint64_t v4 = *(const b2Body ***)(a3 + 16);
  uint64_t v5 = v3[3];
  unsigned int v6 = v4[3];
  if (v5 != v6)
  {
    int v9 = result;
    float result = (b2Body *)b2Body::ShouldCollide(v3[3], v4[3]);
    if (result)
    {
      unsigned int v10 = (b2Fixture *)*(unsigned int *)(a2 + 28);
      uint64_t v11 = (b2Fixture *)*(unsigned int *)(a3 + 28);
      uint64_t v12 = *(b2Body ***)&v6->var24;
      if (v12)
      {
        while (1)
        {
          if (*v12 == v5)
          {
            uint64_t v13 = v12[1];
            float32x2_t v14 = *(b2Body ***)&v13->var10.var1.var0.var1;
            float var0 = (void *)v13->var10.var2.var0.var0;
            float var1 = v13->var10.var2.var0.var1;
            float var2 = v13->var10.var2.var0.var2;
            BOOL v18 = v14 == v3 && var0 == v4;
            BOOL v19 = v18 && LODWORD(var1) == v10;
            if (v19 && LODWORD(var2) == v11) {
              break;
            }
            BOOL v21 = v14 == (b2Body **)v4 && var0 == v3;
            BOOL v22 = v21 && LODWORD(var1) == v11;
            if (v22 && LODWORD(var2) == v10) {
              break;
            }
          }
          uint64_t v12 = (b2Body **)v12[3];
          if (!v12) {
            goto LABEL_26;
          }
        }
      }
      else
      {
LABEL_26:
        float result = (b2Body *)b2Contact::Create((b2Contact *)v3, v10, (b2Contact *)v4, v11);
        float v32 = result;
        if (result)
        {
          b2Vec2 v24 = *(b2Vec2 *)(*(void *)&result->var10.var1.var0.var1 + 24);
          uint64_t v25 = *(void *)(*(void *)&result->var10.var2.var0.var0 + 24);
          std::__hash_table<b2Contact *,std::hash<b2Contact *>,std::equal_to<b2Contact *>,std::allocator<b2Contact *>>::__emplace_unique_key_args<b2Contact *,b2Contact * const&>((uint64_t)&v9->var15, &v32, &v32);
          unint64_t v26 = v32;
          uint64_t v27 = v32;
          *(void *)&v32->var4 = v25;
          p_var4 = &v27->var4;
          *(void *)&v26->unsigned __int16 var6 = v26;
          v26->var8.float var0 = 0;
          b2Rot v29 = *(b2Rot *)(*(void *)&v24 + 200);
          v26->var8.float var1 = v29;
          if (v29) {
            *(void *)(*(void *)&v29 + 16) = p_var4;
          }
          *(void *)(*(void *)&v24 + 200) = p_var4;
          v26->var9.float var0 = v24;
          p_var9 = &v26->var9;
          v26->var9.float var1 = (b2Rot)v26;
          v26->var10.float var0 = 0;
          b2Vec2 v31 = *(b2Vec2 *)(v25 + 200);
          v26->var10.var1.var0.float var0 = v31;
          if (v31) {
            *(void *)(*(void *)&v31 + 16) = p_var9;
          }
          *(void *)(v25 + 200) = p_var9;
          b2Body::SetAwake(*(b2Body **)&v24, 1);
          return b2Body::SetAwake((b2Body *)v25, 1);
        }
      }
    }
  }
  return result;
}

uint64_t b2ContactManager::ClearContactIslandFlags(uint64_t this)
{
  for (uint64_t i = *(void **)(this + 152); i; uint64_t i = (void *)*i)
    *(_DWORD *)(i[2] + 12) &= ~1u;
  return this;
}

uint64_t b2ContactManager::InvalidateContacts(uint64_t this)
{
  for (uint64_t i = *(void **)(this + 152); i; uint64_t i = (void *)*i)
  {
    uint64_t v2 = i[2];
    *(_DWORD *)(v2 + 12) &= 0xFFFFFFDE;
    *(void *)(v2 + 168) = 0x3F80000000000000;
  }
  return this;
}

uint64_t b2ContactManager::QueryCallback(b2ContactManager *this, int a2)
{
  LODWORD(vb2DynamicTree::~b2DynamicTree(this + 2) = *((_DWORD *)this + 44);
  if (v2 != a2)
  {
    if (a2 < 0 || (int v3 = *((_DWORD *)this + 9), v3 <= a2)) {
      b2ContactManager::QueryCallback();
    }
    if ((v2 & 0x80000000) != 0 || v3 <= (int)v2) {
      b2ContactManager::QueryCallback();
    }
    uint64_t v4 = *((void *)this + 3);
    uint64_t v5 = *(_DWORD **)(v4 + 48 * a2 + 24);
    unsigned int v6 = *(_DWORD **)(v4 + 48 * v2 + 24);
    int v7 = v6[2];
    int v8 = v5[2];
    int v9 = v5[3];
    int v10 = v6[3] & v8;
    int v11 = v6[4] & v8;
    int v12 = v5[4] & v7;
    int v13 = v9 & v7;
    if (v10) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v13 == 0;
    }
    if (!v14 || v11 != 0 || v12 != 0)
    {
      unint64_t v17 = (char *)this + 96;
      if (a2 >= (int)v2) {
        uint64_t v18 = v2;
      }
      else {
        uint64_t v18 = a2;
      }
      if (a2 <= (int)v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = a2;
      }
      uint64_t v20 = v2 | (v18 << 32);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)v17, (unint64_t *)&v20, &v20);
    }
  }
  return 1;
}

void b2ContactManager::FindMinimumTOI(b2ContactManager *this, b2Contact **a2, float *a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  for (uint64_t i = (void *)*((void *)this + 19); i; uint64_t i = (void *)*i)
  {
    uint64_t v5 = i[2];
    uint64_t v6 = *(void *)(v5 + 80);
    uint64_t v7 = *(void *)(v5 + 88);
    uint64_t v8 = *(void *)(v6 + 24);
    uint64_t v9 = *(void *)(v7 + 24);
    int v10 = *(_DWORD *)(v9 + 8);
    if ((v10 & *(_DWORD *)(v8 + 12)) == 0)
    {
      int v11 = *(_DWORD *)(v8 + 8);
      if ((v11 & *(_DWORD *)(v9 + 12)) == 0 && (*(_DWORD *)(v8 + 16) & v10) == 0 && (*(_DWORD *)(v9 + 16) & v11) == 0) {
        continue;
      }
    }
    int v12 = *(_DWORD *)(v5 + 12);
    if ((v12 & 4) == 0 || *(int *)(v5 + 168) > 8) {
      continue;
    }
    if ((v12 & 0x20) != 0)
    {
      float v14 = *(float *)(v5 + 172);
    }
    else
    {
      if (*(_DWORD *)(v8 + 20) != 2 && *(_DWORD *)(v9 + 20) != 2) {
        continue;
      }
      BOOL v13 = b2Body::IsAwake(*(b2Body **)(v6 + 24)) && *(_DWORD *)(v8 + 20) != 0;
      BOOL v15 = b2Body::IsAwake((b2Body *)v9) && *(_DWORD *)(v9 + 20) != 0;
      if (!v13 && !v15) {
        continue;
      }
      BOOL v16 = (b2Body::IsBullet((b2Body *)v8) & 1) != 0 || *(_DWORD *)(v8 + 20) != 2;
      if ((b2Body::IsBullet((b2Body *)v9) & 1) == 0 && *(_DWORD *)(v9 + 20) == 2 && !v16) {
        continue;
      }
      float v18 = *(float *)(v8 + 112);
      float v19 = *(float *)(v9 + 112);
      if (v18 >= v19)
      {
        if (v19 < v18)
        {
          if (v18 <= 1.0) {
            float v21 = *(float *)(v8 + 112);
          }
          else {
            float v21 = 1.0;
          }
          *(float32x4_t *)(v9 + 80) = vmlaq_n_f32(*(float32x4_t *)(v9 + 80), vsubq_f32(*(float32x4_t *)(v9 + 96), *(float32x4_t *)(v9 + 80)), (float)(v21 - v19) / (float)(1.0 - v19));
          *(float *)(v9 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v21;
        }
        float v19 = v18;
      }
      else
      {
        if (v19 <= 1.0) {
          float v20 = *(float *)(v9 + 112);
        }
        else {
          float v20 = 1.0;
        }
        *(float32x4_t *)(v8 + 80) = vmlaq_n_f32(*(float32x4_t *)(v8 + 80), vsubq_f32(*(float32x4_t *)(v8 + 96), *(float32x4_t *)(v8 + 80)), (float)(v20 - v18) / (float)(1.0 - v18));
        *(float *)(v8 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v20;
      }
      if (v19 >= 1.0) {
        b2ContactManager::FindMinimumTOI();
      }
      int v22 = *(_DWORD *)(v5 + 96);
      int v23 = *(_DWORD *)(v5 + 100);
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      v35[2] = 0;
      v35[3] = 0;
      b2DistanceProxy::Set((b2DistanceProxy *)v32, *(b2Shape **)(v6 + 32), v22);
      b2DistanceProxy::Set((b2DistanceProxy *)v35, *(b2Shape **)(v7 + 32), v23);
      long long v24 = *(_OWORD *)(v8 + 64);
      long long v25 = *(_OWORD *)(v8 + 80);
      long long v26 = *(_OWORD *)(v8 + 96);
      int v39 = *(_DWORD *)(v8 + 112);
      long long v37 = v25;
      long long v38 = v26;
      long long v36 = v24;
      long long v27 = *(_OWORD *)(v9 + 64);
      long long v28 = *(_OWORD *)(v9 + 80);
      long long v29 = *(_OWORD *)(v9 + 96);
      int v43 = *(_DWORD *)(v9 + 112);
      long long v41 = v28;
      long long v42 = v29;
      long long v40 = v27;
      int v44 = 1065353216;
      b2TimeOfImpact(v31, (uint64_t)v32);
      float v14 = 1.0;
      if (v31[0] == 3) {
        float v14 = fminf(v19 + (float)((float)(1.0 - v19) * *(float *)&v31[1]), 1.0);
      }
      *(float *)(v5 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v14;
      *(_DWORD *)(v5 + 12) |= 0x20u;
    }
    if (v14 < *a3)
    {
      *a2 = (b2Contact *)v5;
      *a3 = v14;
    }
  }
}

void *b2ContactManager::FindNewContacts(b2Body *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(&this->var10.var2.var0.var1);
  for (b2Vec2 i = this->var10.var1.var0.var0; i; b2Vec2 i = **(b2Vec2 **)&i)
  {
    unsigned int v3 = *(_DWORD *)(*(void *)&i + 16);
    LODWORD(this->var20) = v3;
    if (v3 != -1)
    {
      if ((v3 & 0x80000000) != 0 || SLODWORD(this->var8.var0.y) <= (signed int)v3) {
        b2ContactManager::FindNewContacts();
      }
      b2DynamicTree::Query<b2ContactManager>((int *)&this->var4, (b2ContactManager *)this, (float *)(*(void *)&this->var6 + 48 * v3));
    }
  }
  float result = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(&this->var9.var1);
  for (uint64_t j = *(void **)&this->var11.y; j; uint64_t j = (void *)*j)
  {
    uint64_t v6 = j[2];
    if (v6 < 0 || (int y_low = LODWORD(this->var8.var0.y), y_low <= SHIDWORD(v6))) {
      b2ContactManager::FindNewContacts();
    }
    if ((v6 & 0x80000000) != 0 || y_low <= (int)v6) {
      b2ContactManager::FindNewContacts();
    }
    float result = b2ContactManager::AddPair(this, *(void *)(*(void *)&this->var6 + 48 * HIDWORD(v6) + 16), *(void *)(*(void *)&this->var6 + 48 * v6 + 16));
  }
  return result;
}

void **b2DynamicTree::Query<b2ContactManager>(int *a1, b2ContactManager *this, float *a3)
{
  float v21 = v22;
  int v6 = *a1;
  int v24 = 256;
  v22[0] = v6;
  int v7 = 1;
  do
  {
    uint64_t v8 = (v7 - 1);
    int v23 = v8;
    uint64_t v9 = v21;
    int v10 = v21[v8];
    if (v10 != -1)
    {
      uint64_t v11 = *((void *)a1 + 1);
      int v12 = (float *)(v11 + 48 * v10);
      if ((float)(*a3 - v12[2]) <= 0.0
        && (float)(a3[1] - v12[3]) <= 0.0
        && (float)(*v12 - a3[2]) <= 0.0
        && (float)(v12[1] - a3[3]) <= 0.0)
      {
        uint64_t v13 = v11 + 48 * v10;
        int v16 = *(_DWORD *)(v13 + 36);
        BOOL v15 = (_DWORD *)(v13 + 36);
        int v14 = v16;
        if (v16 == -1)
        {
          b2ContactManager::QueryCallback(this, v21[v8]);
          LODWORD(v8) = v23;
        }
        else
        {
          int v17 = v24;
          if (v7 <= v24)
          {
            v21[v8] = v14;
          }
          else
          {
            v24 *= 2;
            float v21 = b2Alloc(8 * v17);
            memcpy(v21, v9, 4 * v23);
            if (v9 != v22) {
              b2Free(v9);
            }
            uint64_t v9 = v21;
            v21[v23] = *v15;
          }
          int v18 = v23 + 1;
          int v23 = v18;
          int v19 = v24;
          if (v18 >= v24)
          {
            v24 *= 2;
            float v21 = b2Alloc(8 * v19);
            memcpy(v21, v9, 4 * v23);
            if (v9 != v22) {
              b2Free(v9);
            }
            uint64_t v9 = v21;
            int v18 = v23;
          }
          v9[v18] = *(_DWORD *)(v11 + 48 * v10 + 40);
          LODWORD(v8) = ++v23;
        }
      }
    }
    int v7 = v8;
  }
  while ((int)v8 > 0);
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v21);
}

void sub_21357A0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void b2ContactListener::~b2ContactListener(b2ContactListener *this)
{
}

uint64_t *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  int v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (float result = *v6; result; float result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  int v6 = *(void **)(*result + 8 * v4);
  do
  {
    int v7 = v6;
    int v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  void *v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  int v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    *int v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    int v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_21357A534(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<b2Contact *,std::hash<b2Contact *>,std::equal_to<b2Contact *>,std::allocator<b2Contact *>>::__emplace_unique_key_args<b2Contact *,b2Contact * const&>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (b2Vec2 i = *v11; i; b2Vec2 i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  b2Vec2 i = operator new(0x18uLL);
  *b2Vec2 i = 0;
  i[1] = v8;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  float v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *b2Vec2 i = *v21;
LABEL_38:
    *float v21 = i;
    goto LABEL_39;
  }
  *b2Vec2 i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    float v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_21357A788(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (b2Vec2 i = *v9; i; b2Vec2 i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  b2Vec2 i = operator new(0x18uLL);
  *b2Vec2 i = 0;
  i[1] = v6;
  i[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  size_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *b2Vec2 i = *v19;
LABEL_38:
    *size_t v19 = i;
    goto LABEL_39;
  }
  *b2Vec2 i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    size_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_21357A9A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(void *result)
{
  if (result[3])
  {
    uint64_t v1 = result;
    float result = (void *)result[2];
    if (result)
    {
      do
      {
        uint64_t v2 = (void *)*result;
        operator delete(result);
        float result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void **b2GrowableStack<int,256>::~b2GrowableStack(void **a1)
{
  uint64_t v3 = a1 + 1;
  uint64_t v2 = (void **)*a1;
  if (v2 != v3)
  {
    b2Free(v2);
    *a1 = 0;
  }
  return a1;
}

void b2Fixture::b2Fixture(b2Fixture *this)
{
  *(void *)this = &unk_26C3F4058;
  *((_DWORD *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
}

void b2Fixture::~b2Fixture(b2Fixture *this)
{
  *(void *)this = &unk_26C3F4058;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 6);
  if (v3)
  {
    *((void *)this + 7) = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  b2Fixture::~b2Fixture(this);

  JUMPOUT(0x21668C8E0);
}

float b2Fixture::Create(b2Fixture *this, b2Body *a2, const b2FixtureDef *a3)
{
  float var0 = a3->var0;
  *((void *)this + 9) = a3->var1;
  *((void *)this + 5) = *(void *)&a3->var2;
  *((void *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *((void *)this + 3) = a2;
  *((void *)this + 4) = (*(uint64_t (**)(b2Shape *))(*(void *)var0 + 16))(var0);
  float result = a3->var4;
  *((float *)this + b2DynamicTree::~b2DynamicTree(this + 2) = result;
  return result;
}

void b2Fixture::CreateProxies(b2Fixture *this, b2ContactManager *a2, const b2Transform *a3)
{
  int v6 = (*(uint64_t (**)(void))(**((void **)this + 4) + 24))(*((void *)this + 4));
  std::vector<b2FixtureProxy>::resize((uint64_t)this + 48, v6);
  if (v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 32 * v6;
    do
    {
      uint8x8_t v10 = (float32x2_t *)(*((void *)this + 6) + v7);
      v10[3].i32[1] = v8;
      (*(void (**)(void, float32x2_t *, const b2Transform *, uint64_t))(**((void **)this + 4) + 56))(*((void *)this + 4), v10, a3, v8);
      v10[2] = (float32x2_t)this;
      v10[3].i32[0] = b2ContactManager::CreateProxyId((uint64_t)a2, v10);
      uint64_t v8 = (v8 + 1);
      v7 += 32;
    }
    while (v9 != v7);
  }
}

void std::vector<b2FixtureProxy>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 32 * a2;
    }
  }
  else
  {
    std::vector<b2FixtureProxy>::__append((void **)a1, a2 - v2);
  }
}

b2Fixture *b2Fixture::DestroyProxies(b2Fixture *this, b2ContactManager *a2)
{
  unint64_t v2 = this;
  uint64_t v3 = *((void *)this + 6);
  uint64_t v4 = *((void *)this + 7);
  if (v3 != v4)
  {
    do
    {
      this = (b2Fixture *)b2ContactManager::DestroyProxy(a2, *(_DWORD *)(v3 + 24));
      *(_DWORD *)(v3 + 24) = -1;
      v3 += 32;
    }
    while (v3 != v4);
    uint64_t v3 = *((void *)v2 + 6);
  }
  *((void *)v2 + 7) = v3;
  return this;
}

b2Fixture *b2Fixture::Synchronize(b2Fixture *this, b2ContactManager *a2, const b2Transform *a3, const b2Transform *a4)
{
  unint64_t v4 = *((void *)this + 7) - *((void *)this + 6);
  if (v4 && (int)(v4 >> 5) >= 1)
  {
    uint64_t v8 = this;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = v4 & 0x1FFFFFFFE0;
    do
    {
      uint64_t v12 = *((void *)v8 + 6) + v9;
      (*(void (**)(void, float32x2_t *, const b2Transform *, uint64_t))(**((void **)v8 + 4) + 56))(*((void *)v8 + 4), &v16, a3, v10);
      (*(void (**)(void, float32x2_t *, const b2Transform *, uint64_t))(**((void **)v8 + 4) + 56))(*((void *)v8 + 4), &v14, a4, v10);
      *(int8x8_t *)uint64_t v12 = vbsl_s8((int8x8_t)vcgt_f32(v14, v16), (int8x8_t)v16, (int8x8_t)v14);
      *(int8x8_t *)(v12 + 8) = vbsl_s8((int8x8_t)vcgt_f32(v17, v15), (int8x8_t)v17, (int8x8_t)v15);
      float32x2_t v13 = vsub_f32((float32x2_t)a4->var0, (float32x2_t)a3->var0);
      this = (b2Fixture *)b2ContactManager::MoveProxy((uint64_t)a2, *(_DWORD *)(v12 + 24), (float32x4_t *)v12, &v13);
      uint64_t v10 = (v10 + 1);
      v9 += 32;
    }
    while (v11 != v9);
  }
  return this;
}

b2Fixture *b2Fixture::Refilter(b2Fixture *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 152);
    if (v2)
    {
      uint64_t v3 = *((void *)this + 6);
      uint64_t v4 = *((void *)this + 7);
      if (v3 != v4)
      {
        uint8x8_t v5 = (b2ContactManager *)(v2 + 102944);
        do
        {
          this = (b2Fixture *)b2ContactManager::TouchProxy(v5, *(_DWORD *)(v3 + 24));
          v3 += 32;
        }
        while (v3 != v4);
      }
    }
  }
  return this;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<b2FixtureProxy>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

void std::vector<b2FixtureProxy>::__append(void **a1, unint64_t a2)
{
  int v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint8x8_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 5;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 4 > v9) {
      unint64_t v9 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      float32x2_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<b2FixtureProxy>>(v4, v12);
    }
    else {
      float32x2_t v13 = 0;
    }
    float32x2_t v14 = &v13[32 * v10];
    float32x2_t v15 = &v13[32 * v12];
    bzero(v14, 32 * a2);
    float32x2_t v16 = &v14[32 * a2];
    uint64_t v18 = (char *)*a1;
    float32x2_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        *((_OWORD *)v14 - b2DynamicTree::~b2DynamicTree(this + 2) = *((_OWORD *)v17 - 2);
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 32;
        v17 -= 32;
      }
      while (v17 != v18);
      float32x2_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

uint64_t PKGetLinkedOnOrAfter(uint64_t a1)
{
  unint64_t v1 = dyld_get_active_platform() | (unint64_t)(a1 << 32);

  return MEMORY[0x270ED9718](v1);
}

void b2Island::b2Island(b2Island *this, int a2, int a3, int a4, b2StackAllocator *a5, b2ContactListener *a6)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 4) = 0u;
  unint64_t v12 = (void **)((char *)this + 64);
  *((void *)this + 10) = 0;
  float32x2_t v13 = (void **)((char *)this + 40);
  *((_OWORD *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  std::vector<PKPoint>::reserve((void **)this + 2, a2);
  std::vector<PKPoint>::reserve(v13, a3);
  std::vector<PKPoint>::reserve(v12, a4);
  *(void *)this = a5;
  *((void *)this + 1) = a6;
  *((void *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = b2StackAllocator::Allocate(a5, 16 * a2);
  *((void *)this + 11) = b2StackAllocator::Allocate(*(b2StackAllocator **)this, 16 * a2);
}

void sub_21357B128(_Unwind_Exception *a1)
{
  int v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 7b2DynamicTree::~b2DynamicTree(this + 2) = v6;
    operator delete(v6);
  }
  b2Island::b2Island(v3, v2, v1);
  _Unwind_Resume(a1);
}

void b2Island::~b2Island(b2Island *this)
{
  b2StackAllocator::Free(*(void ***)this, *((void **)this + 11));
  b2StackAllocator::Free(*(void ***)this, *((void **)this + 12));
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    *((void *)this + 9) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4)
  {
    *((void *)this + 3) = v4;
    operator delete(v4);
  }
}

void b2Island::Solve(uint64_t *a1, int a2, long long *a3, PKCAether *a4, double a5, float a6, float a7, float a8, float a9, int a10, char *a11)
{
  PKCAether::Evaluator::Evaluator((PKCAether::Evaluator *)&v91, a4);
  uint64_t v22 = a1[2];
  if (a1[3] != v22)
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    unint64_t v25 = 0;
    do
    {
      uint64_t v26 = *(void *)(v22 + v24);
      long long v27 = *(_OWORD *)(v26 + 96);
      v21.n128_u64[0] = *(void *)(v26 + 128);
      float v28 = *(float *)(v26 + 136);
      *(_OWORD *)(v26 + 80) = v27;
      if (*(_DWORD *)(v26 + 20) == 2)
      {
        long long v78 = v27;
        v20.i64[0] = *(void *)(v26 + 32);
        __n128 v29 = v21;
        v29.n128_u32[2] = 0;
        float32x4_t v77 = v20;
        __n128 v75 = v21;
        __n128 v76 = v29;
        PKCAether::Evaluator::evalVelocity((uint64_t)&v91, *(_DWORD *)(v26 + 4), v20, v29, *(float *)(v26 + 208), *(float *)(v26 + 216), a5);
        if (v20.f32[0] >= 3.4028e38)
        {
          if (*(unsigned char *)v26) {
            float v32 = 1.0;
          }
          else {
            float v32 = 0.0;
          }
          LODWORD(v30) = *(_DWORD *)(v26 + 208);
          PKCAether::Evaluator::evalForce(&v91, *(_DWORD *)(v26 + 4), v32, v77, v76, v30, *(float *)(v26 + 216), a5);
          float v31 = *(float *)a3;
          v21.n128_u64[1] = v75.n128_u64[1];
          v21.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)v75.n128_u64[0], vmul_n_f32(vadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)(v26 + 140)), *(float *)a3 * *(float *)(v26 + 212)));
        }
        else
        {
          float v31 = *(float *)a3;
          v21.n128_u64[0] = v20.i64[0];
        }
        long long v27 = v78;
        float v33 = *(float *)(v26 + 228);
        if ((LODWORD(v33) & 0x60000000) != 0) {
          v21.n128_u64[0] = (unint64_t)vmul_n_f32((float32x2_t)v21.n128_u64[0], 1.0 / (float)((float)(v31 * v33) + 1.0));
        }
        float v28 = v28 + (float)((float)(v31 * *(float *)(v26 + 224)) * *(float *)(v26 + 148));
        float v34 = *(float *)(v26 + 232);
        if ((LODWORD(v34) & 0x60000000) != 0) {
          float v28 = v28 * (float)(1.0 / (float)((float)(v31 * v34) + 1.0));
        }
      }
      *(_OWORD *)(a1[11] + v23) = v27;
      uint64_t v35 = a1[12] + v23;
      *(void *)uint64_t v35 = v21.n128_u64[0];
      *(float *)(v35 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v28;
      ++v25;
      uint64_t v22 = a1[2];
      v24 += 8;
      v23 += 16;
    }
    while (v25 < (a1[3] - v22) >> 3);
  }
  long long v87 = *a3;
  uint64_t v36 = a1[11];
  uint64_t v37 = a1[12];
  uint64_t v88 = *((void *)a3 + 2);
  uint64_t v89 = v36;
  uint64_t v90 = v37;
  long long v80 = *a3;
  uint64_t v81 = *((void *)a3 + 2);
  int v82 = (unint64_t)(a1[6] - a1[5]) >> 3;
  uint64_t v83 = v36;
  uint64_t v84 = v37;
  uint64_t v85 = *a1;
  float v86 = a6;
  b2ContactSolver::b2ContactSolver(v79, &v80, a1 + 2, a1 + 5);
  b2ContactSolver::InitializeVelocityConstraints((b2ContactSolver *)v79);
  if (*((unsigned char *)a3 + 20)) {
    b2ContactSolver::WarmStart((uint64_t)v79);
  }
  long long v38 = (void *)a1[8];
  int v39 = (void *)a1[9];
  while (v38 != v39)
  {
    (*(void (**)(void, long long *))(*(void *)*v38 + 48))(*v38, &v87);
    ++v38;
  }
  if (*((int *)a3 + 3) >= 1)
  {
    int v40 = 0;
    do
    {
      long long v41 = (void *)a1[8];
      long long v42 = (void *)a1[9];
      while (v41 != v42)
      {
        (*(void (**)(void, long long *))(*(void *)*v41 + 56))(*v41, &v87);
        ++v41;
      }
      b2ContactSolver::SolveVelocityConstraints((uint64_t)v79);
      ++v40;
    }
    while (v40 < *((_DWORD *)a3 + 3));
  }
  b2ContactSolver::StoreImpulses((uint64_t)v79);
  uint64_t v43 = a1[3];
  if (v43 == a1[2])
  {
    uint64_t v51 = a1[3];
  }
  else
  {
    unint64_t v44 = 0;
    do
    {
      float32x4_t v45 = *(float32x4_t *)(a1[12] + 16 * v44);
      float v46 = *(float *)a3;
      float32x2_t v47 = (float32x2_t)vmulq_f32(v45, v45).u64[0];
      float v48 = vmlas_n_f32(vmuls_lane_f32(v46 * v46, v47, 1), v46 * v46, v47.f32[0]);
      if (v48 > 4.0)
      {
        unint64_t v49 = vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL).u64[0];
        *(float32x2_t *)v45.f32 = vmul_n_f32(*(float32x2_t *)v45.f32, 2.0 / sqrtf(v48));
        v45.i64[1] = v49;
      }
      float v50 = vmuls_lane_f32(v46, v45, 3);
      if ((float)(v50 * v50) > 2.4674)
      {
        if (v50 <= 0.0) {
          float v50 = -v50;
        }
        v45.f32[3] = v45.f32[3] * (float)(1.5708 / v50);
      }
      *(float32x4_t *)(a1[11] + 16 * v44) = vmlaq_n_f32(*(float32x4_t *)(a1[11] + 16 * v44), v45, v46);
      *(float32x4_t *)(a1[12] + 16 * v44++) = v45;
      uint64_t v43 = a1[2];
      uint64_t v51 = a1[3];
    }
    while (v44 < (v51 - v43) >> 3);
  }
  if (*((int *)a3 + 4) < 1)
  {
    char v57 = 1;
  }
  else
  {
    int v52 = 0;
    do
    {
      BOOL v53 = b2ContactSolver::SolvePositionConstraints((b2ContactSolver *)v79);
      float32x4_t v54 = (void *)a1[8];
      int v55 = (void *)a1[9];
      int v56 = 1;
      while (v54 != v55)
      {
        v56 &= (*(uint64_t (**)(void, long long *))(*(void *)*v54 + 64))(*v54, &v87);
        ++v54;
      }
      if (v53 & v56) {
        break;
      }
      ++v52;
    }
    while (v52 < *((_DWORD *)a3 + 4));
    char v57 = v53 & v56 ^ 1;
    uint64_t v43 = a1[2];
    uint64_t v51 = a1[3];
  }
  if (v51 != v43)
  {
    uint64_t v58 = 0;
    unint64_t v59 = 0;
    do
    {
      uint64_t v60 = *(void *)(v43 + 8 * v59);
      *(_OWORD *)(v60 + 96) = *(_OWORD *)(a1[11] + v58);
      *(void *)(v60 + 128) = *(void *)(a1[12] + v58);
      *(_DWORD *)(v60 + 136) = *(_DWORD *)(a1[12] + v58 + 12);
      __float2 v61 = __sincosf_stret(*(float *)(v60 + 108));
      *(__float2 *)(v60 + 40) = v61;
      float v62 = *(float *)(v60 + 64);
      float v63 = *(float *)(v60 + 68);
      float v64 = *(float *)(v60 + 100) - (float)((float)(v61.__cosval * v63) + (float)(v61.__sinval * v62));
      *(float *)(v60 + 3b2DynamicTree::~b2DynamicTree(this + 2) = *(float *)(v60 + 96) - (float)((float)(v61.__cosval * v62) - (float)(v61.__sinval * v63));
      *(float *)(v60 + 36) = v64;
      ++v59;
      uint64_t v43 = a1[2];
      v58 += 16;
    }
    while (v59 < (a1[3] - v43) >> 3);
  }
  b2Island::Report(a1, (uint64_t)v79[9]);
  if (a10)
  {
    long long v66 = (b2Body **)a1[2];
    uint64_t v65 = (b2Body **)a1[3];
    if (v66 == v65)
    {
      float v68 = 3.4028e38;
      if (a9 > 3.4028e38) {
        char v73 = 1;
      }
      else {
        char v73 = v57;
      }
      if ((v73 & 1) == 0) {
        goto LABEL_73;
      }
    }
    else
    {
      float v67 = *(float *)a3;
      float v68 = 3.4028e38;
      float32x2_t v69 = v66;
      do
      {
        float v70 = *v69;
        if ((*v69)->var5)
        {
          if ((v70->var6 & 4) != 0
            && (float)(*(float *)&v70->var15 * *(float *)&v70->var15) <= (float)(a8 * a8)
            && (float)((float)(*(&v70->var14 + 1) * *(&v70->var14 + 1)) + (float)(v70->var14 * v70->var14)) <= (float)(a7 * a7))
          {
            float v71 = v67 + *(float *)&v70[1].var1;
            *(float *)&v70[1].float var1 = v71;
            if (v68 >= v71) {
              float v68 = v71;
            }
          }
          else
          {
            v70[1].float var1 = 0;
            float v68 = 0.0;
          }
        }
        ++v69;
      }
      while (v69 != v65);
      if (v68 < a9) {
        char v72 = 1;
      }
      else {
        char v72 = v57;
      }
      if ((v72 & 1) == 0)
      {
        do
          b2Body::SetAwake(*v66++, 0);
        while (v66 != v65);
LABEL_73:
        char v74 = 1;
        goto LABEL_74;
      }
    }
    char v74 = (v68 > 0.0) & ~v57;
LABEL_74:
    *a11 = v74;
  }
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)v79);
  if (v92)
  {
    float v93 = v92;
    operator delete(v92);
  }
  v79[0] = (void **)&v91;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](v79);
}

void sub_21357B7D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)va);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)(v10 - 224));
  _Unwind_Resume(a1);
}

void *b2Island::Report(void *result, uint64_t a2)
{
  if (result[1])
  {
    uint64_t v2 = result;
    uint64_t v4 = result[5];
    uint64_t v3 = result[6];
    if (v3 != v4)
    {
      unint64_t v6 = 0;
      uint64_t v7 = (int *)(a2 + 20);
      do
      {
        uint64_t v8 = *(void *)(v4 + 8 * v6);
        uint64_t v9 = *(unsigned int *)(a2 + 152 * v6 + 144);
        v15[2] = v9;
        uint64_t v10 = v7;
        uint64_t v11 = v15;
        if ((int)v9 >= 1)
        {
          do
          {
            *(v11 - b2DynamicTree::~b2DynamicTree(this + 2) = *(v10 - 1);
            int v12 = *v10;
            v10 += 9;
            *v11++ = v12;
            --v9;
          }
          while (v9);
        }
        uint64_t v13 = *(void *)(*(void *)(v8 + 80) + 24);
        uint64_t v14 = *(void *)(*(void *)(v8 + 88) + 24);
        if ((*(_DWORD *)(v14 + 8) & *(_DWORD *)(v13 + 16)) != 0 || (*(_DWORD *)(v13 + 8) & *(_DWORD *)(v14 + 16)) != 0)
        {
          float result = (void *)(*(uint64_t (**)(void))(*(void *)v2[1] + 48))(v2[1]);
          uint64_t v4 = v2[5];
          uint64_t v3 = v2[6];
        }
        ++v6;
        v7 += 38;
      }
      while (v6 < (v3 - v4) >> 3);
    }
  }
  return result;
}

void b2Island::SolveTOI(void *a1, long long *a2, int a3, int a4, float a5)
{
  unint64_t v6 = a1[3] - a1[2];
  unint64_t v7 = v6 >> 3;
  if ((int)(v6 >> 3) <= a3) {
    b2Island::SolveTOI();
  }
  if ((int)v7 <= a4) {
    b2Island::SolveTOI();
  }
  if ((int)v7 >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 12;
    do
    {
      uint64_t v13 = *(void *)(a1[2] + v11);
      *(_OWORD *)(a1[11] + v12 - 1b2DynamicTree::~b2DynamicTree(this + 2) = *(_OWORD *)(v13 + 96);
      *(void *)(a1[12] + v12 - 1b2DynamicTree::~b2DynamicTree(this + 2) = *(void *)(v13 + 128);
      *(_DWORD *)(a1[12] + v1b2DynamicTree::~b2DynamicTree(this + 2) = *(_DWORD *)(v13 + 136);
      v12 += 16;
      v11 += 8;
    }
    while ((v6 & 0x7FFFFFFF8) != v11);
  }
  int v37 = (a1[6] - a1[5]) >> 3;
  uint64_t v39 = *a1;
  long long v35 = *a2;
  uint64_t v36 = *((void *)a2 + 2);
  long long v38 = *(_OWORD *)(a1 + 11);
  float v40 = a5;
  b2ContactSolver::b2ContactSolver(v33, &v35, a1 + 2, a1 + 5);
  if (*((int *)a2 + 4) >= 1)
  {
    int v14 = 0;
    do
    {
      if (b2ContactSolver::SolveTOIPositionConstraints((b2ContactSolver *)v33, a3, a4)) {
        break;
      }
      ++v14;
    }
    while (v14 < *((_DWORD *)a2 + 4));
  }
  *(_OWORD *)(*(void *)(a1[2] + 8 * a3) + 80) = *(_OWORD *)(a1[11] + 16 * a3);
  *(_OWORD *)(*(void *)(a1[2] + 8 * a4) + 80) = *(_OWORD *)(a1[11] + 16 * a4);
  b2ContactSolver::InitializeVelocityConstraints((b2ContactSolver *)v33);
  if (*((int *)a2 + 3) >= 1)
  {
    int v16 = 0;
    do
    {
      b2ContactSolver::SolveVelocityConstraints((uint64_t)v33);
      ++v16;
    }
    while (v16 < *((_DWORD *)a2 + 3));
  }
  if ((int)v7 >= 1)
  {
    uint64_t v17 = 0;
    v15.i32[0] = *(_DWORD *)a2;
    float v18 = *(float *)v15.i32 * *(float *)v15.i32;
    float v31 = *(float *)a2;
    float32x4_t v30 = (float32x4_t)vdupq_lane_s32(v15, 0);
    do
    {
      float32x4_t v19 = *(float32x4_t *)(a1[12] + 16 * v17);
      float32x2_t v20 = (float32x2_t)vmulq_f32(v19, v19).u64[0];
      float v21 = vmlas_n_f32(vmuls_lane_f32(v18, v20, 1), v18, v20.f32[0]);
      if (v21 > 4.0)
      {
        unint64_t v22 = vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL).u64[0];
        *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v19.f32, 2.0 / sqrtf(v21));
        v19.i64[1] = v22;
      }
      float v23 = v19.f32[3];
      float v24 = vmuls_lane_f32(v31, v19, 3);
      if ((float)(v24 * v24) > 2.4674)
      {
        if (v24 <= 0.0) {
          float v24 = -v24;
        }
        float v23 = v19.f32[3] * (float)(1.5708 / v24);
        v19.f32[3] = v23;
      }
      uint64_t v25 = a1[11];
      float32x4_t v32 = vmlaq_f32(*(float32x4_t *)(v25 + 16 * v17), v19, v30);
      *(float32x4_t *)(v25 + 16 * v17) = v32;
      *(float32x4_t *)(a1[12] + 16 * v17) = v19;
      uint64_t v26 = *(void *)(a1[2] + 8 * v17);
      *(float32x4_t *)(v26 + 96) = v32;
      *(void *)(v26 + 128) = v19.i64[0];
      *(float *)(v26 + 136) = v23;
      __float2 v27 = __sincosf_stret(v32.f32[3]);
      *(__float2 *)(v26 + 40) = v27;
      float v28 = *(float *)(v26 + 64);
      float v29 = *(float *)(v26 + 68);
      *(float *)(v26 + 3b2DynamicTree::~b2DynamicTree(this + 2) = v32.f32[0] - (float)((float)(v27.__cosval * v28) - (float)(v27.__sinval * v29));
      *(float *)(v26 + 36) = v32.f32[1] - (float)((float)(v27.__cosval * v29) + (float)(v27.__sinval * v28));
      ++v17;
    }
    while ((v6 >> 3) != v17);
  }
  b2Island::Report(a1, v34);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)v33);
}

void sub_21357BC00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)va);
  _Unwind_Resume(a1);
}

uint64_t b2Island::ClearIslandFlags(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  uint64_t v2 = *(void *)(this + 24);
  while (v1 != v2)
  {
    if (!*(_DWORD *)(*(void *)v1 + 20)) {
      *(_WORD *)(*(void *)v1 + 24) &= ~1u;
    }
    v1 += 8;
  }
  return this;
}

void b2Island::SynchronizeBodiesAndContacts(b2Island *this)
{
  uint64_t v1 = (b2Body **)*((void *)this + 2);
  for (uint64_t i = (b2Body **)*((void *)this + 3); v1 != i; ++v1)
  {
    uint64_t v3 = *v1;
    if ((*v1)->var5 == 2)
    {
      b2Body::SynchronizeFixtures(*v1);
      for (uint64_t j = *(void *)&v3->var24; j; uint64_t j = *(void *)(j + 24))
        *(_DWORD *)(*(void *)(j + 8) + 12) &= 0xFFFFFFDE;
    }
  }
}

void b2World::b2World(b2World *this, const b2Vec2 *a2, char a3)
{
  b2StackAllocator::b2StackAllocator((b2StackAllocator *)this);
  b2ContactManager::b2ContactManager((b2ContactManager *)(v5 + 102944));
  *((void *)this + 12899) = 0;
  *((void *)this + 12904) = 0;
  *(_OWORD *)((char *)this + 103240) = 0u;
  *((void *)this + 12891) = 0;
  *((_OWORD *)this + 6446) = 0u;
  *((_OWORD *)this + 6448) = 0u;
  *((_DWORD *)this + 25797) = 16777473;
  *((unsigned char *)this + 103160) = a3;
  operator new();
}

void sub_21357BDC4(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v3, 0x1020C4075D858B6);
  unint64_t v6 = *(void **)v4;
  if (*(void *)v4)
  {
    *(void *)(v4 + 8) = v6;
    operator delete(v6);
  }
  b2ContactManager::~b2ContactManager(v2);
  b2StackAllocator::~b2StackAllocator(v1);
  _Unwind_Resume(a1);
}

void b2World::~b2World(b2World *this)
{
  uint64_t v2 = (void *)((char *)this + 103128);
  uint64_t v3 = *((void *)this + 12891);
  while (v3)
  {
    uint64_t v5 = v3 + 168;
    uint64_t v3 = *(void *)(v3 + 168);
    uint64_t v4 = *(void **)(v5 + 8);
    if (v4)
    {
      do
      {
        unint64_t v6 = (void *)v4[2];
        (*(void (**)(void *))(*v4 + 8))(v4);
        uint64_t v4 = v6;
      }
      while (v6);
    }
  }
  unint64_t v7 = (PKCAether *)v2[3];
  if (v7)
  {
    PKCAether::~PKCAether(v7);
    MEMORY[0x21668C8E0]();
  }
  uint64_t v8 = (void *)v2[13];
  if (v8)
  {
    v2[14] = v8;
    operator delete(v8);
  }
  b2ContactManager::~b2ContactManager((b2ContactManager *)((char *)this + 102944));

  b2StackAllocator::~b2StackAllocator((b2StackAllocator *)this);
}

__n128 b2World::SetGravity(b2World *this, const b2Vec2 *a2, __n128 a3)
{
  a3.n128_u64[0] = (unint64_t)*a2;
  a3.n128_u32[2] = 0;
  *(__n128 *)*((void *)this + 12894) = a3;
  result.n128_u64[0] = a3.n128_u64[0];
  result.n128_u32[2] = a3.n128_u32[2];
  return result;
}

__n128 b2World::GetGravity(b2World *this)
{
  return *(__n128 *)*((void *)this + 12894);
}

b2World *b2World::SetVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 25800) = a2;
  return this;
}

float b2World::GetVelocityThreshold(b2World *this)
{
  return *((float *)this + 25800);
}

uint64_t b2World::IsSettling(b2World *this)
{
  return *((unsigned __int8 *)this + 103204);
}

b2World *b2World::SetSettlingLinearVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 2580b2DynamicTree::~b2DynamicTree(this + 2) = a2;
  return this;
}

float b2World::GetSettlingLinearVelocityThreshold(b2World *this)
{
  return *((float *)this + 25802);
}

b2World *b2World::SetSettlingAngularVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 25803) = a2;
  return this;
}

float b2World::GetSettlingAngularVelocityThreshold(b2World *this)
{
  return *((float *)this + 25803);
}

b2World *b2World::SetSettlingDuration(b2World *this, float a2)
{
  *((float *)this + 25804) = a2;
  return this;
}

float b2World::GetSettlingDuration(b2World *this)
{
  return *((float *)this + 25804);
}

uint64_t b2World::SetDestructionListener(uint64_t result, uint64_t a2)
{
  *(void *)(result + 103168) = a2;
  return result;
}

b2World *b2World::SetContactListener(b2World *this, b2ContactListener *a2)
{
  *((void *)this + 12868) = a2;
  return this;
}

b2World *b2World::SetDebugDraw(b2World *this, b2Draw *a2)
{
  *((void *)this + 12897) = a2;
  return this;
}

void b2World::CreateBody(b2World *this, const b2BodyDef *a2)
{
  if ((*((unsigned char *)this + 102936) & 2) == 0) {
    operator new();
  }
  b2World::CreateBody();
}

void sub_21357C064(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A0C40E00B488BLL);
  _Unwind_Resume(a1);
}

void b2World::DestroyBody(b2World *this, b2Body *a2, uint64_t a3)
{
  uint64_t v3 = (char *)this + 102936;
  if (*((int *)this + 25786) > 0)
  {
    if ((*v3 & 2) == 0)
    {
      uint64_t v6 = *(void *)&a2->var22;
      if (v6)
      {
        do
        {
          uint64_t v7 = *(void *)(v6 + 24);
          uint64_t v8 = *((void *)v3 + 29);
          if (v8) {
            (*(void (**)(uint64_t, void))(*(void *)v8 + 16))(v8, *(void *)(v6 + 8));
          }
          b2World::DestroyJoint(this, *(b2Joint **)(v6 + 8));
          *(void *)&a2->var22 = v7;
          uint64_t v6 = v7;
        }
        while (v7);
      }
      *(void *)&a2->var22 = 0;
      uint64_t v9 = *(void *)&a2->var24;
      if (v9)
      {
        do
        {
          uint64_t v10 = *(void *)(v9 + 24);
          b2ContactManager::DestroyContact((b2ContactManager *)((char *)this + 102944), *(b2Contact **)(v9 + 8));
          uint64_t v9 = v10;
        }
        while (v10);
      }
      *(void *)&a2->var24 = 0;
      var20 = a2->var20;
      if (var20)
      {
        uint64_t v12 = (b2ContactManager *)((char *)this + 102944);
        do
        {
          float var2 = var20->var2;
          uint64_t v14 = *((void *)v3 + 29);
          if (v14) {
            (*(void (**)(uint64_t, b2JointEdge *))(*(void *)v14 + 24))(v14, var20);
          }
          b2Fixture::DestroyProxies((b2Fixture *)var20, v12);
          (*(void (**)(b2JointEdge *))&var20->var0->var2)(var20);
          a2->var20 = var2;
          --LODWORD(a2->var21);
          var20 = var2;
        }
        while (var2);
      }
      a2->var20 = 0;
      LODWORD(a2->var21) = 0;
      var18 = a2->var18;
      if (var18) {
        *((void *)var18 + 21) = *(void *)&a2->var19;
      }
      uint64_t v16 = *(void *)&a2->var19;
      if (v16) {
        *(void *)(v16 + 160) = var18;
      }
      if (*((b2Body **)v3 + 24) == a2) {
        *((void *)v3 + 24) = v16;
      }
      --*((_DWORD *)v3 + 52);
      PKCMechanics::QueryAABB(a2, a2, a3);
      JUMPOUT(0x21668C8E0);
    }
    b2World::DestroyBody();
  }
  b2World::DestroyBody();
}

b2Joint *b2World::DestroyJoint(b2World *this, b2Joint *a2)
{
  uint64_t v2 = (char *)this + 102936;
  if ((*((unsigned char *)this + 102936) & 2) != 0) {
    b2World::DestroyJoint();
  }
  float var2 = a2->var2;
  if (var2) {
    var2->var3 = a2->var3;
  }
  var3 = a2->var3;
  if (var3) {
    var3->float var2 = var2;
  }
  if (*((b2Joint **)this + 12892) == a2) {
    *((void *)this + 1289b2DynamicTree::~b2DynamicTree(this + 2) = var3;
  }
  unsigned __int16 var6 = a2->var6;
  var7 = a2->var7;
  b2Body::SetAwake(var6, 1);
  b2Body::SetAwake(var7, 1);
  uint64_t v9 = a2->var4.var2;
  if (v9) {
    v9->var3 = a2->var4.var3;
  }
  uint64_t v10 = a2->var4.var3;
  if (v10) {
    v10->float var2 = v9;
  }
  if (&a2->var4 == (b2JointEdge *)*(b2Joint **)&var6->var22) {
    *(void *)&var6->var22 = v10;
  }
  uint64_t v11 = a2->var5.var2;
  a2->var4.float var2 = 0;
  a2->var4.var3 = 0;
  if (v11) {
    v11->var3 = a2->var5.var3;
  }
  uint64_t v12 = a2->var5.var3;
  if (v12) {
    v12->float var2 = v11;
  }
  if (&a2->var5 == (b2JointEdge *)*(b2Joint **)&var7->var22) {
    *(void *)&var7->var22 = v12;
  }
  a2->var5.float var2 = 0;
  a2->var5.var3 = 0;
  __n128 result = b2Joint::Destroy(a2, v8);
  int v14 = *((_DWORD *)v2 + 53);
  if (v14 <= 0) {
    b2World::DestroyJoint();
  }
  *((_DWORD *)v2 + 53) = v14 - 1;
  return result;
}

void b2World::CreateJoint(b2World *this, b2Joint *a2)
{
  if ((*((unsigned char *)this + 102936) & 2) == 0) {
    b2Joint::Create(a2, (const b2JointDef *)a2);
  }
  b2World::CreateJoint();
}

void b2World::Solve(b2StackAllocator *a1, long long *a2)
{
  uint64_t v2 = (char *)a1 + 102944;
  for (uint64_t i = *((void *)a1 + 12891); i; uint64_t i = *(void *)(i + 168))
    *(_OWORD *)(i + 48) = *(_OWORD *)(i + 32);
  b2Island::b2Island((b2Island *)v89, *((_DWORD *)a1 + 25786), *((_DWORD *)a1 + 25776), *((_DWORD *)a1 + 25787), a1, *(b2ContactListener **)v2);
  for (uint64_t j = *((void *)v2 + 23); j; uint64_t j = *(void *)(j + 168))
    *(_WORD *)(j + 24) &= ~1u;
  b2ContactManager::ClearContactIslandFlags((uint64_t)v2);
  for (uint64_t k = *((void *)v2 + 24); k; uint64_t k = *(void *)(k + 24))
    *(unsigned char *)(k + 11b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  __p = 0;
  long long v87 = 0;
  unint64_t v88 = 0;
  std::vector<PKPoint>::reserve(&__p, *((int *)v2 + 50));
  uint64_t v6 = *((void *)v2 + 23);
  if (v6)
  {
    uint64_t v81 = v2;
    char v83 = 1;
    do
    {
      if ((*(_WORD *)(v6 + 24) & 1) == 0
        && b2Body::IsAwake((b2Body *)v6)
        && (b2Body::IsActive((b2Body *)v6) & 1) != 0
        && *(_DWORD *)(v6 + 20))
      {
        float32x4_t v91 = v90;
        float v94 = v93;
        float v97 = v96;
        uint64_t v7 = (char *)__p;
        long long v87 = (b2Body **)__p;
        if ((unint64_t)__p >= v88)
        {
          unint64_t v9 = (uint64_t)(v88 - (void)__p) >> 2;
          if (v9 <= 1) {
            unint64_t v9 = 1;
          }
          if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v10 = v9;
          }
          uint64_t v11 = std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v10);
          void *v11 = v6;
          uint64_t v8 = (b2Body **)(v11 + 1);
          int v14 = (char *)__p;
          uint64_t v13 = (char *)v87;
          int32x2_t v15 = (char *)v11;
          if (v87 != __p)
          {
            do
            {
              uint64_t v16 = *((void *)v13 - 1);
              v13 -= 8;
              *((void *)v15 - 1) = v16;
              v15 -= 8;
            }
            while (v13 != v14);
            uint64_t v13 = (char *)__p;
          }
          __p = v15;
          long long v87 = (b2Body **)(v11 + 1);
          unint64_t v88 = (unint64_t)&v11[v12];
          if (v13) {
            operator delete(v13);
          }
        }
        else
        {
          *(void *)__p = v6;
          uint64_t v8 = (b2Body **)(v7 + 8);
        }
        long long v87 = v8;
        *(_WORD *)(v6 + 24) |= 1u;
        uint64_t v17 = (b2Body **)__p;
        while (v17 != v8)
        {
          uint64_t v18 = (uint64_t)*(v8 - 1);
          long long v87 = v8 - 1;
          float32x4_t v19 = v90;
          float32x2_t v20 = v91;
          uint64_t v21 = (v91 - v90) >> 3;
          *(_DWORD *)(v18 + 28) = v21;
          if (v20 >= v92)
          {
            if ((unint64_t)(v21 + 1) >> 61) {
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v23 = v92 - v19;
            uint64_t v24 = v23 >> 2;
            if (v23 >> 2 <= (unint64_t)(v21 + 1)) {
              uint64_t v24 = v21 + 1;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v24;
            }
            if (v25) {
              uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v92, v25);
            }
            else {
              uint64_t v26 = 0;
            }
            __float2 v27 = &v26[8 * v21];
            *(void *)__float2 v27 = v18;
            unint64_t v22 = v27 + 8;
            float v29 = v90;
            float v28 = v91;
            if (v91 != v90)
            {
              do
              {
                uint64_t v30 = *((void *)v28 - 1);
                v28 -= 8;
                *((void *)v27 - 1) = v30;
                v27 -= 8;
              }
              while (v28 != v29);
              float v28 = v90;
            }
            uint64_t v90 = v27;
            float32x4_t v91 = v22;
            float v92 = &v26[8 * v25];
            if (v28) {
              operator delete(v28);
            }
          }
          else
          {
            *(void *)float32x2_t v20 = v18;
            unint64_t v22 = v20 + 8;
          }
          float32x4_t v91 = v22;
          b2Body::SetAwake((b2Body *)v18, 1);
          if (*(_DWORD *)(v18 + 20))
          {
            for (uint64_t m = *(b2Body ***)(v18 + 200); m; uint64_t m = (b2Body **)m[3])
            {
              float32x4_t v32 = m[1];
              if ((v32->var3 & 7) == 6)
              {
                uint64_t v33 = *(void *)(*(void *)&v32->var10.var1.var0.var1 + 24);
                uint64_t v34 = *(void *)(*(void *)&v32->var10.var2.var0.var0 + 24);
                if ((*(_DWORD *)(v34 + 8) & *(_DWORD *)(v33 + 12)) != 0
                  || (*(_DWORD *)(v33 + 8) & *(_DWORD *)(v34 + 12)) != 0)
                {
                  long long v35 = v94;
                  if (v94 >= v95)
                  {
                    uint64_t v37 = (v94 - v93) >> 3;
                    if ((unint64_t)(v37 + 1) >> 61) {
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    }
                    unint64_t v38 = (v95 - v93) >> 2;
                    if (v38 <= v37 + 1) {
                      unint64_t v38 = v37 + 1;
                    }
                    if ((unint64_t)(v95 - v93) >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v39 = v38;
                    }
                    if (v39) {
                      float v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v95, v39);
                    }
                    else {
                      float v40 = 0;
                    }
                    long long v41 = &v40[8 * v37];
                    *(void *)long long v41 = v32;
                    uint64_t v36 = v41 + 8;
                    uint64_t v43 = v93;
                    long long v42 = v94;
                    if (v94 != v93)
                    {
                      do
                      {
                        uint64_t v44 = *((void *)v42 - 1);
                        v42 -= 8;
                        *((void *)v41 - 1) = v44;
                        v41 -= 8;
                      }
                      while (v42 != v43);
                      long long v42 = v93;
                    }
                    float v93 = v41;
                    float v94 = v36;
                    float v95 = &v40[8 * v39];
                    if (v42) {
                      operator delete(v42);
                    }
                  }
                  else
                  {
                    *(void *)float v94 = v32;
                    uint64_t v36 = v35 + 8;
                  }
                  float v94 = v36;
                  v32->var3 |= 1u;
                  float32x4_t v45 = *m;
                  if (((*m)->var6 & 1) == 0)
                  {
                    float v46 = v87;
                    if ((unint64_t)v87 >= v88)
                    {
                      uint64_t v48 = ((char *)v87 - (unsigned char *)__p) >> 3;
                      if ((unint64_t)(v48 + 1) >> 61) {
                        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                      }
                      unint64_t v49 = (uint64_t)(v88 - (void)__p) >> 2;
                      if (v49 <= v48 + 1) {
                        unint64_t v49 = v48 + 1;
                      }
                      if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v50 = v49;
                      }
                      if (v50) {
                        uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v50);
                      }
                      else {
                        uint64_t v51 = 0;
                      }
                      int v52 = &v51[8 * v48];
                      *(void *)int v52 = v45;
                      float32x2_t v47 = (b2Body **)(v52 + 8);
                      float32x4_t v54 = (char *)__p;
                      BOOL v53 = (char *)v87;
                      if (v87 != __p)
                      {
                        do
                        {
                          uint64_t v55 = *((void *)v53 - 1);
                          v53 -= 8;
                          *((void *)v52 - 1) = v55;
                          v52 -= 8;
                        }
                        while (v53 != v54);
                        BOOL v53 = (char *)__p;
                      }
                      __p = v52;
                      long long v87 = v47;
                      unint64_t v88 = (unint64_t)&v51[8 * v50];
                      if (v53) {
                        operator delete(v53);
                      }
                    }
                    else
                    {
                      *long long v87 = v45;
                      float32x2_t v47 = v46 + 1;
                    }
                    long long v87 = v47;
                    v45->var6 |= 1u;
                  }
                }
              }
            }
            for (uint64_t n = *(void *)(v18 + 192); n; uint64_t n = *(void *)(n + 24))
            {
              if (!*(unsigned char *)(*(void *)(n + 8) + 112))
              {
                char v57 = *(b2Body **)n;
                if (b2Body::IsActive(*(b2Body **)n))
                {
                  uint64_t v58 = *(void *)(n + 8);
                  unint64_t v59 = v97;
                  if (v97 >= v98)
                  {
                    uint64_t v61 = (v97 - v96) >> 3;
                    if ((unint64_t)(v61 + 1) >> 61) {
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    }
                    unint64_t v62 = (v98 - v96) >> 2;
                    if (v62 <= v61 + 1) {
                      unint64_t v62 = v61 + 1;
                    }
                    if ((unint64_t)(v98 - v96) >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v63 = v62;
                    }
                    if (v63) {
                      float v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v98, v63);
                    }
                    else {
                      float v64 = 0;
                    }
                    uint64_t v65 = &v64[8 * v61];
                    *(void *)uint64_t v65 = v58;
                    uint64_t v60 = v65 + 8;
                    long long v66 = v97;
                    float v67 = v96;
                    if (v97 != v96)
                    {
                      do
                      {
                        uint64_t v68 = *((void *)v66 - 1);
                        v66 -= 8;
                        *((void *)v65 - 1) = v68;
                        v65 -= 8;
                      }
                      while (v66 != v67);
                      long long v66 = v96;
                    }
                    float v96 = v65;
                    float v97 = v60;
                    float v98 = &v64[8 * v63];
                    if (v66) {
                      operator delete(v66);
                    }
                  }
                  else
                  {
                    *(void *)float v97 = v58;
                    uint64_t v60 = v59 + 8;
                  }
                  float v97 = v60;
                  *(unsigned char *)(*(void *)(n + 8) + 11b2DynamicTree::~b2DynamicTree(this + 2) = 1;
                  if ((v57->var6 & 1) == 0)
                  {
                    float32x2_t v69 = v87;
                    if ((unint64_t)v87 >= v88)
                    {
                      uint64_t v71 = ((char *)v87 - (unsigned char *)__p) >> 3;
                      if ((unint64_t)(v71 + 1) >> 61) {
                        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                      }
                      unint64_t v72 = (uint64_t)(v88 - (void)__p) >> 2;
                      if (v72 <= v71 + 1) {
                        unint64_t v72 = v71 + 1;
                      }
                      if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v73 = v72;
                      }
                      if (v73) {
                        char v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v73);
                      }
                      else {
                        char v74 = 0;
                      }
                      __n128 v75 = (b2Body **)&v74[8 * v71];
                      float32x2_t *v75 = v57;
                      float v70 = v75 + 1;
                      float32x4_t v77 = (char *)__p;
                      __n128 v76 = (char *)v87;
                      if (v87 != __p)
                      {
                        do
                        {
                          long long v78 = (b2Body *)*((void *)v76 - 1);
                          v76 -= 8;
                          *--__n128 v75 = v78;
                        }
                        while (v76 != v77);
                        __n128 v76 = (char *)__p;
                      }
                      __p = v75;
                      long long v87 = v70;
                      unint64_t v88 = (unint64_t)&v74[8 * v73];
                      if (v76) {
                        operator delete(v76);
                      }
                    }
                    else
                    {
                      *long long v87 = v57;
                      float v70 = v69 + 1;
                    }
                    long long v87 = v70;
                    v57->var6 |= 1u;
                  }
                }
              }
            }
          }
          uint64_t v17 = (b2Body **)__p;
          uint64_t v8 = v87;
        }
        unsigned __int8 v85 = 0;
        uint64_t v2 = v81;
        b2Island::Solve(v89, (int)&v84, a2, *((PKCAether **)v81 + 26), *((double *)v81 + 31), *((float *)v81 + 64), *((float *)v81 + 66), *((float *)v81 + 67), *((float *)v81 + 68), v81[216], (char *)&v85);
        int v79 = v85;
        b2Island::ClearIslandFlags((uint64_t)v89);
        v83 &= v79 != 0;
      }
      uint64_t v6 = *(void *)(v6 + 168);
    }
    while (v6);
    uint64_t v80 = *((void *)v2 + 23);
    for (v2[260] = v83 & 1; v80; uint64_t v80 = *(void *)(v80 + 168))
    {
      if ((*(_WORD *)(v80 + 24) & 1) != 0 && *(_DWORD *)(v80 + 20)) {
        b2Body::SynchronizeFixtures((b2Body *)v80);
      }
    }
  }
  else
  {
    v2[260] = 1;
  }
  b2ContactManager::FindNewContacts((b2Body *)v2);
  if (__p)
  {
    long long v87 = (b2Body **)__p;
    operator delete(__p);
  }
  b2Island::~b2Island((b2Island *)v89);
}

void sub_21357CB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
}

void b2World::SolveTOI(b2ContactListener **a1, uint64_t a2)
{
  uint64_t v147 = *MEMORY[0x263EF8340];
  uint64_t v2 = (char *)(a1 + 12868);
  b2Island::b2Island((b2Island *)v127, 64, 32, 0, (b2StackAllocator *)a1, a1[12868]);
  if (v2[247])
  {
    for (uint64_t i = *((void *)v2 + 23); i; uint64_t i = *(void *)(i + 168))
    {
      *(_WORD *)(i + 24) &= ~1u;
      *(_DWORD *)(i + 11b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    }
    b2ContactManager::InvalidateContacts((uint64_t)v2);
  }
  char v4 = 1;
  while (1)
  {
    char v5 = v4;
    float v126 = 0;
    float v125 = 1.0;
    b2ContactManager::FindMinimumTOI((b2ContactManager *)v2, &v126, &v125);
    uint64_t v6 = v126;
    if (!v126 || v125 > 1.0)
    {
      v2[247] = 1;
      goto LABEL_128;
    }
    uint64_t v7 = *(void *)(*((void *)v126 + 10) + 24);
    uint64_t v8 = *(void *)(*((void *)v126 + 11) + 24);
    long long v9 = *(_OWORD *)(v7 + 80);
    long long v143 = *(_OWORD *)(v7 + 64);
    long long v144 = v9;
    long long v10 = *(_OWORD *)(v7 + 112);
    long long v145 = *(_OWORD *)(v7 + 96);
    long long v146 = v10;
    long long v11 = *(_OWORD *)(v8 + 80);
    long long v139 = *(_OWORD *)(v8 + 64);
    long long v140 = v11;
    long long v12 = *(_OWORD *)(v8 + 112);
    long long v141 = *(_OWORD *)(v8 + 96);
    long long v142 = v12;
    if ((LODWORD(v125) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    {
      if (v125 <= 1.0) {
        float v13 = v125;
      }
      else {
        float v13 = 1.0;
      }
      float32x4_t v122 = vmlaq_n_f32(*(float32x4_t *)(v7 + 80), vsubq_f32(*(float32x4_t *)(v7 + 96), *(float32x4_t *)(v7 + 80)), (float)(v13 - *(float *)(v7 + 112)) / (float)(1.0 - *(float *)(v7 + 112)));
      *(float *)(v7 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v13;
      *(float32x4_t *)(v7 + 80) = v122;
      *(float32x4_t *)(v7 + 96) = v122;
      __float2 v14 = __sincosf_stret(v122.f32[3]);
      *(__float2 *)(v7 + 40) = v14;
      float v15 = *(float *)(v7 + 64);
      float v16 = *(float *)(v7 + 68);
      *(float *)(v7 + 3b2DynamicTree::~b2DynamicTree(this + 2) = v122.f32[0] - (float)((float)(v14.__cosval * v15) - (float)(v14.__sinval * v16));
      *(float *)(v7 + 36) = v122.f32[1] - (float)((float)(v14.__cosval * v16) + (float)(v14.__sinval * v15));
      float32x4_t v123 = vmlaq_n_f32(*(float32x4_t *)(v8 + 80), vsubq_f32(*(float32x4_t *)(v8 + 96), *(float32x4_t *)(v8 + 80)), (float)(v13 - *(float *)(v8 + 112)) / (float)(1.0 - *(float *)(v8 + 112)));
      *(float *)(v8 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v13;
      *(float32x4_t *)(v8 + 80) = v123;
      *(float32x4_t *)(v8 + 96) = v123;
      __float2 v17 = __sincosf_stret(v123.f32[3]);
      *(__float2 *)(v8 + 40) = v17;
      float v18 = *(float *)(v8 + 64);
      float v19 = *(float *)(v8 + 68);
      *(float *)(v8 + 3b2DynamicTree::~b2DynamicTree(this + 2) = v123.f32[0] - (float)((float)(v17.__cosval * v18) - (float)(v17.__sinval * v19));
      *(float *)(v8 + 36) = v123.f32[1] - (float)((float)(v17.__cosval * v19) + (float)(v17.__sinval * v18));
    }
    b2Contact::Update(v6, *(b2ContactListener **)v2);
    float32x2_t v20 = v126;
    int v21 = *((_DWORD *)v126 + 3);
    *((_DWORD *)v126 + 3) = v21 & 0xFFFFFFDF;
    ++*((_DWORD *)v20 + 42);
    if ((~v21 & 6) == 0) {
      break;
    }
    *((_DWORD *)v20 + 3) = v21 & 0xFFFFFFDB;
    long long v24 = v144;
    *(_OWORD *)(v7 + 64) = v143;
    *(_OWORD *)(v7 + 80) = v24;
    *(_OWORD *)(v7 + 96) = v145;
    *(_DWORD *)(v7 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v146;
    long long v25 = v140;
    *(_OWORD *)(v8 + 64) = v139;
    *(_OWORD *)(v8 + 80) = v25;
    *(_OWORD *)(v8 + 96) = v141;
    *(_DWORD *)(v8 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v142;
    __float2 v26 = __sincosf_stret(*(float *)(v7 + 108));
    *(__float2 *)(v7 + 40) = v26;
    float v27 = *(float *)(v7 + 64);
    float v28 = *(float *)(v7 + 68);
    float v29 = (float)(v26.__cosval * v27) - (float)(v26.__sinval * v28);
    float v30 = (float)(v26.__cosval * v28) + (float)(v26.__sinval * v27);
    float v31 = *(float *)(v7 + 100);
    *(float *)(v7 + 3b2DynamicTree::~b2DynamicTree(this + 2) = *(float *)(v7 + 96) - v29;
    *(float *)(v7 + 36) = v31 - v30;
    __float2 v32 = __sincosf_stret(*(float *)(v8 + 108));
    *(__float2 *)(v8 + 40) = v32;
    float v33 = *(float *)(v8 + 64);
    float v34 = *(float *)(v8 + 68);
    float v35 = *(float *)(v8 + 100) - (float)((float)(v32.__cosval * v34) + (float)(v32.__sinval * v33));
    *(float *)(v8 + 3b2DynamicTree::~b2DynamicTree(this + 2) = *(float *)(v8 + 96) - (float)((float)(v32.__cosval * v33) - (float)(v32.__sinval * v34));
    *(float *)(v8 + 36) = v35;
LABEL_124:
    char v4 = 0;
    if ((v5 & 1) == 0) {
      goto LABEL_128;
    }
  }
  b2Body::SetAwake((b2Body *)v7, 1);
  b2Body::SetAwake((b2Body *)v8, 1);
  unint64_t v22 = v128;
  float v129 = v128;
  float32x2_t v132 = v131;
  v133[2] = v133[1];
  *(_DWORD *)(v7 + 28) = 0;
  if (v22 >= v130)
  {
    unint64_t v36 = (v130 - v22) >> 2;
    if (v36 <= 1) {
      unint64_t v36 = 1;
    }
    if ((unint64_t)(v130 - v22) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v37 = v36;
    }
    unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v37);
    *(void *)unint64_t v38 = v7;
    uint64_t v23 = v38 + 8;
    long long v41 = v128;
    float v40 = v129;
    long long v42 = v38;
    if (v129 != v128)
    {
      do
      {
        uint64_t v43 = *((void *)v40 - 1);
        v40 -= 8;
        *((void *)v42 - 1) = v43;
        v42 -= 8;
      }
      while (v40 != v41);
      float v40 = v128;
    }
    float v128 = v42;
    float v129 = v38 + 8;
    int16x8_t v130 = &v38[8 * v39];
    if (v40) {
      operator delete(v40);
    }
  }
  else
  {
    *(void *)unint64_t v22 = v7;
    uint64_t v23 = v22 + 8;
  }
  float v129 = v23;
  uint64_t v44 = v128;
  uint64_t v45 = (v23 - v128) >> 3;
  *(_DWORD *)(v8 + 28) = v45;
  if (v23 >= v130)
  {
    if ((unint64_t)(v45 + 1) >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v47 = v130 - v44;
    uint64_t v48 = v47 >> 2;
    if (v47 >> 2 <= (unint64_t)(v45 + 1)) {
      uint64_t v48 = v45 + 1;
    }
    if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v49 = v48;
    }
    if (v49) {
      unint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v49);
    }
    else {
      unint64_t v50 = 0;
    }
    uint64_t v51 = &v50[8 * v45];
    *(void *)uint64_t v51 = v8;
    float v46 = v51 + 8;
    BOOL v53 = v128;
    int v52 = v129;
    if (v129 != v128)
    {
      do
      {
        uint64_t v54 = *((void *)v52 - 1);
        v52 -= 8;
        *((void *)v51 - 1) = v54;
        v51 -= 8;
      }
      while (v52 != v53);
      int v52 = v128;
    }
    float v128 = v51;
    float v129 = v46;
    int16x8_t v130 = &v50[8 * v49];
    if (v52) {
      operator delete(v52);
    }
  }
  else
  {
    *(void *)uint64_t v23 = v8;
    float v46 = v23 + 8;
  }
  float v129 = v46;
  uint64_t v55 = v126;
  int v56 = v132;
  char v120 = v5;
  if ((unint64_t)v132 >= v133[0])
  {
    uint64_t v58 = v132 - v131;
    if ((unint64_t)(v58 + 1) >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v59 = (uint64_t)(v133[0] - (void)v131) >> 2;
    if (v59 <= v58 + 1) {
      unint64_t v59 = v58 + 1;
    }
    if (v133[0] - (void)v131 >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v60 = v59;
    }
    if (v60) {
      uint64_t v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v133, v60);
    }
    else {
      uint64_t v61 = 0;
    }
    unint64_t v62 = (b2Contact **)&v61[8 * v58];
    float *v62 = v55;
    char v57 = v62 + 1;
    float v64 = v131;
    unint64_t v63 = v132;
    if (v132 != v131)
    {
      do
      {
        uint64_t v65 = *--v63;
        *--unint64_t v62 = v65;
      }
      while (v63 != v64);
      unint64_t v63 = v131;
    }
    uint64_t v131 = v62;
    float32x2_t v132 = v57;
    v133[0] = &v61[8 * v60];
    if (v63) {
      operator delete(v63);
    }
  }
  else
  {
    *float32x2_t v132 = v126;
    char v57 = v56 + 1;
  }
  uint64_t v66 = 0;
  float32x2_t v132 = v57;
  *(_WORD *)(v7 + 24) |= 1u;
  *(_WORD *)(v8 + 24) |= 1u;
  *((_DWORD *)v126 + 3) |= 1u;
  v138[0] = v7;
  v138[1] = v8;
  uint64_t v121 = v8;
  char v67 = 1;
  do
  {
    char v68 = v67;
    uint64_t v69 = v138[v66];
    if (*(_DWORD *)(v69 + 20) == 2)
    {
      for (uint64_t j = *(void **)(v69 + 200); j; uint64_t j = (void *)j[3])
      {
        uint64_t v71 = j[1];
        if ((*(unsigned char *)(v71 + 12) & 1) == 0)
        {
          uint64_t v72 = *j;
          if (*(_DWORD *)(*j + 20) != 2
            || (b2Body::IsBullet((b2Body *)v69) & 1) != 0
            || (b2Body::IsBullet((b2Body *)v72) & 1) != 0)
          {
            unint64_t v73 = *(_DWORD **)(*(void *)(v71 + 80) + 24);
            char v74 = *(_DWORD **)(*(void *)(v71 + 88) + 24);
            int v75 = v74[2];
            if ((v75 & v73[3]) != 0
              || (int v76 = v73[2], (v76 & v74[3]) != 0)
              || (v73[4] & v75) != 0
              || (v74[4] & v76) != 0)
            {
              long long v77 = *(_OWORD *)(v72 + 80);
              long long v134 = *(_OWORD *)(v72 + 64);
              long long v78 = *(_OWORD *)(v72 + 96);
              long long v79 = *(_OWORD *)(v72 + 112);
              long long v135 = v77;
              long long v136 = v78;
              long long v137 = v79;
              if ((*(unsigned char *)(v72 + 24) & 1) == 0)
              {
                float v80 = v125;
                if ((LODWORD(v125) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
                {
                  if (v125 > 1.0) {
                    float v80 = 1.0;
                  }
                  float32x4_t v124 = vmlaq_n_f32(*(float32x4_t *)(v72 + 80), vsubq_f32(*(float32x4_t *)(v72 + 96), *(float32x4_t *)(v72 + 80)), (float)(v80 - *(float *)(v72 + 112)) / (float)(1.0 - *(float *)(v72 + 112)));
                  *(float *)(v72 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v80;
                  *(float32x4_t *)(v72 + 80) = v124;
                  *(float32x4_t *)(v72 + 96) = v124;
                  __float2 v81 = __sincosf_stret(v124.f32[3]);
                  *(__float2 *)(v72 + 40) = v81;
                  float v82 = *(float *)(v72 + 64);
                  float v83 = *(float *)(v72 + 68);
                  *(float *)(v72 + 3b2DynamicTree::~b2DynamicTree(this + 2) = v124.f32[0]
                                       - (float)((float)(v81.__cosval * v82) - (float)(v81.__sinval * v83));
                  *(float *)(v72 + 36) = v124.f32[1]
                                       - (float)((float)(v81.__cosval * v83) + (float)(v81.__sinval * v82));
                }
              }
              b2Contact::Update((b2Contact *)v71, *(b2ContactListener **)v2);
              int v84 = *(_DWORD *)(v71 + 12);
              if ((v84 & 4) != 0 && (v84 & 2) != 0)
              {
                *(_DWORD *)(v71 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v84 | 1;
                uint64_t v90 = v132;
                if ((unint64_t)v132 >= v133[0])
                {
                  uint64_t v92 = v132 - v131;
                  if ((unint64_t)(v92 + 1) >> 61) {
                    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                  }
                  unint64_t v93 = (uint64_t)(v133[0] - (void)v131) >> 2;
                  if (v93 <= v92 + 1) {
                    unint64_t v93 = v92 + 1;
                  }
                  if (v133[0] - (void)v131 >= 0x7FFFFFFFFFFFFFF8uLL) {
                    unint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v94 = v93;
                  }
                  if (v94) {
                    float v95 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v133, v94);
                  }
                  else {
                    float v95 = 0;
                  }
                  float v96 = &v95[8 * v92];
                  *(void *)float v96 = v71;
                  float32x4_t v91 = (b2Contact **)(v96 + 8);
                  float v98 = v131;
                  float v97 = v132;
                  if (v132 != v131)
                  {
                    do
                    {
                      uint64_t v99 = (uint64_t)*--v97;
                      *((void *)v96 - 1) = v99;
                      v96 -= 8;
                    }
                    while (v97 != v98);
                    float v97 = v131;
                  }
                  uint64_t v131 = (b2Contact **)v96;
                  float32x2_t v132 = v91;
                  v133[0] = &v95[8 * v94];
                  if (v97) {
                    operator delete(v97);
                  }
                }
                else
                {
                  *float32x2_t v132 = (b2Contact *)v71;
                  float32x4_t v91 = v90 + 1;
                }
                float32x2_t v132 = v91;
                __int16 v100 = *(_WORD *)(v72 + 24);
                if ((v100 & 1) == 0)
                {
                  *(_WORD *)(v72 + 24) = v100 | 1;
                  if (*(_DWORD *)(v72 + 20)) {
                    b2Body::SetAwake((b2Body *)v72, 1);
                  }
                  float v101 = v128;
                  char v102 = v129;
                  uint64_t v103 = (v129 - v128) >> 3;
                  *(_DWORD *)(v72 + 28) = v103;
                  if (v102 >= v130)
                  {
                    if ((unint64_t)(v103 + 1) >> 61) {
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v105 = v130 - v101;
                    uint64_t v106 = v105 >> 2;
                    if (v105 >> 2 <= (unint64_t)(v103 + 1)) {
                      uint64_t v106 = v103 + 1;
                    }
                    if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v107 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v107 = v106;
                    }
                    if (v107) {
                      float v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v107);
                    }
                    else {
                      float v108 = 0;
                    }
                    uint64_t v109 = &v108[8 * v103];
                    *(void *)uint64_t v109 = v72;
                    float v104 = v109 + 8;
                    float32x2_t v111 = v128;
                    float32x2_t v110 = v129;
                    if (v129 != v128)
                    {
                      do
                      {
                        uint64_t v112 = *((void *)v110 - 1);
                        v110 -= 8;
                        *((void *)v109 - 1) = v112;
                        v109 -= 8;
                      }
                      while (v110 != v111);
                      float32x2_t v110 = v128;
                    }
                    float v128 = v109;
                    float v129 = v104;
                    int16x8_t v130 = &v108[8 * v107];
                    if (v110) {
                      operator delete(v110);
                    }
                  }
                  else
                  {
                    *(void *)char v102 = v72;
                    float v104 = v102 + 8;
                  }
                  float v129 = v104;
                }
              }
              else
              {
                *(_DWORD *)(v72 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v137;
                long long v85 = v136;
                *(_OWORD *)(v72 + 80) = v135;
                *(_OWORD *)(v72 + 96) = v85;
                *(_OWORD *)(v72 + 64) = v134;
                __float2 v86 = __sincosf_stret(*(float *)(v72 + 108));
                *(__float2 *)(v72 + 40) = v86;
                float v87 = *(float *)(v72 + 64);
                float v88 = *(float *)(v72 + 68);
                float v89 = *(float *)(v72 + 100) - (float)((float)(v86.__cosval * v88) + (float)(v86.__sinval * v87));
                *(float *)(v72 + 3b2DynamicTree::~b2DynamicTree(this + 2) = *(float *)(v72 + 96)
                                     - (float)((float)(v86.__cosval * v87) - (float)(v86.__sinval * v88));
                *(float *)(v72 + 36) = v89;
              }
            }
          }
        }
      }
    }
    char v67 = 0;
    uint64_t v66 = 1;
  }
  while ((v68 & 1) != 0);
  float v113 = 1.0 / (float)((float)(1.0 - v125) * *(float *)a2);
  *(float *)&long long v134 = (float)(1.0 - v125) * *(float *)a2;
  *((float *)&v134 + 1) = v113;
  int v114 = *(_DWORD *)(a2 + 12);
  DWORD2(v134) = 1065353216;
  HIDWORD(v134) = v114;
  LODWORD(v135) = 20;
  BYTE4(v135) = 0;
  b2Island::SolveTOI(v127, &v134, *(_DWORD *)(v7 + 28), *(_DWORD *)(v121 + 28), *((float *)v2 + 64));
  float v115 = v128;
  float v116 = v129;
  while (v115 != v116)
  {
    uint64_t v117 = *(void *)v115;
    *(_WORD *)(v117 + 24) = *(_WORD *)(*(void *)v115 + 24) & 0xFFFE;
    if (*(_DWORD *)(v117 + 20) == 2)
    {
      b2Body::SynchronizeFixtures((b2Body *)v117);
      for (uint64_t k = *(void *)(v117 + 200); k; uint64_t k = *(void *)(k + 24))
        *(_DWORD *)(*(void *)(k + 8) + 12) &= 0xFFFFFFDE;
    }
    v115 += 8;
  }
  b2ContactManager::FindNewContacts((b2Body *)v2);
  char v5 = v120;
  if (!v2[246]) {
    goto LABEL_124;
  }
  v2[247] = 0;
LABEL_128:
  b2Island::~b2Island((b2Island *)v127);
}

void sub_21357D50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  b2Island::~b2Island((b2Island *)va);
  _Unwind_Resume(a1);
}

void b2World::Step(b2World *this, float a2, int a3, int a4)
{
  float v6 = a2;
  uint64_t v8 = (float *)((char *)this + 102936);
  *((double *)this + 12899) = *((double *)this + 12899) + a2;
  unsigned int v9 = *((_DWORD *)this + 25734);
  if (v9)
  {
    b2ContactManager::FindNewContacts((b2Body *)((char *)this + 102944));
    unsigned int v9 = *(_DWORD *)v8 & 0xFFFFFFFE;
  }
  *(_DWORD *)uint64_t v8 = v9 | 2;
  HIDWORD(v13) = a3;
  int v14 = a4;
  float v10 = 1.0 / v6;
  if (v6 <= 0.0) {
    float v10 = 0.0;
  }
  *(void *)&long long v13 = __PAIR64__(LODWORD(v10), LODWORD(v6));
  *((float *)&v13 + b2DynamicTree::~b2DynamicTree(this + 2) = v8[62] * v6;
  char v15 = *((unsigned char *)v8 + 252);
  b2ContactManager::Collide((b2ContactManager *)((char *)this + 102944));
  if (*((unsigned char *)v8 + 255) && v6 > 0.0)
  {
    PKCMechanics::Solve((uint64_t)this + 103224, &v13);
    b2World::Solve((b2StackAllocator *)this, &v13);
    LODWORD(v6) = v13;
  }
  if (*((unsigned char *)v8 + 253) && v6 > 0.0)
  {
    b2World::SolveTOI((b2ContactListener **)this, (uint64_t)&v13);
    LODWORD(v6) = v13;
  }
  if (v6 > 0.0) {
    v8[62] = *((float *)&v13 + 1);
  }
  int v11 = *(_DWORD *)v8;
  if ((*(_DWORD *)v8 & 4) != 0)
  {
    for (uint64_t i = *((void *)v8 + 24); i; uint64_t i = *(void *)(i + 168))
    {
      *(void *)(i + 144) = 0;
      *(_DWORD *)(i + 140) = 0;
    }
  }
  *(_DWORD *)uint64_t v8 = v11 & 0xFFFFFFFD;
}

b2World *b2World::ClearForces(b2World *this)
{
  for (uint64_t i = *((void *)this + 12891); i; uint64_t i = *(void *)(i + 168))
  {
    *(void *)(i + 144) = 0;
    *(_DWORD *)(i + 140) = 0;
  }
  return this;
}

uint64_t b2World::QueryAABB(uint64_t a1, uint64_t a2, float *a3)
{
  v7[0] = a1 + 102944;
  v7[1] = a2;
  b2DynamicTree::Query<b2WorldQueryWrapper>((int *)(a1 + 102960), (uint64_t)v7, a3);
  return PKCMechanics::QueryAABB(a1 + 103224, a2, a3);
}

uint64_t b2World::RayCast(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v11[0] = a1 + 102944;
  v11[1] = a2;
  int v10 = 1065353216;
  uint64_t v7 = *a4;
  v9[0] = *a3;
  v9[1] = v7;
  b2DynamicTree::RayCast<b2WorldRayCastWrapper>((int *)(a1 + 102960), (uint64_t)v11, (float *)v9);
  return PKCMechanics::QueryAABB(a1 + 103224, a2, a3);
}

void b2World::DrawShape(uint64_t a1, uint64_t a2, b2Transform *a3, QuadTreeNode *a4)
{
  uint64_t v4 = *(void *)(a2 + 32);
  switch(*(_DWORD *)(v4 + 8))
  {
    case 0:
      float var0 = a3->var1.var0;
      float var1 = a3->var1.var1;
      float v11 = *(float *)(v4 + 16);
      float v10 = *(float *)(v4 + 20);
      float v12 = *(float *)(v4 + 12);
      float y = a3->var0.y;
      *(float *)&__p = a3->var0.x + (float)((float)(var1 * v11) - (float)(var0 * v10));
      *((float *)&__p + 1) = (float)((float)(var1 * v10) + (float)(var0 * v11)) + y;
      *(float *)&uint64_t v39 = var1 - (float)(var0 * 0.0);
      *((float *)&v39 + 1) = var0 + (float)(var1 * 0.0);
      (*(void (**)(void, void **, void **, QuadTreeNode *, float))(**(void **)(a1 + 103176) + 40))(*(void *)(a1 + 103176), &__p, &v39, a4, v12);
      break;
    case 1:
      float v17 = a3->var1.var0;
      float v16 = a3->var1.var1;
      float v18 = *(float *)(v4 + 16);
      float v19 = *(float *)(v4 + 20);
      float x = a3->var0.x;
      float v21 = a3->var0.y;
      *(float *)&__p = a3->var0.x + (float)((float)(v16 * v18) - (float)(v17 * v19));
      *((float *)&__p + 1) = (float)((float)(v16 * v19) + (float)(v17 * v18)) + v21;
      float v22 = *(float *)(v4 + 24);
      float v23 = *(float *)(v4 + 28);
      *(float *)&uint64_t v39 = x + (float)((float)(v16 * v22) - (float)(v17 * v23));
      *((float *)&v39 + 1) = v21 + (float)((float)(v16 * v23) + (float)(v17 * v22));
      (*(void (**)(void, void **, void **, QuadTreeNode *))(**(void **)(a1 + 103176) + 48))(*(void *)(a1 + 103176), &__p, &v39, a4);
      break;
    case 2:
      uint64_t v24 = *(void *)(v4 + 24) - *(void *)(v4 + 16);
      __p = 0;
      unint64_t v37 = 0;
      uint64_t v38 = 0;
      std::vector<b2Vec2>::resize((uint64_t)&__p, (int)(v24 >> 3));
      long long v25 = __p;
      if ((int)((unint64_t)v24 >> 3) >= 1)
      {
        uint64_t v26 = ((unint64_t)v24 >> 3);
        float v27 = (float *)(*(void *)(v4 + 16) + 4);
        float v28 = (float32x2_t *)__p;
        do
        {
          b2Rot v29 = a3->var1;
          float32x2_t v30 = (float32x2_t)vrev64_s32((int32x2_t)v29);
          v29.float var0 = -v29.var0;
          *v28++ = vadd_f32((float32x2_t)a3->var0, vmla_n_f32(vmul_n_f32((float32x2_t)v29, *v27), v30, *(v27 - 1)));
          v27 += 2;
          --v26;
        }
        while (v26);
      }
      (*(void (**)(void, void *))(**(void **)(a1 + 103176) + 24))(*(void *)(a1 + 103176), v25);
      if (__p)
      {
        unint64_t v37 = __p;
        operator delete(__p);
      }
      break;
    case 3:
      float v31 = *(float **)(v4 + 16);
      unint64_t v32 = *(void *)(v4 + 24) - (void)v31;
      __p = (void *)__PAIR64__((float)((float)(a3->var1.var1 * v31[1]) + (float)(a3->var1.var0 * *v31)) + a3->var0.y, a3->var0.x + (float)((float)(a3->var1.var1 * *v31) - (float)(a3->var1.var0 * v31[1])));
      if ((int)(v32 >> 3) >= 2)
      {
        float v33 = (void *)(a1 + 103176);
        float v34 = v31 + 3;
        uint64_t v35 = (v32 >> 3) - 1;
        do
        {
          uint64_t v39 = (void *)__PAIR64__((float)((float)(a3->var1.var1 * *v34) + (float)(a3->var1.var0 * *(v34 - 1))) + a3->var0.y, a3->var0.x + (float)((float)(a3->var1.var1 * *(v34 - 1)) - (float)(a3->var1.var0 * *v34)));
          (*(void (**)(void, void **, void **, QuadTreeNode *))(*(void *)*v33 + 48))(*v33, &__p, &v39, a4);
          __p = v39;
          v34 += 2;
          --v35;
        }
        while (v35);
      }
      break;
    case 4:
      int v14 = *(b2Draw **)(a1 + 103176);
      char v15 = **(QuadTree ***)(v4 + 16);
      drawQuadtree((float *)&a3->var0, v14, v15, a4);
      break;
    default:
      return;
  }
}

void sub_21357DAD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float *drawQuadtree(float *result, b2Draw *a2, QuadTree *a3, QuadTreeNode *a4)
{
  float v6 = (const b2Transform *)result;
  uint64_t v7 = *(QuadTree **)a3;
  if (v7) {
    goto LABEL_2;
  }
  if (!*((void *)a3 + 1) && !*((void *)a3 + 2) && !*((void *)a3 + 3))
  {
    float v9 = result[2];
    float v8 = result[3];
    float v10 = *((float *)a3 + 10);
    float v11 = *((float *)a3 + 11);
    float v12 = *((float *)a3 + 8);
    float v13 = *((float *)a3 + 9);
    float v14 = (float)(v8 * v12) - (float)(v9 * v10);
    float v15 = (float)(v10 * v8) + (float)(v9 * v12);
    float v16 = *result;
    float v17 = result[1];
    v24[0] = *result + v14;
    v24[1] = v15 + v17;
    v23[0] = v16 + (float)((float)(v8 * v13) - (float)(v9 * v11));
    v23[1] = v17 + (float)((float)(v8 * v11) + (float)(v9 * v13));
    uint64_t v21 = 0x3F80000000000000;
    int v22 = 0;
    __n128 result = (float *)(*(uint64_t (**)(b2Draw *, float *, float *, uint64_t *))(*(void *)a2 + 48))(a2, v24, v23, &v21);
    uint64_t v7 = *(QuadTree **)a3;
    if (*(void *)a3) {
LABEL_2:
    }
      __n128 result = (float *)drawQuadtree(v6, a2, v7, a4);
  }
  float v18 = (QuadTree *)*((void *)a3 + 1);
  if (v18) {
    __n128 result = (float *)drawQuadtree(v6, a2, v18, a4);
  }
  float v19 = (QuadTree *)*((void *)a3 + 2);
  if (v19) {
    __n128 result = (float *)drawQuadtree(v6, a2, v19, a4);
  }
  float32x2_t v20 = (QuadTree *)*((void *)a3 + 3);
  if (v20) {
    return (float *)drawQuadtree(v6, a2, v20, a4);
  }
  return result;
}

void b2World::DrawJoint(b2World *this, b2Joint *a2)
{
  b2Vec2 var0 = a2->var6->var8.var0;
  b2Vec2 v17 = a2->var7->var8.var0;
  b2Vec2 v18 = var0;
  v16[0] = ((float (*)(b2Joint *))*a2->var0)(a2);
  v16[1] = v5;
  v15[0] = (*((float (**)(b2Joint *))a2->var0 + 1))(a2);
  v15[1] = v6;
  uint64_t v13 = 0x3F4CCCCD3F000000;
  int v14 = 1061997773;
  int var1 = a2->var1;
  if (var1 != 5)
  {
    if (var1 == 4)
    {
      v12[0] = b2PulleyJoint::GetGroundAnchorA((b2PulleyJoint *)a2);
      v12[1] = v8;
      v11[0] = b2PulleyJoint::GetGroundAnchorB((b2PulleyJoint *)a2);
      v11[1] = v9;
      (*(void (**)(void, _DWORD *, _DWORD *, uint64_t *))(**((void **)this + 12897) + 48))(*((void *)this + 12897), v12, v16, &v13);
      (*(void (**)(void, _DWORD *, _DWORD *, uint64_t *))(**((void **)this + 12897) + 48))(*((void *)this + 12897), v11, v15, &v13);
      float v10 = *(void (**)(void))(**((void **)this + 12897) + 48);
    }
    else
    {
      if (var1 != 3)
      {
        (*(void (**)(void, b2Vec2 *, _DWORD *, uint64_t *))(**((void **)this + 12897) + 48))(*((void *)this + 12897), &v18, v16, &v13);
        (*(void (**)(void, _DWORD *, _DWORD *, uint64_t *))(**((void **)this + 12897) + 48))(*((void *)this + 12897), v16, v15, &v13);
      }
      float v10 = *(void (**)(void))(**((void **)this + 12897) + 48);
    }
    v10();
  }
}

void b2World::DrawDebugData(b2World *this)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v2 = (char *)this + 102968;
  uint64_t v3 = (b2Draw *)*((void *)this + 12897);
  if (v3)
  {
    char Flags = b2Draw::GetFlags(v3);
    if ((Flags & 2) != 0)
    {
      for (uint64_t i = (b2Joint *)*((void *)v2 + 21); i; uint64_t i = i->var3)
        b2World::DrawJoint(this, i);
    }
    if ((Flags & 4) != 0)
    {
      uint64_t v30 = 0x3E99999A3F666666;
      int v31 = 1063675494;
      for (uint64_t j = *((void *)v2 + 20); j; uint64_t j = *(void *)(j + 168))
      {
        if (b2Body::IsActive((b2Body *)j))
        {
          for (uint64_t k = *(void **)(j + 176); k; uint64_t k = (void *)k[2])
          {
            uint64_t v8 = k[6];
            uint64_t v9 = k[7];
            while (v8 != v9)
            {
              unsigned int v10 = *(_DWORD *)(v8 + 24);
              if ((v10 & 0x80000000) != 0 || *((_DWORD *)v2 + 3) <= (signed int)v10) {
                b2ContactManager::FindNewContacts();
              }
              uint64_t v11 = *(void *)v2 + 48 * v10;
              unsigned int v12 = *(_DWORD *)(v11 + 12);
              *(void *)&long long v13 = *(void *)(v11 + 4);
              *((void *)&v13 + 1) = v13;
              *(_DWORD *)unint64_t v32 = *(_DWORD *)v11;
              *(_OWORD *)&v32[4] = v13;
              unsigned int v33 = v12;
              __p = (void *)__PAIR64__(v12, *(unsigned int *)v32);
              (*(void (**)(void, unsigned char *, uint64_t, uint64_t *))(**((void **)v2 + 26) + 16))(*((void *)v2 + 26), v32, 4, &v30);
              v8 += 32;
            }
          }
        }
      }
    }
    if ((Flags & 0x10) != 0)
    {
      for (uint64_t m = *((void *)v2 + 20); m; uint64_t m = *(void *)(m + 168))
      {
        *(_OWORD *)unint64_t v32 = *(_OWORD *)(m + 32);
        *(void *)unint64_t v32 = *(void *)(m + 96);
        (*(void (**)(void, unsigned char *))(**((void **)v2 + 26) + 56))(*((void *)v2 + 26), v32);
      }
    }
    if ((Flags & 0x20) != 0)
    {
      int v27 = 0;
      (*(void (**)(void, float32x2_t *, float *, int *))(**((void **)v2 + 26) + 64))(*((void *)v2 + 26), &v29, v28, &v27);
      if (v27 >= 1)
      {
        PKCAether::Evaluator::Evaluator((PKCAether::Evaluator *)v32, *((const PKCAether **)v2 + 23));
        uint64_t v30 = 0x3E99999A3F666666;
        int v31 = 1050253722;
        float v17 = v28[0] - v29.f32[0];
        if ((float)(v28[0] - v29.f32[0]) > 0.0)
        {
          float v18 = v28[1] - v29.f32[1];
          v15.i64[0] = 0;
          float32x4_t v23 = v15;
          float v19 = v17 / (float)v27;
          do
          {
            if (v18 > 0.0)
            {
              v15.i64[0] = 0;
              do
              {
                float32x4_t v24 = v15;
                *(float32x2_t *)v15.f32 = vadd_f32((float32x2_t)__PAIR64__(v15.u32[0], v23.u32[0]), v29);
                uint64_t v26 = v15.i64[0];
                v15.i32[2] = 0;
                LODWORD(v16) = 1.0;
                PKCAether::Evaluator::evalForce((float32x4_t *)v32, -1, 0.0, v15, (__n128)0, v16, 0.0, *((double *)v2 + 28));
                uint64_t v20 = *((void *)v2 + 26);
                uint64_t v25 = v21;
                (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v20 + 72))(v20, &v26, &v25, &v30);
                float32x4_t v15 = v24;
                v15.f32[0] = v19 + v24.f32[0];
              }
              while ((float)(v19 + v24.f32[0]) < v18);
            }
            float32x4_t v22 = v23;
            v22.f32[0] = v19 + v23.f32[0];
            float32x4_t v23 = v22;
          }
          while (v22.f32[0] < v17);
        }
        if (__p)
        {
          uint64_t v35 = __p;
          operator delete(__p);
        }
        uint64_t v30 = (uint64_t)v32;
        std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v30);
      }
    }
  }
}

void sub_21357E1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void **b2DynamicTree::Query<b2WorldQueryWrapper>(int *a1, uint64_t a2, float *a3)
{
  float32x4_t v24 = v25;
  int v6 = *a1;
  int v27 = 256;
  v25[0] = v6;
  int v7 = 1;
  for (uint64_t i = v25; ; uint64_t i = v24)
  {
    while (1)
    {
      uint64_t v9 = (v7 - 1);
      int v26 = v9;
      int v10 = i[v9];
      if (v10 != -1)
      {
        uint64_t v11 = *((void *)a1 + 1);
        unsigned int v12 = (float *)(v11 + 48 * v10);
        if ((float)(*a3 - v12[2]) <= 0.0
          && (float)(a3[1] - v12[3]) <= 0.0
          && (float)(*v12 - a3[2]) <= 0.0
          && (float)(v12[1] - a3[3]) <= 0.0)
        {
          break;
        }
      }
LABEL_23:
      int v7 = v9;
      if ((int)v9 < 1) {
        return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v24);
      }
    }
    uint64_t v13 = v11 + 48 * v10;
    int v16 = *(_DWORD *)(v13 + 36);
    float32x4_t v15 = (_DWORD *)(v13 + 36);
    int v14 = v16;
    if (v16 != -1)
    {
      int v17 = v27;
      if (v7 <= v27)
      {
        i[v9] = v14;
      }
      else
      {
        v27 *= 2;
        float32x4_t v24 = b2Alloc(8 * v17);
        memcpy(v24, i, 4 * v26);
        if (i != v25) {
          b2Free(i);
        }
        uint64_t i = v24;
        v24[v26] = *v15;
      }
      int v21 = v26 + 1;
      int v26 = v21;
      int v22 = v27;
      if (v21 >= v27)
      {
        v27 *= 2;
        float32x4_t v24 = b2Alloc(8 * v22);
        memcpy(v24, i, 4 * v26);
        if (i != v25) {
          b2Free(i);
        }
        uint64_t i = v24;
        int v21 = v26;
      }
      i[v21] = *(_DWORD *)(v11 + 48 * v10 + 40);
      LODWORD(v9) = ++v26;
      goto LABEL_23;
    }
    FixtureProxfloat y = b2ContactManager::GetFixtureProxy(*(b2ContactManager **)a2, i[v9]);
    int v19 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 8) + 16))(*(void *)(a2 + 8), *(void *)(FixtureProxy + 16));
    int v7 = v26;
    int v20 = v26 > 0 ? v19 : 0;
    if (v20 != 1) {
      break;
    }
  }
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v24);
}

void sub_21357E41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t b2ContactManager::GetFixtureProxy(b2ContactManager *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 9) <= (signed int)a2) {
    b2ContactManager::FindNewContacts();
  }
  return *(void *)(*((void *)this + 3) + 48 * a2 + 16);
}

void **b2DynamicTree::RayCast<b2WorldRayCastWrapper>(int *a1, uint64_t a2, float *a3)
{
  float v3 = *a3;
  float v4 = a3[1];
  float v5 = a3[2] - *a3;
  float v6 = a3[3] - v4;
  float v7 = (float)(v6 * v6) + (float)(v5 * v5);
  if (v7 <= 0.0) {
    b2DynamicTree::RayCast<b2WorldRayCastWrapper>();
  }
  float v11 = sqrtf(v7);
  float v12 = a3[2] - *a3;
  float v13 = a3[3] - v4;
  if (v11 >= 0.00000011921)
  {
    float v12 = v5 * (float)(1.0 / v11);
    float v13 = v6 * (float)(1.0 / v11);
  }
  float v14 = -v13;
  if (v13 >= 0.0) {
    float v15 = v13;
  }
  else {
    float v15 = -v13;
  }
  if (v12 <= 0.0) {
    float v16 = -v12;
  }
  else {
    float v16 = v12;
  }
  float v51 = a3[3] - v4;
  float v52 = a3[2] - *a3;
  float v53 = a3[4];
  float v17 = v3 + (float)(v5 * v53);
  float v18 = v4 + (float)(v6 * v53);
  if (v3 >= v17) {
    float v19 = v3 + (float)(v5 * v53);
  }
  else {
    float v19 = *a3;
  }
  if (v3 <= v17) {
    float v20 = v3 + (float)(v5 * v53);
  }
  else {
    float v20 = *a3;
  }
  if (v4 >= v18) {
    float v21 = v4 + (float)(v6 * v53);
  }
  else {
    float v21 = a3[1];
  }
  if (v4 <= v18) {
    float v22 = v4 + (float)(v6 * v53);
  }
  else {
    float v22 = a3[1];
  }
  unint64_t v59 = v60;
  int v23 = *a1;
  int v62 = 256;
  v60[0] = v23;
  int v24 = 1;
  float v55 = v15;
  float v56 = v12;
  float v54 = v16;
  do
  {
    uint64_t v25 = (v24 - 1);
    int v61 = v25;
    int v26 = v59;
    signed int v27 = v59[v25];
    if (v27 == -1) {
      goto LABEL_58;
    }
    uint64_t v28 = *((void *)a1 + 1);
    float32x2_t v29 = (float *)(v28 + 48 * v27);
    float v30 = v29[2];
    if ((float)(v19 - v30) > 0.0) {
      goto LABEL_58;
    }
    float v31 = v29[3];
    if ((float)(v21 - v31) > 0.0) {
      goto LABEL_58;
    }
    float v32 = *v29;
    if ((float)(*v29 - v20) > 0.0) {
      goto LABEL_58;
    }
    float v33 = v29[1];
    if ((float)(v33 - v22) > 0.0) {
      goto LABEL_58;
    }
    float v34 = (float)(v30 + v32) * 0.5;
    float v35 = (float)(v31 + v33) * 0.5;
    float v36 = (float)(v30 - v32) * 0.5;
    float v37 = (float)(v31 - v33) * 0.5;
    float v38 = (float)(v12 * (float)(v4 - v35)) + (float)(v14 * (float)(v3 - v34));
    float v39 = -v38;
    if (v38 > 0.0) {
      float v39 = v38;
    }
    if ((float)(v39 - (float)((float)(v16 * v37) + (float)(v15 * v36))) > 0.0) {
      goto LABEL_58;
    }
    uint64_t v40 = v28 + 48 * v27;
    int v43 = *(_DWORD *)(v40 + 36);
    long long v42 = (_DWORD *)(v40 + 36);
    int v41 = v43;
    if (v43 != -1)
    {
      int v44 = v62;
      if (v24 <= v62)
      {
        v59[v25] = v41;
      }
      else
      {
        v62 *= 2;
        unint64_t v59 = b2Alloc(8 * v44);
        memcpy(v59, v26, 4 * v61);
        if (v26 != v60) {
          b2Free(v26);
        }
        int v26 = v59;
        v59[v61] = *v42;
        float v15 = v55;
        float v12 = v56;
        float v16 = v54;
      }
      int v48 = v61 + 1;
      int v61 = v48;
      int v49 = v62;
      if (v48 >= v62)
      {
        v62 *= 2;
        unint64_t v59 = b2Alloc(8 * v49);
        memcpy(v59, v26, 4 * v61);
        if (v26 != v60) {
          b2Free(v26);
        }
        int v26 = v59;
        int v48 = v61;
        float v15 = v55;
        float v12 = v56;
        float v16 = v54;
      }
      v26[v48] = *(_DWORD *)(v28 + 48 * v27 + 40);
      LODWORD(v25) = ++v61;
      goto LABEL_58;
    }
    long long v57 = *(_OWORD *)a3;
    float v58 = v53;
    float v45 = b2WorldRayCastWrapper::RayCastCallback(a2, (float32x2_t *)&v57, v27);
    float v15 = v55;
    float v12 = v56;
    float v16 = v54;
    if (v45 > 0.0)
    {
      float v46 = v3 + (float)(v52 * v45);
      float v47 = v4 + (float)(v51 * v45);
      if (v3 >= v46) {
        float v19 = v3 + (float)(v52 * v45);
      }
      else {
        float v19 = v3;
      }
      if (v3 <= v46) {
        float v20 = v3 + (float)(v52 * v45);
      }
      else {
        float v20 = v3;
      }
      if (v4 >= v47) {
        float v21 = v4 + (float)(v51 * v45);
      }
      else {
        float v21 = v4;
      }
      if (v4 <= v47) {
        float v22 = v4 + (float)(v51 * v45);
      }
      else {
        float v22 = v4;
      }
      float v53 = v45;
    }
    if (v45 == 0.0) {
      break;
    }
    LODWORD(v25) = v61;
LABEL_58:
    int v24 = v25;
  }
  while ((int)v25 >= 1);
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v59);
}

void sub_21357E7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  b2GrowableStack<int,256>::~b2GrowableStack((void **)va);
  _Unwind_Resume(a1);
}

float32_t b2WorldRayCastWrapper::RayCastCallback(uint64_t a1, float32x2_t *a2, unsigned int a3)
{
  FixtureProxfloat y = b2ContactManager::GetFixtureProxy(*(b2ContactManager **)a1, a3);
  uint64_t v6 = *(void *)(FixtureProxy + 16);
  if (!(*(unsigned int (**)(void, unsigned char *, float32x2_t *, uint64_t, void))(**(void **)(v6 + 32) + 48))(*(void *)(v6 + 32), v9, a2, *(void *)(v6 + 24) + 32, *(unsigned int *)(FixtureProxy + 28)))return a2[2].f32[0]; {
  float32x2_t v8 = vadd_f32(vmul_n_f32(*a2, 1.0 - v10), vmul_n_f32(a2[1], v10));
  }
  (*(void (**)(void, uint64_t, float32x2_t *, unsigned char *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), v6, &v8, v9);
  return result;
}

void PKCLineSeg::updateRelativeTheta(PKCLineSeg *this, double a2, double a3)
{
  float v7 = *(float *)this;
  float v6 = *((float *)this + 1);
  double v8 = atan2(v6 - a3, *(float *)this - a2) + 6.28318531;
  *((double *)this + b2DynamicTree::~b2DynamicTree(this + 2) = v8;
  float v10 = *((float *)this + 2);
  float v9 = *((float *)this + 3);
  double v11 = atan2(v9 - a3, v10 - a2) + 6.28318531;
  *((double *)this + 3) = v11;
  float v12 = a2;
  float v13 = a3;
  if ((float)((float)((float)(v7 - v12) * (float)(v9 - v13)) - (float)((float)(v6 - v13) * (float)(v10 - v12))) > 0.0)
  {
    *((double *)this + b2DynamicTree::~b2DynamicTree(this + 2) = v11;
    *((double *)this + 3) = v8;
    *(float *)this = v10;
    *((float *)this + 1) = v9;
    *((float *)this + b2DynamicTree::~b2DynamicTree(this + 2) = v7;
    *((float *)this + 3) = v6;
  }
}

float *PKCLineSeg::mergeColinear(float *this, const PKCLineSeg *a2)
{
  float v2 = *(float *)a2;
  if (vabds_f32(*this, *(float *)a2) < 0.00011921 && vabds_f32(this[1], *((float *)a2 + 1)) < 0.00011921)
  {
    *(void *)this = *((void *)a2 + 1);
    return this;
  }
  float v3 = *((float *)a2 + 2);
  if (vabds_f32(*this, v3) < 0.00011921 && vabds_f32(this[1], *((float *)a2 + 3)) < 0.00011921)
  {
    int v4 = *((_DWORD *)a2 + 1);
    *this = v2;
    *((_DWORD *)this + 1) = v4;
    return this;
  }
  if (vabds_f32(this[2], v2) >= 0.00011921)
  {
    float v5 = *((float *)a2 + 1);
  }
  else
  {
    float v5 = *((float *)a2 + 1);
    if (vabds_f32(this[3], v5) < 0.00011921)
    {
      int v6 = *((_DWORD *)a2 + 3);
      this[2] = v3;
      *((_DWORD *)this + 3) = v6;
      return this;
    }
  }
  this[2] = v2;
  this[3] = v5;
  return this;
}

uint64_t PKCLineSeg::intersect(PKCLineSeg *this, const PKCLineSeg *a2)
{
  return lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v4, &v3);
}

uint64_t lineIntersection(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double *a9, double *a10)
{
  if (vabdd_f64(a1, a3) < 0.00011920929 && vabdd_f64(a2, a4) < 0.00011920929) {
    return 0;
  }
  if (vabdd_f64(a5, a7) < 0.00011920929 && vabdd_f64(a6, a8) < 0.00011920929) {
    return 0;
  }
  if (vabdd_f64(a1, a5) < 0.00011920929 && vabdd_f64(a2, a6) < 0.00011920929) {
    return 0;
  }
  if (vabdd_f64(a3, a5) < 0.00011920929 && vabdd_f64(a4, a6) < 0.00011920929) {
    return 0;
  }
  if (vabdd_f64(a1, a7) < 0.00011920929 && vabdd_f64(a2, a8) < 0.00011920929) {
    return 0;
  }
  if (vabdd_f64(a3, a7) < 0.00011920929 && vabdd_f64(a4, a8) < 0.00011920929) {
    return 0;
  }
  double v10 = a3 - a1;
  double v11 = a4 - a2;
  double v12 = a5 - a1;
  double v13 = a6 - a2;
  double v14 = a7 - a1;
  double v15 = a8 - a2;
  double v16 = sqrt(v11 * v11 + v10 * v10);
  double v17 = v10 / v16;
  double v18 = v11 / v16;
  double v19 = v13 * v17 - v12 * (v11 / v16);
  double v20 = v15 * v17 - v14 * (v11 / v16);
  if (v19 < 0.0 && v20 < 0.0) {
    return 0;
  }
  if (v19 >= 0.0 && v20 >= 0.0) {
    return 0;
  }
  double v21 = v15 * v18 + v14 * v17 + v20 * (v13 * v18 + v12 * v17 - (v15 * v18 + v14 * v17)) / (v20 - v19);
  if (v21 < 0.00011920929 || v21 + 0.00011920929 > v16) {
    return 0;
  }
  *a9 = a1 + v21 * v17;
  *a10 = a2 + v21 * v18;
  return 1;
}

float PKCLineSeg::clipAgainst(PKCLineSeg *this, const PKCLineSeg *a2)
{
  double v5 = 0.0;
  double v6 = 0.0;
  if (lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v6, &v5))
  {
    float result = v6;
    float v4 = v5;
    *((float *)this + b2DynamicTree::~b2DynamicTree(this + 2) = result;
    *((float *)this + 3) = v4;
  }
  return result;
}

uint64_t PKCLineSeg::split(PKCLineSeg *this, PKCLineSeg *a2, PKCLineSeg **a3, PKCLineSeg **a4)
{
  uint64_t v8 = 0;
  double v9 = 0.0;
  uint64_t v6 = lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v9, (double *)&v8);
  if (v6) {
    operator new();
  }
  *a3 = 0;
  *a4 = 0;
  return v6;
}

void b2ChainAndCircleContact::Create(b2ChainAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_21357EDCC(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

uint64_t b2ChainAndCircleContact::Destroy(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void b2ChainAndCircleContact::b2ChainAndCircleContact(b2ChainAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *double v5 = &unk_26C3F3D90;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 3) {
    b2ChainAndCircleContact::b2ChainAndCircleContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8)) {
    b2ChainAndCircleContact::b2ChainAndCircleContact();
  }
}

uint64_t b2ChainAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 32);
  v10[0] = &unk_26C3F3338;
  v10[1] = 0x3C1374BC00000001;
  v10[4] = 0;
  v10[5] = 0;
  __int16 v11 = 0;
  b2ChainShape::GetChildEdge(v8, (b2EdgeShape *)v10, *(_DWORD *)(a1 + 96));
  return b2CollideEdgeAndCircle(a2, (uint64_t)v10, a3, *(float **)(*(void *)(a1 + 88) + 32), a4);
}

void b2ChainAndCircleContact::~b2ChainAndCircleContact(b2ChainAndCircleContact *this)
{
}

void b2ChainAndPolygonContact::Create(b2ChainAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_21357EFA8(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2ChainAndPolygonContact::b2ChainAndPolygonContact(b2ChainAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *double v5 = &unk_26C3F3DE0;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 3) {
    b2ChainAndPolygonContact::b2ChainAndPolygonContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 2) {
    b2ChainAndPolygonContact::b2ChainAndPolygonContact();
  }
}

void b2ChainAndPolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 80) + 32);
  v9[0] = (float32x2_t)&unk_26C3F3338;
  v9[1] = (float32x2_t)0x3C1374BC00000001;
  v9[4] = 0;
  v9[5] = 0;
  __int16 v10 = 0;
  b2ChainShape::GetChildEdge(v8, (b2EdgeShape *)v9, *(_DWORD *)(a1 + 96));
  b2CollideEdgeAndPolygon(a2, v9, a3, *(void *)(*(void *)(a1 + 88) + 32), a4);
}

void b2ChainAndPolygonContact::~b2ChainAndPolygonContact(b2ChainAndPolygonContact *this)
{
}

void b2CircleContact::Create(b2CircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_21357F144(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2CircleContact::b2CircleContact(b2CircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *double v3 = &unk_26C3F3888;
  if (*(_DWORD *)(*(void *)(v3[10] + 32) + 8)) {
    b2CircleContact::b2CircleContact();
  }
  if (*(_DWORD *)(*(void *)(v3[11] + 32) + 8)) {
    b2CircleContact::b2CircleContact();
  }
}

uint64_t b2CircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollideCircles(a2, *(float **)(*(void *)(a1 + 80) + 32), a3, *(float **)(*(void *)(a1 + 88) + 32), a4);
}

void b2CircleContact::~b2CircleContact(b2CircleContact *this)
{
}

void b2Contact::InitializeRegisters(b2Contact *this)
{
  b2Contact::s_registers = (uint64_t)b2CircleContact::Create;
  byte_2677EC2B0 = 1;
  qword_2677EC348 = (uint64_t)b2PolygonAndCircleContact::Create;
  byte_2677EC350 = 1;
  qword_2677EC2C8 = (uint64_t)b2PolygonAndCircleContact::Create;
  byte_2677EC2D0 = 0;
  qword_2677EC368 = (uint64_t)b2PolygonContact::Create;
  byte_2677EC370 = 1;
  qword_2677EC2F8 = (uint64_t)b2EdgeAndCircleContact::Create;
  byte_2677EC300 = 1;
  qword_2677EC2B8 = (uint64_t)b2EdgeAndCircleContact::Create;
  byte_2677EC2C0 = 0;
  qword_2677EC318 = (uint64_t)b2EdgeAndPolygonContact::Create;
  byte_2677EC320 = 1;
  qword_2677EC358 = (uint64_t)b2EdgeAndPolygonContact::Create;
  byte_2677EC360 = 0;
  qword_2677EC398 = (uint64_t)b2ChainAndCircleContact::Create;
  byte_2677EC3A0 = 1;
  qword_2677EC2D8 = (uint64_t)b2ChainAndCircleContact::Create;
  byte_2677EC2E0 = 0;
  qword_2677EC3B8 = (uint64_t)b2ChainAndPolygonContact::Create;
  byte_2677EC3C0 = 1;
  qword_2677EC378 = (uint64_t)b2ChainAndPolygonContact::Create;
  byte_2677EC380 = 0;
  qword_2677EC418 = (uint64_t)b2QuadtreeAndChainContact::Create;
  byte_2677EC420 = 1;
  qword_2677EC3D8 = (uint64_t)b2QuadtreeAndChainContact::Create;
  byte_2677EC3E0 = 0;
  qword_2677EC2E8 = (uint64_t)b2QuadtreeAndCircleContact::Create;
  byte_2677EC2F0 = 1;
  qword_2677EC3E8 = (uint64_t)b2QuadtreeAndCircleContact::Create;
  byte_2677EC3F0 = 0;
  qword_2677EC3F8 = (uint64_t)b2QuadtreeAndEdgeContact::Create;
  byte_2677EC400 = 1;
  qword_2677EC338 = (uint64_t)b2QuadtreeAndEdgeContact::Create;
  byte_2677EC340 = 0;
  qword_2677EC408 = (uint64_t)b2QuadtreeAndPolygonContact::Create;
  byte_2677EC410 = 1;
  qword_2677EC388 = (uint64_t)b2QuadtreeAndPolygonContact::Create;
  byte_2677EC390 = 0;
  qword_2677EC428 = (uint64_t)b2QuadtreeAndQuadtreeContact::Create;
  byte_2677EC430 = 1;
}

uint64_t b2Contact::AddType(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 >= 5) {
    b2Contact::AddType();
  }
  if (a3 >= 5) {
    b2Contact::AddType();
  }
  double v3 = &b2Contact::s_registers[10 * a2 + 2 * a3];
  *double v3 = result;
  *((unsigned char *)v3 + 8) = 1;
  if (a2 != a3)
  {
    float v4 = &b2Contact::s_registers[10 * a3 + 2 * a2];
    uint64_t *v4 = result;
    *((unsigned char *)v4 + 8) = 0;
  }
  return result;
}

uint64_t b2Contact::Create(b2Contact *this, b2Fixture *a2, b2Contact *a3, b2Fixture *a4)
{
  if (!b2Contact::s_initialized)
  {
    b2Contact::InitializeRegisters(this);
    b2Contact::s_initialized = 1;
  }
  unsigned int v8 = *(_DWORD *)(*((void *)this + 4) + 8);
  if (v8 >= 5) {
    b2Contact::Create();
  }
  uint64_t v9 = *(unsigned int *)(*((void *)a3 + 4) + 8);
  if (v9 >= 5) {
    b2Contact::Create();
  }
  __int16 v10 = (uint64_t (*)(b2Contact *, b2Fixture *, b2Contact *, b2Fixture *))b2Contact::s_registers[10 * v8 + 2 * v9];
  if (!v10) {
    return 0;
  }
  if (LOBYTE(b2Contact::s_registers[10 * v8 + 1 + 2 * v9]))
  {
    __int16 v11 = this;
    double v12 = a2;
    double v13 = a3;
    double v14 = a4;
  }
  else
  {
    __int16 v11 = a3;
    double v12 = a4;
    double v13 = this;
    double v14 = a2;
  }
  uint64_t result = v10(v11, v12, v13, v14);
  if (result) {
    *(_WORD *)(result + 8) = 0;
  }
  return result;
}

uint64_t b2Contact::Destroy(b2Contact *this, b2Contact *a2)
{
  if (!b2Contact::s_initialized) {
    b2Contact::Destroy();
  }
  if (*((int *)this + 41) >= 1)
  {
    b2Body::SetAwake(*(b2Body **)(*((void *)this + 10) + 24), 1);
    b2Body::SetAwake(*(b2Body **)(*((void *)this + 11) + 24), 1);
  }
  double v3 = *(uint64_t (**)(b2Contact *))(*(void *)this + 16);

  return v3(this);
}

void b2Contact::b2Contact(b2Contact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  *((_DWORD *)this + 41) = 0;
  *((_DWORD *)this + 4b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  float v5 = *((float *)a2 + 11);
  float v6 = *((float *)a2 + 10) * *((float *)a4 + 10);
  if (v5 <= *((float *)a4 + 11)) {
    float v5 = *((float *)a4 + 11);
  }
  *(void *)this = &unk_26C3F4030;
  *((_DWORD *)this + 3) = 4;
  *((void *)this + 10) = a2;
  *((void *)this + 11) = a4;
  *((_DWORD *)this + 24) = a3;
  *((_DWORD *)this + 25) = a5;
  *((float *)this + 44) = sqrtf(v6);
  *((float *)this + 45) = v5;
}

b2Body *b2Contact::Update(b2Contact *this, b2ContactListener *a2)
{
  float v4 = (char *)this + 104;
  long long v5 = *(_OWORD *)((char *)this + 120);
  long long v22 = *(_OWORD *)((char *)this + 104);
  v23[0] = v5;
  long long v6 = *(_OWORD *)((char *)this + 152);
  v23[1] = *(_OWORD *)((char *)this + 136);
  long long v24 = v6;
  int v7 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 3) = v7 | 4;
  unsigned int v8 = v7 & 2;
  uint64_t v9 = *(b2Body **)(*((void *)this + 10) + 24);
  __int16 v10 = *(b2Body **)(*((void *)this + 11) + 24);
  uint64_t result = (b2Body *)(**(uint64_t (***)(b2Contact *, char *, uint64_t, uint64_t))this)(this, (char *)this + 104, (uint64_t)&v9->var8, (uint64_t)&v10->var8);
  uint64_t v12 = *((unsigned int *)this + 41);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = HIDWORD(v24);
    do
    {
      double v15 = &v4[20 * v13];
      *((_DWORD *)v15 + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
      *((_DWORD *)v15 + 3) = 0;
      double v16 = v15 + 8;
      if ((int)v14 >= 1)
      {
        uint64_t v17 = v14;
        double v18 = v23;
        while (*v18 != *((_DWORD *)v16 + 2))
        {
          v18 += 5;
          if (!--v17) {
            goto LABEL_9;
          }
        }
        *(void *)double v16 = *((void *)v18 - 1);
      }
LABEL_9:
      ++v13;
    }
    while (v13 != v12);
  }
  if ((int)v12 > 0 != v8 >> 1)
  {
    b2Body::SetAwake(v9, 1);
    uint64_t result = b2Body::SetAwake(v10, 1);
  }
  *((_DWORD *)this + 3) = *((_DWORD *)this + 3) & 0xFFFFFFFD | (2 * ((int)v12 > 0));
  if ((v10->var2 & v9->var4) != 0 || (v9->var2 & v10->var4) != 0)
  {
    if (!v8 && a2 && (int)v12 >= 1)
    {
      *((unsigned char *)this + 8) = 1;
      double v19 = *(uint64_t (**)(b2ContactListener *, b2Contact *))(*(void *)a2 + 16);
      double v20 = a2;
      double v21 = this;
      return (b2Body *)v19(v20, v21);
    }
    if (v8 && a2 && (int)v12 <= 0)
    {
      *((unsigned char *)this + 9) = 1;
      double v19 = *(uint64_t (**)(b2ContactListener *, b2Contact *))(*(void *)a2 + 32);
      double v20 = a2;
      double v21 = this;
      return (b2Body *)v19(v20, v21);
    }
  }
  return result;
}

uint64_t b2ContactSolver::b2ContactSolver(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 3b2DynamicTree::~b2DynamicTree(this + 2) = a4;
  long long v6 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v6;
  int v7 = (b2StackAllocator *)*((void *)a2 + 6);
  *(void *)(a1 + 56) = v7;
  int v8 = *((_DWORD *)a2 + 6);
  *(_DWORD *)(a1 + 80) = v8;
  *(void *)(a1 + 64) = b2StackAllocator::Allocate(v7, 88 * v8);
  *(void *)(a1 + 7b2DynamicTree::~b2DynamicTree(this + 2) = b2StackAllocator::Allocate(*(b2StackAllocator **)(a1 + 56), 152 * *(_DWORD *)(a1 + 80));
  *(_OWORD *)(a1 + 40) = a2[2];
  *(_DWORD *)(a1 + 84) = *((_DWORD *)a2 + 14);
  if (*(int *)(a1 + 80) >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(float32x2_t **)(**(void **)(a1 + 32) + 8 * v11);
      uint64_t v13 = v12[20].u32[1];
      if ((int)v13 <= 0) {
        b2ContactSolver::b2ContactSolver();
      }
      uint64_t v14 = 0;
      float32x2_t v16 = v12[10];
      float32x2_t v15 = v12[11];
      uint64_t v17 = *(float32x2_t **)(*(void *)&v15 + 24);
      __int32 v18 = *(_DWORD *)(*(void *)(*(void *)&v15 + 32) + 12);
      double v19 = *(float32x2_t **)(*(void *)&v16 + 24);
      __int32 v20 = *(_DWORD *)(*(void *)(*(void *)&v16 + 32) + 12);
      uint64_t v21 = *(void *)(a1 + 72);
      float32x2_t v22 = v12[22];
      uint64_t v23 = v21 + 152 * v11;
      int v24 = v17[3].i32[1];
      *(_DWORD *)(v23 + 11b2DynamicTree::~b2DynamicTree(this + 2) = v19[3].i32[1];
      *(_DWORD *)(v23 + 116) = v24;
      int v25 = v17[26].i32[1];
      *(_DWORD *)(v23 + 120) = v19[26].i32[1];
      *(_DWORD *)(v23 + 124) = v25;
      LODWORD(v26) = v19[28].i32[0];
      DWORD1(v26) = v17[28].i32[0];
      *((float32x2_t *)&v26 + 1) = v22;
      *(_OWORD *)(v23 + 128) = v26;
      *(_DWORD *)(v23 + 144) = v13;
      *(_DWORD *)(v23 + 148) = v11;
      *(_OWORD *)(v23 + 80) = 0uLL;
      *(_OWORD *)(v23 + 96) = 0uLL;
      uint64_t v27 = *(void *)(a1 + 64);
      uint64_t v28 = (float32x2_t *)(v27 + 88 * v11);
      __int32 v29 = v17[3].i32[1];
      v28[4].i32[0] = v19[3].i32[1];
      v28[4].i32[1] = v29;
      LODWORD(v26) = v17[26].i32[1];
      v28[5].i32[0] = v19[26].i32[1];
      v28[5].i32[1] = v26;
      v28[6] = v19[8];
      v28[7] = v17[8];
      LODWORD(v26) = v17[28].i32[0];
      v28[8].i32[0] = v19[28].i32[0];
      v28[8].i32[1] = v26;
      float v28[2] = v12[18];
      v28[3] = v12[19];
      v28[10].i32[1] = v13;
      v28[9].i32[1] = v20;
      v28[10].i32[0] = v18;
      v28[9].i32[0] = v12[20].i32[0];
      uint64_t v30 = v21 + v10;
      float v31 = (void *)(v27 + v9);
      float v32 = v12 + 14;
      uint64_t v33 = 36 * v13;
      do
      {
        if (*(unsigned char *)(a1 + 20)) {
          float32x2_t v34 = vmul_n_f32(*v32, *(float *)(a1 + 8));
        }
        else {
          float32x2_t v34 = 0;
        }
        float v35 = (float32x2_t *)(v30 + v14);
        v35[2] = v34;
        v35[3] = 0;
        v35[4].i32[0] = 0;
        float32x2_t *v35 = 0;
        v35[1] = 0;
        *v31++ = v32[-1];
        v14 += 36;
        float v32 = (float32x2_t *)((char *)v32 + 20);
      }
      while (v33 != v14);
      ++v11;
      v10 += 152;
      v9 += 88;
    }
    while (v11 < *(int *)(a1 + 80));
  }
  return a1;
}

void b2ContactSolver::~b2ContactSolver(b2ContactSolver *this)
{
}

void b2ContactSolver::InitializeVelocityConstraints(b2ContactSolver *this)
{
  if (*((int *)this + 20) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 32;
    __asm { FMOV            V19.2S, #1.0 }
    float32x2_t v61 = _D19;
    do
    {
      uint64_t v9 = *((void *)this + 9);
      uint64_t v10 = v9 + 152 * v2;
      uint64_t v11 = *(void *)(**((void **)this + 4) + 8 * *(int *)(v10 + 148));
      if (*(int *)(v11 + 164) <= 0) {
        b2ContactSolver::InitializeVelocityConstraints();
      }
      uint64_t v12 = *(int *)(v10 + 112);
      uint64_t v13 = *(int *)(v10 + 116);
      float v62 = *(float *)(v10 + 124);
      float v63 = *(float *)(v10 + 120);
      float v74 = *(float *)(v10 + 128);
      float v73 = *(float *)(v10 + 132);
      uint64_t v14 = *((void *)this + 5);
      uint64_t v15 = *((void *)this + 6);
      float32x2_t v16 = (float *)(v14 + 16 * v12);
      float v18 = *v16;
      float v17 = v16[1];
      double v19 = (float *)(v15 + 16 * v12);
      float v64 = v19[1];
      float v65 = *v19;
      float v20 = v19[3];
      uint64_t v21 = (float *)(v14 + 16 * v13);
      float v23 = *v21;
      float v22 = v21[1];
      int v24 = (float *)(v15 + 16 * v13);
      float v25 = *v24;
      float v26 = v24[1];
      float v27 = v24[3];
      uint64_t v28 = v11 + 104;
      uint64_t v29 = *((void *)this + 8) + 88 * v2;
      float v69 = *(float *)(v29 + 56);
      float v70 = *(float *)(v29 + 60);
      float v68 = *(float *)(v29 + 52);
      float v66 = v21[3];
      float v67 = *(float *)(v29 + 48);
      float v71 = *(float *)(v29 + 76);
      float v72 = *(float *)(v29 + 80);
      __float2 v30 = __sincosf_stret(v16[3]);
      __float2 v80 = v30;
      __float2 v78 = __sincosf_stret(v66);
      v79[0] = v18 - (float)((float)(v30.__cosval * v67) - (float)(v30.__sinval * v68));
      v79[1] = v17 - (float)((float)(v30.__cosval * v68) + (float)(v30.__sinval * v67));
      v77[0] = v23 - (float)((float)(v78.__cosval * v69) - (float)(v78.__sinval * v70));
      v77[1] = v22 - (float)((float)(v78.__cosval * v70) + (float)(v78.__sinval * v69));
      b2WorldManifold::Initialize((uint64_t)&v75, v28, v79, v77, v71, v72);
      float v32 = (int32x2_t *)(v9 + 152 * v2);
      v32[9] = v75;
      uint64_t v33 = v32 + 9;
      int v34 = v33[9].i32[0];
      if (v34 >= 1)
      {
        uint64_t v35 = v9 + 152 * v2;
        float v36 = (float *)(v35 + 76);
        *(float *)v31.i32 = v63 + v62;
        float v37 = (float *)(v35 + 140);
        float32x2_t v38 = (float32x2_t)vdup_lane_s32(v31, 0);
        float v39 = (float *)(v9 + v3);
        uint64_t v40 = (float *)&v76;
        uint64_t v41 = v33[9].u32[0];
        do
        {
          float v42 = *(v40 - 1) - v18;
          float v43 = *v40 - v17;
          *(v39 - 8) = v42;
          *(v39 - 7) = v43;
          float v44 = *(v40 - 1) - v23;
          float v45 = *v40 - v22;
          *(v39 - 6) = v44;
          *(v39 - 5) = v45;
          float32x2_t v46 = (float32x2_t)*v33;
          v47.i32[0] = vdup_lane_s32(*v33, 1).u32[0];
          v47.f32[1] = -COERCE_FLOAT(*v33);
          float32x2_t v48 = vmla_n_f32(vmul_n_f32((float32x2_t)*v33, -v43), v47, v42);
          float32x2_t v49 = vmla_n_f32(vmul_n_f32((float32x2_t)*v33, -v45), v47, v44);
          float32x2_t v50 = vmla_f32(vmla_f32(v38, v48, vmul_n_f32(v48, v74)), v49, vmul_n_f32(v49, v73));
          *((int8x8_t *)v39 - 1) = vand_s8((int8x8_t)vdiv_f32(v61, v50), (int8x8_t)vcgtz_f32(v50));
          *float v39 = 0.0;
          float v51 = vmlas_n_f32(vmuls_lane_f32((float)((float)(v26 + (float)(v27 * v44)) - v64) - (float)(v20 * v42), v46, 1), (float)(v20 * v43) + (float)((float)(v25 - (float)(v27 * v45)) - v65), v46.f32[0]);
          if (v51 < (float)-*((float *)this + 21)) {
            *float v39 = -(float)(*v37 * v51);
          }
          v40 += 2;
          v39 += 9;
          --v41;
        }
        while (v41);
        if (v34 == 2)
        {
          float v52 = (float)(*(float *)v10 * *v36) - (float)(*(float *)(v10 + 4) * v46.f32[0]);
          float v53 = (float)(*(float *)(v10 + 8) * *v36) - (float)(*(float *)(v10 + 12) * v46.f32[0]);
          float v54 = (float)(*(float *)(v10 + 36) * *v36) - (float)(*(float *)(v10 + 40) * v46.f32[0]);
          float v55 = (float)(*(float *)(v10 + 44) * *v36) - (float)(*(float *)(v10 + 48) * v46.f32[0]);
          float v56 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v52) * v52)) + (float)((float)(v73 * v53) * v53);
          float v57 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v54) * v54)) + (float)((float)(v73 * v55) * v55);
          *(float *)v31.i32 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v52) * v54))
                            + (float)((float)(v73 * v53) * v55);
          float v58 = (float)(v56 * v57) - (float)(*(float *)v31.i32 * *(float *)v31.i32);
          if ((float)(v56 * v56) >= (float)(v58 * 1000.0))
          {
            v33[9].i32[0] = 1;
          }
          else
          {
            uint64_t v59 = v9 + 152 * v2;
            *(float *)(v59 + 96) = v56;
            *(int32x2_t *)(v59 + 100) = vdup_lane_s32(v31, 0);
            *(float *)(v59 + 108) = v57;
            if (v58 != 0.0) {
              float v58 = 1.0 / v58;
            }
            float v60 = -(float)(v58 * *(float *)v31.i32);
            *(float *)(v59 + 80) = v57 * v58;
            *(float *)(v59 + 84) = v60;
            *(float *)(v59 + 88) = v60;
            *(float *)(v59 + 9b2DynamicTree::~b2DynamicTree(this + 2) = v56 * v58;
          }
        }
      }
      ++v2;
      v3 += 152;
    }
    while (v2 < *((int *)this + 20));
  }
}

uint64_t b2ContactSolver::WarmStart(uint64_t this)
{
  if (*(int *)(this + 80) >= 1)
  {
    uint64_t v1 = 0;
    uint64_t v2 = 12;
    do
    {
      uint64_t v3 = *(void *)(this + 72);
      uint64_t v4 = v3 + 152 * v1;
      uint64_t v6 = *(int *)(v4 + 112);
      uint64_t v5 = *(int *)(v4 + 116);
      uint64_t v7 = **(void **)(this + 24);
      uint64_t v8 = *(void *)(v7 + 8 * v6);
      uint64_t v9 = *(void *)(v7 + 8 * v5);
      int v10 = *(_DWORD *)(v8 + 8);
      int v11 = *(_DWORD *)(v9 + 8) & *(_DWORD *)(v8 + 12);
      int v12 = v10 & *(_DWORD *)(v9 + 12);
      if (v11 | v12)
      {
        uint64_t v13 = (float32x2_t *)(v3 + 152 * v1);
        uint64_t v14 = v13[18].u32[0];
        uint64_t v15 = *(void *)(this + 48);
        float32x2_t v16 = (float32x2_t *)(v15 + 16 * v6);
        float32x2_t v17 = *v16;
        float v18 = v16[1].f32[1];
        double v19 = (float32x2_t *)(v15 + 16 * v5);
        float v20 = v19[1].f32[1];
        float32x2_t v21 = *v19;
        if ((int)v14 >= 1)
        {
          float v22 = v13[16].f32[1];
          float32x2_t v23 = v13[9];
          uint64_t v24 = v3 + 152 * v1;
          float v25 = (const float *)(v24 + 124);
          float v26 = (const float *)(v24 + 120);
          float32x2_t v27 = vld1_dup_f32(v25);
          float32x2_t v28 = vld1_dup_f32(v26);
          uint64_t v29 = v3 + v2;
          do
          {
            _S18 = *(_DWORD *)(v29 - 12);
            _S20 = *(_DWORD *)(v29 - 4);
            _D21 = vmul_n_f32(v23, *(float *)(v29 + 4));
            float32x2_t v33 = (float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32(v23, *(float *)(v29 + 8)));
            _D23.i32[0] = vadd_f32(_D21, v33).u32[0];
            _D23.i32[1] = vsub_f32(_D21, v33).i32[1];
            __asm { FMLA            S19, S18, V17.S[1] }
            float v18 = v18 + (float)((float)-*(float *)(v24 + 128) * _S19);
            float32x2_t v17 = vsub_f32(v17, vmul_f32(v28, _D23));
            __asm { FMLA            S21, S20, V17.S[1] }
            float v20 = v20 + (float)(v22 * _D21.f32[0]);
            float32x2_t v21 = vadd_f32(v21, vmul_f32(v27, _D23));
            v29 += 36;
            --v14;
          }
          while (v14);
        }
        if (v11)
        {
          *float32x2_t v16 = v17;
          v16[1].f32[1] = v18;
        }
        if (v12)
        {
          uint64_t v40 = *(void *)(this + 48) + 16 * v5;
          *(float32x2_t *)uint64_t v40 = v21;
          *(float *)(v40 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v20;
        }
      }
      ++v1;
      v2 += 152;
    }
    while (v1 < *(int *)(this + 80));
  }
  return this;
}

uint64_t b2ContactSolver::SolveVelocityConstraints(uint64_t this)
{
  if (*(int *)(this + 80) >= 1)
  {
    uint64_t v1 = 0;
    for (uint64_t i = 16; ; i += 152)
    {
      uint64_t v3 = *(void *)(this + 72);
      uint64_t v4 = v3 + 152 * v1;
      uint64_t v6 = *(int *)(v4 + 112);
      uint64_t v5 = *(int *)(v4 + 116);
      uint64_t v7 = **(void **)(this + 24);
      uint64_t v8 = *(void *)(v7 + 8 * v6);
      uint64_t v9 = *(void *)(v7 + 8 * v5);
      int v10 = *(_DWORD *)(v8 + 8);
      int v11 = *(_DWORD *)(v9 + 8) & *(_DWORD *)(v8 + 12);
      int v12 = v10 & *(_DWORD *)(v9 + 12);
      if (v11 | v12) {
        break;
      }
LABEL_36:
      if (++v1 >= *(int *)(this + 80)) {
        return this;
      }
    }
    uint64_t v13 = v3 + 152 * v1;
    float v15 = *(float *)(v13 + 120);
    float v14 = *(float *)(v13 + 124);
    float v17 = *(float *)(v13 + 128);
    float v16 = *(float *)(v13 + 132);
    uint64_t v18 = *(unsigned int *)(v13 + 144);
    uint64_t v19 = *(void *)(this + 48);
    float v20 = (float *)(v19 + 16 * v6);
    float v21 = *v20;
    float v22 = v20[1];
    float v23 = v20[3];
    uint64_t v24 = (float *)(v19 + 16 * v5);
    float v26 = *v24;
    float v25 = v24[1];
    float v27 = v24[3];
    float v29 = *(float *)(v13 + 72);
    float v28 = *(float *)(v13 + 76);
    if ((int)v18 >= 1)
    {
      float v30 = -v29;
      float v31 = *(float *)(v13 + 136);
      float v32 = -v17;
      float32x2_t v33 = (float *)(v3 + i);
      uint64_t v34 = v18;
      do
      {
        float v36 = *(v33 - 2);
        float v35 = *(v33 - 1);
        float v38 = *(v33 - 4);
        float v37 = *(v33 - 3);
        float v39 = v33[1];
        float v40 = v39
            - (float)(v33[3]
                    * (float)((float)((float)((float)((float)(v25 + (float)(v27 * v36)) - v22) - (float)(v23 * v38))
                                    * v30)
                            + (float)((float)((float)((float)(v26 - (float)(v27 * v35)) - v21) + (float)(v23 * v37))
                                    * v28)));
        if (v40 >= (float)(v31 * *v33)) {
          float v40 = v31 * *v33;
        }
        if (v40 < (float)-(float)(v31 * *v33)) {
          float v40 = -(float)(v31 * *v33);
        }
        float v41 = v40 - v39;
        v33[1] = v40;
        float v42 = v28 * (float)(v40 - v39);
        float v43 = v41 * v30;
        if (v11)
        {
          float v21 = v21 - (float)(v15 * v42);
          float v22 = v22 - (float)(v15 * v43);
          float v23 = v23 + (float)(v32 * (float)((float)(v38 * v43) - (float)(v37 * v42)));
        }
        if (v12)
        {
          float v26 = v26 + (float)(v14 * v42);
          float v25 = v25 + (float)(v14 * v43);
          float v27 = v27 + (float)(v16 * (float)((float)(v36 * v43) - (float)(v35 * v42)));
        }
        v33 += 9;
        --v34;
      }
      while (v34);
      if (v18 == 1)
      {
        float v45 = *(float *)(v4 + 8);
        float v44 = *(float *)(v4 + 12);
        float v47 = *(float *)v4;
        float v46 = *(float *)(v4 + 4);
        float v48 = *(float *)(v4 + 16);
        float v49 = fmaxf(v48- (float)(*(float *)(v4 + 24)* (float)((float)((float)(v28* (float)((float)((float)(v25 + (float)(v27 * v45)) - v22)- (float)(v23 * *(float *)v4)))+ (float)((float)((float)((float)(v26 - (float)(v27 * v44)) - v21)+ (float)(v23 * v46))* v29))- *(float *)(v4 + 32))), 0.0);
        *(float *)(v4 + 16) = v49;
        float v50 = v29 * (float)(v49 - v48);
        float v51 = v28 * (float)(v49 - v48);
        if (v11)
        {
          float v21 = v21 - (float)(v15 * v50);
          float v22 = v22 - (float)(v15 * v51);
          float v23 = v23 + (float)(v32 * (float)((float)(v47 * v51) - (float)(v46 * v50)));
        }
        if (v12)
        {
          float v26 = v26 + (float)(v14 * v50);
          float v25 = v25 + (float)(v14 * v51);
          float v27 = v27 + (float)(v16 * (float)((float)(v45 * v51) - (float)(v44 * v50)));
        }
        goto LABEL_32;
      }
    }
    float v52 = *(float *)(v4 + 16);
    if (v52 < 0.0 || (float v53 = *(float *)(v4 + 52), v53 < 0.0)) {
      b2ContactSolver::SolveVelocityConstraints();
    }
    float v54 = *(float *)(v4 + 8);
    float v55 = *(float *)(v4 + 12);
    float v56 = *(float *)v4;
    float v57 = *(float *)(v4 + 4);
    float v58 = *(float *)(v4 + 44);
    float v59 = *(float *)(v4 + 48);
    float v60 = *(float *)(v4 + 36);
    float v61 = *(float *)(v4 + 40);
    float v62 = (float *)(v3 + 152 * v1);
    float v63 = v62[26];
    float v64 = v62[25];
    float v65 = (float)((float)((float)(v28
                                * (float)((float)((float)(v25 + (float)(v27 * v54)) - v22) - (float)(v23 * *(float *)v4)))
                        + (float)((float)((float)((float)(v26 - (float)(v27 * v55)) - v21) + (float)(v23 * v57)) * v29))
                - *(float *)(v4 + 32))
        - (float)((float)(v53 * v63) + (float)(v62[24] * v52));
    float v66 = (float)((float)((float)(v28 * (float)((float)((float)(v25 + (float)(v27 * v58)) - v22) - (float)(v23 * v60)))
                        + (float)((float)((float)((float)(v26 - (float)(v27 * v59)) - v21) + (float)(v23 * v61)) * v29))
                - *(float *)(v4 + 68))
        - (float)((float)(v53 * v62[27]) + (float)(v64 * v52));
    float v67 = (float)(v62[22] * v66) + (float)(v62[20] * v65);
    if (v67 > 0.0 || (float v68 = (float)(v66 * v62[23]) + (float)(v62[21] * v65), v68 > 0.0))
    {
      float v75 = -(float)(*(float *)(v4 + 24) * v65);
      if (v75 < 0.0 || (float)(v66 + (float)(v64 * v75)) < 0.0)
      {
        float v82 = -(float)(*(float *)(v4 + 60) * v66);
        if (v82 >= 0.0 && (float)(v65 + (float)(v63 * v82)) >= 0.0)
        {
          float v83 = 0.0 - v52;
          float v84 = v82 - v53;
          float v85 = v29 * v83;
          float v86 = v28 * v83;
          float v87 = v29 * v84;
          float v88 = v28 * v84;
          float v21 = v21 - (float)(v15 * (float)(v85 + v87));
          float v22 = v22 - (float)(v15 * (float)(v86 + v88));
          float v23 = v23
              - (float)(v17
                      * (float)((float)((float)(v56 * v86) - (float)(v57 * v85))
                              + (float)((float)(v60 * v88) - (float)(v61 * v87))));
          float v26 = v26 + (float)(v14 * (float)(v85 + v87));
          float v25 = v25 + (float)(v14 * (float)(v86 + v88));
          float v27 = v27
              + (float)(v16
                      * (float)((float)((float)(v54 * v86) - (float)(v55 * v85))
                              + (float)((float)(v58 * v88) - (float)(v59 * v87))));
          *(_DWORD *)(v4 + 16) = 0;
          *(float *)(v4 + 5b2DynamicTree::~b2DynamicTree(this + 2) = v82;
          goto LABEL_32;
        }
        if (v65 < 0.0 || v66 < 0.0) {
          goto LABEL_32;
        }
        float v90 = 0.0 - v52;
        float v91 = 0.0 - v53;
        float v92 = v29 * v90;
        float v93 = v28 * v90;
        float v94 = v29 * v91;
        float v95 = v28 * v91;
        float v21 = v21 - (float)(v15 * (float)(v92 + v94));
        float v22 = v22 - (float)(v15 * (float)(v93 + v95));
        float v23 = v23
            - (float)(v17
                    * (float)((float)((float)(v56 * v93) - (float)(v57 * v92))
                            + (float)((float)(v60 * v95) - (float)(v61 * v94))));
        float v26 = v26 + (float)(v14 * (float)(v92 + v94));
        float v25 = v25 + (float)(v14 * (float)(v93 + v95));
        float v27 = v27
            + (float)(v16
                    * (float)((float)((float)(v54 * v93) - (float)(v55 * v92))
                            + (float)((float)(v58 * v95) - (float)(v59 * v94))));
        *(_DWORD *)(v4 + 16) = 0;
      }
      else
      {
        float v76 = v75 - v52;
        float v77 = 0.0 - v53;
        float v78 = v29 * v76;
        float v79 = v28 * v76;
        float v80 = v29 * v77;
        float v81 = v28 * v77;
        float v21 = v21 - (float)(v15 * (float)(v80 + v78));
        float v22 = v22 - (float)(v15 * (float)(v81 + v79));
        float v23 = v23
            - (float)(v17
                    * (float)((float)((float)(v60 * v81) - (float)(v61 * v80))
                            + (float)((float)(v56 * v79) - (float)(v57 * v78))));
        float v26 = v26 + (float)(v14 * (float)(v80 + v78));
        float v25 = v25 + (float)(v14 * (float)(v81 + v79));
        float v27 = v27
            + (float)(v16
                    * (float)((float)((float)(v58 * v81) - (float)(v59 * v80))
                            + (float)((float)(v54 * v79) - (float)(v55 * v78))));
        *(float *)(v4 + 16) = v75;
      }
      *(_DWORD *)(v4 + 5b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    }
    else
    {
      float v69 = (float)-v67 - v52;
      float v70 = (float)-v68 - v53;
      float v71 = v29 * v69;
      float v72 = v28 * v69;
      float v73 = v29 * v70;
      float v74 = v28 * v70;
      float v21 = v21 - (float)(v15 * (float)(v71 + v73));
      float v22 = v22 - (float)(v15 * (float)(v72 + v74));
      float v23 = v23
          - (float)(v17
                  * (float)((float)((float)(v56 * v72) - (float)(v57 * v71))
                          + (float)((float)(v60 * v74) - (float)(v61 * v73))));
      float v26 = v26 + (float)(v14 * (float)(v71 + v73));
      float v25 = v25 + (float)(v14 * (float)(v72 + v74));
      float v27 = v27
          + (float)(v16
                  * (float)((float)((float)(v54 * v72) - (float)(v55 * v71))
                          + (float)((float)(v58 * v74) - (float)(v59 * v73))));
      *(float *)(v4 + 16) = -v67;
      *(float *)(v4 + 5b2DynamicTree::~b2DynamicTree(this + 2) = -v68;
    }
LABEL_32:
    if (v11)
    {
      *float v20 = v21;
      v20[1] = v22;
      v20[3] = v23;
    }
    if (v12)
    {
      float v89 = (float *)(*(void *)(this + 48) + 16 * v5);
      float *v89 = v26;
      v89[1] = v25;
      v89[3] = v27;
    }
    goto LABEL_36;
  }
  return this;
}

uint64_t b2ContactSolver::StoreImpulses(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 80);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)(this + 72);
    uint64_t v4 = **(void **)(this + 32);
    uint64_t v5 = (uint64_t *)(v3 + 16);
    do
    {
      uint64_t v6 = v3 + 152 * v2;
      uint64_t v7 = *(unsigned int *)(v6 + 144);
      if ((int)v7 >= 1)
      {
        uint64_t v8 = (void *)(*(void *)(v4 + 8 * *(int *)(v6 + 148)) + 112);
        uint64_t v9 = v5;
        do
        {
          uint64_t v10 = *v9;
          uint64_t v9 = (uint64_t *)((char *)v9 + 36);
          *uint64_t v8 = v10;
          uint64_t v8 = (void *)((char *)v8 + 20);
          --v7;
        }
        while (v7);
      }
      ++v2;
      v5 += 19;
    }
    while (v2 != v1);
  }
  return this;
}

BOOL b2ContactSolver::SolvePositionConstraints(b2ContactSolver *this)
{
  if (*((int *)this + 20) < 1)
  {
    float v3 = 0.0;
  }
  else
  {
    uint64_t v2 = 0;
    float v3 = 0.0;
    do
    {
      uint64_t v4 = *((void *)this + 8) + 88 * v2;
      uint64_t v6 = *(int *)(v4 + 32);
      uint64_t v5 = *(int *)(v4 + 36);
      int v7 = *(_DWORD *)(v4 + 84);
      uint64_t v8 = *((void *)this + 5);
      uint64_t v9 = (float *)(v8 + 16 * v6);
      float v10 = *v9;
      float v11 = v9[1];
      float v12 = v9[3];
      uint64_t v13 = (float *)(v8 + 16 * v5);
      float v15 = *v13;
      float v14 = v13[1];
      float v46 = v13[3];
      if (v7 <= 0)
      {
        float v27 = (uint64_t *)*((void *)this + 3);
      }
      else
      {
        int v16 = 0;
        float v43 = *(float *)(v4 + 52);
        float v44 = *(float *)(v4 + 48);
        float v41 = *(float *)(v4 + 60);
        float v42 = *(float *)(v4 + 56);
        float v45 = *(float *)(v4 + 68);
        float v38 = *(float *)(v4 + 44);
        float v39 = *(float *)(v4 + 40);
        float v40 = *(float *)(v4 + 64);
        do
        {
          float v17 = v12;
          __float2 v18 = __sincosf_stret(v12);
          __float2 v56 = v18;
          __float2 v54 = __sincosf_stret(v46);
          v55[0] = v10 - (float)((float)(v18.__cosval * v44) - (float)(v18.__sinval * v43));
          v55[1] = v11 - (float)((float)(v43 * v18.__cosval) + (float)(v18.__sinval * v44));
          float v52 = v15 - (float)((float)(v54.__cosval * v42) - (float)(v54.__sinval * v41));
          float v53 = v14 - (float)((float)(v41 * v54.__cosval) + (float)(v54.__sinval * v42));
          b2PositionSolverManifold::Initialize(&v47, v4, v55, &v52, v16, v53);
          float v19 = v49 - v10;
          float v20 = v50 - v11;
          float v21 = v49 - v15;
          float v22 = v50 - v14;
          if (v3 >= v51) {
            float v3 = v51;
          }
          float v23 = (float)((float)(v39 + v38)
                      + (float)((float)(v40 * (float)((float)(v19 * v48) - (float)(v20 * v47)))
                              * (float)((float)(v19 * v48) - (float)(v20 * v47))))
              + (float)((float)(v45 * (float)((float)(v21 * v48) - (float)(v22 * v47)))
                      * (float)((float)(v21 * v48) - (float)(v22 * v47)));
          float v24 = 0.0;
          if (v23 > 0.0)
          {
            float v25 = fminf((float)(v51 + 0.0045) * 0.2, 0.0);
            if (v25 < -0.2) {
              float v25 = -0.2;
            }
            float v24 = (float)-v25 / v23;
          }
          float v26 = v47 * v24;
          float v27 = (uint64_t *)*((void *)this + 3);
          uint64_t v28 = *(void *)(*v27 + 8 * v6);
          float v29 = v48 * v24;
          uint64_t v30 = *(void *)(*v27 + 8 * v5);
          if ((*(_DWORD *)(v30 + 8) & *(_DWORD *)(v28 + 12)) != 0)
          {
            float v10 = v10 - (float)(v39 * v26);
            float v11 = v11 - (float)(v39 * v29);
            float v12 = v17 + (float)((float)-v40 * (float)((float)(v26 * (float)-v20) + (float)(v19 * v29)));
          }
          else
          {
            float v12 = v17;
          }
          if ((*(_DWORD *)(v28 + 8) & *(_DWORD *)(v30 + 12)) != 0)
          {
            float v15 = v15 + (float)(v38 * v26);
            float v14 = v14 + (float)(v38 * v29);
            float v46 = v46 + (float)(v45 * (float)((float)(v26 * (float)-v22) + (float)(v21 * v29)));
          }
          ++v16;
        }
        while (v7 != v16);
      }
      uint64_t v31 = *v27;
      uint64_t v32 = *(void *)(*v27 + 8 * v6);
      uint64_t v33 = *(void *)(v31 + 8 * v5);
      if ((*(_DWORD *)(v33 + 8) & *(_DWORD *)(v32 + 12)) != 0)
      {
        uint64_t v34 = (float *)(*((void *)this + 5) + 16 * v6);
        *uint64_t v34 = v10;
        v34[1] = v11;
        v34[3] = v12;
        uint64_t v35 = **((void **)this + 3);
        uint64_t v33 = *(void *)(v35 + 8 * v5);
        uint64_t v32 = *(void *)(v35 + 8 * v6);
      }
      if ((*(_DWORD *)(v32 + 8) & *(_DWORD *)(v33 + 12)) != 0)
      {
        float v36 = (float *)(*((void *)this + 5) + 16 * v5);
        *float v36 = v15;
        v36[1] = v14;
        v36[3] = v46;
      }
      ++v2;
    }
    while (v2 < *((int *)this + 20));
  }
  return v3 >= -0.0135;
}

float b2PositionSolverManifold::Initialize(float *a1, uint64_t a2, float *a3, float *a4, int a5, float result)
{
  if (*(int *)(a2 + 84) <= 0) {
    b2PositionSolverManifold::Initialize();
  }
  switch(*(_DWORD *)(a2 + 72))
  {
    case 0:
    case 3:
      float v7 = a3[2];
      float v6 = a3[3];
      float v8 = *(float *)(a2 + 24);
      float v9 = *(float *)(a2 + 28);
      float v10 = *a3 + (float)((float)(v6 * v8) - (float)(v7 * v9));
      float v11 = (float)((float)(v6 * v9) + (float)(v7 * v8)) + a3[1];
      float v13 = a4[2];
      float v12 = a4[3];
      float v14 = *(float *)(a2 + 4);
      float v15 = *a4 + (float)((float)(v12 * *(float *)a2) - (float)(v13 * v14));
      float v16 = (float)((float)(v12 * v14) + (float)(v13 * *(float *)a2)) + a4[1];
      float v17 = v15 - v10;
      float v18 = v16 - v11;
      *a1 = v15 - v10;
      a1[1] = v16 - v11;
      float v19 = (float)(v18 * v18) + (float)(v17 * v17);
      float v20 = sqrtf(v19);
      if (v20 >= 0.00000011921)
      {
        float v21 = 1.0 / v20;
        float v22 = v17 * (float)(1.0 / v20);
        float v23 = v18 * v21;
        *a1 = v22;
        a1[1] = v23;
        float v19 = (float)(v18 * v23) + (float)(v17 * v22);
      }
      a1[2] = (float)(v10 + v15) * 0.5;
      a1[3] = (float)(v11 + v16) * 0.5;
      uint64_t result = (float)(v19 - *(float *)(a2 + 76)) - *(float *)(a2 + 80);
      a1[4] = result;
      break;
    case 1:
      float v25 = a3[2];
      float v24 = a3[3];
      float v26 = *(float *)(a2 + 16);
      float v27 = *(float *)(a2 + 20);
      float v28 = (float)(v24 * v26) - (float)(v25 * v27);
      float v29 = (float)(v24 * v27) + (float)(v25 * v26);
      *a1 = v28;
      a1[1] = v29;
      float v31 = a3[2];
      float v30 = a3[3];
      float v32 = *(float *)(a2 + 24);
      float v33 = *(float *)(a2 + 28);
      float v34 = *a3 + (float)((float)(v30 * v32) - (float)(v31 * v33));
      float v35 = (float)((float)(v30 * v33) + (float)(v31 * v32)) + a3[1];
      float v36 = (float *)(a2 + 8 * a5);
      float v38 = a4[2];
      float v37 = a4[3];
      float v39 = v36[1];
      float v40 = *a4 + (float)((float)(v37 * *v36) - (float)(v38 * v39));
      float v41 = (float)((float)(v37 * v39) + (float)(v38 * *v36)) + a4[1];
      uint64_t result = (float)((float)((float)(v29 * (float)(v41 - v35)) + (float)((float)(v40 - v34) * v28))
                     - *(float *)(a2 + 76))
             - *(float *)(a2 + 80);
      a1[3] = v41;
      a1[4] = result;
      a1[2] = v40;
      break;
    case 2:
      float v43 = a4[2];
      float v42 = a4[3];
      float v44 = *(float *)(a2 + 16);
      float v45 = *(float *)(a2 + 20);
      float v46 = (float)(v42 * v44) - (float)(v43 * v45);
      float v47 = (float)(v42 * v45) + (float)(v43 * v44);
      *a1 = v46;
      a1[1] = v47;
      float v49 = a4[2];
      float v48 = a4[3];
      float v50 = *(float *)(a2 + 24);
      float v51 = *(float *)(a2 + 28);
      float v52 = *a4 + (float)((float)(v48 * v50) - (float)(v49 * v51));
      float v53 = (float)((float)(v48 * v51) + (float)(v49 * v50)) + a4[1];
      __float2 v54 = (float *)(a2 + 8 * a5);
      float v56 = a3[2];
      float v55 = a3[3];
      float v57 = v54[1];
      float v58 = *a3 + (float)((float)(v55 * *v54) - (float)(v56 * v57));
      float v59 = (float)((float)(v55 * v57) + (float)(v56 * *v54)) + a3[1];
      float v60 = (float)((float)((float)(v47 * (float)(v59 - v53)) + (float)((float)(v58 - v52) * v46)) - *(float *)(a2 + 76))
          - *(float *)(a2 + 80);
      a1[3] = v59;
      a1[4] = v60;
      uint64_t result = -(float)((float)(v42 * v44) - (float)(v43 * v45));
      *a1 = result;
      a1[1] = -v47;
      a1[2] = v58;
      break;
    default:
      return result;
  }
  return result;
}

BOOL b2ContactSolver::SolveTOIPositionConstraints(b2ContactSolver *this, int a2, int a3)
{
  if (*((int *)this + 20) < 1)
  {
    float v56 = 0.0;
  }
  else
  {
    uint64_t v5 = 0;
    float v56 = 0.0;
    int v48 = a3;
    do
    {
      uint64_t v6 = *((void *)this + 8);
      uint64_t v7 = v6 + 88 * v5;
      int v8 = *(_DWORD *)(v7 + 32);
      BOOL v9 = v8 == a2 || v8 == a3;
      float v50 = 0.0;
      float v54 = 0.0;
      if (v9)
      {
        uint64_t v10 = v6 + 88 * v5;
        float v50 = *(float *)(v10 + 40);
        float v54 = *(float *)(v10 + 64);
      }
      uint64_t v11 = *(int *)(v7 + 36);
      float v49 = 0.0;
      BOOL v12 = v11 == a2 || v11 == a3;
      float v55 = 0.0;
      if (v12)
      {
        uint64_t v13 = v6 + 88 * v5;
        float v49 = *(float *)(v13 + 44);
        float v55 = *(float *)(v13 + 68);
      }
      uint64_t v14 = v8;
      int v15 = *(_DWORD *)(v7 + 84);
      uint64_t v16 = *((void *)this + 5);
      float v17 = (float *)(v16 + 16 * v14);
      float v18 = *v17;
      float v19 = v17[1];
      float v20 = v17[3];
      float v21 = (float *)(v16 + 16 * v11);
      float v22 = *v21;
      float v23 = v21[1];
      float v57 = v21[3];
      if (v15 <= 0)
      {
        float v37 = (uint64_t *)*((void *)this + 3);
      }
      else
      {
        int v24 = 0;
        float v52 = *(float *)(v7 + 52);
        float v53 = *(float *)(v7 + 48);
        float v25 = *(float *)(v7 + 60);
        float v51 = *(float *)(v7 + 56);
        do
        {
          float v26 = v20;
          __float2 v27 = __sincosf_stret(v20);
          __float2 v67 = v27;
          __float2 v65 = __sincosf_stret(v57);
          v66[0] = v18 - (float)((float)(v27.__cosval * v53) - (float)(v27.__sinval * v52));
          v66[1] = v19 - (float)((float)(v52 * v27.__cosval) + (float)(v27.__sinval * v53));
          float v63 = v22 - (float)((float)(v65.__cosval * v51) - (float)(v65.__sinval * v25));
          float v64 = v23 - (float)((float)(v25 * v65.__cosval) + (float)(v65.__sinval * v51));
          b2PositionSolverManifold::Initialize(&v58, v7, v66, &v63, v24, v64);
          float v28 = v60 - v18;
          float v29 = v61 - v19;
          float v30 = v60 - v22;
          float v31 = v61 - v23;
          float v32 = v56;
          if (v56 >= v62) {
            float v32 = v62;
          }
          float v56 = v32;
          float v33 = (float)((float)(v50 + v49)
                      + (float)((float)(v54 * (float)((float)(v28 * v59) - (float)(v29 * v58)))
                              * (float)((float)(v28 * v59) - (float)(v29 * v58))))
              + (float)((float)(v55 * (float)((float)(v30 * v59) - (float)(v31 * v58)))
                      * (float)((float)(v30 * v59) - (float)(v31 * v58)));
          float v34 = 0.0;
          if (v33 > 0.0)
          {
            float v35 = fminf((float)(v62 + 0.0045) * 0.75, 0.0);
            if (v35 < -0.2) {
              float v35 = -0.2;
            }
            float v34 = (float)-v35 / v33;
          }
          float v36 = v58 * v34;
          float v37 = (uint64_t *)*((void *)this + 3);
          uint64_t v38 = *(void *)(*v37 + 8 * v14);
          float v39 = v59 * v34;
          uint64_t v40 = *(void *)(*v37 + 8 * v11);
          if ((*(_DWORD *)(v40 + 8) & *(_DWORD *)(v38 + 12)) != 0)
          {
            float v18 = v18 - (float)(v50 * v36);
            float v19 = v19 - (float)(v50 * v39);
            float v20 = v26 + (float)((float)-v54 * (float)((float)(v36 * (float)-v29) + (float)(v28 * v39)));
          }
          else
          {
            float v20 = v26;
          }
          if ((*(_DWORD *)(v38 + 8) & *(_DWORD *)(v40 + 12)) != 0)
          {
            float v22 = v22 + (float)(v49 * v36);
            float v23 = v23 + (float)(v49 * v39);
            float v57 = v57 + (float)(v55 * (float)((float)(v36 * (float)-v31) + (float)(v30 * v39)));
          }
          ++v24;
        }
        while (v15 != v24);
      }
      uint64_t v41 = *v37;
      uint64_t v42 = *(void *)(*v37 + 8 * v14);
      uint64_t v43 = *(void *)(v41 + 8 * v11);
      if ((*(_DWORD *)(v43 + 8) & *(_DWORD *)(v42 + 12)) != 0)
      {
        float v44 = (float *)(*((void *)this + 5) + 16 * v14);
        float *v44 = v18;
        v44[1] = v19;
        v44[3] = v20;
        uint64_t v45 = **((void **)this + 3);
        uint64_t v43 = *(void *)(v45 + 8 * v11);
        uint64_t v42 = *(void *)(v45 + 8 * v14);
      }
      a3 = v48;
      if ((*(_DWORD *)(v42 + 8) & *(_DWORD *)(v43 + 12)) != 0)
      {
        float v46 = (float *)(*((void *)this + 5) + 16 * v11);
        *float v46 = v22;
        v46[1] = v23;
        v46[3] = v57;
      }
      ++v5;
    }
    while (v5 < *((int *)this + 20));
  }
  return v56 >= -0.00675;
}

void b2EdgeAndCircleContact::Create(b2EdgeAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_213580E70(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2EdgeAndCircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *float v3 = &unk_26C3F3D68;
  if (*(_DWORD *)(*(void *)(v3[10] + 32) + 8) != 1) {
    b2EdgeAndCircleContact::b2EdgeAndCircleContact();
  }
  if (*(_DWORD *)(*(void *)(v3[11] + 32) + 8)) {
    b2EdgeAndCircleContact::b2EdgeAndCircleContact();
  }
}

uint64_t b2EdgeAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollideEdgeAndCircle(a2, *(void *)(*(void *)(a1 + 80) + 32), a3, *(float **)(*(void *)(a1 + 88) + 32), a4);
}

void b2EdgeAndCircleContact::~b2EdgeAndCircleContact(b2EdgeAndCircleContact *this)
{
}

void b2EdgeAndPolygonContact::Create(b2EdgeAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_213580F90(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2EdgeAndPolygonContact::b2EdgeAndPolygonContact(b2EdgeAndPolygonContact *this, b2Fixture *a2, b2Fixture *a3)
{
  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *float v3 = &unk_26C3F3DB8;
  if (*(_DWORD *)(*(void *)(v3[10] + 32) + 8) != 1) {
    b2EdgeAndPolygonContact::b2EdgeAndPolygonContact();
  }
  if (*(_DWORD *)(*(void *)(v3[11] + 32) + 8) != 2) {
    b2EdgeAndPolygonContact::b2EdgeAndPolygonContact();
  }
}

void b2EdgeAndPolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
}

void b2EdgeAndPolygonContact::~b2EdgeAndPolygonContact(b2EdgeAndPolygonContact *this)
{
}

void b2PolygonAndCircleContact::Create(b2PolygonAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_2135810B4(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2PolygonAndCircleContact::b2PolygonAndCircleContact(b2PolygonAndCircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *float v3 = &unk_26C3F3E30;
  if (*(_DWORD *)(*(void *)(v3[10] + 32) + 8) != 2) {
    b2PolygonAndCircleContact::b2PolygonAndCircleContact();
  }
  if (*(_DWORD *)(*(void *)(v3[11] + 32) + 8)) {
    b2PolygonAndCircleContact::b2PolygonAndCircleContact();
  }
}

float b2PolygonAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollidePolygonAndCircle(a2, *(void *)(*(void *)(a1 + 80) + 32), a3, *(float **)(*(void *)(a1 + 88) + 32), a4);
}

void b2PolygonAndCircleContact::~b2PolygonAndCircleContact(b2PolygonAndCircleContact *this)
{
}

void b2PolygonContact::Create(b2PolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_2135811D4(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2PolygonContact::b2PolygonContact(b2PolygonContact *this, b2Fixture *a2, b2Fixture *a3)
{
  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *float v3 = &unk_26C3F3B40;
  if (*(_DWORD *)(*(void *)(v3[10] + 32) + 8) != 2) {
    b2PolygonContact::b2PolygonContact();
  }
  if (*(_DWORD *)(*(void *)(v3[11] + 32) + 8) != 2) {
    b2PolygonContact::b2PolygonContact();
  }
}

void b2PolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, const b2Transform *a3, const b2Transform *a4)
{
}

void b2PolygonContact::~b2PolygonContact(b2PolygonContact *this)
{
}

void sub_213581360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21358144C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213581514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I7PKCGridNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xA0uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceI7PKCGridNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_2135816E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI7PKCGridNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C3F43D0;
  PKCGrid::PKCGrid((PKCGrid *)(a1 + 24));
  return a1;
}

void sub_21358173C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCGrid>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F43D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCGrid>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F43D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

void std::__shared_ptr_emplace<PKCGrid>::__on_zero_shared(uint64_t a1)
{
}

void PKCGrid::~PKCGrid(PKCGrid *this)
{
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  float v3 = (void *)*((void *)this + 11);
  if (v3)
  {
    *((void *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 8);
  if (v4)
  {
    *((void *)this + 9) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 5);
  if (v5)
  {
    *((void *)this + 6) = v5;
    operator delete(v5);
  }
}

float noise1(float a1)
{
  int v1 = (int)a1 - (a1 <= 0.0);
  float v2 = a1 - (float)v1;
  float v3 = v2 + -1.0;
  uint64_t v4 = (v1 + 1);
  float v5 = (float)(v2 * (float)(v2 * v2)) * (float)((float)(v2 * (float)((float)(v2 * 6.0) + -15.0)) + 10.0);
  LOBYTE(v1) = perm_0[v1];
  float v6 = (float)((v1 & 7) + 1);
  if ((v1 & 8) != 0) {
    float v6 = -v6;
  }
  float v7 = v2 * v6;
  float v8 = (float)((perm_0[v4] & 7) + 1);
  if ((perm_0[v4] & 8) != 0) {
    float v8 = -v8;
  }
  return (float)(v7 + (float)(v5 * (float)((float)(v3 * v8) - v7))) * 0.188;
}

float pnoise1(int a1, float a2)
{
  int v2 = (int)a2 - (a2 <= 0.0);
  float v3 = a2 - (float)v2;
  float v4 = v3 + -1.0;
  uint64_t v5 = ((v2 + 1) % a1);
  float v6 = (float)(v3 * (float)(v3 * v3)) * (float)((float)(v3 * (float)((float)(v3 * 6.0) + -15.0)) + 10.0);
  LOBYTE(vb2DynamicTree::~b2DynamicTree(this + 2) = perm_0[(v2 % a1)];
  float v7 = (float)((v2 & 7) + 1);
  if ((v2 & 8) != 0) {
    float v7 = -v7;
  }
  float v8 = v3 * v7;
  float v9 = (float)((perm_0[v5] & 7) + 1);
  if ((perm_0[v5] & 8) != 0) {
    float v9 = -v9;
  }
  return (float)(v8 + (float)(v6 * (float)((float)(v4 * v9) - v8))) * 0.188;
}

float noise2(float a1, float a2, double a3, double a4, double a5, double a6, double a7)
{
  int v7 = (int)a1 - (a1 <= 0.0);
  int v8 = (int)a2 - (a2 <= 0.0);
  *(float *)&__int32 v9 = a1 - (float)v7;
  *(float *)&a6 = a2 - (float)v8;
  *(float *)v10.i32 = *(float *)&v9 + -1.0;
  *(float *)&a4 = *(float *)&a6 + -1.0;
  uint64_t v11 = (v7 + 1);
  uint64_t v12 = (v8 + 1);
  float v13 = (float)(*(float *)&a6 * (float)(*(float *)&a6 * *(float *)&a6))
      * (float)((float)(*(float *)&a6 * (float)((float)(*(float *)&a6 * 6.0) + -15.0)) + 10.0);
  *(float *)&a7 = (float)(*(float *)&v9 * (float)((float)(*(float *)&v9 * 6.0) + -15.0)) + 10.0;
  float v14 = (float)(*(float *)&v9 * (float)(*(float *)&v9 * *(float *)&v9)) * *(float *)&a7;
  uint64_t v15 = perm_0[v8];
  uint64_t v16 = &perm_0[v7];
  uint64_t v17 = perm_0[v12];
  float v18 = &perm_0[v11];
  LOBYTE(a7) = v18[v15];
  BYTE4(a7) = v16[v15];
  int8x8_t v19 = vand_s8(*(int8x8_t *)&a7, (int8x8_t)0xFF000000FFLL);
  int8x8_t v20 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  v10.i32[1] = v9;
  int8x8_t v21 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v19 & 0xFFFFFF04FFFFFF04));
  int32x2_t v22 = vceqz_s32((int32x2_t)(*(void *)&v19 & 0xFFFFFF02FFFFFF02));
  v23.i64[0] = v22.i32[0];
  v23.i64[1] = v22.i32[1];
  __asm
  {
    FMOV            V18.2D, #-2.0
    FMOV            V19.2D, #2.0
  }
  float64x2_t v30 = vmulq_f64((float64x2_t)vbslq_s8(v23, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v21, v20, v10)));
  float32x2_t v31 = (float32x2_t)vbsl_s8(v21, v10, v20);
  int8x8_t v32 = (int8x8_t)vneg_f32(v31);
  float32x2_t v33 = vcvt_f32_f64(vaddq_f64(v30, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v19 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v31, v32))));
  v32.i8[0] = v18[v17];
  v32.i8[4] = v16[v17];
  int8x8_t v34 = vand_s8(v32, (int8x8_t)0xFF000000FFLL);
  int8x8_t v35 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v34 & 0xFFFFFF04FFFFFF04));
  int8x8_t v36 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  *(int32x2_t *)&v30.f64[0] = vceqz_s32((int32x2_t)(*(void *)&v34 & 0xFFFFFF02FFFFFF02));
  v23.i64[0] = SLODWORD(v30.f64[0]);
  v23.i64[1] = SHIDWORD(v30.f64[0]);
  float64x2_t v37 = vmulq_f64((float64x2_t)vbslq_s8(v23, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v35, v36, v10)));
  float32x2_t v38 = (float32x2_t)vbsl_s8(v35, v10, v36);
  float32x2_t v39 = vmla_n_f32(v33, vsub_f32(vcvt_f32_f64(vaddq_f64(v37, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v34 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v38, (int8x8_t)vneg_f32(v38))))), v33), v13);
  return (float)(v39.f32[1] + (float)(v14 * (float)(v39.f32[0] - v39.f32[1]))) * 0.507;
}

float pnoise2(int a1, int a2, float a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int v9 = (int)a3 - (a3 <= 0.0);
  int v10 = (int)*(float *)&a4 - (*(float *)&a4 <= 0.0);
  *(float *)&__int32 v11 = a3 - (float)v9;
  *(float *)&a8 = *(float *)&a4 - (float)v10;
  *(float *)v12.i32 = *(float *)&v11 + -1.0;
  *(float *)&a4 = *(float *)&a8 + -1.0;
  uint64_t v13 = ((v9 + 1) % a1);
  uint64_t v14 = ((v10 + 1) % a2);
  float v15 = (float)(*(float *)&a8 * (float)(*(float *)&a8 * *(float *)&a8))
      * (float)((float)(*(float *)&a8 * (float)((float)(*(float *)&a8 * 6.0) + -15.0)) + 10.0);
  *(float *)&a9 = (float)(*(float *)&v11 * (float)((float)(*(float *)&v11 * 6.0) + -15.0)) + 10.0;
  float v16 = (float)(*(float *)&v11 * (float)(*(float *)&v11 * *(float *)&v11)) * *(float *)&a9;
  uint64_t v17 = perm_0[(v10 % a2)];
  float v18 = &perm_0[(v9 % a1)];
  uint64_t v19 = perm_0[v14];
  int8x8_t v20 = &perm_0[v13];
  LOBYTE(a9) = v20[v17];
  BYTE4(a9) = v18[v17];
  int8x8_t v21 = vand_s8(*(int8x8_t *)&a9, (int8x8_t)0xFF000000FFLL);
  int8x8_t v22 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
  v12.i32[1] = v11;
  int8x8_t v23 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v21 & 0xFFFFFF04FFFFFF04));
  int32x2_t v24 = vceqz_s32((int32x2_t)(*(void *)&v21 & 0xFFFFFF02FFFFFF02));
  v25.i64[0] = v24.i32[0];
  v25.i64[1] = v24.i32[1];
  __asm
  {
    FMOV            V18.2D, #-2.0
    FMOV            V19.2D, #2.0
  }
  float64x2_t v32 = vmulq_f64((float64x2_t)vbslq_s8(v25, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v23, v22, v12)));
  float32x2_t v33 = (float32x2_t)vbsl_s8(v23, v12, v22);
  int8x8_t v34 = (int8x8_t)vneg_f32(v33);
  float32x2_t v35 = vcvt_f32_f64(vaddq_f64(v32, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v21 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v33, v34))));
  v34.i8[0] = v20[v19];
  v34.i8[4] = v18[v19];
  int8x8_t v36 = vand_s8(v34, (int8x8_t)0xFF000000FFLL);
  int8x8_t v37 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF04FFFFFF04));
  int8x8_t v38 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  *(int32x2_t *)&v32.f64[0] = vceqz_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF02FFFFFF02));
  v25.i64[0] = SLODWORD(v32.f64[0]);
  v25.i64[1] = SHIDWORD(v32.f64[0]);
  float64x2_t v39 = vmulq_f64((float64x2_t)vbslq_s8(v25, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v37, v38, v12)));
  float32x2_t v40 = (float32x2_t)vbsl_s8(v37, v12, v38);
  float32x2_t v41 = vmla_n_f32(v35, vsub_f32(vcvt_f32_f64(vaddq_f64(v39, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v40, (int8x8_t)vneg_f32(v40))))), v35), v15);
  return (float)(v41.f32[1] + (float)(v16 * (float)(v41.f32[0] - v41.f32[1]))) * 0.507;
}

float noise3(float a1, float a2, float a3, double a4, double a5, double a6, double a7, int8x8_t a8)
{
  int v10 = (int)a1 - (a1 <= 0.0);
  int v11 = (int)a2 - (a2 <= 0.0);
  int v12 = (int)a3 - (a3 <= 0.0);
  *(float *)&__int32 v13 = a1 - (float)v10;
  *(float *)v8.i32 = a2 - (float)v11;
  *(float *)v9.i32 = a3 - (float)v12;
  *(float *)v14.i32 = *(float *)&v13 + -1.0;
  *(float *)&a5 = *(float *)v8.i32 + -1.0;
  *(float *)&a6 = *(float *)v9.i32 + -1.0;
  uint64_t v15 = (v10 + 1);
  uint64_t v16 = (v11 + 1);
  uint64_t v17 = (v12 + 1);
  uint64_t v18 = ((int)a2 - (a2 <= 0.0));
  a8.i32[0] = 10.0;
  float v19 = (float)(*(float *)v9.i32 * (float)(*(float *)v9.i32 * *(float *)v9.i32))
      * (float)((float)(*(float *)v9.i32 * (float)((float)(*(float *)v9.i32 * 6.0) + -15.0)) + 10.0);
  float v20 = (float)(*(float *)v8.i32 * (float)(*(float *)v8.i32 * *(float *)v8.i32))
      * (float)((float)(*(float *)v8.i32 * (float)((float)(*(float *)v8.i32 * 6.0) + -15.0)) + 10.0);
  uint64_t v21 = perm_0[((int)a3 - (a3 <= 0.0))];
  uint64_t v22 = perm_0[v18 + v21];
  int8x8_t v23 = &perm_0[v10];
  uint64_t v24 = perm_0[v17];
  uint64_t v25 = perm_0[v18 + v24];
  uint64_t v26 = perm_0[v16 + v21];
  uint64_t v27 = perm_0[v16 + v24];
  a8.i8[0] = perm_0[v15 + v22];
  a8.i8[4] = v23[v22];
  int8x8_t v28 = vand_s8(a8, (int8x8_t)0xFF000000FFLL);
  v14.i32[1] = v13;
  int8x8_t v29 = (int8x8_t)vdup_lane_s32(v9, 0);
  int8x8_t v30 = (int8x8_t)vdup_lane_s32(v8, 0);
  float32x2_t v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v28 & 0xFFFFFF0FFFFFFF0FLL)), v30, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v28 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v29));
  float32x2_t v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v28 & 0xFFFFFF0FFFFFFF0FLL)), v14, v30);
  float32x2_t v33 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v28 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v32, (int8x8_t)vneg_f32(v32));
  int8x8_t v34 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v28 & 0xFFFFFF02FFFFFF02));
  float32x2_t v35 = vadd_f32(v33, (float32x2_t)vbsl_s8(v34, (int8x8_t)v31, (int8x8_t)vneg_f32(v31)));
  v34.i8[0] = perm_0[v15 + v25];
  v34.i8[4] = v23[v25];
  int8x8_t v36 = vand_s8(v34, (int8x8_t)0xFF000000FFLL);
  int8x8_t v37 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  float32x2_t v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v36 & 0xFFFFFF0FFFFFFF0FLL)), v30, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v37));
  float32x2_t v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v36 & 0xFFFFFF0FFFFFFF0FLL)), v14, v30);
  float32x2_t v40 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v39, (int8x8_t)vneg_f32(v39));
  float32x2_t v41 = vsub_f32(vadd_f32(v40, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v36 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v38, (int8x8_t)vneg_f32(v38))), v35);
  v40.i8[0] = perm_0[v15 + v26];
  v40.i8[4] = v23[v26];
  float32x2_t v42 = vmla_n_f32(v35, v41, v19);
  int8x8_t v43 = vand_s8((int8x8_t)v40, (int8x8_t)0xFF000000FFLL);
  int8x8_t v44 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
  float32x2_t v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v43 & 0xFFFFFF0FFFFFFF0FLL)), v44, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v43 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v29));
  float32x2_t v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v43 & 0xFFFFFF0FFFFFFF0FLL)), v14, v44);
  float32x2_t v47 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v43 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v46, (int8x8_t)vneg_f32(v46));
  int8x8_t v48 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v43 & 0xFFFFFF02FFFFFF02));
  float32x2_t v49 = vadd_f32(v47, (float32x2_t)vbsl_s8(v48, (int8x8_t)v45, (int8x8_t)vneg_f32(v45)));
  v48.i8[0] = perm_0[v15 + v27];
  v48.i8[4] = v23[v27];
  int8x8_t v50 = vand_s8(v48, (int8x8_t)0xFF000000FFLL);
  float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v50 & 0xFFFFFF0FFFFFFF0FLL)), v44, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v50 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v37));
  float32x2_t v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v50 & 0xFFFFFF0FFFFFFF0FLL)), v14, v44);
  float32x2_t v53 = vmla_n_f32(v42, vsub_f32(vmla_n_f32(v49, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v50 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v52, (int8x8_t)vneg_f32(v52)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v50 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v51, (int8x8_t)vneg_f32(v51))), v49), v19), v42), v20);
  return (float)(v53.f32[1]
               + (float)((float)((float)(*(float *)&v13 * (float)(*(float *)&v13 * *(float *)&v13))
                               * (float)((float)(*(float *)&v13 * (float)((float)(*(float *)&v13 * 6.0) + -15.0)) + 10.0))
                       * (float)(v53.f32[0] - v53.f32[1])))
       * 0.936;
}

float pnoise3(int a1, int a2, int a3, float a4, float a5, float a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int v13 = (int)a4 - (a4 <= 0.0);
  int v14 = (int)a5 - (a5 <= 0.0);
  int v15 = (int)a6 - (a6 <= 0.0);
  *(float *)&__int32 v16 = a4 - (float)v13;
  *(float *)v11.i32 = a5 - (float)v14;
  *(float *)v12.i32 = a6 - (float)v15;
  *(float *)v17.i32 = *(float *)&v16 + -1.0;
  *(float *)&a8 = *(float *)v11.i32 + -1.0;
  *(float *)&a9 = *(float *)v12.i32 + -1.0;
  uint64_t v18 = ((v13 + 1) % a1);
  uint64_t v19 = ((v14 + 1) % a2);
  uint64_t v20 = ((v15 + 1) % a3);
  uint64_t v21 = (v14 % a2);
  a11.i32[0] = 10.0;
  float v22 = (float)(*(float *)v12.i32 * (float)(*(float *)v12.i32 * *(float *)v12.i32))
      * (float)((float)(*(float *)v12.i32 * (float)((float)(*(float *)v12.i32 * 6.0) + -15.0)) + 10.0);
  float v23 = (float)(*(float *)v11.i32 * (float)(*(float *)v11.i32 * *(float *)v11.i32))
      * (float)((float)(*(float *)v11.i32 * (float)((float)(*(float *)v11.i32 * 6.0) + -15.0)) + 10.0);
  uint64_t v24 = perm_0[(v15 % a3)];
  uint64_t v25 = perm_0[v21 + v24];
  uint64_t v26 = &perm_0[(v13 % a1)];
  uint64_t v27 = perm_0[v20];
  uint64_t v28 = perm_0[v21 + v27];
  uint64_t v29 = perm_0[v19 + v24];
  uint64_t v30 = perm_0[v19 + v27];
  float32x2_t v31 = &perm_0[v18];
  a11.i8[0] = v31[v25];
  a11.i8[4] = v26[v25];
  int8x8_t v32 = vand_s8(a11, (int8x8_t)0xFF000000FFLL);
  v17.i32[1] = v16;
  int8x8_t v33 = (int8x8_t)vdup_lane_s32(v12, 0);
  int8x8_t v34 = (int8x8_t)vdup_lane_s32(v11, 0);
  float32x2_t v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v32 & 0xFFFFFF0FFFFFFF0FLL)), v34, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v32 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v33));
  float32x2_t v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v32 & 0xFFFFFF0FFFFFFF0FLL)), v17, v34);
  float32x2_t v37 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v32 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v36, (int8x8_t)vneg_f32(v36));
  int8x8_t v38 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v32 & 0xFFFFFF02FFFFFF02));
  float32x2_t v39 = vadd_f32(v37, (float32x2_t)vbsl_s8(v38, (int8x8_t)v35, (int8x8_t)vneg_f32(v35)));
  v38.i8[0] = v31[v28];
  v38.i8[4] = v26[v28];
  int8x8_t v40 = vand_s8(v38, (int8x8_t)0xFF000000FFLL);
  int8x8_t v41 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
  float32x2_t v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v40 & 0xFFFFFF0FFFFFFF0FLL)), v34, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v40 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v41));
  float32x2_t v43 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v40 & 0xFFFFFF0FFFFFFF0FLL)), v17, v34);
  float32x2_t v44 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v40 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v43, (int8x8_t)vneg_f32(v43));
  float32x2_t v45 = vsub_f32(vadd_f32(v44, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v40 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v42, (int8x8_t)vneg_f32(v42))), v39);
  v44.i8[0] = v31[v29];
  v44.i8[4] = v26[v29];
  float32x2_t v46 = vmla_n_f32(v39, v45, v22);
  int8x8_t v47 = vand_s8((int8x8_t)v44, (int8x8_t)0xFF000000FFLL);
  int8x8_t v48 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
  float32x2_t v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v47 & 0xFFFFFF0FFFFFFF0FLL)), v48, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v47 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v33));
  float32x2_t v50 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v47 & 0xFFFFFF0FFFFFFF0FLL)), v17, v48);
  float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v47 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v50, (int8x8_t)vneg_f32(v50));
  int8x8_t v52 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v47 & 0xFFFFFF02FFFFFF02));
  float32x2_t v53 = vadd_f32(v51, (float32x2_t)vbsl_s8(v52, (int8x8_t)v49, (int8x8_t)vneg_f32(v49)));
  v52.i8[0] = v31[v30];
  v52.i8[4] = v26[v30];
  int8x8_t v54 = vand_s8(v52, (int8x8_t)0xFF000000FFLL);
  float32x2_t v55 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(void *)&v54 & 0xFFFFFF0FFFFFFF0FLL)), v48, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(void *)&v54 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v41));
  float32x2_t v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v54 & 0xFFFFFF0FFFFFFF0FLL)), v17, v48);
  float32x2_t v57 = vmla_n_f32(v46, vsub_f32(vmla_n_f32(v53, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v54 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v56, (int8x8_t)vneg_f32(v56)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v54 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v55, (int8x8_t)vneg_f32(v55))), v53), v22), v46), v23);
  return (float)(v57.f32[1]
               + (float)((float)((float)(*(float *)&v16 * (float)(*(float *)&v16 * *(float *)&v16))
                               * (float)((float)(*(float *)&v16 * (float)((float)(*(float *)&v16 * 6.0) + -15.0)) + 10.0))
                       * (float)(v57.f32[0] - v57.f32[1])))
       * 0.936;
}

float noise4(float a1, float a2, float a3, float a4, double a5, double a6, double a7, int8x8_t a8)
{
  int v13 = (int)a1 - (a1 <= 0.0);
  int v14 = (int)a2 - (a2 <= 0.0);
  int v15 = (int)a3 - (a3 <= 0.0);
  int v16 = (int)a4 - (a4 <= 0.0);
  *(float *)&__int32 v17 = a1 - (float)v13;
  *(float *)v9.i32 = a2 - (float)v14;
  *(float *)v10.i32 = a3 - (float)v15;
  *(float *)v8.i32 = a4 - (float)v16;
  *(float *)v18.i32 = *(float *)&v17 + -1.0;
  *(float *)&a6 = *(float *)v9.i32 + -1.0;
  *(float *)v12.i32 = *(float *)v10.i32 + -1.0;
  *(float *)v11.i32 = *(float *)v8.i32 + -1.0;
  uint64_t v19 = (v13 + 1);
  uint64_t v20 = (v14 + 1);
  uint64_t v21 = (v15 + 1);
  uint64_t v22 = (v16 + 1);
  uint64_t v23 = v13;
  uint64_t v24 = ((int)a2 - (a2 <= 0.0));
  uint64_t v25 = ((int)a3 - (a3 <= 0.0));
  a8.i32[0] = 10.0;
  float v26 = (float)(*(float *)v8.i32 * (float)(*(float *)v8.i32 * *(float *)v8.i32))
      * (float)((float)(*(float *)v8.i32 * (float)((float)(*(float *)v8.i32 * 6.0) + -15.0)) + 10.0);
  float v27 = (float)(*(float *)v10.i32 * (float)(*(float *)v10.i32 * *(float *)v10.i32))
      * (float)((float)(*(float *)v10.i32 * (float)((float)(*(float *)v10.i32 * 6.0) + -15.0)) + 10.0);
  float v28 = (float)(*(float *)v9.i32 * (float)(*(float *)v9.i32 * *(float *)v9.i32))
      * (float)((float)(*(float *)v9.i32 * (float)((float)(*(float *)v9.i32 * 6.0) + -15.0)) + 10.0);
  float v29 = (float)(*(float *)&v17 * (float)(*(float *)&v17 * *(float *)&v17))
      * (float)((float)(*(float *)&v17 * (float)((float)(*(float *)&v17 * 6.0) + -15.0)) + 10.0);
  uint64_t v30 = perm_0[v16];
  uint64_t v31 = perm_0[v25 + v30];
  uint64_t v32 = perm_0[v24 + v31];
  uint64_t v33 = perm_0[v22];
  uint64_t v34 = perm_0[v25 + v33];
  uint64_t v35 = perm_0[v24 + v34];
  uint64_t v36 = perm_0[v21 + v30];
  uint64_t v37 = perm_0[v24 + v36];
  uint64_t v38 = perm_0[v21 + v33];
  uint64_t v39 = perm_0[v24 + v38];
  uint64_t v40 = perm_0[v20 + v31];
  uint64_t v41 = perm_0[v20 + v34];
  uint64_t v42 = perm_0[v20 + v36];
  uint64_t v43 = perm_0[v20 + v38];
  float32x2_t v44 = &perm_0[v19];
  a8.i8[0] = v44[v32];
  a8.i8[4] = perm_0[v23 + v32];
  int8x8_t v45 = vand_s8(a8, (int8x8_t)0xFF000000FFLL);
  v18.i32[1] = v17;
  int8x8_t v46 = (int8x8_t)vdup_lane_s32(v9, 0);
  float32x2_t v47 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  int8x8_t v48 = (int8x8_t)vdup_lane_s32(v10, 0);
  float32x2_t v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v46, v48);
  int8x8_t v50 = (int8x8_t)vdup_lane_s32(v8, 0);
  float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v48, v50);
  float32x2_t v52 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v45 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v47, (int8x8_t)vneg_f32(v47)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v45 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v49, (int8x8_t)vneg_f32(v49)));
  int8x8_t v53 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v45 & 0xFFFFFF04FFFFFF04));
  float32x2_t v54 = vadd_f32((float32x2_t)vbsl_s8(v53, (int8x8_t)v51, (int8x8_t)vneg_f32(v51)), v52);
  v53.i8[0] = v44[v35];
  v53.i8[4] = perm_0[v23 + v35];
  int8x8_t v55 = vand_s8(v53, (int8x8_t)0xFF000000FFLL);
  float32x2_t v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  float32x2_t v57 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v46, v48);
  int8x8_t v58 = (int8x8_t)vdup_lane_s32(v11, 0);
  float32x2_t v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v48, v58);
  float32x2_t v60 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v55 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v59, (int8x8_t)vneg_f32(v59)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v55 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v56, (int8x8_t)vneg_f32(v56)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v55 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v57, (int8x8_t)vneg_f32(v57)))), v54);
  float32x2_t v61 = vmla_n_f32(v54, v60, v26);
  v60.i8[0] = v44[v37];
  v60.i8[4] = perm_0[v23 + v37];
  int8x8_t v62 = vand_s8((int8x8_t)v60, (int8x8_t)0xFF000000FFLL);
  float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  int8x8_t v64 = (int8x8_t)vdup_lane_s32(v12, 0);
  float32x2_t v65 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v46, v64);
  float32x2_t v66 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v64, v50);
  float32x2_t v67 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v62 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v66, (int8x8_t)vneg_f32(v66)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v62 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v63, (int8x8_t)vneg_f32(v63)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v62 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v65, (int8x8_t)vneg_f32(v65))));
  v66.i8[0] = v44[v39];
  v66.i8[4] = perm_0[v23 + v39];
  int8x8_t v68 = vand_s8((int8x8_t)v66, (int8x8_t)0xFF000000FFLL);
  float32x2_t v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  float32x2_t v70 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v46, v64);
  float32x2_t v71 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v64, v58);
  float32x2_t v72 = vmla_n_f32(v67, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v68 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v71, (int8x8_t)vneg_f32(v71)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v68 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v69, (int8x8_t)vneg_f32(v69)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v68 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v70, (int8x8_t)vneg_f32(v70)))), v67), v26);
  float32x2_t v73 = vsub_f32(v72, v61);
  v72.i8[0] = v44[v40];
  float32x2_t v74 = vmla_n_f32(v61, v73, v27);
  v72.i8[4] = perm_0[v23 + v40];
  int8x8_t v75 = vand_s8((int8x8_t)v72, (int8x8_t)0xFF000000FFLL);
  int8x8_t v76 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  float32x2_t v77 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  float32x2_t v78 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v76, v48);
  float32x2_t v79 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v48, v50);
  float32x2_t v80 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v75 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v77, (int8x8_t)vneg_f32(v77)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v75 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v78, (int8x8_t)vneg_f32(v78)));
  float32x2_t v81 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v75 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v79, (int8x8_t)vneg_f32(v79));
  float32x2_t v82 = vadd_f32(v81, v80);
  v81.i8[0] = v44[v41];
  v81.i8[4] = perm_0[v23 + v41];
  int8x8_t v83 = vand_s8((int8x8_t)v81, (int8x8_t)0xFF000000FFLL);
  float32x2_t v84 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  float32x2_t v85 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v76, v48);
  float32x2_t v86 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v48, v58);
  float32x2_t v87 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v83 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v86, (int8x8_t)vneg_f32(v86)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v83 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v84, (int8x8_t)vneg_f32(v84)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v83 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v85, (int8x8_t)vneg_f32(v85)))), v82);
  float32x2_t v88 = vmla_n_f32(v82, v87, v26);
  v87.i8[0] = v44[v42];
  v87.i8[4] = perm_0[v23 + v42];
  int8x8_t v89 = vand_s8((int8x8_t)v87, (int8x8_t)0xFF000000FFLL);
  float32x2_t v90 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  float32x2_t v91 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v76, v64);
  float32x2_t v92 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v64, v50);
  float32x2_t v93 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v89 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v90, (int8x8_t)vneg_f32(v90)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v89 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v91, (int8x8_t)vneg_f32(v91)));
  int8x8_t v94 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v89 & 0xFFFFFF04FFFFFF04));
  float32x2_t v95 = vadd_f32((float32x2_t)vbsl_s8(v94, (int8x8_t)v92, (int8x8_t)vneg_f32(v92)), v93);
  v94.i8[0] = v44[v43];
  v94.i8[4] = perm_0[v23 + v43];
  int8x8_t v96 = vand_s8(v94, (int8x8_t)0xFF000000FFLL);
  float32x2_t v97 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  float32x2_t v98 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v76, v64);
  float32x2_t v99 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v64, v58);
  float32x2_t v100 = vmla_n_f32(v74, vsub_f32(vmla_n_f32(v88, vsub_f32(vmla_n_f32(v95, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v96 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v99, (int8x8_t)vneg_f32(v99)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v96 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v97, (int8x8_t)vneg_f32(v97)), (float32x2_t)vbsl_s8(
                                        (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v96 & 0xFFFFFF02FFFFFF02)),
                                        (int8x8_t)v98,
                                        (int8x8_t)vneg_f32(v98)))),
                     v95),
                   v26),
                 v88),
               v27),
             v74),
           v28);
  return (float)(v100.f32[1] + (float)(v29 * (float)(v100.f32[0] - v100.f32[1]))) * 0.87;
}

float pnoise4(int a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, double a9, double a10, double a11, int8x8_t a12)
{
  int v17 = (int)a5 - (a5 <= 0.0);
  int v18 = (int)a6 - (a6 <= 0.0);
  int v19 = (int)a7 - (a7 <= 0.0);
  int v20 = (int)a8 - (a8 <= 0.0);
  *(float *)&__int32 v21 = a5 - (float)v17;
  *(float *)v13.i32 = a6 - (float)v18;
  *(float *)v14.i32 = a7 - (float)v19;
  *(float *)v12.i32 = a8 - (float)v20;
  *(float *)v22.i32 = *(float *)&v21 + -1.0;
  *(float *)&a10 = *(float *)v13.i32 + -1.0;
  *(float *)v15.i32 = *(float *)v14.i32 + -1.0;
  *(float *)v16.i32 = *(float *)v12.i32 + -1.0;
  uint64_t v23 = ((v17 + 1) % a1);
  uint64_t v24 = ((v18 + 1) % a2);
  uint64_t v25 = ((v19 + 1) % a3);
  uint64_t v26 = ((v20 + 1) % a4);
  uint64_t v27 = (v17 % a1);
  uint64_t v28 = (v18 % a2);
  uint64_t v29 = (v19 % a3);
  a12.i32[0] = 10.0;
  float v30 = (float)(*(float *)v12.i32 * (float)(*(float *)v12.i32 * *(float *)v12.i32))
      * (float)((float)(*(float *)v12.i32 * (float)((float)(*(float *)v12.i32 * 6.0) + -15.0)) + 10.0);
  float v31 = (float)(*(float *)v14.i32 * (float)(*(float *)v14.i32 * *(float *)v14.i32))
      * (float)((float)(*(float *)v14.i32 * (float)((float)(*(float *)v14.i32 * 6.0) + -15.0)) + 10.0);
  float v32 = (float)(*(float *)v13.i32 * (float)(*(float *)v13.i32 * *(float *)v13.i32))
      * (float)((float)(*(float *)v13.i32 * (float)((float)(*(float *)v13.i32 * 6.0) + -15.0)) + 10.0);
  float v33 = (float)(*(float *)&v21 * (float)(*(float *)&v21 * *(float *)&v21))
      * (float)((float)(*(float *)&v21 * (float)((float)(*(float *)&v21 * 6.0) + -15.0)) + 10.0);
  uint64_t v34 = perm_0[(v20 % a4)];
  uint64_t v35 = perm_0[v29 + v34];
  uint64_t v36 = perm_0[v28 + v35];
  uint64_t v37 = perm_0[v26];
  uint64_t v38 = perm_0[v29 + v37];
  uint64_t v39 = perm_0[v28 + v38];
  uint64_t v40 = perm_0[v25 + v34];
  uint64_t v41 = perm_0[v28 + v40];
  uint64_t v42 = perm_0[v25 + v37];
  uint64_t v43 = perm_0[v28 + v42];
  uint64_t v44 = perm_0[v24 + v35];
  uint64_t v45 = perm_0[v24 + v38];
  uint64_t v46 = perm_0[v24 + v40];
  uint64_t v47 = perm_0[v24 + v42];
  int8x8_t v48 = &perm_0[v23];
  a12.i8[0] = v48[v36];
  a12.i8[4] = perm_0[v27 + v36];
  int8x8_t v49 = vand_s8(a12, (int8x8_t)0xFF000000FFLL);
  v22.i32[1] = v21;
  int8x8_t v50 = (int8x8_t)vdup_lane_s32(v13, 0);
  float32x2_t v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  int8x8_t v52 = (int8x8_t)vdup_lane_s32(v14, 0);
  float32x2_t v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v50, v52);
  int8x8_t v54 = (int8x8_t)vdup_lane_s32(v12, 0);
  float32x2_t v55 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v52, v54);
  float32x2_t v56 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v49 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v51, (int8x8_t)vneg_f32(v51)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v49 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v53, (int8x8_t)vneg_f32(v53)));
  int8x8_t v57 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v49 & 0xFFFFFF04FFFFFF04));
  float32x2_t v58 = vadd_f32((float32x2_t)vbsl_s8(v57, (int8x8_t)v55, (int8x8_t)vneg_f32(v55)), v56);
  v57.i8[0] = v48[v39];
  v57.i8[4] = perm_0[v27 + v39];
  int8x8_t v59 = vand_s8(v57, (int8x8_t)0xFF000000FFLL);
  float32x2_t v60 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  float32x2_t v61 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v50, v52);
  int8x8_t v62 = (int8x8_t)vdup_lane_s32(v16, 0);
  float32x2_t v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v52, v62);
  float32x2_t v64 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v59 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v63, (int8x8_t)vneg_f32(v63)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v59 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v60, (int8x8_t)vneg_f32(v60)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v59 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v61, (int8x8_t)vneg_f32(v61)))), v58);
  float32x2_t v65 = vmla_n_f32(v58, v64, v30);
  v64.i8[0] = v48[v41];
  v64.i8[4] = perm_0[v27 + v41];
  int8x8_t v66 = vand_s8((int8x8_t)v64, (int8x8_t)0xFF000000FFLL);
  float32x2_t v67 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  int8x8_t v68 = (int8x8_t)vdup_lane_s32(v15, 0);
  float32x2_t v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v50, v68);
  float32x2_t v70 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v68, v54);
  float32x2_t v71 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v66 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v70, (int8x8_t)vneg_f32(v70)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v66 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v67, (int8x8_t)vneg_f32(v67)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v66 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v69, (int8x8_t)vneg_f32(v69))));
  v70.i8[0] = v48[v43];
  v70.i8[4] = perm_0[v27 + v43];
  int8x8_t v72 = vand_s8((int8x8_t)v70, (int8x8_t)0xFF000000FFLL);
  float32x2_t v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  float32x2_t v74 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v50, v68);
  float32x2_t v75 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v68, v62);
  float32x2_t v76 = vmla_n_f32(v71, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v72 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v75, (int8x8_t)vneg_f32(v75)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v72 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v73, (int8x8_t)vneg_f32(v73)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v72 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v74, (int8x8_t)vneg_f32(v74)))), v71), v30);
  float32x2_t v77 = vsub_f32(v76, v65);
  v76.i8[0] = v48[v44];
  float32x2_t v78 = vmla_n_f32(v65, v77, v31);
  v76.i8[4] = perm_0[v27 + v44];
  int8x8_t v79 = vand_s8((int8x8_t)v76, (int8x8_t)0xFF000000FFLL);
  int8x8_t v80 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a10, 0);
  float32x2_t v81 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  float32x2_t v82 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v80, v52);
  float32x2_t v83 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v52, v54);
  float32x2_t v84 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v79 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v81, (int8x8_t)vneg_f32(v81)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v79 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v82, (int8x8_t)vneg_f32(v82)));
  float32x2_t v85 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v79 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v83, (int8x8_t)vneg_f32(v83));
  float32x2_t v86 = vadd_f32(v85, v84);
  v85.i8[0] = v48[v45];
  v85.i8[4] = perm_0[v27 + v45];
  int8x8_t v87 = vand_s8((int8x8_t)v85, (int8x8_t)0xFF000000FFLL);
  float32x2_t v88 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  float32x2_t v89 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v80, v52);
  float32x2_t v90 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v52, v62);
  float32x2_t v91 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v87 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v90, (int8x8_t)vneg_f32(v90)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v87 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v88, (int8x8_t)vneg_f32(v88)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v87 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v89, (int8x8_t)vneg_f32(v89)))), v86);
  float32x2_t v92 = vmla_n_f32(v86, v91, v30);
  v91.i8[0] = v48[v46];
  v91.i8[4] = perm_0[v27 + v46];
  int8x8_t v93 = vand_s8((int8x8_t)v91, (int8x8_t)0xFF000000FFLL);
  float32x2_t v94 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  float32x2_t v95 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v80, v68);
  float32x2_t v96 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v68, v54);
  float32x2_t v97 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v93 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v94, (int8x8_t)vneg_f32(v94)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v93 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v95, (int8x8_t)vneg_f32(v95)));
  int8x8_t v98 = (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v93 & 0xFFFFFF04FFFFFF04));
  float32x2_t v99 = vadd_f32((float32x2_t)vbsl_s8(v98, (int8x8_t)v96, (int8x8_t)vneg_f32(v96)), v97);
  v98.i8[0] = v48[v47];
  v98.i8[4] = perm_0[v27 + v47];
  int8x8_t v100 = vand_s8(v98, (int8x8_t)0xFF000000FFLL);
  float32x2_t v101 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(void *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  float32x2_t v102 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(void *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v80, v68);
  float32x2_t v103 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(void *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v68, v62);
  float32x2_t v104 = vmla_n_f32(v78, vsub_f32(vmla_n_f32(v92, vsub_f32(vmla_n_f32(v99, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v100 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v103, (int8x8_t)vneg_f32(v103)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v100 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v101, (int8x8_t)vneg_f32(v101)), (float32x2_t)vbsl_s8(
                                        (int8x8_t)vceqz_s32((int32x2_t)(*(void *)&v100 & 0xFFFFFF02FFFFFF02)),
                                        (int8x8_t)v102,
                                        (int8x8_t)vneg_f32(v102)))),
                     v99),
                   v30),
                 v92),
               v31),
             v78),
           v32);
  return (float)(v104.f32[1] + (float)(v33 * (float)(v104.f32[0] - v104.f32[1]))) * 0.87;
}

void sub_21358304C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135835F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t stringToShape(NSString *a1)
{
  int v1 = a1;
  int v2 = v1;
  if (!v1) {
    goto LABEL_5;
  }
  if ([(NSString *)v1 isEqualToString:@"empty"])
  {
    uint64_t v3 = 0;
    goto LABEL_6;
  }
  if ([(NSString *)v2 isEqualToString:@"infinite"])
  {
LABEL_5:
    uint64_t v3 = 1;
    goto LABEL_6;
  }
  if ([(NSString *)v2 isEqualToString:@"ellipsoidal"])
  {
    uint64_t v3 = 2;
  }
  else if ([(NSString *)v2 isEqualToString:@"box"])
  {
    uint64_t v3 = 3;
  }
  else if ([(NSString *)v2 isEqualToString:@"cgpath"])
  {
    uint64_t v3 = 4;
  }
  else if ([(NSString *)v2 isEqualToString:@"convexhull"])
  {
    uint64_t v3 = 5;
  }
  else
  {
    uint64_t v3 = 1;
  }
LABEL_6:

  return v3;
}

void sub_213583784(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_213583ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583CBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213583EE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCPathHolder>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F41A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCPathHolder>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F41A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

void std::__shared_ptr_emplace<PKCPathHolder>::__on_zero_shared(uint64_t a1)
{
}

void PKCPathHolder::~PKCPathHolder(PKCPathHolder *this)
{
  int v1 = *(const CGPath **)this;
  if (v1) {
    CGPathRelease(v1);
  }
}

float b2DistanceJointDef::Initialize(b2DistanceJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  this->bodyA = a2;
  this->bodyB = a3;
  float v5 = a4->x - a2->var8.var0.x;
  float v6 = a4->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  this->localAnchorA.float x = (float)(v6 * var0) + (float)(var1 * v5);
  this->localAnchorA.float y = (float)(var1 * v6) - (float)(var0 * v5);
  float v9 = a5->x - a3->var8.var0.x;
  float v10 = a5->y - a3->var8.var0.y;
  float v12 = a3->var8.var1.var0;
  float v11 = a3->var8.var1.var1;
  this->localAnchorB.float x = (float)(v10 * v12) + (float)(v11 * v9);
  this->localAnchorB.float y = (float)(v11 * v10) - (float)(v12 * v9);
  float result = sqrtf((float)((float)(a5->y - a4->y) * (float)(a5->y - a4->y))+ (float)((float)(a5->x - a4->x) * (float)(a5->x - a4->x)));
  this->length = result;
  return result;
}

void b2DistanceJoint::b2DistanceJoint(b2DistanceJoint *this, const b2JointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, a2);
  *(void *)uint64_t v3 = &unk_26C3F38B0;
  *(void *)(v3 + 140) = *(void *)(&a2->var4 + 4);
  *(void *)(v3 + 148) = *(void *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 164) = HIDWORD(a2[1].var1);
  *(void *)(v3 + 128) = a2[1].var2;
  *(_DWORD *)(v3 + 156) = 0;
  *(_DWORD *)(v3 + 160) = 0;
  *(_DWORD *)(v3 + 136) = 0;
}

void b2DistanceJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 200) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 208) = v9;
  float v10 = *(float *)(v4 + 212);
  float v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 216) = v10;
  *(float *)(a1 + 220) = v11;
  float v12 = *(float *)(v4 + 224);
  float v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 224) = v12;
  *(float *)(a1 + 228) = v13;
  uint64_t v14 = *(void *)(a2 + 24);
  uint64_t v15 = *(void *)(a2 + 32);
  int32x2_t v16 = (float *)(v14 + 16 * v6);
  float v60 = *v16;
  float v61 = v16[1];
  int v17 = (float *)(v15 + 16 * v6);
  float v67 = v17[1];
  float v65 = *v17;
  float v66 = v17[3];
  int v18 = (float *)(v14 + 16 * v7);
  float v19 = v18[1];
  float v59 = *v18;
  float v20 = v18[3];
  __int32 v21 = (float *)(v15 + 16 * v7);
  float v63 = v21[1];
  float v64 = *v21;
  float v62 = v21[3];
  __float2 v22 = __sincosf_stret(v16[3]);
  __float2 v23 = __sincosf_stret(v20);
  float v24 = *(float *)(a1 + 140) - *(float *)&v8;
  float v25 = *(float *)(a1 + 144) - *((float *)&v8 + 1);
  float v26 = (float)(v22.__cosval * v24) - (float)(v22.__sinval * v25);
  float v27 = (float)(v22.__cosval * v25) + (float)(v22.__sinval * v24);
  *(float *)(a1 + 184) = v26;
  *(float *)(a1 + 188) = v27;
  float v28 = *(float *)(a1 + 148) - *(float *)&v9;
  float v29 = *(float *)(a1 + 152) - *((float *)&v9 + 1);
  float v30 = (float)(v23.__cosval * v28) - (float)(v23.__sinval * v29);
  float v31 = (float)(v23.__cosval * v29) + (float)(v23.__sinval * v28);
  *(float *)(a1 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v30;
  *(float *)(a1 + 196) = v31;
  float v32 = (float)((float)(v59 + v30) - v60) - v26;
  float v33 = (float)((float)(v19 + v31) - v61) - v27;
  float v34 = sqrtf((float)(v33 * v33) + (float)(v32 * v32));
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  if (v34 > 0.0045)
  {
    float v36 = v32 * (float)(1.0 / v34);
    float v37 = v33 * (float)(1.0 / v34);
  }
  *(float *)(a1 + 176) = v36;
  *(float *)(a1 + 180) = v37;
  float v38 = (float)(v11
              + (float)(v10
                      + (float)((float)(v12 * (float)((float)(v26 * v37) - (float)(v27 * v36)))
                              * (float)((float)(v26 * v37) - (float)(v27 * v36)))))
      + (float)((float)(v13 * (float)((float)(v30 * v37) - (float)(v31 * v36)))
              * (float)((float)(v30 * v37) - (float)(v31 * v36)));
  float v39 = 1.0 / v38;
  if (v38 == 0.0) {
    float v39 = 0.0;
  }
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v39;
  float v40 = *(float *)(a1 + 128);
  float v41 = 0.0;
  if (v40 > 0.0)
  {
    float v42 = v34 - *(float *)(a1 + 164);
    float v43 = (float)(v40 * 6.2832) * (float)((float)(v39 + v39) * *(float *)(a1 + 132));
    float v44 = (float)(v40 * 6.2832) * (float)((float)(v40 * 6.2832) * v39);
    float v45 = *(float *)a2 * (float)(v43 + (float)(*(float *)a2 * v44));
    if (v45 == 0.0) {
      float v35 = 0.0;
    }
    else {
      float v35 = 1.0 / v45;
    }
    float v41 = (float)(v44 * (float)(v42 * *(float *)a2)) * v35;
    float v46 = v38 + v35;
    float v47 = 1.0 / (float)(v38 + v35);
    if (v46 == 0.0) {
      float v48 = 0.0;
    }
    else {
      float v48 = v47;
    }
    *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v48;
  }
  *(float *)(a1 + 156) = v35;
  *(float *)(a1 + 136) = v41;
  if (*(unsigned char *)(a2 + 20))
  {
    float v49 = *(float *)(a2 + 8) * *(float *)(a1 + 160);
    *(float *)(a1 + 160) = v49;
    float v50 = v36 * v49;
    float v51 = v37 * v49;
    float v52 = v65 - (float)(v10 * v50);
    float v53 = v67 - (float)(v10 * v51);
    float v54 = v66 - (float)(v12 * (float)((float)(v50 * (float)-v27) + (float)(v26 * v51)));
    float v55 = v64 + (float)(v11 * v50);
    float v56 = v63 + (float)(v11 * v51);
    float v57 = v62 + (float)(v13 * (float)((float)(v50 * (float)-v31) + (float)(v30 * v51)));
  }
  else
  {
    *(_DWORD *)(a1 + 160) = 0;
    float v54 = v66;
    float v53 = v67;
    float v55 = v64;
    float v52 = v65;
    float v57 = v62;
    float v56 = v63;
  }
  float *v17 = v52;
  v17[1] = v53;
  v17[3] = v54;
  float32x2_t v58 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 172));
  *float32x2_t v58 = v55;
  v58[1] = v56;
  v58[3] = v57;
}

float b2DistanceJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = (float *)(v2 + 16 * *(int *)(a1 + 168));
  float v4 = *v3;
  float v5 = v3[1];
  float v6 = v3[3];
  uint64_t v7 = (float *)(v2 + 16 * *(int *)(a1 + 172));
  float v8 = *v7;
  float v9 = v7[1];
  float v10 = v7[3];
  float v12 = *(float *)(a1 + 184);
  float v11 = *(float *)(a1 + 188);
  float v14 = *(float *)(a1 + 192);
  float v13 = *(float *)(a1 + 196);
  float v15 = *(float *)(a1 + 176);
  float v16 = *(float *)(a1 + 180);
  float v17 = *(float *)(a1 + 160);
  float v18 = -(float)(*(float *)(a1 + 232)
               * (float)((float)(*(float *)(a1 + 136)
                               + (float)((float)(v16
                                               * (float)((float)(v9 + (float)(v10 * v14))
                                                       - (float)(v5 + (float)(v6 * v12))))
                                       + (float)(v15
                                               * (float)((float)(*v7 - (float)(v10 * v13))
                                                       - (float)(*v3 - (float)(v6 * v11))))))
                       + (float)(*(float *)(a1 + 156) * v17)));
  *(float *)(a1 + 160) = v17
                       - (float)(*(float *)(a1 + 232)
                               * (float)((float)(*(float *)(a1 + 136)
                                               + (float)((float)(v16
                                                               * (float)((float)(v9 + (float)(v10 * v14))
                                                                       - (float)(v5 + (float)(v6 * v12))))
                                                       + (float)(v15
                                                               * (float)((float)(*v7 - (float)(v10 * v13))
                                                                       - (float)(*v3 - (float)(v6 * v11))))))
                                       + (float)(*(float *)(a1 + 156) * v17)));
  float v19 = v15 * v18;
  float v20 = v16 * v18;
  float v21 = *(float *)(a1 + 216);
  float v22 = *(float *)(a1 + 220);
  float result = v4 - (float)(v21 * v19);
  float v24 = v6 - (float)(*(float *)(a1 + 224) * (float)((float)(v12 * v20) - (float)(v11 * v19)));
  float v25 = v10 + (float)(*(float *)(a1 + 228) * (float)((float)(v14 * v20) - (float)(v13 * v19)));
  *uint64_t v3 = result;
  v3[1] = v5 - (float)(v21 * v20);
  v3[3] = v24;
  float v26 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 172));
  *float v26 = v8 + (float)(v19 * v22);
  v26[1] = v9 + (float)(v20 * v22);
  v26[3] = v25;
  return result;
}

BOOL b2DistanceJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  if (*(float *)(a1 + 128) > 0.0) {
    return 1;
  }
  uint64_t v5 = *(void *)(a2 + 24);
  float v6 = (float *)(v5 + 16 * *(int *)(a1 + 168));
  float v8 = *v6;
  float v7 = v6[1];
  float v9 = v6[3];
  float v10 = (float *)(v5 + 16 * *(int *)(a1 + 172));
  float v11 = *v10;
  float v12 = v10[1];
  float v13 = v10[3];
  __float2 v14 = __sincosf_stret(v9);
  __float2 v15 = __sincosf_stret(v13);
  float v16 = *(float *)(a1 + 140) - *(float *)(a1 + 200);
  float v17 = *(float *)(a1 + 144) - *(float *)(a1 + 204);
  float v18 = (float)(v14.__cosval * v16) - (float)(v14.__sinval * v17);
  float v19 = (float)(v14.__cosval * v17) + (float)(v14.__sinval * v16);
  float v20 = *(float *)(a1 + 148) - *(float *)(a1 + 208);
  float v21 = *(float *)(a1 + 152) - *(float *)(a1 + 212);
  float v22 = (float)(v15.__cosval * v20) - (float)(v15.__sinval * v21);
  float v23 = (float)(v15.__cosval * v21) + (float)(v15.__sinval * v20);
  float v24 = (float)((float)(v11 + v22) - v8) - v18;
  float v25 = (float)((float)(v12 + v23) - v7) - v19;
  float v26 = sqrtf((float)(v25 * v25) + (float)(v24 * v24));
  if (v26 >= 0.00000011921)
  {
    float v24 = v24 * (float)(1.0 / v26);
    float v25 = v25 * (float)(1.0 / v26);
  }
  else
  {
    float v26 = 0.0;
  }
  float v27 = fminf(v26 - *(float *)(a1 + 164), 0.2);
  if (v27 < -0.2) {
    float v27 = -0.2;
  }
  float v28 = *(float *)(a1 + 228);
  float v29 = -(float)(*(float *)(a1 + 232) * v27);
  float v30 = v24 * v29;
  float v31 = v25 * v29;
  float v32 = *(float *)(a1 + 216);
  float v33 = *(float *)(a1 + 220);
  float v34 = v9 - (float)(*(float *)(a1 + 224) * (float)((float)(v18 * v31) - (float)(v19 * v30)));
  float *v6 = v8 - (float)(v32 * v30);
  v6[1] = v7 - (float)(v32 * v31);
  v6[3] = v34;
  float v35 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 172));
  float *v35 = v11 + (float)(v33 * v30);
  v35[1] = v12 + (float)(v33 * v31);
  v35[3] = v13 + (float)(v28 * (float)((float)(v22 * v31) - (float)(v23 * v30)));
  float v36 = -v27;
  if (v27 > 0.0) {
    float v36 = v27;
  }
  return v36 < 0.0045;
}

float b2DistanceJoint::GetAnchorA(b2DistanceJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var14.x)
               - (float)(this->var6->var8.var1.var0 * this->var14.y));
}

float b2DistanceJoint::GetAnchorB(b2DistanceJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var15.x)
               - (float)(this->var7->var8.var1.var0 * this->var15.y));
}

float b2DistanceJoint::GetReactionForce(b2DistanceJoint *this, float a2)
{
  return this->var21.x * (float)(this->var17 * a2);
}

double b2DistanceJoint::GetReactionTorque(b2DistanceJoint *this, float a2)
{
  return 0.0;
}

void b2DistanceJoint::~b2DistanceJoint(b2DistanceJoint *this)
{
}

float b2FrictionJointDef::Initialize(b2FrictionJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4)
{
  *((void *)this + b2DynamicTree::~b2DynamicTree(this + 2) = a2;
  *((void *)this + 3) = a3;
  float v4 = a4->x - a2->var8.var0.x;
  float v5 = a4->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  *((float *)this + 9) = (float)(v5 * var0) + (float)(var1 * v4);
  *((float *)this + 10) = (float)(var1 * v5) - (float)(var0 * v4);
  float v8 = a4->x - a3->var8.var0.x;
  float v9 = a4->y - a3->var8.var0.y;
  float v11 = a3->var8.var1.var0;
  float v10 = a3->var8.var1.var1;
  float v12 = (float)(v9 * v11) + (float)(v10 * v8);
  float result = (float)(v10 * v9) - (float)(v11 * v8);
  *((float *)this + 11) = v12;
  *((float *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = result;
  return result;
}

void b2FrictionJoint::b2FrictionJoint(b2FrictionJoint *this, const b2FrictionJointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(void *)uint64_t v3 = &unk_26C3F3908;
  *(void *)(v3 + 128) = *(void *)((char *)a2 + 36);
  *(void *)(v3 + 136) = *(void *)((char *)a2 + 44);
  *(void *)(v3 + 144) = 0;
  *(_DWORD *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 156) = *(void *)((char *)a2 + 52);
}

void b2FrictionJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 164) = v6;
  *(_DWORD *)(a1 + 168) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 188) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 196) = v9;
  float v48 = *(float *)(v5 + 212);
  float v49 = *(float *)(v4 + 212);
  *(float *)(a1 + 204) = v49;
  *(float *)(a1 + 208) = v48;
  float v10 = *(float *)(v4 + 224);
  float v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v10;
  *(float *)(a1 + 216) = v11;
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = *(void *)(a2 + 32);
  float v14 = *(float *)(v12 + 16 * v6 + 12);
  __float2 v15 = (float32x2_t *)(v13 + 16 * v6);
  float32x2_t v16 = *v15;
  float v17 = v15[1].f32[1];
  float v18 = *(float *)(v12 + 16 * v7 + 12);
  float v19 = (float32x2_t *)(v13 + 16 * v7);
  float32x2_t v50 = *v19;
  float v20 = v19[1].f32[1];
  __float2 v21 = __sincosf_stret(v14);
  __float2 v22 = __sincosf_stret(v18);
  float v23 = *(float *)(a1 + 128) - *(float *)&v8;
  float v24 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  float v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = _S2;
  *(float *)(a1 + 176) = v26;
  float v27 = *(float *)(a1 + 136) - *(float *)&v9;
  float v28 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  float v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  *(float *)(a1 + 180) = _S3;
  *(float *)(a1 + 184) = v30;
  float v31 = (float)((float)(v49 + v48) + (float)((float)(v10 * v26) * v26)) + (float)((float)(v11 * v30) * v30);
  float v32 = (float)(v30 * (float)-(float)(v11 * _S3)) + (float)((float)-(float)(v10 * _S2) * v26);
  float v33 = (float)((float)(v49 + v48) + (float)((float)(v10 * _S2) * _S2)) + (float)((float)(v11 * _S3) * _S3);
  float v34 = (float)(v31 * v33) - (float)(v32 * v32);
  if (v34 != 0.0) {
    float v34 = 1.0 / v34;
  }
  float v35 = -(float)(v34 * v32);
  *(float *)(a1 + 220) = v33 * v34;
  *(float *)(a1 + 224) = v35;
  *(float *)(a1 + 228) = v35;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v31 * v34;
  float v36 = v10 + v11;
  if ((float)(v10 + v11) > 0.0) {
    float v36 = 1.0 / (float)(v10 + v11);
  }
  *(float *)(a1 + 236) = v36;
  if (*(unsigned char *)(a2 + 20))
  {
    float v37 = *(float *)(a2 + 8);
    float v38 = v37 * *(float *)(a1 + 152);
    *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v38;
    _D5 = vmul_n_f32(*(float32x2_t *)(a1 + 144), v37);
    *(float32x2_t *)(a1 + 144) = _D5;
    float32x2_t v16 = vsub_f32(v16, vmul_n_f32(_D5, v49));
    __asm { FMLA            S4, S2, V5.S[1] }
    float v17 = v17 + (float)((float)-v10 * (float)(v38 + _S4));
    __asm { FMLA            S0, S3, V5.S[1] }
    float v20 = v20 + (float)(v11 * (float)(v38 + _S0));
    float32x2_t v46 = vadd_f32(v50, vmul_n_f32(_D5, v48));
  }
  else
  {
    *(void *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    float32x2_t v46 = v50;
  }
  *__float2 v15 = v16;
  v15[1].f32[1] = v17;
  uint64_t v47 = *(void *)(a2 + 32) + 16 * *(int *)(a1 + 168);
  *(float32x2_t *)uint64_t v47 = v46;
  *(float *)(v47 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v20;
}

float b2FrictionJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = (float *)(v2 + 16 * *(int *)(a1 + 164));
  float v5 = *v3;
  float v4 = v3[1];
  float v6 = v3[3];
  uint64_t v7 = (float *)(v2 + 16 * *(int *)(a1 + 168));
  float v9 = *v7;
  float v8 = v7[1];
  float v10 = v7[3];
  float v12 = *(float *)(a1 + 212);
  float v11 = *(float *)(a1 + 216);
  float v13 = *(float *)a2;
  float v14 = *(float *)(a1 + 156);
  float v15 = *(float *)a2 * *(float *)(a1 + 160);
  float v16 = *(float *)(a1 + 152);
  float v17 = v16 - (float)((float)(v10 - v6) * *(float *)(a1 + 236));
  if (v17 >= v15) {
    float v17 = *(float *)a2 * *(float *)(a1 + 160);
  }
  if (v17 < (float)-v15) {
    float v17 = -v15;
  }
  *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v17;
  float v18 = v17 - v16;
  float v19 = v6 - (float)(v12 * v18);
  float v20 = v10 + (float)(v11 * v18);
  float v21 = *(float *)(a1 + 180);
  float v22 = *(float *)(a1 + 184);
  float v23 = *(float *)(a1 + 172);
  float v24 = *(float *)(a1 + 176);
  float v25 = (float)(v24 * v19) + (float)((float)(v9 - (float)(v22 * v20)) - v5);
  float v26 = (float)((float)(v8 + (float)(v21 * v20)) - v4) - (float)(v23 * v19);
  float v27 = (float)(*(float *)(a1 + 228) * v26) + (float)(*(float *)(a1 + 220) * v25);
  float v29 = *(float *)(a1 + 204);
  float v28 = *(float *)(a1 + 208);
  float v30 = -v12;
  float v31 = (float)(*(float *)(a1 + 232) * v26) + (float)(*(float *)(a1 + 224) * v25);
  float v32 = *(float *)(a1 + 144);
  float v33 = *(float *)(a1 + 148);
  float v34 = v32 - v27;
  float v35 = v33 - v31;
  *(float *)(a1 + 144) = v32 - v27;
  *(float *)(a1 + 148) = v35;
  float v36 = v13 * v14;
  float v37 = (float)(v35 * v35) + (float)(v34 * v34);
  if (v37 > (float)(v36 * v36))
  {
    float v38 = sqrtf(v37);
    if (v38 >= 0.00000011921)
    {
      float v39 = 1.0 / v38;
      float v34 = v34 * v39;
      float v35 = v35 * v39;
    }
    float v34 = v36 * v34;
    float v35 = v36 * v35;
    *(float *)(a1 + 144) = v34;
    *(float *)(a1 + 148) = v35;
  }
  float result = v8 + (float)(v28 * (float)(v35 - v33));
  *uint64_t v3 = v5 - (float)(v29 * (float)(v34 - v32));
  v3[1] = v4 - (float)(v29 * (float)(v35 - v33));
  v3[3] = v19 + (float)(v30 * (float)((float)(v23 * (float)(v35 - v33)) - (float)(v24 * (float)(v34 - v32))));
  float v41 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 168));
  *float v41 = v9 + (float)(v28 * (float)(v34 - v32));
  v41[1] = result;
  v41[3] = v20 + (float)(v11 * (float)((float)(v21 * (float)(v35 - v33)) - (float)(v22 * (float)(v34 - v32))));
  return result;
}

uint64_t b2FrictionJoint::SolvePositionConstraints()
{
  return 1;
}

float b2FrictionJoint::GetAnchorA(b2FrictionJoint *this)
{
  return *(float *)(*((void *)this + 12) + 32)
       + (float)((float)(*(float *)(*((void *)this + 12) + 44) * *((float *)this + 32))
               - (float)(*(float *)(*((void *)this + 12) + 40) * *((float *)this + 33)));
}

float b2FrictionJoint::GetAnchorB(b2FrictionJoint *this)
{
  return *(float *)(*((void *)this + 13) + 32)
       + (float)((float)(*(float *)(*((void *)this + 13) + 44) * *((float *)this + 34))
               - (float)(*(float *)(*((void *)this + 13) + 40) * *((float *)this + 35)));
}

float b2FrictionJoint::GetReactionForce(b2FrictionJoint *this, float a2)
{
  return *((float *)this + 36) * a2;
}

float b2FrictionJoint::GetReactionTorque(b2FrictionJoint *this, float a2)
{
  return *((float *)this + 38) * a2;
}

uint64_t b2FrictionJoint::SetMaxForce(uint64_t this, float a2)
{
  if (a2 >= 0.0)
  {
    BOOL v2 = a2 == -INFINITY;
    BOOL v3 = a2 < -INFINITY;
  }
  else
  {
    BOOL v2 = 1;
    BOOL v3 = 0;
  }
  if (v3 || v2 || a2 >= INFINITY) {
    b2FrictionJoint::SetMaxForce();
  }
  *(float *)(this + 156) = a2;
  return this;
}

float b2FrictionJoint::GetMaxForce(b2FrictionJoint *this)
{
  return *((float *)this + 39);
}

uint64_t b2FrictionJoint::SetMaxTorque(uint64_t this, float a2)
{
  if (a2 >= 0.0)
  {
    BOOL v2 = a2 == -INFINITY;
    BOOL v3 = a2 < -INFINITY;
  }
  else
  {
    BOOL v2 = 1;
    BOOL v3 = 0;
  }
  if (v3 || v2 || a2 >= INFINITY) {
    b2FrictionJoint::SetMaxTorque();
  }
  *(float *)(this + 160) = a2;
  return this;
}

float b2FrictionJoint::GetMaxTorque(b2FrictionJoint *this)
{
  return *((float *)this + 40);
}

void b2FrictionJoint::~b2FrictionJoint(b2FrictionJoint *this)
{
}

float b2GearJoint::b2GearJoint(b2Joint *a1, uint64_t a2)
{
  b2Joint::b2Joint(a1, (const b2JointDef *)a2);
  *(void *)uint64_t v3 = &unk_26C3F3390;
  uint64_t v4 = *(void *)(a2 + 40);
  int v5 = *(_DWORD *)(v4 + 8);
  int v6 = *(_DWORD *)(*(void *)(a2 + 48) + 8);
  *(_DWORD *)(v3 + 128) = v5;
  *(_DWORD *)(v3 + 13b2DynamicTree::~b2DynamicTree(this + 2) = v6;
  if ((v5 - 1) >= 2) {
    b2GearJoint::b2GearJoint();
  }
  if ((v6 - 1) >= 2) {
    b2GearJoint::b2GearJoint();
  }
  uint64_t v7 = *(float **)(v4 + 96);
  float v8 = *(float **)(v4 + 104);
  *(void *)(v3 + 136) = v7;
  *(void *)(v3 + 96) = v8;
  if (v5 == 1)
  {
    float v9 = v8[27];
    float v10 = v7[27];
    *(void *)(v3 + 168) = *(void *)(v4 + 128);
    *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = *(void *)(v4 + 136);
    float v11 = *(float *)(v4 + 176);
    *(float *)(v3 + 200) = v11;
    *(void *)(v3 + 184) = 0;
    float v12 = (float)(v9 - v10) - v11;
  }
  else
  {
    float v14 = v7[10];
    float v13 = v7[11];
    float v16 = v7[8];
    float v15 = v7[9];
    float v18 = v8[10];
    float v17 = v8[11];
    float v20 = v8[8];
    float v19 = v8[9];
    unint64_t v21 = *(void *)(v4 + 128);
    *(void *)(v3 + 168) = v21;
    unint64_t v22 = HIDWORD(v21);
    float v23 = *(float *)&v21;
    uint64_t v24 = *(void *)(v4 + 136);
    *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v24;
    *(_DWORD *)(v3 + 200) = *(_DWORD *)(v4 + 160);
    uint64_t v25 = *(void *)(v4 + 144);
    *(void *)(v3 + 184) = v25;
    float v26 = (float)(v20 - v16) + (float)((float)(v17 * *(float *)&v24) - (float)(v18 * *((float *)&v24 + 1)));
    float v27 = (float)(v19 - v15) + (float)((float)(v17 * *((float *)&v24 + 1)) + (float)(v18 * *(float *)&v24));
    float v12 = (float)((float)((float)((float)(v13 * v27) - (float)(v14 * v26)) - *(float *)&v22) * *((float *)&v25 + 1))
        + (float)((float)((float)((float)(v14 * v27) + (float)(v13 * v26)) - v23) * *(float *)&v25);
  }
  uint64_t v28 = *(void *)(a2 + 48);
  float v29 = *(float **)(v28 + 96);
  float v30 = *(float **)(v28 + 104);
  *(void *)(v3 + 144) = v29;
  *(void *)(v3 + 104) = v30;
  if (v6 == 1)
  {
    float v31 = v30[27];
    float v32 = v29[27];
    *(void *)(v3 + 176) = *(void *)(v28 + 128);
    *(void *)(v3 + 160) = *(void *)(v28 + 136);
    float v33 = *(float *)(v28 + 176);
    *(float *)(v3 + 204) = v33;
    *(void *)(v3 + 19b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    float v34 = (float)(v31 - v32) - v33;
  }
  else
  {
    float v36 = v29[10];
    float v35 = v29[11];
    float v38 = v29[8];
    float v37 = v29[9];
    float v40 = v30[10];
    float v39 = v30[11];
    float v42 = v30[8];
    float v41 = v30[9];
    unint64_t v43 = *(void *)(v28 + 128);
    *(void *)(v3 + 176) = v43;
    unint64_t v44 = HIDWORD(v43);
    float v45 = *(float *)&v43;
    uint64_t v46 = *(void *)(v28 + 136);
    *(void *)(v3 + 160) = v46;
    *(_DWORD *)(v3 + 204) = *(_DWORD *)(v28 + 160);
    uint64_t v47 = *(void *)(v28 + 144);
    *(void *)(v3 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v47;
    float v48 = (float)(v42 - v38) + (float)((float)(v39 * *(float *)&v46) - (float)(v40 * *((float *)&v46 + 1)));
    float v49 = (float)(v41 - v37) + (float)((float)(v39 * *((float *)&v46 + 1)) + (float)(v40 * *(float *)&v46));
    float v34 = (float)((float)((float)((float)(v35 * v49) - (float)(v36 * v48)) - *(float *)&v44) * *((float *)&v47 + 1))
        + (float)((float)((float)((float)(v36 * v49) + (float)(v35 * v48)) - v45) * *(float *)&v47);
  }
  float v50 = *(float *)(a2 + 56);
  float result = v12 + (float)(v50 * v34);
  *(float *)(v3 + 208) = result;
  *(float *)(v3 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v50;
  *(_DWORD *)(v3 + 216) = 0;
  return result;
}

float b2GearJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 220) = v6;
  *(_DWORD *)(a1 + 224) = v7;
  uint64_t v8 = *(void *)(a1 + 136);
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = *(int *)(v8 + 28);
  uint64_t v11 = *(int *)(v9 + 28);
  *(_DWORD *)(a1 + 228) = v10;
  *(_DWORD *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v11;
  *(void *)(a1 + 236) = *(void *)(v4 + 64);
  *(void *)(a1 + 244) = *(void *)(v5 + 64);
  uint64_t v12 = *(void *)(v8 + 64);
  *(void *)(a1 + 25b2DynamicTree::~b2DynamicTree(this + 2) = v12;
  uint64_t v13 = *(void *)(v9 + 64);
  *(void *)(a1 + 260) = v13;
  float v85 = *(float *)(v4 + 212);
  *(float *)(a1 + 268) = v85;
  float v14 = *(float *)(v5 + 212);
  *(float *)(a1 + 27b2DynamicTree::~b2DynamicTree(this + 2) = v14;
  float v15 = *(float *)(v8 + 212);
  *(float *)(a1 + 276) = v15;
  float v87 = *(float *)(v9 + 212);
  *(float *)(a1 + 280) = v87;
  float v16 = *(float *)(v4 + 224);
  *(float *)(a1 + 284) = v16;
  float v17 = *(float *)(v5 + 224);
  *(float *)(a1 + 288) = v17;
  float v18 = *(float *)(v8 + 224);
  *(float *)(a1 + 29b2DynamicTree::~b2DynamicTree(this + 2) = v18;
  float v86 = *(float *)(v9 + 224);
  *(float *)(a1 + 296) = v86;
  uint64_t v20 = *(void *)(a2 + 24);
  uint64_t v19 = *(void *)(a2 + 32);
  unint64_t v21 = (float *)(v19 + 16 * v6);
  float v90 = v21[1];
  float v91 = *v21;
  unint64_t v22 = (float *)(v19 + 16 * v7);
  float v24 = *v22;
  float v23 = v22[1];
  float v88 = v21[3];
  float v89 = v22[3];
  uint64_t v25 = (float *)(v19 + 16 * v10);
  float v92 = v23;
  float v93 = v25[1];
  float v26 = v25[3];
  float v27 = *(float *)(v20 + 16 * v11 + 12);
  uint64_t v28 = (float *)(v19 + 16 * v11);
  float v96 = v28[1];
  float v97 = *v28;
  float v94 = *v25;
  float v95 = v28[3];
  __float2 v29 = __sincosf_stret(*(float *)(v20 + 16 * v7 + 12));
  __float2 v30 = __sincosf_stret(v27);
  float cosval = v30.__cosval;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    float v32 = v16 + v18;
    float v33 = 1.0;
    float v34 = 0.0;
    float v35 = 0.0;
    float v36 = 1.0;
    float v38 = v86;
    float v37 = v87;
    float v39 = v15;
    float v40 = v85;
  }
  else
  {
    float v84 = v17;
    float v41 = v14;
    float v42 = *(float *)(v20 + 16 * v6 + 12);
    __float2 v43 = __sincosf_stret(*(float *)(v20 + 16 * v10 + 12));
    float v44 = v42;
    float v14 = v41;
    float v17 = v84;
    __float2 v45 = __sincosf_stret(v44);
    float cosval = v30.__cosval;
    float v46 = *(float *)(a1 + 184);
    float v47 = *(float *)(a1 + 188);
    float v34 = (float)(v43.__cosval * v46) - (float)(v43.__sinval * v47);
    float v35 = (float)(v43.__cosval * v47) + (float)(v43.__sinval * v46);
    float v48 = *(float *)(a1 + 168) - *(float *)&v12;
    float v49 = *(float *)(a1 + 172) - *((float *)&v12 + 1);
    float v50 = (float)(v43.__cosval * v48) - (float)(v43.__sinval * v49);
    float v51 = (float)(v43.__cosval * v49) + (float)(v43.__sinval * v48);
    float v52 = *(float *)(a1 + 152) - *(float *)(a1 + 236);
    float v53 = *(float *)(a1 + 156) - *(float *)(a1 + 240);
    float v36 = (float)(v50 * v35) - (float)(v51 * v34);
    float v33 = (float)((float)((float)(v45.__cosval * v52) - (float)(v45.__sinval * v53)) * v35)
        - (float)((float)((float)(v45.__cosval * v53) + (float)(v45.__sinval * v52)) * v34);
    float v40 = v85;
    float v38 = v86;
    float v39 = v15;
    float v32 = (float)((float)(v85 + v15) + (float)((float)(v18 * v36) * v36)) + (float)((float)(v16 * v33) * v33);
    float v37 = v87;
  }
  *(float *)(a1 + 300) = v34;
  *(float *)(a1 + 304) = v35;
  *(float *)(a1 + 316) = v33;
  *(float *)(a1 + 324) = v36;
  float v54 = 0.0;
  float v55 = v32 + 0.0;
  if (*(_DWORD *)(a1 + 132) == 1)
  {
    *(_DWORD *)(a1 + 308) = 0;
    float v56 = *(float *)(a1 + 212);
    float v57 = v55 + (float)((float)(v56 * v56) * (float)(v17 + v38));
    float v58 = 0.0;
    float v59 = v56;
  }
  else
  {
    float v60 = *(float *)(a1 + 192);
    float v61 = *(float *)(a1 + 196);
    float v62 = (float)(cosval * v60) - (float)(v30.__sinval * v61);
    float v63 = (float)(cosval * v61) + (float)(v30.__sinval * v60);
    float v64 = *(float *)(a1 + 176) - *(float *)&v13;
    float v65 = *(float *)(a1 + 180) - *((float *)&v13 + 1);
    float v66 = (float)(cosval * v64) - (float)(v30.__sinval * v65);
    float v67 = (float)(cosval * v65) + (float)(v30.__sinval * v64);
    float v68 = *(float *)(a1 + 160) - *(float *)(a1 + 244);
    float v69 = *(float *)(a1 + 164) - *(float *)(a1 + 248);
    float v70 = (float)(v29.__cosval * v68) - (float)(v29.__sinval * v69);
    float v71 = (float)(v29.__cosval * v69) + (float)(v29.__sinval * v68);
    float v72 = *(float *)(a1 + 212);
    float v54 = v62 * v72;
    float v58 = v63 * v72;
    *(float *)(a1 + 308) = v62 * v72;
    float v59 = v72 * (float)((float)(v66 * v63) - (float)(v67 * v62));
    float v56 = v72 * (float)((float)(v70 * v63) - (float)(v71 * v62));
    float v57 = v55
        + (float)((float)((float)(v59 * (float)(v38 * v59)) + (float)((float)(v72 * v72) * (float)(v14 + v37)))
                + (float)((float)(v17 * v56) * v56));
  }
  float v74 = v89;
  float v73 = v90;
  float v75 = v88;
  *(float *)(a1 + 31b2DynamicTree::~b2DynamicTree(this + 2) = v58;
  *(float *)(a1 + 320) = v56;
  *(float *)(a1 + 328) = v59;
  float v76 = 1.0 / v57;
  BOOL v77 = v57 <= 0.0;
  float v78 = 0.0;
  if (!v77) {
    float v78 = v76;
  }
  *(float *)(a1 + 33b2DynamicTree::~b2DynamicTree(this + 2) = v78;
  if (*(unsigned char *)(a2 + 20))
  {
    float v79 = *(float *)(a1 + 216);
    float v73 = v90 + (float)((float)(v40 * v79) * v35);
    float v75 = v88 + (float)((float)(v16 * v79) * v33);
    float v24 = v24 + (float)((float)(v14 * v79) * v54);
    float v91 = v91 + (float)(v34 * (float)(v40 * v79));
    float v92 = v92 + (float)((float)(v14 * v79) * v58);
    float v74 = v89 + (float)((float)(v17 * v79) * v56);
    float v93 = v93 - (float)((float)(v39 * v79) * v35);
    float v94 = v94 - (float)(v34 * (float)(v39 * v79));
    float v26 = v26 + (float)((float)-(float)(v18 * v79) * v36);
    float v96 = v96 - (float)((float)(v37 * v79) * v58);
    float v97 = v97 - (float)((float)(v37 * v79) * v54);
    float v95 = v95 + (float)((float)-(float)(v38 * v79) * v59);
  }
  else
  {
    *(_DWORD *)(a1 + 216) = 0;
  }
  *unint64_t v21 = v91;
  v21[1] = v73;
  v21[3] = v75;
  int8x8_t v80 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 224));
  *int8x8_t v80 = v24;
  v80[1] = v92;
  v80[3] = v74;
  float32x2_t v81 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 228));
  float *v81 = v94;
  v81[1] = v93;
  v81[3] = v26;
  float32x2_t v82 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 232));
  *float32x2_t v82 = v97;
  v82[1] = v96;
  float result = v95;
  v82[3] = v95;
  return result;
}

float b2GearJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = (float *)(v2 + 16 * *(int *)(a1 + 224));
  float v4 = *v3;
  float v5 = v3[1];
  float v6 = v3[3];
  uint64_t v7 = (float *)(v2 + 16 * *(int *)(a1 + 228));
  float v8 = *v7;
  float v9 = v7[1];
  float v10 = v7[3];
  uint64_t v11 = (float *)(v2 + 16 * *(int *)(a1 + 220));
  float v12 = *v11;
  float v13 = v11[1];
  float v14 = v11[3];
  float v15 = (float *)(v2 + 16 * *(int *)(a1 + 232));
  float v16 = *v15;
  float v17 = v15[1];
  float v18 = v15[3];
  float v19 = *(float *)(a1 + 300);
  float v20 = *(float *)(a1 + 304);
  float v21 = *(float *)(a1 + 308);
  float v22 = *(float *)(a1 + 312);
  float v23 = *(float *)(a1 + 316);
  float v24 = *(float *)(a1 + 324);
  float v25 = *(float *)(a1 + 320);
  float v26 = *(float *)(a1 + 328);
  float v27 = -(float)(*(float *)(a1 + 332)
               * (float)((float)((float)((float)((float)(v13 - v9) * v20) + (float)(v19 * (float)(*v11 - *v7)))
                               + (float)((float)((float)(v5 - v17) * v22) + (float)(v21 * (float)(v4 - *v15))))
                       + (float)((float)((float)(v23 * v14) - (float)(v24 * v10))
                               + (float)((float)(v25 * v6) - (float)(v26 * v18)))));
  *(float *)(a1 + 216) = *(float *)(a1 + 216)
                       - (float)(*(float *)(a1 + 332)
                               * (float)((float)((float)((float)((float)(v13 - v9) * v20)
                                                       + (float)(v19 * (float)(*v11 - *v7)))
                                               + (float)((float)((float)(v5 - v17) * v22)
                                                       + (float)(v21 * (float)(v4 - *v15))))
                                       + (float)((float)((float)(v23 * v14) - (float)(v24 * v10))
                                               + (float)((float)(v25 * v6) - (float)(v26 * v18)))));
  float v28 = *(float *)(a1 + 268) * v27;
  float v29 = v14 + (float)((float)(*(float *)(a1 + 284) * v27) * v23);
  float v30 = v27 * *(float *)(a1 + 272);
  float result = v4 + (float)(v21 * v30);
  float v32 = v5 + (float)(v22 * v30);
  float v33 = v6 + (float)((float)(v27 * *(float *)(a1 + 288)) * v25);
  float v34 = v27 * *(float *)(a1 + 276);
  float v35 = v8 - (float)(v19 * v34);
  float v36 = v9 - (float)(v20 * v34);
  float v37 = v10 + (float)((float)-(float)(*(float *)(a1 + 292) * v27) * v24);
  float v38 = v27 * *(float *)(a1 + 280);
  float v39 = v18 + (float)((float)-(float)(*(float *)(a1 + 296) * v27) * v26);
  float *v11 = v12 + (float)(v19 * v28);
  v11[1] = v13 + (float)(v20 * v28);
  v11[3] = v29;
  float v40 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 224));
  float *v40 = result;
  v40[1] = v32;
  v40[3] = v33;
  float v41 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 228));
  *float v41 = v35;
  v41[1] = v36;
  v41[3] = v37;
  float v42 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 232));
  *float v42 = v16 - (float)(v21 * v38);
  v42[1] = v17 - (float)(v22 * v38);
  v42[3] = v39;
  return result;
}

uint64_t b2GearJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  float v5 = (float *)(v4 + 16 * *(int *)(a1 + 224));
  float v81 = v5[1];
  float v82 = *v5;
  float v6 = v5[3];
  uint64_t v7 = (float *)(v4 + 16 * *(int *)(a1 + 228));
  float v9 = *v7;
  float v8 = v7[1];
  float v10 = v7[3];
  uint64_t v11 = (float *)(v4 + 16 * *(int *)(a1 + 220));
  float v77 = v11[1];
  float v78 = *v11;
  float v12 = v11[3];
  float v13 = (float *)(v4 + 16 * *(int *)(a1 + 232));
  float v83 = v13[1];
  float v84 = *v13;
  float v14 = v13[3];
  __float2 v15 = __sincosf_stret(v6);
  __float2 v16 = __sincosf_stret(v14);
  float v80 = v12;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    float v17 = *(float *)(a1 + 284);
    float v18 = *(float *)(a1 + 292);
    float v19 = v17 + v18;
    float v20 = (float)(v12 - v10) - *(float *)(a1 + 200);
    float v21 = 1.0;
    float v22 = 0.0;
    float v23 = 0.0;
    float v24 = 1.0;
    float v26 = v77;
    float v25 = v78;
  }
  else
  {
    __float2 v27 = __sincosf_stret(v10);
    __float2 v28 = __sincosf_stret(v12);
    float v29 = *(float *)(a1 + 184);
    float v30 = *(float *)(a1 + 188);
    float v22 = (float)(v27.__cosval * v29) - (float)(v27.__sinval * v30);
    float v23 = (float)(v27.__cosval * v30) + (float)(v27.__sinval * v29);
    float v31 = *(float *)(a1 + 168) - *(float *)(a1 + 252);
    float v32 = *(float *)(a1 + 172) - *(float *)(a1 + 256);
    float v33 = *(float *)(a1 + 152) - *(float *)(a1 + 236);
    float v34 = *(float *)(a1 + 156) - *(float *)(a1 + 240);
    float v35 = (float)(v28.__cosval * v33) - (float)(v28.__sinval * v34);
    float v36 = (float)(v28.__cosval * v34) + (float)(v28.__sinval * v33);
    float v24 = (float)((float)((float)(v27.__cosval * v31) - (float)(v27.__sinval * v32)) * v23)
        - (float)((float)((float)(v27.__cosval * v32) + (float)(v27.__sinval * v31)) * v22);
    float v21 = (float)(v35 * v23) - (float)(v36 * v22);
    float v18 = *(float *)(a1 + 292);
    float v17 = *(float *)(a1 + 284);
    float v19 = (float)((float)(*(float *)(a1 + 276) + *(float *)(a1 + 268)) + (float)((float)(v24 * v18) * v24))
        + (float)((float)(v17 * v21) * v21);
    float v26 = v77;
    float v25 = v78;
    float v20 = (float)(v30
                * (float)((float)((float)(v27.__cosval * (float)((float)(v77 - v8) + v36))
                                - (float)(v27.__sinval * (float)((float)(v78 - v9) + v35)))
                        - v32))
        + (float)((float)((float)((float)(v27.__sinval * (float)((float)(v77 - v8) + v36))
                                + (float)(v27.__cosval * (float)((float)(v78 - v9) + v35)))
                        - v31)
                * v29);
  }
  float v37 = 0.0;
  float v38 = v19 + 0.0;
  if (*(_DWORD *)(a1 + 132) == 1)
  {
    float v39 = *(float *)(a1 + 212);
    float v40 = *(float *)(a1 + 288);
    float v41 = *(float *)(a1 + 296);
    float v42 = v38 + (float)((float)(v39 * v39) * (float)(v40 + v41));
    float v43 = (float)(v6 - v14) - *(float *)(a1 + 204);
    float v44 = 0.0;
    float v45 = v39;
    float v46 = v39;
  }
  else
  {
    float v47 = *(float *)(a1 + 192);
    float v48 = *(float *)(a1 + 196);
    float v49 = (float)(v16.__cosval * v47) - (float)(v16.__sinval * v48);
    float v50 = (float)(v16.__cosval * v48) + (float)(v16.__sinval * v47);
    float v79 = v8;
    float v51 = *(float *)(a1 + 176) - *(float *)(a1 + 260);
    float v52 = v20;
    float v53 = v25;
    float v54 = *(float *)(a1 + 180) - *(float *)(a1 + 264);
    float v55 = v18;
    float v56 = v26;
    float v57 = *(float *)(a1 + 160) - *(float *)(a1 + 244);
    float v58 = *(float *)(a1 + 164) - *(float *)(a1 + 248);
    float v59 = (float)(v15.__cosval * v57) - (float)(v15.__sinval * v58);
    float v60 = (float)(v15.__cosval * v58) + (float)(v15.__sinval * v57);
    float v39 = *(float *)(a1 + 212);
    float v37 = v49 * v39;
    float v44 = v50 * v39;
    float v46 = v39
        * (float)((float)((float)((float)(v16.__cosval * v51) - (float)(v16.__sinval * v54)) * v50)
                - (float)((float)((float)(v16.__cosval * v54) + (float)(v16.__sinval * v51)) * v49));
    float v45 = v39 * (float)((float)(v59 * v50) - (float)(v60 * v49));
    float v41 = *(float *)(a1 + 296);
    float v40 = *(float *)(a1 + 288);
    float v42 = v38
        + (float)((float)((float)(v46 * (float)(v46 * v41))
                        + (float)((float)(v39 * v39) * (float)(*(float *)(a1 + 280) + *(float *)(a1 + 272))))
                + (float)((float)(v40 * v45) * v45));
    float v61 = (float)(v82 - v84) + v59;
    float v62 = (float)(v81 - v83) + v60;
    float v63 = (float)(v16.__sinval * v62) + (float)(v16.__cosval * v61);
    float v64 = (float)((float)(v16.__cosval * v62) - (float)(v16.__sinval * v61)) - v54;
    float v26 = v56;
    float v18 = v55;
    float v65 = v48 * v64;
    float v25 = v53;
    float v20 = v52;
    float v43 = v65 + (float)((float)(v63 - v51) * v47);
    float v8 = v79;
  }
  float v66 = 0.0;
  if (v42 > 0.0) {
    float v66 = (float)-(float)((float)(v20 + (float)(v39 * v43)) - *(float *)(a1 + 208)) / v42;
  }
  float v67 = v66 * *(float *)(a1 + 268);
  float v68 = v80 + (float)((float)(v66 * v17) * v21);
  float v69 = v66 * *(float *)(a1 + 272);
  float v70 = v6 + (float)((float)(v66 * v40) * v45);
  float v71 = v66 * *(float *)(a1 + 276);
  float v72 = v66 * *(float *)(a1 + 280);
  float *v11 = v25 + (float)(v22 * v67);
  v11[1] = v26 + (float)(v23 * v67);
  v11[3] = v68;
  float v73 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 224));
  *float v73 = v82 + (float)(v37 * v69);
  v73[1] = v81 + (float)(v44 * v69);
  v73[3] = v70;
  float v74 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 228));
  float *v74 = v9 - (float)(v22 * v71);
  v74[1] = v8 - (float)(v23 * v71);
  v74[3] = v10 + (float)((float)-(float)(v18 * v66) * v24);
  float v75 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 232));
  float *v75 = v84 - (float)(v37 * v72);
  v75[1] = v83 - (float)(v44 * v72);
  v75[3] = v14 + (float)((float)-(float)(v41 * v66) * v46);
  return 1;
}

float b2GearJoint::GetAnchorA(b2GearJoint *this)
{
  return *(float *)(*((void *)this + 12) + 32)
       + (float)((float)(*(float *)(*((void *)this + 12) + 44) * *((float *)this + 38))
               - (float)(*(float *)(*((void *)this + 12) + 40) * *((float *)this + 39)));
}

float b2GearJoint::GetAnchorB(b2GearJoint *this)
{
  return *(float *)(*((void *)this + 13) + 32)
       + (float)((float)(*(float *)(*((void *)this + 13) + 44) * *((float *)this + 40))
               - (float)(*(float *)(*((void *)this + 13) + 40) * *((float *)this + 41)));
}

float b2GearJoint::GetReactionForce(b2GearJoint *this, float a2)
{
  return (float)(*((float *)this + 54) * *((float *)this + 75)) * a2;
}

float b2GearJoint::GetReactionTorque(b2GearJoint *this, float a2)
{
  return (float)(*((float *)this + 54) * *((float *)this + 79)) * a2;
}

uint64_t b2GearJoint::SetRatio(uint64_t this, float a2)
{
  if (a2 <= -INFINITY || a2 >= INFINITY) {
    b2GearJoint::SetRatio();
  }
  *(float *)(this + 21b2DynamicTree::~b2DynamicTree(this + 2) = a2;
  return this;
}

float b2GearJoint::GetRatio(b2GearJoint *this)
{
  return *((float *)this + 53);
}

void b2GearJoint::~b2GearJoint(b2GearJoint *this)
{
}

void b2QuadtreeAndChainContact::Create(b2QuadtreeAndChainContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_2135860C0(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndChainContact::b2QuadtreeAndChainContact(b2QuadtreeAndChainContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *float v5 = &unk_26C3F3E58;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 4) {
    b2QuadtreeAndChainContact::b2QuadtreeAndChainContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 3) {
    b2QuadtreeAndChainContact::b2QuadtreeAndChainContact();
  }
}

uint64_t b2QuadtreeAndChainContact::Evaluate()
{
  return puts("b2QuadtreeAndChainContact");
}

void b2QuadtreeAndCircleContact::Create(b2QuadtreeAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_2135861C8(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact(b2QuadtreeAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *float v5 = &unk_26C3F3EA8;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8)) {
    b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 4) {
    b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact();
  }
}

void b2QuadtreeAndCircleContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
  a2[7].i32[1] = 0;
  uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 32);
  float v7 = a3[2];
  float v6 = a3[3];
  float v8 = *(float *)(v5 + 16);
  float v9 = *(float *)(v5 + 20);
  float v10 = *a3 + (float)((float)(v6 * v8) - (float)(v7 * v9));
  uint64_t v11 = *(void *)(*(void *)(a1 + 88) + 32);
  float v12 = (float)((float)(v6 * v9) + (float)(v7 * v8)) + a3[1];
  float v13 = v10 - *a4;
  float v14 = v12 - a4[1];
  float v16 = a4[2];
  float v15 = a4[3];
  float v17 = (float)(v14 * v16) + (float)(v15 * v13);
  float v18 = (float)(v15 * v14) - (float)(v16 * v13);
  float v32 = 0;
  uint64_t v33 = 0;
  __p = 0;
  double v19 = v17;
  float v20 = v17 + -0.1;
  double v21 = v18;
  float v22 = v18 + -0.1;
  *(float *)&double v19 = v19 + 0.1;
  float v23 = v21 + 0.1;
  BOOL v24 = QuadTree::intersectBox(*(uint64_t **)(v11 + 16), (uint64_t)&__p, v20, v22, *(float *)&v19, v23);
  float v25 = (char *)__p;
  if (v24)
  {
    a2[7].i32[0] = 3;
    a2[6] = *(float32x2_t *)(v5 + 16);
    if ((unint64_t)(v32 - v25) <= 0x10) {
      uint64_t v26 = ((unint64_t)(v32 - v25) >> 3);
    }
    else {
      uint64_t v26 = 2;
    }
    a2[7].i32[1] = v26;
    if ((int)v26 >= 1)
    {
      __float2 v27 = a2 + 2;
      __float2 v28 = v25;
      do
      {
        uint64_t v29 = *(void *)v28;
        v28 += 8;
        v30.i32[0] = *(_DWORD *)(v29 + 32);
        v30.i32[1] = *(_DWORD *)(v29 + 44);
        v27[-2] = vmul_f32(vadd_f32(*(float32x2_t *)(v29 + 36), v30), (float32x2_t)0x3F0000003F000000);
        v27->i32[0] = 0;
        __float2 v27 = (float32x2_t *)((char *)v27 + 20);
        --v26;
      }
      while (v26);
    }
    a2[5] = 0;
  }
  if (v25)
  {
    float v32 = v25;
    operator delete(v25);
  }
}

void sub_2135863A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void b2QuadtreeAndEdgeContact::Create(b2QuadtreeAndEdgeContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_21358642C(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact(b2QuadtreeAndEdgeContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *uint64_t v5 = &unk_26C3F3E08;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 4) {
    b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 1) {
    b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact();
  }
}

uint64_t b2QuadtreeAndEdgeContact::Evaluate()
{
  return puts("b2QuadtreeAndEdgeContact");
}

void b2QuadtreeAndPolygonContact::Create(b2QuadtreeAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_213586534(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact(b2QuadtreeAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *uint64_t v5 = &unk_26C3F3ED0;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 4) {
    b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 2) {
    b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact();
  }
}

uint64_t b2QuadtreeAndPolygonContact::Evaluate()
{
  return puts("b2QuadtreeAndPolygonContact");
}

void b2QuadtreeAndQuadtreeContact::Create(b2QuadtreeAndQuadtreeContact *this, b2Fixture *a2, int a3, b2Fixture *a4)
{
}

void sub_21358663C(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact(b2QuadtreeAndQuadtreeContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *uint64_t v5 = &unk_26C3F3EF8;
  if (*(_DWORD *)(*(void *)(v5[10] + 32) + 8) != 4) {
    b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact();
  }
  if (*(_DWORD *)(*(void *)(v5[11] + 32) + 8) != 4) {
    b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact();
  }
}

uint64_t b2QuadtreeAndQuadtreeContact::Evaluate()
{
  return puts("b2QuadtreeAndQuadtreeContact");
}

void b2QuadtreeAndChainContact::~b2QuadtreeAndChainContact(b2QuadtreeAndChainContact *this)
{
}

void b2QuadtreeAndCircleContact::~b2QuadtreeAndCircleContact(b2QuadtreeAndCircleContact *this)
{
}

void b2QuadtreeAndEdgeContact::~b2QuadtreeAndEdgeContact(b2QuadtreeAndEdgeContact *this)
{
}

void b2QuadtreeAndPolygonContact::~b2QuadtreeAndPolygonContact(b2QuadtreeAndPolygonContact *this)
{
}

void b2QuadtreeAndQuadtreeContact::~b2QuadtreeAndQuadtreeContact(b2QuadtreeAndQuadtreeContact *this)
{
}

void b2Joint::Create(b2Joint *this, const b2JointDef *a2)
{
  switch(LODWORD(this->var0))
  {
    case 1:
      operator new();
    case 2:
      operator new();
    case 3:
      operator new();
    case 4:
      operator new();
    case 5:
      operator new();
    case 6:
      operator new();
    case 7:
      operator new();
    case 8:
      operator new();
    case 9:
      operator new();
    case 0xA:
      operator new();
    default:
      b2Joint::Create();
  }
}

void sub_213586930(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x10A1C406679337BLL);
  _Unwind_Resume(a1);
}

b2Joint *b2Joint::Destroy(b2Joint *this, b2Joint *a2)
{
  if (this) {
    return (b2Joint *)(*((uint64_t (**)(void))this->var0 + 5))();
  }
  return this;
}

void b2Joint::b2Joint(b2Joint *this, const b2JointDef *a2)
{
  this->float var0 = (void **)&unk_26C3F3F80;
  float var2 = a2->var2;
  var3 = a2->var3;
  if (var2 == var3) {
    b2Joint::b2Joint();
  }
  this->float var1 = a2->var0;
  this->float var2 = 0;
  this->var3 = 0;
  this->unsigned __int16 var6 = var2;
  this->var7 = var3;
  this->var9 = a2->var4;
  this->var8 = 0;
  this->var10 = a2->var1;
  *(_OWORD *)&this->var4.float var0 = 0u;
  *(_OWORD *)&this->var4.float var2 = 0u;
  *(_OWORD *)&this->var5.float var0 = 0u;
  *(_OWORD *)&this->var5.float var2 = 0u;
}

uint64_t b2Joint::IsActive(b2Joint *this)
{
  uint64_t result = b2Body::IsActive(this->var6);
  if (result)
  {
    var7 = this->var7;
    return b2Body::IsActive(var7);
  }
  return result;
}

b2Joint *b2Joint::SetCollideConnected(b2Joint *this, BOOL a2)
{
  if (this->var9 != a2)
  {
    uint64_t v2 = this;
    this->var9 = a2;
    if (!a2)
    {
      unsigned __int16 var6 = this->var6;
      if (var6)
      {
        uint64_t v4 = *(void *)&var6->var24;
        if (v4)
        {
          p_var19 = (b2ContactManager *)&var6->var17[443].var19;
          do
          {
            this = (b2Joint *)b2ContactManager::DestroyContact(p_var19, *(b2Contact **)(v4 + 8));
            uint64_t v4 = *(void *)&v2->var6->var24;
          }
          while (v4);
        }
      }
      var7 = v2->var7;
      if (var7)
      {
        uint64_t v7 = *(void *)&var7->var24;
        if (v7)
        {
          float v8 = (b2ContactManager *)&var7->var17[443].var19;
          do
          {
            this = (b2Joint *)b2ContactManager::DestroyContact(v8, *(b2Contact **)(v7 + 8));
            uint64_t v7 = *(void *)&v2->var7->var24;
          }
          while (v7);
        }
      }
    }
  }
  return this;
}

double b2MouseJoint::b2MouseJoint(b2Joint *a1, uint64_t a2)
{
  b2Joint::b2Joint(a1, (const b2JointDef *)a2);
  *(void *)uint64_t v3 = &unk_26C3F35A0;
  float v4 = *(float *)(a2 + 36);
  BOOL v5 = v4 > -INFINITY && v4 < INFINITY;
  if (!v5 || ((float v6 = *(float *)(a2 + 40), v6 > -INFINITY) ? (v7 = v6 < INFINITY) : (v7 = 0), !v7)) {
    b2MouseJoint::b2MouseJoint();
  }
  float v8 = *(float *)(a2 + 44);
  if (v8 < 0.0 || v8 <= -INFINITY || v8 >= INFINITY) {
    b2MouseJoint::b2MouseJoint();
  }
  float v9 = *(float *)(a2 + 48);
  if (v9 < 0.0 || v9 <= -INFINITY || v9 >= INFINITY) {
    b2MouseJoint::b2MouseJoint();
  }
  float v10 = *(float *)(a2 + 52);
  if (v10 < 0.0 || v10 <= -INFINITY || v10 >= INFINITY) {
    b2MouseJoint::b2MouseJoint();
  }
  unint64_t v11 = *(void *)(a2 + 36);
  *(void *)(v3 + 136) = v11;
  unint64_t v12 = HIDWORD(v11);
  float v13 = *(float *)&v11;
  float v14 = *(float **)(v3 + 104);
  float v15 = v13 - v14[8];
  float v16 = *(float *)&v12 - v14[9];
  float v18 = v14[10];
  float v17 = v14[11];
  *(float *)(v3 + 128) = (float)(v16 * v18) + (float)(v17 * v15);
  *(float *)(v3 + 13b2DynamicTree::~b2DynamicTree(this + 2) = (float)(v17 * v16) - (float)(v18 * v15);
  *(_DWORD *)(v3 + 164) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(v3 + 160) = 0;
  double result = *(double *)(a2 + 48);
  *(double *)(v3 + 144) = result;
  *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(_DWORD *)(v3 + 168) = 0;
  return result;
}

uint64_t b2MouseJoint::SetTarget(b2Body **this, b2Body **a2)
{
  uint64_t result = b2Body::IsAwake(this[13]);
  if ((result & 1) == 0) {
    uint64_t result = (uint64_t)b2Body::SetAwake(this[13], 1);
  }
  this[17] = *a2;
  return result;
}

uint64_t b2MouseJoint::GetTarget(b2MouseJoint *this)
{
  return (uint64_t)this + 136;
}

uint64_t b2MouseJoint::SetMaxForce(uint64_t this, float a2)
{
  *(float *)(this + 164) = a2;
  return this;
}

float b2MouseJoint::GetMaxForce(b2MouseJoint *this)
{
  return *((float *)this + 41);
}

uint64_t b2MouseJoint::SetFrequency(uint64_t this, float a2)
{
  *(float *)(this + 144) = a2;
  return this;
}

float b2MouseJoint::GetFrequency(b2MouseJoint *this)
{
  return *((float *)this + 36);
}

uint64_t b2MouseJoint::SetDampingRatio(uint64_t this, float a2)
{
  *(float *)(this + 148) = a2;
  return this;
}

float b2MouseJoint::GetDampingRatio(b2MouseJoint *this)
{
  return *((float *)this + 37);
}

void b2MouseJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = *(int *)(v2 + 28);
  *(_DWORD *)(a1 + 176) = v3;
  uint64_t v4 = *(void *)(v2 + 64);
  *(void *)(a1 + 188) = v4;
  float v5 = *(float *)(v2 + 224);
  float v6 = *(float *)(v2 + 208);
  float v7 = *(float *)(v2 + 212);
  *(float *)(a1 + 196) = v7;
  *(float *)(a1 + 200) = v5;
  float v8 = *(float *)(a1 + 144) * 6.2832;
  float v9 = v6 * (float)(v8 * v8);
  float v10 = *(float *)a2;
  float v11 = (float)(v8 * (float)((float)(v6 + v6) * *(float *)(a1 + 148))) + (float)(*(float *)a2 * v9);
  if (v11 <= 0.00000011921) {
    b2MouseJoint::InitVelocityConstraints();
  }
  uint64_t v14 = *(void *)(a2 + 32) + 16 * v3;
  float32x2_t v15 = *(float32x2_t *)v14;
  float v16 = *((float *)&v4 + 1);
  float v17 = *(float *)&v4;
  float v18 = (float *)(*(void *)(a2 + 24) + 16 * v3);
  float v43 = v7;
  __float2 v19 = __sincosf_stret(v18[3]);
  float v20 = *(float *)(v14 + 12);
  float v22 = *v18;
  float v21 = v18[1];
  float v23 = 1.0 / (float)(v10 * v11);
  if ((float)(v10 * v11) == 0.0) {
    float v23 = v10 * v11;
  }
  *(float *)(a1 + 168) = v23;
  float v24 = (float)(v10 * v9) * v23;
  *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v24;
  float v25 = *(float *)(a1 + 128) - v17;
  float v26 = *(float *)(a1 + 132) - v16;
  _S2 = (float)(v19.__cosval * v25) - (float)(v19.__sinval * v26);
  float v28 = (float)(v19.__cosval * v26) + (float)(v19.__sinval * v25);
  *(float *)(a1 + 180) = _S2;
  *(float *)(a1 + 184) = v28;
  float v29 = v23 + (float)(v43 + (float)((float)(v5 * v28) * v28));
  float v30 = v28 * (float)-(float)(v5 * _S2);
  float v31 = v23 + (float)(v43 + (float)((float)(v5 * _S2) * _S2));
  float v32 = (float)(v29 * v31) - (float)(v30 * v30);
  float v33 = 1.0 / v32;
  if (v32 == 0.0) {
    float v33 = (float)(v29 * v31) - (float)(v30 * v30);
  }
  float v34 = -(float)(v33 * v30);
  *(float *)(a1 + 204) = v31 * v33;
  *(float *)(a1 + 208) = v34;
  *(float *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v34;
  *(float *)(a1 + 216) = v29 * v33;
  float v35 = v24 * (float)((float)(v21 + v28) - *(float *)(a1 + 140));
  *(float *)(a1 + 220) = v24 * (float)((float)(v22 + _S2) - *(float *)(a1 + 136));
  *(float *)(a1 + 224) = v35;
  float v36 = v20 * 0.98;
  if (*(unsigned char *)(a2 + 20))
  {
    _D3 = vmul_n_f32(*(float32x2_t *)(a1 + 156), COERCE_FLOAT(*(void *)(a2 + 8)));
    *(float32x2_t *)(a1 + 156) = _D3;
    float32x2_t v15 = vadd_f32(v15, vmul_n_f32(_D3, v43));
    __asm { FMLA            S0, S2, V3.S[1] }
    float v36 = v36 + (float)(v5 * _S0);
  }
  else
  {
    *(_DWORD *)(a1 + 156) = 0;
    *(_DWORD *)(a1 + 160) = 0;
  }
  *(float32x2_t *)uint64_t v14 = v15;
  *(float *)(v14 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v36;
}

float b2MouseJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  float v3 = *v2;
  float v4 = v2[1];
  float v5 = v2[3];
  float v7 = *(float *)(a1 + 180);
  float v6 = *(float *)(a1 + 184);
  float v8 = *(float *)(a1 + 156);
  float v9 = *(float *)(a1 + 160);
  float v11 = *(float *)(a1 + 164);
  float v10 = *(float *)(a1 + 168);
  float v12 = (float)((float)(*v2 - (float)(v5 * v6)) + *(float *)(a1 + 220)) + (float)(v10 * v8);
  float v13 = (float)((float)(v4 + (float)(v5 * v7)) + *(float *)(a1 + 224)) + (float)(v10 * v9);
  float v14 = (float)-(float)(v13 * *(float *)(a1 + 212)) - (float)(*(float *)(a1 + 204) * v12);
  float v15 = (float)-(float)(v13 * *(float *)(a1 + 216)) - (float)(*(float *)(a1 + 208) * v12);
  float v16 = v14 + v8;
  float v17 = v9 + v15;
  *(float *)(a1 + 156) = v14 + v8;
  *(float *)(a1 + 160) = v17;
  float v18 = *(float *)a2 * v11;
  float v19 = (float)(v17 * v17) + (float)(v16 * v16);
  if (v19 > (float)(v18 * v18))
  {
    float v20 = v18 / sqrtf(v19);
    float v16 = v16 * v20;
    float v17 = v17 * v20;
    *(float *)(a1 + 156) = v16;
    *(float *)(a1 + 160) = v17;
  }
  float v21 = v16 - v8;
  float v22 = v17 - v9;
  float v23 = *(float *)(a1 + 196);
  float result = v3 + (float)(v21 * v23);
  float v25 = v5 + (float)(*(float *)(a1 + 200) * (float)((float)(v7 * v22) - (float)(v6 * v21)));
  float *v2 = result;
  v2[1] = v4 + (float)(v22 * v23);
  v2[3] = v25;
  return result;
}

uint64_t b2MouseJoint::SolvePositionConstraints()
{
  return 1;
}

float b2MouseJoint::GetAnchorA(b2MouseJoint *this)
{
  return *((float *)this + 34);
}

float b2MouseJoint::GetAnchorB(b2MouseJoint *this)
{
  return *(float *)(*((void *)this + 13) + 32)
       + (float)((float)(*(float *)(*((void *)this + 13) + 44) * *((float *)this + 32))
               - (float)(*(float *)(*((void *)this + 13) + 40) * *((float *)this + 33)));
}

float b2MouseJoint::GetReactionForce(b2MouseJoint *this, float a2)
{
  return *((float *)this + 39) * a2;
}

float b2MouseJoint::GetReactionTorque(b2MouseJoint *this, float a2)
{
  return a2 * 0.0;
}

void b2MouseJoint::~b2MouseJoint(b2MouseJoint *this)
{
}

void PKCGrid::PKCGrid(PKCGrid *this)
{
  *(void *)this = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
}

{
  *(void *)this = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 7b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
}

void PKCGrid::setGridSize(PKCGrid *this, int a2, int a3, int a4)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + b2DynamicTree::~b2DynamicTree(this + 2) = a4;
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  unint64_t v6 = a3 * a2;
  char v8 = 0;
  unint64_t v7 = v5 - v4;
  if (v6 <= v7)
  {
    if (v6 < v7) {
      *((void *)this + 6) = v4 + v6;
    }
  }
  else
  {
    std::vector<unsigned char>::__append((void *)this + 5, v6 - v7, &v8);
  }
}

void PKCGrid::setData(PKCGrid *this, const unsigned __int8 *a2, int a3, unsigned int a4)
{
  uint64_t v7 = *((void *)this + 5);
  char v8 = (void *)((char *)this + 40);
  uint64_t v9 = a4;
  unint64_t v10 = *((void *)this + 6) - v7;
  if (a4 <= v10)
  {
    if (a4 < v10) {
      *((void *)this + 6) = v7 + a4;
    }
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 5, a4 - v10);
  }
  if (a4)
  {
    uint64_t v11 = 0;
    do
    {
      *(unsigned char *)(*v8 + v11) = *a2;
      a2 += a3;
      ++v11;
    }
    while (v9 != v11);
  }
}

void PKCGrid::setVectorData(PKCGrid *this, const unsigned __int8 *a2, int a3, int a4)
{
  if (a3)
  {
    if (a4)
    {
      *(_DWORD *)this = a3;
      *((_DWORD *)this + 1) = a4;
      uint64_t v7 = (void *)((char *)this + 64);
      _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEm((uint64_t)this + 64, a4 * a3);
      if (a4 >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        int v12 = 3;
        float32x2_t v13 = (float32x2_t)vdup_n_s32(0x42FE0000u);
        __asm { FMOV            V2.2S, #-1.0 }
        float32x2_t v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
        do
        {
          uint64_t v20 = a3;
          uint64_t v21 = v10;
          int v22 = v12;
          if (a3 >= 1)
          {
            do
            {
              LOBYTE(v8) = a2[v22 - 3];
              BYTE4(v8) = a2[v22 - 2];
              v9.i8[0] = a2[v22 - 1];
              unsigned int v23 = 1123942400;
              v9.f32[0] = (float)v9.u32[0] / 127.0;
              LOBYTE(v23) = a2[v22];
              LODWORD(v24) = vadd_f32(v9, _D2).u32[0];
              v9.f32[1] = (float)v23;
              *(float32x2_t *)&long long v8 = vadd_f32(vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8(*(int8x8_t *)&v8, (int8x8_t)0xFF000000FFLL)), v13), _D2);
              float32x2_t v9 = vdiv_f32(v9, v19);
              HIDWORD(v24) = v9.i32[1];
              *((void *)&v8 + 1) = v24;
              *(_OWORD *)(*v7 + v21) = v8;
              v22 += 4;
              v21 += 16;
              --v20;
            }
            while (v20);
          }
          ++v11;
          v12 += 4 * a3;
          v10 += 16 * a3;
        }
        while (v11 != a4);
      }
    }
  }
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

PKCGrid *PKCGrid::tagPixelData(PKCGrid *this, float a2, const unsigned __int8 *a3, int a4, int a5)
{
  int v5 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    int v6 = *((_DWORD *)this + 1);
    if (v6 && v6 >= 1)
    {
      int v8 = 0;
      do
      {
        if (v5 >= 1)
        {
          uint64_t v9 = 0;
          int v10 = (~(int)(float)((float)((float)a5 * (float)v8) / (float)v6) + a5) * a4;
          do
          {
            *(unsigned char *)(*((void *)this + 5) + v8 * v5 + v9) = a3[4 * v10
                                                                + 3
                                                                + 4
                                                                * (int)(float)((float)((float)a4 * (float)(int)v9)
                                                                             / (float)v5)] > (int)(float)(a2 * 255.0);
            int v5 = *(_DWORD *)this;
            ++v9;
          }
          while ((int)v9 < *(_DWORD *)this);
          int v6 = *((_DWORD *)this + 1);
        }
        ++v8;
      }
      while (v8 < v6);
    }
  }
  return this;
}

uint64_t PKCGrid::traverse(PKCGrid *this, int *a2, int *a3)
{
  uint64_t v3 = 0;
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v4 = *a2;
  int v5 = *a3;
  int v6 = *(_DWORD *)this;
  do
  {
    int v7 = dword_21359B5B0[v3] + v4 + v6 * (dword_21359B5D0[v3] + v5);
    if (v7 < 1) {
      int v8 = 0;
    }
    else {
      int v8 = *(unsigned __int8 *)(*((void *)this + 5) + v7);
    }
    v16[v3++] = v8 != 0;
  }
  while (v3 != 8);
  uint64_t v9 = 0;
  int v10 = 0;
  do
  {
    int v11 = v16[v9++];
    if (v11 != v16[v9 & 7]) {
      ++v10;
    }
  }
  while (v9 != 8);
  if (v10 == 2)
  {
    for (uint64_t i = 0; i != 8; ++i)
    {
      if (!v16[i]) {
        break;
      }
    }
    int v13 = 0;
    while (1)
    {
      uint64_t v14 = ((_BYTE)i + (_BYTE)v13) & 7;
      if (v16[v14]) {
        break;
      }
      if (++v13 == 8)
      {
        uint64_t v14 = 0;
        break;
      }
    }
    *a2 = v4 + dword_21359B5B0[v14];
    *a3 += dword_21359B5D0[v14];
  }
  return 0;
}

void rdpReduce(uint64_t a1@<X0>, double **a2@<X8>, float a3@<S0>)
{
  int v5 = *(double **)a1;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = v4 - *(void *)a1;
  unint64_t v7 = v6 >> 4;
  if ((unint64_t)v6 > 0x2F)
  {
    double v10 = *v5;
    double v11 = v5[1];
    double v13 = *(double *)(v4 - 16);
    double v12 = *(double *)(v4 - 8);
    if (v7 - 1 < 2)
    {
      int v19 = -1;
      float v18 = 0.0;
    }
    else
    {
      float v14 = v13 - v10;
      double v15 = (v12 - v11) / v14;
      double v16 = sqrt(v15 * v15 + 1.0);
      uint64_t v17 = v5 + 3;
      float v18 = 0.0;
      int v19 = -1;
      uint64_t v20 = 2;
      do
      {
        double v21 = *(v17 - 1);
        if (v10 == v13) {
          double v22 = vabdd_f64(v21, v10);
        }
        else {
          double v22 = fabs(v11 - v15 * v10 - (*v17 - v15 * v21)) / v16;
        }
        float v23 = v22;
        if (v18 < v23)
        {
          float v18 = v23;
          int v19 = v20 - 1;
        }
        v17 += 2;
        ++v20;
      }
      while (v7 != v20);
    }
    if (v18 <= a3)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      uint64_t v24 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a2 + 2), 1uLL);
      float v25 = *a2;
      float v26 = a2[1];
      float v28 = &v24[2 * v27];
      *uint64_t v24 = v10;
      v24[1] = v11;
      float v29 = v24 + 2;
      float v30 = v24;
      if (v26 != v25)
      {
        do
        {
          *((_OWORD *)v30 - 1) = *((_OWORD *)v26 - 1);
          v30 -= 2;
          v26 -= 2;
        }
        while (v26 != v25);
        float v25 = *a2;
      }
      *a2 = v30;
      a2[1] = v29;
      a2[2] = v28;
      if (v25)
      {
        operator delete(v25);
        float v28 = a2[2];
      }
      a2[1] = v29;
      if (v29 >= v28)
      {
        float v32 = *a2;
        uint64_t v33 = ((char *)v29 - (char *)*a2) >> 4;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 60) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v35 = (char *)v28 - (char *)v32;
        if (v35 >> 3 > v34) {
          unint64_t v34 = v35 >> 3;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          float v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a2 + 2), v36);
          float v32 = *a2;
          float v29 = a2[1];
        }
        else
        {
          float v37 = 0;
        }
        float v38 = (double *)&v37[16 * v33];
        float v39 = (double *)&v37[16 * v36];
        double *v38 = v13;
        v38[1] = v12;
        float v31 = v38 + 2;
        if (v29 != v32)
        {
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v29 - 1);
            v38 -= 2;
            v29 -= 2;
          }
          while (v29 != v32);
          float v32 = *a2;
        }
        *a2 = v38;
        a2[1] = v31;
        a2[2] = v39;
        if (v32) {
          operator delete(v32);
        }
      }
      else
      {
        float v24[2] = v13;
        v24[3] = v12;
        float v31 = v24 + 4;
      }
      a2[1] = v31;
    }
    else
    {
      float v45 = 0;
      float v46 = 0;
      uint64_t v47 = 0;
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>((uint64_t)&v45, 0, (char *)v5, (char *)&v5[2 * v19 + 2], (16 * v19 + 16) >> 4);
      float v42 = 0;
      float v43 = 0;
      uint64_t v44 = 0;
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>((uint64_t)&v42, 0, (char *)(*(void *)a1 + 16 * v19), *(char **)(a1 + 8), (*(void *)(a1 + 8) - (*(void *)a1 + 16 * v19)) >> 4);
      rdpReduce(&v45, a3);
      rdpReduce(&v42, a3);
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint*>,std::__wrap_iter<CGPoint*>>((uint64_t)a2, (uint64_t)a2[1], __p + 16, v41, (v41 - (__p + 16)) >> 4);
      if (__p) {
        operator delete(__p);
      }
      if (v42)
      {
        float v43 = v42;
        operator delete(v42);
      }
      if (v45)
      {
        float v46 = v45;
        operator delete(v45);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(a2, v5, v4, v7);
  }
}

void sub_2135878A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  int v19 = *(void **)v17;
  if (*(void *)v17)
  {
    *(void *)(v17 + 8) = v19;
    operator delete(v19);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void mooreNeighborTracing(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  int v8 = a3 + 2;
  uint64_t v9 = (a2 + 2);
  size_t v10 = (a3 + 2) * (int)v9;
  double v11 = malloc_type_malloc(v10, 0xF7ACFA6uLL);
  double v12 = v11;
  int v55 = a2;
  if (a2 >= -1)
  {
    uint64_t v13 = 0;
    if (v8 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v8;
    }
    double v15 = (char *)(~(uint64_t)a2 + a1);
    double v16 = v11;
    do
    {
      if (a3 >= -1)
      {
        uint64_t v17 = 0;
        float v18 = v15;
        int v19 = v16;
        do
        {
          char v20 = 0;
          if (v13 && v17 && v13 != a2 + 1 && a3 + 1 != v17) {
            char v20 = *v18;
          }
          *int v19 = v20;
          ++v17;
          v19 += v9;
          v18 += a2;
        }
        while (v14 != v17);
      }
      ++v13;
      ++v16;
      ++v15;
    }
    while (v13 != v9);
  }
  double v21 = malloc_type_malloc(v10, 0xC9BDD9EFuLL);
  bzero(v21, v10);
  if (a3 >= -1)
  {
    *(_DWORD *)&v60[8] = 0;
    BOOL v22 = 0;
    int v23 = -3 - a2;
    int v24 = -2 - a2;
    int v25 = ~a2;
    int v26 = a2 + 3;
    int v27 = a2 + 1;
    uint64_t v28 = (int)v9;
    uint64_t v54 = v8;
    int v59 = -2 - a2;
    *(void *)float v60 = (-3 - a2);
    int v57 = a2 + 3;
    int v58 = ~a2;
    int v56 = a2 + 1;
    while (v55 < -1)
    {
      BOOL v29 = 0;
LABEL_22:
      if (!v29)
      {
        ++*(void *)&v60[4];
        if (*(uint64_t *)&v60[4] < v54) {
          continue;
        }
      }
      goto LABEL_16;
    }
    uint64_t v30 = 0;
    uint64_t v31 = *(void *)&v60[4] * v28;
    uint64_t v61 = *(void *)&v60[4] * v28;
LABEL_26:
    uint64_t v32 = v30 + v31;
    if (*((unsigned char *)v21 + v30 + v31) == 1 && !v22) {
      goto LABEL_16;
    }
    if (v12[v32] != 1 || v22)
    {
      BOOL v29 = 0;
      goto LABEL_64;
    }
    int v33 = 0;
    int v34 = 1;
    *((unsigned char *)v21 + v3b2DynamicTree::~b2DynamicTree(this + 2) = 1;
    uint64_t v63 = 0x7FFFFFFFFLL;
    int v64 = v23;
    int v65 = 7;
    int v66 = v24;
    int v67 = 1;
    int v68 = v25;
    uint64_t v69 = 0x100000001;
    int v70 = 3;
    int v71 = v26;
    int v72 = 3;
    int v73 = v9;
    int v74 = 5;
    int v75 = v27;
    int v35 = v30 + v31;
    int v76 = 5;
    while (1)
    {
      int v36 = -1;
      while (1)
      {
        uint64_t v37 = v34 - 1;
        uint64_t v38 = *((int *)&v63 + 2 * v37) + (uint64_t)v35;
        BOOL v22 = v12[v38] == 1;
        if (v12[v38] == 1) {
          break;
        }
        if (v34 <= 0) {
          int v39 = -(-v34 & 7);
        }
        else {
          int v39 = v34 & 7;
        }
        int v34 = v39 + 1;
        if (++v36 >= 9) {
          goto LABEL_63;
        }
      }
      v35 += *((_DWORD *)&v63 + 2 * v37);
      int v34 = *((_DWORD *)&v63 + 2 * v37 + 1);
      if (v38 == v32)
      {
        if (v34 == 1 || v33 > 1)
        {
LABEL_63:
          BOOL v29 = v22;
          if (v22) {
            goto LABEL_22;
          }
LABEL_64:
          if (++v30 >= v28) {
            goto LABEL_22;
          }
          goto LABEL_26;
        }
        ++v33;
      }
      *((unsigned char *)v21 + v38) = 1;
      double v41 = (double)(~((int)v38 / (int)v9 * (int)v9) + (int)v38);
      double v42 = (double)((int)v38 / (int)v9 - 1);
      uint64_t v44 = *(double **)(a4 + 8);
      unint64_t v43 = *(void *)(a4 + 16);
      if ((unint64_t)v44 >= v43)
      {
        float v46 = *(double **)a4;
        uint64_t v47 = ((uint64_t)v44 - *(void *)a4) >> 4;
        unint64_t v48 = v47 + 1;
        if ((unint64_t)(v47 + 1) >> 60) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        int v62 = v33;
        uint64_t v49 = v43 - (void)v46;
        if (v49 >> 3 > v48) {
          unint64_t v48 = v49 >> 3;
        }
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v50 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v50 = v48;
        }
        if (v50)
        {
          float v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(a4 + 16, v50);
          float v46 = *(double **)a4;
          uint64_t v44 = *(double **)(a4 + 8);
        }
        else
        {
          float v51 = 0;
        }
        float v52 = (double *)&v51[16 * v47];
        double *v52 = v41;
        v52[1] = v42;
        float v53 = v52;
        if (v44 != v46)
        {
          do
          {
            *((_OWORD *)v53 - 1) = *((_OWORD *)v44 - 1);
            v53 -= 2;
            v44 -= 2;
          }
          while (v44 != v46);
          float v46 = *(double **)a4;
        }
        float v45 = v52 + 2;
        *(void *)a4 = v53;
        *(void *)(a4 + 8) = v52 + 2;
        *(void *)(a4 + 16) = &v51[16 * v50];
        if (v46) {
          operator delete(v46);
        }
        int v24 = v59;
        int v23 = *(_DWORD *)v60;
        int v26 = v57;
        int v25 = v58;
        int v27 = v56;
        uint64_t v28 = (int)v9;
        uint64_t v31 = v61;
        int v33 = v62;
      }
      else
      {
        double *v44 = v41;
        v44[1] = v42;
        float v45 = v44 + 2;
      }
      *(void *)(a4 + 8) = v45;
    }
  }
LABEL_16:
  free(v21);

  free(v12);
}

void PKCGrid::traceOutline(int *a1, char **a2, float a3)
{
  a2[1] = *a2;
  uint64_t v6 = malloc_type_malloc(a1[1] * (uint64_t)*a1, 0x21AD04B8uLL);
  unint64_t v7 = v6;
  int v8 = (unsigned __int8 *)*((void *)a1 + 5);
  uint64_t v9 = (unsigned __int8 *)*((void *)a1 + 6);
  if (v8 != v9)
  {
    size_t v10 = (BOOL *)v6;
    do
    {
      int v11 = *v8++;
      *v10++ = v11 != 0;
    }
    while (v8 != v9);
  }
  mooreNeighborTracing((uint64_t)v6, *a1, a1[1], (uint64_t)a2);
  free(v7);
  if (a2[1] != *a2 && a1[1] + *a1 >= 67)
  {
    rdpReduce((uint64_t)a2, &v28, a3);
    int v25 = 0;
    int v26 = 0;
    int v27 = 0;
    double v12 = v29;
    if (v29 == v28)
    {
      BOOL v22 = 0;
      uint64_t v13 = 0;
      double v21 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      do
      {
        v12 -= 2;
        if (v13 >= v27)
        {
          uint64_t v14 = (v13 - v25) >> 4;
          if ((unint64_t)(v14 + 1) >> 60) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v15 = (v27 - v25) >> 3;
          if (v15 <= v14 + 1) {
            unint64_t v15 = v14 + 1;
          }
          if ((unint64_t)(v27 - v25) >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16) {
            uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)&v27, v16);
          }
          else {
            uint64_t v17 = 0;
          }
          float v18 = &v17[16 * v14];
          *(_OWORD *)float v18 = *(_OWORD *)v12;
          int v19 = v26;
          char v20 = v18;
          if (v26 != v25)
          {
            do
            {
              *((_OWORD *)v20 - 1) = *((_OWORD *)v19 - 1);
              v20 -= 16;
              v19 -= 16;
            }
            while (v19 != v25);
            int v19 = v25;
          }
          uint64_t v13 = v18 + 16;
          int v25 = v20;
          int v27 = &v17[16 * v16];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v13 = *(_OWORD *)v12;
          v13 += 16;
        }
        int v26 = v13;
      }
      while (v12 != v28);
      double v21 = v25;
      BOOL v22 = v27;
    }
    int v23 = *a2;
    *a2 = v21;
    a2[1] = v13;
    int v24 = a2[2];
    a2[2] = v22;
    int v27 = v24;
    if (v23)
    {
      operator delete(v23);
      double v12 = v28;
    }
    if (v12)
    {
      BOOL v29 = v12;
      operator delete(v12);
    }
  }
}

void sub_213587F78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void PKCGrid::labelGrid(PKCGrid *this)
{
  uint64_t v3 = (void *)((char *)this + 112);
  uint64_t v2 = *((void *)this + 14);
  uint64_t v4 = (unsigned char *)*((void *)this + 5);
  int v5 = (unsigned char *)*((void *)this + 6);
  unint64_t v6 = *((void *)this + 15) - v2;
  if (v5 - v4 <= v6)
  {
    if (v5 - v4 < v6) {
      *((void *)this + 15) = v2 + v5 - v4;
    }
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 14, v5 - v4 - v6);
    uint64_t v4 = (unsigned char *)*((void *)this + 5);
    int v5 = (unsigned char *)*((void *)this + 6);
  }
  unint64_t v7 = (void **)((char *)this + 88);
  *((void *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = *((void *)this + 11);
  if (v4 != v5)
  {
    uint64_t v8 = 0;
    do
    {
      if (*v4)
      {
        uint64_t v9 = *(_DWORD *)this;
        int v10 = (int)v8 / (int)v9;
        if ((int)v8 % (int)v9) {
          BOOL v11 = (int)v8 % (int)v9 == v9 - 1;
        }
        else {
          BOOL v11 = 1;
        }
        BOOL v12 = v11 || v10 == 0;
        if (!v12
          && v10 != *((_DWORD *)this + 1) - 1
          && (uint64_t v13 = *((void *)this + 5), *(unsigned char *)(v13 + (v8 + 1)))
          && *(unsigned char *)(v8 + v13 - 1)
          && *(unsigned char *)(v13 + v8 + v9)
          && *(unsigned char *)(v13 + v8 - v9))
        {
          *(unsigned char *)(*v3 + v8) = -3;
        }
        else
        {
          *(unsigned char *)(*((void *)this + 14) + v8) = 0;
          unint64_t v15 = (char *)*((void *)this + 12);
          unint64_t v14 = *((void *)this + 13);
          if ((unint64_t)v15 >= v14)
          {
            uint64_t v17 = (char *)*v7;
            uint64_t v18 = (v15 - (unsigned char *)*v7) >> 2;
            unint64_t v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 62) {
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v20 = v14 - (void)v17;
            if (v20 >> 1 > v19) {
              unint64_t v19 = v20 >> 1;
            }
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v21 = v19;
            }
            if (v21)
            {
              BOOL v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 104, v21);
              uint64_t v17 = (char *)*((void *)this + 11);
              unint64_t v15 = (char *)*((void *)this + 12);
            }
            else
            {
              BOOL v22 = 0;
            }
            int v23 = &v22[4 * v18];
            *(_DWORD *)int v23 = v8;
            unint64_t v16 = v23 + 4;
            while (v15 != v17)
            {
              int v24 = *((_DWORD *)v15 - 1);
              v15 -= 4;
              *((_DWORD *)v23 - 1) = v24;
              v23 -= 4;
            }
            *((void *)this + 11) = v23;
            *((void *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = v16;
            *((void *)this + 13) = &v22[4 * v21];
            if (v17) {
              operator delete(v17);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v15 = v8;
            unint64_t v16 = v15 + 4;
          }
          *((void *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = v16;
        }
      }
      else
      {
        *(unsigned char *)(*v3 + v8) = 3;
      }
      ++v8;
      ++v4;
    }
    while (v4 != v5);
  }
}

void PKCGrid::calcQuadTree(PKCGrid *this, const CGRect *a2)
{
  uint64_t v3 = (uint64_t *)((char *)this + 112);
  *((void *)this + 15) = *((void *)this + 14);
  uint64_t v5 = *((void *)this + 5);
  uint64_t v4 = *((void *)this + 6);
  if (v4 != v5) {
    std::vector<unsigned char>::__append((unint64_t *)this + 14, v4 - v5);
  }
  __p = 0;
  float v129 = 0;
  int16x8_t v130 = 0;
  float v125 = 0;
  float v126 = 0;
  float v127 = 0;
  PKCGrid::labelGrid(this);
  unint64_t v6 = (int *)*((void *)this + 11);
  for (uint64_t i = (int *)*((void *)this + 12); v6 != i; ++v6)
  {
    uint64_t v8 = *v6;
    int v9 = (int)v8 % *(_DWORD *)this;
    if (v9 < *(_DWORD *)this - 2)
    {
      uint64_t v10 = v8 + 1;
      uint64_t v11 = *v3;
      int v12 = *(unsigned __int8 *)(*v3 + v8 + 1);
      if (v12 == 3)
      {
        *(unsigned char *)(v11 + v10) = 1;
        unint64_t v15 = v126;
        if (v126 >= v127)
        {
          int v23 = (char *)v125;
          uint64_t v24 = (v126 - (unsigned char *)v125) >> 2;
          unint64_t v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v26 = v127 - (unsigned char *)v125;
          if ((v127 - (unsigned char *)v125) >> 1 > v25) {
            unint64_t v25 = v26 >> 1;
          }
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v127, v27);
            int v23 = (char *)v125;
            unint64_t v15 = v126;
          }
          else
          {
            uint64_t v28 = 0;
          }
          uint64_t v31 = &v28[4 * v24];
          *(_DWORD *)uint64_t v31 = v10;
          unint64_t v16 = v31 + 4;
          while (v15 != v23)
          {
            int v32 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            *((_DWORD *)v31 - 1) = v32;
            v31 -= 4;
          }
          float v125 = v31;
          float v126 = v16;
          float v127 = &v28[4 * v27];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          *(_DWORD *)float v126 = v10;
          unint64_t v16 = v15 + 4;
        }
        float v126 = v16;
      }
      else if (v12 == 253)
      {
        *(unsigned char *)(v11 + v10) = -1;
        uint64_t v13 = v129;
        if (v129 >= v130)
        {
          uint64_t v17 = (char *)__p;
          uint64_t v18 = (v129 - (unsigned char *)__p) >> 2;
          unint64_t v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v20 = v130 - (unsigned char *)__p;
          if ((v130 - (unsigned char *)__p) >> 1 > v19) {
            unint64_t v19 = v20 >> 1;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v19;
          }
          if (v21)
          {
            BOOL v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v130, v21);
            uint64_t v17 = (char *)__p;
            uint64_t v13 = v129;
          }
          else
          {
            BOOL v22 = 0;
          }
          BOOL v29 = &v22[4 * v18];
          *(_DWORD *)BOOL v29 = v10;
          unint64_t v14 = v29 + 4;
          while (v13 != v17)
          {
            int v30 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *((_DWORD *)v29 - 1) = v30;
            v29 -= 4;
          }
          __p = v29;
          float v129 = v14;
          int16x8_t v130 = &v22[4 * v21];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          *(_DWORD *)float v129 = v10;
          unint64_t v14 = v13 + 4;
        }
        float v129 = v14;
      }
    }
    if (v9 >= 1)
    {
      uint64_t v33 = v8 - 1;
      uint64_t v34 = *v3;
      int v35 = *(unsigned __int8 *)(*v3 + v8 - 1);
      if (v35 == 3)
      {
        *(unsigned char *)(v34 + v33) = 1;
        uint64_t v38 = v126;
        if (v126 >= v127)
        {
          float v46 = (char *)v125;
          uint64_t v47 = (v126 - (unsigned char *)v125) >> 2;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v49 = v127 - (unsigned char *)v125;
          if ((v127 - (unsigned char *)v125) >> 1 > v48) {
            unint64_t v48 = v49 >> 1;
          }
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v48;
          }
          if (v50)
          {
            float v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v127, v50);
            float v46 = (char *)v125;
            uint64_t v38 = v126;
          }
          else
          {
            float v51 = 0;
          }
          uint64_t v54 = &v51[4 * v47];
          *(_DWORD *)uint64_t v54 = v33;
          int v39 = v54 + 4;
          while (v38 != v46)
          {
            int v55 = *((_DWORD *)v38 - 1);
            v38 -= 4;
            *((_DWORD *)v54 - 1) = v55;
            v54 -= 4;
          }
          float v125 = v54;
          float v126 = v39;
          float v127 = &v51[4 * v50];
          if (v46) {
            operator delete(v46);
          }
        }
        else
        {
          *(_DWORD *)float v126 = v33;
          int v39 = v38 + 4;
        }
        float v126 = v39;
      }
      else if (v35 == 253)
      {
        *(unsigned char *)(v34 + v33) = -1;
        int v36 = v129;
        if (v129 >= v130)
        {
          float v40 = (char *)__p;
          uint64_t v41 = (v129 - (unsigned char *)__p) >> 2;
          unint64_t v42 = v41 + 1;
          if ((unint64_t)(v41 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v43 = v130 - (unsigned char *)__p;
          if ((v130 - (unsigned char *)__p) >> 1 > v42) {
            unint64_t v42 = v43 >> 1;
          }
          if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v44 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v44 = v42;
          }
          if (v44)
          {
            float v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v130, v44);
            float v40 = (char *)__p;
            int v36 = v129;
          }
          else
          {
            float v45 = 0;
          }
          float v52 = &v45[4 * v41];
          *(_DWORD *)float v52 = v33;
          uint64_t v37 = v52 + 4;
          while (v36 != v40)
          {
            int v53 = *((_DWORD *)v36 - 1);
            v36 -= 4;
            *((_DWORD *)v52 - 1) = v53;
            v52 -= 4;
          }
          __p = v52;
          float v129 = v37;
          int16x8_t v130 = &v45[4 * v44];
          if (v40) {
            operator delete(v40);
          }
        }
        else
        {
          *(_DWORD *)float v129 = v33;
          uint64_t v37 = v36 + 4;
        }
        float v129 = v37;
      }
    }
    int v56 = (int)v8 / *(_DWORD *)this;
    if (v56 < *((_DWORD *)this + 1) - 2)
    {
      uint64_t v57 = *(_DWORD *)this + (int)v8;
      uint64_t v58 = *v3;
      int v59 = *(unsigned __int8 *)(*v3 + v57);
      if (v59 == 3)
      {
        *(unsigned char *)(v58 + v57) = 1;
        int v63 = *(_DWORD *)this + v8;
        int v64 = v126;
        if (v126 >= v127)
        {
          int v72 = (char *)v125;
          uint64_t v73 = (v126 - (unsigned char *)v125) >> 2;
          unint64_t v74 = v73 + 1;
          if ((unint64_t)(v73 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v75 = v127 - (unsigned char *)v125;
          if ((v127 - (unsigned char *)v125) >> 1 > v74) {
            unint64_t v74 = v75 >> 1;
          }
          if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v76 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v76 = v74;
          }
          if (v76)
          {
            uint64_t v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v127, v76);
            int v72 = (char *)v125;
            int v64 = v126;
          }
          else
          {
            uint64_t v77 = 0;
          }
          float v80 = &v77[4 * v73];
          *(_DWORD *)float v80 = v63;
          int v65 = v80 + 4;
          while (v64 != v72)
          {
            int v81 = *((_DWORD *)v64 - 1);
            v64 -= 4;
            *((_DWORD *)v80 - 1) = v81;
            v80 -= 4;
          }
          float v125 = v80;
          float v126 = v65;
          float v127 = &v77[4 * v76];
          if (v72) {
            operator delete(v72);
          }
        }
        else
        {
          *(_DWORD *)float v126 = v63;
          int v65 = v64 + 4;
        }
        float v126 = v65;
      }
      else if (v59 == 253)
      {
        *(unsigned char *)(v58 + v57) = -1;
        int v60 = *(_DWORD *)this + v8;
        uint64_t v61 = v129;
        if (v129 >= v130)
        {
          int v66 = (char *)__p;
          uint64_t v67 = (v129 - (unsigned char *)__p) >> 2;
          unint64_t v68 = v67 + 1;
          if ((unint64_t)(v67 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v69 = v130 - (unsigned char *)__p;
          if ((v130 - (unsigned char *)__p) >> 1 > v68) {
            unint64_t v68 = v69 >> 1;
          }
          if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v70 = v68;
          }
          if (v70)
          {
            int v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v130, v70);
            int v66 = (char *)__p;
            uint64_t v61 = v129;
          }
          else
          {
            int v71 = 0;
          }
          float v78 = &v71[4 * v67];
          *(_DWORD *)float v78 = v60;
          int v62 = v78 + 4;
          while (v61 != v66)
          {
            int v79 = *((_DWORD *)v61 - 1);
            v61 -= 4;
            *((_DWORD *)v78 - 1) = v79;
            v78 -= 4;
          }
          __p = v78;
          float v129 = v62;
          int16x8_t v130 = &v71[4 * v70];
          if (v66) {
            operator delete(v66);
          }
        }
        else
        {
          *(_DWORD *)float v129 = v60;
          int v62 = v61 + 4;
        }
        float v129 = v62;
      }
    }
    if (v56 >= 1)
    {
      uint64_t v82 = v8 - *(_DWORD *)this;
      uint64_t v83 = *((void *)this + 14);
      int v84 = *(unsigned __int8 *)(v83 + v82);
      if (v84 == 3)
      {
        *(unsigned char *)(v83 + v8b2DynamicTree::~b2DynamicTree(this + 2) = 1;
        int v88 = v8 - *(_DWORD *)this;
        float v89 = v126;
        if (v126 >= v127)
        {
          float v97 = (char *)v125;
          uint64_t v98 = (v126 - (unsigned char *)v125) >> 2;
          unint64_t v99 = v98 + 1;
          if ((unint64_t)(v98 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v100 = v127 - (unsigned char *)v125;
          if ((v127 - (unsigned char *)v125) >> 1 > v99) {
            unint64_t v99 = v100 >> 1;
          }
          if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v101 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v101 = v99;
          }
          if (v101)
          {
            float32x2_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v127, v101);
            float v97 = (char *)v125;
            float v89 = v126;
          }
          else
          {
            float32x2_t v102 = 0;
          }
          uint64_t v105 = &v102[4 * v98];
          *(_DWORD *)uint64_t v105 = v88;
          float v90 = v105 + 4;
          while (v89 != v97)
          {
            int v106 = *((_DWORD *)v89 - 1);
            v89 -= 4;
            *((_DWORD *)v105 - 1) = v106;
            v105 -= 4;
          }
          float v125 = v105;
          float v126 = v90;
          float v127 = &v102[4 * v101];
          if (v97) {
            operator delete(v97);
          }
        }
        else
        {
          *(_DWORD *)float v126 = v88;
          float v90 = v89 + 4;
        }
        float v126 = v90;
      }
      else if (v84 == 253)
      {
        *(unsigned char *)(v83 + v8b2DynamicTree::~b2DynamicTree(this + 2) = -1;
        int v85 = v8 - *(_DWORD *)this;
        float v86 = v129;
        if (v129 >= v130)
        {
          float v91 = (char *)__p;
          uint64_t v92 = (v129 - (unsigned char *)__p) >> 2;
          unint64_t v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v94 = v130 - (unsigned char *)__p;
          if ((v130 - (unsigned char *)__p) >> 1 > v93) {
            unint64_t v93 = v94 >> 1;
          }
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v95 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v95 = v93;
          }
          if (v95)
          {
            float v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v130, v95);
            float v91 = (char *)__p;
            float v86 = v129;
          }
          else
          {
            float v96 = 0;
          }
          float32x2_t v103 = &v96[4 * v92];
          *(_DWORD *)float32x2_t v103 = v85;
          float v87 = v103 + 4;
          while (v86 != v91)
          {
            int v104 = *((_DWORD *)v86 - 1);
            v86 -= 4;
            *((_DWORD *)v103 - 1) = v104;
            v103 -= 4;
          }
          __p = v103;
          float v129 = v87;
          int16x8_t v130 = &v96[4 * v95];
          if (v91) {
            operator delete(v91);
          }
        }
        else
        {
          *(_DWORD *)float v129 = v85;
          float v87 = v86 + 4;
        }
        float v129 = v87;
      }
    }
  }
  CGFloat x = a2->origin.x;
  float v108 = PKGet_INV_PTM_RATIO();
  double width = a2->size.width;
  float v110 = PKGet_INV_PTM_RATIO();
  CGFloat y = a2->origin.y;
  float v112 = PKGet_INV_PTM_RATIO();
  double height = a2->size.height;
  float v114 = PKGet_INV_PTM_RATIO();
  float v115 = x * v108;
  float v116 = v115 + width * v110;
  float v117 = y * v112;
  float v118 = v117 + height * v114;
  *(float *)&CGFloat x = (float)(v116 - v115) * 0.5;
  *(float *)&CGFloat y = (float)(v118 - v117) * 0.5;
  float v123 = v116 - *(float *)&x;
  float v124 = v115 - *(float *)&x;
  float v121 = v118 - *(float *)&y;
  float v122 = v117 - *(float *)&y;
  float v120 = 1.0 / (float)*(_DWORD *)this;
  std::allocate_shared[abi:ne180100]<QuadTree,std::allocator<QuadTree>,float,float,float,float,float,void>((uint64_t)v131, &v124, &v123, &v122, &v121, &v120);
}

void sub_213588A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void PKCGrid::calcLevelSet(PKCGrid *this, int a2)
{
  PKCGrid::labelGrid(this);
  if (a2)
  {
    __p = 0;
    v224 = 0;
    v225 = 0;
    v220 = 0;
    v221 = 0;
    v222 = 0;
    v217 = 0;
    v218 = 0;
    v219 = 0;
    v214 = 0;
    v215 = 0;
    v216 = 0;
    uint64_t v4 = (int *)*((void *)this + 11);
    uint64_t v5 = (int *)*((void *)this + 12);
    if (v4 == v5)
    {
      uint64_t v105 = 0;
    }
    else
    {
      do
      {
        uint64_t v6 = *v4;
        int v7 = (int)v6 % *(_DWORD *)this;
        if (v7 < *(_DWORD *)this - 2)
        {
          uint64_t v8 = v6 + 1;
          uint64_t v9 = *((void *)this + 14);
          int v10 = *(unsigned __int8 *)(v9 + v6 + 1);
          if (v10 == 3)
          {
            *(unsigned char *)(v9 + v8) = 1;
            uint64_t v13 = v221;
            if (v221 >= v222)
            {
              unint64_t v21 = (char *)v220;
              uint64_t v22 = (v221 - (unsigned char *)v220) >> 2;
              unint64_t v23 = v22 + 1;
              if ((unint64_t)(v22 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v24 = v222 - (unsigned char *)v220;
              if ((v222 - (unsigned char *)v220) >> 1 > v23) {
                unint64_t v23 = v24 >> 1;
              }
              if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v23;
              }
              if (v25)
              {
                uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v25);
                unint64_t v21 = (char *)v220;
                uint64_t v13 = v221;
              }
              else
              {
                uint64_t v26 = 0;
              }
              BOOL v29 = &v26[4 * v22];
              *(_DWORD *)BOOL v29 = v8;
              unint64_t v14 = v29 + 4;
              while (v13 != v21)
              {
                int v30 = *((_DWORD *)v13 - 1);
                v13 -= 4;
                *((_DWORD *)v29 - 1) = v30;
                v29 -= 4;
              }
              v220 = v29;
              v221 = v14;
              v222 = &v26[4 * v25];
              if (v21) {
                operator delete(v21);
              }
            }
            else
            {
              *(_DWORD *)v221 = v8;
              unint64_t v14 = v13 + 4;
            }
            v221 = v14;
          }
          else if (v10 == 253)
          {
            *(unsigned char *)(v9 + v8) = -1;
            uint64_t v11 = v224;
            if (v224 >= v225)
            {
              unint64_t v15 = (char *)__p;
              uint64_t v16 = (v224 - (unsigned char *)__p) >> 2;
              unint64_t v17 = v16 + 1;
              if ((unint64_t)(v16 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v18 = v225 - (unsigned char *)__p;
              if ((v225 - (unsigned char *)__p) >> 1 > v17) {
                unint64_t v17 = v18 >> 1;
              }
              if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v19 = v17;
              }
              if (v19)
              {
                uint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v19);
                unint64_t v15 = (char *)__p;
                uint64_t v11 = v224;
              }
              else
              {
                uint64_t v20 = 0;
              }
              unint64_t v27 = &v20[4 * v16];
              *(_DWORD *)unint64_t v27 = v8;
              int v12 = v27 + 4;
              while (v11 != v15)
              {
                int v28 = *((_DWORD *)v11 - 1);
                v11 -= 4;
                *((_DWORD *)v27 - 1) = v28;
                v27 -= 4;
              }
              __p = v27;
              v224 = v12;
              v225 = &v20[4 * v19];
              if (v15) {
                operator delete(v15);
              }
            }
            else
            {
              *(_DWORD *)v224 = v8;
              int v12 = v11 + 4;
            }
            v224 = v12;
          }
        }
        if (v7 >= 1)
        {
          uint64_t v31 = v6 - 1;
          uint64_t v32 = *((void *)this + 14);
          int v33 = *(unsigned __int8 *)(v32 + v6 - 1);
          if (v33 == 3)
          {
            *(unsigned char *)(v32 + v31) = 1;
            int v36 = v221;
            if (v221 >= v222)
            {
              unint64_t v44 = (char *)v220;
              uint64_t v45 = (v221 - (unsigned char *)v220) >> 2;
              unint64_t v46 = v45 + 1;
              if ((unint64_t)(v45 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v47 = v222 - (unsigned char *)v220;
              if ((v222 - (unsigned char *)v220) >> 1 > v46) {
                unint64_t v46 = v47 >> 1;
              }
              if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v48 = v46;
              }
              if (v48)
              {
                uint64_t v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v48);
                unint64_t v44 = (char *)v220;
                int v36 = v221;
              }
              else
              {
                uint64_t v49 = 0;
              }
              float v52 = &v49[4 * v45];
              *(_DWORD *)float v52 = v31;
              uint64_t v37 = v52 + 4;
              while (v36 != v44)
              {
                int v53 = *((_DWORD *)v36 - 1);
                v36 -= 4;
                *((_DWORD *)v52 - 1) = v53;
                v52 -= 4;
              }
              v220 = v52;
              v221 = v37;
              v222 = &v49[4 * v48];
              if (v44) {
                operator delete(v44);
              }
            }
            else
            {
              *(_DWORD *)v221 = v31;
              uint64_t v37 = v36 + 4;
            }
            v221 = v37;
          }
          else if (v33 == 253)
          {
            *(unsigned char *)(v32 + v31) = -1;
            uint64_t v34 = v224;
            if (v224 >= v225)
            {
              uint64_t v38 = (char *)__p;
              uint64_t v39 = (v224 - (unsigned char *)__p) >> 2;
              unint64_t v40 = v39 + 1;
              if ((unint64_t)(v39 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v41 = v225 - (unsigned char *)__p;
              if ((v225 - (unsigned char *)__p) >> 1 > v40) {
                unint64_t v40 = v41 >> 1;
              }
              if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v42 = v40;
              }
              if (v42)
              {
                uint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v42);
                uint64_t v38 = (char *)__p;
                uint64_t v34 = v224;
              }
              else
              {
                uint64_t v43 = 0;
              }
              unint64_t v50 = &v43[4 * v39];
              *(_DWORD *)unint64_t v50 = v31;
              int v35 = v50 + 4;
              while (v34 != v38)
              {
                int v51 = *((_DWORD *)v34 - 1);
                v34 -= 4;
                *((_DWORD *)v50 - 1) = v51;
                v50 -= 4;
              }
              __p = v50;
              v224 = v35;
              v225 = &v43[4 * v42];
              if (v38) {
                operator delete(v38);
              }
            }
            else
            {
              *(_DWORD *)v224 = v31;
              int v35 = v34 + 4;
            }
            v224 = v35;
          }
        }
        int v54 = (int)v6 / *(_DWORD *)this;
        if (v54 < *((_DWORD *)this + 1) - 2)
        {
          uint64_t v55 = *(_DWORD *)this + (int)v6;
          uint64_t v56 = *((void *)this + 14);
          int v57 = *(unsigned __int8 *)(v56 + v55);
          if (v57 == 3)
          {
            *(unsigned char *)(v56 + v55) = 1;
            int v61 = *(_DWORD *)this + v6;
            int v62 = v221;
            if (v221 >= v222)
            {
              unint64_t v70 = (char *)v220;
              uint64_t v71 = (v221 - (unsigned char *)v220) >> 2;
              unint64_t v72 = v71 + 1;
              if ((unint64_t)(v71 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v73 = v222 - (unsigned char *)v220;
              if ((v222 - (unsigned char *)v220) >> 1 > v72) {
                unint64_t v72 = v73 >> 1;
              }
              if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v74 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v74 = v72;
              }
              if (v74)
              {
                uint64_t v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v74);
                unint64_t v70 = (char *)v220;
                int v62 = v221;
              }
              else
              {
                uint64_t v75 = 0;
              }
              float v78 = &v75[4 * v71];
              *(_DWORD *)float v78 = v61;
              int v63 = v78 + 4;
              while (v62 != v70)
              {
                int v79 = *((_DWORD *)v62 - 1);
                v62 -= 4;
                *((_DWORD *)v78 - 1) = v79;
                v78 -= 4;
              }
              v220 = v78;
              v221 = v63;
              v222 = &v75[4 * v74];
              if (v70) {
                operator delete(v70);
              }
            }
            else
            {
              *(_DWORD *)v221 = v61;
              int v63 = v62 + 4;
            }
            v221 = v63;
          }
          else if (v57 == 253)
          {
            *(unsigned char *)(v56 + v55) = -1;
            int v58 = *(_DWORD *)this + v6;
            int v59 = v224;
            if (v224 >= v225)
            {
              int v64 = (char *)__p;
              uint64_t v65 = (v224 - (unsigned char *)__p) >> 2;
              unint64_t v66 = v65 + 1;
              if ((unint64_t)(v65 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v67 = v225 - (unsigned char *)__p;
              if ((v225 - (unsigned char *)__p) >> 1 > v66) {
                unint64_t v66 = v67 >> 1;
              }
              if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v68 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v68 = v66;
              }
              if (v68)
              {
                uint64_t v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v68);
                int v64 = (char *)__p;
                int v59 = v224;
              }
              else
              {
                uint64_t v69 = 0;
              }
              unint64_t v76 = &v69[4 * v65];
              *(_DWORD *)unint64_t v76 = v58;
              int v60 = v76 + 4;
              while (v59 != v64)
              {
                int v77 = *((_DWORD *)v59 - 1);
                v59 -= 4;
                *((_DWORD *)v76 - 1) = v77;
                v76 -= 4;
              }
              __p = v76;
              v224 = v60;
              v225 = &v69[4 * v68];
              if (v64) {
                operator delete(v64);
              }
            }
            else
            {
              *(_DWORD *)v224 = v58;
              int v60 = v59 + 4;
            }
            v224 = v60;
          }
        }
        if (v54 >= 1)
        {
          uint64_t v80 = v6 - *(_DWORD *)this;
          uint64_t v81 = *((void *)this + 14);
          int v82 = *(unsigned __int8 *)(v81 + v80);
          if (v82 == 3)
          {
            *(unsigned char *)(v81 + v80) = 1;
            int v86 = v6 - *(_DWORD *)this;
            float v87 = v221;
            if (v221 >= v222)
            {
              unint64_t v95 = (char *)v220;
              uint64_t v96 = (v221 - (unsigned char *)v220) >> 2;
              unint64_t v97 = v96 + 1;
              if ((unint64_t)(v96 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v98 = v222 - (unsigned char *)v220;
              if ((v222 - (unsigned char *)v220) >> 1 > v97) {
                unint64_t v97 = v98 >> 1;
              }
              if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v99 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v99 = v97;
              }
              if (v99)
              {
                uint64_t v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v99);
                unint64_t v95 = (char *)v220;
                float v87 = v221;
              }
              else
              {
                uint64_t v100 = 0;
              }
              float32x2_t v103 = &v100[4 * v96];
              *(_DWORD *)float32x2_t v103 = v86;
              int v88 = v103 + 4;
              while (v87 != v95)
              {
                int v104 = *((_DWORD *)v87 - 1);
                v87 -= 4;
                *((_DWORD *)v103 - 1) = v104;
                v103 -= 4;
              }
              v220 = v103;
              v221 = v88;
              v222 = &v100[4 * v99];
              if (v95) {
                operator delete(v95);
              }
            }
            else
            {
              *(_DWORD *)v221 = v86;
              int v88 = v87 + 4;
            }
            v221 = v88;
          }
          else if (v82 == 253)
          {
            *(unsigned char *)(v81 + v80) = -1;
            int v83 = v6 - *(_DWORD *)this;
            int v84 = v224;
            if (v224 >= v225)
            {
              float v89 = (char *)__p;
              uint64_t v90 = (v224 - (unsigned char *)__p) >> 2;
              unint64_t v91 = v90 + 1;
              if ((unint64_t)(v90 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v92 = v225 - (unsigned char *)__p;
              if ((v225 - (unsigned char *)__p) >> 1 > v91) {
                unint64_t v91 = v92 >> 1;
              }
              if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v93 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v93 = v91;
              }
              if (v93)
              {
                uint64_t v94 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v93);
                float v89 = (char *)__p;
                int v84 = v224;
              }
              else
              {
                uint64_t v94 = 0;
              }
              unint64_t v101 = &v94[4 * v90];
              *(_DWORD *)unint64_t v101 = v83;
              int v85 = v101 + 4;
              while (v84 != v89)
              {
                int v102 = *((_DWORD *)v84 - 1);
                v84 -= 4;
                *((_DWORD *)v101 - 1) = v102;
                v101 -= 4;
              }
              __p = v101;
              v224 = v85;
              v225 = &v94[4 * v93];
              if (v89) {
                operator delete(v89);
              }
            }
            else
            {
              *(_DWORD *)v224 = v83;
              int v85 = v84 + 4;
            }
            v224 = v85;
          }
        }
        ++v4;
      }
      while (v4 != v5);
      int v106 = (int *)__p;
      uint64_t v105 = (int *)v224;
      if (__p != v224)
      {
        do
        {
          uint64_t v107 = *v106;
          int v108 = (int)v107 % *(_DWORD *)this;
          if (v108 < *(_DWORD *)this - 2)
          {
            uint64_t v109 = v107 + 1;
            uint64_t v110 = *((void *)this + 14);
            if (*(unsigned __int8 *)(v110 + v107 + 1) == 253)
            {
              *(unsigned char *)(v110 + v109) = -2;
              float32x2_t v111 = v218;
              if (v218 >= v219)
              {
                float v113 = (char *)v217;
                uint64_t v114 = (v218 - (unsigned char *)v217) >> 2;
                unint64_t v115 = v114 + 1;
                if ((unint64_t)(v114 + 1) >> 62) {
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v116 = v219 - (unsigned char *)v217;
                if ((v219 - (unsigned char *)v217) >> 1 > v115) {
                  unint64_t v115 = v116 >> 1;
                }
                if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v117 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v117 = v115;
                }
                if (v117)
                {
                  float v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v117);
                  float v113 = (char *)v217;
                  float32x2_t v111 = v218;
                }
                else
                {
                  float v118 = 0;
                }
                uint64_t v119 = &v118[4 * v114];
                *(_DWORD *)uint64_t v119 = v109;
                float v112 = v119 + 4;
                while (v111 != v113)
                {
                  int v120 = *((_DWORD *)v111 - 1);
                  v111 -= 4;
                  *((_DWORD *)v119 - 1) = v120;
                  v119 -= 4;
                }
                v217 = v119;
                v218 = v112;
                v219 = &v118[4 * v117];
                if (v113) {
                  operator delete(v113);
                }
              }
              else
              {
                *(_DWORD *)v218 = v109;
                float v112 = v111 + 4;
              }
              v218 = v112;
            }
          }
          if (v108 >= 1)
          {
            uint64_t v121 = v107 - 1;
            uint64_t v122 = *((void *)this + 14);
            if (*(unsigned __int8 *)(v122 + v107 - 1) == 253)
            {
              *(unsigned char *)(v122 + v121) = -2;
              float v123 = v218;
              if (v218 >= v219)
              {
                float v125 = (char *)v217;
                uint64_t v126 = (v218 - (unsigned char *)v217) >> 2;
                unint64_t v127 = v126 + 1;
                if ((unint64_t)(v126 + 1) >> 62) {
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v128 = v219 - (unsigned char *)v217;
                if ((v219 - (unsigned char *)v217) >> 1 > v127) {
                  unint64_t v127 = v128 >> 1;
                }
                if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v129 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v129 = v127;
                }
                if (v129)
                {
                  int16x8_t v130 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v129);
                  float v125 = (char *)v217;
                  float v123 = v218;
                }
                else
                {
                  int16x8_t v130 = 0;
                }
                uint64_t v131 = &v130[4 * v126];
                *(_DWORD *)uint64_t v131 = v121;
                float v124 = v131 + 4;
                while (v123 != v125)
                {
                  int v132 = *((_DWORD *)v123 - 1);
                  v123 -= 4;
                  *((_DWORD *)v131 - 1) = v132;
                  v131 -= 4;
                }
                v217 = v131;
                v218 = v124;
                v219 = &v130[4 * v129];
                if (v125) {
                  operator delete(v125);
                }
              }
              else
              {
                *(_DWORD *)v218 = v121;
                float v124 = v123 + 4;
              }
              v218 = v124;
            }
          }
          int v133 = (int)v107 / *(_DWORD *)this;
          if (v133 < *((_DWORD *)this + 1) - 2)
          {
            int v134 = *(_DWORD *)this + v107;
            uint64_t v135 = *((void *)this + 14);
            if (*(unsigned __int8 *)(v135 + v134) == 253)
            {
              *(unsigned char *)(v135 + v134) = -2;
              int v136 = *(_DWORD *)this + v107;
              long long v137 = v218;
              if (v218 >= v219)
              {
                long long v139 = (char *)v217;
                uint64_t v140 = (v218 - (unsigned char *)v217) >> 2;
                unint64_t v141 = v140 + 1;
                if ((unint64_t)(v140 + 1) >> 62) {
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v142 = v219 - (unsigned char *)v217;
                if ((v219 - (unsigned char *)v217) >> 1 > v141) {
                  unint64_t v141 = v142 >> 1;
                }
                if ((unint64_t)v142 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v143 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v143 = v141;
                }
                if (v143)
                {
                  long long v144 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v143);
                  long long v139 = (char *)v217;
                  long long v137 = v218;
                }
                else
                {
                  long long v144 = 0;
                }
                long long v145 = &v144[4 * v140];
                *(_DWORD *)long long v145 = v136;
                v138 = v145 + 4;
                while (v137 != v139)
                {
                  int v146 = *((_DWORD *)v137 - 1);
                  v137 -= 4;
                  *((_DWORD *)v145 - 1) = v146;
                  v145 -= 4;
                }
                v217 = v145;
                v218 = v138;
                v219 = &v144[4 * v143];
                if (v139) {
                  operator delete(v139);
                }
              }
              else
              {
                *(_DWORD *)v218 = v136;
                v138 = v137 + 4;
              }
              v218 = v138;
            }
          }
          if (v133 >= 1)
          {
            uint64_t v147 = v107 - *(_DWORD *)this;
            uint64_t v148 = *((void *)this + 14);
            if (*(unsigned __int8 *)(v148 + v147) == 253)
            {
              *(unsigned char *)(v148 + v147) = -2;
              int v149 = v107 - *(_DWORD *)this;
              v150 = v218;
              if (v218 >= v219)
              {
                v152 = (char *)v217;
                uint64_t v153 = (v218 - (unsigned char *)v217) >> 2;
                unint64_t v154 = v153 + 1;
                if ((unint64_t)(v153 + 1) >> 62) {
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v155 = v219 - (unsigned char *)v217;
                if ((v219 - (unsigned char *)v217) >> 1 > v154) {
                  unint64_t v154 = v155 >> 1;
                }
                if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v156 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v156 = v154;
                }
                if (v156)
                {
                  v157 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v156);
                  v152 = (char *)v217;
                  v150 = v218;
                }
                else
                {
                  v157 = 0;
                }
                v158 = &v157[4 * v153];
                *(_DWORD *)v158 = v149;
                v151 = v158 + 4;
                while (v150 != v152)
                {
                  int v159 = *((_DWORD *)v150 - 1);
                  v150 -= 4;
                  *((_DWORD *)v158 - 1) = v159;
                  v158 -= 4;
                }
                v217 = v158;
                v218 = v151;
                v219 = &v157[4 * v156];
                if (v152) {
                  operator delete(v152);
                }
              }
              else
              {
                *(_DWORD *)v218 = v149;
                v151 = v150 + 4;
              }
              v218 = v151;
            }
          }
          ++v106;
        }
        while (v106 != v105);
        uint64_t v105 = (int *)__p;
      }
    }
    v160 = (int *)v224;
    if (v105 != (int *)v224)
    {
      do
      {
        uint64_t v161 = *v105;
        int v162 = (int)v161 % *(_DWORD *)this;
        if (v162 < *(_DWORD *)this - 2)
        {
          uint64_t v163 = v161 + 1;
          uint64_t v164 = *((void *)this + 14);
          if (*(unsigned char *)(v164 + v161 + 1) == 3)
          {
            *(unsigned char *)(v164 + v163) = 2;
            v165 = v215;
            if (v215 >= v216)
            {
              v167 = v214;
              uint64_t v168 = (v215 - v214) >> 2;
              unint64_t v169 = v168 + 1;
              if ((unint64_t)(v168 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v170 = v216 - v214;
              if ((v216 - v214) >> 1 > v169) {
                unint64_t v169 = v170 >> 1;
              }
              if ((unint64_t)v170 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v171 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v171 = v169;
              }
              if (v171)
              {
                v172 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v171);
                v167 = v214;
                v165 = v215;
              }
              else
              {
                v172 = 0;
              }
              v173 = &v172[4 * v168];
              *(_DWORD *)v173 = v163;
              v166 = v173 + 4;
              while (v165 != v167)
              {
                int v174 = *((_DWORD *)v165 - 1);
                v165 -= 4;
                *((_DWORD *)v173 - 1) = v174;
                v173 -= 4;
              }
              v214 = v173;
              v216 = &v172[4 * v171];
              if (v167) {
                operator delete(v167);
              }
            }
            else
            {
              *(_DWORD *)v215 = v163;
              v166 = v215 + 4;
            }
            v215 = v166;
          }
        }
        if (v162 >= 1)
        {
          uint64_t v175 = v161 - 1;
          uint64_t v176 = *((void *)this + 14);
          if (*(unsigned char *)(v176 + v161 - 1) == 3)
          {
            *(unsigned char *)(v176 + v175) = 2;
            v177 = v215;
            if (v215 >= v216)
            {
              v179 = v214;
              uint64_t v180 = (v215 - v214) >> 2;
              unint64_t v181 = v180 + 1;
              if ((unint64_t)(v180 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v182 = v216 - v214;
              if ((v216 - v214) >> 1 > v181) {
                unint64_t v181 = v182 >> 1;
              }
              if ((unint64_t)v182 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v183 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v183 = v181;
              }
              if (v183)
              {
                v184 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v183);
                v179 = v214;
                v177 = v215;
              }
              else
              {
                v184 = 0;
              }
              v185 = &v184[4 * v180];
              *(_DWORD *)v185 = v175;
              v178 = v185 + 4;
              while (v177 != v179)
              {
                int v186 = *((_DWORD *)v177 - 1);
                v177 -= 4;
                *((_DWORD *)v185 - 1) = v186;
                v185 -= 4;
              }
              v214 = v185;
              v216 = &v184[4 * v183];
              if (v179) {
                operator delete(v179);
              }
            }
            else
            {
              *(_DWORD *)v215 = v175;
              v178 = v215 + 4;
            }
            v215 = v178;
          }
        }
        int v187 = (int)v161 / *(_DWORD *)this;
        if (v187 < *((_DWORD *)this + 1) - 2)
        {
          int v188 = *(_DWORD *)this + v161;
          uint64_t v189 = *((void *)this + 14);
          if (*(unsigned char *)(v189 + v188) == 3)
          {
            *(unsigned char *)(v189 + v188) = 2;
            int v190 = *(_DWORD *)this + v161;
            v191 = v215;
            if (v215 >= v216)
            {
              v193 = v214;
              uint64_t v194 = (v215 - v214) >> 2;
              unint64_t v195 = v194 + 1;
              if ((unint64_t)(v194 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v196 = v216 - v214;
              if ((v216 - v214) >> 1 > v195) {
                unint64_t v195 = v196 >> 1;
              }
              if ((unint64_t)v196 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v197 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v197 = v195;
              }
              if (v197)
              {
                v198 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v197);
                v193 = v214;
                v191 = v215;
              }
              else
              {
                v198 = 0;
              }
              v199 = &v198[4 * v194];
              *(_DWORD *)v199 = v190;
              v192 = v199 + 4;
              while (v191 != v193)
              {
                int v200 = *((_DWORD *)v191 - 1);
                v191 -= 4;
                *((_DWORD *)v199 - 1) = v200;
                v199 -= 4;
              }
              v214 = v199;
              v216 = &v198[4 * v197];
              if (v193) {
                operator delete(v193);
              }
            }
            else
            {
              *(_DWORD *)v215 = v190;
              v192 = v215 + 4;
            }
            v215 = v192;
          }
        }
        if (v187 >= 1)
        {
          uint64_t v201 = v161 - *(_DWORD *)this;
          uint64_t v202 = *((void *)this + 14);
          if (*(unsigned char *)(v202 + v201) == 3)
          {
            *(unsigned char *)(v202 + v201) = 2;
            int v203 = v161 - *(_DWORD *)this;
            v204 = v215;
            if (v215 >= v216)
            {
              v206 = v214;
              uint64_t v207 = (v215 - v214) >> 2;
              unint64_t v208 = v207 + 1;
              if ((unint64_t)(v207 + 1) >> 62) {
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v209 = v216 - v214;
              if ((v216 - v214) >> 1 > v208) {
                unint64_t v208 = v209 >> 1;
              }
              if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v210 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v210 = v208;
              }
              if (v210)
              {
                v211 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v210);
                v206 = v214;
                v204 = v215;
              }
              else
              {
                v211 = 0;
              }
              v212 = &v211[4 * v207];
              *(_DWORD *)v212 = v203;
              v205 = v212 + 4;
              while (v204 != v206)
              {
                int v213 = *((_DWORD *)v204 - 1);
                v204 -= 4;
                *((_DWORD *)v212 - 1) = v213;
                v212 -= 4;
              }
              v214 = v212;
              v216 = &v211[4 * v210];
              if (v206) {
                operator delete(v206);
              }
            }
            else
            {
              *(_DWORD *)v215 = v203;
              v205 = v215 + 4;
            }
            v215 = v205;
          }
        }
        ++v105;
      }
      while (v105 != v160);
    }
    if (v214) {
      operator delete(v214);
    }
    if (v217)
    {
      v218 = (char *)v217;
      operator delete(v217);
    }
    if (v220)
    {
      v221 = (char *)v220;
      operator delete(v220);
    }
    if (__p)
    {
      v224 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_213589948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  if (a17) {
    operator delete(a17);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PKCGrid::printGrid(PKCGrid *this)
{
  puts("\n");
  if (*((int *)this + 1) >= 1)
  {
    int v2 = 0;
    do
    {
      int v3 = *(_DWORD *)this;
      if (*(_DWORD *)this >= 1)
      {
        uint64_t v4 = 0;
        do
        {
          if (*(char *)(*((void *)this + 14) + v2 * v3 + v4) >= 1) {
            uint64_t v5 = " ";
          }
          else {
            uint64_t v5 = "*";
          }
          printf("%s", v5);
          int v3 = *(_DWORD *)this;
          ++v4;
        }
        while ((int)v4 < *(_DWORD *)this);
      }
      putchar(10);
      ++v2;
    }
    while (v2 < *((_DWORD *)this + 1));
  }

  return puts("\n");
}

BOOL PKCGrid::isGridRegionOccupied(PKCGrid *this, float a2, float a3, float a4, float a5)
{
  float v5 = (float)*((int *)this + 1);
  int v6 = (int)(float)((float)(1.0 - a3) * v5);
  int v7 = (int)(float)((float)(1.0 - (float)(a3 + a5)) * v5);
  if (v7 >= v6)
  {
    return 0;
  }
  else
  {
    uint64_t v8 = *(_DWORD *)this;
    int v9 = (int)(float)((float)(a2 + a4) * (float)(int)v8);
    int v10 = (int)(float)((float)(int)v8 * a2);
    uint64_t v11 = v7;
    uint64_t v12 = v10 + (int)v8 * (uint64_t)v7;
    BOOL v13 = 1;
    while (v9 <= v10)
    {
LABEL_7:
      BOOL v13 = ++v11 < v6;
      v12 += v8;
      if (v11 == v6) {
        return v13;
      }
    }
    unint64_t v14 = (unsigned __int8 *)(*((void *)this + 5) + v12);
    int v15 = v9 - v10;
    while (!*v14++)
    {
      if (!--v15) {
        goto LABEL_7;
      }
    }
  }
  return v13;
}

id PKCGrid::physicsBodyFromSmoothedOutline(PKCGrid *this, float a2, float64x2_t *a3)
{
  __p = 0;
  BOOL v29 = 0;
  uint64_t v30 = 0;
  PKCGrid::traceOutline((int *)this, (char **)&__p, a2);
  float v5 = (char *)operator new(0x40uLL);
  int v6 = (std::__shared_weak_count *)v5;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)float v5 = &unk_26C3F4398;
  *((_OWORD *)v5 + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  int v7 = (void **)(v5 + 32);
  *((_OWORD *)v5 + 3) = 0u;
  uint64_t v8 = v29;
  if (v29 != __p)
  {
    shared_weak_owners = 0;
    int v10 = v5 + 48;
    do
    {
      float64x2_t v11 = v8[-1];
      --v8;
      float32x2_t v12 = vcvt_f32_f64(vmulq_f64(*a3, vdivq_f64(v11, vcvtq_f64_f32(vcvt_f32_s32(*(int32x2_t *)this)))));
      if ((unint64_t)shared_weak_owners >= *v10)
      {
        shared_owners = (char *)*v7;
        uint64_t v15 = (shared_weak_owners - (unsigned char *)*v7) >> 3;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v17 = *v10 - (void)shared_owners;
        if (v17 >> 2 > v16) {
          unint64_t v16 = v17 >> 2;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          unint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v6[2], v18);
          shared_owners = (char *)v6[1].__shared_owners_;
          shared_weak_owners = (char *)v6[1].__shared_weak_owners_;
        }
        else
        {
          unint64_t v19 = 0;
        }
        uint64_t v20 = (float32x2_t *)&v19[8 * v15];
        *uint64_t v20 = v12;
        BOOL v13 = v20 + 1;
        if (shared_weak_owners != shared_owners)
        {
          do
          {
            float32x2_t v21 = *(float32x2_t *)(shared_weak_owners - 8);
            shared_weak_owners -= 8;
            v20[-1] = v21;
            --v20;
          }
          while (shared_weak_owners != shared_owners);
          shared_owners = (char *)*v7;
        }
        v6[1].__shared_owners_ = (uint64_t)v20;
        v6[1].__shared_weak_owners_ = (uint64_t)v13;
        v6[2].__vftable = (std::__shared_weak_count_vtbl *)&v19[8 * v18];
        if (shared_owners) {
          operator delete(shared_owners);
        }
      }
      else
      {
        *(float32x2_t *)shared_weak_owners = v12;
        BOOL v13 = (float32x2_t *)(shared_weak_owners + 8);
      }
      v6[1].__shared_weak_owners_ = (uint64_t)v13;
      shared_weak_owners = (char *)v13;
    }
    while (v8 != __p);
  }
  CGFloat v22 = a3->f64[0] * 0.5;
  CGFloat v23 = a3->f64[1] * 0.5;
  uint64_t v26 = v6 + 1;
  unint64_t v27 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v24 = +[PKPhysicsBody bodyWithOutline:offset:](PKPhysicsBody, "bodyWithOutline:offset:", &v26, v22, v23);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  if (__p)
  {
    BOOL v29 = (float64x2_t *)__p;
    operator delete(__p);
  }

  return v24;
}

void sub_213589DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void PKCGrid::pathFromOutlineWithSmoothingThreshold(PKCGrid *this@<X0>, float a2@<S0>, unsigned int a3@<S1>, unsigned int a4@<S2>, unsigned int a5@<S3>, unsigned int a6@<S4>, void *a7@<X8>)
{
  uint64_t v32 = 0;
  int v33 = 0;
  uint64_t v34 = 0;
  PKCGrid::traceOutline((int *)this, &v32, a2);
  int v9 = operator new(0x40uLL);
  v9[1] = 0;
  void v9[2] = 0;
  void *v9 = &unk_26C3F4398;
  *((_OWORD *)v9 + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *a7 = v9 + 3;
  a7[1] = v9;
  int v10 = v33;
  if (v33 == v32)
  {
    if (!v33) {
      return;
    }
  }
  else
  {
    float32x2_t v11 = vmla_f32((float32x2_t)__PAIR64__(a4, a3), (float32x2_t)0xBF000000BF000000, (float32x2_t)__PAIR64__(a6, a5));
    float64x2_t v29 = vcvtq_f64_f32((float32x2_t)__PAIR64__(a6, a5));
    float32x2_t v31 = v11;
    do
    {
      float64x2_t v12 = *((float64x2_t *)v10 - 1);
      v10 -= 16;
      float32x2_t v13 = vadd_f32(v31, vcvt_f32_f64(vmulq_f64(vdivq_f64(v12, vcvtq_f64_f32(vcvt_f32_s32(*(int32x2_t *)this))), v29)));
      unint64_t v14 = (void *)*a7;
      uint64_t v15 = *(float32x2_t **)(*a7 + 16);
      unint64_t v16 = *(void *)(*a7 + 24);
      if ((unint64_t)v15 >= v16)
      {
        unint64_t v18 = (float32x2_t *)v14[1];
        uint64_t v19 = v15 - v18;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 61) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v21 = v16 - (void)v18;
        if (v21 >> 2 > v20) {
          unint64_t v20 = v21 >> 2;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22)
        {
          CGFloat v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(*a7 + 24, v22);
          unint64_t v18 = (float32x2_t *)v14[1];
          uint64_t v15 = (float32x2_t *)v14[2];
        }
        else
        {
          CGFloat v23 = 0;
        }
        uint64_t v24 = (float32x2_t *)&v23[8 * v19];
        *uint64_t v24 = v13;
        uint64_t v17 = v24 + 1;
        if (v15 != v18)
        {
          do
          {
            float32x2_t v25 = v15[-1];
            --v15;
            v24[-1] = v25;
            --v24;
          }
          while (v15 != v18);
          unint64_t v18 = (float32x2_t *)v14[1];
        }
        v14[1] = v24;
        v14[2] = v17;
        v14[3] = &v23[8 * v22];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        *uint64_t v15 = v13;
        uint64_t v17 = v15 + 1;
      }
      v14[2] = v17;
    }
    while (v10 != v32);
  }
  int v33 = v10;
  operator delete(v10);
}

void sub_213589FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

PKPhysicsBody *PKCGrid::physicsBodyFromMarchingCubes(PKCGrid *this, const CGRect *a2)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  CGSize size = a2->size;
  int v63 = objc_alloc_init(PKPhysicsBody);
  PKCGrid::labelGrid(this);
  uint64_t v4 = malloc_type_malloc(*((int *)this + 1) * (uint64_t)*(_DWORD *)this, 0xEB51B0A9uLL);
  int v5 = *((_DWORD *)this + 1);
  if (v5 >= 1)
  {
    int v6 = 0;
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v66 = vmulq_f64((float64x2_t)size, _Q0);
    int v11 = *(_DWORD *)this;
    do
    {
      int v12 = v6 + 1;
      if (v11 >= 2)
      {
        int v13 = 0;
        do
        {
          uint64_t v14 = 0;
          int v78 = v13;
          v79[0] = v6;
          int v15 = v13 + 1;
          v79[1] = v13 + 1;
          float v79[2] = v6;
          v79[3] = v13 + 1;
          v79[4] = v6 + 1;
          unint64_t v16 = v79;
          v79[5] = v13;
          v79[6] = v6 + 1;
          do
          {
            unsigned int v17 = 0;
            int v18 = *(v16 - 1);
            if (v11 > v18)
            {
              int v19 = *v16;
              if (((*v16 | v18) & 0x80000000) == 0)
              {
                if (*((_DWORD *)this + 1) <= v19 || *((int *)this + 2) < 1) {
                  unsigned int v17 = 0;
                }
                else {
                  unsigned int v17 = *(unsigned __int8 *)(*((void *)this + 14) + v18 + v19 * v11);
                }
              }
            }
            v16 += 2;
            *((unsigned char *)v71 + v14++) = v17 >> 7;
          }
          while (v14 != 4);
          v4[v13 + v11 * v6] = LOBYTE(v71[0]) | (2 * BYTE1(v71[0])) | (4 * BYTE2(v71[0])) | (8 * HIBYTE(v71[0]));
          int v11 = *(_DWORD *)this;
          ++v13;
        }
        while (v15 < *(_DWORD *)this - 1);
        int v5 = *((_DWORD *)this + 1);
      }
      ++v6;
    }
    while (v12 < v5);
    if (v5 >= 1)
    {
      int v20 = 0;
      CGFloat v21 = a2->size.width / (double)v11;
      *(float *)&CGFloat v21 = v21;
      float v68 = *(float *)&v21;
      float32x2_t v22 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v21, 0);
      int v62 = v4;
      do
      {
        int v23 = v20 + 1;
        if (v11 >= 2)
        {
          int v24 = 0;
          int v64 = v20 + 1;
          int v65 = v20;
          do
          {
            unsigned int v25 = v4[v11 * v20 + (uint64_t)v24];
            if (v4[v11 * v20 + (uint64_t)v24]) {
              _ZF = v25 == 15;
            }
            else {
              _ZF = 1;
            }
            if (!_ZF)
            {
              v71[0] = v24;
              v71[1] = v20;
              int v27 = v24 + 1;
              int v72 = v24 + 1;
              int v73 = v20;
              int v74 = v24 + 1;
              int v75 = v23;
              int v76 = v24;
              int v77 = v23;
              switch(v25)
              {
                case 3u:
                  if (v27 < v11)
                  {
                    int v28 = v11 - 1;
                    uint64_t v29 = v11 - (uint64_t)v27;
                    do
                    {
                      if (v4[v20 * v11 + 1 + v24] != 3) {
                        goto LABEL_43;
                      }
                      ++v24;
                      --v29;
                    }
                    while (v29);
                    goto LABEL_42;
                  }
                  break;
                case 6u:
                  int v30 = v23;
                  if (v23 < *((_DWORD *)this + 1))
                  {
                    do
                    {
                      uint64_t v32 = v24 + *(_DWORD *)this * (uint64_t)v30;
                      if (v4[v32] != 6) {
                        break;
                      }
                      v4[v32] = 0;
                      ++v30;
                    }
                    while (v30 < *((_DWORD *)this + 1));
                    goto LABEL_37;
                  }
                  break;
                case 9u:
                  int v30 = v23;
                  if (v23 < *((_DWORD *)this + 1))
                  {
                    do
                    {
                      uint64_t v31 = v24 + *(_DWORD *)this * (uint64_t)v30;
                      if (v4[v31] != 9) {
                        break;
                      }
                      v4[v31] = 0;
                      ++v30;
                    }
                    while (v30 < *((_DWORD *)this + 1));
LABEL_37:
                    int v75 = v30;
                    int v77 = v30;
                  }
                  break;
                case 0xCu:
                  if (v27 < v11)
                  {
                    int v28 = v11 - 1;
                    uint64_t v33 = v11 - (uint64_t)v27;
                    while (v4[v20 * v11 + 1 + v24] == 12)
                    {
                      ++v24;
                      if (!--v33)
                      {
LABEL_42:
                        int v72 = v11;
                        int v74 = v11;
                        int v24 = v28;
                        goto LABEL_44;
                      }
                    }
LABEL_43:
                    int v72 = v24 + 1;
                    int v74 = v24 + 1;
                  }
                  break;
                default:
                  break;
              }
LABEL_44:
              uint64_t v34 = 0;
              int v35 = 0;
              do
              {
                if ((v25 >> v34))
                {
                  *(float32x2_t *)&v79[2 * v35++ - 1] = vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v71[2 * v34]), v68);
                  float v36 = 1.0;
                }
                else
                {
                  float v36 = 0.0;
                }
                uint64_t v37 = v34 + 1;
                if ((v25 >> ((v34 + 1) & 3))) {
                  float v38 = 1.0;
                }
                else {
                  float v38 = 0.0;
                }
                if (v36 != v38) {
                  *(float32x2_t *)&v79[2 * v35++ - 1] = vmla_n_f32(vmul_n_f32(vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v71[2 * (v37 & 3)]), v68), v36 / (float)(v36 - v38)), vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v71[2 * v34]), v68), 1.0 - (float)(v36 / (float)(v36 - v38)));
                }
                ++v34;
              }
              while (v37 != 4);
              if (v35 > 2)
              {
                uint64_t v39 = (char *)operator new(0x40uLL);
                *((void *)v39 + 1) = 0;
                *((void *)v39 + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
                *(void *)uint64_t v39 = &unk_26C3F4398;
                *((_OWORD *)v39 + b2DynamicTree::~b2DynamicTree(this + 2) = 0u;
                unint64_t v40 = (float **)(v39 + 32);
                *((_OWORD *)v39 + 3) = 0u;
                std::vector<PKPoint>::reserve((void **)v39 + 4, v35);
                uint64_t v41 = 0;
                unint64_t v42 = v39 + 48;
                uint64_t v43 = (float32x2_t *)*((void *)v39 + 5);
                do
                {
                  float32x2_t v44 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(vmla_f32(*(float32x2_t *)&v79[2 * v41 - 1], (float32x2_t)0x3F0000003F000000, v22)), v66));
                  if ((unint64_t)v43 >= *v42)
                  {
                    unint64_t v46 = (char *)*v40;
                    uint64_t v47 = ((char *)v43 - (char *)*v40) >> 3;
                    unint64_t v48 = v47 + 1;
                    if ((unint64_t)(v47 + 1) >> 61) {
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v49 = *v42 - (void)v46;
                    if (v49 >> 2 > v48) {
                      unint64_t v48 = v49 >> 2;
                    }
                    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v50 = v48;
                    }
                    if (v50)
                    {
                      int v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v39 + 48), v50);
                      unint64_t v46 = (char *)*((void *)v39 + 4);
                      uint64_t v43 = (float32x2_t *)*((void *)v39 + 5);
                    }
                    else
                    {
                      int v51 = 0;
                    }
                    float v52 = (float32x2_t *)&v51[8 * v47];
                    float32x2_t *v52 = v44;
                    uint64_t v45 = v52 + 1;
                    if (v43 != (float32x2_t *)v46)
                    {
                      do
                      {
                        float32x2_t v53 = v43[-1];
                        --v43;
                        v52[-1] = v53;
                        --v52;
                      }
                      while (v43 != (float32x2_t *)v46);
                      unint64_t v46 = (char *)*v40;
                    }
                    *((void *)v39 + 4) = v52;
                    *((void *)v39 + 5) = v45;
                    *((void *)v39 + 6) = &v51[8 * v50];
                    if (v46) {
                      operator delete(v46);
                    }
                  }
                  else
                  {
                    float32x2_t *v43 = v44;
                    uint64_t v45 = v43 + 1;
                  }
                  *((void *)v39 + 5) = v45;
                  ++v41;
                  uint64_t v43 = v45;
                }
                while (v41 != v35);
                int v54 = *v40 + 3;
                float v55 = **v40;
                uint64_t v56 = v35 - 1;
                float v57 = 0.0;
                do
                {
                  float v58 = *(v54 - 2);
                  float v59 = *(v54 - 1);
                  float v60 = *v54;
                  v54 += 2;
                  float v57 = v57
                      + sqrtf((float)((float)(v60 - v58) * (float)(v60 - v58))+ (float)((float)(v59 - v55) * (float)(v59 - v55)));
                  float v55 = v59;
                  --v56;
                }
                while (v56);
                *((float *)v39 + 6) = v57;
                uint64_t v69 = v39 + 24;
                unint64_t v70 = (std::__shared_weak_count *)v39;
                atomic_fetch_add_explicit((atomic_ullong *volatile)v39 + 1, 1uLL, memory_order_relaxed);
                addPolygonFromPath(v63, (uint64_t)&v69);
                uint64_t v4 = v62;
                int v23 = v64;
                int v20 = v65;
                if (v70) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v70);
                }
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39);
              }
              int v11 = *(_DWORD *)this;
            }
            ++v24;
          }
          while (v24 < v11 - 1);
          int v5 = *((_DWORD *)this + 1);
        }
        int v20 = v23;
      }
      while (v23 < v5);
    }
  }
  free(v4);
  v63->_shapeType = 7;
  [(PKPhysicsBody *)v63 set_allowSleep:1];

  return v63;
}

void sub_21358A65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::__append(void *a1, unint64_t a2, unsigned char *a3)
{
  unint64_t v4 = a2;
  int v7 = (unsigned char *)a1[1];
  uint64_t v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      int v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      int v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = &v7[-*a1];
    unint64_t v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = v6 - *a1;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      int v12 = operator new(v11);
    }
    else {
      int v12 = 0;
    }
    uint64_t v14 = &v8[(void)v12];
    int v15 = &v8[(void)v12 + v4];
    unint64_t v16 = &v8[(void)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    unsigned int v17 = (unsigned char *)*a1;
    if (v7 != (unsigned char *)*a1)
    {
      do
      {
        char v18 = *--v7;
        *--uint64_t v14 = v18;
      }
      while (v7 != v17);
      int v7 = (unsigned char *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  int v5 = (char *)a1[1];
  unint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    int v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    int v12 = &v7[v11];
    int v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v4, v12);
    }
    else {
      int v13 = 0;
    }
    uint64_t v14 = &v13[16 * v10];
    char v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    unint64_t v16 = &v14[16 * a2];
    char v18 = (char *)*a1;
    unsigned int v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        long long v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      unsigned int v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    float result = std::vector<CGPoint>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21358AAB4(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CGPoint>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

char *std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  int v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    int v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      char v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v9, v17);
    }
    else {
      char v18 = 0;
    }
    int v28 = &v18[16 * v15];
    __p = v18;
    uint64_t v34 = v28;
    float v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    int v30 = &v28[16 * a5];
    do
    {
      long long v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)int v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    int v35 = v30;
    int v5 = (char *)std::vector<CGPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    CGFloat v21 = &__src[16 * a5];
    int v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[16 * a5];
    unsigned int v25 = &v23[-16 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)uint64_t v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  CGFloat v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  int v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21358ACEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CGPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  int v5 = *(void **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    size_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      uint64_t v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  int v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char *std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint*>,std::__wrap_iter<CGPoint*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  int v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    int v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      char v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v9, v17);
    }
    else {
      char v18 = 0;
    }
    int v28 = &v18[16 * v15];
    __p = v18;
    uint64_t v34 = v28;
    float v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    int v30 = &v28[16 * a5];
    do
    {
      long long v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)int v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    int v35 = v30;
    int v5 = (char *)std::vector<CGPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    CGFloat v21 = &__src[16 * a5];
    int v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[16 * a5];
    unsigned int v25 = &v23[-16 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)uint64_t v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  CGFloat v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  int v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_21358AFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

void std::allocate_shared[abi:ne180100]<QuadTree,std::allocator<QuadTree>,float,float,float,float,float,void>(uint64_t a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  uint64_t v11 = operator new(0x20uLL);
  std::__shared_ptr_emplace<QuadTree>::__shared_ptr_emplace[abi:ne180100]<float,float,float,float,float,std::allocator<QuadTree>,0>((uint64_t)v11, a2, a3, a4, a5, a6);
}

void sub_21358B0BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<QuadTree>::__shared_ptr_emplace[abi:ne180100]<float,float,float,float,float,std::allocator<QuadTree>,0>(uint64_t a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C3F4408;
  QuadTree::QuadTree((QuadTree *)(a1 + 24), *a2, *a3, *a4, *a5, *a6);
}

void sub_21358B12C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<QuadTree>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4408;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QuadTree>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3F4408;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21668C8E0);
}

void std::__shared_ptr_emplace<QuadTree>::__on_zero_shared(uint64_t a1)
{
}

float b2PrismaticJointDef::Initialize(b2PrismaticJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  this->bodyA = a2;
  this->bodyB = a3;
  float v7 = a4->x - a2->var8.var0.x;
  float v8 = a4->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  this->localAnchorA.CGFloat x = (float)(v8 * var0) + (float)(var1 * v7);
  this->localAnchorA.float y = (float)(var1 * v8) - (float)(var0 * v7);
  float v11 = a4->x - a3->var8.var0.x;
  float v12 = a4->y - a3->var8.var0.y;
  float v14 = a3->var8.var1.var0;
  float v13 = a3->var8.var1.var1;
  this->localAnchorB.CGFloat x = (float)(v12 * v14) + (float)(v13 * v11);
  this->localAnchorB.float y = (float)(v13 * v12) - (float)(v14 * v11);
  float v16 = a2->var8.var1.var0;
  float v15 = a2->var8.var1.var1;
  float y = a5->y;
  float v18 = (float)(v16 * y) + (float)(v15 * a5->x);
  float v19 = (float)(v15 * y) - (float)(v16 * a5->x);
  this->localAxisA.CGFloat x = v18;
  this->localAxisA.float y = v19;
  float v20 = atan2f(a3->var8.var1.var0, a3->var8.var1.var1);
  float result = v20 - atan2f(a2->var8.var1.var0, a2->var8.var1.var1);
  this->referenceAngle = result;
  return result;
}

void b2PrismaticJoint::b2PrismaticJoint(b2PrismaticJoint *this, const b2JointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, a2);
  *(void *)uint64_t v3 = &unk_26C3F3B68;
  *(void *)(v3 + 128) = *(void *)(&a2->var4 + 4);
  *(void *)(v3 + 136) = *(void *)(&a2[1].var0 + 1);
  b2Vec2 v4 = *(b2Vec2 *)((char *)&a2[1].var1 + 4);
  *(b2Vec2 *)(v3 + 144) = v4;
  float y = v4.y;
  float x = v4.x;
  float v7 = sqrtf((float)(v4.y * v4.y) + (float)(v4.x * v4.x));
  if (v7 >= 0.00000011921)
  {
    float v8 = 1.0 / v7;
    float x = v8 * v4.x;
    float y = v8 * v4.y;
    *(float *)(v3 + 144) = v8 * v4.x;
    *(float *)(v3 + 148) = v8 * v4.y;
  }
  *(float *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = -y;
  *(float *)(v3 + 156) = x;
  *(_DWORD *)(v3 + 160) = HIDWORD(a2[1].var2);
  *(_DWORD *)(v3 + 31b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 17b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 164) = 0;
  *(void *)&long long v9 = *(b2Body **)((char *)&a2[1].var3 + 4);
  *((void *)&v9 + 1) = *(void *)&a2[2].var0;
  *(_OWORD *)(v3 + 180) = v9;
  *(unsigned char *)(v3 + 196) = a2[1].var3;
  *(unsigned char *)(v3 + 197) = *(&a2[1].var4 + 4);
  *(_DWORD *)(v3 + 200) = 0;
  *(void *)(v3 + 25b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 244) = 0;
}

void b2PrismaticJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 204) = v6;
  *(_DWORD *)(a1 + 208) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 220) = v9;
  float v10 = *(float *)(v4 + 212);
  float v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 228) = v10;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v11;
  float v12 = *(float *)(v4 + 224);
  float v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 236) = v12;
  *(float *)(a1 + 240) = v13;
  uint64_t v14 = *(void *)(a2 + 24);
  uint64_t v15 = *(void *)(a2 + 32);
  float v16 = (float *)(v14 + 16 * v6);
  float v86 = *v16;
  float v87 = v16[1];
  unint64_t v17 = (float *)(v15 + 16 * v6);
  float v82 = *v17;
  float v83 = v17[3];
  float v18 = (float *)(v14 + 16 * v7);
  float v19 = v18[1];
  float v84 = v17[1];
  float v85 = *v18;
  float v20 = v18[3];
  CGFloat v21 = (float *)(v15 + 16 * v7);
  float v80 = v21[1];
  float v81 = *v21;
  float v79 = v21[3];
  __float2 v24 = __sincosf_stret(v16[3]);
  float cosval = v24.__cosval;
  LODWORD(v2b2DynamicTree::~b2DynamicTree(this + 2) = *(void *)&v24;
  __float2 v25 = __sincosf_stret(v20);
  float v26 = *(float *)(a1 + 128) - *(float *)&v8;
  float v27 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  float v28 = (float)(cosval * v26) - (float)(v22 * v27);
  float v29 = (float)(cosval * v27) + (float)(v22 * v26);
  float v30 = *(float *)(a1 + 136) - *(float *)&v9;
  float v31 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  float v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  float v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  float v34 = (float)((float)(v85 - v86) + v32) - v28;
  float v35 = (float)((float)(v19 - v87) + v33) - v29;
  float v36 = *(float *)(a1 + 144);
  float v37 = *(float *)(a1 + 148);
  float v38 = (float)(cosval * v36) - (float)(v22 * v37);
  float v39 = (float)(cosval * v37) + (float)(v22 * v36);
  *(float *)(a1 + 244) = v38;
  *(float *)(a1 + 248) = v39;
  float v40 = v28 + v34;
  float v41 = v29 + v35;
  _S2 = (float)(v40 * v39) - (float)((float)(v29 + v35) * v38);
  *(float *)(a1 + 268) = _S2;
  _S0 = (float)(v32 * v39) - (float)(v33 * v38);
  *(float *)(a1 + 27b2DynamicTree::~b2DynamicTree(this + 2) = _S0;
  float v44 = (float)((float)(v10 + v11) + (float)((float)(v12 * _S2) * _S2)) + (float)((float)(v13 * _S0) * _S0);
  float v45 = 1.0 / v44;
  if (v44 <= 0.0) {
    float v45 = (float)((float)(v10 + v11) + (float)((float)(v12 * _S2) * _S2)) + (float)((float)(v13 * _S0) * _S0);
  }
  *(float *)(a1 + 31b2DynamicTree::~b2DynamicTree(this + 2) = v45;
  float v46 = *(float *)(a1 + 152);
  float v47 = *(float *)(a1 + 156);
  float v48 = (float)(cosval * v46) - (float)(v22 * v47);
  float v49 = (float)(cosval * v47) + (float)(v22 * v46);
  *(float *)(a1 + 25b2DynamicTree::~b2DynamicTree(this + 2) = v48;
  *(float *)(a1 + 256) = v49;
  float v50 = (float)(v40 * v49) - (float)(v41 * v48);
  *(float *)(a1 + 260) = v50;
  float v51 = (float)(v32 * v49) - (float)(v33 * v48);
  *(float *)(a1 + 264) = v51;
  float v52 = (float)(v13 * v51) + (float)(v12 * v50);
  float v53 = (float)(_S0 * (float)(v13 * v51)) + (float)((float)(v12 * v50) * _S2);
  float v54 = v12 + v13;
  if ((float)(v12 + v13) == 0.0) {
    float v54 = 1.0;
  }
  float v55 = (float)(v13 * _S0) + (float)(v12 * _S2);
  *(float *)(a1 + 276) = (float)((float)(v10 + v11) + (float)((float)(v12 * v50) * v50))
                       + (float)((float)(v13 * v51) * v51);
  *(float *)(a1 + 280) = v52;
  *(float *)(a1 + 284) = v53;
  *(float *)(a1 + 288) = v52;
  *(float *)(a1 + 29b2DynamicTree::~b2DynamicTree(this + 2) = v54;
  *(float *)(a1 + 296) = v55;
  *(float *)(a1 + 300) = v53;
  *(float *)(a1 + 304) = v55;
  *(float *)(a1 + 308) = v44;
  if (!*(unsigned char *)(a1 + 196)) {
    goto LABEL_12;
  }
  float v57 = *(float *)(a1 + 180);
  float v56 = *(float *)(a1 + 184);
  float v58 = v56 - v57;
  if ((float)(v56 - v57) <= 0.0) {
    float v58 = -(float)(v56 - v57);
  }
  if (v58 < 0.009)
  {
    *(_DWORD *)(a1 + 200) = 3;
LABEL_13:
    float v61 = v83;
    float v60 = v84;
    float v63 = v81;
    float v62 = v82;
    float v65 = v79;
    float v64 = v80;
    goto LABEL_14;
  }
  float v59 = (float)(v39 * v35) + (float)(v38 * v34);
  if (v59 <= v57)
  {
    float v61 = v83;
    float v60 = v84;
    float v63 = v81;
    float v62 = v82;
    float v65 = v79;
    float v64 = v80;
    if (*(_DWORD *)(a1 + 200) == 1) {
      goto LABEL_14;
    }
    int v78 = 1;
    goto LABEL_24;
  }
  if (v59 < v56)
  {
LABEL_12:
    *(_DWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    goto LABEL_13;
  }
  float v61 = v83;
  float v60 = v84;
  float v63 = v81;
  float v62 = v82;
  float v65 = v79;
  float v64 = v80;
  if (*(_DWORD *)(a1 + 200) != 2)
  {
    int v78 = 2;
LABEL_24:
    *(_DWORD *)(a1 + 200) = v78;
    *(_DWORD *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  }
LABEL_14:
  if (!*(unsigned char *)(a1 + 197)) {
    *(_DWORD *)(a1 + 176) = 0;
  }
  if (*(unsigned char *)(a2 + 20))
  {
    float32x4_t v66 = vmulq_n_f32(*(float32x4_t *)(a1 + 164), COERCE_FLOAT(*(_OWORD *)(a2 + 8)));
    *(float32x4_t *)(a1 + 164) = v66;
    _Q17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3), v66);
    float v68 = (float)(v48 * v66.f32[0]) + vmuls_lane_f32(v38, _Q17, 2);
    float v69 = (float)(v49 * v66.f32[0]) + vmuls_lane_f32(v39, _Q17, 2);
    __asm
    {
      FMLA            S7, S2, V17.S[2]
      FMLA            S6, S0, V17.S[2]
    }
    float v62 = v62 - (float)(v10 * v68);
    float v60 = v60 - (float)(v10 * v69);
    float v61 = v61 - (float)(v12 * _S7);
    float v63 = v63 + (float)(v11 * v68);
    float v64 = v64 + (float)(v11 * v69);
    float v65 = v65 + (float)(v13 * _S6);
  }
  else
  {
    *(void *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    *(void *)(a1 + 164) = 0;
  }
  int v76 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 204));
  float *v76 = v62;
  v76[1] = v60;
  v76[3] = v61;
  int v77 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 208));
  *int v77 = v63;
  v77[1] = v64;
  v77[3] = v65;
}

void b2PrismaticJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 204));
  float v6 = *v5;
  float v7 = v5[1];
  float v8 = v5[3];
  uint64_t v9 = (float *)(v4 + 16 * *(int *)(a1 + 208));
  float v10 = *v9;
  float v11 = v9[1];
  float v12 = v9[3];
  float v14 = *(float *)(a1 + 228);
  float v13 = *(float *)(a1 + 232);
  float v16 = *(float *)(a1 + 236);
  float v15 = *(float *)(a1 + 240);
  if (*(unsigned char *)(a1 + 197) && *(_DWORD *)(a1 + 200) != 3)
  {
    float v17 = *(float *)(a1 + 244);
    float v18 = *(float *)(a1 + 248);
    float v19 = *(float *)(a1 + 272);
    float v20 = *(float *)(a1 + 268);
    float v21 = *(float *)(a1 + 188);
    float v22 = *(float *)(a1 + 176);
    float v23 = *(float *)a2 * v21;
    float v24 = v22
        + (float)(*(float *)(a1 + 312)
                * (float)(*(float *)(a1 + 192)
                        - (float)((float)((float)((float)((float)(v11 - v7) * v18) + (float)(v17 * (float)(v10 - v6)))
                                        + (float)(v19 * v12))
                                - (float)(v20 * v8))));
    if (v24 >= v23) {
      float v24 = *(float *)a2 * v21;
    }
    if (v24 < (float)-v23) {
      float v24 = -v23;
    }
    *(float *)(a1 + 176) = v24;
    float v25 = v24 - v22;
    float v26 = v17 * v25;
    float v27 = v18 * v25;
    float v6 = v6 - (float)(v14 * v26);
    float v7 = v7 - (float)(v14 * v27);
    float v8 = v8 - (float)(v16 * (float)(v20 * v25));
    float v10 = v10 + (float)(v13 * v26);
    float v11 = v11 + (float)(v13 * v27);
    float v12 = v12 + (float)(v15 * (float)(v19 * v25));
  }
  float v67 = v16;
  float v68 = v15;
  float v28 = (float)((float)((float)((float)(v11 - v7) * *(float *)(a1 + 256))
                      + (float)(*(float *)(a1 + 252) * (float)(v10 - v6)))
              + (float)(*(float *)(a1 + 264) * v12))
      - (float)(*(float *)(a1 + 260) * v8);
  float v29 = v12 - v8;
  if (*(unsigned char *)(a1 + 196) && *(_DWORD *)(a1 + 200))
  {
    float v65 = v14;
    float v66 = v13;
    float v30 = (float)((float)((float)(v11 - v7) * *(float *)(a1 + 248)) + (float)(*(float *)(a1 + 244) * (float)(v10 - v6)))
        + (float)(*(float *)(a1 + 272) * v12);
    float v31 = -*(float *)(a1 + 268);
    float v62 = *(float *)(a1 + 168);
    float v63 = *(float *)(a1 + 164);
    float v64 = *(float *)(a1 + 172);
    float v32 = -v28;
    float v33 = -v29;
    v69.float var0 = -v28;
    v69.float var1 = -v29;
    v69.float var2 = -(float)(v30 + (float)(v31 * v8));
    float v34 = b2Mat33::Solve33((b2Mat33 *)(a1 + 276), &v69);
    float v35 = *(float *)(a1 + 168);
    *(float *)(a1 + 164) = v34 + *(float *)(a1 + 164);
    *(float *)(a1 + 168) = v36 + v35;
    float v38 = v37 + *(float *)(a1 + 172);
    *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v38;
    int v39 = *(_DWORD *)(a1 + 200);
    if (v39 == 2)
    {
      BOOL v40 = v38 < 0.0;
    }
    else
    {
      if (v39 != 1)
      {
LABEL_18:
        float v49 = v38 - v64;
        float v50 = v32 - (float)(*(float *)(a1 + 300) * v49);
        float v51 = v33 - (float)(v49 * *(float *)(a1 + 304));
        v69.float var0 = v50;
        v69.float var1 = v51;
        float v52 = v63 + b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v69);
        float v54 = v62 + v53;
        *(float *)(a1 + 164) = v52;
        *(float *)(a1 + 168) = v54;
        float v55 = v52 - v63;
        float v56 = v54 - v62;
        float v57 = *(float *)(a1 + 172) - v64;
        float32x2_t v44 = vadd_f32(vmul_n_f32(*(float32x2_t *)(a1 + 252), v55), vmul_n_f32(*(float32x2_t *)(a1 + 244), v57));
        float v58 = (float)(v56 + (float)(v55 * *(float *)(a1 + 260))) + (float)(v57 * *(float *)(a1 + 268));
        float v59 = (float)(v56 + (float)(v55 * *(float *)(a1 + 264))) + (float)(v57 * *(float *)(a1 + 272));
        float v47 = v8 - (float)(v67 * v58);
        float v48 = v12 + (float)(v68 * v59);
        float v14 = v65;
        float v13 = v66;
        goto LABEL_19;
      }
      BOOL v40 = v38 > 0.0;
    }
    if (!v40) {
      float v38 = 0.0;
    }
    *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v38;
    goto LABEL_18;
  }
  v69.float var0 = -v28;
  v69.float var1 = -v29;
  float v41 = b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v69);
  float v43 = v42 + *(float *)(a1 + 168);
  *(float *)(a1 + 164) = v41 + *(float *)(a1 + 164);
  *(float *)(a1 + 168) = v43;
  float32x2_t v44 = vmul_n_f32(*(float32x2_t *)(a1 + 252), v41);
  float v45 = v42 + (float)(v41 * *(float *)(a1 + 260));
  float v46 = v42 + (float)(v41 * *(float *)(a1 + 264));
  float v47 = v8 - (float)(v67 * v45);
  float v48 = v12 + (float)(v68 * v46);
LABEL_19:
  float v60 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 204));
  *float v60 = v6 - (float)(v14 * v44.f32[0]);
  v60[1] = v7 - vmuls_lane_f32(v14, v44, 1);
  v60[3] = v47;
  float v61 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 208));
  float *v61 = v10 + (float)(v13 * v44.f32[0]);
  v61[1] = v11 + vmuls_lane_f32(v13, v44, 1);
  v61[3] = v48;
}

BOOL b2PrismaticJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 204));
  float v6 = *v5;
  float v7 = v5[1];
  float v8 = v5[3];
  float v115 = v8;
  uint64_t v9 = (float *)(v4 + 16 * *(int *)(a1 + 208));
  float v11 = *v9;
  float v10 = v9[1];
  float v12 = v9[3];
  __float2 v13 = __sincosf_stret(v8);
  __float2 v14 = __sincosf_stret(v12);
  float v16 = *(float *)(a1 + 228);
  float v15 = *(float *)(a1 + 232);
  float v18 = *(float *)(a1 + 236);
  float v17 = *(float *)(a1 + 240);
  float v19 = *(float *)(a1 + 128) - *(float *)(a1 + 212);
  float v20 = *(float *)(a1 + 132) - *(float *)(a1 + 216);
  float v21 = (float)(v13.__cosval * v19) - (float)(v13.__sinval * v20);
  float v22 = (float)(v13.__cosval * v20) + (float)(v13.__sinval * v19);
  float v23 = *(float *)(a1 + 136) - *(float *)(a1 + 220);
  float v24 = *(float *)(a1 + 140) - *(float *)(a1 + 224);
  float v25 = (float)(v14.__cosval * v23) - (float)(v14.__sinval * v24);
  float v26 = (float)(v14.__cosval * v24) + (float)(v14.__sinval * v23);
  float v117 = v7;
  float v118 = v11;
  float v27 = v11 + v25;
  float v28 = v22;
  float v120 = v10;
  float v29 = v10 + v26;
  float v30 = v26;
  float v116 = v6;
  float v31 = (float)(v27 - v6) - v21;
  float v32 = (float)(v29 - v7) - v22;
  float v33 = *(float *)(a1 + 144);
  float v34 = *(float *)(a1 + 148);
  float v35 = (float)(v13.__cosval * v33) - (float)(v13.__sinval * v34);
  float v36 = (float)(v13.__cosval * v34) + (float)(v13.__sinval * v33);
  float v37 = *(float *)(a1 + 152);
  float v38 = *(float *)(a1 + 156);
  float v39 = (float)(v13.__cosval * v37) - (float)(v13.__sinval * v38);
  float v40 = (float)(v13.__cosval * v38) + (float)(v13.__sinval * v37);
  float v41 = (float)(v40 * v32) + (float)(v39 * v31);
  float v119 = v12;
  float v42 = (float)(v12 - v8) - *(float *)(a1 + 160);
  float v43 = -v41;
  if (v41 <= 0.0) {
    float v44 = -v41;
  }
  else {
    float v44 = (float)(v40 * v32) + (float)(v39 * v31);
  }
  float v45 = -v42;
  float v113 = v36;
  float v114 = v21;
  float v111 = v40;
  float v112 = v32;
  if (*(unsigned char *)(a1 + 196))
  {
    float v46 = (float)(v36 * v32) + (float)(v35 * v31);
    float v48 = *(float *)(a1 + 180);
    float v47 = *(float *)(a1 + 184);
    float v49 = v47 - v48;
    if ((float)(v47 - v48) <= 0.0) {
      float v49 = -(float)(v47 - v48);
    }
    if (v49 < 0.009)
    {
      float v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      float v105 = v39;
      float v107 = v31;
      float v109 = v25;
      float v102 = v35;
      float v50 = fminf(v46, 0.2);
      if (v50 < -0.2) {
        float v50 = -0.2;
      }
      if (v46 <= 0.0) {
        float v46 = -v46;
      }
LABEL_23:
      if (v44 <= v46) {
        float v44 = v46;
      }
      float v76 = *(float *)(a1 + 260);
      float v77 = v18 * v76;
      float v78 = *(float *)(a1 + 264);
      float v79 = v17 * v78;
      float v80 = (float)((float)(v16 + v15) + (float)((float)(v18 * v76) * v76)) + (float)((float)(v17 * v78) * v78);
      float v81 = (float)(v17 * v78) + (float)(v18 * v76);
      float v82 = *(float *)(a1 + 268);
      float v83 = *(float *)(a1 + 272);
      float v84 = (float)(v79 * v83) + (float)(v77 * v82);
      float v85 = v18 + v17;
      if ((float)(v18 + v17) == 0.0) {
        float v85 = 1.0;
      }
      float v86 = (float)(v17 * v83) + (float)(v18 * v82);
      *(float *)(a1 + 276) = v80;
      *(float *)(a1 + 280) = v81;
      *(float *)(a1 + 284) = v84;
      *(float *)(a1 + 288) = v81;
      *(float *)(a1 + 29b2DynamicTree::~b2DynamicTree(this + 2) = v85;
      *(float *)(a1 + 296) = v86;
      *(float *)(a1 + 300) = v84;
      *(float *)(a1 + 304) = v86;
      *(float *)(a1 + 308) = (float)((float)(v16 + v15) + (float)((float)(v18 * v82) * v82))
                           + (float)((float)(v17 * v83) * v83);
      v121.float var0 = v43;
      v121.float var1 = -v42;
      v121.float var2 = -v50;
      float v87 = v17;
      float v88 = v15;
      float v57 = v18;
      float v73 = v16;
      float v89 = v45;
      float v62 = b2Mat33::Solve33((b2Mat33 *)(a1 + 276), &v121);
      float v64 = v89;
      float v65 = v88;
      float v74 = v87;
      float v71 = v113;
      float v70 = v114;
      float v69 = v107;
      float v72 = v109;
      float v59 = v102;
      float v42 = v103;
      float v67 = v111;
      float v66 = v112;
      float v68 = v105;
      goto LABEL_28;
    }
    if (v46 <= v48)
    {
      float v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      float v105 = v39;
      float v107 = v31;
      float v109 = v25;
      float v102 = v35;
      float v50 = fminf((float)(v46 - v48) + 0.0045, 0.0);
      if (v50 < -0.2) {
        float v50 = -0.2;
      }
      float v46 = v48 - v46;
      goto LABEL_23;
    }
    if (v46 >= v47)
    {
      float v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      float v105 = v39;
      float v107 = v31;
      float v109 = v25;
      float v102 = v35;
      float v46 = v46 - v47;
      float v50 = fminf(v46 + -0.0045, 0.2);
      if (v50 < 0.0) {
        float v50 = 0.0;
      }
      goto LABEL_23;
    }
  }
  float v51 = *(float *)(a1 + 260);
  float v52 = *(float *)(a1 + 264);
  float v53 = (float)((float)(v16 + v15) + (float)((float)(v18 * v51) * v51)) + (float)((float)(v17 * v52) * v52);
  float v54 = (float)(v17 * v52) + (float)(v18 * v51);
  *(float *)(a1 + 276) = v53;
  *(float *)(a1 + 280) = v54;
  float v55 = 1.0;
  *(_DWORD *)(a1 + 284) = 0;
  *(float *)(a1 + 288) = v54;
  if ((float)(v18 + v17) != 0.0) {
    float v55 = v18 + v17;
  }
  *(float *)(a1 + 29b2DynamicTree::~b2DynamicTree(this + 2) = v55;
  *(_DWORD *)(a1 + 296) = 0;
  v121.float var0 = v43;
  v121.float var1 = -v42;
  float v56 = v17;
  float v104 = v15;
  float v106 = v16;
  float v57 = v18;
  float v108 = v28;
  float v110 = v30;
  float v58 = v25;
  float v59 = v35;
  float v60 = v31;
  float v61 = v39;
  float v62 = b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v121);
  float v64 = -v42;
  float v65 = v104;
  float v67 = v111;
  float v66 = v112;
  float v68 = v61;
  float v69 = v60;
  float v71 = v113;
  float v70 = v114;
  float v72 = v58;
  float v28 = v108;
  float v30 = v110;
  float v73 = v106;
  float v74 = v56;
  float v75 = 0.0;
LABEL_28:
  if (v42 <= 0.0) {
    float v90 = v64;
  }
  else {
    float v90 = v42;
  }
  float v91 = (float)(v72 * v67) - (float)(v30 * v68);
  float v92 = v70 + v69;
  float v93 = v28 + v66;
  float v94 = (float)(v92 * v67) - (float)((float)(v28 + v66) * v68);
  float v95 = (float)(v72 * v71) - (float)(v30 * v59);
  float v96 = (float)(v92 * v71) - (float)(v93 * v59);
  float v97 = (float)(v68 * v62) + (float)(v59 * v75);
  float v98 = (float)(v67 * v62) + (float)(v71 * v75);
  unint64_t v99 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 204));
  *unint64_t v99 = v116 - (float)(v73 * v97);
  v99[1] = v117 - (float)(v73 * v98);
  v99[3] = v115 - (float)(v57 * (float)((float)(v63 + (float)(v62 * v94)) + (float)(v75 * v96)));
  uint64_t v100 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 208));
  *uint64_t v100 = v118 + (float)(v65 * v97);
  v100[1] = v120 + (float)(v65 * v98);
  v100[3] = v119 + (float)(v74 * (float)((float)(v63 + (float)(v62 * v91)) + (float)(v75 * v95)));
  return v90 <= 0.034907 && v44 <= 0.0045;
}

float b2PrismaticJoint::GetAnchorA(b2PrismaticJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2PrismaticJoint::GetAnchorB(b2PrismaticJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float32x2_t b2PrismaticJoint::GetReactionForce(b2PrismaticJoint *this, float a2)
{
  return vmul_n_f32(vadd_f32(vmul_n_f32((float32x2_t)this->var34, this->var16.var0), vmul_n_f32((float32x2_t)this->var33, this->var17 + this->var16.var2)), a2);
}

float b2PrismaticJoint::GetReactionTorque(b2PrismaticJoint *this, float a2)
{
  return this->var16.var1 * a2;
}

float b2PrismaticJoint::GetJointTranslation(b2PrismaticJoint *this)
{
  unsigned __int16 var6 = this->var6;
  var7 = this->var7;
  float var0 = var6->var8.var1.var0;
  float var1 = var6->var8.var1.var1;
  float x = this->var11.x;
  return (float)((float)((float)((float)((float)(var7->var8.var1.var1 * this->var12.y)
                                       + (float)(var7->var8.var1.var0 * this->var12.x))
                               + var7->var8.var0.y)
                       - (float)((float)((float)(var1 * this->var11.y) + (float)(var0 * x)) + var6->var8.var0.y))
               * (float)((float)(var1 * this->var13.y) + (float)(var0 * this->var13.x)))
       + (float)((float)((float)(var7->var8.var0.x
                               + (float)((float)(var7->var8.var1.var1 * this->var12.x)
                                       - (float)(var7->var8.var1.var0 * this->var12.y)))
                       - (float)(var6->var8.var0.x + (float)((float)(var1 * x) - (float)(var0 * this->var11.y))))
               * (float)((float)(var1 * this->var13.x) - (float)(var0 * this->var13.y)));
}

float b2PrismaticJoint::GetJointSpeed(b2PrismaticJoint *this)
{
  p_float var0 = (float *)&this->var6->var0;
  int v2 = (float *)&this->var7->var0;
  float v3 = this->var11.x - p_var0[16];
  float v4 = this->var11.y - p_var0[17];
  float v6 = p_var0[10];
  float v5 = p_var0[11];
  float v7 = (float)(v5 * v3) - (float)(v6 * v4);
  float v8 = (float)(v5 * v4) + (float)(v6 * v3);
  float v9 = this->var12.x - v2[16];
  float v10 = this->var12.y - v2[17];
  float v12 = v2[10];
  float v11 = v2[11];
  float v13 = (float)(v11 * v9) - (float)(v12 * v10);
  float v14 = (float)(v11 * v10) + (float)(v12 * v9);
  float x = this->var13.x;
  float y = this->var13.y;
  float v17 = p_var0[34];
  return (float)((float)((float)((float)(v14 + v2[25]) - (float)(v8 + p_var0[25]))
                       * (float)((float)((float)(v5 * x) - (float)(v6 * y)) * v17))
               + (float)((float)((float)(v13 + v2[24]) - (float)(v7 + p_var0[24]))
                       * (float)-(float)(v17 * (float)((float)(v5 * y) + (float)(v6 * x)))))
       + (float)((float)((float)((float)(v5 * y) + (float)(v6 * x))
                       * (float)((float)((float)(v2[33] + (float)(v13 * v2[34])) - p_var0[33]) - (float)(v7 * v17)))
               + (float)((float)((float)(v5 * x) - (float)(v6 * y))
                       * (float)((float)(v8 * v17) + (float)((float)(v2[32] - (float)(v14 * v2[34])) - p_var0[32]))));
}

BOOL b2PrismaticJoint::IsLimitEnabled(b2PrismaticJoint *this)
{
  return this->var22;
}

b2PrismaticJoint *b2PrismaticJoint::EnableLimit(b2PrismaticJoint *this, BOOL a2)
{
  if (this->var22 != a2)
  {
    BOOL v2 = a2;
    float v3 = this;
    b2Body::SetAwake(this->var6, 1);
    this = (b2PrismaticJoint *)b2Body::SetAwake(v3->var7, 1);
    v3->var22 = v2;
    v3->var16.float var2 = 0.0;
  }
  return this;
}

float b2PrismaticJoint::GetLowerLimit(b2PrismaticJoint *this)
{
  return this->var18;
}

float b2PrismaticJoint::GetUpperLimit(b2PrismaticJoint *this)
{
  return this->var19;
}

b2PrismaticJoint *b2PrismaticJoint::SetLimits(b2PrismaticJoint *this, float a2, float a3)
{
  if (a2 > a3) {
    b2PrismaticJoint::SetLimits();
  }
  float v5 = this;
  if (this->var18 != a2 || this->var19 != a3)
  {
    b2Body::SetAwake(this->var6, 1);
    this = (b2PrismaticJoint *)b2Body::SetAwake(v5->var7, 1);
    v5->var18 = a2;
    v5->var19 = a3;
    v5->var16.float var2 = 0.0;
  }
  return this;
}

BOOL b2PrismaticJoint::IsMotorEnabled(b2PrismaticJoint *this)
{
  return this->var23;
}

b2Body *b2PrismaticJoint::EnableMotor(b2PrismaticJoint *this, BOOL a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var23 = a2;
  return result;
}

b2Body *b2PrismaticJoint::SetMotorSpeed(b2PrismaticJoint *this, float a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var21 = a2;
  return result;
}

b2Body *b2PrismaticJoint::SetMaxMotorForce(b2PrismaticJoint *this, float a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var20 = a2;
  return result;
}

float b2PrismaticJoint::GetMotorForce(b2PrismaticJoint *this, float a2)
{
  return this->var17 * a2;
}

void b2PrismaticJoint::~b2PrismaticJoint(b2PrismaticJoint *this)
{
}

uint64_t b2PulleyJointDef::Initialize(uint64_t this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5, const b2Vec2 *a6, const b2Vec2 *a7, float a8)
{
  *(void *)(this + 16) = a2;
  *(void *)(this + 24) = a3;
  *(b2Vec2 *)(this + 36) = *a4;
  *(b2Vec2 *)(this + 44) = *a5;
  float v8 = a6->x - a2->var8.var0.x;
  float v9 = a6->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  *(float *)(this + 5b2DynamicTree::~b2DynamicTree(this + 2) = (float)(v9 * var0) + (float)(var1 * v8);
  *(float *)(this + 56) = (float)(var1 * v9) - (float)(var0 * v8);
  float v12 = a7->x - a3->var8.var0.x;
  float v13 = a7->y - a3->var8.var0.y;
  float v15 = a3->var8.var1.var0;
  float v14 = a3->var8.var1.var1;
  *(float *)(this + 60) = (float)(v13 * v15) + (float)(v14 * v12);
  *(float *)(this + 64) = (float)(v14 * v13) - (float)(v15 * v12);
  float v16 = a6->y - a4->y;
  float v17 = sqrtf((float)(v16 * v16) + (float)((float)(a6->x - a4->x) * (float)(a6->x - a4->x)));
  float v18 = sqrtf((float)((float)(a7->y - a5->y) * (float)(a7->y - a5->y))+ (float)((float)(a7->x - a5->x) * (float)(a7->x - a5->x)));
  *(float *)(this + 68) = v17;
  *(float *)(this + 7b2DynamicTree::~b2DynamicTree(this + 2) = v18;
  *(float *)(this + 76) = a8;
  if (a8 <= 0.00000011921) {
    b2PulleyJointDef::Initialize();
  }
  return this;
}

void b2PulleyJoint::b2PulleyJoint(b2PulleyJoint *this, const b2PulleyJointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(void *)uint64_t v3 = &unk_26C3F3700;
  *(void *)(v3 + 128) = *(void *)((char *)a2 + 36);
  *(void *)(v3 + 136) = *(void *)((char *)a2 + 44);
  *(void *)(v3 + 144) = *(void *)((char *)a2 + 52);
  *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = *(void *)((char *)a2 + 60);
  float v4 = *((float *)a2 + 19);
  if (v4 == 0.0) {
    b2PulleyJoint::b2PulleyJoint();
  }
  *(float *)(v3 + 160) = *((float *)a2 + 17) + (float)(v4 * *((float *)a2 + 18));
  *(float *)(v3 + 164) = v4;
  *(_DWORD *)(v3 + 168) = 0;
}

void b2PulleyJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v6;
  *(_DWORD *)(a1 + 176) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 220) = v9;
  float v10 = *(float *)(v4 + 212);
  float v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 228) = v10;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v11;
  float v60 = v11;
  float v12 = *(float *)(v5 + 224);
  float v59 = *(float *)(v4 + 224);
  *(float *)(a1 + 236) = v59;
  *(float *)(a1 + 240) = v12;
  float v61 = v12;
  uint64_t v13 = *(void *)(a2 + 24);
  uint64_t v14 = *(void *)(a2 + 32);
  float v15 = (float *)(v13 + 16 * v6);
  float v17 = *v15;
  float v16 = v15[1];
  float v18 = (float *)(v14 + 16 * v6);
  float v67 = v18[1];
  float v65 = *v18;
  float v66 = v18[3];
  float v19 = (float *)(v13 + 16 * v7);
  float v20 = *v19;
  float v21 = v19[1];
  float v22 = v19[3];
  float v23 = (float *)(v14 + 16 * v7);
  float v63 = v23[1];
  float v64 = *v23;
  float v62 = v23[3];
  __float2 v24 = __sincosf_stret(v15[3]);
  __float2 v25 = __sincosf_stret(v22);
  float v26 = *(float *)(a1 + 144) - *(float *)&v8;
  float v27 = *(float *)(a1 + 148) - *((float *)&v8 + 1);
  float v28 = (float)(v24.__cosval * v26) - (float)(v24.__sinval * v27);
  float v29 = (float)(v24.__cosval * v27) + (float)(v24.__sinval * v26);
  *(float *)(a1 + 196) = v28;
  *(float *)(a1 + 200) = v29;
  float v30 = *(float *)(a1 + 152) - *(float *)&v9;
  float v31 = *(float *)(a1 + 156) - *((float *)&v9 + 1);
  float v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  float v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  *(float *)(a1 + 204) = v32;
  *(float *)(a1 + 208) = v33;
  float v34 = (float)(v17 + v28) - *(float *)(a1 + 128);
  float v35 = (float)(v16 + v29) - *(float *)(a1 + 132);
  float v36 = (float)(v20 + v32) - *(float *)(a1 + 136);
  float v37 = (float)(v21 + v33) - *(float *)(a1 + 140);
  float v38 = sqrtf((float)(v35 * v35) + (float)(v34 * v34));
  float v39 = sqrtf((float)(v37 * v37) + (float)(v36 * v36));
  float v40 = 0.0;
  float v41 = 0.0;
  float v42 = 0.0;
  if (v38 > 0.045)
  {
    float v41 = v34 * (float)(1.0 / v38);
    float v42 = v35 * (float)(1.0 / v38);
  }
  *(float *)(a1 + 180) = v41;
  *(float *)(a1 + 184) = v42;
  float v43 = 0.0;
  if (v39 > 0.045)
  {
    float v40 = v36 * (float)(1.0 / v39);
    float v43 = v37 * (float)(1.0 / v39);
  }
  *(float *)(a1 + 188) = v40;
  *(float *)(a1 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v43;
  float v44 = *(float *)(a1 + 164);
  float v45 = (float)(v10
              + (float)((float)(v59 * (float)((float)(v28 * v42) - (float)(v29 * v41)))
                      * (float)((float)(v28 * v42) - (float)(v29 * v41))))
      + (float)((float)(v44 * v44)
              * (float)(v60
                      + (float)((float)(v61 * (float)((float)(v32 * v43) - (float)(v33 * v40)))
                              * (float)((float)(v32 * v43) - (float)(v33 * v40)))));
  if (v45 > 0.0) {
    float v45 = 1.0 / v45;
  }
  *(float *)(a1 + 244) = v45;
  if (*(unsigned char *)(a2 + 20))
  {
    float v46 = *(float *)(a2 + 8) * *(float *)(a1 + 168);
    *(float *)(a1 + 168) = v46;
    float v47 = -(float)(v46 * v41);
    float v48 = -(float)(v46 * v42);
    float v49 = -(float)(v44 * v46);
    float v50 = v40 * v49;
    float v51 = v43 * v49;
    float v52 = v65 + (float)(v10 * v47);
    float v53 = v67 + (float)(v10 * v48);
    float v54 = v66 + (float)(v59 * (float)((float)(v47 * (float)-v29) + (float)(v28 * v48)));
    float v55 = v64 + (float)(v60 * v50);
    float v56 = v63 + (float)(v60 * v51);
    float v57 = v62 + (float)(v61 * (float)((float)(v50 * (float)-v33) + (float)(v32 * v51)));
  }
  else
  {
    *(_DWORD *)(a1 + 168) = 0;
    float v54 = v66;
    float v53 = v67;
    float v55 = v64;
    float v52 = v65;
    float v57 = v62;
    float v56 = v63;
  }
  *float v18 = v52;
  v18[1] = v53;
  v18[3] = v54;
  float v58 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  *float v58 = v55;
  v58[1] = v56;
  v58[3] = v57;
}

float b2PulleyJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = (float *)(v2 + 16 * *(int *)(a1 + 172));
  float v4 = *v3;
  float v5 = v3[1];
  float v6 = v3[3];
  uint64_t v7 = (float *)(v2 + 16 * *(int *)(a1 + 176));
  float v8 = *v7;
  float v9 = v7[1];
  float v10 = v7[3];
  float v12 = *(float *)(a1 + 196);
  float v11 = *(float *)(a1 + 200);
  float v14 = *(float *)(a1 + 204);
  float v13 = *(float *)(a1 + 208);
  float v15 = *(float *)(a1 + 180);
  float v16 = *(float *)(a1 + 184);
  float v17 = *(float *)(a1 + 188);
  float v18 = *(float *)(a1 + 192);
  float v19 = *(float *)(a1 + 164);
  float v20 = -(float)(*(float *)(a1 + 244)
               * (float)-(float)((float)((float)((float)(v5 + (float)(v6 * v12)) * v16)
                                       + (float)(v15 * (float)(*v3 - (float)(v6 * v11))))
                               + (float)(v19
                                       * (float)((float)((float)(v9 + (float)(v10 * v14)) * v18)
                                               + (float)(v17 * (float)(*v7 - (float)(v10 * v13)))))));
  *(float *)(a1 + 168) = *(float *)(a1 + 168)
                       - (float)(*(float *)(a1 + 244)
                               * (float)-(float)((float)((float)((float)(v5 + (float)(v6 * v12)) * v16)
                                                       + (float)(v15 * (float)(*v3 - (float)(v6 * v11))))
                                               + (float)(v19
                                                       * (float)((float)((float)(v9 + (float)(v10 * v14)) * v18)
                                                               + (float)(v17 * (float)(*v7 - (float)(v10 * v13)))))));
  float v21 = -(float)(v20 * v15);
  float v22 = -(float)(v20 * v16);
  float v23 = -(float)(v19 * v20);
  float v24 = v17 * v23;
  float v25 = v18 * v23;
  float v26 = *(float *)(a1 + 228);
  float v27 = *(float *)(a1 + 232);
  float result = v4 + (float)(v26 * v21);
  float v29 = v6 + (float)(*(float *)(a1 + 236) * (float)((float)(v12 * v22) - (float)(v11 * v21)));
  float v30 = v10 + (float)(*(float *)(a1 + 240) * (float)((float)(v14 * v25) - (float)(v13 * v24)));
  *uint64_t v3 = result;
  v3[1] = v5 + (float)(v26 * v22);
  v3[3] = v29;
  float v31 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  *float v31 = v8 + (float)(v24 * v27);
  v31[1] = v9 + (float)(v25 * v27);
  v31[3] = v30;
  return result;
}

BOOL b2PulleyJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  float v5 = (float *)(v4 + 16 * *(int *)(a1 + 172));
  float v7 = *v5;
  float v6 = v5[1];
  float v8 = v5[3];
  float v9 = (float *)(v4 + 16 * *(int *)(a1 + 176));
  float v11 = *v9;
  float v10 = v9[1];
  float v12 = v9[3];
  __float2 v13 = __sincosf_stret(v8);
  __float2 v14 = __sincosf_stret(v12);
  float v15 = *(float *)(a1 + 144) - *(float *)(a1 + 212);
  float v16 = *(float *)(a1 + 148) - *(float *)(a1 + 216);
  float v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  float v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  float v19 = *(float *)(a1 + 152) - *(float *)(a1 + 220);
  float v20 = *(float *)(a1 + 156) - *(float *)(a1 + 224);
  float v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  float v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  float v23 = (float)(v7 + v17) - *(float *)(a1 + 128);
  float v24 = (float)(v6 + v18) - *(float *)(a1 + 132);
  float v25 = (float)(v11 + v21) - *(float *)(a1 + 136);
  float v26 = (float)(v10 + v22) - *(float *)(a1 + 140);
  float v27 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  float v28 = sqrtf((float)(v26 * v26) + (float)(v25 * v25));
  float v29 = 0.0;
  float v30 = 0.0;
  float v31 = 0.0;
  if (v27 > 0.045)
  {
    float v30 = v23 * (float)(1.0 / v27);
    float v31 = v24 * (float)(1.0 / v27);
  }
  float v32 = 0.0;
  if (v28 > 0.045)
  {
    float v29 = v25 * (float)(1.0 / v28);
    float v32 = v26 * (float)(1.0 / v28);
  }
  float v33 = *(float *)(a1 + 236);
  float v34 = *(float *)(a1 + 240);
  float v35 = *(float *)(a1 + 228);
  float v36 = *(float *)(a1 + 232);
  float v37 = *(float *)(a1 + 164);
  float v38 = (float)(v35
              + (float)((float)((float)((float)(v17 * v31) - (float)(v18 * v30)) * v33)
                      * (float)((float)(v17 * v31) - (float)(v18 * v30))))
      + (float)((float)(v37 * v37)
              * (float)(v36
                      + (float)((float)((float)((float)(v21 * v32) - (float)(v22 * v29)) * v34)
                              * (float)((float)(v21 * v32) - (float)(v22 * v29)))));
  if (v38 > 0.0) {
    float v38 = 1.0 / v38;
  }
  float v39 = *(float *)(a1 + 160) - v27;
  float v40 = v39 - (float)(v37 * v28);
  float v41 = -(float)(v39 + (float)((float)-v37 * v28));
  if (v40 > 0.0) {
    float v41 = v40;
  }
  float v42 = -(float)(v38 * v40);
  float v43 = -(float)(v42 * v30);
  float v44 = -(float)(v42 * v31);
  float v45 = -(float)(v37 * v42);
  float v46 = v29 * v45;
  float v47 = v32 * v45;
  *float v5 = v7 + (float)(v35 * v43);
  v5[1] = v6 + (float)(v35 * v44);
  v5[3] = v8 + (float)(v33 * (float)((float)(v17 * v44) - (float)(v18 * v43)));
  float v48 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 176));
  *float v48 = v11 + (float)(v36 * v46);
  v48[1] = v10 + (float)(v36 * v47);
  v48[3] = v12 + (float)(v34 * (float)((float)(v21 * v47) - (float)(v22 * v46)));
  return v41 < 0.0045;
}

float b2PulleyJoint::GetAnchorA(b2PulleyJoint *this)
{
  return *(float *)(*((void *)this + 12) + 32)
       + (float)((float)(*(float *)(*((void *)this + 12) + 44) * *((float *)this + 36))
               - (float)(*(float *)(*((void *)this + 12) + 40) * *((float *)this + 37)));
}

float b2PulleyJoint::GetAnchorB(b2PulleyJoint *this)
{
  return *(float *)(*((void *)this + 13) + 32)
       + (float)((float)(*(float *)(*((void *)this + 13) + 44) * *((float *)this + 38))
               - (float)(*(float *)(*((void *)this + 13) + 40) * *((float *)this + 39)));
}

float b2PulleyJoint::GetReactionForce(b2PulleyJoint *this, float a2)
{
  return (float)(*((float *)this + 42) * *((float *)this + 47)) * a2;
}

double b2PulleyJoint::GetReactionTorque(b2PulleyJoint *this, float a2)
{
  return 0.0;
}

float b2PulleyJoint::GetGroundAnchorA(b2PulleyJoint *this)
{
  return *((float *)this + 32);
}

float b2PulleyJoint::GetGroundAnchorB(b2PulleyJoint *this)
{
  return *((float *)this + 34);
}

float b2PulleyJoint::GetLengthA(b2PulleyJoint *this)
{
  uint64_t v1 = (float *)*((void *)this + 12);
  float v3 = v1[10];
  float v2 = v1[11];
  float v4 = *((float *)this + 36);
  float v5 = *((float *)this + 37);
  float v6 = v1[8] + (float)((float)(v2 * v4) - (float)(v3 * v5));
  float v7 = (float)((float)(v2 * v5) + (float)(v3 * v4)) + v1[9];
  return sqrtf((float)((float)(v7 - *((float *)this + 33)) * (float)(v7 - *((float *)this + 33)))+ (float)((float)(v6 - *((float *)this + 32)) * (float)(v6 - *((float *)this + 32))));
}

float b2PulleyJoint::GetLengthB(b2PulleyJoint *this)
{
  uint64_t v1 = (float *)*((void *)this + 13);
  float v3 = v1[10];
  float v2 = v1[11];
  float v4 = *((float *)this + 38);
  float v5 = *((float *)this + 39);
  float v6 = v1[8] + (float)((float)(v2 * v4) - (float)(v3 * v5));
  float v7 = (float)((float)(v2 * v5) + (float)(v3 * v4)) + v1[9];
  return sqrtf((float)((float)(v7 - *((float *)this + 35)) * (float)(v7 - *((float *)this + 35)))+ (float)((float)(v6 - *((float *)this + 34)) * (float)(v6 - *((float *)this + 34))));
}

void b2PulleyJoint::~b2PulleyJoint(b2PulleyJoint *this)
{
}

float b2RevoluteJointDef::Initialize(b2RevoluteJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4)
{
  this->bodyA = a2;
  this->bodyB = a3;
  float v6 = a4->x - a2->var8.var0.x;
  float v7 = a4->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  this->localAnchorA.float x = (float)(v7 * var0) + (float)(var1 * v6);
  this->localAnchorA.float y = (float)(var1 * v7) - (float)(var0 * v6);
  float v10 = a4->x - a3->var8.var0.x;
  float v11 = a4->y - a3->var8.var0.y;
  float v13 = a3->var8.var1.var0;
  float v12 = a3->var8.var1.var1;
  this->localAnchorB.float x = (float)(v11 * v13) + (float)(v12 * v10);
  this->localAnchorB.float y = (float)(v12 * v11) - (float)(v13 * v10);
  float v14 = atan2f(a3->var8.var1.var0, a3->var8.var1.var1);
  float result = v14 - atan2f(a2->var8.var1.var0, a2->var8.var1.var1);
  this->referenceAngle = result;
  return result;
}

void b2RevoluteJoint::b2RevoluteJoint(b2RevoluteJoint *this, const b2JointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, a2);
  *(void *)uint64_t v3 = &unk_26C3F39B8;
  *(void *)(v3 + 128) = *(void *)(&a2->var4 + 4);
  *(void *)(v3 + 136) = *(void *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 176) = HIDWORD(a2[1].var1);
  *(void *)(v3 + 144) = 0;
  *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 180) = *(b2Body **)((char *)&a2[1].var2 + 4);
  *(int32x2_t *)(v3 + 164) = vrev64_s32(*(int32x2_t *)&a2[1].var4);
  *(unsigned char *)(v3 + 17b2DynamicTree::~b2DynamicTree(this + 2) = a2[1].var2;
  *(unsigned char *)(v3 + 160) = BYTE4(a2[1].var3);
  *(_DWORD *)(v3 + 284) = 0;
}

float normalizeAngle(float result)
{
  for (; result <= -3.1416; float result = result + 6.2832)
    ;
  for (; result > 3.1416; float result = result + -6.2832)
    ;
  return result;
}

void b2RevoluteJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 188) = v6;
  *(_DWORD *)(a1 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 220) = v9;
  float v56 = *(float *)(v5 + 212);
  float v57 = *(float *)(v4 + 212);
  *(float *)(a1 + 228) = v57;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v56;
  float v10 = *(float *)(v4 + 224);
  float v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 236) = v10;
  *(float *)(a1 + 240) = v11;
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = *(void *)(a2 + 32);
  float v14 = *(float *)(v12 + 16 * v6 + 12);
  float v15 = (float32x2_t *)(v13 + 16 * v6);
  float32x2_t v16 = *v15;
  float v17 = *(float *)(v12 + 16 * v7 + 12);
  float v18 = (float32x2_t *)(v13 + 16 * v7);
  float32x2_t v19 = *v18;
  float v54 = v15[1].f32[1];
  float v55 = v18[1].f32[1];
  __float2 v20 = __sincosf_stret(v14);
  __float2 v21 = __sincosf_stret(v17);
  float v22 = *(float *)(a1 + 128) - *(float *)&v8;
  float v23 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v20.__cosval * v22) - (float)(v20.__sinval * v23);
  float v25 = (float)(v20.__cosval * v23) + (float)(v20.__sinval * v22);
  *(float *)(a1 + 196) = _S2;
  *(float *)(a1 + 200) = v25;
  float v26 = *(float *)(a1 + 136) - *(float *)&v9;
  float v27 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v21.__cosval * v26) - (float)(v21.__sinval * v27);
  float v29 = (float)(v21.__cosval * v27) + (float)(v21.__sinval * v26);
  *(float *)(a1 + 204) = _S3;
  *(float *)(a1 + 208) = v29;
  float v30 = (float)((float)(v57 + v56) + (float)((float)(v25 * v25) * v10)) + (float)((float)(v29 * v29) * v11);
  float v31 = (float)(v11 * (float)-(float)(v29 * _S3)) + (float)((float)-(float)(v25 * _S2) * v10);
  float v32 = v10 + v11;
  float v33 = (float)-(float)(v29 * v11) - (float)(v25 * v10);
  *(float *)(a1 + 268) = v33;
  *(float *)(a1 + 244) = v30;
  *(float *)(a1 + 248) = v31;
  *(float *)(a1 + 260) = (float)((float)(v57 + v56) + (float)((float)(_S2 * _S2) * v10))
                       + (float)((float)(_S3 * _S3) * v11);
  float v34 = (float)(v11 * _S3) + (float)(_S2 * v10);
  *(float *)(a1 + 27b2DynamicTree::~b2DynamicTree(this + 2) = v34;
  *(float *)(a1 + 25b2DynamicTree::~b2DynamicTree(this + 2) = v33;
  *(float *)(a1 + 256) = v31;
  *(float *)(a1 + 264) = v34;
  *(float *)(a1 + 276) = v10 + v11;
  float v35 = 1.0 / (float)(v10 + v11);
  if ((float)(v10 + v11) <= 0.0) {
    float v35 = v10 + v11;
  }
  *(float *)(a1 + 280) = v35;
  if (!*(unsigned char *)(a1 + 160) || v32 == 0.0) {
    *(_DWORD *)(a1 + 156) = 0;
  }
  if (!*(unsigned char *)(a1 + 172) || v32 == 0.0)
  {
    *(_DWORD *)(a1 + 284) = 0;
    goto LABEL_17;
  }
  for (float i = (float)(v17 - v14) - *(float *)(a1 + 176); i <= -3.1416; float i = i + 6.2832)
    ;
  for (; i > 3.1416; float i = i + -6.2832)
    ;
  float v38 = *(float *)(a1 + 180);
  float v37 = *(float *)(a1 + 184);
  float v39 = v37 - v38;
  if ((float)(v37 - v38) <= 0.0) {
    float v39 = -(float)(v37 - v38);
  }
  if (v39 < 0.069813)
  {
    *(_DWORD *)(a1 + 284) = 3;
LABEL_17:
    float v41 = v54;
    float v40 = v55;
    goto LABEL_18;
  }
  if (i <= v38)
  {
    float v41 = v54;
    float v40 = v55;
    if (*(_DWORD *)(a1 + 284) != 1) {
      *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    }
    int v53 = 1;
  }
  else
  {
    _NF = i < v37;
    float v41 = v54;
    float v40 = v55;
    if (_NF)
    {
      *(_DWORD *)(a1 + 284) = 0;
      *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
      goto LABEL_18;
    }
    if (*(_DWORD *)(a1 + 284) != 2) {
      *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    }
    int v53 = 2;
  }
  *(_DWORD *)(a1 + 284) = v53;
LABEL_18:
  if (*(unsigned char *)(a2 + 20))
  {
    float v42 = *(float *)(a2 + 8);
    float v43 = v42 * *(float *)(a1 + 152);
    float v44 = v42 * *(float *)(a1 + 156);
    *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v43;
    *(float *)(a1 + 156) = v44;
    _D1 = vmul_n_f32(*(float32x2_t *)(a1 + 144), v42);
    *(float32x2_t *)(a1 + 144) = _D1;
    float32x2_t v16 = vsub_f32(v16, vmul_n_f32(_D1, v57));
    __asm { FMLA            S4, S2, V1.S[1] }
    float v41 = v41 - (float)(v10 * (float)(v43 + (float)(v44 + _S4)));
    float32x2_t v19 = vadd_f32(v19, vmul_n_f32(_D1, v56));
    __asm { FMLA            S0, S3, V1.S[1] }
    float v40 = v40 + (float)(v11 * (float)(v43 + (float)(v44 + _S0)));
  }
  else
  {
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  }
  *float v15 = v16;
  v15[1].f32[1] = v41;
  uint64_t v52 = *(void *)(a2 + 32) + 16 * *(int *)(a1 + 192);
  *(float32x2_t *)uint64_t v52 = v19;
  *(float *)(v52 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v40;
}

float b2RevoluteJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 188));
  float v7 = *v5;
  float v6 = v5[1];
  float v8 = v5[3];
  uint64_t v9 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  float v11 = *v9;
  float v10 = v9[1];
  float v12 = v9[3];
  float v14 = *(float *)(a1 + 236);
  float v13 = *(float *)(a1 + 240);
  float v15 = v14 + v13;
  if (*(unsigned char *)(a1 + 160) && *(_DWORD *)(a1 + 284) != 3 && v15 != 0.0)
  {
    float v16 = *(float *)(a1 + 156);
    float v17 = *(float *)a2 * *(float *)(a1 + 164);
    float v18 = v16 - (float)(*(float *)(a1 + 280) * (float)((float)(v12 - v8) - *(float *)(a1 + 168)));
    if (v18 >= v17) {
      float v18 = *(float *)a2 * *(float *)(a1 + 164);
    }
    if (v18 < (float)-v17) {
      float v18 = -v17;
    }
    *(float *)(a1 + 156) = v18;
    float v19 = v18 - v16;
    float v8 = v8 - (float)(v14 * v19);
    float v12 = v12 + (float)(v13 * v19);
  }
  float v20 = *(float *)(a1 + 232);
  float v54 = *(float *)(a1 + 228);
  if (*(unsigned char *)(a1 + 172) && *(_DWORD *)(a1 + 284) && v15 != 0.0)
  {
    float v51 = v7;
    float v52 = v11;
    float v50 = v10;
    float v21 = (float)((float)(v11 - (float)(v12 * *(float *)(a1 + 208))) - v7) + (float)(v8 * *(float *)(a1 + 200));
    float v22 = (float)((float)(v10 + (float)(v12 * *(float *)(a1 + 204))) - v6) - (float)(v8 * *(float *)(a1 + 196));
    v56.float var0 = v21;
    v56.float var1 = v22;
    v56.float var2 = v12 - v8;
    float v24 = b2Mat33::Solve33((b2Mat33 *)(a1 + 244), &v56);
    float v26 = v25;
    float v27 = -v24;
    float v28 = -v25;
    float v29 = -v23;
    int v30 = *(_DWORD *)(a1 + 284);
    if (v30 == 1)
    {
      float v42 = *(float *)(a1 + 152);
      float v32 = v42 - v23;
      if (v32 >= 0.0) {
        goto LABEL_20;
      }
    }
    else
    {
      if (v30 != 2)
      {
        if (v30 == 3)
        {
          float v31 = *(float *)(a1 + 148);
          *(float *)(a1 + 144) = *(float *)(a1 + 144) - v24;
          *(float *)(a1 + 148) = v31 - v26;
          float v32 = *(float *)(a1 + 152) - v23;
LABEL_21:
          *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v32;
        }
LABEL_22:
        float v7 = v51;
        float v11 = v52;
        float v37 = v50;
        float v41 = v54;
        float v39 = v8
            - (float)(v14
                    * (float)(v29 + (float)((float)(*(float *)(a1 + 196) * v28) - (float)(*(float *)(a1 + 200) * v27))));
        float v40 = v12
            + (float)(v13
                    * (float)(v29 + (float)((float)(*(float *)(a1 + 204) * v28) - (float)(*(float *)(a1 + 208) * v27))));
        goto LABEL_23;
      }
      float v42 = *(float *)(a1 + 152);
      float v32 = v42 - v23;
      if (v32 <= 0.0)
      {
LABEL_20:
        float v45 = *(float *)(a1 + 148) - v26;
        *(float *)(a1 + 144) = *(float *)(a1 + 144) - v24;
        *(float *)(a1 + 148) = v45;
        goto LABEL_21;
      }
    }
    float v43 = (float)(v42 * *(float *)(a1 + 272)) - v22;
    v55.float x = (float)(v42 * *(float *)(a1 + 268)) - v21;
    v55.float y = v43;
    float v27 = b2Mat33::Solve22((b2Mat33 *)(a1 + 244), &v55);
    float v29 = -*(float *)(a1 + 152);
    float v44 = v28 + *(float *)(a1 + 148);
    *(float *)(a1 + 144) = v27 + *(float *)(a1 + 144);
    *(float *)(a1 + 148) = v44;
    *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    goto LABEL_22;
  }
  float v33 = -(float)((float)((float)(v10 + (float)(v12 * *(float *)(a1 + 204))) - v6) - (float)(v8 * *(float *)(a1 + 196)));
  v56.float var0 = -(float)((float)((float)(v11 - (float)(v12 * *(float *)(a1 + 208))) - v7)
                    + (float)(v8 * *(float *)(a1 + 200)));
  v56.float var1 = v33;
  float v53 = v20;
  float v34 = v13;
  float v35 = v6;
  float v36 = v10;
  float v27 = b2Mat33::Solve22((b2Mat33 *)(a1 + 244), (const b2Vec2 *)&v56);
  float v37 = v36;
  float v6 = v35;
  float v38 = v28 + *(float *)(a1 + 148);
  *(float *)(a1 + 144) = v27 + *(float *)(a1 + 144);
  *(float *)(a1 + 148) = v38;
  float v39 = v8 - (float)(v14 * (float)((float)(*(float *)(a1 + 196) * v28) - (float)(*(float *)(a1 + 200) * v27)));
  float v40 = v12 + (float)(v34 * (float)((float)(*(float *)(a1 + 204) * v28) - (float)(*(float *)(a1 + 208) * v27)));
  float v20 = v53;
  float v41 = v54;
LABEL_23:
  float v46 = v7 - (float)(v41 * v27);
  float result = v11 + (float)(v20 * v27);
  float v48 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 188));
  *float v48 = v46;
  v48[1] = v6 - (float)(v41 * v28);
  v48[3] = v39;
  float v49 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 192));
  float *v49 = result;
  v49[1] = v37 + (float)(v20 * v28);
  v49[3] = v40;
  return result;
}

BOOL b2RevoluteJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 188));
  float v6 = *v5;
  float v7 = v5[3];
  float v8 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  float v46 = v5[1];
  float v47 = *v8;
  float v48 = v8[1];
  float v9 = v8[3];
  float v11 = *(float *)(a1 + 236);
  float v10 = *(float *)(a1 + 240);
  float v12 = 0.0;
  if (*(unsigned char *)(a1 + 172))
  {
    int v13 = *(_DWORD *)(a1 + 284);
    if (v13)
    {
      if ((float)(v11 + v10) != 0.0)
      {
        for (float i = (float)(v9 - v7) - *(float *)(a1 + 176); i <= -3.1416; float i = i + 6.2832)
          ;
        for (; i > 3.1416; float i = i + -6.2832)
          ;
        if (v13 == 1)
        {
          float v17 = i - *(float *)(a1 + 180);
          float v12 = -v17;
          float v18 = -0.13963;
          float v19 = fminf(v17 + 0.034907, 0.0);
          BOOL v20 = v19 < -0.13963;
        }
        else
        {
          if (v13 != 2)
          {
            float v15 = 0.0;
            float v12 = 0.0;
            if (v13 == 3)
            {
              float v16 = fminf(i - *(float *)(a1 + 180), 0.13963);
              if (v16 < -0.13963) {
                float v16 = -0.13963;
              }
              float v15 = -(float)(*(float *)(a1 + 280) * v16);
              if (v16 <= 0.0) {
                float v12 = -v16;
              }
              else {
                float v12 = v16;
              }
            }
LABEL_21:
            float v7 = v7 - (float)(v11 * v15);
            float v9 = v9 + (float)(v10 * v15);
            goto LABEL_22;
          }
          float v12 = i - *(float *)(a1 + 184);
          float v19 = fminf(v12 + -0.034907, 0.13963);
          BOOL v20 = v19 < 0.0;
          float v18 = 0.0;
        }
        if (v20) {
          float v19 = v18;
        }
        float v15 = -(float)(*(float *)(a1 + 280) * v19);
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  __float2 v21 = __sincosf_stret(v7);
  __float2 v22 = __sincosf_stret(v9);
  float v23 = *(float *)(a1 + 128) - *(float *)(a1 + 212);
  float v24 = *(float *)(a1 + 132) - *(float *)(a1 + 216);
  float v25 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  float v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  float v27 = *(float *)(a1 + 136) - *(float *)(a1 + 220);
  float v28 = *(float *)(a1 + 140) - *(float *)(a1 + 224);
  float v29 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  float v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  float v31 = (float)((float)(v47 + v29) - v6) - v25;
  float v32 = (float)((float)(v48 + v30) - v46) - v26;
  float v33 = sqrtf((float)(v32 * v32) + (float)(v31 * v31));
  float v34 = *(float *)(a1 + 228);
  float v35 = *(float *)(a1 + 232);
  float v36 = (float)((float)(v34 + v35) + (float)((float)(v11 * v26) * v26)) + (float)((float)(v10 * v30) * v30);
  float v37 = (float)(v30 * (float)-(float)(v10 * v29)) + (float)((float)-(float)(v11 * v25) * v26);
  float v38 = (float)((float)(v34 + v35) + (float)((float)(v11 * v25) * v25)) + (float)((float)(v10 * v29) * v29);
  float v39 = (float)(v36 * v38) - (float)(v37 * v37);
  if (v39 != 0.0) {
    float v39 = 1.0 / v39;
  }
  float v40 = (float)(v38 * v31) - (float)(v37 * v32);
  float v41 = (float)(v36 * v32) - (float)(v37 * v31);
  float v42 = -(float)(v39 * v40);
  float v43 = -(float)(v39 * v41);
  *uint64_t v5 = v6 - (float)(v34 * v42);
  v5[1] = v46 - (float)(v34 * v43);
  v5[3] = v7 - (float)(v11 * (float)((float)(v25 * v43) - (float)(v26 * v42)));
  float v44 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 192));
  float *v44 = v47 + (float)(v35 * v42);
  v44[1] = v48 + (float)(v35 * v43);
  v44[3] = v9 + (float)(v10 * (float)((float)(v29 * v43) - (float)(v30 * v42)));
  return v12 <= 0.034907 && v33 <= 0.0045;
}

float b2RevoluteJoint::GetAnchorA(b2RevoluteJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2RevoluteJoint::GetAnchorB(b2RevoluteJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2RevoluteJoint::GetReactionForce(b2RevoluteJoint *this, float a2)
{
  return this->var13.var0 * a2;
}

float b2RevoluteJoint::GetReactionTorque(b2RevoluteJoint *this, float a2)
{
  return this->var13.var2 * a2;
}

float b2RevoluteJoint::GetJointAngle(b2RevoluteJoint *this)
{
  return (float)(this->var7->var11.x - this->var6->var11.x) - this->var19;
}

float b2RevoluteJoint::GetJointSpeed(b2RevoluteJoint *this)
{
  return *(float *)&this->var7->var15 - *(float *)&this->var6->var15;
}

BOOL b2RevoluteJoint::IsMotorEnabled(b2RevoluteJoint *this)
{
  return this->var15;
}

b2Body *b2RevoluteJoint::EnableMotor(b2RevoluteJoint *this, BOOL a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var15 = a2;
  return result;
}

float b2RevoluteJoint::GetMotorTorque(b2RevoluteJoint *this, float a2)
{
  return this->var14 * a2;
}

b2Body *b2RevoluteJoint::SetMotorSpeed(b2RevoluteJoint *this, float a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var17 = a2;
  return result;
}

b2Body *b2RevoluteJoint::SetMaxMotorTorque(b2RevoluteJoint *this, float a2)
{
  b2Body::SetAwake(this->var6, 1);
  float result = b2Body::SetAwake(this->var7, 1);
  this->var16 = a2;
  return result;
}

BOOL b2RevoluteJoint::IsLimitEnabled(b2RevoluteJoint *this)
{
  return this->var18;
}

b2RevoluteJoint *b2RevoluteJoint::EnableLimit(b2RevoluteJoint *this, BOOL a2)
{
  if (this->var18 != a2)
  {
    BOOL v2 = a2;
    uint64_t v3 = this;
    b2Body::SetAwake(this->var6, 1);
    this = (b2RevoluteJoint *)b2Body::SetAwake(v3->var7, 1);
    v3->var18 = v2;
    v3->var13.float var2 = 0.0;
  }
  return this;
}

b2RevoluteJoint *b2RevoluteJoint::SetLimits(b2RevoluteJoint *this, float a2, float a3)
{
  if (a2 > a3) {
    b2RevoluteJoint::SetLimits();
  }
  uint64_t v5 = this;
  if (this->var20 != a2 || this->var21 != a3)
  {
    b2Body::SetAwake(this->var6, 1);
    this = (b2RevoluteJoint *)b2Body::SetAwake(v5->var7, 1);
    v5->var13.float var2 = 0.0;
    v5->var20 = a2;
    v5->var21 = a3;
  }
  return this;
}

void b2RevoluteJoint::~b2RevoluteJoint(b2RevoluteJoint *this)
{
}

uint64_t Worley(float64x2_t *a1, uint64_t a2, double *__b, uint64_t a4, uint64_t a5)
{
  float v7 = __b;
  uint64_t v8 = a2;
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v10 = a2 - 1;
  if (a2 >= 1) {
    memset_pattern16(__b, &unk_21359BAA0, 8 * a2);
  }
  float64x2_t v11 = vmulq_f64(*a1, (float64x2_t)vdupq_n_s64(0x3FD97B4A2339C0ECuLL));
  double v36 = v11.f64[0];
  float64x2_t v38 = v11;
  double v39 = a1[1].f64[0] * 0.39815;
  *(double *)&unint64_t v12 = v39;
  uint64_t v13 = (__PAIR128__((uint64_t)v11.f64[0], *(unint64_t *)&v11.f64[0]) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  double v14 = v11.f64[1];
  uint64_t v15 = (__PAIR128__((uint64_t)v11.f64[1], *(unint64_t *)&v11.f64[1]) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  uint64_t v16 = (__PAIR128__((uint64_t)*(double *)&v12, v12) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  uint64_t result = AddSamples(v13, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
  double v18 = v36 - (double)v13;
  double v19 = v14 - (double)v15;
  double v20 = *(double *)&v12 - (double)v16;
  double v21 = v18 * v18;
  double v22 = v19 * v19;
  double v23 = v7[v10];
  if (v18 * v18 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v24 = 1.0 - v18;
  double v25 = v20 * v20;
  if (v22 < v23)
  {
    uint64_t result = AddSamples(v13, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v26 = 1.0 - v19;
  double v27 = v24 * v24;
  if (v25 < v23)
  {
    uint64_t result = AddSamples(v13, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v28 = 1.0 - v20;
  double v29 = v26 * v26;
  if (v27 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v30 = v28 * v28;
  if (v29 < v23)
  {
    uint64_t result = AddSamples(v13, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v30 < v23)
  {
    uint64_t result = AddSamples(v13, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v31 = v21 + v22;
  if (v21 + v22 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v21 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v22 + v25 < v23)
  {
    uint64_t result = AddSamples(v13, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v37 = v27 + v29;
  if (v27 + v29 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v27 + v30 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v29 + v30 < v23)
  {
    uint64_t result = AddSamples(v13, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v32 = v21 + v29;
  if (v21 + v29 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v21 + v30 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v22 + v30 < v23)
  {
    uint64_t result = AddSamples(v13, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  double v33 = v27 + v22;
  if (v33 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v27 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v29 + v25 < v23)
  {
    uint64_t result = AddSamples(v13, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v31 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v31 + v30 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v32 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v32 + v30 < v23)
  {
    uint64_t result = AddSamples(v13 - 1, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v33 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v33 + v30 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v37 + v25 < v23)
  {
    uint64_t result = AddSamples(v13 + 1, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    double v23 = v7[v10];
  }
  if (v37 + v30 < v23) {
    uint64_t result = AddSamples(v13 + 1, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
  }
  if (v8 >= 1)
  {
    float v34 = (double *)(a4 + 16);
    float64x2_t v35 = (float64x2_t)vdupq_n_s64(0x400417CA3F5539E6uLL);
    do
    {
      double *v7 = sqrt(*v7) * 2.51161623;
      ++v7;
      *((float64x2_t *)v34 - 1) = vmulq_f64(*(float64x2_t *)(v34 - 2), v35);
      *float v34 = *v34 * 2.51161623;
      v34 += 3;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t AddSamples(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = 702395077 * result + 915488749 * a2 + 2120969693 * a3;
  uint64_t v9 = *(int *)((char *)&Poisson_count + ((v8 >> 22) & 0x3FFFFFFFFFCLL));
  if ((int)v9 >= 1)
  {
    uint64_t v10 = 0;
    v11.i64[0] = result;
    v11.i64[1] = a2;
    float64x2_t v12 = vcvtq_f64_s64(v11);
    double v13 = (double)a3;
    uint64_t result = a7 + 24 * a4 - 24;
    uint64_t v14 = 8 * a4 - 8;
    uint64_t v15 = (void *)(a6 + v14);
    uint64_t v16 = (void *)(a8 + v14);
    __asm { FMOV            V2.2D, #0.5 }
    float64x2_t v22 = (float64x2_t)vdupq_n_s64(0x3DF0000000000000uLL);
    do
    {
      uint64_t v23 = 1402024253 * v8 + 586950981;
      v24.i64[0] = 1402024253 * v23 + 586950981;
      v24.i64[1] = 1402024253 * v24.i64[0] + 586950981;
      unint64_t v8 = 1402024253 * v24.i64[1] + 586950981;
      float64x2_t v25 = vsubq_f64(vaddq_f64(vmulq_f64(vaddq_f64(vcvtq_f64_u64(v24), _Q2), v22), v12), *a5);
      double v26 = ((double)v8 + 0.5) * 2.32830644e-10 + v13 - a5[1].f64[0];
      double v27 = vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v25, v25).f64[1]), v25.f64[0], v25.f64[0]) + v26 * v26;
      if (v27 < *(double *)(a6 + 8 * (a4 - 1)))
      {
        uint64_t v28 = a4;
        while (1)
        {
          uint64_t v29 = v28 - 1;
          if (v28 < 1) {
            break;
          }
          double v30 = *(double *)(a6 - 8 + 8 * v28--);
          if (v27 >= v30)
          {
            uint64_t v31 = v29 + 1;
            goto LABEL_9;
          }
        }
        uint64_t v31 = a4 & (a4 >> 63);
LABEL_9:
        if (a4 - 2 >= v31)
        {
          double v32 = v16;
          double v33 = v15;
          uint64_t v34 = a7 + 24 * a4 - 24;
          uint64_t v35 = a4 - 1;
          double v36 = v15;
          double v37 = v16;
          uint64_t v38 = v34;
          do
          {
            uint64_t v39 = *--v36;
            uint64_t v40 = v39;
            uint64_t v41 = *--v37;
            *double v33 = v40;
            *double v32 = v41;
            long long v42 = *(_OWORD *)(v38 - 24);
            v38 -= 24;
            *(_OWORD *)uint64_t v34 = v42;
            --v35;
            *(void *)(v34 + 16) = *(void *)(v34 - 8);
            double v32 = v37;
            double v33 = v36;
            uint64_t v34 = v38;
          }
          while (v35 > v31);
        }
        *(double *)(a6 + 8 * v31) = v27;
        *(void *)(a8 + 8 * v31) = v23;
        float v43 = (float64x2_t *)(a7 + 24 * v31);
        float64x2_t *v43 = v25;
        v43[1].f64[0] = v26;
      }
      ++v10;
    }
    while (v10 != v9);
  }
  return result;
}

void b2RopeJoint::b2RopeJoint(b2RopeJoint *this, const b2JointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, a2);
  *(void *)uint64_t v3 = &unk_26C3F33E8;
  *(void *)(v3 + 128) = *(void *)(&a2->var4 + 4);
  *(void *)(v3 + 136) = *(void *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 144) = HIDWORD(a2[1].var1);
  *(void *)(v3 + 220) = 0;
  *(_DWORD *)(v3 + 148) = 0;
  *(_DWORD *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
}

void b2RopeJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 156) = v6;
  *(_DWORD *)(a1 + 160) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 188) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 196) = v9;
  float v10 = *(float *)(v4 + 212);
  float v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 204) = v10;
  *(float *)(a1 + 208) = v11;
  float v55 = v11;
  float v12 = *(float *)(v5 + 224);
  float v54 = *(float *)(v4 + 224);
  *(float *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v54;
  *(float *)(a1 + 216) = v12;
  float v56 = v12;
  uint64_t v13 = *(void *)(a2 + 24);
  uint64_t v14 = *(void *)(a2 + 32);
  uint64_t v15 = (float *)(v13 + 16 * v6);
  float v17 = *v15;
  float v16 = v15[1];
  double v18 = (float *)(v14 + 16 * v6);
  float v62 = v18[1];
  float v60 = *v18;
  float v61 = v18[3];
  double v19 = (float *)(v13 + 16 * v7);
  float v20 = *v19;
  float v21 = v19[1];
  float v22 = v19[3];
  uint64_t v23 = (float *)(v14 + 16 * v7);
  float v58 = v23[1];
  float v59 = *v23;
  float v57 = v23[3];
  __float2 v24 = __sincosf_stret(v15[3]);
  __float2 v25 = __sincosf_stret(v22);
  float v26 = *(float *)(a1 + 128) - *(float *)&v8;
  float v27 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  float v28 = (float)(v24.__cosval * v26) - (float)(v24.__sinval * v27);
  float v29 = (float)(v24.__cosval * v27) + (float)(v24.__sinval * v26);
  *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v28;
  *(float *)(a1 + 176) = v29;
  float v30 = *(float *)(a1 + 136) - *(float *)&v9;
  float v31 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  float v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  float v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  *(float *)(a1 + 180) = v32;
  *(float *)(a1 + 184) = v33;
  float v34 = (float)((float)(v20 + v32) - v17) - v28;
  float v35 = (float)((float)(v21 + v33) - v16) - v29;
  float v36 = sqrtf((float)(v35 * v35) + (float)(v34 * v34));
  *(float *)(a1 + 148) = v36;
  *(_DWORD *)(a1 + 224) = 2 * ((float)(v36 - *(float *)(a1 + 144)) > 0.0);
  if (v36 <= 0.0045)
  {
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  }
  else
  {
    float v37 = 1.0 / v36;
    float v38 = v34 * v37;
    float v39 = v35 * v37;
    *(float *)(a1 + 164) = v38;
    *(float *)(a1 + 168) = v39;
    float v40 = (float)(v55
                + (float)(v10
                        + (float)((float)(v54 * (float)((float)(v28 * v39) - (float)(v29 * v38)))
                                * (float)((float)(v28 * v39) - (float)(v29 * v38)))))
        + (float)((float)(v56 * (float)((float)(v32 * v39) - (float)(v33 * v38)))
                * (float)((float)(v32 * v39) - (float)(v33 * v38)));
    float v41 = 1.0 / v40;
    BOOL v42 = v40 == 0.0;
    float v43 = 0.0;
    if (!v42) {
      float v43 = v41;
    }
    *(float *)(a1 + 220) = v43;
    if (*(unsigned char *)(a2 + 20))
    {
      float v44 = *(float *)(a2 + 8) * *(float *)(a1 + 152);
      *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v44;
      float v45 = v38 * v44;
      float v46 = v39 * v44;
      float v47 = v60 - (float)(v10 * v45);
      float v48 = v62 - (float)(v10 * v46);
      float v49 = v61 - (float)(v54 * (float)((float)(v45 * (float)-v29) + (float)(v28 * v46)));
      float v50 = v59 + (float)(v55 * v45);
      float v51 = v58 + (float)(v55 * v46);
      float v52 = v57 + (float)(v56 * (float)((float)(v45 * (float)-v33) + (float)(v32 * v46)));
    }
    else
    {
      *(_DWORD *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
      float v49 = v61;
      float v48 = v62;
      float v50 = v59;
      float v47 = v60;
      float v52 = v57;
      float v51 = v58;
    }
    *double v18 = v47;
    v18[1] = v48;
    v18[3] = v49;
    float v53 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 160));
    float *v53 = v50;
    v53[1] = v51;
    v53[3] = v52;
  }
}

float b2RopeJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = (float *)(v2 + 16 * *(int *)(a1 + 156));
  float v4 = *v3;
  float v5 = v3[1];
  float v6 = v3[3];
  uint64_t v7 = (float *)(v2 + 16 * *(int *)(a1 + 160));
  float v8 = *v7;
  float v9 = v7[1];
  float v10 = v7[3];
  float v12 = *(float *)(a1 + 172);
  float v11 = *(float *)(a1 + 176);
  float v14 = *(float *)(a1 + 180);
  float v13 = *(float *)(a1 + 184);
  float v15 = *(float *)(a1 + 148) - *(float *)(a1 + 144);
  float v16 = *(float *)(a1 + 164);
  float v17 = *(float *)(a1 + 168);
  float v18 = (float)((float)((float)(v9 + (float)(v10 * v14)) - (float)(v5 + (float)(v6 * v12))) * v17)
      + (float)(v16 * (float)((float)(*v7 - (float)(v10 * v13)) - (float)(*v3 - (float)(v6 * v11))));
  if (v15 < 0.0) {
    float v18 = v18 + (float)(*(float *)(a2 + 4) * v15);
  }
  float v19 = *(float *)(a1 + 152);
  float v20 = v19 - (float)(*(float *)(a1 + 220) * v18);
  if (v20 > 0.0) {
    float v20 = 0.0;
  }
  *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v20;
  float v21 = v20 - v19;
  float v22 = v16 * v21;
  float v23 = v17 * v21;
  float v24 = *(float *)(a1 + 204);
  float v25 = *(float *)(a1 + 208);
  float result = v4 - (float)(v24 * v22);
  float v27 = v6 - (float)(*(float *)(a1 + 212) * (float)((float)(v12 * v23) - (float)(v11 * v22)));
  float v28 = v10 + (float)(*(float *)(a1 + 216) * (float)((float)(v14 * v23) - (float)(v13 * v22)));
  *uint64_t v3 = result;
  v3[1] = v5 - (float)(v24 * v23);
  v3[3] = v27;
  float v29 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 160));
  *float v29 = v8 + (float)(v25 * v22);
  v29[1] = v9 + (float)(v25 * v23);
  v29[3] = v28;
  return result;
}

BOOL b2RopeJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  float v5 = (float *)(v4 + 16 * *(int *)(a1 + 156));
  float v6 = *v5;
  float v7 = v5[1];
  float v8 = v5[3];
  float v9 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  float v10 = *v9;
  float v11 = v9[1];
  float v12 = v9[3];
  __float2 v13 = __sincosf_stret(v8);
  __float2 v14 = __sincosf_stret(v12);
  float v15 = *(float *)(a1 + 128) - *(float *)(a1 + 188);
  float v16 = *(float *)(a1 + 132) - *(float *)(a1 + 192);
  float v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  float v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  float v19 = *(float *)(a1 + 136) - *(float *)(a1 + 196);
  float v20 = *(float *)(a1 + 140) - *(float *)(a1 + 200);
  float v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  float v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  float v23 = (float)((float)(v10 + v21) - v6) - v17;
  float v24 = (float)((float)(v11 + v22) - v7) - v18;
  float v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  float v26 = 0.0;
  if (v25 >= 0.00000011921)
  {
    float v23 = v23 * (float)(1.0 / v25);
    float v24 = v24 * (float)(1.0 / v25);
  }
  else
  {
    float v25 = 0.0;
  }
  float v27 = fminf(v25 - *(float *)(a1 + 144), 0.2);
  if (v27 >= 0.0) {
    float v26 = v27;
  }
  float v28 = *(float *)(a1 + 216);
  float v29 = -(float)(*(float *)(a1 + 220) * v26);
  float v30 = v23 * v29;
  float v31 = v24 * v29;
  float v32 = *(float *)(a1 + 204);
  float v33 = *(float *)(a1 + 208);
  float v34 = v8 - (float)(*(float *)(a1 + 212) * (float)((float)(v17 * v31) - (float)(v18 * v30)));
  *float v5 = v6 - (float)(v32 * v30);
  v5[1] = v7 - (float)(v32 * v31);
  v5[3] = v34;
  float v35 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 160));
  float *v35 = v10 + (float)(v33 * v30);
  v35[1] = v11 + (float)(v33 * v31);
  v35[3] = v12 + (float)(v28 * (float)((float)(v21 * v31) - (float)(v22 * v30)));
  return (float)(v25 - *(float *)(a1 + 144)) < 0.0045;
}

float b2RopeJoint::GetAnchorA(b2RopeJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2RopeJoint::GetAnchorB(b2RopeJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2RopeJoint::GetReactionForce(b2RopeJoint *this, float a2)
{
  return this->var18.x * (float)(this->var15 * a2);
}

double b2RopeJoint::GetReactionTorque(b2RopeJoint *this, float a2)
{
  return 0.0;
}

uint64_t b2RopeJoint::GetLimitState(b2RopeJoint *this)
{
  return this->var28;
}

void b2RopeJoint::~b2RopeJoint(b2RopeJoint *this)
{
}

void b2WeldJoint::b2WeldJoint(b2WeldJoint *this, const b2JointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, a2);
  *(void *)uint64_t v3 = &unk_26C3F3440;
  *(void *)(v3 + 128) = *(void *)(&a2->var4 + 4);
  *(void *)(v3 + 136) = *(void *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 144) = HIDWORD(a2[1].var1);
  *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(_DWORD *)(v3 + 148) = 0;
}

void b2WeldJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 160) = v6;
  *(_DWORD *)(a1 + 164) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 184) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v9;
  float v46 = *(float *)(v5 + 212);
  float v47 = *(float *)(v4 + 212);
  *(float *)(a1 + 200) = v47;
  *(float *)(a1 + 204) = v46;
  float v10 = *(float *)(v4 + 224);
  float v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 208) = v10;
  *(float *)(a1 + 21b2DynamicTree::~b2DynamicTree(this + 2) = v11;
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = *(void *)(a2 + 32);
  float v14 = *(float *)(v12 + 16 * v6 + 12);
  float v15 = (float32x2_t *)(v13 + 16 * v6);
  float32x2_t v16 = *v15;
  float v17 = v15[1].f32[1];
  float v18 = *(float *)(v12 + 16 * v7 + 12);
  float v19 = (float32x2_t *)(v13 + 16 * v7);
  float32x2_t v48 = *v19;
  float v20 = v19[1].f32[1];
  __float2 v21 = __sincosf_stret(v14);
  __float2 v22 = __sincosf_stret(v18);
  float v23 = *(float *)(a1 + 128) - *(float *)&v8;
  float v24 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  float v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  float v27 = *(float *)(a1 + 136) - *(float *)&v9;
  float v28 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  float v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  float v31 = (float)((float)(v47 + v46) + (float)((float)(v26 * v26) * v10)) + (float)((float)(v30 * v30) * v11);
  float v32 = (float)(v11 * (float)-(float)(v30 * _S3)) + (float)((float)-(float)(v26 * _S2) * v10);
  *(float *)(a1 + 168) = _S2;
  *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v26;
  *(float *)(a1 + 176) = _S3;
  *(float *)(a1 + 180) = v30;
  float v33 = (float)-(float)(v30 * v11) - (float)(v26 * v10);
  *(float *)(a1 + 216) = v31;
  *(float *)(a1 + 220) = v32;
  float v34 = (float)(v11 * _S3) + (float)(_S2 * v10);
  *(float *)(a1 + 240) = v33;
  *(float *)(a1 + 244) = v34;
  *(float *)(a1 + 224) = v33;
  *(float *)(a1 + 228) = v32;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = (float)((float)(v47 + v46) + (float)((float)(_S2 * _S2) * v10))
                       + (float)((float)(_S3 * _S3) * v11);
  *(float *)(a1 + 236) = v34;
  *(float *)(a1 + 248) = v10 + v11;
  if (*(unsigned char *)(a2 + 20))
  {
    float v35 = *(float *)(a2 + 8);
    float v36 = v35 * *(float *)(a1 + 156);
    *(float *)(a1 + 156) = v36;
    _D1 = vmul_n_f32(*(float32x2_t *)(a1 + 148), v35);
    *(float32x2_t *)(a1 + 148) = _D1;
    float32x2_t v16 = vsub_f32(v16, vmul_n_f32(_D1, v47));
    __asm { FMLA            S4, S2, V1.S[1] }
    float v17 = v17 - (float)(v10 * (float)(v36 + _S4));
    __asm { FMLA            S0, S3, V1.S[1] }
    float v20 = v20 + (float)(v11 * (float)(v36 + _S0));
    float32x2_t v44 = vadd_f32(v48, vmul_n_f32(_D1, v46));
  }
  else
  {
    *(void *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    float32x2_t v44 = v48;
  }
  *float v15 = v16;
  v15[1].f32[1] = v17;
  uint64_t v45 = *(void *)(a2 + 32) + 16 * *(int *)(a1 + 164);
  *(float32x2_t *)uint64_t v45 = v44;
  *(float *)(v45 + 1b2DynamicTree::~b2DynamicTree(this + 2) = v20;
}

float b2WeldJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  float v6 = *v5;
  float v7 = v5[1];
  float v8 = v5[3];
  uint64_t v9 = (float *)(v4 + 16 * *(int *)(a1 + 164));
  float v10 = *v9;
  float v11 = v9[1];
  float v12 = v9[3];
  float v13 = *(float *)(a1 + 200);
  float v14 = *(float *)(a1 + 204);
  float v26 = *(float *)(a1 + 208);
  float v27 = *(float *)(a1 + 212);
  float v15 = (float)((float)(v11 + (float)(v12 * *(float *)(a1 + 176))) - v7) - (float)(v8 * *(float *)(a1 + 168));
  v28.float var0 = (float)((float)(*v9 - (float)(v12 * *(float *)(a1 + 180))) - *v5) + (float)(v8 * *(float *)(a1 + 172));
  v28.float var1 = v15;
  v28.float var2 = v12 - v8;
  float v16 = b2Mat33::Solve33((b2Mat33 *)(a1 + 216), &v28);
  float v18 = *(float *)(a1 + 152) - v17;
  *(float *)(a1 + 148) = *(float *)(a1 + 148) - v16;
  *(float *)(a1 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v18;
  *(float *)(a1 + 156) = *(float *)(a1 + 156) - v19;
  float v20 = v6 + (float)(v13 * v16);
  float v21 = v8
      - (float)(v26 * (float)((float)((float)(v16 * *(float *)(a1 + 172)) - (float)(*(float *)(a1 + 168) * v17)) - v19));
  float v22 = v10 - (float)(v14 * v16);
  float result = v12
         + (float)(v27
                 * (float)((float)((float)(v16 * *(float *)(a1 + 180)) - (float)(*(float *)(a1 + 176) * v17)) - v19));
  float v24 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 160));
  *float v24 = v20;
  v24[1] = v7 + (float)(v13 * v17);
  v24[3] = v21;
  float v25 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 164));
  float *v25 = v22;
  v25[1] = v11 - (float)(v14 * v17);
  v25[3] = result;
  return result;
}

BOOL b2WeldJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  float v34 = v5[1];
  float v40 = v5[3];
  float v41 = *v5;
  float v6 = (float *)(v4 + 16 * *(int *)(a1 + 164));
  float v7 = *v6;
  float v38 = *v6;
  float v42 = v6[1];
  float v8 = v6[3];
  __float2 v9 = __sincosf_stret(v40);
  float v37 = v8;
  __float2 v10 = __sincosf_stret(v8);
  float v11 = *(float *)(a1 + 200);
  float v36 = *(float *)(a1 + 204);
  float v13 = *(float *)(a1 + 208);
  float v12 = *(float *)(a1 + 212);
  float v14 = *(float *)(a1 + 128) - *(float *)(a1 + 184);
  float v15 = *(float *)(a1 + 132) - *(float *)(a1 + 188);
  float v16 = (float)(v9.__cosval * v14) - (float)(v9.__sinval * v15);
  float v17 = (float)(v9.__cosval * v15) + (float)(v9.__sinval * v14);
  float v18 = *(float *)(a1 + 136) - *(float *)(a1 + 192);
  float v19 = *(float *)(a1 + 140) - *(float *)(a1 + 196);
  float v20 = (float)(v10.__cosval * v18) - (float)(v10.__sinval * v19);
  float v21 = (float)(v10.__cosval * v19) + (float)(v10.__sinval * v18);
  float v22 = (float)(v8 - v40) - *(float *)(a1 + 144);
  float v39 = sqrtf((float)((float)((float)((float)(v42 + v21) - v34) - v17) * (float)((float)((float)(v42 + v21) - v34) - v17))+ (float)((float)((float)((float)(v7 + v20) - v41) - v16) * (float)((float)((float)(v7 + v20) - v41) - v16)));
  float v23 = -v22;
  float v24 = v11;
  *(float *)(a1 + 216) = (float)((float)(v11 + v36) + (float)((float)(v17 * v17) * v13))
                       + (float)((float)(v21 * v21) * v12);
  float v25 = (float)(v12 * (float)-(float)(v21 * v20)) + (float)((float)-(float)(v17 * v16) * v13);
  float v26 = (float)-(float)(v21 * v12) - (float)(v17 * v13);
  *(float *)(a1 + 228) = v25;
  *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = (float)((float)(v11 + v36) + (float)((float)(v16 * v16) * v13))
                       + (float)((float)(v20 * v20) * v12);
  float v27 = (float)(v12 * v20) + (float)(v16 * v13);
  *(float *)(a1 + 220) = v25;
  *(float *)(a1 + 224) = v26;
  *(float *)(a1 + 236) = v27;
  *(float *)(a1 + 240) = v26;
  *(float *)(a1 + 244) = v27;
  *(float *)(a1 + 248) = v13 + v12;
  if (v22 > 0.0) {
    float v23 = v22;
  }
  float v35 = v23;
  v43.float var0 = (float)((float)(v7 + v20) - v41) - v16;
  v43.float var1 = (float)((float)(v42 + v21) - v34) - v17;
  v43.float var2 = v22;
  float v28 = b2Mat33::Solve33((b2Mat33 *)(a1 + 216), &v43);
  float v31 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 160));
  *float v31 = v41 + (float)(v24 * v28);
  v31[1] = v34 + (float)(v24 * v29);
  v31[3] = v40 - (float)(v13 * (float)((float)((float)(v17 * v28) - (float)(v16 * v29)) - v30));
  float v32 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 164));
  *float v32 = v38 - (float)(v36 * v28);
  v32[1] = v42 - (float)(v36 * v29);
  v32[3] = v37 + (float)(v12 * (float)((float)((float)(v21 * v28) - (float)(v20 * v29)) - v30));
  return v35 <= 0.034907 && v39 <= 0.0045;
}

float b2WeldJoint::GetAnchorA(b2WeldJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2WeldJoint::GetAnchorB(b2WeldJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2WeldJoint::GetReactionForce(b2WeldJoint *this, float a2)
{
  return this->var14.var0 * a2;
}

float b2WeldJoint::GetReactionTorque(b2WeldJoint *this, float a2)
{
  return this->var14.var2 * a2;
}

void b2WeldJoint::~b2WeldJoint(b2WeldJoint *this)
{
}

float b2WheelJointDef::Initialize(b2WheelJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  *((void *)this + b2DynamicTree::~b2DynamicTree(this + 2) = a2;
  *((void *)this + 3) = a3;
  float v5 = a4->x - a2->var8.var0.x;
  float v6 = a4->y - a2->var8.var0.y;
  float var0 = a2->var8.var1.var0;
  float var1 = a2->var8.var1.var1;
  *((float *)this + 9) = (float)(v6 * var0) + (float)(var1 * v5);
  *((float *)this + 10) = (float)(var1 * v6) - (float)(var0 * v5);
  float v9 = a4->x - a3->var8.var0.x;
  float v10 = a4->y - a3->var8.var0.y;
  float v12 = a3->var8.var1.var0;
  float v11 = a3->var8.var1.var1;
  *((float *)this + 11) = (float)(v10 * v12) + (float)(v11 * v9);
  *((float *)this + 1b2DynamicTree::~b2DynamicTree(this + 2) = (float)(v11 * v10) - (float)(v12 * v9);
  float v14 = a2->var8.var1.var0;
  float v13 = a2->var8.var1.var1;
  float y = a5->y;
  float v16 = (float)(v14 * y) + (float)(v13 * a5->x);
  float result = (float)(v13 * y) - (float)(v14 * a5->x);
  *((float *)this + 13) = v16;
  *((float *)this + 14) = result;
  return result;
}

void b2WheelJoint::b2WheelJoint(b2WheelJoint *this, const b2WheelJointDef *a2)
{
  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(void *)uint64_t v3 = &unk_26C3F35F8;
  *(void *)(v3 + 136) = *(void *)((char *)a2 + 36);
  *(void *)(v3 + 144) = *(void *)((char *)a2 + 44);
  uint64_t v4 = *(void *)((char *)a2 + 52);
  *(void *)(v3 + 15b2DynamicTree::~b2DynamicTree(this + 2) = v4;
  *(_DWORD *)(v3 + 160) = HIDWORD(v4) ^ 0x80000000;
  *(_DWORD *)(v3 + 164) = v4;
  *(void *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 176) = 0;
  *(void *)(v3 + 180) = *((void *)a2 + 8);
  *(unsigned char *)(v3 + 188) = *((unsigned char *)a2 + 60);
  *(void *)(v3 + 128) = *((void *)a2 + 9);
  *(void *)(v3 + 264) = 0;
  *(void *)(v3 + 27b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(_DWORD *)(v3 + 280) = 0;
  *(void *)(v3 + 23b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(void *)(v3 + 240) = 0;
}

void b2WheelJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v6 = *(int *)(v4 + 28);
  uint64_t v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 19b2DynamicTree::~b2DynamicTree(this + 2) = v6;
  *(_DWORD *)(a1 + 196) = v7;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(a1 + 200) = v8;
  uint64_t v9 = *(void *)(v5 + 64);
  *(void *)(a1 + 208) = v9;
  float v10 = *(float *)(v4 + 212);
  float v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 216) = v10;
  *(float *)(a1 + 220) = v11;
  float v12 = *(float *)(v4 + 224);
  float v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 224) = v12;
  *(float *)(a1 + 228) = v13;
  uint64_t v14 = *(void *)(a2 + 24);
  uint64_t v15 = *(void *)(a2 + 32);
  float v16 = (float *)(v14 + 16 * v6);
  float v82 = *v16;
  float v83 = v16[1];
  float v17 = (float *)(v15 + 16 * v6);
  float v78 = *v17;
  float v79 = v17[3];
  float v18 = (float *)(v14 + 16 * v7);
  float v19 = v18[1];
  float v80 = v17[1];
  float v81 = *v18;
  float v20 = v18[3];
  float v21 = (float *)(v15 + 16 * v7);
  float v76 = v21[1];
  float v77 = *v21;
  float v75 = v21[3];
  __float2 v24 = __sincosf_stret(v16[3]);
  float cosval = v24.__cosval;
  LODWORD(v2b2DynamicTree::~b2DynamicTree(this + 2) = *(void *)&v24;
  __float2 v25 = __sincosf_stret(v20);
  float v26 = *(float *)(a1 + 136) - *(float *)&v8;
  float v27 = *(float *)(a1 + 140) - *((float *)&v8 + 1);
  float v28 = (float)(cosval * v26) - (float)(v22 * v27);
  float v29 = (float)(cosval * v27) + (float)(v22 * v26);
  float v30 = *(float *)(a1 + 144) - *(float *)&v9;
  float v31 = *(float *)(a1 + 148) - *((float *)&v9 + 1);
  float v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  float v33 = v25.__cosval * v31;
  float v34 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  float v35 = (float)((float)(v81 + v32) - v82) - v28;
  float v36 = (float)((float)(v19 + v34) - v83) - v29;
  float v37 = *(float *)(a1 + 160);
  float v38 = *(float *)(a1 + 164);
  float v39 = (float)(cosval * v37) - (float)(v22 * v38);
  float v40 = (float)(cosval * v38) + (float)(v22 * v37);
  *(float *)(a1 + 240) = v39;
  *(float *)(a1 + 244) = v40;
  float v41 = v28 + v35;
  float v42 = v29 + v36;
  float v43 = (float)(v41 * v40) - (float)((float)(v29 + v36) * v39);
  *(float *)(a1 + 256) = v43;
  float v44 = (float)(v32 * v40) - (float)(v34 * v39);
  *(float *)(a1 + 260) = v44;
  float v45 = (float)((float)(v10 + v11) + (float)((float)(v12 * v43) * v43)) + (float)((float)(v13 * v44) * v44);
  if (v45 > 0.0) {
    float v45 = 1.0 / v45;
  }
  *(float *)(a1 + 264) = v45;
  *(void *)(a1 + 27b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  float v46 = *(float *)(a1 + 128);
  if (v46 <= 0.0)
  {
    *(_DWORD *)(a1 + 176) = 0;
  }
  else
  {
    float v47 = -(float)(v33 + (float)(v25.__sinval * v30));
    float v48 = *(float *)(a1 + 152);
    float v49 = *(float *)(a1 + 156);
    float v50 = (float)(v49 * (float)-v22) + (float)(cosval * v48);
    float v51 = (float)(cosval * v49) + (float)(v22 * v48);
    *(float *)(a1 + 23b2DynamicTree::~b2DynamicTree(this + 2) = v50;
    *(float *)(a1 + 236) = v51;
    float v52 = (float)(v50 * (float)-v42) + (float)(v41 * v51);
    float v53 = (float)(v50 * v47) + (float)(v32 * v51);
    *(float *)(a1 + 248) = v52;
    *(float *)(a1 + 25b2DynamicTree::~b2DynamicTree(this + 2) = v53;
    float v54 = (float)((float)(v10 + v11) + (float)((float)(v12 * v52) * v52)) + (float)((float)(v13 * v53) * v53);
    if (v54 > 0.0)
    {
      float v55 = (float)(v36 * v51) + (float)(v35 * v50);
      float v56 = (float)(v46 * 6.2832) * (float)((float)(v46 * 6.2832) * (float)(1.0 / v54));
      float v57 = *(float *)a2;
      float v58 = *(float *)a2
          * (float)((float)((float)(v46 * 6.2832)
                          * (float)((float)((float)(1.0 / v54) + (float)(1.0 / v54)) * *(float *)(a1 + 132)))
                  + (float)(*(float *)a2 * v56));
      if (v58 > 0.0) {
        float v58 = 1.0 / v58;
      }
      *(float *)(a1 + 280) = v58;
      *(float *)(a1 + 276) = (float)(v56 * (float)(v55 * v57)) * v58;
      float v59 = v54 + v58;
      if (v59 > 0.0) {
        float v59 = 1.0 / v59;
      }
      *(float *)(a1 + 27b2DynamicTree::~b2DynamicTree(this + 2) = v59;
    }
  }
  if (*(unsigned char *)(a1 + 188))
  {
    *(float *)(a1 + 268) = v12 + v13;
    if ((float)(v12 + v13) > 0.0) {
      *(float *)(a1 + 268) = 1.0 / (float)(v12 + v13);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  }
  if (*(unsigned char *)(a2 + 20))
  {
    float v60 = *(float *)(a2 + 8);
    float v61 = v60 * *(float *)(a1 + 168);
    float v62 = v60 * *(float *)(a1 + 176);
    float v63 = v60 * *(float *)(a1 + 172);
    *(float *)(a1 + 168) = v61;
    *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v63;
    *(float *)(a1 + 176) = v62;
    float v64 = (float)(v39 * v61) + (float)(v62 * *(float *)(a1 + 232));
    float v65 = (float)(v40 * v61) + (float)(v62 * *(float *)(a1 + 236));
    float v66 = v63 + (float)((float)(v62 * *(float *)(a1 + 248)) + (float)(v61 * v43));
    float v67 = v63 + (float)((float)(v62 * *(float *)(a1 + 252)) + (float)(v61 * v44));
    float v68 = v78 - (float)(v10 * v64);
    float v69 = v80 - (float)(v10 * v65);
    float v70 = v79 - (float)(v12 * v66);
    float v71 = v77 + (float)(v11 * v64);
    float v72 = v76 + (float)(v11 * v65);
    float v73 = v75 + (float)(v13 * v67);
  }
  else
  {
    *(_DWORD *)(a1 + 176) = 0;
    *(void *)(a1 + 168) = 0;
    float v70 = v79;
    float v69 = v80;
    float v71 = v77;
    float v68 = v78;
    float v73 = v75;
    float v72 = v76;
  }
  float *v17 = v68;
  v17[1] = v69;
  v17[3] = v70;
  float v74 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 196));
  float *v74 = v71;
  v74[1] = v72;
  v74[3] = v73;
}

float b2WheelJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  float v3 = *(float *)(a1 + 216);
  float v2 = *(float *)(a1 + 220);
  float v5 = *(float *)(a1 + 224);
  float v4 = *(float *)(a1 + 228);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = (float *)(v6 + 16 * *(int *)(a1 + 192));
  float v8 = *v7;
  float v9 = v7[1];
  float v10 = v7[3];
  float v11 = (float *)(v6 + 16 * *(int *)(a1 + 196));
  float v12 = *v11;
  float v13 = v11[1];
  float v14 = v11[3];
  float v15 = *(float *)(a1 + 232);
  float v16 = *(float *)(a1 + 236);
  float v18 = *(float *)(a1 + 248);
  float v17 = *(float *)(a1 + 252);
  float v19 = *(float *)(a1 + 176);
  float v20 = *(float *)(a1 + 180);
  float v21 = -(float)(*(float *)(a1 + 272)
               * (float)((float)((float)((float)((float)((float)((float)(v13 - v9) * v16)
                                                       + (float)(v15 * (float)(*v11 - *v7)))
                                               + (float)(v17 * v14))
                                       - (float)(v18 * v10))
                               + *(float *)(a1 + 276))
                       + (float)(*(float *)(a1 + 280) * v19)));
  *(float *)(a1 + 176) = v19
                       - (float)(*(float *)(a1 + 272)
                               * (float)((float)((float)((float)((float)((float)((float)(v13 - v9) * v16)
                                                                       + (float)(v15 * (float)(*v11 - *v7)))
                                                               + (float)(v17 * v14))
                                                       - (float)(v18 * v10))
                                               + *(float *)(a1 + 276))
                                       + (float)(*(float *)(a1 + 280) * v19)));
  float v22 = v15 * v21;
  float v23 = v16 * v21;
  float v24 = v8 - (float)(v3 * v22);
  float v25 = v9 - (float)(v3 * v23);
  float v26 = v10 - (float)(v5 * (float)(v18 * v21));
  float v27 = v12 + (float)(v2 * v22);
  float v28 = v13 + (float)(v2 * v23);
  float v29 = v14 + (float)(v4 * (float)(v17 * v21));
  float v30 = *(float *)a2 * v20;
  float v31 = *(float *)(a1 + 172);
  float v32 = v31 - (float)(*(float *)(a1 + 268) * (float)((float)(v29 - v26) - *(float *)(a1 + 184)));
  if (v32 >= v30) {
    float v32 = *(float *)a2 * v20;
  }
  if (v32 < (float)-v30) {
    float v32 = -v30;
  }
  float v33 = v32 - v31;
  float v34 = v26 - (float)(v5 * v33);
  float v35 = v29 + (float)(v4 * v33);
  float v36 = *(float *)(a1 + 240);
  float v37 = *(float *)(a1 + 244);
  float v38 = *(float *)(a1 + 260);
  float v39 = *(float *)(a1 + 256);
  float v40 = *(float *)(a1 + 264);
  float v41 = -(float)(v40
               * (float)((float)((float)((float)((float)(v28 - v25) * v37) + (float)(v36 * (float)(v27 - v24)))
                               + (float)(v38 * v35))
                       - (float)(v39 * v34)));
  *(float *)(a1 + 168) = *(float *)(a1 + 168)
                       - (float)(v40
                               * (float)((float)((float)((float)((float)(v28 - v25) * v37)
                                                       + (float)(v36 * (float)(v27 - v24)))
                                               + (float)(v38 * v35))
                                       - (float)(v39 * v34)));
  *(float *)(a1 + 17b2DynamicTree::~b2DynamicTree(this + 2) = v32;
  float v42 = v24 - (float)(v3 * (float)(v36 * v41));
  float v43 = v25 - (float)(v3 * (float)(v37 * v41));
  float v44 = v27 + (float)(v2 * (float)(v36 * v41));
  float result = v28 + (float)(v2 * (float)(v37 * v41));
  float *v7 = v42;
  v7[1] = v43;
  v7[3] = v34 - (float)(v5 * (float)(v39 * v41));
  float v46 = (float *)(*(void *)(a2 + 32) + 16 * *(int *)(a1 + 196));
  *float v46 = v44;
  v46[1] = result;
  v46[3] = v35 + (float)(v4 * (float)(v38 * v41));
  return result;
}

BOOL b2WheelJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  float v5 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  float v7 = *v5;
  float v6 = v5[1];
  float v8 = v5[3];
  float v9 = (float *)(v4 + 16 * *(int *)(a1 + 196));
  float v11 = *v9;
  float v10 = v9[1];
  float v12 = v9[3];
  __float2 v13 = __sincosf_stret(v8);
  __float2 v14 = __sincosf_stret(v12);
  float v15 = *(float *)(a1 + 136) - *(float *)(a1 + 200);
  float v16 = *(float *)(a1 + 140) - *(float *)(a1 + 204);
  float v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  float v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  float v19 = *(float *)(a1 + 144) - *(float *)(a1 + 208);
  float v20 = *(float *)(a1 + 148) - *(float *)(a1 + 212);
  float v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  float v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  float v23 = (float)((float)(v11 - v7) + v21) - v17;
  float v24 = (float)((float)(v10 - v6) + v22) - v18;
  float v25 = *(float *)(a1 + 160);
  float v26 = *(float *)(a1 + 164);
  float v27 = (float)(v13.__cosval * v25) - (float)(v13.__sinval * v26);
  float v28 = (float)(v13.__cosval * v26) + (float)(v13.__sinval * v25);
  float v29 = (float)(v28 * v24) + (float)(v23 * v27);
  float v30 = *(float *)(a1 + 216);
  float v31 = *(float *)(a1 + 220);
  float v32 = *(float *)(a1 + 224);
  float v33 = *(float *)(a1 + 228);
  float v34 = (float)((float)(v30 + v31) + (float)((float)(v32 * *(float *)(a1 + 256)) * *(float *)(a1 + 256)))
      + (float)((float)(v33 * *(float *)(a1 + 260)) * *(float *)(a1 + 260));
  float v35 = (float)-v29 / v34;
  BOOL v36 = v34 == 0.0;
  float v37 = 0.0;
  if (!v36) {
    float v37 = v35;
  }
  *float v5 = v7 - (float)(v30 * (float)(v27 * v37));
  v5[1] = v6 - (float)(v30 * (float)(v28 * v37));
  v5[3] = v8
        - (float)(v32 * (float)((float)((float)((float)(v17 + v23) * v28) - (float)((float)(v18 + v24) * v27)) * v37));
  float v38 = (float *)(*(void *)(a2 + 24) + 16 * *(int *)(a1 + 196));
  float *v38 = v11 + (float)(v31 * (float)(v27 * v37));
  v38[1] = v10 + (float)(v31 * (float)(v28 * v37));
  v38[3] = v12 + (float)(v33 * (float)((float)((float)(v21 * v28) - (float)(v22 * v27)) * v37));
  if (v29 <= 0.0) {
    float v39 = -v29;
  }
  else {
    float v39 = (float)(v28 * v24) + (float)(v23 * v27);
  }
  return v39 <= 0.0045;
}

float b2WheelJoint::GetAnchorA(b2WheelJoint *this)
{
  return *(float *)(*((void *)this + 12) + 32)
       + (float)((float)(*(float *)(*((void *)this + 12) + 44) * *((float *)this + 34))
               - (float)(*(float *)(*((void *)this + 12) + 40) * *((float *)this + 35)));
}

float b2WheelJoint::GetAnchorB(b2WheelJoint *this)
{
  return *(float *)(*((void *)this + 13) + 32)
       + (float)((float)(*(float *)(*((void *)this + 13) + 44) * *((float *)this + 36))
               - (float)(*(float *)(*((void *)this + 13) + 40) * *((float *)this + 37)));
}

float32x2_t b2WheelJoint::GetReactionForce(float32x2_t *this, float a2)
{
  return vmul_n_f32(vadd_f32(vmul_n_f32(this[30], this[21].f32[0]), vmul_n_f32(this[29], this[22].f32[0])), a2);
}

float b2WheelJoint::GetReactionTorque(b2WheelJoint *this, float a2)
{
  return *((float *)this + 43) * a2;
}

float b2WheelJoint::GetJointTranslation(b2WheelJoint *this)
{
  uint64_t v1 = (float *)*((void *)this + 12);
  float v2 = (float *)*((void *)this + 13);
  float v4 = v1[10];
  float v3 = v1[11];
  float v5 = *((float *)this + 34);
  return (float)((float)((float)((float)((float)(v2[11] * *((float *)this + 37))
                                       + (float)(v2[10] * *((float *)this + 36)))
                               + v2[9])
                       - (float)((float)((float)(v3 * *((float *)this + 35)) + (float)(v4 * v5)) + v1[9]))
               * (float)((float)(v3 * *((float *)this + 39)) + (float)(v4 * *((float *)this + 38))))
       + (float)((float)((float)(v2[8]
                               + (float)((float)(v2[11] * *((float *)this + 36))
                                       - (float)(v2[10] * *((float *)this + 37))))
                       - (float)(v1[8] + (float)((float)(v3 * v5) - (float)(v4 * *((float *)this + 35)))))
               * (float)((float)(v3 * *((float *)this + 38)) - (float)(v4 * *((float *)this + 39))));
}

float b2WheelJoint::GetJointSpeed(b2WheelJoint *this)
{
  return *(float *)(*((void *)this + 13) + 136) - *(float *)(*((void *)this + 12) + 136);
}

uint64_t b2WheelJoint::IsMotorEnabled(b2WheelJoint *this)
{
  return *((unsigned __int8 *)this + 188);
}

b2Body *b2WheelJoint::EnableMotor(b2Body **this, char a2)
{
  b2Body::SetAwake(this[12], 1);
  float result = b2Body::SetAwake(this[13], 1);
  *((unsigned char *)this + 188) = a2;
  return result;
}

b2Body *b2WheelJoint::SetMotorSpeed(b2Body **this, float a2)
{
  b2Body::SetAwake(this[12], 1);
  float result = b2Body::SetAwake(this[13], 1);
  *((float *)this + 46) = a2;
  return result;
}

b2Body *b2WheelJoint::SetMaxMotorTorque(b2Body **this, float a2)
{
  b2Body::SetAwake(this[12], 1);
  float result = b2Body::SetAwake(this[13], 1);
  *((float *)this + 45) = a2;
  return result;
}

float b2WheelJoint::GetMotorTorque(b2WheelJoint *this, float a2)
{
  return *((float *)this + 43) * a2;
}

void b2WheelJoint::~b2WheelJoint(b2WheelJoint *this)
{
}

void b2Rope::b2Rope(b2Rope *this)
{
  *(_DWORD *)this = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  *(void *)((char *)this + 68) = 0x3DCCCCCD3F800000;
}

void b2Rope::~b2Rope(void **this)
{
}

float b2Rope::Initialize(int *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8);
  if (v2 <= 2) {
    b2Rope::Initialize();
  }
  *a1 = v2;
  *((void *)a1 + 1) = b2Alloc(8 * v2);
  *((void *)a1 + b2DynamicTree::~b2DynamicTree(this + 2) = b2Alloc(8 * *a1);
  *((void *)a1 + 3) = b2Alloc(8 * *a1);
  *((void *)a1 + 4) = b2Alloc(4 * *a1);
  LODWORD(v5) = *a1;
  if (*a1 >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      *(void *)(*((void *)a1 + 1) + 8 * v6) = *(void *)(*(void *)a2 + 8 * v6);
      *(void *)(*((void *)a1 + 2) + 8 * v6) = *(void *)(*(void *)a2 + 8 * v6);
      *(void *)(*((void *)a1 + 3) + 8 * v6) = 0;
      float v7 = *(float *)(*(void *)(a2 + 16) + 4 * v6);
      if (v7 <= 0.0) {
        float v8 = 0.0;
      }
      else {
        float v8 = 1.0 / v7;
      }
      *(float *)(*((void *)a1 + 4) + 4 * v6++) = v8;
      uint64_t v5 = *a1;
    }
    while (v6 < v5);
  }
  uint64_t v9 = (v5 - 1);
  *((void *)a1 + 5) = b2Alloc(4 * (int)v9);
  float v10 = (float *)b2Alloc(4 * ((int)v5 - 2));
  *((void *)a1 + 6) = v10;
  uint64_t v11 = (v5 - 2);
  if ((int)v5 >= 2)
  {
    float v12 = v10;
    __float2 v13 = (float *)*((void *)a1 + 5);
    __float2 v14 = (float *)(*((void *)a1 + 1) + 8);
    do
    {
      float v15 = *(v14 - 2);
      float v16 = *(v14 - 1);
      float v17 = *v14;
      float v18 = v14[1];
      v14 += 2;
      *v13++ = sqrtf((float)((float)(v16 - v18) * (float)(v16 - v18)) + (float)((float)(v15 - v17) * (float)(v15 - v17)));
      --v9;
    }
    while (v9);
    if ((int)v5 >= 3)
    {
      float v19 = (float *)(*((void *)a1 + 1) + 12);
      do
      {
        float v20 = *(v19 - 3);
        float v21 = *(v19 - 2);
        float v22 = *(v19 - 1);
        float v23 = *v19;
        float v24 = v19[1];
        float v25 = v19[2];
        v19 += 2;
        *v12++ = atan2f((float)((float)(v22 - v20) * (float)(v25 - v23)) - (float)((float)(v23 - v21) * (float)(v24 - v22)), (float)((float)(v23 - v21) * (float)(v25 - v23)) + (float)((float)(v22 - v20) * (float)(v24 - v22)));
        --v11;
      }
      while (v11);
    }
  }
  *((void *)a1 + 7) = *(void *)(a2 + 24);
  *((void *)a1 + 8) = *(void *)(a2 + 32);
  float result = *(float *)(a2 + 40);
  *((float *)a1 + 18) = result;
  return result;
}

void b2Rope::Step(float32x2_t *this, double a2, int a3, double a4, double a5, double a6, double a7, int32x4_t a8)
{
  if (*(float *)&a2 != 0.0)
  {
    LODWORD(a6) = LODWORD(a2);
    LODWORD(v10) = this->i32[0];
    double v28 = a6;
    if (this->i32[0] >= 1)
    {
      *(float *)&a2 = expf(-(float)(*(float *)&a2 * this[8].f32[0]));
      a6 = v28;
      uint64_t v11 = 0;
      float32x2_t v12 = this[1];
      do
      {
        *(void *)(*(void *)&this[2] + 8 * v11) = *(void *)(*(void *)&v12 + 8 * v11);
        float32x2_t v13 = this[3];
        if (*(float *)(*(void *)&this[4] + 4 * v11) <= 0.0) {
          float32x2_t v14 = *(float32x2_t *)(*(void *)&v13 + 8 * v11);
        }
        else {
          float32x2_t v14 = vadd_f32(vmul_n_f32(this[7], *(float *)&v28), *(float32x2_t *)(*(void *)&v13 + 8 * v11));
        }
        float32x2_t v15 = vmul_n_f32(v14, *(float *)&a2);
        *(float32x2_t *)(*(void *)&v13 + 8 * v11) = v15;
        float32x2_t v12 = this[1];
        a5 = *(double *)(*(void *)&v12 + 8 * v11);
        a4 = COERCE_DOUBLE(vadd_f32(vmul_n_f32(v15, *(float *)&v28), *(float32x2_t *)&a5));
        *(double *)(*(void *)&v12 + 8 * v11++) = a4;
        uint64_t v10 = this->i32[0];
      }
      while (v11 < v10);
    }
    if (a3 >= 1)
    {
      do
      {
        b2Rope::SolveC2((uint64_t)this, a2, a4, a5, a6, a7, a8);
        b2Rope::SolveC3((b2Rope *)this);
        b2Rope::SolveC2((uint64_t)this, v16, v17, v18, v19, v20, v21);
        --a3;
      }
      while (a3);
      LODWORD(v10) = this->i32[0];
      LODWORD(a6) = LODWORD(v28);
    }
    if ((int)v10 >= 1)
    {
      float v22 = (float32x2_t *)this[1];
      float v23 = (float32x2_t *)this[2];
      float v24 = (float32x2_t *)this[3];
      uint64_t v10 = v10;
      do
      {
        float32x2_t v25 = *v22++;
        float32x2_t v26 = v25;
        float32x2_t v27 = *v23++;
        *v24++ = vmul_n_f32(vsub_f32(v26, v27), 1.0 / *(float *)&a6);
        --v10;
      }
      while (v10);
    }
  }
}

uint64_t b2Rope::SolveC2(uint64_t this, double a2, double a3, double a4, double a5, double a6, int32x4_t a7)
{
  if (*(int *)this >= 2)
  {
    uint64_t v7 = 0;
    float v8 = *(float32x2_t **)(this + 8);
    uint64_t v9 = *(void *)(this + 32);
    uint64_t v11 = (uint64_t)*v8;
    uint64_t v10 = v8 + 1;
    v12.i64[0] = v11;
    uint64_t v13 = 4 * (*(_DWORD *)this - 1);
    do
    {
      unint64_t v14 = (unint64_t)*v10;
      *(float32x2_t *)v15.f32 = vsub_f32(*v10, *(float32x2_t *)v12.f32);
      *(float *)a7.i32 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15).i32[1]), v15.f32[0], v15.f32[0]));
      if (*(float *)a7.i32 >= 0.00000011921) {
        *(float32x2_t *)v15.f32 = vmul_n_f32(*(float32x2_t *)v15.f32, 1.0 / *(float *)a7.i32);
      }
      else {
        a7.i32[0] = 0;
      }
      float32x2_t v16 = *(float32x2_t *)(v9 + v7);
      if (vaddv_f32(v16) != 0.0)
      {
        v15.i64[1] = v15.i64[0];
        *(float32x2_t *)a7.i8 = vmul_n_f32(vmul_n_f32(vdiv_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)v16, 1)), 0)), *(float *)(this + 68)), *(float *)(*(void *)(this + 40) + v7) - *(float *)a7.i32);
        a7 = vzip1q_s32(a7, a7);
        float32x4_t v17 = vmulq_f32(v15, (float32x4_t)a7);
        *(float32x2_t *)&v12.u32[2] = *v10;
        v18.i64[0] = vsubq_f32(v12, v17).u64[0];
        v18.i64[1] = vaddq_f32(v12, v17).i64[1];
        *(int8x16_t *)v10[-1].f32 = v18;
        unint64_t v14 = vextq_s8(v18, v18, 8uLL).u64[0];
      }
      v7 += 4;
      ++v10;
      v12.i64[0] = v14;
    }
    while (v13 != v7);
  }
  return this;
}

void b2Rope::SolveC3(b2Rope *this)
{
  if (*(int *)this >= 3)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (*(_DWORD *)this - 2);
    float v4 = (float *)*((void *)this + 1);
    uint64_t v5 = *((void *)this + 4);
    float v7 = *v4;
    float v6 = v4[1];
    float v9 = v4[2];
    float v8 = v4[3];
    float v10 = -1.0;
    float v11 = 1.0;
    do
    {
      uint64_t v12 = v2 + 1;
      uint64_t v13 = &v4[2 * v2 + 4];
      float v14 = *v13;
      float v15 = v13[1];
      float v16 = v9 - v7;
      float v17 = v8 - v6;
      float v18 = *v13 - v9;
      float v19 = v15 - v8;
      float v20 = (float)(v17 * v17) + (float)(v16 * v16);
      float v21 = (float)(v19 * v19) + (float)(v18 * v18);
      if ((float)(v20 * v21) != 0.0)
      {
        float v22 = *(float *)(v5 + 4 * v2);
        float v23 = *(float *)(v5 + 4 * v12);
        float v24 = *(float *)(v5 + 4 * (v2 + 2));
        float v25 = v10 / v20;
        float v26 = -(float)(v17 * v25);
        float v27 = v16 * v25;
        float v28 = v11 / v21;
        float v29 = -(float)(v19 * v28);
        float v30 = v26 - v29;
        float v31 = (float)(v16 * v25) - (float)(v18 * v28);
        float v32 = (float)((float)(v18 * v28) * (float)(v18 * v28)) + (float)(v29 * v29);
        if ((float)((float)((float)(v23 * (float)((float)(v31 * v31) + (float)(v30 * v30)))
                           + (float)(v22 * (float)((float)(v27 * v27) + (float)(v26 * v26))))
                   + (float)(v24 * v32)) != 0.0)
        {
          float v42 = (float)((float)(v23 * (float)((float)(v31 * v31) + (float)(v30 * v30)))
                      + (float)(v22 * (float)((float)(v27 * v27) + (float)(v26 * v26))))
              + (float)(v24 * v32);
          float v43 = v31;
          float v44 = v26 - v29;
          float v45 = *(float *)(v5 + 4 * v2);
          float v46 = v18 * v28;
          float v47 = -(float)(v19 * v28);
          float v48 = *(float *)(v5 + 4 * v12);
          float v49 = *(float *)(v5 + 4 * (v2 + 2));
          float v33 = atan2f((float)(v18 * (float)-v17) + (float)(v16 * v19), (float)(v17 * v19) + (float)(v16 * v18));
          float v34 = *(float *)(*((void *)this + 6) + 4 * v2);
          for (float i = v33 - v34; i > 3.1416; float i = v33 - v34)
            float v33 = v33 + -6.2832;
          float v11 = 1.0;
          if (i < -3.1416)
          {
            do
            {
              float v33 = v33 + 6.2832;
              float i = v33 - v34;
            }
            while ((float)(v33 - v34) < -3.1416);
          }
          BOOL v36 = &v4[2 * v2];
          float v37 = &v4[2 * v12];
          float v38 = i * (float)-(float)(*((float *)this + 18) * (float)(1.0 / v42));
          float v39 = v7 - (float)(v26 * (float)(v45 * v38));
          float v40 = v6 - (float)(v27 * (float)(v45 * v38));
          float v9 = v9 + (float)(v44 * (float)(v48 * v38));
          float v8 = v8 + (float)(v43 * (float)(v48 * v38));
          float v41 = v49 * v38;
          float v14 = v14 + (float)(v47 * v41);
          *BOOL v36 = v39;
          v36[1] = v40;
          *float v37 = v9;
          v37[1] = v8;
          float v15 = v15 + (float)(v46 * v41);
          *uint64_t v13 = v14;
          v13[1] = v15;
          float v10 = -1.0;
        }
      }
      float v7 = v9;
      float v6 = v8;
      float v8 = v15;
      float v9 = v14;
      ++v2;
    }
    while (v12 != v3);
  }
}

uint64_t b2Rope::SetAngle(uint64_t this, float a2)
{
  if (*(int *)this >= 3)
  {
    uint64_t v2 = (*(_DWORD *)this - 2);
    uint64_t v3 = *(float **)(this + 48);
    do
    {
      *v3++ = a2;
      --v2;
    }
    while (v2);
  }
  return this;
}

int *b2Rope::Draw(int *this, b2Draw *a2)
{
  uint64_t v6 = 0x3F0000003ECCCCCDLL;
  int v7 = 1060320051;
  if (*this >= 2)
  {
    uint64_t v3 = this;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      ++v5;
      this = (int *)(*(uint64_t (**)(b2Draw *, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 48))(a2, *((void *)v3 + 1) + v4, *((void *)v3 + 1) + v4 + 8, &v6);
      v4 += 8;
    }
    while (v5 < *v3 - 1);
  }
  return this;
}

BOOL triangleDoesNotContainOtherPoints(void *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = v4 - *a1;
  if (v4 == *a1)
  {
    return 1;
  }
  else
  {
    uint64_t v6 = 0;
    BOOL v7 = 0;
    unint64_t v8 = v5 >> 3;
    _S3 = vsub_f32(a3, a2).u32[0];
    _S5 = vsub_f32(a4, a2).u32[0];
    _S7 = vsub_f32(a4, a3).u32[0];
    if (v8 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v8;
    }
    do
    {
      float32x2_t v13 = *(float32x2_t *)(*a1 + 8 * v6);
      float32x2_t v14 = vsub_f32(a2, v13);
      if (fabsf(v14.f32[0]) > 0.0001 || fabsf(v14.f32[1]) > 0.0001)
      {
        float32x2_t v15 = vsub_f32(a3, v13);
        if (fabsf(v15.f32[0]) > 0.0001 || fabsf(v15.f32[1]) > 0.0001)
        {
          float32x2_t v16 = vsub_f32(a4, v13);
          if (fabsf(v16.f32[0]) > 0.0001 || fabsf(v16.f32[1]) > 0.0001)
          {
            _D20 = vsub_f32(v13, a2);
            __asm
            {
              FMLA            S19, S3, V20.S[1]
              FMLA            S21, S5, V20.S[1]
            }
            if (_S19 > 0.0 == _S21 <= 0.0)
            {
              BOOL v24 = _S19 > 0.0;
              _D18 = vsub_f32(v13, a3);
              __asm { FMLA            S19, S7, V18.S[1] }
              if ((v24 ^ (_S19 <= 0.0))) {
                break;
              }
            }
          }
        }
      }
      BOOL v7 = v8 <= ++v6;
    }
    while (v12 != v6);
  }
  return v7;
}

BOOL validConvexPolygon(int a1, int a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = *a3;
  unint64_t v5 = (a3[1] - *a3) >> 3;
  unint64_t v6 = ((int)v5 + a1) % v5;
  int v7 = ((int)v5 + a2) % v5;
  if ((int)v6 <= v7) {
    int v8 = ((int)v5 + a2) % v5;
  }
  else {
    int v8 = v5 + v7;
  }
  if (v8 - (int)v6 + 1 < 3) {
    return 0;
  }
  int v11 = v6 + 1;
  if ((int)v6 + 1 < v8)
  {
    unint64_t v12 = v11;
    do
    {
      uint64_t v13 = (v12 % v5) + v5;
      float32x2_t v14 = *(float32x2_t *)(v4 + ((uint64_t)((v12 % v5) << 32) >> 29));
      float32x2_t v15 = vsub_f32(*(float32x2_t *)(v4 + 8 * (int)((((v13 << 32) - 0x100000000) >> 32) % v5)), v14);
      float32x2_t v16 = vsub_f32(*(float32x2_t *)(v4 + 8 * (int)((((v13 << 32) + 0x100000000) >> 32) % v5)), v14);
      if (vmlas_n_f32((float)-v15.f32[1] * v16.f32[0], v16.f32[1], v15.f32[0]) >= 0.0) {
        return 0;
      }
    }
    while ((uint64_t)++v12 < v8);
  }
  if ((int)v6 + 2 <= v8)
  {
    float32x2_t v18 = *(float32x2_t *)(v4 + 8 * (int)v6);
    float32x2_t v19 = *(float32x2_t *)(v4 + 8 * (int)(v11 % v5));
    float32x2_t v20 = vsub_f32(v19, v18);
    uint64_t v21 = (int)v6 + 2;
    unint64_t v17 = v8;
    while (1)
    {
      float32x2_t v22 = *(float32x2_t *)(v4 + 8 * (int)(v21 % v5));
      float32x2_t v23 = vsub_f32(v22, v18);
      if (vmlas_n_f32(-(float)(v23.f32[1] * v20.f32[0]), v20.f32[1], v23.f32[0]) >= 0.0
        || !triangleDoesNotContainOtherPoints(a4, v19, v18, v22))
      {
        return 0;
      }
      if (v21++ >= v8) {
        goto LABEL_16;
      }
    }
  }
  unint64_t v17 = v8;
LABEL_16:
  float32x2_t v25 = *(float32x2_t *)(v4 + 8 * (int)(v17 % v5));
  float32x2_t v26 = *(float32x2_t *)(v4 + 8 * (int)(((int)v5 + v8 - 1) % v5));
  float32x2_t v27 = *(float32x2_t *)(v4 + 8 * (int)(((int)v5 + (int)v6) % v5));
  float32x2_t v28 = vsub_f32(v26, v25);
  float32x2_t v29 = vsub_f32(v27, v25);
  if (vmlas_n_f32((float)-v28.f32[1] * v29.f32[0], v29.f32[1], v28.f32[0]) >= 0.0) {
    return 0;
  }

  return triangleDoesNotContainOtherPoints(a4, v26, v25, v27);
}

uint64_t trisFromCCWFaces(uint64_t a1, char **a2, void **a3)
{
  float v79 = 0;
  float v80 = 0;
  uint64_t v81 = 0;
  _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(&v79, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  unint64_t v6 = (char *)v79;
  int v7 = v80;
  if ((unint64_t)(v80 - (unsigned char *)v79) >= 0x11)
  {
    uint64_t v73 = (uint64_t)(a3 + 2);
    int v8 = a2 + 2;
    uint64_t v75 = (uint64_t)a3;
    while (1)
    {
      __p = 0;
      float v77 = 0;
      float v78 = 0;
      unint64_t v9 = (v7 - v6) >> 3;
      if (v7 == v6) {
        break;
      }
      float v10 = 0;
      unint64_t v11 = 0;
      do
      {
        float32x2_t v12 = *(float32x2_t *)&v6[8 * v11];
        float32x2_t v13 = vsub_f32(*(float32x2_t *)&v6[8 * (int)(((int)v11 + (int)v9 - 1) % v9)], v12);
        float32x2_t v14 = vsub_f32(*(float32x2_t *)&v6[8 * (int)(((int)v11 + (int)v9 + 1) % v9)], v12);
        if (vmlas_n_f32((float)-v13.f32[1] * v14.f32[0], v14.f32[1], v13.f32[0]) >= 0.0)
        {
          if (v10 >= v78)
          {
            float32x2_t v16 = __p;
            uint64_t v17 = (v10 - __p) >> 2;
            unint64_t v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62) {
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v19 = v78 - __p;
            if ((v78 - __p) >> 1 > v18) {
              unint64_t v18 = v19 >> 1;
            }
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v20 = v18;
            }
            if (v20)
            {
              uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v78, v20);
              float32x2_t v16 = __p;
              float v10 = v77;
            }
            else
            {
              uint64_t v21 = 0;
            }
            float32x2_t v22 = &v21[4 * v17];
            *(_DWORD *)float32x2_t v22 = v11;
            float32x2_t v15 = v22 + 4;
            while (v10 != v16)
            {
              int v23 = *((_DWORD *)v10 - 1);
              v10 -= 4;
              *((_DWORD *)v22 - 1) = v23;
              v22 -= 4;
            }
            __p = v22;
            float v78 = &v21[4 * v20];
            if (v16) {
              operator delete(v16);
            }
          }
          else
          {
            *(_DWORD *)float v10 = v11;
            float32x2_t v15 = v10 + 4;
          }
          float v77 = v15;
          float v10 = v15;
          unint64_t v6 = (char *)v79;
          int v7 = v80;
        }
        ++v11;
        unint64_t v9 = (v7 - v6) >> 3;
      }
      while (v9 > v11);
      uint64_t v24 = v10 - __p;
      if (v10 == __p) {
        break;
      }
      unint64_t v25 = v24 >> 2;
      if (v24 >> 2 == v9)
      {
        unint64_t v26 = (unint64_t)(a2[1] - *a2) >> 3;
        float32x2_t v28 = a3[1];
        unint64_t v27 = (unint64_t)a3[2];
        if ((unint64_t)v28 >= v27)
        {
          float v49 = *a3;
          uint64_t v50 = ((char *)v28 - (unsigned char *)*a3) >> 2;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62) {
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v52 = v27 - (void)v49;
          if (v52 >> 1 > v51) {
            unint64_t v51 = v52 >> 1;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v53 = v51;
          }
          if (v53)
          {
            float v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v73, v53);
            float v49 = *a3;
            float32x2_t v28 = a3[1];
          }
          else
          {
            float v54 = 0;
          }
          float v55 = &v54[4 * v50];
          *(_DWORD *)float v55 = v26;
          float32x2_t v29 = v55 + 4;
          while (v28 != v49)
          {
            int v56 = *--v28;
            *((_DWORD *)v55 - 1) = v56;
            v55 -= 4;
          }
          *a3 = v55;
          a3[1] = v29;
          a3[2] = &v54[4 * v53];
          if (v49) {
            operator delete(v49);
          }
        }
        else
        {
          *float32x2_t v28 = v26;
          float32x2_t v29 = v28 + 1;
        }
        a3[1] = v29;
        if ((int)((unint64_t)(v80 - (unsigned char *)v79) >> 3) < 1) {
          goto LABEL_29;
        }
        uint64_t v57 = ((unint64_t)(v80 - (unsigned char *)v79) >> 3);
        float v58 = a2[1];
        do
        {
          uint64_t v59 = (v57 - 1);
          float v60 = v79;
          if ((unint64_t)v58 >= *v8)
          {
            uint64_t v61 = (v58 - *a2) >> 3;
            if ((unint64_t)(v61 + 1) >> 61) {
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v62 = *v8 - (void)*a2;
            uint64_t v63 = v62 >> 2;
            if (v62 >> 2 <= (unint64_t)(v61 + 1)) {
              uint64_t v63 = v61 + 1;
            }
            if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v64 = v63;
            }
            if (v64) {
              float v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v64);
            }
            else {
              float v65 = 0;
            }
            float v66 = &v65[8 * v61];
            *(void *)float v66 = v60[v59];
            float v58 = v66 + 8;
            float v68 = *a2;
            float v67 = a2[1];
            if (v67 != *a2)
            {
              do
              {
                uint64_t v69 = *((void *)v67 - 1);
                v67 -= 8;
                *((void *)v66 - 1) = v69;
                v66 -= 8;
              }
              while (v67 != v68);
              float v67 = *a2;
            }
            *a2 = v66;
            a2[1] = v58;
            a2[2] = &v65[8 * v64];
            if (v67) {
              operator delete(v67);
            }
          }
          else
          {
            *(void *)float v58 = *((void *)v79 + v59);
            v58 += 8;
          }
          a2[1] = v58;
        }
        while (v57-- > 1);
        int v30 = 1;
LABEL_94:
        a3 = (void **)v75;
      }
      else
      {
        if ((unint64_t)v24 >= 5)
        {
          uint64_t v31 = 0;
          while (1)
          {
            if (v25 == v31) {
              goto LABEL_36;
            }
            uint64_t v32 = v31 + 1;
            int v33 = *(_DWORD *)&__p[4 * v31];
            uint64_t v34 = v33;
            int v35 = *(_DWORD *)&__p[4 * ((v31 + 1) % v25)];
            uint64_t v36 = v35;
            if (validConvexPolygon(v33, v35, (uint64_t *)&v79, (void *)a1)) {
              break;
            }
            BOOL valid = validConvexPolygon(v36, v34, (uint64_t *)&v79, (void *)a1);
            uint64_t v31 = v32;
            if (valid)
            {
              emitConvexBodyInclusive(v36, v34, (uint64_t *)&v79, a2, v75);
              unint64_t v38 = ((v36 + 1) % (unint64_t)((v80 - (unsigned char *)v79) >> 3));
              int v39 = v34 - 1;
LABEL_93:
              erasePointsInclusive((void *)v38, v39, (char **)&v79);
              int v30 = 2;
              goto LABEL_94;
            }
          }
          emitConvexBodyInclusive(v34, v36, (uint64_t *)&v79, a2, v75);
          unint64_t v38 = ((v34 + 1) % (unint64_t)((v80 - (unsigned char *)v79) >> 3));
          int v39 = v36 - 1;
          goto LABEL_93;
        }
LABEL_36:
        unint64_t v40 = 0;
        if (v25 <= 1) {
          uint64_t v41 = 1;
        }
        else {
          uint64_t v41 = v25;
        }
        uint64_t v74 = v41;
        do
        {
          int v42 = *(_DWORD *)&__p[4 * v40++];
          if (*(int *)&__p[4 * (v40 % v25)] <= 3) {
            int v43 = 3;
          }
          else {
            int v43 = *(_DWORD *)&__p[4 * (v40 % v25)];
          }
          while (v43 >= 3)
          {
            if (validConvexPolygon(v42, --v43 + v42, (uint64_t *)&v79, (void *)a1))
            {
              a3 = (void **)v75;
              emitConvexBodyInclusive(v42, v42 + v43, (uint64_t *)&v79, a2, v75);
              erasePointsInclusive((void *)((int)(((v80 - (unsigned char *)v79) >> 3) + v42 + 1)% (unint64_t)((v80 - (unsigned char *)v79) >> 3)), (int)(((v80 - (unsigned char *)v79) >> 3) + v42 + v43 - 1) % (unint64_t)((v80 - (unsigned char *)v79) >> 3), (char **)&v79);
              int v30 = 2;
              goto LABEL_95;
            }
          }
        }
        while (v40 != v74);
        uint64_t v44 = 0;
        do
        {
          int v45 = *(_DWORD *)&__p[4 * v44];
          uint64_t v72 = v44;
          if (*(int *)&__p[4 * ((v44 - 1) % v25)] <= 3) {
            int v46 = 3;
          }
          else {
            int v46 = *(_DWORD *)&__p[4 * ((v44 - 1) % v25)];
          }
          int v47 = 1 - v46;
          while (v46 >= 3)
          {
            --v46;
            if (validConvexPolygon(v45 + v47++, v45, (uint64_t *)&v79, (void *)a1))
            {
              a3 = (void **)v75;
              emitConvexBodyInclusive(v45 - v46, v45, (uint64_t *)&v79, a2, v75);
              erasePointsInclusive((void *)((int)(((v80 - (unsigned char *)v79) >> 3) + v45 - v46 + 1)% (unint64_t)((v80 - (unsigned char *)v79) >> 3)), (int)(((v80 - (unsigned char *)v79) >> 3) + v45 - 1) % (unint64_t)((v80 - (unsigned char *)v79) >> 3), (char **)&v79);
              int v30 = 0;
              goto LABEL_95;
            }
          }
          uint64_t v44 = v72 + 1;
          int v30 = 3;
          a3 = (void **)v75;
        }
        while (v72 + 1 != v74);
      }
LABEL_95:
      if (__p) {
        operator delete(__p);
      }
      if ((v30 | 2) != 2)
      {
        unint64_t v6 = (char *)v79;
        goto LABEL_101;
      }
      unint64_t v6 = (char *)v79;
      int v7 = v80;
      if ((unint64_t)(v80 - (unsigned char *)v79) <= 0x10) {
        goto LABEL_101;
      }
    }
    emitConvexBodyInclusive(0, v9 - 1, (uint64_t *)&v79, a2, (uint64_t)a3);
LABEL_29:
    int v30 = 1;
    goto LABEL_95;
  }
LABEL_101:
  if (v6)
  {
    float v80 = v6;
    operator delete(v6);
  }
  return 1;
}

void sub_2135909C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void emitConvexBodyInclusive(int a1, int a2, uint64_t *a3, char **a4, uint64_t a5)
{
  unint64_t v10 = (unint64_t)(a4[1] - *a4) >> 3;
  unint64_t v11 = *(void *)(a5 + 16);
  float32x2_t v12 = *(_DWORD **)(a5 + 8);
  if ((unint64_t)v12 >= v11)
  {
    float32x2_t v14 = *(_DWORD **)a5;
    uint64_t v15 = ((uint64_t)v12 - *(void *)a5) >> 2;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 62) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v11 - (void)v14;
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a5 + 16, v18);
      float32x2_t v14 = *(_DWORD **)a5;
      float32x2_t v12 = *(_DWORD **)(a5 + 8);
    }
    else
    {
      uint64_t v19 = 0;
    }
    unint64_t v20 = &v19[4 * v15];
    uint64_t v21 = &v19[4 * v18];
    *(_DWORD *)unint64_t v20 = v10;
    float32x2_t v13 = v20 + 4;
    while (v12 != v14)
    {
      int v22 = *--v12;
      *((_DWORD *)v20 - 1) = v22;
      v20 -= 4;
    }
    *(void *)a5 = v20;
    *(void *)(a5 + 8) = v13;
    *(void *)(a5 + 16) = v21;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    _DWORD *v12 = v10;
    float32x2_t v13 = v12 + 1;
  }
  *(void *)(a5 + 8) = v13;
  unint64_t v23 = (a3[1] - *a3) >> 3;
  unint64_t v24 = ((int)v23 + a1) % v23;
  int v25 = ((int)v23 + a2) % v23;
  if ((int)v24 <= v25) {
    LODWORD(v23) = 0;
  }
  int v26 = v23 + v25;
  if (v26 >= (int)v24)
  {
    unint64_t v27 = a4 + 2;
    uint64_t v28 = (int)v24;
    uint64_t v29 = v26;
    int v30 = a4[1];
    do
    {
      uint64_t v31 = *a3;
      unint64_t v32 = v28 % (unint64_t)((a3[1] - *a3) >> 3);
      if ((unint64_t)v30 >= *v27)
      {
        uint64_t v33 = (v30 - *a4) >> 3;
        if ((unint64_t)(v33 + 1) >> 61) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v34 = *v27 - (void)*a4;
        uint64_t v35 = v34 >> 2;
        if (v34 >> 2 <= (unint64_t)(v33 + 1)) {
          uint64_t v35 = v33 + 1;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v35;
        }
        if (v36) {
          float v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a4 + 2), v36);
        }
        else {
          float v37 = 0;
        }
        unint64_t v38 = &v37[8 * v33];
        *(void *)unint64_t v38 = *(void *)(v31 + 8 * v32);
        int v30 = v38 + 8;
        unint64_t v40 = *a4;
        int v39 = a4[1];
        if (v39 != *a4)
        {
          do
          {
            uint64_t v41 = *((void *)v39 - 1);
            v39 -= 8;
            *((void *)v38 - 1) = v41;
            v38 -= 8;
          }
          while (v39 != v40);
          int v39 = *a4;
        }
        *a4 = v38;
        a4[1] = v30;
        a4[2] = &v37[8 * v36];
        if (v39) {
          operator delete(v39);
        }
      }
      else
      {
        *(void *)int v30 = *(void *)(v31 + 8 * v32);
        v30 += 8;
      }
      a4[1] = v30;
    }
    while (v28++ < v29);
  }
}

void *erasePointsInclusive(void *result, int a2, char **a3)
{
  unint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  unint64_t v6 = (v4 - *a3) >> 3;
  unint64_t v7 = ((int)v6 + (int)result) % v6;
  unint64_t v8 = ((int)v6 + a2) % v6;
  uint64_t v9 = (uint64_t)&(*a3)[8 * (int)v7];
  if ((int)v7 <= (int)v8)
  {
    unint64_t v10 = &v5[8 * (int)v8 + 8];
    if ((char *)v9 == v10) {
      return result;
    }
    uint64_t v11 = v4 - v10;
    if (v4 != v10) {
      float result = memmove(&(*a3)[8 * (int)v7], v10, v4 - v10);
    }
    goto LABEL_12;
  }
  if ((char *)v9 == v4) {
    uint64_t v9 = (uint64_t)a3[1];
  }
  else {
    a3[1] = (char *)v9;
  }
  float32x2_t v12 = &v5[8 * (int)v8 + 8];
  if (v5 != v12)
  {
    uint64_t v11 = v9 - (void)v12;
    if ((char *)v9 != v12) {
      float result = memmove(v5, v12, v9 - (void)v12);
    }
    uint64_t v9 = (uint64_t)v5;
LABEL_12:
    a3[1] = (char *)(v9 + v11);
  }
  return result;
}

void *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    float result = std::vector<PKPoint>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_213590D98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void PKPath::PKPath(PKPath *this, const CGPath *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + b2DynamicTree::~b2DynamicTree(this + 2) = 0;
  *((void *)this + 3) = 0;
  uint64_t v3 = (const CGPath *)MEMORY[0x21668C730](a2);
  *((void *)this + 4) = v3;
  unint64_t v6 = this;
  info[0] = 0;
  uint64_t v5 = 0x3F8000000000000FLL;
  CGPathApply(v3, info, (CGPathApplierFunction)PKPathApplyCGPath);
}

void sub_213590EA0(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void PKPathApplyCGPath(void *a1, const CGPathElement *a2, float32x2_t a3)
{
  if (!a1 || *(unsigned char *)a1) {
    return;
  }
  uint64_t v5 = a1[2];
  uint64_t v7 = (void **)(v5 + 8);
  unint64_t v6 = *(float **)(v5 + 8);
  size_t v8 = *(float **)(v5 + 16);
  CGPathElementType type = a2->type;
  BOOL v10 = v6 == v8 && type == kCGPathElementMoveToPoint;
  if (v10)
  {
    points = a2->points;
    float x = points->x;
    float y = points->y;
    unint64_t v43 = *(void *)(v5 + 24);
    if ((unint64_t)v6 >= v43)
    {
      uint64_t v45 = v43 - (void)v6;
      uint64_t v46 = v45 >> 2;
      if ((unint64_t)(v45 >> 2) <= 1) {
        uint64_t v46 = 1;
      }
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v47 = v46;
      }
      float v48 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v47);
      float v49 = *(char **)(v5 + 8);
      uint64_t v50 = *(char **)(v5 + 16);
      uint64_t v52 = &v48[2 * v51];
      *float v48 = x;
      v48[1] = y;
      uint64_t v44 = v48 + 2;
      if (v50 != v49)
      {
        do
        {
          uint64_t v53 = *((void *)v50 - 1);
          v50 -= 8;
          *((void *)v48 - 1) = v53;
          v48 -= 2;
        }
        while (v50 != v49);
        float v49 = (char *)*v7;
      }
      *(void *)(v5 + 8) = v48;
      *(void *)(v5 + 16) = v44;
      *(void *)(v5 + 24) = v52;
      if (v49) {
        operator delete(v49);
      }
    }
    else
    {
      float *v6 = x;
      v6[1] = y;
      uint64_t v44 = v6 + 2;
    }
    *(void *)(v5 + 16) = v44;
    *(_DWORD *)a1[2] = 0;
    return;
  }
  uint64_t v11 = ((char *)v8 - (char *)v6) >> 3;
  float v13 = *(v8 - 2);
  float v12 = *(v8 - 1);
  switch(type)
  {
    case kCGPathElementCloseSubpath:
      float v54 = *v6;
      float v55 = v6[1];
      unint64_t v56 = *(void *)(v5 + 24);
      if ((unint64_t)v8 >= v56)
      {
        unint64_t v61 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          goto LABEL_85;
        }
        uint64_t v62 = v56 - (void)v6;
        if (v62 >> 2 > v61) {
          unint64_t v61 = v62 >> 2;
        }
        if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v63 = v61;
        }
        if (v63)
        {
          unint64_t v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v63);
          unint64_t v6 = *(float **)(v5 + 8);
          size_t v8 = *(float **)(v5 + 16);
        }
        else
        {
          unint64_t v64 = 0;
        }
        uint64_t v69 = (float *)&v64[8 * v11];
        float *v69 = v54;
        v69[1] = v55;
        uint64_t v57 = v69 + 2;
        if (v8 != v6)
        {
          do
          {
            uint64_t v70 = *((void *)v8 - 1);
            v8 -= 2;
            *((void *)v69 - 1) = v70;
            v69 -= 2;
          }
          while (v8 != v6);
          unint64_t v6 = (float *)*v7;
        }
        *(void *)(v5 + 8) = v69;
        *(void *)(v5 + 16) = v57;
        *(void *)(v5 + 24) = &v64[8 * v63];
        if (v6) {
          operator delete(v6);
        }
      }
      else
      {
        *size_t v8 = v54;
        v8[1] = v55;
        uint64_t v57 = v8 + 2;
      }
      *(void *)(v5 + 16) = v57;
      *(float *)a1[2] = sqrtf((float)((float)(v55 - v12) * (float)(v55 - v12))+ (float)((float)(v54 - v13) * (float)(v54 - v13)))+ *(float *)a1[2];
      goto LABEL_76;
    case kCGPathElementAddLineToPoint:
      float32x2_t v58 = vcvt_f32_f64(*(float64x2_t *)a2->points);
      unint64_t v59 = *(void *)(v5 + 24);
      if ((unint64_t)v8 < v59)
      {
        *(float32x2_t *)size_t v8 = v58;
        float v60 = v8 + 2;
LABEL_83:
        *(void *)(v5 + 16) = v60;
        *(float *)a1[2] = sqrtf((float)((float)(v58.f32[1] - v12) * (float)(v58.f32[1] - v12))+ (float)((float)(v58.f32[0] - v13) * (float)(v58.f32[0] - v13)))+ *(float *)a1[2];
        return;
      }
      unint64_t v65 = v11 + 1;
      if (!((unint64_t)(v11 + 1) >> 61))
      {
        uint64_t v66 = v59 - (void)v6;
        if (v66 >> 2 > v65) {
          unint64_t v65 = v66 >> 2;
        }
        if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v67 = v65;
        }
        float32x2_t v73 = v58;
        if (v67)
        {
          float v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v67);
          float32x2_t v58 = v73;
          unint64_t v6 = *(float **)(v5 + 8);
          size_t v8 = *(float **)(v5 + 16);
        }
        else
        {
          float v68 = 0;
        }
        float v71 = (float32x2_t *)&v68[8 * v11];
        *float v71 = v58;
        float v60 = (float *)&v71[1];
        if (v8 != v6)
        {
          do
          {
            float32x2_t v72 = *(float32x2_t *)(v8 - 2);
            v8 -= 2;
            v71[-1] = v72;
            --v71;
          }
          while (v8 != v6);
          unint64_t v6 = (float *)*v7;
        }
        *(void *)(v5 + 8) = v71;
        *(void *)(v5 + 16) = v60;
        *(void *)(v5 + 24) = &v68[8 * v67];
        if (v6)
        {
          operator delete(v6);
          float32x2_t v58 = v73;
        }
        goto LABEL_83;
      }
LABEL_85:
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    case kCGPathElementMoveToPoint:
LABEL_76:
      *(unsigned char *)a1 = 1;
      return;
  }
  int v14 = 0;
  int v15 = *((_DWORD *)a1 + 1);
  if (v15 <= 1) {
    int v15 = 1;
  }
  float v16 = (float)v15;
  int v17 = v15 + 1;
  float v18 = 0.0;
  float v19 = *(v8 - 1);
  float v20 = *(v8 - 2);
  do
  {
    a3.f32[0] = v20;
    a3 = pointOnPath((uint64_t)a2, a3, v19, (float)v14 / v16);
    float v18 = v18
        + sqrtf((float)((float)(v21 - v19) * (float)(v21 - v19))+ (float)((float)(a3.f32[0] - v20) * (float)(a3.f32[0] - v20)));
    ++v14;
    float v19 = v21;
    float v20 = a3.f32[0];
  }
  while (v17 != v14);
  int v22 = 0;
  if ((int)(float)(v18 / *((float *)a1 + 2)) <= 1) {
    int v23 = 1;
  }
  else {
    int v23 = (int)(float)(v18 / *((float *)a1 + 2));
  }
  do
  {
    *(double *)&float32x2_t v24 = (double)v22 / (double)v23;
    float v25 = *(double *)&v24;
    v24.f32[0] = v13;
    unsigned __int32 v26 = pointOnPath((uint64_t)a2, v24, v12, v25).u32[0];
    float v28 = *(float *)&v26;
    float v29 = v27;
    unint64_t v30 = *(void *)(v5 + 24);
    if ((unint64_t)v8 >= v30)
    {
      uint64_t v32 = ((char *)v8 - (char *)v6) >> 3;
      unint64_t v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 61) {
        goto LABEL_85;
      }
      uint64_t v34 = v30 - (void)v6;
      if (v34 >> 2 > v33) {
        unint64_t v33 = v34 >> 2;
      }
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v33;
      }
      if (v35)
      {
        unint64_t v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v35);
        unint64_t v6 = *(float **)(v5 + 8);
        size_t v8 = *(float **)(v5 + 16);
      }
      else
      {
        unint64_t v36 = 0;
      }
      float v37 = (float *)&v36[8 * v32];
      *float v37 = v28;
      v37[1] = v29;
      unint64_t v38 = v37;
      if (v8 != v6)
      {
        do
        {
          uint64_t v39 = *((void *)v8 - 1);
          v8 -= 2;
          *((void *)v38 - 1) = v39;
          v38 -= 2;
        }
        while (v8 != v6);
        unint64_t v6 = *(float **)(v5 + 8);
      }
      uint64_t v31 = v37 + 2;
      *(void *)(v5 + 8) = v38;
      *(void *)(v5 + 16) = v37 + 2;
      *(void *)(v5 + 24) = &v36[8 * v35];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *size_t v8 = *(float *)&v26;
      v8[1] = v27;
      uint64_t v31 = v8 + 2;
    }
    *(void *)(v5 + 16) = v31;
    uint64_t v5 = a1[2];
    unint64_t v6 = *(float **)(v5 + 8);
    size_t v8 = *(float **)(v5 + 16);
    *(float *)uint64_t v5 = *(float *)v5
                 + sqrtf((float)((float)(v29 - *(v8 - 3)) * (float)(v29 - *(v8 - 3)))+ (float)((float)(v28 - *(v8 - 4)) * (float)(v28 - *(v8 - 4))));
    BOOL v10 = v22++ == v23;
  }
  while (!v10);
}

void printPKPath(void *a1, const CGPathElement *a2)
{
  switch(a2->type)
  {
    case kCGPathElementMoveToPoint:
      points = a2->points;
      CGFloat x = points->x;
      CGFloat y = points->y;
      uint64_t v5 = @"moveto";
      goto LABEL_4;
    case kCGPathElementAddLineToPoint:
      unint64_t v6 = a2->points;
      CGFloat x = v6->x;
      CGFloat y = v6->y;
      uint64_t v5 = @"lineto";
LABEL_4:
      NSLog(&cfstr_FF.isa, *(void *)&x, *(void *)&y, v5);
      break;
    case kCGPathElementAddQuadCurveToPoint:
      NSLog(&cfstr_FFFF.isa, *(void *)&a2->points->x, *(void *)&a2->points->y, *(void *)&a2->points[1].x, *(void *)&a2->points[1].y, @"quadcurveto");
      break;
    case kCGPathElementAddCurveToPoint:
      uint64_t v7 = a2->points;
      NSLog(&cfstr_FFFFFF.isa, *(void *)&v7->x, *(void *)&v7->y, *(void *)&v7[1].x, *(void *)&v7[1].y, *(void *)&v7[2].x, *(void *)&v7[2].y, @"curveto");
      break;
    case kCGPathElementCloseSubpath:
      NSLog(&cfstr_Closepath.isa);
      break;
    default:
      return;
  }
}

BOOL PKPath::isEqualToPath(PKPath *this, PKPath *a2)
{
  uint64_t v2 = (const CGPath *)*((void *)this + 4);
  uint64_t v3 = (const CGPath *)*((void *)a2 + 4);
  if (!v2) {
    return !v3;
  }
  if (!v3) {
    return 0;
  }
  BOOL result = CGPathEqualToPath(v2, v3);
  if (result) {
    return 1;
  }
  return result;
}

float PKPath::computeLength(PKPath *this, float result)
{
  *(_DWORD *)this = 0;
  uint64_t v2 = (float *)*((void *)this + 1);
  uint64_t v3 = *((void *)this + 2) - (void)v2;
  if ((unint64_t)v3 >= 9)
  {
    unint64_t v4 = v3 >> 3;
    float v7 = *v2;
    float v6 = v2[1];
    uint64_t v5 = v2 + 3;
    if (v4 <= 2) {
      unint64_t v4 = 2;
    }
    unint64_t v8 = v4 - 1;
    BOOL result = 0.0;
    do
    {
      float v9 = *(v5 - 1);
      float v10 = *v5;
      BOOL result = result
             + sqrtf((float)((float)(*v5 - v6) * (float)(*v5 - v6)) + (float)((float)(v9 - v7) * (float)(v9 - v7)));
      *(float *)this = result;
      v5 += 2;
      float v6 = v10;
      float v7 = v9;
      --v8;
    }
    while (v8);
  }
  return result;
}

void PKPath::createPath(PKPath *this)
{
  uint64_t v2 = (const CGPath *)*((void *)this + 4);
  if (v2) {
    CGPathRelease(v2);
  }
  if (*((void *)this + 2) == *((void *)this + 1))
  {
    *((void *)this + 4) = 0;
  }
  else
  {
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, **((float **)this + 1), *(float *)(*((void *)this + 1) + 4));
    uint64_t v4 = *((void *)this + 1);
    if ((unint64_t)(*((void *)this + 2) - v4) >= 9)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 1;
      do
      {
        CGPathAddLineToPoint(Mutable, 0, *(float *)(v4 + v5 + 8), *(float *)(v4 + v5 + 12));
        ++v6;
        uint64_t v4 = *((void *)this + 1);
        v5 += 8;
      }
      while (v6 < (*((void *)this + 2) - v4) >> 3);
    }
    CGPathCloseSubpath(Mutable);
    *((void *)this + 4) = MEMORY[0x21668C730](Mutable);
    CGPathRelease(Mutable);
  }
}

void PKPathCreateFromCGPath()
{
}

void sub_21359163C(_Unwind_Exception *a1)
{
  MEMORY[0x21668C8E0](v1, 0x1060C402159C14DLL);
  _Unwind_Resume(a1);
}

void PKPathCreateFromCGPathWithOptions()
{
}

void rdpReduce(uint64_t a1@<X0>, float **a2@<X8>, float a3@<S0>)
{
  uint64_t v5 = *(float **)a1;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = v4 - *(void *)a1;
  unint64_t v7 = v6 >> 3;
  if ((unint64_t)v6 > 0x17)
  {
    float v10 = *v5;
    float v11 = v5[1];
    float v13 = *(float *)(v4 - 8);
    float v12 = *(float *)(v4 - 4);
    if (v7 - 1 < 2)
    {
      int v18 = -1;
      float v17 = 0.0;
    }
    else
    {
      double v14 = (float)((float)(v12 - v11) / (float)(v13 - v10));
      double v15 = sqrt(v14 * v14 + 1.0);
      float v16 = v5 + 3;
      float v17 = 0.0;
      int v18 = -1;
      uint64_t v19 = 2;
      do
      {
        float v20 = *(v16 - 1);
        if (v10 == v13) {
          float v21 = vabds_f32(v20, v10);
        }
        else {
          float v21 = fabs(v11 - v14 * v10 - (*v16 - v14 * v20)) / v15;
        }
        if (v21 > v17)
        {
          float v17 = v21;
          int v18 = v19 - 1;
        }
        v16 += 2;
        ++v19;
      }
      while (v7 != v19);
    }
    if (v17 <= a3)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      int v22 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), 1uLL);
      int v23 = *a2;
      float32x2_t v24 = a2[1];
      unsigned __int32 v26 = &v22[2 * v25];
      float *v22 = v10;
      v22[1] = v11;
      float v27 = v22 + 2;
      float v28 = v22;
      if (v24 != v23)
      {
        do
        {
          uint64_t v29 = *((void *)v24 - 1);
          v24 -= 2;
          *((void *)v28 - 1) = v29;
          v28 -= 2;
        }
        while (v24 != v23);
        int v23 = *a2;
      }
      *a2 = v28;
      a2[1] = v27;
      a2[2] = v26;
      if (v23)
      {
        operator delete(v23);
        unsigned __int32 v26 = a2[2];
      }
      a2[1] = v27;
      if (v27 >= v26)
      {
        uint64_t v31 = *a2;
        uint64_t v32 = ((char *)v27 - (char *)*a2) >> 3;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 61) {
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v34 = (char *)v26 - (char *)v31;
        if (v34 >> 2 > v33) {
          unint64_t v33 = v34 >> 2;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v33;
        }
        if (v35)
        {
          unint64_t v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v35);
          uint64_t v31 = *a2;
          float v27 = a2[1];
        }
        else
        {
          unint64_t v36 = 0;
        }
        float v37 = (float *)&v36[8 * v32];
        unint64_t v38 = (float *)&v36[8 * v35];
        *float v37 = v13;
        v37[1] = v12;
        unint64_t v30 = v37 + 2;
        if (v27 != v31)
        {
          do
          {
            uint64_t v39 = *((void *)v27 - 1);
            v27 -= 2;
            *((void *)v37 - 1) = v39;
            v37 -= 2;
          }
          while (v27 != v31);
          uint64_t v31 = *a2;
        }
        *a2 = v37;
        a2[1] = v30;
        a2[2] = v38;
        if (v31) {
          operator delete(v31);
        }
      }
      else
      {
        v22[2] = v13;
        v22[3] = v12;
        unint64_t v30 = v22 + 4;
      }
      a2[1] = v30;
    }
    else
    {
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>((uint64_t)&v45, 0, (char *)v5, (char *)&v5[2 * v18 + 2], (8 * v18 + 8) >> 3);
      int v42 = 0;
      unint64_t v43 = 0;
      uint64_t v44 = 0;
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>((uint64_t)&v42, 0, (char *)(*(void *)a1 + 8 * v18), *(char **)(a1 + 8), (*(void *)(a1 + 8) - (*(void *)a1 + 8 * v18)) >> 3);
      rdpReduce(&v45, a3);
      rdpReduce(&v42, a3);
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint*>,std::__wrap_iter<PKPoint*>>((uint64_t)a2, (uint64_t)a2[1], __p + 8, v41, (v41 - (__p + 8)) >> 3);
      if (__p) {
        operator delete(__p);
      }
      if (v42)
      {
        unint64_t v43 = v42;
        operator delete(v42);
      }
      if (v45)
      {
        uint64_t v46 = v45;
        operator delete(v45);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>(a2, v5, v4, v7);
  }
}

void sub_213591A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v19 = *(void **)v17;
  if (*(void *)v17)
  {
    *(void *)(v17 + 8) = v19;
    operator delete(v19);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void PKPathCreateFromSimplifiedCGPath()
{
}

uint64_t PKSplitBracesAndComma(CFStringRef theString, CFStringRef *a2, CFStringRef *a3)
{
  CFIndex v19 = -1;
  if (!ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters) {
    ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, @"{[,]}");
  }
  CFIndex Length = CFStringGetLength(theString);
  if (Length >= 1)
  {
    CFIndex v6 = Length;
    uint64_t v7 = 0;
    CFIndex v8 = 0;
    int v9 = 0;
    float v10 = &v19;
    locatiouint64_t n = -1;
    CFIndex v12 = Length;
    while (1)
    {
      v21.locatiouint64_t n = v8;
      v21.length = v12;
      if (!CFStringFindCharacterFromSet(theString, (CFCharacterSetRef)ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters, v21, 0, &result))break; {
      if (result.location >= v6 || result.length != 1)
      }
        break;
      CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex(theString, result.location);
      if ((CharacterAtIndex & 0xFFFFFFDF) == 0x5B)
      {
        if (!v9) {
          locatiouint64_t n = result.location;
        }
        ++v9;
      }
      else if (CharacterAtIndex == 44)
      {
        if (v9 == 1)
        {
          if (v7 <= 0)
          {
            *v10++ = result.location;
            ++v7;
          }
          int v9 = 1;
        }
      }
      else if ((CharacterAtIndex & 0xFFFFFFDF) == 0x5D && !--v9)
      {
        uint64_t v15 = 0;
        if (location != -1)
        {
          CFIndex v16 = result.location;
          if (result.location != -1 && location < result.location)
          {
            uint64_t v15 = 0;
            CFIndex v17 = v19;
            if (v19 > location + 1 && v19 < result.location - 1)
            {
              v22.length = v19 + ~location;
              v22.locatiouint64_t n = location + 1;
              *a2 = CFStringCreateWithSubstring(0, theString, v22);
              v23.locatiouint64_t n = v17 + 1;
              v23.length = v16 + ~v17;
              *a3 = CFStringCreateWithSubstring(0, theString, v23);
              return 1;
            }
          }
        }
        return v15;
      }
      if (result.location + 1 < v6)
      {
        v12 += v8 + ~result.location;
        CFIndex v8 = result.location + 1;
        if (v12 > 0) {
          continue;
        }
      }
      return 0;
    }
  }
  return 0;
}

double PKCGPointFromString(void *a1)
{
  uint64_t v1 = a1;
  double DoubleValue = *MEMORY[0x263F00148];
  if ((unint64_t)[(__CFString *)v1 length] >= 5)
  {
    CFStringRef v6 = 0;
    CFStringRef str = 0;
    if (PKSplitBracesAndComma(v1, &str, &v6))
    {
      CFStringRef v3 = str;
      double DoubleValue = CFStringGetDoubleValue(str);
      CFStringRef v4 = v6;
      CFStringGetDoubleValue(v6);
      CFRelease(v3);
      CFRelease(v4);
    }
  }

  return DoubleValue;
}

void sub_213591E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_213591EBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_213591F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_21359200C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_2135920C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135921D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2135922F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CGPath *PKCGPathCreateFromArray(void *a1, int a2)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  id v51 = a1;
  if (v51)
  {
    float v3 = 1.0;
    if (a2) {
      float v3 = PKGet_PTM_RATIO();
    }
    Mutable = CGPathCreateMutable();
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    id v5 = v51;
    uint64_t v6 = [v5 countByEnumeratingWithState:&v52 objects:v56 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v53;
      double v8 = v3;
      do
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (*(void *)v53 != v7) {
            objc_enumerationMutation(v5);
          }
          float v10 = *(void **)(*((void *)&v52 + 1) + 8 * i);
          float v11 = [v10 objectForKey:@"type"];
          int v12 = [v11 intValue];

          float v13 = [v10 objectForKey:@"points"];
          double v14 = v13;
          switch(v12)
          {
            case 0:
              uint64_t v15 = [v13 objectAtIndex:0];
              [v15 CGPointValue];
              double v17 = v16;
              double v19 = v18;

              CGPathMoveToPoint(Mutable, 0, v17 * v8, v19 * v8);
              break;
            case 1:
              unint64_t v30 = [v13 objectAtIndex:0];
              [v30 CGPointValue];
              double v32 = v31;
              double v34 = v33;

              CGPathAddLineToPoint(Mutable, 0, v32 * v8, v34 * v8);
              break;
            case 2:
              float v20 = [v13 objectAtIndex:0];
              [v20 CGPointValue];
              double v22 = v21;
              double v24 = v23;

              uint64_t v25 = [v14 objectAtIndex:1];
              [v25 CGPointValue];
              double v27 = v26;
              double v29 = v28;

              CGPathAddQuadCurveToPoint(Mutable, 0, v22 * v8, v24 * v8, v27 * v8, v29 * v8);
              break;
            case 3:
              unint64_t v35 = [v13 objectAtIndex:0];
              [v35 CGPointValue];
              double v37 = v36;
              double v39 = v38;

              unint64_t v40 = [v14 objectAtIndex:1];
              [v40 CGPointValue];
              double v42 = v41;
              double v44 = v43;

              uint64_t v45 = [v14 objectAtIndex:2];
              [v45 CGPointValue];
              double v47 = v46;
              double v49 = v48;

              CGPathAddCurveToPoint(Mutable, 0, v37 * v8, v39 * v8, v42 * v8, v44 * v8, v47 * v8, v49 * v8);
              break;
            case 4:
              CGPathCloseSubpath(Mutable);
              break;
            default:
              break;
          }
        }
        uint64_t v6 = [v5 countByEnumeratingWithState:&v52 objects:v56 count:16];
      }
      while (v6);
    }
  }
  else
  {
    Mutable = 0;
  }

  return Mutable;
}

void sub_21359265C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id PKArrayFromPKPath(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = [MEMORY[0x263EFF980] array];
    float v3 = *(float **)(a1 + 8);
    CFStringRef v4 = *(float **)(a1 + 16);
    if (v3 != v4)
    {
      char v5 = 1;
      do
      {
        float v6 = *v3;
        float v7 = v3[1];
        double v8 = [MEMORY[0x263EFF9A0] dictionary];
        if (v5) {
          [NSNumber numberWithInt:0];
        }
        else {
        int v9 = [NSNumber numberWithInt:1];
        }
        [v8 setValue:v9 forKey:@"type"];

        float v10 = [MEMORY[0x263EFF980] array];
        float v11 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", v6, v7);
        [v10 addObject:v11];

        [v8 setValue:v10 forKey:@"points"];
        [v2 addObject:v8];

        char v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_2135928B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id PKArrayFromB2PolygonShape(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = [MEMORY[0x263EFF980] array];
    float v3 = *(float **)(a1 + 16);
    CFStringRef v4 = *(float **)(a1 + 24);
    if (v3 != v4)
    {
      char v5 = 1;
      do
      {
        float v6 = *v3;
        float v7 = v3[1];
        double v8 = [MEMORY[0x263EFF9A0] dictionary];
        if (v5) {
          [NSNumber numberWithInt:0];
        }
        else {
        int v9 = [NSNumber numberWithInt:1];
        }
        [v8 setValue:v9 forKey:@"type"];

        float v10 = [MEMORY[0x263EFF980] array];
        float v11 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", v6, v7);
        [v10 addObject:v11];

        [v8 setValue:v10 forKey:@"points"];
        [v2 addObject:v8];

        char v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_213592A6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id PKArrayFromB2ChainShape(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = [MEMORY[0x263EFF980] array];
    float v3 = *(float **)(a1 + 16);
    CFStringRef v4 = *(float **)(a1 + 24);
    if (v3 != v4)
    {
      char v5 = 1;
      do
      {
        float v6 = *v3;
        float v7 = v3[1];
        double v8 = [MEMORY[0x263EFF9A0] dictionary];
        if (v5) {
          [NSNumber numberWithInt:0];
        }
        else {
        int v9 = [NSNumber numberWithInt:1];
        }
        [v8 setValue:v9 forKey:@"type"];

        float v10 = [MEMORY[0x263EFF980] array];
        float v11 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", v6, v7);
        [v10 addObject:v11];

        [v8 setValue:v10 forKey:@"points"];
        [v2 addObject:v8];

        char v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_213592C28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const CGPath *PKArrayFromCGPath(const CGPath *a1, int a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    objc_msgSend(MEMORY[0x263EFF980], "array", 0);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    float v4 = 1.0;
    if (a2) {
      float v4 = PKGet_INV_PTM_RATIO();
    }
    float v7 = v4;
    CGPathApply(v2, &v6, (CGPathApplierFunction)PKArrayFromCGPathApply);
    uint64_t v2 = (const CGPath *)v6;
  }

  return v2;
}

void sub_213592D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void PKArrayFromCGPathApply(id *a1, const CGPathElement *a2)
{
  id v12 = *a1;
  float v3 = [MEMORY[0x263EFF9A0] dictionary];
  CGPathElementType type = a2->type;
  char v5 = [NSNumber numberWithInt:a2->type];
  [v3 setValue:v5 forKey:@"type"];

  points = a2->points;
  float v7 = [MEMORY[0x263EFF980] array];
  switch(type)
  {
    case kCGPathElementMoveToPoint:
    case kCGPathElementAddLineToPoint:
      int v9 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points->x, points->y);
      [v7 addObject:v9];
      goto LABEL_5;
    case kCGPathElementAddQuadCurveToPoint:
      double v8 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points->x, points->y);
      [v7 addObject:v8];

      int v9 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points[1].x, points[1].y);
      [v7 addObject:v9];
      goto LABEL_5;
    case kCGPathElementAddCurveToPoint:
      float v10 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points->x, points->y);
      [v7 addObject:v10];

      float v11 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points[1].x, points[1].y);
      [v7 addObject:v11];

      int v9 = objc_msgSend(MEMORY[0x263F08D40], "valueWithCGPoint:", points[2].x, points[2].y);
      [v7 addObject:v9];
LABEL_5:

      break;
    default:
      break;
  }
  [v3 setValue:v7 forKey:@"points"];
  [v12 addObject:v3];
}

void sub_213592F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  float v13 = v12;

  _Unwind_Resume(a1);
}

float32x2_t pointOnPath(uint64_t a1, float32x2_t result, float32_t a3, float a4)
{
  if (a4 > 1.0) {
    a4 = 1.0;
  }
  if (a4 < 0.0) {
    a4 = 0.0;
  }
  result.f32[1] = a3;
  switch(*(_DWORD *)a1)
  {
    case 0:
      if (a4 >= 1.0) {
        CFRange result = vcvt_f32_f64(*(float64x2_t *)*(void *)(a1 + 8));
      }
      break;
    case 1:
      CFRange result = vadd_f32(result, vmul_n_f32(vsub_f32(vcvt_f32_f64(*(float64x2_t *)*(void *)(a1 + 8)), result), a4));
      break;
    case 2:
      float v4 = *(float64x2_t **)(a1 + 8);
      float v5 = 1.0 - a4;
      float32x2_t v6 = vmul_n_f32(result, v5 * v5);
      float32x2_t v7 = vmul_n_f32(vcvt_f32_f64(*v4), a4 * (float)(v5 + v5));
      float32x2_t v8 = vmul_n_f32(vcvt_f32_f64(v4[1]), a4 * a4);
      float32x2_t v9 = vadd_f32(v6, v7);
      goto LABEL_10;
    case 3:
      float v10 = *(float64x2_t **)(a1 + 8);
      float v11 = (float)(1.0 - a4) * 3.0;
      float v12 = a4 * (float)((float)(1.0 - a4) * v11);
      float32x2_t v13 = vmul_n_f32(result, (float)(1.0 - a4) * (float)((float)(1.0 - a4) * (float)(1.0 - a4)));
      float32x2_t v14 = vmul_n_f32(vcvt_f32_f64(v10[1]), a4 * (float)(a4 * v11));
      float32x2_t v8 = vmul_n_f32(vcvt_f32_f64(v10[2]), a4 * (float)(a4 * a4));
      float32x2_t v9 = vadd_f32(vadd_f32(v13, vmul_n_f32(vcvt_f32_f64(*v10), v12)), v14);
LABEL_10:
      CFRange result = vadd_f32(v9, v8);
      break;
    default:
      return result;
  }
  return result;
}

char *std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  float v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  float32x2_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    float32x2_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      double v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v9, v17);
    }
    else {
      double v18 = 0;
    }
    double v28 = &v18[8 * v15];
    __p = v18;
    double v34 = v28;
    double v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    unint64_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)double v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    unint64_t v35 = v30;
    float v5 = std::vector<PKPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    double v21 = &__src[8 * a5];
    double v23 = *(char **)(v9 - 8);
LABEL_17:
    double v24 = &v5[8 * a5];
    uint64_t v25 = &v23[-8 * a5];
    double v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      double v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)double v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  double v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  double v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_2135932B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<PKPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  float v5 = *(char **)(a2 + 8);
  float32x2_t v6 = (char *)*a1;
  float32x2_t v7 = v5;
  if (*a1 != __src)
  {
    float32x2_t v8 = __src;
    float32x2_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    float32x2_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  float32x2_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char *std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint*>,std::__wrap_iter<PKPoint*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  float v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  float32x2_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    float32x2_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      double v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v9, v17);
    }
    else {
      double v18 = 0;
    }
    double v28 = &v18[8 * v15];
    __p = v18;
    double v34 = v28;
    double v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    unint64_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)double v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    unint64_t v35 = v30;
    float v5 = std::vector<PKPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    double v21 = &__src[8 * a5];
    double v23 = *(char **)(v9 - 8);
LABEL_17:
    double v24 = &v5[8 * a5];
    uint64_t v25 = &v23[-8 * a5];
    double v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      double v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)double v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  double v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  double v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_213593590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float gradrot2(char a1, float *a2, float *a3, float a4, float a5)
{
  float v5 = (float *)((char *)&grad2 + 8 * (a1 & 7));
  float v6 = *v5;
  float v7 = v5[1];
  *a2 = (float)(a5 * *v5) - (float)(v7 * a4);
  float result = (float)(v7 * a5) + (float)(a4 * v6);
  *a3 = result;
  return result;
}

float gradrot3(char a1, float *a2, float *a3, float *a4, float a5, float a6)
{
  float v6 = (float *)((char *)&grad3u + 12 * (a1 & 0xF));
  float v7 = v6[1];
  float v8 = v6[2];
  uint64_t v9 = (float *)((char *)&grad3v + 12 * (a1 & 0xF));
  float v10 = v9[1];
  float v11 = v9[2];
  *a2 = (float)(*v9 * a5) + (float)(a6 * *v6);
  *a3 = (float)(v10 * a5) + (float)(a6 * v7);
  float result = (float)(v11 * a5) + (float)(a6 * v8);
  *a4 = result;
  return result;
}

float graddotp2(float a1, float a2, float a3, float a4)
{
  return (float)(a2 * a4) + (float)(a1 * a3);
}

float graddotp3(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a5) + (float)(a1 * a4)) + (float)(a3 * a6);
}

float srdnoise2(float *a1, float *a2, float a3, float a4, float a5)
{
  __float2 v9 = __sincosf_stret(a5);

  return srdnoise2_sincos(a1, a2, a3, a4, v9.__sinval, v9.__cosval);
}

float srdnoise2_sincos(float *a1, float *a2, float a3, float a4, float a5, float a6)
{
  float v6 = (float)(a3 + a4) * 0.366025403;
  int v7 = (int)(float)(v6 + a3) - ((float)(v6 + a3) <= 0.0);
  int v8 = (int)(float)(v6 + a4) - ((float)(v6 + a4) <= 0.0);
  float v9 = (float)(v7 + v8) * 0.211324865;
  float v10 = (float)v8 - v9;
  float v11 = a3 - (float)((float)v7 - v9);
  float v12 = a4 - v10;
  float v13 = 0.0;
  float v14 = 1.0;
  if (v11 <= v12) {
    float v15 = 0.0;
  }
  else {
    float v15 = 1.0;
  }
  float v16 = (float)(v11 - v15) + 0.211324865;
  if (v11 > v12) {
    float v14 = 0.0;
  }
  float v17 = (float)(v12 - v14) + 0.211324865;
  int v18 = v7;
  int v19 = -v7;
  if (v19 >= 0) {
    int v20 = -v19;
  }
  else {
    int v20 = v18;
  }
  int v21 = v8;
  int v22 = -v8;
  if (v22 >= 0) {
    int v21 = -v22;
  }
  float v23 = (float)(0.5 - (float)(v11 * v11)) - (float)(v12 * v12);
  float v24 = 0.0;
  float v25 = 0.0;
  float v26 = 0.0;
  float v27 = 0.0;
  float v28 = 0.0;
  float v29 = 0.0;
  if (v23 >= 0.0)
  {
    unint64_t v30 = (float *)((char *)&grad2 + 8 * (perm_1[perm_1[v21] + (uint64_t)v20] & 7));
    float v31 = v30[1];
    float v24 = (float)(a6 * *v30) - (float)(v31 * a5);
    float v25 = (float)(v31 * a6) + (float)(a5 * *v30);
    float v27 = v23 * v23;
    float v28 = v27 * v27;
    float v29 = (float)(v27 * v27) * (float)((float)(v12 * v25) + (float)(v24 * v11));
    float v26 = (float)(0.5 - (float)(v11 * v11)) - (float)(v12 * v12);
  }
  float v32 = (float)(v11 + -1.0) + 0.42264973;
  float v33 = (float)(v12 + -1.0) + 0.42264973;
  float v34 = (float)(0.5 - (float)(v16 * v16)) - (float)(v17 * v17);
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
  float v39 = 0.0;
  if (v34 >= 0.0)
  {
    unint64_t v40 = (float *)((char *)&grad2
                  + 8 * (perm_1[perm_1[v21 + (unint64_t)(v11 <= v12)] + (uint64_t)(v20 + (v11 > v12))] & 7));
    float v41 = v40[1];
    float v13 = (float)(a6 * *v40) - (float)(v41 * a5);
    float v35 = (float)(v41 * a6) + (float)(a5 * *v40);
    float v37 = v34 * v34;
    float v38 = v37 * v37;
    float v39 = (float)(v37 * v37) * (float)((float)(v35 * v17) + (float)(v13 * v16));
    float v36 = (float)(0.5 - (float)(v16 * v16)) - (float)(v17 * v17);
  }
  float v42 = (float)(0.5 - (float)(v32 * v32)) - (float)(v33 * v33);
  float v43 = 0.0;
  float v44 = 0.0;
  float v45 = 0.0;
  float v46 = 0.0;
  float v47 = 0.0;
  float v48 = 0.0;
  if (v42 >= 0.0)
  {
    double v49 = (float *)((char *)&grad2 + 8 * (perm_1[perm_1[v21 + 1] + 1 + (uint64_t)v20] & 7));
    float v50 = v49[1];
    float v43 = (float)(a6 * *v49) - (float)(v50 * a5);
    float v44 = (float)(v50 * a6) + (float)(a5 * *v49);
    float v46 = v42 * v42;
    float v47 = v46 * v46;
    float v48 = (float)(v46 * v46) * (float)((float)(v44 * v33) + (float)(v43 * v32));
    float v45 = (float)(0.5 - (float)(v32 * v32)) - (float)(v33 * v33);
  }
  if (a1 && a2)
  {
    float v51 = (float)((float)(v12 * v25) + (float)(v24 * v11)) * (float)(v26 * v27);
    *a1 = v11 * v51;
    *a2 = v12 * v51;
    float v52 = (float)((float)(v35 * v17) + (float)(v13 * v16)) * (float)(v36 * v37);
    *a1 = *a1 + (float)(v52 * v16);
    *a2 = *a2 + (float)(v52 * v17);
    float v53 = (float)((float)(v44 * v33) + (float)(v43 * v32)) * (float)(v45 * v46);
    *a1 = *a1 + (float)(v53 * v32);
    *a2 = *a2 + (float)(v53 * v33);
    *a1 = *a1 * -8.0;
    *a2 = *a2 * -8.0;
    *a1 = (float)((float)((float)(v13 * v38) + (float)(v28 * v24)) + (float)(v47 * v43)) + *a1;
    *a2 = (float)((float)((float)(v35 * v38) + (float)(v28 * v25)) + (float)(v47 * v44)) + *a2;
    *a1 = *a1 * 40.0;
    *a2 = *a2 * 40.0;
  }
  return (float)((float)(v29 + v39) + v48) * 40.0;
}

float srdnoise3(float *a1, float *a2, float *a3, float a4, float a5, float a6, float a7)
{
  __float2 v13 = __sincosf_stret(a7);

  return srdnoise3_sincos(a1, a2, a3, a4, a5, a6, v13.__sinval, v13.__cosval);
}

float srdnoise3_sincos(float *a1, float *a2, float *a3, float a4, float a5, float a6, float a7, float a8)
{
  float v8 = (float)((float)(a4 + a5) + a6) * 0.33333;
  int v9 = (int)(float)(v8 + a4) - ((float)(v8 + a4) <= 0.0);
  int v10 = (int)(float)(v8 + a5) - ((float)(v8 + a5) <= 0.0);
  int v11 = (int)(float)(v8 + a6) - ((float)(v8 + a6) <= 0.0);
  float v12 = (float)(v9 + v10 + v11) * 0.16667;
  float v13 = (float)v10 - v12;
  float v14 = (float)v11 - v12;
  float v15 = a4 - (float)((float)v9 - v12);
  float v16 = a5 - v13;
  float v17 = a6 - v14;
  if (v15 >= v16)
  {
    int v19 = 0;
    if (v16 < v17)
    {
      int v22 = 0;
      BOOL v18 = v15 >= v17;
      BOOL v21 = v15 < v17;
      BOOL v20 = 1;
      goto LABEL_6;
    }
    BOOL v21 = 0;
    BOOL v23 = 0;
    BOOL v18 = 1;
    BOOL v20 = 1;
  }
  else
  {
    BOOL v18 = 0;
    if (v16 < v17)
    {
      int v19 = 0;
      BOOL v20 = 0;
      BOOL v21 = 1;
      int v22 = 1;
LABEL_6:
      BOOL v23 = 1;
      goto LABEL_10;
    }
    BOOL v21 = 0;
    BOOL v20 = v15 >= v17;
    BOOL v23 = v15 < v17;
    int v19 = 1;
  }
  int v22 = 1;
LABEL_10:
  float v24 = (float)(v15 - (float)v18) + 0.16667;
  float v25 = (float)(v16 - (float)v19) + 0.16667;
  float v26 = (float)(v17 - (float)v21) + 0.16667;
  int v28 = v9 + 512;
  BOOL v27 = -v28 < 0;
  int v28 = v28;
  if (!v27) {
    int v28 = --(char)v28;
  }
  int v29 = v10 + 512;
  BOOL v27 = -v29 < 0;
  int v29 = v29;
  if (!v27) {
    int v29 = --(char)v29;
  }
  int v30 = v11 + 512;
  if (v30 <= 0) {
    int v31 = --(char)v30;
  }
  else {
    int v31 = v30;
  }
  float v32 = (float)((float)(0.6 - (float)(v15 * v15)) - (float)(v16 * v16)) - (float)(v17 * v17);
  float v33 = 0.0;
  float v34 = 0.0;
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
  float v39 = 0.0;
  float v40 = 0.0;
  if (v32 >= 0.0)
  {
    float v41 = (float *)((char *)&grad3u + 12 * (perm_1[perm_1[perm_1[v31] + (uint64_t)v29] + (uint64_t)v28] & 0xF));
    float v42 = (float *)((char *)&grad3v + 12 * (perm_1[perm_1[perm_1[v31] + (uint64_t)v29] + (uint64_t)v28] & 0xF));
    float v34 = (float)(*v42 * a7) + (float)(a8 * *v41);
    float v35 = (float)(v42[1] * a7) + (float)(a8 * v41[1]);
    float v36 = (float)(v42[2] * a7) + (float)(a8 * v41[2]);
    float v38 = v32 * v32;
    float v39 = v38 * v38;
    float v40 = (float)(v38 * v38) * (float)((float)((float)(v16 * v35) + (float)(v34 * v15)) + (float)(v36 * v17));
    float v37 = (float)((float)(0.6 - (float)(v15 * v15)) - (float)(v16 * v16)) - (float)(v17 * v17);
  }
  float v86 = v37;
  float v87 = v38;
  float v89 = v34;
  float v90 = v35;
  float v91 = v36;
  float v96 = v40;
  float v43 = (float)(v15 - (float)v20) + 0.33333;
  float v44 = (float)(v16 - (float)v22) + 0.33333;
  float v45 = (float)(v17 - (float)v23) + 0.33333;
  float v46 = (float)((float)(0.6 - (float)(v24 * v24)) - (float)(v25 * v25)) - (float)(v26 * v26);
  float v47 = 0.0;
  float v48 = 0.0;
  float v49 = 0.0;
  float v50 = 0.0;
  float v51 = 0.0;
  float v52 = 0.0;
  if (v46 >= 0.0)
  {
    uint64_t v53 = 3 * (perm_1[perm_1[perm_1[v21 + (uint64_t)v31] + (uint64_t)(v19 + v29)] + (uint64_t)(v18 + v28)] & 0xF);
    long long v54 = (float *)((char *)&grad3u + 4 * v53);
    long long v55 = (float *)((char *)&grad3v + 4 * v53);
    float v33 = (float)(*v55 * a7) + (float)(a8 * *v54);
    float v47 = (float)(v55[1] * a7) + (float)(a8 * v54[1]);
    float v48 = (float)(v55[2] * a7) + (float)(a8 * v54[2]);
    float v50 = v46 * v46;
    float v51 = v50 * v50;
    float v52 = (float)(v50 * v50) * (float)((float)((float)(v25 * v47) + (float)(v33 * v24)) + (float)(v48 * v26));
    float v49 = (float)((float)(0.6 - (float)(v24 * v24)) - (float)(v25 * v25)) - (float)(v26 * v26);
  }
  float v94 = (float)(v15 - (float)v18) + 0.16667;
  float v95 = v52;
  float v88 = v33;
  float v92 = v25;
  float v93 = v26;
  float v56 = (float)(v15 + -1.0) + 0.5;
  float v57 = (float)(v16 + -1.0) + 0.5;
  float v58 = (float)(v17 + -1.0) + 0.5;
  float v59 = (float)((float)(0.6 - (float)(v43 * v43)) - (float)(v44 * v44)) - (float)(v45 * v45);
  float v60 = 0.0;
  float v61 = 0.0;
  float v62 = 0.0;
  float v63 = 0.0;
  float v64 = 0.0;
  float v65 = 0.0;
  float v66 = 0.0;
  float v67 = 0.0;
  if (v59 >= 0.0)
  {
    uint64_t v68 = 3 * (perm_1[perm_1[perm_1[v23 + (uint64_t)v31] + (uint64_t)(v22 + v29)] + (uint64_t)(v20 + v28)] & 0xF);
    uint64_t v69 = (float *)((char *)&grad3u + 4 * v68);
    uint64_t v70 = (float *)((char *)&grad3v + 4 * v68);
    float v61 = (float)(*v70 * a7) + (float)(a8 * *v69);
    float v62 = (float)(v70[1] * a7) + (float)(a8 * v69[1]);
    float v63 = (float)(v70[2] * a7) + (float)(a8 * v69[2]);
    float v65 = v59 * v59;
    float v66 = v65 * v65;
    float v67 = (float)(v65 * v65) * (float)((float)((float)(v44 * v62) + (float)(v61 * v43)) + (float)(v63 * v45));
    float v64 = (float)((float)(0.6 - (float)(v43 * v43)) - (float)(v44 * v44)) - (float)(v45 * v45);
  }
  float v71 = (float)((float)(0.6 - (float)(v56 * v56)) - (float)(v57 * v57)) - (float)(v58 * v58);
  float v72 = 0.0;
  float v73 = 0.0;
  float v74 = 0.0;
  float v75 = 0.0;
  float v76 = 0.0;
  float v77 = 0.0;
  if (v71 >= 0.0)
  {
    uint64_t v78 = 3 * (perm_1[perm_1[perm_1[v31 + 1] + 1 + (uint64_t)v29] + 1 + (uint64_t)v28] & 0xF);
    float v79 = (float *)((char *)&grad3u + 4 * v78);
    float v80 = (float *)((char *)&grad3v + 4 * v78);
    float v60 = (float)(*v80 * a7) + (float)(a8 * *v79);
    float v72 = (float)(v80[1] * a7) + (float)(a8 * v79[1]);
    float v73 = (float)(v80[2] * a7) + (float)(a8 * v79[2]);
    float v75 = v71 * v71;
    float v76 = v75 * v75;
    float v77 = (float)(v75 * v75) * (float)((float)((float)(v57 * v72) + (float)(v60 * v56)) + (float)(v73 * v58));
    float v74 = (float)((float)(0.6 - (float)(v56 * v56)) - (float)(v57 * v57)) - (float)(v58 * v58);
  }
  if (a1 && a2 && a3)
  {
    float v81 = (float)((float)((float)(v16 * v90) + (float)(v89 * v15)) + (float)(v91 * v17)) * (float)(v86 * v87);
    *a1 = v15 * v81;
    *a2 = v16 * v81;
    *a3 = v17 * v81;
    float v82 = (float)((float)((float)(v92 * v47) + (float)(v88 * v94)) + (float)(v48 * v93)) * (float)(v49 * v50);
    *a1 = *a1 + (float)(v82 * v94);
    *a2 = *a2 + (float)(v82 * v92);
    *a3 = *a3 + (float)(v82 * v93);
    float v83 = (float)((float)((float)(v44 * v62) + (float)(v61 * v43)) + (float)(v63 * v45)) * (float)(v64 * v65);
    *a1 = *a1 + (float)(v83 * v43);
    *a2 = *a2 + (float)(v83 * v44);
    *a3 = *a3 + (float)(v83 * v45);
    float v84 = (float)((float)((float)(v57 * v72) + (float)(v60 * v56)) + (float)(v73 * v58)) * (float)(v74 * v75);
    *a1 = *a1 + (float)(v84 * v56);
    *a2 = *a2 + (float)(v84 * v57);
    *a3 = *a3 + (float)(v84 * v58);
    *a1 = *a1 * -8.0;
    *a2 = *a2 * -8.0;
    *a3 = *a3 * -8.0;
    *a1 = (float)((float)((float)((float)(v88 * v51) + (float)(v39 * v89)) + (float)(v66 * v61)) + (float)(v76 * v60))
        + *a1;
    *a2 = (float)((float)((float)((float)(v47 * v51) + (float)(v39 * v90)) + (float)(v66 * v62)) + (float)(v76 * v72))
        + *a2;
    *a3 = (float)((float)((float)((float)(v48 * v51) + (float)(v39 * v91)) + (float)(v66 * v63)) + (float)(v76 * v73))
        + *a3;
    *a1 = *a1 * 28.0;
    *a2 = *a2 * 28.0;
    *a3 = *a3 * 28.0;
  }
  return (float)((float)((float)(v96 + v95) + v67) + v77) * 28.0;
}

float srdnoise3_sincos_vector(float32x4_t *a1, float32x4_t a2, float a3, float a4)
{
  int8x16_t v4 = (int8x16_t)vmulq_f32(a2, (float32x4_t)xmmword_21359BB00);
  *(float32x2_t *)v4.i8 = vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL));
  float32x4_t v5 = vrndmq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v4.i8, 1)), 0), a2));
  int8x16_t v6 = (int8x16_t)vmulq_f32(v5, (float32x4_t)xmmword_21359BB10);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  float32x4_t v7 = vsubq_f32(a2, vsubq_f32(v5, (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1)), 0)));
  float32x4_t v8 = v7;
  v8.i32[3] = 0;
  __asm { FMOV            V5.4S, #1.0 }
  float32x4_t v14 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v8, (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v8, (int32x4_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL)), (int32x4_t)v8)), _Q5, (int8x16_t)0);
  float32x4_t v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v8, (float32x4_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 4uLL), (int32x4_t)v8)), _Q5, (int8x16_t)0);
  if (v7.f32[2] <= v7.f32[0]) {
    float v16 = 0.0;
  }
  else {
    float v16 = 1.0;
  }
  v14.f32[2] = v16;
  if (v7.f32[0] < v7.f32[2]) {
    float v17 = 0.0;
  }
  else {
    float v17 = 1.0;
  }
  v15.f32[0] = v17;
  float32x4_t v18 = vminnmq_f32(v14, v15);
  float32x4_t v19 = vmaxnmq_f32(v14, v15);
  float32x4_t v22 = vaddq_f32(vsubq_f32(v7, v18), (float32x4_t)vdupq_n_s32(0x3E2AAAABu));
  float32x4_t v23 = vaddq_f32(vsubq_f32(v7, v19), (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  __asm { FMOV            V18.4S, #-1.0 }
  float32x4_t v21 = vaddq_f32(v7, _Q18);
  _Q18.i64[0] = 0x3F0000003F000000;
  _Q18.i64[1] = 0x3F0000003F000000;
  float32x4_t v24 = vaddq_f32(v21, _Q18);
  v22.i32[3] = 0;
  v23.i32[3] = 0;
  v24.i32[3] = 0;
  int16x4_t v25 = vmovn_s32(vcvtq_s32_f32(v5));
  float v26 = &perm_1[v25.u8[4]];
  uint64_t v27 = perm_1[perm_1[*v26 + (unint64_t)v25.u8[2]] + (unint64_t)v25.u8[0]] & 0xF;
  uint64_t v28 = perm_1[perm_1[perm_1[(int)v18.f32[2] + (unint64_t)v25.u8[4]] + (uint64_t)((int)v18.f32[1] + v25.u8[2])]
             + (uint64_t)((int)v18.f32[0] + v25.u8[0])] & 0xF;
  uint64_t v29 = perm_1[perm_1[perm_1[(int)v19.f32[2] + (unint64_t)v25.u8[4]] + (uint64_t)((int)v19.f32[1] + v25.u8[2])]
             + (uint64_t)((int)v19.f32[0] + v25.u8[0])] & 0xF;
  uint64_t v30 = perm_1[v25.u8[0]
             + 1
             + (unint64_t)perm_1[v25.u8[2] + 1 + (unint64_t)v26[1]]] & 0xF;
  float32x4_t v31 = vmulq_f32(v8, v8);
  *(float32x2_t *)v31.f32 = vadd_f32(*(float32x2_t *)v31.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL));
  int8x16_t v32 = (int8x16_t)vmulq_f32(v22, v22);
  *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  int8x16_t v33 = (int8x16_t)vmulq_f32(v23, v23);
  *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  int8x16_t v34 = (int8x16_t)vmulq_f32(v24, v24);
  *(int32x2_t *)v35.f32 = vzip1_s32(*(int32x2_t *)v31.f32, *(int32x2_t *)v32.i8);
  v35.i32[2] = v33.i32[0];
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  v35.i32[3] = v34.i32[0];
  *(int32x2_t *)v31.f32 = vzip2_s32(*(int32x2_t *)v31.f32, *(int32x2_t *)v32.i8);
  v31.i64[1] = __PAIR64__(v34.u32[1], vdup_lane_s32(*(int32x2_t *)v33.i8, 1).u32[0]);
  float32x4_t v36 = vaddq_f32(v35, v31);
  float32x4_t v37 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v27], a3), grad3u_vector[v27], a4);
  int8x16_t v38 = (int8x16_t)vmulq_f32(v8, v37);
  int32x2_t v39 = (int32x2_t)vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
  float32x4_t v40 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v28], a3), grad3u_vector[v28], a4);
  int8x16_t v41 = (int8x16_t)vmulq_f32(v22, v40);
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
  float32x4_t v42 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v29], a3), grad3u_vector[v29], a4);
  int8x16_t v43 = (int8x16_t)vmulq_f32(v23, v42);
  *(float32x2_t *)v43.i8 = vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
  float32x4_t v44 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v30], a3), grad3u_vector[v30], a4);
  int8x16_t v45 = (int8x16_t)vmulq_f32(v24, v44);
  *(float32x2_t *)v45.i8 = vadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL));
  *(int32x2_t *)v46.f32 = vzip1_s32(v39, *(int32x2_t *)v35.f32);
  v46.i64[1] = __PAIR64__(v45.u32[0], v43.u32[0]);
  *(int32x2_t *)v35.f32 = vzip2_s32(v39, *(int32x2_t *)v35.f32);
  v35.i64[1] = __PAIR64__(v45.u32[1], vdup_lane_s32(*(int32x2_t *)v43.i8, 1).u32[0]);
  float32x4_t v47 = vaddq_f32(v46, v35);
  float32x4_t v48 = vmaxnmq_f32(vsubq_f32((float32x4_t)vdupq_n_s32(0x3F19999Au), v36), (float32x4_t)0);
  float32x4_t v49 = vmulq_f32(v48, v48);
  float32x4_t v50 = vmulq_f32(v49, v49);
  __asm { FMOV            V18.4S, #28.0 }
  if (a1)
  {
    float32x4_t v52 = vmulq_f32(vmulq_f32(v48, v49), v47);
    float32x4_t v53 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v22, *(float32x2_t *)v52.f32, 1), v8, v52.f32[0]), v23, v52, 2), v24, v52, 3);
    v54.i64[0] = 0xC1000000C1000000;
    v54.i64[1] = 0xC1000000C1000000;
    *a1 = vmulq_f32(vaddq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v40, *(float32x2_t *)v50.f32, 1), v37, v50.f32[0]), v42, v50, 2), v44, v50, 3), vmulq_f32(v53, v54)), _Q18);
  }
  int8x16_t v55 = (int8x16_t)vmulq_f32(vmulq_f32(v50, v47), _Q18);
  return vaddv_f32(vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)));
}

float PKGet_PTM_RATIO()
{
  return *(float *)&_PK_PTM_RATIO;
}

float PKGet_INV_PTM_RATIO()
{
  return *(float *)&_PK_PKGet_INV_PTM_RATIO;
}

float PKSet_PTM_Ratio(float a1)
{
  _PK_PTM_RATIO = LODWORD(a1);
  float result = 1.0 / a1;
  _PK_PKGet_INV_PTM_RATIO = LODWORD(result);
  return result;
}

float32_t PKPhysicsReapplyScaleOnFixture(b2FixtureDef *a1, b2Fixture *a2, float a3, float a4)
{
  int8x16_t v4 = (float32x2_t *)*((void *)a2 + 4);
  float v5 = a3 * a4;
  switch(v4[1].i32[0])
  {
    case 0:
      v4[2] = vmul_f32(vabs_f32((float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3))), *(float32x2_t *)((char *)a1->var0 + 16));
      break;
    case 1:
      float var0 = a1->var0;
      if (*((unsigned char *)a1->var0 + 48)) {
        v4[4] = vmul_f32(*(float32x2_t *)((char *)var0 + 32), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      }
      *(float32x4_t *)v4[2].f32 = vmulq_f32(*((float32x4_t *)var0 + 1), (float32x4_t)vdupq_lane_s64(__SPAIR64__(LODWORD(a4), LODWORD(a3)), 0));
      if (*((unsigned char *)var0 + 49)) {
        void v4[5] = vmul_f32(*(float32x2_t *)((char *)var0 + 40), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      }
      break;
    case 2:
      float32x4_t v7 = a1->var0;
      uint64_t v8 = *((void *)a1->var0 + 2);
      uint64_t v9 = *((void *)a1->var0 + 3) - v8;
      unint64_t v10 = (unint64_t)v9 >> 3;
      int v11 = (float32x2_t *)*((void *)a2 + 4);
      if (v5 >= 0.0)
      {
        if ((int)v10 >= 1)
        {
          uint64_t v35 = 0;
          do
          {
            *(float32x2_t *)(*(void *)&v4[2] + v35) = vmul_f32(*(float32x2_t *)(*((void *)v7 + 2) + v35), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
            *(void *)(*(void *)&v4[5] + v35) = *(void *)(*((void *)v7 + 5) + v35);
            v35 += 8;
          }
          while ((v9 & 0x7FFFFFFF8) != v35);
          int v11 = (float32x2_t *)*((void *)a2 + 4);
        }
      }
      else if ((int)v10 >= 1)
      {
        float v12 = (float32x2_t *)v4[2];
        uint64_t v13 = ((unint64_t)v9 >> 3);
        uint64_t v14 = (v10 << 32) - 0x100000000;
        uint64_t v15 = v13;
        do
        {
          *v12++ = vmul_f32(*(float32x2_t *)(v8 + (v14 >> 29)), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
          v14 -= 0x100000000;
          --v15;
        }
        while (v15);
        uint64_t v16 = 0;
        float32x2_t v17 = v4[2];
        uint64_t v18 = (int)(v9 >> 3);
        float32x4_t v19 = (float *)(*(void *)&v17 + 4);
        uint64_t v20 = 4;
        do
        {
          uint64_t v21 = v16 + 1;
          if (v16 + 1 < v18) {
            uint64_t v22 = v16 + 1;
          }
          else {
            uint64_t v22 = 0;
          }
          float32x4_t v23 = (float *)(*(void *)&v17 + 8 * v22);
          float v24 = *v23 - *(v19 - 1);
          v25.f32[0] = v23[1] - *v19;
          if ((float)((float)(v25.f32[0] * v25.f32[0]) + (float)(v24 * v24)) >= 1.4211e-14)
          {
            float v26 = -v24;
            uint64_t v27 = (float *)(*(void *)&v4[5] + v20);
            *(v27 - 1) = v25.f32[0];
            *uint64_t v27 = -v24;
            float v28 = sqrtf((float)(v24 * v24) + (float)(v25.f32[0] * v25.f32[0]));
            if (v28 >= 0.00000011921)
            {
              v25.f32[1] = v26;
              *(float32x2_t *)(v27 - 1) = vmul_n_f32(v25, 1.0 / v28);
            }
          }
          else
          {
            *(void *)(*(void *)&v4[5] + 8 * v16) = 0x3F80000000000000;
          }
          v19 += 2;
          v20 += 8;
          uint64_t v16 = v21;
        }
        while (v13 != v21);
        int v11 = v4;
      }
      v4[8] = vmul_f32(*(float32x2_t *)((char *)v7 + 64), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      int8x16_t v4 = v11;
      break;
    case 3:
      uint64_t v29 = (float32x2_t *)*((void *)a1->var0 + 2);
      unint64_t v30 = *((void *)a1->var0 + 3) - (void)v29;
      unint64_t v31 = v30 >> 3;
      if (v5 >= 0.0)
      {
        if ((int)v31 >= 1)
        {
          float32x4_t v36 = (float32x2_t *)v4[2];
          uint64_t v37 = (v30 >> 3);
          do
          {
            float32x2_t v38 = *v29++;
            *v36++ = vmul_f32(v38, (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
            --v37;
          }
          while (v37);
        }
      }
      else if ((int)v31 >= 1)
      {
        int8x16_t v32 = (float32x2_t *)v4[2];
        uint64_t v33 = (v30 >> 3);
        uint64_t v34 = (v31 << 32) - 0x100000000;
        do
        {
          *v32++ = vmul_f32(*(float32x2_t *)((char *)v29 + (v34 >> 29)), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
          v34 -= 0x100000000;
          --v33;
        }
        while (v33);
      }
      break;
    default:
      break;
  }
  float v39 = *((float *)a1->var0 + 3);
  float32_t result = (float)(v39 * hypotf(a3, a4)) / 1.4142;
  v4[1].f32[1] = result;
  return result;
}

void b2ChainShape::GetVertex()
{
  __assert_rtn("GetVertex", "b2ChainShape.h", 94, "0 <= index && index < GetVertexCount()");
}

void b2CollideEdgeAndCircle()
{
}

void b2CollidePolygons()
{
  __assert_rtn("b2FindIncidentEdge", "b2CollidePolygon.cpp", 151, "0 <= edge1 && edge1 < poly1->GetVertexCount()");
}

void b2EdgeSeparation()
{
  __assert_rtn("b2EdgeSeparation", "b2CollidePolygon.cpp", 32, "0 <= edge1 && edge1 < poly1->GetVertexCount()");
}

void b2DistanceProxy::Set()
{
}

{
  __assert_rtn("Set", "b2Distance.cpp", 53, "0 <= index && index < chain->GetVertexCount()");
}

void b2Distance()
{
}

{
  __assert_rtn("GetVertex", "b2Distance.h", 104, "0 <= index && index < GetVertexCount()");
}

void b2Simplex::ReadCache()
{
  __assert_rtn("ReadCache", "b2Distance.cpp", 111, "cache->count <= 3");
}

void b2Simplex::GetClosestPoint()
{
}

{
  __assert_rtn("GetClosestPoint", "b2Distance.cpp", 204, "false");
}

void b2Simplex::GetSearchDirection()
{
}

void b2Simplex::GetWitnessPoints()
{
}

{
  __assert_rtn("GetWitnessPoints", "b2Distance.cpp", 227, "false");
}

void b2Simplex::GetMetric()
{
}

{
  __assert_rtn("GetMetric", "b2Distance.cpp", 256, "false");
}

void b2DynamicTree::AllocateNode()
{
  __assert_rtn("AllocateNode", "b2DynamicTree.cpp", 62, "m_nodeCount == m_nodeCapacity");
}

void b2DynamicTree::FreeNode()
{
}

{
  __assert_rtn("FreeNode", "b2DynamicTree.cpp", 99, "0 <= nodeId && nodeId < m_nodeCapacity");
}

void b2DynamicTree::InsertLeaf()
{
  __assert_rtn("InsertLeaf", "b2DynamicTree.cpp", 311, "child1 != (-1)");
}

{
  __assert_rtn("InsertLeaf", "b2DynamicTree.cpp", 312, "child2 != (-1)");
}

void b2DynamicTree::DestroyProxy()
{
}

{
  __assert_rtn("DestroyProxy", "b2DynamicTree.cpp", 129, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2DynamicTree::MoveProxy()
{
}

{
  __assert_rtn("MoveProxy", "b2DynamicTree.cpp", 138, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2DynamicTree::Balance()
{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 386, "iA != (-1)");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 411, "0 <= iF && iF < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 412, "0 <= iG && iG < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 428, "m_nodes[C->parent].child2 == iA");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 471, "0 <= iD && iD < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 472, "0 <= iE && iE < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 488, "m_nodes[B->parent].child2 == iA");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 397, "0 <= iC && iC < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 396, "0 <= iB && iB < m_nodeCapacity");
}

void b2DynamicTree::ComputeHeight()
{
  __assert_rtn("ComputeHeight", "b2DynamicTree.cpp", 567, "0 <= nodeId && nodeId < m_nodeCapacity");
}

void b2DynamicTree::ValidateStructure()
{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 607, "node->height == 0");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 606, "child2 == (-1)");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 612, "0 <= child2 && child2 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 615, "m_nodes[child2].parent == index");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 614, "m_nodes[child1].parent == index");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 611, "0 <= child1 && child1 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 595, "m_nodes[index].parent == (-1)");
}

void b2DynamicTree::ValidateMetrics()
{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 637, "node->height == 0");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 636, "child2 == (-1)");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 642, "0 <= child2 && child2 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 654, "aabb.upperBound == node->aabb.upperBound");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 653, "aabb.lowerBound == node->aabb.lowerBound");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 648, "node->height == height");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 641, "0 <= child1 && child1 < m_nodeCapacity");
}

void b2DynamicTree::Validate()
{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 676, "m_nodeCount + freeCount == m_nodeCapacity");
}

{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 674, "GetHeight() == ComputeHeight()");
}

{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 669, "0 <= freeIndex && freeIndex < m_nodeCapacity");
}

void b2DynamicTree::GetMaxBalance()
{
  __assert_rtn("GetMaxBalance", "b2DynamicTree.cpp", 690, "node->IsLeaf() == false");
}

void b2TimeOfImpact()
{
}

void b2SeparationFunction::Initialize()
{
}

void b2SeparationFunction::FindMinSeparation()
{
}

void b2SeparationFunction::Evaluate()
{
}

void b2ChainShape::CreateChain()
{
  __assert_rtn("CreateChain", "b2ChainShape.cpp", 45, "count >= 2");
}

void b2ChainShape::GetChildEdge()
{
  __assert_rtn("GetChildEdge", "b2ChainShape.cpp", 85, "0 <= index && index < GetVertexCount() - 1");
}

void b2ChainShape::RayCast()
{
}

void b2ChainShape::ComputeAABB()
{
}

void b2PolygonShape::RayCast()
{
  __assert_rtn("RayCast", "b2PolygonShape.cpp", 349, "0.0f <= lower && lower <= input.maxFraction");
}

void b2PolygonShape::ComputeMass()
{
  __assert_rtn("ComputeMass", "b2PolygonShape.cpp", 406, "GetVertexCount() >= 3");
}

void MechanicsCollisionCallback::ReportFixture()
{
  __assert_rtn("GetAABB", "b2Fixture.h", 295, "0 <= childIndex && childIndex < m_proxies.size()");
}

void b2StackAllocator::Allocate()
{
}

void b2StackAllocator::Free()
{
}

{
  __assert_rtn("Free", "b2StackAllocator.cpp", 65, "p == entry->data");
}

void b2Body::b2Body()
{
}

{
  __assert_rtn("b2Body", "b2Body.mm", 57, "bd->linearVelocity.IsValid()");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 58, "b2IsValid(bd->angle)");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 59, "b2IsValid(bd->angularVelocity)");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 60, "b2IsValid(bd->angularDamping) && bd->angularDamping >= 0.0f");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 61, "b2IsValid(bd->linearDamping) && bd->linearDamping >= 0.0f");
}

void b2Body::SetType()
{
  __assert_rtn("SetType", "b2Body.mm", 169, "m_world->IsLocked() == false");
}

void b2Body::CreateFixture()
{
  __assert_rtn("CreateFixture", "b2Body.mm", 221, "m_world->IsLocked() == false");
}

void b2Body::DestroyFixture()
{
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 290, "found");
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 271, "fixture->m_body == this");
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 265, "m_world->IsLocked() == false");
}

void b2Body::SetMassData()
{
}

{
  __assert_rtn("SetMassData", "b2Body.mm", 397, "m_world->IsLocked() == false");
}

void b2Body::SetTransform()
{
  __assert_rtn("SetTransform", "b2Body.mm", 561, "m_world->IsLocked() == false");
}

void b2Body::SetActive()
{
  __assert_rtn("SetActive", "b2Body.mm", 602, "m_world->IsLocked() == false");
}

void b2ContactManager::QueryCallback()
{
  __assert_rtn("GetCollisionBits", "b2DynamicTree.h", 177, "0 <= proxyId && proxyId < m_nodeCapacity");
}

{
  __assert_rtn("GetCategoryBits", "b2DynamicTree.h", 173, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2ContactManager::FindMinimumTOI()
{
}

void b2ContactManager::FindNewContacts()
{
  __assert_rtn("GetFixtureProxy", "b2DynamicTree.h", 162, "0 <= proxyId && proxyId < m_nodeCapacity");
}

{
  __assert_rtn("GetFatAABB", "b2DynamicTree.h", 168, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2Island::b2Island(void **a1, void **a2, uint64_t a3)
{
  float v5 = *a1;
  if (v5)
  {
    *(void *)(a3 + 48) = v5;
    operator delete(v5);
  }
  int8x16_t v6 = *a2;
  if (*a2)
  {
    *(void *)(a3 + 24) = v6;
    operator delete(v6);
  }
}

void b2Island::SolveTOI()
{
}

{
  __assert_rtn("SolveTOI", "b2Island.mm", 404, "toiIndexA < bodyCount");
}

void b2World::CreateBody()
{
  __assert_rtn("CreateBody", "b2World.mm", 186, "IsLocked() == false");
}

void b2World::DestroyBody()
{
}

{
  __assert_rtn("DestroyBody", "b2World.mm", 210, "IsLocked() == false");
}

void b2World::DestroyJoint()
{
}

{
  __assert_rtn("DestroyJoint", "b2World.mm", 326, "IsLocked() == false");
}

void b2World::CreateJoint()
{
  __assert_rtn("CreateJoint", "b2World.mm", 287, "IsLocked() == false");
}

void b2DynamicTree::RayCast<b2WorldRayCastWrapper>()
{
}

void b2ChainAndCircleContact::b2ChainAndCircleContact()
{
  __assert_rtn("b2ChainAndCircleContact", "b2ChainAndCircleContact.cpp", 40, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2ChainAndCircleContact", "b2ChainAndCircleContact.cpp", 39, "m_fixtureA->GetType() == b2Shape::e_chain");
}

void b2ChainAndPolygonContact::b2ChainAndPolygonContact()
{
  __assert_rtn("b2ChainAndPolygonContact", "b2ChainAndPolygonContact.cpp", 40, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2ChainAndPolygonContact", "b2ChainAndPolygonContact.cpp", 39, "m_fixtureA->GetType() == b2Shape::e_chain");
}

void b2CircleContact::b2CircleContact()
{
  __assert_rtn("b2CircleContact", "b2CircleContact.cpp", 41, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2CircleContact", "b2CircleContact.cpp", 40, "m_fixtureA->GetType() == b2Shape::e_circle");
}

void b2Contact::AddType()
{
  __assert_rtn("AddType", "b2Contact.cpp", 63, "0 <= type1 && type1 < b2Shape::e_typeCount");
}

{
  __assert_rtn("AddType", "b2Contact.cpp", 64, "0 <= type2 && type2 < b2Shape::e_typeCount");
}

void b2Contact::Create()
{
  __assert_rtn("Create", "b2Contact.cpp", 87, "0 <= type1 && type1 < b2Shape::e_typeCount");
}

{
  __assert_rtn("Create", "b2Contact.cpp", 88, "0 <= type2 && type2 < b2Shape::e_typeCount");
}

void b2Contact::Destroy()
{
  __assert_rtn("Destroy", "b2Contact.cpp", 116, "s_initialized == true");
}

void b2ContactSolver::b2ContactSolver()
{
}

void b2ContactSolver::InitializeVelocityConstraints()
{
}

void b2ContactSolver::SolveVelocityConstraints()
{
  __assert_rtn("SolveVelocityConstraints", "b2ContactSolver.cpp", 436, "a.x >= 0.0f && a.y >= 0.0f");
}

void b2PositionSolverManifold::Initialize()
{
}

void b2EdgeAndCircleContact::b2EdgeAndCircleContact()
{
  __assert_rtn("b2EdgeAndCircleContact", "b2EdgeAndCircleContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2EdgeAndCircleContact", "b2EdgeAndCircleContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_edge");
}

void b2EdgeAndPolygonContact::b2EdgeAndPolygonContact()
{
  __assert_rtn("b2EdgeAndPolygonContact", "b2EdgeAndPolygonContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2EdgeAndPolygonContact", "b2EdgeAndPolygonContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_edge");
}

void b2PolygonAndCircleContact::b2PolygonAndCircleContact()
{
  __assert_rtn("b2PolygonAndCircleContact", "b2PolygonAndCircleContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2PolygonAndCircleContact", "b2PolygonAndCircleContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_polygon");
}

void b2PolygonContact::b2PolygonContact()
{
  __assert_rtn("b2PolygonContact", "b2PolygonContact.cpp", 42, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2PolygonContact", "b2PolygonContact.cpp", 41, "m_fixtureA->GetType() == b2Shape::e_polygon");
}

void b2FrictionJoint::SetMaxForce()
{
  __assert_rtn("SetMaxForce", "b2FrictionJoint.cpp", 217, "b2IsValid(force) && force >= 0.0f");
}

void b2FrictionJoint::SetMaxTorque()
{
  __assert_rtn("SetMaxTorque", "b2FrictionJoint.cpp", 228, "b2IsValid(torque) && torque >= 0.0f");
}

void b2GearJoint::b2GearJoint()
{
  __assert_rtn("b2GearJoint", "b2GearJoint.cpp", 51, "m_typeB == e_revoluteJoint || m_typeB == e_prismaticJoint");
}

{
  __assert_rtn("b2GearJoint", "b2GearJoint.cpp", 50, "m_typeA == e_revoluteJoint || m_typeA == e_prismaticJoint");
}

void b2GearJoint::SetRatio()
{
}

void b2QuadtreeAndChainContact::b2QuadtreeAndChainContact()
{
  __assert_rtn("b2QuadtreeAndChainContact", "b2QuadtreeAndOtherContact.cpp", 26, "m_fixtureB->GetType() == b2Shape::e_chain");
}

{
  __assert_rtn("b2QuadtreeAndChainContact", "b2QuadtreeAndOtherContact.cpp", 25, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact()
{
  __assert_rtn("b2QuadtreeAndCircleContact", "b2QuadtreeAndOtherContact.cpp", 48, "m_fixtureB->GetType() == b2Shape::e_quadtree");
}

{
  __assert_rtn("b2QuadtreeAndCircleContact", "b2QuadtreeAndOtherContact.cpp", 47, "m_fixtureA->GetType() == b2Shape::e_circle");
}

void b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact()
{
  __assert_rtn("b2QuadtreeAndEdgeContact", "b2QuadtreeAndOtherContact.cpp", 117, "m_fixtureB->GetType() == b2Shape::e_edge");
}

{
  __assert_rtn("b2QuadtreeAndEdgeContact", "b2QuadtreeAndOtherContact.cpp", 116, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact()
{
  __assert_rtn("b2QuadtreeAndPolygonContact", "b2QuadtreeAndOtherContact.cpp", 140, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2QuadtreeAndPolygonContact", "b2QuadtreeAndOtherContact.cpp", 139, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact()
{
  __assert_rtn("b2QuadtreeAndQuadtreeContact", "b2QuadtreeAndOtherContact.cpp", 164, "m_fixtureB->GetType() == b2Shape::e_quadtree");
}

{
  __assert_rtn("b2QuadtreeAndQuadtreeContact", "b2QuadtreeAndOtherContact.cpp", 163, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2Joint::Create()
{
}

void b2Joint::b2Joint()
{
  __assert_rtn("b2Joint", "b2Joint.cpp", 116, "def->bodyA != def->bodyB");
}

void b2MouseJoint::b2MouseJoint()
{
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 35, "b2IsValid(def->maxForce) && def->maxForce >= 0.0f");
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 36, "b2IsValid(def->frequencyHz) && def->frequencyHz >= 0.0f");
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 37, "b2IsValid(def->dampingRatio) && def->dampingRatio >= 0.0f");
}

void b2MouseJoint::InitVelocityConstraints()
{
}

void b2PrismaticJoint::SetLimits()
{
  __assert_rtn("SetLimits", "b2PrismaticJoint.cpp", 562, "lower <= upper");
}

void b2PulleyJointDef::Initialize()
{
}

void b2PulleyJoint::b2PulleyJoint()
{
  __assert_rtn("b2PulleyJoint", "b2PulleyJoint.cpp", 62, "def->ratio != 0.0f");
}

void b2RevoluteJoint::SetLimits()
{
  __assert_rtn("SetLimits", "b2RevoluteJoint.cpp", 485, "lower <= upper");
}

void b2Rope::Initialize()
{
  __assert_rtn("Initialize", "b2Rope.cpp", 48, "def->count >= 3");
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x270EE4748](alloc, theString);
}

void CFRelease(CFTypeRef cf)
{
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x270EE5110](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x270EE5128](alloc, str, range.location, range.length);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x270EE5158](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x270EE5190](theString, idx);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x270EE51A8](str);
  return result;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x270EE59A8](retstr, sx, sy);
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x270EE6FD0](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x270EE6FD8](path);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x270EE7008](path, transform);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x270EE7030]();
}

CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x270EE7050](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x270EE7058](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGPathEqualToPath(CGPathRef path1, CGPathRef path2)
{
  return MEMORY[0x270EE7068](path1, path2);
}

uint64_t CGPathIsEllipse()
{
  return MEMORY[0x270EE70B8]();
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
}

void CGPathRelease(CGPathRef path)
{
}

CGFloat CGRectGetMidX(CGRect rect)
{
  MEMORY[0x270EE71D8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  MEMORY[0x270EE71F0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x270EE7260]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x270EE7268]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x270EE7270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

NSZone *NSDefaultMallocZone(void)
{
  return (NSZone *)MEMORY[0x270EF2A70]();
}

void NSLog(NSString *format, ...)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x270F989E8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_free_exception(void *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__float cosval = v2;
  result.__sinval = v1;
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x270ED86A8](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x270ED9698]();
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

void free(void *a1)
{
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

float hypotf(float a1, float a2)
{
  MEMORY[0x270ED9E60](a1, a2);
  return result;
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int putchar(int a1)
{
  return MEMORY[0x270EDB090](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}