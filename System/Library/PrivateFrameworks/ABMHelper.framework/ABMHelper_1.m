void sub_1A6112A58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::ifstream::~ifstream((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::ifstream::basic_ifstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA460] + 64;
  a1[53] = MEMORY[0x1E4FBA460] + 64;
  v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x1E4FBA460] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x1A6274EA0](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1A6112C04(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1A62751A0](v1);
  _Unwind_Resume(a1);
}

BOOL support::fs::getFileSize(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2)
  {
    std::istream::tellg();
    std::istream::seekg();
    std::istream::tellg();
    *a2 = v5;
    std::istream::seekg();
  }
  return v2 != 0;
}

{
  uint64_t v2;
  BOOL v4;
  uint64_t v6[90];

  v6[89] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned __int8 *)(a1 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a1 + 8);
  }
  if (!v2) {
    return 0;
  }
  memset(v6, 170, 0x240uLL);
  std::ifstream::basic_ifstream(v6);
  uint64_t v4 = v6[17] != 0;
  if (v6[17])
  {
    std::istream::tellg();
    std::istream::seekg();
    std::istream::tellg();
    *a2 = v6[88];
    std::istream::seekg();
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)((char *)v6 + *(void *)(v6[0] - 24)), *(_DWORD *)((char *)&v6[4] + *(void *)(v6[0] - 24)) | 4);
    }
  }
  v6[0] = *MEMORY[0x1E4FBA3F8];
  *(uint64_t *)((char *)v6 + *(void *)(v6[0] - 24)) = *(void *)(MEMORY[0x1E4FBA3F8] + 24);
  MEMORY[0x1A6274EB0](&v6[2]);
  std::istream::~istream();
  MEMORY[0x1A62751A0](&v6[53]);
  return v4;
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1A6274EB0](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1A62751A0](a1 + 53);
  return a1;
}

uint64_t support::fs::loadFile(const char *a1, uint64_t a2)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  uint64_t v3 = fopen(a1, "rb");
  if (v3)
  {
    uint64_t v4 = v3;
    fseek(v3, 0, 2);
    unint64_t v5 = MEMORY[0x1A6275830](v4);
    if (v5 != -1)
    {
      size_t v6 = v5;
      v8 = *(char **)a2;
      uint64_t v7 = *(char **)(a2 + 8);
      unint64_t v9 = (unint64_t)&v7[-*(void *)a2];
      size_t v10 = v5 - v9;
      if (v5 <= v9)
      {
        if (v5 < v9) {
          *(void *)(a2 + 8) = &v8[v5];
        }
        goto LABEL_36;
      }
      uint64_t v11 = *(void *)(a2 + 16);
      if (v11 - (uint64_t)v7 >= v10)
      {
        bzero(*(void **)(a2 + 8), v10);
        *(void *)(a2 + 8) = &v7[v10];
LABEL_36:
        rewind(v4);
        v30 = *(char **)a2;
        uint64_t v19 = 1;
        fread(v30, v6, 1uLL, v4);
        fclose(v4);
        return v19;
      }
      if ((v5 & 0x8000000000000000) != 0) {
        std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v12 = v11 - (void)v8;
      uint64_t v13 = 2 * v12;
      if (2 * v12 <= v5) {
        uint64_t v13 = v5;
      }
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v14 = v13;
      }
      v15 = (char *)operator new(v14);
      v16 = &v15[v9];
      v17 = &v15[v14];
      bzero(&v15[v9], v10);
      if (v7 == v8)
      {
LABEL_34:
        *(void *)a2 = v16;
        *(void *)(a2 + 8) = &v15[v6];
        *(void *)(a2 + 16) = v17;
        if (v7) {
          operator delete(v7);
        }
        goto LABEL_36;
      }
      if (v9 >= 8 && (unint64_t)(v8 - v15) >= 0x20)
      {
        if (v9 < 0x20)
        {
          unint64_t v18 = 0;
          goto LABEL_26;
        }
        unint64_t v18 = v9 & 0xFFFFFFFFFFFFFFE0;
        v20 = v7 - 16;
        v21 = &v15[v7 - 16 - v8];
        unint64_t v22 = v9 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v23 = *(_OWORD *)v20;
          *((_OWORD *)v21 - 1) = *((_OWORD *)v20 - 1);
          *(_OWORD *)v21 = v23;
          v21 -= 32;
          v20 -= 32;
          v22 -= 32;
        }
        while (v22);
        if (v9 == v18) {
          goto LABEL_33;
        }
        if ((v9 & 0x18) != 0)
        {
LABEL_26:
          v16 -= v9 & 0xFFFFFFFFFFFFFFF8;
          v24 = &v7[-v18 - 8];
          v25 = (char *)(v24 - v8);
          unint64_t v26 = v18 - (v9 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            uint64_t v27 = *(void *)v24;
            v24 -= 8;
            *(void *)&v25[(void)v15] = v27;
            v25 -= 8;
            v26 += 8;
          }
          while (v26);
          v7 -= v9 & 0xFFFFFFFFFFFFFFF8;
          if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_33;
          }
          goto LABEL_31;
        }
        v16 -= v18;
        v7 -= v18;
      }
LABEL_31:
      v28 = v16 - 1;
      do
      {
        char v29 = *--v7;
        *v28-- = v29;
      }
      while (v7 != v8);
LABEL_33:
      uint64_t v7 = v8;
      v16 = v15;
      goto LABEL_34;
    }
  }
  return 0;
}

BOOL support::fs::fileExists(const char *a1)
{
  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v1.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v3.st_blksize = v1;
  *(timespec *)v3.st_qspare = v1;
  v3.st_birthtimespec = v1;
  *(timespec *)&v3.st_size = v1;
  v3.st_mtimespec = v1;
  v3.st_ctimespec = v1;
  *(timespec *)&v3.st_uid = v1;
  v3.st_atimespec = v1;
  *(timespec *)&v3.st_dev = v1;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  return stat(a1, &v3) == 0;
}

void support::fs::createUniqueFilename(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v25.__loop_count_ = v4;
  *(_OWORD *)&v25.__start_.__cntrl_ = v4;
  *(_OWORD *)&v25.__traits_.__loc_.__locale_ = v4;
  *(_OWORD *)&v25.__traits_.__col_ = v4;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v25, "^([/_\\-[:alnum:]]*)(.*)", 0);
  memset(&v24, 170, sizeof(v24));
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string v24 = *(std::string *)a1;
  }
  for (unsigned int i = 1; ; ++i)
  {
    v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v26.st_blksize = v6;
    *(timespec *)v26.st_qspare = v6;
    v26.st_birthtimespec = v6;
    *(timespec *)&v26.st_size = v6;
    v26.st_mtimespec = v6;
    v26.st_ctimespec = v6;
    *(timespec *)&v26.st_uid = v6;
    v26.st_atimespec = v6;
    *(timespec *)&v26.st_dev = v6;
    if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v7 = &v24;
    }
    else {
      uint64_t v7 = (std::string *)v24.__r_.__value_.__r.__words[0];
    }
    if (stat((const char *)v7, &v26))
    {
      *(std::string *)a2 = v24;
      goto LABEL_42;
    }
    uint64_t v8 = *(unsigned __int8 *)(a1 + 23);
    if ((v8 & 0x80u) == 0) {
      unint64_t v9 = (std::sub_match<const char *> *)a1;
    }
    else {
      unint64_t v9 = *(std::sub_match<const char *> **)a1;
    }
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *(void *)(a1 + 8);
    }
    size_t v10 = (std::sub_match<std::__wrap_iter<const char *>> *)((char *)v9 + v8);
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v33 = v11;
    unint64_t v30 = 0xAAAAAAAAAAAAAA00;
    v27[1].__end_cap_.__value_ = (std::sub_match<std::__wrap_iter<const char *>> *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    LOBYTE(v33) = 0;
    BYTE8(v33) = 0;
    uint64_t v34 = 0;
    memset(v27, 0, 41);
    *(_OWORD *)&v26.st_birthtimespec.tv_nsec = v11;
    v26.st_ctimespec.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v26.st_atimespec.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    memset(&v26.st_mtimespec, 0, 17);
    memset(&v26.st_ctimespec.tv_nsec, 0, 17);
    LOBYTE(v26.st_size) = 0;
    v26.st_blocks = 0;
    memset(&v26, 0, 41);
    int v12 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&v25, v9, (std::sub_match<const char *> *)((char *)v9 + v8), (std::vector<std::csub_match> *)&v26, 4160);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(v27, (uint64_t)v9, v10, (uint64_t *)&v26.st_dev, 0);
    if (*(void *)&v26.st_dev)
    {
      v26.st_ino = *(void *)&v26.st_dev;
      operator delete(*(void **)&v26.st_dev);
    }
    if ((_BYTE)v33) {
      int v13 = v12 ^ 1;
    }
    else {
      int v13 = 1;
    }
    if (v27[0].__begin_)
    {
      v27[0].__end_ = v27[0].__begin_;
      operator delete(v27[0].__begin_);
    }
    if ((v12 & v13) == 0) {
      break;
    }
    memset(&v26, 170, 24);
    std::to_string(&v23, i);
    size_t v14 = std::string::insert(&v23, 0, "$1-", 3uLL);
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v27[0].__end_cap_.__value_ = (std::sub_match<std::__wrap_iter<const char *>> *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27[0].__begin_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    v16 = std::string::append((std::string *)v27, "$2", 2uLL);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    *(void *)&v26.st_uid = *((void *)&v16->__r_.__value_.__l + 2);
    *(_OWORD *)&v26.st_dev = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v27[0].__end_cap_.__value_) < 0)
    {
      operator delete(v27[0].__begin_);
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_26;
      }
    }
    else if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_26;
    }
    operator delete(v23.__r_.__value_.__l.__data_);
LABEL_26:
    memset(v27, 0, 24);
    uint64_t v18 = *(unsigned __int8 *)(a1 + 23);
    if ((v18 & 0x80u) == 0) {
      v19.__i_ = (std::__wrap_iter<const char *>::iterator_type)a1;
    }
    else {
      v19.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)a1;
    }
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a1 + 8);
    }
    if ((v26.st_gid & 0x80000000) == 0) {
      v21 = (char *)&v26;
    }
    else {
      v21 = *(char **)&v26.st_dev;
    }
    v20.__i_ = &v19.__i_[v18];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>((std::string *)v27, v19, v20, &v25, v21, 0);
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v24.__r_.__value_.__l.__data_);
      std::string v24 = (std::string)v27[0];
      if ((SHIBYTE(v26.st_gid) & 0x80000000) == 0) {
        continue;
      }
    }
    else
    {
      std::string v24 = (std::string)v27[0];
      if ((SHIBYTE(v26.st_gid) & 0x80000000) == 0) {
        continue;
      }
    }
    operator delete(*(void **)&v26.st_dev);
  }
  *(unsigned char *)(a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
LABEL_42:
  cntrl = v25.__start_.__cntrl_;
  if (v25.__start_.__cntrl_ && !atomic_fetch_add(&v25.__start_.__cntrl_->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
    std::__shared_weak_count::__release_weak(cntrl);
  }
  std::locale::~locale(&v25.__traits_.__loc_);
}

void sub_1A6113414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::locale a19)
{
}

void sub_1A6113428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::locale a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (*(char *)(v38 - 185) < 0) {
    operator delete(*(void **)(v38 - 208));
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a25);
  _Unwind_Resume(a1);
}

void support::fs::createUniquePath(const char *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v2 = a1;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__src.st_blksize = v4;
  *(timespec *)__src.st_qspare = v4;
  __src.st_birthtimespec = v4;
  *(timespec *)&__src.st_size = v4;
  __src.st_mtimespec = v4;
  __src.st_ctimespec = v4;
  *(timespec *)&__src.st_uid = v4;
  __src.st_atimespec = v4;
  *(timespec *)&__src.st_dev = v4;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (!stat(a1, &__src))
  {
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    timespec v27 = v5;
    timespec v28 = v5;
    timespec v25 = v5;
    timespec v26 = v5;
    timespec v23 = v5;
    timespec v24 = v5;
    *(timespec *)__src.st_qspare = v5;
    timespec v22 = v5;
    *(timespec *)&__src.st_size = v5;
    *(timespec *)&__src.st_blksize = v5;
    __src.st_ctimespec = v5;
    __src.st_birthtimespec = v5;
    __src.st_atimespec = v5;
    __src.st_mtimespec = v5;
    *(timespec *)&__src.st_dev = v5;
    *(timespec *)&__src.st_uid = v5;
    snprintf((char *)&__src, 0x100uLL, "-%u", 1);
    memset(a2, 170, sizeof(std::string));
    size_t v6 = strlen((const char *)&__src);
    if (v6 > 0x7FFFFFFFFFFFFFF7) {
LABEL_32:
    }
      std::string::__throw_length_error[abi:ne180100]();
    __darwin_ino64_t v7 = v6;
    int v8 = 2;
    while (v7 < 0x17)
    {
      HIBYTE(__dst.st_gid) = v7;
      p_dst = &__dst;
      if (v7) {
        goto LABEL_15;
      }
LABEL_16:
      *((unsigned char *)&p_dst->st_dev + v7) = 0;
      int v13 = v2[23];
      if (v13 >= 0) {
        size_t v14 = v2;
      }
      else {
        size_t v14 = *(const std::string::value_type **)v2;
      }
      if (v13 >= 0) {
        std::string::size_type v15 = *((unsigned __int8 *)v2 + 23);
      }
      else {
        std::string::size_type v15 = *((void *)v2 + 1);
      }
      v16 = std::string::insert((std::string *)&__dst, 0, v14, v15);
      long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      a2->__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__dst.st_gid) < 0) {
        operator delete(*(void **)&__dst.st_dev);
      }
      v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&__dst.st_blksize = v18;
      *(timespec *)__dst.st_qspare = v18;
      __dst.st_birthtimespec = v18;
      *(timespec *)&__dst.st_size = v18;
      __dst.st_mtimespec = v18;
      __dst.st_ctimespec = v18;
      *(timespec *)&__dst.st_uid = v18;
      __dst.st_atimespec = v18;
      *(timespec *)&__dst.st_dev = v18;
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::__wrap_iter<const char *> v19 = (const char *)a2;
      }
      else {
        std::__wrap_iter<const char *> v19 = (const char *)a2->__r_.__value_.__r.__words[0];
      }
      if (stat(v19, &__dst)) {
        return;
      }
      if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0) {
        operator delete(a2->__r_.__value_.__l.__data_);
      }
      v9.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v9.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      timespec v27 = v9;
      timespec v28 = v9;
      timespec v25 = v9;
      timespec v26 = v9;
      timespec v23 = v9;
      timespec v24 = v9;
      *(timespec *)__src.st_qspare = v9;
      timespec v22 = v9;
      *(timespec *)&__src.st_size = v9;
      *(timespec *)&__src.st_blksize = v9;
      __src.st_ctimespec = v9;
      __src.st_birthtimespec = v9;
      __src.st_atimespec = v9;
      __src.st_mtimespec = v9;
      *(timespec *)&__src.st_dev = v9;
      *(timespec *)&__src.st_uid = v9;
      snprintf((char *)&__src, 0x100uLL, "-%u", v8);
      memset(a2, 170, sizeof(std::string));
      __darwin_ino64_t v7 = strlen((const char *)&__src);
      ++v8;
      if (v7 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_32;
      }
    }
    uint64_t v11 = (v7 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v11 = v7 | 7;
    }
    uint64_t v12 = v11 + 1;
    p_dst = (stat *)operator new(v11 + 1);
    __dst.st_ino = v7;
    *(void *)&__dst.st_uid = v12 | 0x8000000000000000;
    *(void *)&__dst.st_dev = p_dst;
LABEL_15:
    memcpy(p_dst, &__src, v7);
    goto LABEL_16;
  }
  if (v2[23] < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v2, *((void *)v2 + 1));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v2;
    a2->__r_.__value_.__r.__words[2] = *((void *)v2 + 2);
  }
}

void sub_1A6113768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL support::fs::createDir(const char *a1, mode_t a2, int a3)
{
  timespec v5 = a1;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v29.st_blksize = v6;
  *(timespec *)v29.st_qspare = v6;
  v29.st_birthtimespec = v6;
  *(timespec *)&v29.st_size = v6;
  v29.st_mtimespec = v6;
  v29.st_ctimespec = v6;
  *(timespec *)&v29.st_uid = v6;
  v29.st_atimespec = v6;
  *(timespec *)&v29.st_dev = v6;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (!stat(a1, &v29)) {
    return 1;
  }
  if (!a3)
  {
    if (v5[23] >= 0) {
      v21 = v5;
    }
    else {
      v21 = *(const char **)v5;
    }
    return mkdir(v21, a2) == 0;
  }
  v27[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v28 = 0x1AAAAAAAAAAAAAALL;
  v27[0] = (void *)0xAAAAAAAAAAAA002FLL;
  memset(&__p[32], 170, 24);
  ctu::tokenize();
  memset(__p, 0, 24);
  if (v5[23] >= 0) {
    __darwin_ino64_t v7 = v5;
  }
  else {
    __darwin_ino64_t v7 = *(const char **)v5;
  }
  if (*v7 == 47)
  {
    *(_OWORD *)__p = *(_OWORD *)v27;
    *(void *)&__p[16] = v28;
  }
  uint64_t v8 = *(void *)&__p[32];
  if (*(void *)&__p[40] != *(void *)&__p[32])
  {
    unint64_t v9 = 0;
    unsigned int v10 = 1;
    while (1)
    {
      if (v10 != 1)
      {
        if (v28 >= 0) {
          uint64_t v11 = v27;
        }
        else {
          uint64_t v11 = (void **)v27[0];
        }
        if (v28 >= 0) {
          std::string::size_type v12 = HIBYTE(v28);
        }
        else {
          std::string::size_type v12 = (std::string::size_type)v27[1];
        }
        std::string::append((std::string *)__p, (const std::string::value_type *)v11, v12);
        uint64_t v8 = *(void *)&__p[32];
      }
      uint64_t v13 = v8 + 24 * v9;
      int v14 = *(char *)(v13 + 23);
      std::string::size_type v15 = v14 >= 0 ? (const std::string::value_type *)v13 : *(const std::string::value_type **)v13;
      std::string::size_type v16 = v14 >= 0 ? *(unsigned __int8 *)(v13 + 23) : *(void *)(v13 + 8);
      std::string::append((std::string *)__p, v15, v16);
      v17.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v17.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v29.st_blksize = v17;
      *(timespec *)v29.st_qspare = v17;
      v29.st_birthtimespec = v17;
      *(timespec *)&v29.st_size = v17;
      v29.st_mtimespec = v17;
      v29.st_ctimespec = v17;
      *(timespec *)&v29.st_uid = v17;
      v29.st_atimespec = v17;
      *(timespec *)&v29.st_dev = v17;
      timespec v18 = __p[23] >= 0 ? __p : *(const char **)__p;
      if (stat(v18, &v29))
      {
        std::__wrap_iter<const char *> v19 = __p[23] >= 0 ? __p : *(const char **)__p;
        if (mkdir(v19, a2)) {
          break;
        }
      }
      unint64_t v9 = v10;
      uint64_t v8 = *(void *)&__p[32];
      ++v10;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__p[40] - *(void *)&__p[32]) >> 3) <= v9) {
        goto LABEL_42;
      }
    }
    uint64_t v20 = 0;
    if ((__p[23] & 0x80000000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
LABEL_42:
  uint64_t v20 = 1;
  if ((__p[23] & 0x80000000) != 0) {
LABEL_43:
  }
    operator delete(*(void **)__p);
LABEL_44:
  uint64_t v22 = *(void *)&__p[32];
  if (*(void *)&__p[32])
  {
    uint64_t v23 = *(void *)&__p[40];
    timespec v24 = *(void **)&__p[32];
    if (*(void *)&__p[40] != *(void *)&__p[32])
    {
      do
      {
        if (*(char *)(v23 - 1) < 0) {
          operator delete(*(void **)(v23 - 24));
        }
        v23 -= 24;
      }
      while (v23 != v22);
      timespec v24 = *(void **)&__p[32];
    }
    *(void *)&__p[40] = v22;
    operator delete(v24);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  return v20;
}

void sub_1A6113A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    if ((a24 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    if ((a24 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  operator delete(a19);
  _Unwind_Resume(a1);
}

BOOL support::fs::rename(const std::__fs::filesystem::path *a1, const std::__fs::filesystem::path *a2, std::error_code *a3)
{
  if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    a1 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
  }
  if ((a2->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    a2 = (const std::__fs::filesystem::path *)a2->__pn_.__r_.__value_.__r.__words[0];
  }
  rename(a1, a2, a3);
  return v3 == 0;
}

BOOL support::fs::chmod(const char *a1, mode_t a2)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  return chmod(a1, a2) == 0;
}

uint64_t support::fs::removeDir(const char *a1)
{
  timespec v1 = (const std::__fs::filesystem::path *)a1;
  v46[2] = *MEMORY[0x1E4F143B8];
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__dst.st_blkstd::string::size_type size = v2;
  *(timespec *)__dst.st_qspare = v2;
  __dst.st_birthtimespec = v2;
  *(timespec *)&__dst.st_std::string::size_type size = v2;
  __dst.st_mtimespec = v2;
  __dst.st_ctimespec = v2;
  *(timespec *)&__dst.st_uid = v2;
  __dst.st_atimespec = v2;
  *(timespec *)&__dst.st_dev = v2;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (stat(a1, &__dst)) {
    return 1;
  }
  v42 = 0;
  v43 = 0;
  uint64_t v44 = 0;
  support::fs::readDir((const char *)v1, (uint64_t)&v42);
  unsigned int v5 = 0;
  while (1)
  {
    unsigned int v6 = v5;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (unsigned char *)v42) >> 3);
    BOOL v3 = v7 <= v5;
    if (v7 <= v5) {
      break;
    }
    uint64_t v8 = (char *)v42 + 24 * v5;
    memset(&__p, 170, sizeof(__p));
    if (v8[23] < 0)
    {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v9 = *(_OWORD *)v8;
      __p.__r_.__value_.__r.__words[2] = *((void *)v8 + 2);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v9;
    }
    int v10 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (size == 2)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      if (LOWORD(p_p->__r_.__value_.__l.__data_) == 11822)
      {
LABEL_58:
        char v30 = 1;
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_6;
      }
    }
    else if (size == 1)
    {
      std::string::size_type v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v12 = &__p;
      }
      if (v12->__r_.__value_.__s.__data_[0] == 46) {
        goto LABEL_58;
      }
    }
    int v14 = SHIBYTE(v1->__pn_.__r_.__value_.__r.__words[2]);
    if (v14 >= 0) {
      size_t v15 = HIBYTE(v1->__pn_.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t v15 = v1->__pn_.__r_.__value_.__l.__size_;
    }
    unint64_t v16 = v15 + 1;
    memset(&__dst, 170, 24);
    if (v15 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v16 >= 0x17)
    {
      uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v18 = v16 | 7;
      }
      uint64_t v19 = v18 + 1;
      p_dst = (char *)operator new(v18 + 1);
      __dst.st_ino = v15 + 1;
      *(void *)&__dst.st_uid = v19 | 0x8000000000000000;
      *(void *)&__dst.st_dev = p_dst;
    }
    else
    {
      memset(&__dst, 0, 24);
      p_dst = (char *)&__dst;
      HIBYTE(__dst.st_gid) = v15 + 1;
      if (!v15) {
        goto LABEL_38;
      }
    }
    if (v14 >= 0) {
      uint64_t v20 = v1;
    }
    else {
      uint64_t v20 = (const std::__fs::filesystem::path *)v1->__pn_.__r_.__value_.__r.__words[0];
    }
    memmove(p_dst, v20, v15);
LABEL_38:
    *(_WORD *)&p_dst[v15] = 47;
    if (v10 >= 0) {
      v21 = &__p;
    }
    else {
      v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    uint64_t v22 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v21, size);
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[0];
    v46[0] = v22->__r_.__value_.__l.__size_;
    *(void *)((char *)v46 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
    char v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    __p.__r_.__value_.__r.__words[0] = v23;
    __p.__r_.__value_.__l.__size_ = v46[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v46 + 7);
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v24;
    if (SHIBYTE(__dst.st_gid) < 0)
    {
      operator delete(*(void **)&__dst.st_dev);
      char v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      std::string::size_type v23 = __p.__r_.__value_.__r.__words[0];
    }
    v25.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v25.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&__dst.st_blkstd::string::size_type size = v25;
    *(timespec *)__dst.st_qspare = v25;
    __dst.st_birthtimespec = v25;
    *(timespec *)&__dst.st_std::string::size_type size = v25;
    __dst.st_mtimespec = v25;
    __dst.st_ctimespec = v25;
    *(timespec *)&__dst.st_uid = v25;
    __dst.st_atimespec = v25;
    if (v24 >= 0) {
      timespec v26 = &__p;
    }
    else {
      timespec v26 = (std::string *)v23;
    }
    *(timespec *)&__dst.st_dev = v25;
    if (!stat((const char *)v26, &__dst)
      && ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (uint64_t v31 = &__p)
        : (uint64_t v31 = (std::string *)__p.__r_.__value_.__r.__words[0]),
          (uint64_t v32 = opendir((const char *)v31), (v33 = v32) != 0) && (v34 = readdir(v32), closedir(v33), v34)))
    {
      std::string::append(&__p, "/", 1uLL);
      char v30 = support::fs::removeDir(&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
    }
    else
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v28 = (const std::__fs::filesystem::path *)&__p;
      }
      else {
        uint64_t v28 = (const std::__fs::filesystem::path *)__p.__r_.__value_.__r.__words[0];
      }
      if (!remove(v28, v27)) {
        goto LABEL_58;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        stat v29 = &__p;
      }
      else {
        stat v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      char v30 = unlink((const char *)v29) == 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
    }
LABEL_6:
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_7:
    unsigned int v5 = v6 + 1;
    if ((v30 & 1) == 0) {
      goto LABEL_75;
    }
  }
  if ((v1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v35 = v1;
  }
  else {
    v35 = (const std::__fs::filesystem::path *)v1->__pn_.__r_.__value_.__r.__words[0];
  }
  if (remove(v35, v4))
  {
    if ((v1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v36 = (const char *)v1;
    }
    else {
      v36 = (const char *)v1->__pn_.__r_.__value_.__r.__words[0];
    }
    unlink(v36);
  }
LABEL_75:
  v37 = (void **)v42;
  if (v42)
  {
    uint64_t v38 = v43;
    v39 = v42;
    if (v43 != v42)
    {
      do
      {
        if (*((char *)v38 - 1) < 0) {
          operator delete(*(v38 - 3));
        }
        v38 -= 3;
      }
      while (v38 != v37);
      v39 = v42;
    }
    v43 = v37;
    operator delete(v39);
  }
  return v3;
}

void sub_1A6113F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_1A6113F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((a16 & 0x80000000) == 0)
  {
    std::vector<std::string>::~vector[abi:ne180100](&a17);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::vector<std::string>::~vector[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

BOOL support::fs::removeFile(const std::__fs::filesystem::path *a1, std::error_code *a2)
{
  timespec v2 = a1;
  if ((a1->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    a1 = (const std::__fs::filesystem::path *)a1->__pn_.__r_.__value_.__r.__words[0];
  }
  if (!remove(a1, a2)) {
    return 1;
  }
  if ((v2->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v3 = (const char *)v2;
  }
  else {
    BOOL v3 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  }
  return unlink(v3) == 0;
}

uint64_t support::fs::removeDirContents(const char *a1, unint64_t a2)
{
  BOOL v3 = a1;
  v62 = 0;
  v63 = 0;
  uint64_t v64 = 0;
  support::fs::readDir(a1, (uint64_t)&v62);
  time_t v56 = time(0);
  unsigned int v5 = (void **)v62;
  timespec v4 = v63;
  if (v62 == v63)
  {
    char v52 = 1;
    if (v62) {
      goto LABEL_105;
    }
    return v52 & 1;
  }
  double v6 = (double)a2;
  char v57 = 1;
  while (1)
  {
    memset(&v61, 170, sizeof(v61));
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v61, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }
    else
    {
      long long v7 = *(_OWORD *)v5;
      v61.__r_.__value_.__r.__words[2] = (std::string::size_type)v5[2];
      *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v7;
    }
    int v8 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
    std::string::size_type v9 = (v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? HIBYTE(v61.__r_.__value_.__r.__words[2])
       : v61.__r_.__value_.__l.__size_;
    if (v9 == 2) {
      break;
    }
    if (v9 == 1)
    {
      int v10 = (std::string *)v61.__r_.__value_.__r.__words[0];
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v10 = &v61;
      }
      if (v10->__r_.__value_.__s.__data_[0] == 46) {
        goto LABEL_95;
      }
    }
LABEL_19:
    memset(__p, 170, 24);
    int v12 = v3[23];
    if (v12 >= 0) {
      size_t v13 = *((unsigned __int8 *)v3 + 23);
    }
    else {
      size_t v13 = *((void *)v3 + 1);
    }
    unint64_t v14 = v13 + 1;
    memset(&__dst, 170, 24);
    if (v13 + 1 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v14 >= 0x17)
    {
      int v58 = SHIBYTE(v61.__r_.__value_.__r.__words[2]);
      std::string::size_type v16 = v9;
      timespec v17 = v5;
      uint64_t v18 = v4;
      uint64_t v19 = v3;
      unint64_t v20 = a2;
      uint64_t v21 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v21 = v14 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_dst = (stat *)operator new(v21 + 1);
      __dst.st_ino = v13 + 1;
      *(void *)&__dst.st_uid = v22 | 0x8000000000000000;
      *(void *)&__dst.st_dev = p_dst;
      a2 = v20;
      BOOL v3 = v19;
      timespec v4 = v18;
      unsigned int v5 = v17;
      std::string::size_type v9 = v16;
      int v8 = v58;
    }
    else
    {
      memset(&__dst, 0, 24);
      p_dst = &__dst;
      HIBYTE(__dst.st_gid) = v13 + 1;
      if (!v13) {
        goto LABEL_33;
      }
    }
    if (v12 >= 0) {
      std::string::size_type v23 = v3;
    }
    else {
      std::string::size_type v23 = *(const char **)v3;
    }
    memmove(p_dst, v23, v13);
LABEL_33:
    *(_WORD *)((char *)&p_dst->st_dev + v13) = 47;
    if (v8 >= 0) {
      char v24 = &v61;
    }
    else {
      char v24 = (std::string *)v61.__r_.__value_.__r.__words[0];
    }
    timespec v25 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v24, v9);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    __p[2] = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.st_gid) < 0)
    {
      operator delete(*(void **)&__dst.st_dev);
      if (!a2) {
        goto LABEL_47;
      }
    }
    else if (!a2)
    {
      goto LABEL_47;
    }
    v27.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v27.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&__dst.st_blkstd::string::size_type size = v27;
    *(timespec *)__dst.st_qspare = v27;
    __dst.st_birthtimespec = v27;
    *(timespec *)&__dst.st_std::string::size_type size = v27;
    __dst.st_mtimespec = v27;
    __dst.st_ctimespec = v27;
    __dst.st_atimespec = v27;
    *(timespec *)&__dst.st_dev = v27;
    *(timespec *)&__dst.st_uid = v27;
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v28 = __p;
    }
    else {
      uint64_t v28 = (void **)__p[0];
    }
    if (!stat((const char *)v28, &__dst) && difftime(v56, __dst.st_ctimespec.tv_sec) >= v6)
    {
LABEL_47:
      v31.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v31.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&__dst.st_blkstd::string::size_type size = v31;
      *(timespec *)__dst.st_qspare = v31;
      __dst.st_birthtimespec = v31;
      *(timespec *)&__dst.st_std::string::size_type size = v31;
      __dst.st_mtimespec = v31;
      __dst.st_ctimespec = v31;
      __dst.st_atimespec = v31;
      *(timespec *)&__dst.st_dev = v31;
      *(timespec *)&__dst.st_uid = v31;
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v32 = __p;
      }
      else {
        uint64_t v32 = (void **)__p[0];
      }
      if (stat((const char *)v32, &__dst)
        || (SHIBYTE(__p[2]) >= 0 ? (v36 = __p) : (v36 = (void **)__p[0]),
            (v37 = opendir((const char *)v36), (uint64_t v38 = v37) == 0) || (v39 = readdir(v37), closedir(v38), !v39)))
      {
        if (SHIBYTE(__p[2]) >= 0) {
          uint64_t v34 = (const std::__fs::filesystem::path *)__p;
        }
        else {
          uint64_t v34 = (const std::__fs::filesystem::path *)__p[0];
        }
        if (!remove(v34, v33)
          || (SHIBYTE(__p[2]) >= 0 ? (v35 = __p) : (v35 = (void **)__p[0]), !unlink((const char *)v35)))
        {
LABEL_89:
          int v30 = 0;
          char v57 = 1;
          char v29 = 1;
          if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
            goto LABEL_91;
          }
          goto LABEL_90;
        }
        goto LABEL_59;
      }
      int v40 = v3[23];
      if (v40 >= 0) {
        size_t v41 = *((unsigned __int8 *)v3 + 23);
      }
      else {
        size_t v41 = *((void *)v3 + 1);
      }
      unint64_t v42 = v41 + 1;
      memset(&v59, 170, sizeof(v59));
      if (v41 + 1 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v42 >= 0x17)
      {
        uint64_t v44 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v42 | 7) != 0x17) {
          uint64_t v44 = v42 | 7;
        }
        uint64_t v45 = v44 + 1;
        v43 = (char *)operator new(v44 + 1);
        v59.__r_.__value_.__l.__size_ = v41 + 1;
        v59.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
      }
      else
      {
        memset(&v59, 0, sizeof(v59));
        v43 = (char *)&v59;
        *((unsigned char *)&v59.__r_.__value_.__s + 23) = v41 + 1;
        if (!v41) {
          goto LABEL_80;
        }
      }
      if (v40 >= 0) {
        v46 = v3;
      }
      else {
        v46 = *(const char **)v3;
      }
      memmove(v43, v46, v41);
LABEL_80:
      *(_WORD *)&v43[v41] = 47;
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v47 = &v61;
      }
      else {
        v47 = (std::string *)v61.__r_.__value_.__r.__words[0];
      }
      if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v61.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v61.__r_.__value_.__l.__size_;
      }
      v49 = std::string::append(&v59, (const std::string::value_type *)v47, size);
      long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
      *(void *)&__dst.st_uid = *((void *)&v49->__r_.__value_.__l + 2);
      *(_OWORD *)&__dst.st_dev = v50;
      v49->__r_.__value_.__l.__size_ = 0;
      v49->__r_.__value_.__r.__words[2] = 0;
      v49->__r_.__value_.__r.__words[0] = 0;
      char v51 = support::fs::removeDir((const char *)&__dst);
      if (SHIBYTE(__dst.st_gid) < 0)
      {
        operator delete(*(void **)&__dst.st_dev);
        if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      else if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_88:
        if (v51) {
          goto LABEL_89;
        }
LABEL_59:
        char v57 = 0;
        char v29 = 0;
        int v30 = 2;
        if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
          goto LABEL_91;
        }
        goto LABEL_90;
      }
      operator delete(v59.__r_.__value_.__l.__data_);
      if (v51) {
        goto LABEL_89;
      }
      goto LABEL_59;
    }
    char v29 = 0;
    int v30 = 3;
    if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
      goto LABEL_91;
    }
LABEL_90:
    operator delete(__p[0]);
LABEL_91:
    if (v29) {
      goto LABEL_95;
    }
    if ((SHIBYTE(v61.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_93;
    }
LABEL_96:
    operator delete(v61.__r_.__value_.__l.__data_);
    if (v30 != 3) {
      goto LABEL_97;
    }
LABEL_3:
    v5 += 3;
    if (v5 == v4) {
      goto LABEL_102;
    }
  }
  uint64_t v11 = (std::string *)v61.__r_.__value_.__r.__words[0];
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v61;
  }
  if (LOWORD(v11->__r_.__value_.__l.__data_) != 11822) {
    goto LABEL_19;
  }
LABEL_95:
  int v30 = 0;
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_96;
  }
LABEL_93:
  if (v30 == 3) {
    goto LABEL_3;
  }
LABEL_97:
  if (!v30) {
    goto LABEL_3;
  }
LABEL_102:
  unsigned int v5 = (void **)v62;
  char v52 = v57;
  if (!v62) {
    return v52 & 1;
  }
LABEL_105:
  v53 = v63;
  v54 = v5;
  if (v63 != v5)
  {
    do
    {
      if (*((char *)v53 - 1) < 0) {
        operator delete(*(v53 - 3));
      }
      v53 -= 3;
    }
    while (v53 != v5);
    v54 = v62;
  }
  v63 = v5;
  operator delete(v54);
  return v52 & 1;
}

void sub_1A6114578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  std::vector<std::string>::~vector[abi:ne180100](&a31);
  _Unwind_Resume(a1);
}

void support::fs::moveDirUnique(const char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  timespec v4 = (const std::__fs::filesystem::path *)a1;
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v16.st_blkstd::string::size_type size = v6;
  *(timespec *)v16.st_qspare = v6;
  v16.st_birthtimespec = v6;
  *(timespec *)&v16.st_std::string::size_type size = v6;
  v16.st_mtimespec = v6;
  v16.st_ctimespec = v6;
  *(timespec *)&v16.st_uid = v6;
  v16.st_atimespec = v6;
  *(timespec *)&v16.st_dev = v6;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (stat(a1, &v16)) {
    goto LABEL_4;
  }
  long long v7 = (v4->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
     ? (const char *)v4
     : (const char *)v4->__pn_.__r_.__value_.__r.__words[0];
  int v8 = opendir(v7);
  if (!v8) {
    goto LABEL_4;
  }
  std::string::size_type v9 = v8;
  int v10 = readdir(v8);
  closedir(v9);
  if (!v10) {
    goto LABEL_4;
  }
  memset((void *)a3, 170, 24);
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  support::fs::createUniquePath((const char *)&__p, (std::string *)a3);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((v4->__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v12 = v4;
  }
  else {
    int v12 = (const std::__fs::filesystem::path *)v4->__pn_.__r_.__value_.__r.__words[0];
  }
  if (*(char *)(a3 + 23) >= 0) {
    size_t v13 = (const std::__fs::filesystem::path *)a3;
  }
  else {
    size_t v13 = *(const std::__fs::filesystem::path **)a3;
  }
  rename(v12, v13, v11);
  if (v14)
  {
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
LABEL_4:
    *(unsigned char *)(a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
  }
}

void sub_1A6114788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void support::fs::getFileName(std::string *a1@<X8>)
{
  memset(__p, 170, sizeof(__p));
  ctu::tokenize();
  if (*((char *)__p[1] - 1) < 0)
  {
    std::string::__init_copy_ctor_external(a1, *((const std::string::value_type **)__p[1] - 3), *((void *)__p[1] - 2));
  }
  else
  {
    long long v2 = *(_OWORD *)((char *)__p[1] - 24);
    a1->__r_.__value_.__r.__words[2] = *((void *)__p[1] - 1);
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v2;
  }
  if (__p[0])
  {
    BOOL v3 = (void **)__p[1];
    timespec v4 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != __p[0]);
      timespec v4 = __p[0];
    }
    operator delete(v4);
  }
}

void sub_1A611485C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

uint64_t support::fs::lockDir(const char *a1)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  uint64_t v1 = open(a1, 0);
  if ((v1 & 0x80000000) != 0) {
    return v1;
  }
  int v5 = 1;
  v3[0] = 0;
  v3[1] = 0;
  pid_t v4 = getpid();
  if ((fcntl(v1, 9, v3) & 0x80000000) == 0) {
    return v1;
  }
  close(v1);
  return 0xFFFFFFFFLL;
}

BOOL support::fs::unlockDir(support::fs *this)
{
  int v1 = (int)this;
  int v6 = 2;
  v4[0] = 0;
  v4[1] = 0;
  pid_t v5 = getpid();
  BOOL v2 = fcntl(v1, 9, v4) == 0;
  close(v1);
  return v2;
}

BOOL support::fs::getFilteredFiles(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  *__error() = 0;
  if (a1[23] < 0)
  {
    long long v7 = opendir(*(const char **)a1);
    if (v7) {
      goto LABEL_3;
    }
LABEL_78:
    uint64_t v45 = GetOsLogContext()[1];
    BOOL result = os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
    if (result)
    {
      if (a1[23] < 0) {
        a1 = *(const char **)a1;
      }
      v47 = __error();
      v48 = strerror(*v47);
      v58.st_dev = 136315394;
      *(void *)&v58.st_mode = a1;
      WORD2(v58.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&v58.st_ino + 6) = (__darwin_ino64_t)v48;
      _os_log_error_impl(&dword_1A609F000, v45, OS_LOG_TYPE_ERROR, "Error %s (%s)\n", (uint8_t *)&v58, 0x16u);
      return 0;
    }
    return result;
  }
  long long v7 = opendir(a1);
  if (!v7) {
    goto LABEL_78;
  }
LABEL_3:
  int v8 = v7;
  std::string::size_type v9 = readdir(v7);
  if (v9)
  {
    char v51 = a1;
    char v49 = 0;
    while (1)
    {
      d_name = v9->d_name;
      memset(__dst, 170, sizeof(__dst));
      size_t v11 = strlen(v9->d_name);
      if (v11 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v12 = v11;
      if (v11 >= 0x17) {
        break;
      }
      __dst[23] = v11;
      size_t v13 = __dst;
      if (v11) {
        goto LABEL_12;
      }
LABEL_13:
      v13[v12] = 0;
      uint64_t v16 = __dst[23];
      int v17 = __dst[23];
      uint64_t v18 = *(void *)&__dst[8];
      if (__dst[23] >= 0) {
        std::string::size_type v19 = __dst[23];
      }
      else {
        std::string::size_type v19 = *(void *)&__dst[8];
      }
      if (v19 == 2)
      {
        uint64_t v21 = *(_WORD **)__dst;
        if (__dst[23] >= 0) {
          uint64_t v21 = __dst;
        }
        if (*v21 == 11822) {
          goto LABEL_73;
        }
      }
      else if (v19 == 1)
      {
        unint64_t v20 = *(unsigned char **)__dst;
        if (__dst[23] >= 0) {
          unint64_t v20 = __dst;
        }
        if (*v20 == 46) {
          goto LABEL_73;
        }
      }
      if (a4) {
        goto LABEL_53;
      }
      uint64_t v22 = v8;
      uint64_t v23 = a4;
      uint64_t v24 = a3;
      v25.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v25.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v58.st_blkstd::string::size_type size = v25;
      *(timespec *)v58.st_qspare = v25;
      v58.st_birthtimespec = v25;
      *(timespec *)&v58.st_std::string::size_type size = v25;
      v58.st_mtimespec = v25;
      v58.st_ctimespec = v25;
      *(timespec *)&v58.st_uid = v25;
      v58.st_atimespec = v25;
      *(timespec *)&v58.st_dev = v25;
      int v26 = v51[23];
      if (v26 >= 0) {
        size_t v27 = *((unsigned __int8 *)v51 + 23);
      }
      else {
        size_t v27 = *((void *)v51 + 1);
      }
      unint64_t v28 = v27 + 1;
      memset(&v52, 170, sizeof(v52));
      if (v27 + 1 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v28 >= 0x17)
      {
        uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v28 | 7) != 0x17) {
          uint64_t v30 = v28 | 7;
        }
        uint64_t v31 = v30 + 1;
        char v29 = (char *)operator new(v30 + 1);
        v52.__r_.__value_.__l.__size_ = v27 + 1;
        v52.__r_.__value_.__r.__words[2] = v31 | 0x8000000000000000;
        v52.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
      }
      else
      {
        memset(&v52, 0, sizeof(v52));
        char v29 = (char *)&v52;
        *((unsigned char *)&v52.__r_.__value_.__s + 23) = v27 + 1;
        if (!v27) {
          goto LABEL_40;
        }
      }
      if (v26 >= 0) {
        uint64_t v32 = v51;
      }
      else {
        uint64_t v32 = *(const char **)v51;
      }
      memmove(v29, v32, v27);
LABEL_40:
      a3 = v24;
      *(_WORD *)&v29[v27] = 47;
      if (v17 >= 0) {
        long long v33 = __dst;
      }
      else {
        long long v33 = *(const std::string::value_type **)__dst;
      }
      uint64_t v34 = std::string::append(&v52, v33, v19);
      a4 = v23;
      long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
      v55[0] = *((void *)&v34->__r_.__value_.__l + 2);
      *(_OWORD *)std::string __p = v35;
      v34->__r_.__value_.__l.__size_ = 0;
      v34->__r_.__value_.__r.__words[2] = 0;
      v34->__r_.__value_.__r.__words[0] = 0;
      if (v55[0] >= 0) {
        v36 = __p;
      }
      else {
        v36 = (void **)__p[0];
      }
      lstat((const char *)v36, &v58);
      int v8 = v22;
      if (SHIBYTE(v55[0]) < 0)
      {
        operator delete(__p[0]);
        if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_48:
          if ((v58.st_mode & 0xF000) != 0xA000) {
            goto LABEL_52;
          }
          goto LABEL_73;
        }
      }
      else if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_48;
      }
      operator delete(v52.__r_.__value_.__l.__data_);
      if ((v58.st_mode & 0xF000) != 0xA000)
      {
LABEL_52:
        uint64_t v16 = __dst[23];
        uint64_t v18 = *(void *)&__dst[8];
        LOBYTE(v17) = __dst[23];
LABEL_53:
        if ((v17 & 0x80u) == 0) {
          v37 = (std::sub_match<const char *> *)__dst;
        }
        else {
          v37 = *(std::sub_match<const char *> **)__dst;
        }
        if ((v17 & 0x80u) != 0) {
          uint64_t v16 = v18;
        }
        uint64_t v38 = (std::sub_match<std::__wrap_iter<const char *>> *)((char *)v37 + v16);
        *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v56 = v39;
        v55[6] = 0xAAAAAAAAAAAAAA00;
        v55[3] = 0xAAAAAAAAAAAAAAAALL;
        v55[4] = 0;
        v55[5] = 0;
        v55[7] = 0;
        v55[8] = 0;
        LOBYTE(v56) = 0;
        BYTE8(v56) = 0;
        uint64_t v57 = 0;
        *(_OWORD *)std::string __p = 0u;
        memset(v55, 0, 25);
        *(_OWORD *)&v58.st_birthtimespec.tv_nsec = v39;
        v58.st_ctimespec.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v58.st_atimespec.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        memset(&v58.st_mtimespec, 0, 17);
        memset(&v58.st_ctimespec.tv_nsec, 0, 17);
        LOBYTE(v58.st_size) = 0;
        v58.st_blocks = 0;
        memset(&v58, 0, 41);
        int v40 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a2, v37, (std::sub_match<const char *> *)((char *)v37 + v16), (std::vector<std::csub_match> *)&v58, 4160);
        std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)__p, (uint64_t)v37, v38, (uint64_t *)&v58.st_dev, 0);
        if (*(void *)&v58.st_dev)
        {
          v58.st_ino = *(void *)&v58.st_dev;
          operator delete(*(void **)&v58.st_dev);
        }
        if ((_BYTE)v56) {
          int v41 = v40 ^ 1;
        }
        else {
          int v41 = 1;
        }
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if ((v40 & v41) != 0)
        {
          unint64_t v42 = *(void *)(a3 + 8);
          if (v42 >= *(void *)(a3 + 16))
          {
            uint64_t v44 = std::vector<std::string>::__push_back_slow_path<std::string const&>((char **)a3, (uint64_t)__dst);
          }
          else
          {
            if ((__dst[23] & 0x80000000) != 0)
            {
              std::string::__init_copy_ctor_external(*(std::string **)(a3 + 8), *(const std::string::value_type **)__dst, *(std::string::size_type *)&__dst[8]);
            }
            else
            {
              long long v43 = *(_OWORD *)__dst;
              *(void *)(v42 + 16) = *(void *)&__dst[16];
              *(_OWORD *)unint64_t v42 = v43;
            }
            uint64_t v44 = (std::string *)(v42 + 24);
            *(void *)(a3 + 8) = v42 + 24;
          }
          *(void *)(a3 + 8) = v44;
          char v49 = 1;
        }
      }
LABEL_73:
      if ((__dst[23] & 0x80000000) != 0) {
        operator delete(*(void **)__dst);
      }
      std::string::size_type v9 = readdir(v8);
      if (!v9) {
        goto LABEL_83;
      }
    }
    uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v14 = v11 | 7;
    }
    uint64_t v15 = v14 + 1;
    size_t v13 = operator new(v14 + 1);
    *(void *)&__dst[8] = v12;
    *(void *)&__dst[16] = v15 | 0x8000000000000000;
    *(void *)stat __dst = v13;
LABEL_12:
    memmove(v13, d_name, v12);
    goto LABEL_13;
  }
  char v49 = 0;
LABEL_83:
  closedir(v8);
  return v49 & 1;
}

void sub_1A6114EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49)
{
  *(void *)(v49 + 8) = v50;
  if (a30 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A6115168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void support::fs::getBasePath(unsigned __int8 *a1@<X0>, uint64_t a2@<X8>)
{
  BOOL v2 = a1;
  if (((char)a1[23] & 0x80000000) == 0)
  {
    if (!a1[23])
    {
      *(_OWORD *)a2 = *(_OWORD *)a1;
      *(void *)(a2 + 16) = *((void *)a1 + 2);
      return;
    }
LABEL_6:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    memset(&__p, 170, sizeof(__p));
    support::fs::getFileName(&__p);
    size_t v4 = *((void *)v2 + 1);
    if ((v2[23] & 0x80u) == 0)
    {
      size_t v5 = v2[23];
    }
    else
    {
      BOOL v2 = *(unsigned __int8 **)v2;
      size_t v5 = v4;
    }
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    char v7 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v9 = &v2[v5];
    if (v5) {
      BOOL v10 = size == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10)
    {
      uint64_t v15 = &v2[v5];
    }
    else
    {
      uint64_t v14 = v2;
      uint64_t v15 = &v2[v5];
      do
      {
        if (*v14 == p_p->__r_.__value_.__s.__data_[0])
        {
          uint64_t v16 = 1;
          while (size != v16)
          {
            if (&v14[v16] == v9) {
              goto LABEL_20;
            }
            int v17 = v14[v16];
            int v18 = p_p->__r_.__value_.__s.__data_[v16++];
            if (v17 != v18) {
              goto LABEL_37;
            }
          }
          uint64_t v15 = v14;
        }
LABEL_37:
        ++v14;
      }
      while (v14 != v9);
    }
LABEL_20:
    BOOL v11 = v15 != v9 || size == 0;
    if (!v11 || v15 - v2 == -1) {
      goto LABEL_34;
    }
    if (v5 >= v15 - v2) {
      size_t v12 = v15 - v2;
    }
    else {
      size_t v12 = v5;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v12 >= 0x17)
    {
      uint64_t v19 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v19 = v12 | 7;
      }
      uint64_t v20 = v19 + 1;
      size_t v13 = (long long *)operator new(v19 + 1);
      *((void *)&v22 + 1) = v12;
      unint64_t v23 = v20 | 0x8000000000000000;
      *(void *)&long long v22 = v13;
    }
    else
    {
      HIBYTE(v23) = v12;
      size_t v13 = &v22;
      if (!v12)
      {
        LOBYTE(v22) = 0;
        if ((*(char *)(a2 + 23) & 0x80000000) == 0)
        {
LABEL_33:
          *(_OWORD *)a2 = v22;
          *(void *)(a2 + 16) = v23;
          char v7 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
LABEL_34:
          if (v7 < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          return;
        }
LABEL_49:
        operator delete(*(void **)a2);
        goto LABEL_33;
      }
    }
    memmove(v13, v2, v12);
    *((unsigned char *)v13 + v12) = 0;
    if ((*(char *)(a2 + 23) & 0x80000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_49;
  }
  if (*((void *)a1 + 1)) {
    goto LABEL_6;
  }
  uint64_t v21 = *(const std::string::value_type **)a1;

  std::string::__init_copy_ctor_external((std::string *)a2, v21, 0);
}

void sub_1A61153C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void support::fs::getLastNumberDir(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  memset(&v69, 170, sizeof(v69));
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v69, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string v69 = *(std::string *)a1;
  }
  size_t v4 = (std::string *)v69.__r_.__value_.__r.__words[0];
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v5 = &v69;
  }
  else {
    size_t v5 = (std::string *)v69.__r_.__value_.__r.__words[0];
  }
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v69.__r_.__value_.__l.__size_;
  }
  std::string::size_type v7 = size + 1;
  do
  {
    std::string::size_type v8 = v7 - 1;
    if (v7 == 1) {
      goto LABEL_20;
    }
    int v9 = v5->__r_.__value_.__s.__data_[v7-- - 2];
  }
  while (v9 == 47);
  if (v8)
  {
    std::string::size_type v10 = v8 - 1;
    if ((*((unsigned char *)&v69.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (v69.__r_.__value_.__l.__size_ > v10)
      {
        v69.__r_.__value_.__l.__size_ = v8;
        goto LABEL_19;
      }
    }
    else if (v10 < HIBYTE(v69.__r_.__value_.__r.__words[2]))
    {
      *((unsigned char *)&v69.__r_.__value_.__s + 23) = v8 & 0x7F;
      size_t v4 = &v69;
LABEL_19:
      v4->__r_.__value_.__s.__data_[v8] = 0;
      goto LABEL_20;
    }
    std::string::__throw_out_of_range[abi:ne180100]();
  }
LABEL_20:
  memset(&v68, 170, sizeof(v68));
  support::fs::getBasePath((unsigned __int8 *)&v69, (uint64_t)&v68);
  std::string::size_type v11 = HIBYTE(v69.__r_.__value_.__r.__words[2]);
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v11 = v69.__r_.__value_.__l.__size_;
  }
  if (!v11) {
    goto LABEL_33;
  }
  std::string::size_type v12 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v12 = v68.__r_.__value_.__l.__size_;
  }
  if (!v12)
  {
LABEL_33:
    if ((*(char *)(a1 + 23) & 0x80000000) == 0)
    {
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
      if ((SHIBYTE(v68.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_125;
      }
      goto LABEL_130;
    }
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
    goto LABEL_124;
  }
  memset(&v67, 170, sizeof(v67));
  support::fs::getFileName(&v67);
  int v13 = SHIBYTE(v67.__r_.__value_.__r.__words[2]);
  if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v14 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v14 = v67.__r_.__value_.__l.__size_;
  }
  unint64_t v15 = v14 + 13;
  memset(__dst, 170, sizeof(__dst));
  if (v14 + 13 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v15 >= 0x17)
  {
    uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v17 = v15 | 7;
    }
    uint64_t v18 = v17 + 1;
    uint64_t v16 = (void **)operator new(v17 + 1);
    __dst[1] = (void *)(v14 + 13);
    __dst[2] = (void *)(v18 | 0x8000000000000000);
    __dst[0] = v16;
  }
  else
  {
    memset(__dst, 0, sizeof(__dst));
    uint64_t v16 = __dst;
    HIBYTE(__dst[2]) = v14 + 13;
    if (!v14) {
      goto LABEL_44;
    }
  }
  if (v13 >= 0) {
    uint64_t v19 = &v67;
  }
  else {
    uint64_t v19 = (std::string *)v67.__r_.__value_.__r.__words[0];
  }
  memmove(v16, v19, v14);
LABEL_44:
  strcpy((char *)v16 + v14, "-[[:alnum:]]*");
  *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v64[32] = v20;
  long long v65 = v20;
  *(_OWORD *)uint64_t v64 = v20;
  *(_OWORD *)&v64[16] = v20;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)v64, (uint64_t)__dst, 0);
  std::string v61 = 0;
  v62 = 0;
  uint64_t v63 = 0;
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v60, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
  }
  else {
    std::string v60 = v68;
  }
  std::locale::locale(&v54, (const std::locale *)v64);
  long long v55 = *(_OWORD *)&v64[8];
  long long v56 = *(_OWORD *)&v64[24];
  uint64_t v57 = *(void *)&v64[40];
  stat v58 = (std::__shared_weak_count *)v65;
  if ((void)v65) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v65 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v59 = *((void *)&v65 + 1);
  if (!support::fs::getFilteredFiles((const char *)&v60, (uint64_t)&v54, (uint64_t)&v61, 0))
  {
    uint64_t v24 = v58;
    if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
    std::locale::~locale(&v54);
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v60.__r_.__value_.__l.__data_);
    }
    goto LABEL_84;
  }
  uint64_t v21 = (void **)v61;
  long long v22 = v62;
  unint64_t v23 = v58;
  if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  std::locale::~locale(&v54);
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v60.__r_.__value_.__l.__data_);
    if (v21 == v22)
    {
LABEL_84:
      if ((*(char *)(a1 + 23) & 0x80000000) == 0)
      {
        *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
        a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 16);
        uint64_t v34 = (void **)v61;
        if (!v61) {
          goto LABEL_120;
        }
        goto LABEL_113;
      }
      std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
LABEL_112:
      uint64_t v34 = (void **)v61;
      if (!v61) {
        goto LABEL_120;
      }
      goto LABEL_113;
    }
  }
  else if (v21 == v22)
  {
    goto LABEL_84;
  }
  timespec v25 = (char *)v61;
  int v26 = (char *)v62;
  if (v61 != v62)
  {
    unsigned int v27 = 0;
    while (1)
    {
      memset(&__p, 170, sizeof(__p));
      ctu::tokenize();
      memset(&v52, 170, sizeof(v52));
      if (*(char *)(__p.__r_.__value_.__l.__size_ - 1) < 0)
      {
        std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)(__p.__r_.__value_.__l.__size_ - 24), *(void *)(__p.__r_.__value_.__l.__size_ - 16));
      }
      else
      {
        long long v29 = *(_OWORD *)(__p.__r_.__value_.__l.__size_ - 24);
        v52.__r_.__value_.__r.__words[2] = *(void *)(__p.__r_.__value_.__l.__size_ - 8);
        *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v29;
      }
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v30 = &v52;
      }
      else {
        uint64_t v30 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      unsigned int v31 = strtol((const char *)v30, 0, 0);
      if (v27 <= v31) {
        unsigned int v27 = v31;
      }
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v52.__r_.__value_.__l.__data_);
        std::string::size_type v32 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0])
        {
LABEL_79:
          std::string::size_type v33 = __p.__r_.__value_.__l.__size_;
          unint64_t v28 = (void *)v32;
          if (__p.__r_.__value_.__l.__size_ != v32)
          {
            do
            {
              if (*(char *)(v33 - 1) < 0) {
                operator delete(*(void **)(v33 - 24));
              }
              v33 -= 24;
            }
            while (v33 != v32);
            unint64_t v28 = (void *)__p.__r_.__value_.__r.__words[0];
          }
          __p.__r_.__value_.__l.__size_ = v32;
          operator delete(v28);
        }
      }
      else
      {
        std::string::size_type v32 = __p.__r_.__value_.__r.__words[0];
        if (__p.__r_.__value_.__r.__words[0]) {
          goto LABEL_79;
        }
      }
      v25 += 24;
      if (v25 == v26) {
        goto LABEL_89;
      }
    }
  }
  unsigned int v27 = 0;
LABEL_89:
  int v35 = SHIBYTE(v69.__r_.__value_.__r.__words[2]);
  if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v36 = HIBYTE(v69.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v36 = v69.__r_.__value_.__l.__size_;
  }
  unint64_t v37 = v36 + 1;
  memset(&v52, 170, sizeof(v52));
  if (v36 + 1 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v37 >= 0x17)
  {
    uint64_t v39 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v37 | 7) != 0x17) {
      uint64_t v39 = v37 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v38 = (char *)operator new(v39 + 1);
    v52.__r_.__value_.__l.__size_ = v36 + 1;
    v52.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
    v52.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
  }
  else
  {
    memset(&v52, 0, sizeof(v52));
    uint64_t v38 = (char *)&v52;
    *((unsigned char *)&v52.__r_.__value_.__s + 23) = v36 + 1;
    if (!v36) {
      goto LABEL_103;
    }
  }
  if (v35 >= 0) {
    int v41 = &v69;
  }
  else {
    int v41 = (std::string *)v69.__r_.__value_.__r.__words[0];
  }
  memmove(v38, v41, v36);
LABEL_103:
  *(_WORD *)&v38[v36] = 45;
  std::to_string(&v51, v27);
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v42 = &v51;
  }
  else {
    unint64_t v42 = (std::string *)v51.__r_.__value_.__r.__words[0];
  }
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v43 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v43 = v51.__r_.__value_.__l.__size_;
  }
  uint64_t v44 = std::string::append(&v52, (const std::string::value_type *)v42, v43);
  long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  v46 = std::string::append(&__p, "/", 1uLL);
  long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
  a2->__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v47;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_111:
      if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_112;
      }
      goto LABEL_134;
    }
  }
  else if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_111;
  }
  operator delete(v51.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_112;
  }
LABEL_134:
  operator delete(v52.__r_.__value_.__l.__data_);
  uint64_t v34 = (void **)v61;
  if (!v61) {
    goto LABEL_120;
  }
LABEL_113:
  v48 = v62;
  uint64_t v49 = v34;
  if (v62 != v34)
  {
    do
    {
      if (*((char *)v48 - 1) < 0) {
        operator delete(*(v48 - 3));
      }
      v48 -= 3;
    }
    while (v48 != v34);
    uint64_t v49 = v61;
  }
  v62 = v34;
  operator delete(v49);
LABEL_120:
  uint64_t v50 = (std::__shared_weak_count *)v65;
  if ((void)v65 && !atomic_fetch_add((atomic_ullong *volatile)(v65 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
    std::locale::~locale((std::locale *)v64);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
LABEL_123:
      if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_124;
      }
      goto LABEL_129;
    }
  }
  else
  {
    std::locale::~locale((std::locale *)v64);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_123;
    }
  }
  operator delete(__dst[0]);
  if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_124:
    if ((SHIBYTE(v68.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_125;
    }
    goto LABEL_130;
  }
LABEL_129:
  operator delete(v67.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v68.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_125:
    if ((SHIBYTE(v69.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_131:
    operator delete(v69.__r_.__value_.__l.__data_);
    return;
  }
LABEL_130:
  operator delete(v68.__r_.__value_.__l.__data_);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_131;
  }
}

void sub_1A6115B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,std::locale a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,uint64_t a46,std::locale a47)
{
  if (a28 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a21 & 0x80000000) == 0)
      {
LABEL_8:
        std::vector<std::string>::~vector[abi:ne180100](&a44);
        std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a47);
        if (*(char *)(v47 - 161) < 0)
        {
          operator delete(*(void **)(v47 - 184));
          if ((*(char *)(v47 - 137) & 0x80000000) == 0)
          {
LABEL_10:
            if ((*(char *)(v47 - 113) & 0x80000000) == 0) {
              goto LABEL_11;
            }
            goto LABEL_15;
          }
        }
        else if ((*(char *)(v47 - 137) & 0x80000000) == 0)
        {
          goto LABEL_10;
        }
        operator delete(*(void **)(v47 - 160));
        if ((*(char *)(v47 - 113) & 0x80000000) == 0)
        {
LABEL_11:
          if ((*(char *)(v47 - 89) & 0x80000000) == 0) {
            goto LABEL_12;
          }
          goto LABEL_16;
        }
LABEL_15:
        operator delete(*(void **)(v47 - 136));
        if ((*(char *)(v47 - 89) & 0x80000000) == 0) {
LABEL_12:
        }
          _Unwind_Resume(a1);
LABEL_16:
        operator delete(*(void **)(v47 - 112));
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a16);
      goto LABEL_8;
    }
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a10);
  if ((a21 & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

BOOL support::fs::getPartitionInfo(uint64_t a1, void *a2, void *a3, unint64_t *a4)
{
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 23))
    {
      memset(&v11, 0, sizeof(v11));
      int v7 = statvfs((const char *)a1, &v11);
      BOOL result = v7 == 0;
      if (v7) {
        return result;
      }
LABEL_7:
      *a4 = v11.f_frsize;
      uint64_t f_bavail = v11.f_bavail;
      *a2 = v11.f_blocks;
      *a3 = f_bavail;
      return result;
    }
    return 0;
  }
  if (!*(void *)(a1 + 8)) {
    return 0;
  }
  memset(&v11, 0, sizeof(v11));
  int v9 = statvfs(*(const char **)a1, &v11);
  BOOL result = v9 == 0;
  if (!v9) {
    goto LABEL_7;
  }
  return result;
}

void *support::fs::readCurrentLine@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::istream::tellg();
  uint64_t v4 = v10;
  if (v10 >= 2)
  {
    do
    {
      std::istream::seekg();
      if (std::istream::peek() == 10) {
        break;
      }
    }
    while (v4-- > 1);
  }
  std::istream::seekg();
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  int v6 = std::locale::use_facet(v9, MEMORY[0x1E4FBA258]);
  unsigned __int8 v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(v9);
  return std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (uint64_t)a2, v7);
}

void sub_1A6115ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void sub_1A6115EE4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0)
  {
    operator delete(*(void **)v1);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(std::string *a1, std::__wrap_iter<const char *> a2, std::__wrap_iter<const char *> a3, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *a4, char *a5, unsigned __int32 __m)
{
  __int16 v6 = __m;
  unsigned int i = (std::string::value_type *)a2.__i_;
  v11.first.__i_ = (std::__wrap_iter<const char *>::iterator_type)0xAAAAAAAAAAAAAAAALL;
  v11.second.__i_ = (std::__wrap_iter<const char *>::iterator_type)0xAAAAAAAAAAAAAAAALL;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__suffix_.second.__i_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__ready_ = v11;
  v38.__match_.__prefix_.std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__prefix_.matched = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__matches_.__end_cap_.__value_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__unmatched_.second.__i_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__pregex_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__match_.__matches_.__begin_ = v11;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)&v38.__begin_.__i_ = v11;
  std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(&v38, a2, a3, a4, (std::regex_constants::match_flag_type)__m);
  end = v38.__match_.__matches_.__end_;
  if (v38.__match_.__matches_.__end_ == v38.__match_.__matches_.__begin_)
  {
    if ((v6 & 0x200) != 0) {
      goto LABEL_44;
    }
    for (; i != a3.__i_; ++i)
      std::string::push_back(a1, *i);
    goto LABEL_43;
  }
  p_match = &v38.__match_;
  size_t v14 = strlen(a5);
  unint64_t v15 = (unsigned __int8 *)&a5[v14];
  if ((v6 & 0x200) == 0)
  {
    if ((v6 & 0x400) != 0)
    {
      std::string::size_type v33 = (std::string::value_type *)v38.__match_.__prefix_.first.__i_;
      for (std::__wrap_iter<const char *>::iterator_type j = v38.__match_.__prefix_.second.__i_; v33 != j; ++v33)
        std::string::push_back(a1, *v33);
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
      uint64_t v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
      std::__wrap_iter<const char *>::iterator_type v17 = v38.__match_.__suffix_.second.__i_;
      if ((v6 & 0x200) != 0) {
        goto LABEL_43;
      }
      goto LABEL_39;
    }
    __int16 v37 = v6;
    int v35 = (unsigned __int8 *)&a5[v14];
    size_t v36 = (unsigned __int8 *)a5;
LABEL_12:
    uint64_t v18 = (std::string::value_type ***)p_match;
    std::__wrap_iter<const char *>::iterator_type v20 = v38.__match_.__prefix_.first.__i_;
    std::__wrap_iter<const char *>::iterator_type v19 = v38.__match_.__prefix_.second.__i_;
    while (1)
    {
      if (v20 == v19)
      {
        p_match = (std::regex_iterator<std::__wrap_iter<const char *>, char>::value_type *)v18;
        __int16 v6 = v37;
        a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>(v18, a1, v36, v35, v37);
        uint64_t v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
        std::__wrap_iter<const char *>::iterator_type v17 = v38.__match_.__suffix_.second.__i_;
        std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v38);
        if (v38.__match_.__matches_.__end_ == v38.__match_.__matches_.__begin_) {
          goto LABEL_38;
        }
        goto LABEL_12;
      }
      char v24 = *v20;
      int v25 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
      if ((v25 & 0x80000000) == 0) {
        break;
      }
      uint64_t v27 = a1->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL;
      size_t size = v27 - 1;
      if (a1->__r_.__value_.__l.__size_ == v27 - 1)
      {
        if (v27 == 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        int v26 = (std::string *)a1->__r_.__value_.__r.__words[0];
        if (size <= 0x3FFFFFFFFFFFFFF2) {
          goto LABEL_22;
        }
        size_t v30 = 0x7FFFFFFFFFFFFFF7;
LABEL_30:
        unsigned int v31 = (std::string *)operator new(v30);
        long long v22 = v31;
        if (!size || (memmove(v31, v26, size), size != 22)) {
          operator delete(v26);
        }
        a1->__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
        a1->__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
        goto LABEL_35;
      }
      long long v22 = (std::string *)a1->__r_.__value_.__r.__words[0];
      size_t size = a1->__r_.__value_.__l.__size_;
LABEL_35:
      a1->__r_.__value_.__l.__size_ = size + 1;
LABEL_14:
      unint64_t v23 = (char *)v22 + size;
      *unint64_t v23 = v24;
      v23[1] = 0;
      ++v20;
    }
    if (*((unsigned char *)&a1->__r_.__value_.__s + 23) != 22)
    {
      size_t size = HIBYTE(a1->__r_.__value_.__r.__words[2]);
      *((unsigned char *)&a1->__r_.__value_.__s + 23) = (v25 + 1) & 0x7F;
      long long v22 = a1;
      goto LABEL_14;
    }
    int v26 = a1;
    size_t size = 22;
LABEL_22:
    if (size + 1 > 2 * size) {
      unint64_t v28 = size + 1;
    }
    else {
      unint64_t v28 = 2 * size;
    }
    uint64_t v29 = (v28 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v28 | 7) != 0x17) {
      uint64_t v29 = v28 | 7;
    }
    if (v28 >= 0x17) {
      size_t v30 = v29 + 1;
    }
    else {
      size_t v30 = 23;
    }
    goto LABEL_30;
  }
  if ((v6 & 0x400) == 0)
  {
    do
    {
      a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
      uint64_t v16 = (std::string::value_type *)v38.__match_.__suffix_.first.__i_;
      std::__wrap_iter<const char *>::iterator_type v17 = v38.__match_.__suffix_.second.__i_;
      std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::operator++(&v38);
    }
    while (v38.__match_.__matches_.__end_ != v38.__match_.__matches_.__begin_);
LABEL_38:
    if ((v6 & 0x200) != 0) {
      goto LABEL_43;
    }
LABEL_39:
    while (v16 != v17)
      std::string::push_back(a1, *v16++);
    goto LABEL_43;
  }
  a1 = std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>((std::string::value_type ***)&v38.__match_, a1, (unsigned __int8 *)a5, v15, v6);
LABEL_43:
  end = v38.__match_.__matches_.__begin_;
LABEL_44:
  if (end)
  {
    v38.__match_.__matches_.__end_ = end;
    operator delete(end);
  }
  return a1;
}

void sub_1A6116224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::match_results<std::__wrap_iter<char const*>>::format<std::back_insert_iterator<std::string>>(std::string::value_type ***a1, std::string *this, unsigned __int8 *a3, unsigned __int8 *a4, __int16 a5)
{
  __int16 v6 = a3;
  std::string::size_type v8 = a1;
  if ((a5 & 0x100) != 0)
  {
    if (a3 == a4) {
      return this;
    }
    std::string v52 = a1 + 3;
    while (1)
    {
      int v29 = *v6;
      if (v29 != 92) {
        break;
      }
      size_t v30 = v6 + 1;
      if (v6 + 1 == a4)
      {
        LOBYTE(v29) = 92;
LABEL_38:
        std::string::push_back(this, v29);
        size_t v30 = v6;
        goto LABEL_39;
      }
      int v29 = *v30;
      if ((v29 - 48) > 9u)
      {
        ++v6;
        goto LABEL_38;
      }
      unint64_t v44 = (v29 - 48);
      uint64_t v45 = (uint64_t)&(*v8)[3 * v44];
      BOOL v46 = 0xAAAAAAAAAAAAAAABLL * (v8[1] - *v8) > v44;
      uint64_t v47 = (uint64_t)v52;
      if (v46) {
        uint64_t v47 = v45;
      }
      v48 = *(std::string::value_type **)v47;
      uint64_t v49 = *(std::string::value_type **)(v47 + 8);
      if (*(std::string::value_type **)v47 != v49)
      {
        do
        {
          std::string::value_type v50 = *v48++;
          std::string::push_back(this, v50);
        }
        while (v48 != v49);
      }
LABEL_39:
      __int16 v6 = v30 + 1;
      if (v30 + 1 == a4) {
        return this;
      }
    }
    if (v29 != 38) {
      goto LABEL_38;
    }
    unsigned int v31 = *v8;
    std::string::size_type v33 = **v8;
    std::string::size_type v32 = v31[1];
    while (1)
    {
      if (v33 == v32)
      {
        size_t v30 = v6;
        std::string::size_type v8 = a1;
        goto LABEL_39;
      }
      std::string::value_type v37 = *v33;
      int v38 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
      if (v38 < 0)
      {
        std::string::size_type v40 = this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL;
        size_t size = v40 - 1;
        if (this->__r_.__value_.__l.__size_ != v40 - 1)
        {
          int v35 = (std::string *)this->__r_.__value_.__r.__words[0];
          size_t size = this->__r_.__value_.__l.__size_;
          goto LABEL_65;
        }
        if (v40 == 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        uint64_t v39 = (std::string *)this->__r_.__value_.__r.__words[0];
        if (size > 0x3FFFFFFFFFFFFFF2)
        {
          size_t v43 = 0x7FFFFFFFFFFFFFF7;
          int v35 = (std::string *)operator new(0x7FFFFFFFFFFFFFF7uLL);
          goto LABEL_61;
        }
      }
      else
      {
        if (*((unsigned char *)&this->__r_.__value_.__s + 23) != 22)
        {
          size_t size = HIBYTE(this->__r_.__value_.__r.__words[2]);
          *((unsigned char *)&this->__r_.__value_.__s + 23) = (v38 + 1) & 0x7F;
          int v35 = this;
          goto LABEL_44;
        }
        uint64_t v39 = this;
        size_t size = 22;
      }
      if (size + 1 > 2 * size) {
        unint64_t v41 = size + 1;
      }
      else {
        unint64_t v41 = 2 * size;
      }
      uint64_t v42 = (v41 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v41 | 7) != 0x17) {
        uint64_t v42 = v41 | 7;
      }
      if (v41 >= 0x17) {
        size_t v43 = v42 + 1;
      }
      else {
        size_t v43 = 23;
      }
      int v35 = (std::string *)operator new(v43);
      if (!size)
      {
LABEL_62:
        operator delete(v39);
        goto LABEL_63;
      }
LABEL_61:
      memmove(v35, v39, size);
      if (size != 22) {
        goto LABEL_62;
      }
LABEL_63:
      this->__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
      this->__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
LABEL_65:
      this->__r_.__value_.__l.__size_ = size + 1;
LABEL_44:
      size_t v36 = (char *)v35 + size;
      std::string::value_type *v36 = v37;
      v36[1] = 0;
      ++v33;
    }
  }
  if (a3 != a4)
  {
    do
    {
      int v9 = *v6;
      if (v9 == 36)
      {
        uint64_t v10 = v6 + 1;
        if (v6 + 1 != a4)
        {
          int v11 = (char)*v10;
          int v9 = *v10;
          if (v11 > 38)
          {
            if (v11 == 39)
            {
              uint64_t v18 = (std::string::value_type *)v8[9];
              std::__wrap_iter<const char *>::iterator_type v19 = (std::string::value_type *)v8[10];
              while (v18 != v19)
              {
                std::string::value_type v20 = *v18++;
                std::string::push_back(this, v20);
              }
              goto LABEL_6;
            }
            if (v11 == 96)
            {
              unint64_t v15 = (std::string::value_type *)v8[6];
              uint64_t v16 = (std::string::value_type *)v8[7];
              while (v15 != v16)
              {
                std::string::value_type v17 = *v15++;
                std::string::push_back(this, v17);
              }
              goto LABEL_6;
            }
          }
          else
          {
            if (v11 == 36)
            {
              ++v6;
              goto LABEL_5;
            }
            if (v11 == 38)
            {
              std::string::size_type v12 = **v8;
              int v13 = (*v8)[1];
              while (v12 != v13)
              {
                std::string::value_type v14 = *v12++;
                std::string::push_back(this, v14);
              }
              goto LABEL_6;
            }
          }
          if ((v9 - 48) <= 9)
          {
            unint64_t v21 = *v10 - 48;
            if (v6 + 2 != a4)
            {
              uint64_t v22 = v6[2];
              unsigned int v23 = v22 - 48;
              uint64_t v24 = v22 + 10 * (int)v21 - 48;
              if (v23 > 9)
              {
                uint64_t v10 = v6 + 1;
              }
              else
              {
                unint64_t v21 = v24;
                uint64_t v10 = v6 + 2;
              }
            }
            if (0xAAAAAAAAAAAAAAABLL * (v8[1] - *v8) <= v21) {
              uint64_t v25 = (uint64_t)(v8 + 3);
            }
            else {
              uint64_t v25 = (uint64_t)&(*v8)[3 * (int)v21];
            }
            int v26 = *(std::string::value_type **)v25;
            uint64_t v27 = *(std::string::value_type **)(v25 + 8);
            if (*(std::string::value_type **)v25 != v27)
            {
              do
              {
                std::string::value_type v28 = *v26++;
                std::string::push_back(this, v28);
              }
              while (v26 != v27);
            }
            goto LABEL_6;
          }
        }
        LOBYTE(v9) = 36;
      }
LABEL_5:
      std::string::push_back(this, v9);
      uint64_t v10 = v6;
LABEL_6:
      __int16 v6 = v10 + 1;
    }
    while (v10 + 1 != a4);
  }
  return this;
}

void *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, uint64_t a2, unsigned __int8 a3)
{
  char v11 = -86;
  MEMORY[0x1A6274F00](&v11, a1, 1);
  if (!v11) {
    return a1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    unsigned __int8 v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24) + 40);
    std::string::size_type v8 = (unsigned char *)v7[3];
    if (v8 != (unsigned char *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    if (v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1A61167AC(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24) + 32) |= 1u;
  if ((*((unsigned char *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1A611676CLL);
  }
  __cxa_rethrow();
}

void sub_1A6116828(_Unwind_Exception *a1)
{
}

void *Capabilities::create_default_global@<X0>(void *a1@<X8>)
{
  BOOL v3 = operator new(1uLL);
  *a1 = v3;
  BOOL result = operator new(0x20uLL);
  *BOOL result = &unk_1EFB0B110;
  result[1] = 0;
  result[2] = 0;
  result[3] = v3;
  a1[1] = result;
  return result;
}

void sub_1A6116898(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t Capabilities::isCMHandDetectionSupported(Capabilities *this)
{
  capabilities::abs::supportsCMHandDetection(this);
  uint64_t v1 = (void *)MEMORY[0x1E4F221C0];

  return [v1 isCallHandednessAvailable];
}

void std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<Capabilities *,std::shared_ptr<Capabilities>::__shared_ptr_default_delete<Capabilities,Capabilities>,std::allocator<Capabilities>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001A61F86EFLL) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001A61F86EFLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A61F86EFLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A61F86EFLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

const char *diag::config::toString(unsigned int a1)
{
  if (a1 > 4) {
    return "Unknown";
  }
  else {
    return off_1E5C47230[a1];
  }
}

{
  if (a1 > 2) {
    return "Unknown";
  }
  else {
    return off_1E5C47258[a1];
  }
}

{
  if (a1 > 2) {
    return "Unknown";
  }
  else {
    return off_1E5C47270[a1];
  }
}

const char *diag::config::toStringCompact(unsigned int a1)
{
  if (a1 > 2) {
    return "unknown";
  }
  else {
    return off_1E5C47288[a1];
  }
}

BOOL diag::config::equal_nocase(const char *a1, const char *a2)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  return strcasecmp(a1, a2) == 0;
}

uint64_t diag::config::asEnum(uint64_t a1, _DWORD *a2)
{
  char v7 = 4;
  strcpy(v6, "none");
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v3 = (const char *)a1;
  }
  else {
    uint64_t v3 = *(const char **)a1;
  }
  if (!strcasecmp(v3, v6))
  {
    *a2 = 0;
    return 1;
  }
  else
  {
    char v7 = 5;
    strcpy(v6, "reset");
    if (!strcasecmp(v3, v6))
    {
      *a2 = 1;
      return 1;
    }
    else
    {
      char v7 = 11;
      strcpy(v6, "reconfigure");
      int v4 = strcasecmp(v3, v6);
      uint64_t result = 0;
      if (!v4)
      {
        *a2 = 2;
        return 1;
      }
    }
  }
  return result;
}

uint64_t diag::config::getShouldAlwaysFilter(diag::config *this)
{
  int IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  int IsInternalBuild = TelephonyUtilIsInternalBuild();
  return (IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild()) ^ 1;
}

void sys::getCurrentBootSessionUUID(unsigned char *a1@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(void *)&v19[13] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__s = v3;
  *(_OWORD *)std::__wrap_iter<const char *>::iterator_type v19 = v3;
  size_t v15 = 37;
  if (!sysctlbyname("kern.bootsessionuuid", __s, &v15, 0, 0) && v15 == 37)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v8 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v8 = v4 | 7;
      }
      uint64_t v9 = v8 + 1;
      uint64_t v10 = operator new(v8 + 1);
      *((void *)a1 + 1) = v5;
      *((void *)a1 + 2) = v9 | 0x8000000000000000;
      *(void *)a1 = v10;
      a1 = v10;
    }
    else
    {
      a1[23] = v4;
      if (!v4) {
        goto LABEL_17;
      }
    }
    memcpy(a1, __s, v5);
LABEL_17:
    a1[v5] = 0;
    return;
  }
  GetABMLogServer(&v13);
  uint64_t v6 = *((void *)GetGlobalLogger(&v13) + 4);
  char v7 = v14;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    char v11 = __error();
    std::string::size_type v12 = strerror(*v11);
    *(_DWORD *)buf = 136315138;
    std::string::value_type v17 = v12;
    _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Failed to get boot session uuid, error: %s", buf, 0xCu);
  }
  a1[23] = 0;
  *a1 = 0;
}

void sub_1A6116DA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sys::updateBootSessionUUID(sys *this)
{
  memset(&v14, 170, sizeof(v14));
  sys::getCurrentBootSessionUUID(&v14);
  pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  if (!off_1EB5EE4F0)
  {
    SharedData::create_default_global(&v15);
    long long v2 = v15;
    long long v15 = 0uLL;
    long long v3 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
    off_1EB5EE4F0 = v2;
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    size_t v4 = (std::__shared_weak_count *)*((void *)&v15 + 1);
    if (*((void *)&v15 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  }
  std::string::size_type v12 = v1;
  uint64_t v13 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
  if (*(&off_1EB5EE4F0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  char v11 = 15;
  strcpy((char *)v10, "BootSessionUUID");
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, v14.__r_.__value_.__l.__data_, v14.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v14;
  }
  *(void *)&long long v15 = v10;
  *((void *)&v15 + 1) = &__p;
  uint64_t v16 = v1;
  size_t v5 = v1 + 10;
  os_unfair_lock_lock(v5);
  uint64_t v6 = SharedData::setPreference<std::string>(std::string const&,std::string)::{lambda(void)#1}::operator()((char **)&v15);
  os_unfair_lock_unlock(v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v11 & 0x80000000) == 0)
    {
LABEL_16:
      char v7 = v13;
      if (!v13) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v10[0]);
  char v7 = v13;
  if (!v13) {
    goto LABEL_21;
  }
LABEL_20:
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v6;
    }
    goto LABEL_24;
  }
LABEL_21:
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    return v6;
  }
LABEL_24:
  operator delete(v14.__r_.__value_.__l.__data_);
  return v6;
}

void sub_1A6117004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sys::isBootSessionChanged(sys *this)
{
  memset(__s1, 170, sizeof(__s1));
  sys::getCurrentBootSessionUUID(__s1);
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  uint64_t v1 = off_1EB5EE4F0;
  if (!off_1EB5EE4F0)
  {
    SharedData::create_default_global(__p);
    long long v2 = *(_OWORD *)__p;
    __p[0] = 0;
    __p[1] = 0;
    long long v3 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
    off_1EB5EE4F0 = v2;
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    size_t v4 = (std::__shared_weak_count *)__p[1];
    if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v1 = off_1EB5EE4F0;
  }
  size_t v5 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
  if (*(&off_1EB5EE4F0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  char v23 = 15;
  strcpy((char *)__p, "BootSessionUUID");
  uint64_t v6 = (os_unfair_lock_s *)(v1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 40));
  if (v23 >= 0) {
    char v7 = __p;
  }
  else {
    char v7 = (void **)__p[0];
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v28, (const char *)v7);
  uint64_t v8 = (const void *)(**(uint64_t (***)(uint64_t, uint64_t))v1)(v1, v28);
  if (v8)
  {
    ctu::cf::assign();
    CFRelease(v8);
  }
  MEMORY[0x1A62748E0](&v28);
  os_unfair_lock_unlock(v6);
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  char v9 = HIBYTE(__s1[2]);
  if (SHIBYTE(__s1[2]) >= 0) {
    uint64_t v10 = (void *)HIBYTE(__s1[2]);
  }
  else {
    uint64_t v10 = __s1[1];
  }
  char v11 = (void *)HIBYTE(v26);
  int v12 = SHIBYTE(v26);
  if (v26 < 0) {
    char v11 = v25;
  }
  if (v10 != v11)
  {
    BOOL v19 = 1;
    if ((SHIBYTE(v26) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_46;
  }
  if (v26 >= 0) {
    uint64_t v13 = (unsigned __int8 *)&v24;
  }
  else {
    uint64_t v13 = (unsigned __int8 *)v24;
  }
  if (SHIBYTE(__s1[2]) < 0)
  {
    BOOL v19 = memcmp(__s1[0], v13, (size_t)__s1[1]) != 0;
    goto LABEL_42;
  }
  if (HIBYTE(__s1[2]))
  {
    uint64_t v14 = HIBYTE(__s1[2]) - 1;
    long long v15 = __s1;
    do
    {
      int v17 = *(unsigned __int8 *)v15;
      long long v15 = (void **)((char *)v15 + 1);
      int v16 = v17;
      int v18 = *v13++;
      BOOL v19 = v16 != v18;
    }
    while (v16 == v18 && v14-- != 0);
LABEL_42:
    if ((v12 & 0x80000000) == 0) {
      goto LABEL_43;
    }
LABEL_46:
    operator delete(v24);
    if ((HIBYTE(__s1[2]) & 0x80) == 0) {
      return v19;
    }
    goto LABEL_47;
  }
  BOOL v19 = 0;
  if (SHIBYTE(v26) < 0) {
    goto LABEL_46;
  }
LABEL_43:
  if ((v9 & 0x80) == 0) {
    return v19;
  }
LABEL_47:
  operator delete(__s1[0]);
  return v19;
}

void sub_1A6117340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sys::isHardwareModelChanged(sys *this)
{
  BOOL v40 = 0;
  pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  if (!off_1EB5EE4F0)
  {
    SharedData::create_default_global(__dst);
    long long v2 = __dst[0];
    __dst[0] = 0uLL;
    long long v3 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
    off_1EB5EE4F0 = v2;
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    size_t v4 = (std::__shared_weak_count *)*((void *)&__dst[0] + 1);
    if (*((void *)&__dst[0] + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__dst[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  }
  std::string __p = v1;
  int v35 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
  if (*(&off_1EB5EE4F0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  size_t v5 = (const void *)*MEMORY[0x1E4F4C5D0];
  size_t v6 = strlen((const char *)*MEMORY[0x1E4F4C5D0]);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = operator new(v9 + 1);
    *((void *)&__dst[0] + 1) = v7;
    *(void *)&__dst[1] = v10 | 0x8000000000000000;
    *(void *)&__dst[0] = v8;
    goto LABEL_18;
  }
  BYTE7(__dst[1]) = v6;
  uint64_t v8 = __dst;
  if (v6) {
LABEL_18:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  os_unfair_lock_lock(v1 + 10);
  Preferences::getPreference<__CFDictionary const*>(v1, (const char *)__dst, &v40);
  os_unfair_lock_unlock(v1 + 10);
  if (SBYTE7(__dst[1]) < 0) {
    operator delete(*(void **)&__dst[0]);
  }
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
    BOOL v11 = v40;
    if (!v40) {
      return v11;
    }
  }
  else
  {
    BOOL v11 = v40;
    if (!v40) {
      return v11;
    }
  }
  CFTypeID v12 = CFGetTypeID((CFTypeRef)v11);
  if (v12 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFTypeRef cf = (CFTypeRef)v11;
  CFRetain((CFTypeRef)v11);
  v37[0] = 0xAAAAAAAAAAAAAAAALL;
  v37[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v37, (const __CFDictionary *)v11);
  memset(__dst, 170, 24);
  uint64_t v13 = (const void *)*MEMORY[0x1E4F4D2F8];
  size_t v14 = strlen((const char *)*MEMORY[0x1E4F4D2F8]);
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  long long v15 = (std::__shared_weak_count *)v14;
  if (v14 >= 0x17)
  {
    uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v17 = v14 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_p = operator new(v17 + 1);
    int v35 = v15;
    int64_t v36 = v18 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_35;
  }
  HIBYTE(v36) = v14;
  p_p = &__p;
  if (v14) {
LABEL_35:
  }
    memmove(p_p, v13, (size_t)v15);
  BOOL v19 = (const char *)*MEMORY[0x1E4F4C518];
  *((unsigned char *)&v15->__vftable + (void)p_p) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v41, v19);
  ctu::cf::map_adapter::getString();
  uint64_t v20 = (config::hw *)MEMORY[0x1A62748E0](&v41);
  if (SHIBYTE(v36) < 0) {
    operator delete(__p);
  }
  config::hw::product(v20);
  char v21 = BYTE7(__dst[1]);
  if ((SBYTE7(__dst[1]) & 0x80u) == 0) {
    uint64_t v22 = (std::__shared_weak_count *)BYTE7(__dst[1]);
  }
  else {
    uint64_t v22 = (std::__shared_weak_count *)*((void *)&__dst[0] + 1);
  }
  char v23 = (std::__shared_weak_count *)HIBYTE(v36);
  int v24 = SHIBYTE(v36);
  if (v36 < 0) {
    char v23 = v35;
  }
  if (v22 != v23)
  {
    BOOL v11 = 1;
    if ((SHIBYTE(v36) & 0x80000000) == 0) {
      goto LABEL_60;
    }
    goto LABEL_64;
  }
  if (v36 >= 0) {
    uint64_t v25 = (unsigned __int8 *)&__p;
  }
  else {
    uint64_t v25 = (unsigned __int8 *)__p;
  }
  if (SBYTE7(__dst[1]) < 0)
  {
    BOOL v11 = memcmp(*(const void **)&__dst[0], v25, *((size_t *)&__dst[0] + 1)) != 0;
    goto LABEL_59;
  }
  if (BYTE7(__dst[1]))
  {
    uint64_t v26 = BYTE7(__dst[1]) - 1;
    uint64_t v27 = (unsigned __int8 *)__dst;
    do
    {
      int v29 = *v27++;
      int v28 = v29;
      int v30 = *v25++;
      BOOL v11 = v28 != v30;
    }
    while (v28 == v30 && v26-- != 0);
LABEL_59:
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_60;
    }
LABEL_64:
    operator delete(__p);
    if ((BYTE7(__dst[1]) & 0x80) == 0)
    {
LABEL_61:
      MEMORY[0x1A6274930](v37);
      CFTypeRef v32 = cf;
      if (!cf) {
        return v11;
      }
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  BOOL v11 = 0;
  if (SHIBYTE(v36) < 0) {
    goto LABEL_64;
  }
LABEL_60:
  if ((v21 & 0x80) == 0) {
    goto LABEL_61;
  }
LABEL_65:
  operator delete(*(void **)&__dst[0]);
  MEMORY[0x1A6274930](v37);
  CFTypeRef v32 = cf;
  if (cf) {
LABEL_66:
  }
    CFRelease(v32);
  return v11;
}

void sub_1A61177CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
    MEMORY[0x1A6274930](&a15);
    ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a17);
    _Unwind_Resume(a1);
  }
  MEMORY[0x1A6274930](&a15);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a17);
  _Unwind_Resume(a1);
}

void sub_1A6117874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sys::isFWVersionChanged(unsigned __int8 *a1)
{
  CFTypeRef cf = 0;
  pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  long long v2 = (os_unfair_lock_s *)off_1EB5EE4F0;
  if (!off_1EB5EE4F0)
  {
    SharedData::create_default_global(__dst);
    long long v3 = __dst[0];
    __dst[0] = 0uLL;
    size_t v4 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
    off_1EB5EE4F0 = v3;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    size_t v5 = (std::__shared_weak_count *)*((void *)&__dst[0] + 1);
    if (*((void *)&__dst[0] + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__dst[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    long long v2 = (os_unfair_lock_s *)off_1EB5EE4F0;
  }
  std::string __p = v2;
  int64_t v36 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
  if (*(&off_1EB5EE4F0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  size_t v6 = (const void *)*MEMORY[0x1E4F4C5D0];
  size_t v7 = strlen((const char *)*MEMORY[0x1E4F4C5D0]);
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    uint64_t v9 = operator new(v10 + 1);
    *((void *)&__dst[0] + 1) = v8;
    *(void *)&__dst[1] = v11 | 0x8000000000000000;
    *(void *)&__dst[0] = v9;
    goto LABEL_18;
  }
  BYTE7(__dst[1]) = v7;
  uint64_t v9 = __dst;
  if (v7) {
LABEL_18:
  }
    memmove(v9, v6, v8);
  *((unsigned char *)v9 + v8) = 0;
  os_unfair_lock_lock(v2 + 10);
  Preferences::getPreference<__CFDictionary const*>(v2, (const char *)__dst, &cf);
  os_unfair_lock_unlock(v2 + 10);
  if (SBYTE7(__dst[1]) < 0) {
    operator delete(*(void **)&__dst[0]);
  }
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
    CFTypeRef v12 = cf;
    if (!cf) {
      return 0;
    }
  }
  else
  {
    CFTypeRef v12 = cf;
    if (!cf) {
      return 0;
    }
  }
  CFTypeID v13 = CFGetTypeID(v12);
  if (v13 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFTypeRef v39 = v12;
  CFRetain(v12);
  v38[0] = 0xAAAAAAAAAAAAAAAALL;
  v38[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v38, (const __CFDictionary *)v12);
  memset(__dst, 170, 24);
  size_t v14 = (const void *)*MEMORY[0x1E4F4D2F8];
  size_t v15 = strlen((const char *)*MEMORY[0x1E4F4D2F8]);
  if (v15 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  int v16 = (std::__shared_weak_count *)v15;
  if (v15 >= 0x17)
  {
    uint64_t v19 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v19 = v15 | 7;
    }
    uint64_t v20 = v19 + 1;
    p_p = operator new(v19 + 1);
    int64_t v36 = v16;
    unint64_t v37 = v20 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_34;
  }
  HIBYTE(v37) = v15;
  p_p = &__p;
  if (v15) {
LABEL_34:
  }
    memmove(p_p, v14, (size_t)v16);
  char v21 = (const char *)*MEMORY[0x1E4F4C770];
  *((unsigned char *)&v16->__vftable + (void)p_p) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v42, v21);
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v42);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  if ((SBYTE7(__dst[1]) & 0x80u) == 0) {
    uint64_t v23 = BYTE7(__dst[1]);
  }
  else {
    uint64_t v23 = *((void *)&__dst[0] + 1);
  }
  uint64_t v24 = a1[23];
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *((void *)a1 + 1);
  }
  if (v23 == v24)
  {
    if (v25 >= 0) {
      uint64_t v22 = a1;
    }
    else {
      uint64_t v22 = *(unsigned __int8 **)a1;
    }
    if ((BYTE7(__dst[1]) & 0x80) != 0)
    {
      CFTypeRef v32 = *(void **)&__dst[0];
      BOOL v18 = memcmp(*(const void **)&__dst[0], v22, *((size_t *)&__dst[0] + 1)) != 0;
      goto LABEL_59;
    }
    if (!BYTE7(__dst[1]))
    {
      BOOL v18 = 0;
      MEMORY[0x1A6274930](v38, v22);
      CFTypeRef v33 = v39;
      if (!v39) {
        return v18;
      }
      goto LABEL_61;
    }
    uint64_t v26 = BYTE7(__dst[1]) - 1;
    uint64_t v27 = (unsigned __int8 *)__dst;
    do
    {
      int v29 = *v27++;
      int v28 = v29;
      int v30 = *v22++;
      BOOL v18 = v28 != v30;
    }
    while (v28 == v30 && v26-- != 0);
    if ((BYTE7(__dst[1]) & 0x80) == 0) {
      goto LABEL_60;
    }
  }
  else
  {
    BOOL v18 = 1;
    if ((BYTE7(__dst[1]) & 0x80) == 0) {
      goto LABEL_60;
    }
  }
  CFTypeRef v32 = *(void **)&__dst[0];
LABEL_59:
  operator delete(v32);
LABEL_60:
  MEMORY[0x1A6274930](v38, v22);
  CFTypeRef v33 = v39;
  if (v39) {
LABEL_61:
  }
    CFRelease(v33);
  return v18;
}

BOOL sys::isOSVersionChanged(sys *this)
{
  BOOL v40 = 0;
  pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  if (!off_1EB5EE4F0)
  {
    SharedData::create_default_global(__dst);
    long long v2 = __dst[0];
    __dst[0] = 0uLL;
    long long v3 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
    off_1EB5EE4F0 = v2;
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    size_t v4 = (std::__shared_weak_count *)*((void *)&__dst[0] + 1);
    if (*((void *)&__dst[0] + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__dst[0] + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v1 = (os_unfair_lock_s *)off_1EB5EE4F0;
  }
  std::string __p = v1;
  int v35 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
  if (*(&off_1EB5EE4F0 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
  size_t v5 = (const void *)*MEMORY[0x1E4F4C5D0];
  size_t v6 = strlen((const char *)*MEMORY[0x1E4F4C5D0]);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    size_t v8 = operator new(v9 + 1);
    *((void *)&__dst[0] + 1) = v7;
    *(void *)&__dst[1] = v10 | 0x8000000000000000;
    *(void *)&__dst[0] = v8;
    goto LABEL_18;
  }
  BYTE7(__dst[1]) = v6;
  size_t v8 = __dst;
  if (v6) {
LABEL_18:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  os_unfair_lock_lock(v1 + 10);
  Preferences::getPreference<__CFDictionary const*>(v1, (const char *)__dst, &v40);
  os_unfair_lock_unlock(v1 + 10);
  if (SBYTE7(__dst[1]) < 0) {
    operator delete(*(void **)&__dst[0]);
  }
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
    BOOL v11 = v40;
    if (!v40) {
      return v11;
    }
  }
  else
  {
    BOOL v11 = v40;
    if (!v40) {
      return v11;
    }
  }
  CFTypeID v12 = CFGetTypeID((CFTypeRef)v11);
  if (v12 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFTypeRef cf = (CFTypeRef)v11;
  CFRetain((CFTypeRef)v11);
  v37[0] = 0xAAAAAAAAAAAAAAAALL;
  v37[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v37, (const __CFDictionary *)v11);
  memset(__dst, 170, 24);
  CFTypeID v13 = (const void *)*MEMORY[0x1E4F4D2F8];
  size_t v14 = strlen((const char *)*MEMORY[0x1E4F4D2F8]);
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v15 = (std::__shared_weak_count *)v14;
  if (v14 >= 0x17)
  {
    uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v17 = v14 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_p = operator new(v17 + 1);
    int v35 = v15;
    int64_t v36 = v18 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_35;
  }
  HIBYTE(v36) = v14;
  p_p = &__p;
  if (v14) {
LABEL_35:
  }
    memmove(p_p, v13, (size_t)v15);
  uint64_t v19 = (const char *)*MEMORY[0x1E4F4C778];
  *((unsigned char *)&v15->__vftable + (void)p_p) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v41, v19);
  ctu::cf::map_adapter::getString();
  uint64_t v20 = (config::build *)MEMORY[0x1A62748E0](&v41);
  if (SHIBYTE(v36) < 0) {
    operator delete(__p);
  }
  config::build::version(v20);
  char v21 = BYTE7(__dst[1]);
  if ((SBYTE7(__dst[1]) & 0x80u) == 0) {
    uint64_t v22 = (std::__shared_weak_count *)BYTE7(__dst[1]);
  }
  else {
    uint64_t v22 = (std::__shared_weak_count *)*((void *)&__dst[0] + 1);
  }
  uint64_t v23 = (std::__shared_weak_count *)HIBYTE(v36);
  int v24 = SHIBYTE(v36);
  if (v36 < 0) {
    uint64_t v23 = v35;
  }
  if (v22 != v23)
  {
    BOOL v11 = 1;
    if ((SHIBYTE(v36) & 0x80000000) == 0) {
      goto LABEL_60;
    }
    goto LABEL_64;
  }
  if (v36 >= 0) {
    int v25 = (unsigned __int8 *)&__p;
  }
  else {
    int v25 = (unsigned __int8 *)__p;
  }
  if (SBYTE7(__dst[1]) < 0)
  {
    BOOL v11 = memcmp(*(const void **)&__dst[0], v25, *((size_t *)&__dst[0] + 1)) != 0;
    goto LABEL_59;
  }
  if (BYTE7(__dst[1]))
  {
    uint64_t v26 = BYTE7(__dst[1]) - 1;
    uint64_t v27 = (unsigned __int8 *)__dst;
    do
    {
      int v29 = *v27++;
      int v28 = v29;
      int v30 = *v25++;
      BOOL v11 = v28 != v30;
    }
    while (v28 == v30 && v26-- != 0);
LABEL_59:
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_60;
    }
LABEL_64:
    operator delete(__p);
    if ((BYTE7(__dst[1]) & 0x80) == 0)
    {
LABEL_61:
      MEMORY[0x1A6274930](v37);
      CFTypeRef v32 = cf;
      if (!cf) {
        return v11;
      }
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  BOOL v11 = 0;
  if (SHIBYTE(v36) < 0) {
    goto LABEL_64;
  }
LABEL_60:
  if ((v21 & 0x80) == 0) {
    goto LABEL_61;
  }
LABEL_65:
  operator delete(*(void **)&__dst[0]);
  MEMORY[0x1A6274930](v37);
  CFTypeRef v32 = cf;
  if (cf) {
LABEL_66:
  }
    CFRelease(v32);
  return v11;
}

void sub_1A6118194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
    MEMORY[0x1A6274930](&a15);
    ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a17);
    _Unwind_Resume(a1);
  }
  MEMORY[0x1A6274930](&a15);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a17);
  _Unwind_Resume(a1);
}

void sub_1A611823C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void SharedData::create_default_global(void *a1@<X8>)
{
  std::string __p = operator new(0x60uLL);
  strcpy((char *)__p, "/private/var/wireless/Library/Preferences/com.apple.AppleBasebandManager.Statistics.plist");
  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blksize_t size = v3;
  *(timespec *)v10.st_qspare = v3;
  v10.st_birthtimespec = v3;
  *(timespec *)&v10.st_size_t size = v3;
  v10.st_mtimespec = v3;
  v10.st_ctimespec = v3;
  *(timespec *)&v10.st_uid = v3;
  v10.st_atimespec = v3;
  long long v9 = xmmword_1A61F8770;
  *(timespec *)&v10.st_dev = v3;
  if (!stat((const char *)__p, &v10))
  {
    size_t v5 = v9 >= 0 ? (const std::__fs::filesystem::path *)&__p : (const std::__fs::filesystem::path *)__p;
    if (remove(v5, v4))
    {
      if (v9 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      unlink(p_p);
    }
  }
  size_t v7 = operator new(0x30uLL);
  MEMORY[0x1A6274940](v7, @"com.apple.AppleBasebandManager.data", *MEMORY[0x1E4F1D3F0]);
  v7[3] = 0;
  v7[4] = 0;
  *((_DWORD *)v7 + 10) = 0;
  std::shared_ptr<SharedData>::shared_ptr[abi:ne180100]<SharedData,void>(a1, (uint64_t)v7);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
}

void sub_1A611836C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  operator delete(v15);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::shared_ptr<SharedData>::shared_ptr[abi:ne180100]<SharedData,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  size_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B160;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (a2)
  {
    size_t v6 = *(std::__shared_weak_count **)(a2 + 32);
    if (v6)
    {
      if (v6->__shared_owners_ == -1)
      {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        *(void *)(a2 + 24) = a2;
        *(void *)(a2 + 32) = v4;
        std::__shared_weak_count::__release_weak(v6);
        if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_7;
        }
      }
    }
    else
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 24) = a2;
      *(void *)(a2 + 32) = v4;
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_7:
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
  return a1;
}

void sub_1A61184CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<SharedData>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<SharedData>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    timespec v3 = *(std::__shared_weak_count **)(v2 + 32);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    size_t v4 = (void *)MEMORY[0x1A6274950](v2);
    operator delete(v4);
  }
  return a1;
}

void std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    timespec v3 = (void *)MEMORY[0x1A6274950](v1);
    operator delete(v3);
  }
}

uint64_t std::__shared_ptr_pointer<SharedData *,std::shared_ptr<SharedData>::__shared_ptr_default_delete<SharedData,SharedData>,std::allocator<SharedData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001A61F87FBLL) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001A61F87FBLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A61F87FBLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A61F87FBLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t ctu::PthreadMutexGuardPolicy<SharedData>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t SharedData::setPreference<std::string>(std::string const&,std::string)::{lambda(void)#1}::operator()(char **a1)
{
  uint64_t v1 = a1[1];
  uint64_t v2 = a1[2];
  uint64_t v3 = *a1;
  if (v1[23] < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v1, *((void *)v1 + 1));
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    long long v4 = *(_OWORD *)v1;
    __p.__r_.__value_.__r.__words[2] = *((void *)v1 + 2);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v4;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      std::string v9 = __p;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(&v9, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
LABEL_6:
  if (v3[23] >= 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(char **)v3;
  }
  uint64_t v6 = ctu::cf::plist_adapter::set<std::string>((int)v2, (uint64_t)&v9, v5);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v9.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v6;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    return v6;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  return v6;
}

void sub_1A61187EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((a14 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ctu::cf::plist_adapter::set<std::string>(int a1, uint64_t a2, char *a3)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v7, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v7 = *(std::string *)a2;
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v6, a3);
  uint64_t v4 = ctu::cf::plist_adapter::set<std::string>();
  MEMORY[0x1A62748E0](&v6);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return v4;
}

uint64_t ctu::cf::plist_adapter::set<std::string>()
{
  return 0;
}

void sub_1A61189E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t Preferences::getPreference<__CFDictionary const*>(uint64_t (***a1)(void, uint64_t), const char *a2, void *a3)
{
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v9, a2);
  size_t v5 = (const void *)(**a1)(a1, v9);
  uint64_t v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == CFDictionaryGetTypeID()) {
      *a3 = v6;
    }
    CFRelease(v6);
  }
  return MEMORY[0x1A62748E0](&v9);
}

uint64_t __cxx_global_var_init_0()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<SharedData>::~PthreadMutexGuardPolicy, &ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance, &dword_1A609F000);
  }
  return result;
}

_DWORD *abm::DirectoryQuery::DirectoryQuery(_DWORD *a1, int a2, long long *a3)
{
  *a1 = a2;
  uint64_t v4 = (std::string *)(a1 + 2);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    v4->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  a1[8] = 0;
  return a1;
}

{
  std::string *v4;
  long long v5;

  *a1 = a2;
  uint64_t v4 = (std::string *)(a1 + 2);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    v4->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
  a1[8] = 0;
  return a1;
}

uint64_t abm::FileProperties::FileProperties(uint64_t a1, int a2, long long *a3, char a4, int a5)
{
  *(_DWORD *)a1 = a2;
  size_t v8 = (std::string *)(a1 + 8);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    v8->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(unsigned char *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  return a1;
}

{
  std::string *v8;
  long long v9;

  *(_DWORD *)a1 = a2;
  size_t v8 = (std::string *)(a1 + 8);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    v8->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(unsigned char *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  return a1;
}

uint64_t abm::FileProperties::isDirectory(abm::FileProperties *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t abm::FileProperties::getDir(abm::FileProperties *this)
{
  return *(unsigned int *)this;
}

uint64_t abm::FileProperties::getState(abm::FileProperties *this)
{
  return *((unsigned int *)this + 9);
}

void abm::FileProperties::getName(abm::FileProperties *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 31) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 1), *((void *)this + 2));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 8);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 3);
  }
}

std::string *abm::FileProperties::getPath@<X0>(abm::FileProperties *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = (const char *)abm::sBaseDirectories[2 * *(unsigned int *)this];
  uint64_t result = (std::string *)strlen(v4);
  int v6 = *((char *)this + 31);
  if (v6 >= 0) {
    size_t v7 = *((unsigned __int8 *)this + 31);
  }
  else {
    size_t v7 = *((void *)this + 2);
  }
  unint64_t v8 = (unint64_t)result + v7;
  memset(a2, 170, sizeof(std::string));
  if ((unint64_t)result + v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v9 = (size_t)result;
  if (v8 <= 0x16)
  {
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
    a2->__r_.__value_.__r.__words[0] = 0;
    stat v10 = a2;
    *((unsigned char *)&a2->__r_.__value_.__s + 23) = v8;
    if (!result) {
      goto LABEL_12;
    }
LABEL_11:
    uint64_t result = (std::string *)memcpy(v10, v4, v9);
    goto LABEL_12;
  }
  uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v8 | 7) != 0x17) {
    uint64_t v11 = v8 | 7;
  }
  uint64_t v12 = v11 + 1;
  uint64_t result = (std::string *)operator new(v11 + 1);
  stat v10 = result;
  a2->__r_.__value_.__l.__size_ = v8;
  a2->__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
  a2->__r_.__value_.__r.__words[0] = (std::string::size_type)result;
  if (v9) {
    goto LABEL_11;
  }
LABEL_12:
  if (v7)
  {
    if (v6 >= 0) {
      CFTypeID v13 = (char *)this + 8;
    }
    else {
      CFTypeID v13 = (char *)*((void *)this + 1);
    }
    uint64_t result = (std::string *)memmove((char *)v10 + v9, v13, v7);
  }
  v10->__r_.__value_.__s.__data_[v9 + v7] = 0;
  if (*((unsigned char *)this + 32)) {
    return std::string::append(a2, "/", 1uLL);
  }
  return result;
}

void sub_1A6118E1C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t abm::FileProperties::getDirPath@<X0>(abm::FileProperties *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (const char *)abm::sBaseDirectories[2 * *(unsigned int *)this];
  unint64_t result = strlen(v3);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = result;
  if (result >= 0x17)
  {
    uint64_t v6 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v6 = result | 7;
    }
    uint64_t v7 = v6 + 1;
    unint64_t v8 = operator new(v6 + 1);
    a2[1] = v5;
    a2[2] = v7 | 0x8000000000000000;
    *a2 = v8;
    a2 = v8;
  }
  else
  {
    *((unsigned char *)a2 + 23) = result;
    if (!result)
    {
      *(unsigned char *)a2 = 0;
      return result;
    }
  }
  unint64_t result = (unint64_t)memmove(a2, v3, v5);
  *((unsigned char *)a2 + v5) = 0;
  return result;
}

uint64_t abm::FileProperties::setState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

void abm::asString(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v2 = *a1;
  if (*(char *)(*a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(v2 + 8), *(void *)(v2 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v2 + 8);
    a2->__r_.__value_.__r.__words[2] = *(void *)(v2 + 24);
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v3;
  }
}

size_t abm::baseDirectoryString@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  long long v3 = (const char *)abm::sBaseDirectories[2 * a1];
  size_t result = strlen(v3);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = result;
  if (result >= 0x17)
  {
    uint64_t v6 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v6 = result | 7;
    }
    uint64_t v7 = v6 + 1;
    unint64_t v8 = operator new(v6 + 1);
    a2[1] = v5;
    a2[2] = v7 | 0x8000000000000000;
    *a2 = v8;
    a2 = v8;
  }
  else
  {
    *((unsigned char *)a2 + 23) = result;
    if (!result)
    {
      *(unsigned char *)a2 = 0;
      return result;
    }
  }
  size_t result = (size_t)memmove(a2, v3, v5);
  *((unsigned char *)a2 + v5) = 0;
  return result;
}

void abm::findFiles(unsigned int **a1@<X0>, unsigned int a2@<W1>, char ***a3@<X8>)
{
  *a3 = (char **)0xAAAAAAAAAAAAAAAALL;
  a3[1] = (char **)0xAAAAAAAAAAAAAAAALL;
  size_t v5 = (char **)operator new(0x30uLL);
  v5[1] = 0;
  v5[2] = 0;
  *size_t v5 = (char *)&unk_1EFB0B1B0;
  v5[4] = 0;
  v5[5] = 0;
  a3[1] = v5;
  v5[3] = 0;
  v72 = a3;
  *a3 = v5 + 3;
  uint64_t v6 = *a1;
  v70 = a1;
  if (*a1 != a1[1])
  {
    while (1)
    {
      std::string __p = 0;
      v88 = 0;
      uint64_t v89 = 0;
      memset(&__dst, 170, sizeof(__dst));
      unint64_t v8 = (const char *)abm::sBaseDirectories[2 * *v6];
      size_t v9 = strlen(v8);
      if (v9 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v10 = v9;
      v71 = v6;
      if (v9 >= 0x17) {
        break;
      }
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9;
      p_dst = &__dst;
      if (v9) {
        goto LABEL_13;
      }
LABEL_14:
      p_dst->__r_.__value_.__s.__data_[v10] = 0;
      size_t v14 = (const std::string::value_type **)(v6 + 2);
      memset(&v85, 170, sizeof(v85));
      if (*((char *)v6 + 31) < 0)
      {
        std::string::size_type v16 = *((void *)v6 + 2);
        if (v16)
        {
          std::string::__init_copy_ctor_external(&v85, *v14, v16);
          goto LABEL_28;
        }
      }
      else if (*((unsigned char *)v6 + 31))
      {
        long long v15 = *(_OWORD *)v14;
        v85.__r_.__value_.__r.__words[2] = *((void *)v6 + 3);
        *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v15;
        goto LABEL_28;
      }
      uint64_t v17 = (const char *)abm::sBaseDirectories[2 * *v6 + 1];
      size_t v18 = strlen(v17);
      if (v18 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v19 = v18;
      if (v18 >= 0x17)
      {
        uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v18 | 7) != 0x17) {
          uint64_t v21 = v18 | 7;
        }
        uint64_t v22 = v21 + 1;
        uint64_t v20 = operator new(v21 + 1);
        v85.__r_.__value_.__l.__size_ = v19;
        v85.__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
        v85.__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
      }
      else
      {
        *((unsigned char *)&v85.__r_.__value_.__s + 23) = v18;
        uint64_t v20 = &v85;
        if (!v18) {
          goto LABEL_27;
        }
      }
      memmove(v20, v17, v19);
LABEL_27:
      *((unsigned char *)v20 + v19) = 0;
LABEL_28:
      *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v83[32] = v23;
      long long v84 = v23;
      *(_OWORD *)v83 = v23;
      *(_OWORD *)&v83[16] = v23;
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)v83, (uint64_t)&v85, 0);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v82, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string v82 = __dst;
      }
      std::locale::locale(&v76, (const std::locale *)v83);
      long long v77 = *(_OWORD *)&v83[8];
      long long v78 = *(_OWORD *)&v83[24];
      uint64_t v79 = *(void *)&v83[40];
      v80 = (std::__shared_weak_count *)v84;
      int v24 = v71;
      if ((void)v84) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v84 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v81 = *((void *)&v84 + 1);
      support::fs::getFilteredFiles((const char *)&v82, (uint64_t)&v76, (uint64_t)&__p, a2);
      int v25 = v80;
      if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
        std::locale::~locale(&v76);
        if ((SHIBYTE(v82.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_37;
        }
LABEL_36:
        operator delete(v82.__r_.__value_.__l.__data_);
        goto LABEL_37;
      }
      std::locale::~locale(&v76);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_36;
      }
LABEL_37:
      for (unsigned int i = (const std::string::value_type *)__p; i != (const std::string::value_type *)v88; i += 24)
      {
        uint64_t v27 = *v72;
        int v28 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t size = __dst.__r_.__value_.__l.__size_;
        }
        int v30 = i[23];
        if (v30 >= 0) {
          size_t v31 = *((unsigned __int8 *)i + 23);
        }
        else {
          size_t v31 = *((void *)i + 1);
        }
        unint64_t v32 = v31 + size;
        memset(v73, 170, sizeof(v73));
        if (v31 + size > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        if (v32 <= 0x16)
        {
          memset(v73, 0, sizeof(v73));
          CFTypeRef v33 = (char *)v73;
          HIBYTE(v73[2]) = v31 + size;
          if (!size) {
            goto LABEL_55;
          }
LABEL_51:
          if (v28 >= 0) {
            uint64_t v34 = &__dst;
          }
          else {
            uint64_t v34 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          memmove(v33, v34, size);
          goto LABEL_55;
        }
        uint64_t v40 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v32 | 7) != 0x17) {
          uint64_t v40 = v32 | 7;
        }
        uint64_t v41 = v40 + 1;
        CFTypeRef v33 = (char *)operator new(v40 + 1);
        v73[1] = (void *)(v31 + size);
        v73[2] = (void *)(v41 | 0x8000000000000000);
        v73[0] = v33;
        int v24 = v71;
        if (size) {
          goto LABEL_51;
        }
LABEL_55:
        int v35 = &v33[size];
        if (v31)
        {
          if (v30 >= 0) {
            int64_t v36 = i;
          }
          else {
            int64_t v36 = *(const std::string::value_type **)i;
          }
          memmove(v35, v36, v31);
        }
        v35[v31] = 0;
        v37.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v37.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v90.st_blksize_t size = v37;
        *(timespec *)v90.st_qspare = v37;
        v90.st_birthtimespec = v37;
        *(timespec *)&v90.st_size_t size = v37;
        v90.st_mtimespec = v37;
        v90.st_ctimespec = v37;
        *(timespec *)&v90.st_uid = v37;
        v90.st_atimespec = v37;
        *(timespec *)&v90.st_dev = v37;
        if (SHIBYTE(v73[2]) >= 0) {
          int v38 = v73;
        }
        else {
          int v38 = (void **)v73[0];
        }
        if (stat((const char *)v38, &v90)
          || (SHIBYTE(v73[2]) >= 0 ? (uint64_t v42 = v73) : (uint64_t v42 = (void **)v73[0]),
              size_t v43 = opendir((const char *)v42),
              (unint64_t v44 = v43) == 0))
        {
          BOOL v39 = 0;
        }
        else
        {
          uint64_t v45 = readdir(v43);
          closedir(v44);
          BOOL v39 = v45 != 0;
        }
        BOOL v46 = (char *)operator new(0x40uLL);
        *((void *)v46 + 1) = 0;
        *((void *)v46 + 2) = 0;
        *(void *)BOOL v46 = &unk_1EFB0B200;
        *((_DWORD *)v46 + 6) = *v24;
        uint64_t v47 = v46 + 24;
        v48 = (std::string *)(v46 + 32);
        if (i[23] < 0)
        {
          std::string::__init_copy_ctor_external(v48, *(const std::string::value_type **)i, *((void *)i + 1));
        }
        else
        {
          long long v49 = *(_OWORD *)i;
          *((void *)v46 + 6) = *((void *)i + 2);
          *(_OWORD *)&v48->__r_.__value_.__l.__data_ = v49;
        }
        v46[56] = v39;
        *((_DWORD *)v46 + 15) = 1;
        v74 = v46 + 24;
        v75 = (std::__shared_weak_count *)v46;
        std::string::value_type v50 = v27[1];
        unint64_t v51 = (unint64_t)v27[2];
        if ((unint64_t)v50 >= v51)
        {
          uint64_t v53 = (v50 - *v27) >> 4;
          unint64_t v54 = v53 + 1;
          if ((unint64_t)(v53 + 1) >> 60) {
            std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v55 = v51 - (void)*v27;
          if (v55 >> 3 > v54) {
            unint64_t v54 = v55 >> 3;
          }
          if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v56 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v56 = v54;
          }
          if (v56 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v57 = (char *)operator new(16 * v56);
          stat v58 = &v57[16 * v53];
          uint64_t v59 = &v57[16 * v56];
          *(void *)stat v58 = v47;
          *((void *)v58 + 1) = v46;
          v74 = 0;
          v75 = 0;
          std::string v52 = v58 + 16;
          std::string v60 = *v27;
          std::string v61 = v27[1];
          if (v61 == *v27)
          {
            *uint64_t v27 = v58;
            v27[1] = v52;
            std::vector<std::ssub_match> v27[2] = v59;
          }
          else
          {
            do
            {
              long long v62 = *((_OWORD *)v61 - 1);
              v61 -= 16;
              *((_OWORD *)v58 - 1) = v62;
              v58 -= 16;
              *(void *)std::string v61 = 0;
              *((void *)v61 + 1) = 0;
            }
            while (v61 != v60);
            std::string v61 = *v27;
            uint64_t v63 = v27[1];
            *uint64_t v27 = v58;
            v27[1] = v52;
            std::vector<std::ssub_match> v27[2] = v59;
            while (v63 != v61)
            {
              uint64_t v64 = (std::__shared_weak_count *)*((void *)v63 - 1);
              if (v64 && !atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
                std::__shared_weak_count::__release_weak(v64);
              }
              v63 -= 16;
            }
          }
          if (v61) {
            operator delete(v61);
          }
        }
        else
        {
          *(void *)std::string::value_type v50 = v47;
          *((void *)v50 + 1) = v46;
          std::string v52 = v50 + 16;
          v74 = 0;
          v75 = 0;
        }
        v27[1] = v52;
        long long v65 = v75;
        if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
          std::__shared_weak_count::__release_weak(v65);
        }
        if (SHIBYTE(v73[2]) < 0) {
          operator delete(v73[0]);
        }
      }
      v66 = (std::__shared_weak_count *)v84;
      if ((void)v84 && !atomic_fetch_add((atomic_ullong *volatile)(v84 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
      std::locale::~locale((std::locale *)v83);
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v85.__r_.__value_.__l.__data_);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_108;
        }
LABEL_105:
        std::string v67 = (void **)__p;
        if (__p)
        {
LABEL_109:
          std::string v68 = v88;
          uint64_t v7 = v67;
          if (v88 != v67)
          {
            do
            {
              if (*((char *)v68 - 1) < 0) {
                operator delete(*(v68 - 3));
              }
              v68 -= 3;
            }
            while (v68 != v67);
            uint64_t v7 = __p;
          }
          v88 = v67;
          operator delete(v7);
        }
      }
      else
      {
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_105;
        }
LABEL_108:
        operator delete(__dst.__r_.__value_.__l.__data_);
        std::string v67 = (void **)__p;
        if (__p) {
          goto LABEL_109;
        }
      }
      uint64_t v6 = v24 + 10;
      if (v6 == v70[1]) {
        return;
      }
    }
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v10;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    uint64_t v6 = v71;
LABEL_13:
    memmove(p_dst, v8, v10);
    goto LABEL_14;
  }
}

void sub_1A61198DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if ((a52 & 0x80000000) == 0)
  {
    std::vector<std::string>::~vector[abi:ne180100](&v53);
    ((void (*)())std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100])();
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A61198BCLL);
}

void sub_1A61198EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if ((a52 & 0x80000000) == 0) {
    JUMPOUT(0x1A61198F8);
  }
  JUMPOUT(0x1A61198BCLL);
}

void sub_1A6119910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B1B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B1B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<abm::FileProperties>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        size_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<abm::FileProperties>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::FileProperties>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B200;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<abm::FileProperties>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void _GLOBAL__sub_I_HelperTaskUtils_cpp()
{
  abm::sBaseDirectories = (uint64_t)abm::trace::kTrashFolder[0];
  *(void *)algn_1EB5EEC08 = ".*";
  qword_1EB5EEC10 = (uint64_t)abm::trace::kScratchFolder[0];
  unk_1EB5EEC18 = ".*";
  qword_1EB5EEC20 = (uint64_t)"/var/wireless/Library/Logs/abm.workspace/";
  unk_1EB5EEC28 = ".*";
  qword_1EB5EEC30 = (uint64_t)"/var/mobile/Library/Logs/CrashReporter/Baseband/";
  unk_1EB5EEC38 = ".*";
  qword_1EB5EEC40 = (uint64_t)"/var/wireless/Library/Logs/";
  unk_1EB5EEC48 = "^\b$";
  qword_1EB5EEC50 = (uint64_t)"/var/wireless/Library/Logs/CrashReporter/";
  unk_1EB5EEC58 = "^CommCenter.*";
  qword_1EB5EEC60 = (uint64_t)abm::trace::kSnapshotFolder[0];
  unk_1EB5EEC68 = ".*";
  qword_1EB5EEC70 = (uint64_t)abm::trace::kMobileBasebandServicesFolder[0];
  unk_1EB5EEC78 = ".*";
}

void abm::CellularLoggingEUR::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, void *a4@<X8>)
{
}

uint64_t abm::CellularLoggingEUR::CellularLoggingEUR(uint64_t a1, uint64_t *a2, uint64_t *a3, dispatch_object_t *a4)
{
  size_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v12 = *a2;
  uint64_t v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *a3;
  uint64_t v6 = (std::__shared_weak_count *)a3[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v8 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  *(void *)a1 = &unk_1EFB0CB40;
  size_t v14 = "carriercellularlogging.modem";
  ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>((void *)a1, &v14, &v12);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)a1 = &unk_1EFB0CB40;
  *(void *)(a1 + 88) = v7;
  *(void *)(a1 + 96) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v9 = v13;
  *(void *)(a1 + 104) = v12;
  *(void *)(a1 + 112) = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = v8;
  if (!v8)
  {
    *(unsigned char *)(a1 + 128) = 0;
    if (!v6) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  dispatch_retain(v8);
  *(unsigned char *)(a1 + 128) = 0;
  dispatch_release(v8);
  if (v6) {
LABEL_13:
  }
    std::__shared_weak_count::__release_weak(v6);
LABEL_14:
  std::string::size_type v10 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *(void *)a1 = &unk_1EFB0B250;
  *(_WORD *)(a1 + 129) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  return a1;
}

void sub_1A6119D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v11)
  {
    dispatch_release(v11);
    if (!v10)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
      _Unwind_Resume(a1);
    }
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::~CellularLoggingEUR(void **this)
{
  *this = &unk_1EFB0B250;
  if ((*((char *)this + 279) & 0x80000000) == 0)
  {
    if ((*((char *)this + 247) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    operator delete(this[28]);
    uint64_t v2 = (std::__shared_weak_count *)this[26];
    if (!v2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  operator delete(this[32]);
  if (*((char *)this + 247) < 0) {
    goto LABEL_6;
  }
LABEL_3:
  uint64_t v2 = (std::__shared_weak_count *)this[26];
  if (!v2)
  {
LABEL_8:
    uint64_t v3 = (std::__shared_weak_count *)this[23];
    if (!v3) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
LABEL_7:
  if (atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  uint64_t v3 = (std::__shared_weak_count *)this[23];
  if (!v3) {
    goto LABEL_12;
  }
LABEL_9:
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_12:
  uint64_t v4 = (std::__shared_weak_count *)this[21];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if ((*((char *)this + 159) & 0x80000000) == 0)
    {
LABEL_15:
      size_t v5 = (abm::CellularLoggingCommon *)this;
      goto LABEL_17;
    }
  }
  else if ((*((char *)this + 159) & 0x80000000) == 0)
  {
    goto LABEL_15;
  }
  operator delete(this[17]);
  size_t v5 = (abm::CellularLoggingCommon *)this;

LABEL_17:
  abm::CellularLoggingCommon::~CellularLoggingCommon(v5);
}

{
  void *v1;
  uint64_t vars8;

  abm::CellularLoggingEUR::~CellularLoggingEUR(this);

  operator delete(v1);
}

uint64_t abm::CellularLoggingEUR::start(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  xpc_object_t v4 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  BOOL v5 = abm::CellularLoggingCommon::start();
  xpc_release(v4);
  uint64_t v110 = 0;
  if (!v5)
  {
    size_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Failed creating path", (uint8_t *)&buf, 2u);
    }
    return 0;
  }
  memset(&v109, 170, sizeof(v109));
  char v108 = 4;
  strcpy((char *)v107, "Mode");
  abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v107, &v109);
  if (v108 < 0) {
    operator delete(v107[0]);
  }
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&v109, &buf, 0)) {
    *(_DWORD *)(a1 + 196) = buf.__r_.__value_.__l.__data_;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(int *)(a1 + 196);
    if (v7 > 4) {
      unint64_t v8 = "Unknown";
    }
    else {
      unint64_t v8 = off_1E5C472A0[v7];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Previous trace mode: %s", (uint8_t *)&buf, 0xCu);
  }
  char v106 = 7;
  strcpy((char *)v105, "Enabled");
  abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v105, &buf);
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }
  std::string v109 = buf;
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
  buf.__r_.__value_.__s.__data_[0] = 0;
  if (v106 < 0) {
    operator delete(v105[0]);
  }
  BOOL v104 = 0;
  util::convert<BOOL>(&v109, &v104, 0);
  if (*(unsigned char *)(a1 + 130)) {
    *(unsigned char *)(a1 + 130) = 0;
  }
  BOOL v11 = v104;
  *(unsigned char *)(a1 + 129) = v104;
  *(unsigned char *)(a1 + 130) = 1;
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = "true";
    if (!v11) {
      uint64_t v13 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
    _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Previous trace enabled: %s", (uint8_t *)&buf, 0xCu);
  }
  char v103 = 9;
  strcpy((char *)v102, "High_Tput");
  abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v102, &buf);
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }
  std::string v109 = buf;
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
  buf.__r_.__value_.__s.__data_[0] = 0;
  if (v103 < 0) {
    operator delete(v102[0]);
  }
  size_t v14 = (unsigned char *)(a1 + 131);
  util::convert<BOOL>(&v109, (BOOL *)(a1 + 131), 0);
  long long v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*v14) {
      std::string::size_type v16 = "true";
    }
    else {
      std::string::size_type v16 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
    _os_log_impl(&dword_1A609F000, v15, OS_LOG_TYPE_DEFAULT, "#I Previous trace QDSS enabled: %s", (uint8_t *)&buf, 0xCu);
  }
  char v101 = 12;
  strcpy((char *)__p, "Data_Logging");
  abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)__p, &buf);
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v109.__r_.__value_.__l.__data_);
  }
  std::string v109 = buf;
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
  buf.__r_.__value_.__s.__data_[0] = 0;
  if (v101 < 0) {
    operator delete(__p[0]);
  }
  util::convert<BOOL>(&v109, (BOOL *)(a1 + 132), 0);
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 132)) {
      size_t v18 = "true";
    }
    else {
      size_t v18 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Previous trace ADPL enabled: %s", (uint8_t *)&buf, 0xCu);
  }
  char v99 = 4;
  strcpy((char *)v98, "File");
  abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v98, &buf);
  std::string::size_type v19 = (void **)(a1 + 256);
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*v19);
  }
  *(_OWORD *)std::string::size_type v19 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  *(void *)(a1 + 272) = *((void *)&buf.__r_.__value_.__l + 2);
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
  buf.__r_.__value_.__s.__data_[0] = 0;
  if (v99 < 0) {
    operator delete(v98[0]);
  }
  xpc_object_t value = xpc_dictionary_get_value(*a2, "kKeyConfigName");
  xpc_object_t object = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  uint64_t v21 = (void **)(a1 + 224);
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*v21);
  }
  *(_OWORD *)uint64_t v21 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  *(void *)(a1 + 240) = *((void *)&buf.__r_.__value_.__l + 2);
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
  buf.__r_.__value_.__s.__data_[0] = 0;
  xpc_release(object);
  uint64_t v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 279) < 0)
    {
      std::string::size_type v19 = (void **)*v19;
      long long v23 = (void *)(a1 + 224);
      if ((*(char *)(a1 + 247) & 0x80000000) == 0) {
        goto LABEL_57;
      }
    }
    else
    {
      long long v23 = (void *)(a1 + 224);
      if ((*(char *)(a1 + 247) & 0x80000000) == 0)
      {
LABEL_57:
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v23;
        _os_log_impl(&dword_1A609F000, v22, OS_LOG_TYPE_DEFAULT, "#I Previous trace DMC: %s, Current trace DMC: %s", (uint8_t *)&buf, 0x16u);
        goto LABEL_58;
      }
    }
    long long v23 = *v21;
    goto LABEL_57;
  }
LABEL_58:
  xpc_object_t v24 = *a2;
  xpc_object_t v96 = v24;
  if (v24) {
    xpc_retain(v24);
  }
  else {
    xpc_object_t v96 = xpc_null_create();
  }
  int v25 = (std::string::size_type *)(a1 + 248);
  BOOL FileSize = abm::CellularLoggingCommon::getFileSize(a1, &v96, (uint64_t *)(a1 + 248));
  xpc_release(v96);
  xpc_object_t v96 = 0;
  if (!FileSize)
  {
    timespec v37 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    unint64_t v56 = "Failed to get file size";
    goto LABEL_173;
  }
  unint64_t v28 = *v25;
  int v29 = (capabilities::abs *)capabilities::radio::vendor(v27);
  int shouldUseMinBasebandTransportIOReadSize = capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v29);
  unint64_t v31 = 0x8000;
  if (shouldUseMinBasebandTransportIOReadSize) {
    unint64_t v31 = 0x4000;
  }
  if (v28 >= v31)
  {
    std::string::size_type v35 = *v25;
    if ((*v25 & (*v25 - 1)) != 0) {
      goto LABEL_70;
    }
LABEL_78:
    char v95 = 8;
    strcpy((char *)v94, "FileSize");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v94, &buf);
    if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v109.__r_.__value_.__l.__data_);
    }
    std::string v109 = buf;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
    buf.__r_.__value_.__s.__data_[0] = 0;
    if (v95 < 0) {
      operator delete(v94[0]);
    }
    LODWORD(object) = 0;
    util::convert<unsigned int>(&v109, &object, 0);
    BOOL v39 = *(NSObject **)(a1 + 40);
    BOOL v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if (v40)
    {
      std::string::size_type v41 = *v25 >> 10;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = object >> 10;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v41;
      _os_log_impl(&dword_1A609F000, v39, OS_LOG_TYPE_DEFAULT, "#I Previous trace file size: %u KB, Current trace file size: %zu KB", (uint8_t *)&buf, 0x12u);
    }
    if (*v14)
    {
      uint64_t v42 = ".bin";
    }
    else if (capabilities::diag::diagVersion((capabilities::diag *)v40) == 3)
    {
      uint64_t v42 = ".diag.qmdl2";
    }
    else
    {
      uint64_t v42 = ".diag.qmdl";
    }
    std::string::__assign_external((std::string *)(a1 + 136), v42);
    *(_DWORD *)(a1 + 192) = 2 * *(unsigned __int8 *)(a1 + 131);
    size_t v43 = *(std::__shared_weak_count **)(a1 + 112);
    uint64_t v92 = *(void *)(a1 + 104);
    v93 = v43;
    if (v43) {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v44 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
    dispatch_object_t v91 = dispatch_queue_create("CellularLogging.DIAG.reader.queue", v44);
    BasebandTransport::create((capabilities::radio *)&v92, &v91, (uint64_t)&buf);
    long long v45 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
    BOOL v46 = *(std::__shared_weak_count **)(a1 + 168);
    *(_OWORD *)(a1 + 160) = v45;
    if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
    size_t size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
    if (v91) {
      dispatch_release(v91);
    }
    v48 = v93;
    if (v93 && !atomic_fetch_add(&v93->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
    if (*(void *)(a1 + 160))
    {
      abm::CellularLoggingEUR::getGUID((abm::CellularLoggingEUR *)a1, &buf);
      long long v49 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
      std::string::value_type v50 = *(std::__shared_weak_count **)(a1 + 208);
      *(_OWORD *)(a1 + 200) = v49;
      if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
      unint64_t v51 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
      if (buf.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
      if (*(void *)(a1 + 200))
      {
        char v90 = 12;
        strcpy((char *)v89, "Data_Logging");
        std::to_string(&buf, 0);
        std::string v88 = buf;
        abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v89, (const std::string::value_type *)&v88);
        if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v88.__r_.__value_.__l.__data_);
        }
        if (v90 < 0) {
          operator delete(v89[0]);
        }
        std::string v52 = (const char *)*MEMORY[0x1E4F4C0E0];
        size_t v53 = strlen((const char *)*MEMORY[0x1E4F4C0E0]);
        if (v53 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_179;
        }
        unint64_t v54 = (void *)v53;
        if (v53 >= 0x17)
        {
          uint64_t v57 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v53 | 7) != 0x17) {
            uint64_t v57 = v53 | 7;
          }
          uint64_t v58 = v57 + 1;
          uint64_t v55 = (void **)operator new(v57 + 1);
          __dst[1] = v54;
          unint64_t v87 = v58 | 0x8000000000000000;
          __dst[0] = v55;
        }
        else
        {
          HIBYTE(v87) = v53;
          uint64_t v55 = __dst;
          if (!v53)
          {
LABEL_128:
            *((unsigned char *)v54 + (void)v55) = 0;
            std::to_string(&buf, 0);
            std::string v85 = buf;
            abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)__dst, (const std::string::value_type *)&v85);
            if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v85.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v87) & 0x80000000) == 0)
              {
LABEL_130:
                char v84 = 4;
                strcpy((char *)v83, "File");
                if ((*(char *)(a1 + 247) & 0x80000000) == 0) {
                  goto LABEL_131;
                }
                goto LABEL_167;
              }
            }
            else if ((SHIBYTE(v87) & 0x80000000) == 0)
            {
              goto LABEL_130;
            }
            operator delete(__dst[0]);
            char v84 = 4;
            strcpy((char *)v83, "File");
            if ((*(char *)(a1 + 247) & 0x80000000) == 0)
            {
LABEL_131:
              size_t v59 = strlen((const char *)(a1 + 224));
              if (v59 <= 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_132;
              }
              goto LABEL_168;
            }
LABEL_167:
            uint64_t v21 = (void **)*v21;
            size_t v59 = strlen((const char *)v21);
            if (v59 <= 0x7FFFFFFFFFFFFFF7)
            {
LABEL_132:
              std::string v60 = (void *)v59;
              if (v59 >= 0x17)
              {
                uint64_t v62 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v59 | 7) != 0x17) {
                  uint64_t v62 = v59 | 7;
                }
                uint64_t v63 = v62 + 1;
                std::string v61 = operator new(v62 + 1);
                v81[1] = v60;
                unint64_t v82 = v63 | 0x8000000000000000;
                v81[0] = v61;
              }
              else
              {
                HIBYTE(v82) = v59;
                std::string v61 = v81;
                if (!v59)
                {
LABEL_139:
                  *((unsigned char *)v60 + (void)v61) = 0;
                  abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v83, (const std::string::value_type *)v81);
                  if (SHIBYTE(v82) < 0) {
                    operator delete(v81[0]);
                  }
                  if (v84 < 0) {
                    operator delete(v83[0]);
                  }
                  char v80 = 14;
                  strcpy((char *)v79, "TraceOwnership");
                  std::to_string(&buf, 1);
                  std::string v78 = buf;
                  abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v79, (const std::string::value_type *)&v78);
                  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v78.__r_.__value_.__l.__data_);
                  }
                  if (v80 < 0) {
                    operator delete(v79[0]);
                  }
                  char v77 = 4;
                  strcpy((char *)v76, "Mode");
                  std::to_string(&buf, 4);
                  std::string v75 = buf;
                  abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v76, (const std::string::value_type *)&v75);
                  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
                  {
                    operator delete(v75.__r_.__value_.__l.__data_);
                    if ((v77 & 0x80000000) == 0)
                    {
LABEL_149:
                      size_t v64 = strlen(v52);
                      if (v64 <= 0x7FFFFFFFFFFFFFF7) {
                        goto LABEL_150;
                      }
                      goto LABEL_179;
                    }
                  }
                  else if ((v77 & 0x80000000) == 0)
                  {
                    goto LABEL_149;
                  }
                  operator delete(v76[0]);
                  size_t v64 = strlen(v52);
                  if (v64 <= 0x7FFFFFFFFFFFFFF7)
                  {
LABEL_150:
                    long long v65 = (void *)v64;
                    if (v64 >= 0x17)
                    {
                      uint64_t v67 = (v64 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v64 | 7) != 0x17) {
                        uint64_t v67 = v64 | 7;
                      }
                      uint64_t v68 = v67 + 1;
                      v66 = operator new(v67 + 1);
                      v73[1] = v65;
                      unint64_t v74 = v68 | 0x8000000000000000;
                      v73[0] = v66;
                    }
                    else
                    {
                      HIBYTE(v74) = v64;
                      v66 = v73;
                      if (!v64) {
                        goto LABEL_157;
                      }
                    }
                    memmove(v66, v52, (size_t)v65);
LABEL_157:
                    *((unsigned char *)v65 + (void)v66) = 0;
                    std::to_string(&buf, 1);
                    std::string v72 = buf;
                    abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v73, (const std::string::value_type *)&v72);
                    if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v72.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v74) < 0) {
                      operator delete(v73[0]);
                    }
                    if (abm::CellularLoggingEUR::startReader((abm::CellularLoggingEUR *)a1, 1))
                    {
                      uint64_t v10 = 1;
                      if ((SHIBYTE(v109.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v10;
                      }
                      goto LABEL_75;
                    }
                    abm::CellularLoggingEUR::stopReader((abm::CellularLoggingEUR *)a1, 1);
                    goto LABEL_74;
                  }
LABEL_179:
                  std::string::__throw_length_error[abi:ne180100]();
                }
              }
              memmove(v61, v21, (size_t)v60);
              goto LABEL_139;
            }
LABEL_168:
            std::string::__throw_length_error[abi:ne180100]();
          }
        }
        memmove(v55, v52, (size_t)v54);
        goto LABEL_128;
      }
      timespec v37 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_74;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unint64_t v56 = "Failed to retrieve GUID for DIAG trace";
    }
    else
    {
      timespec v37 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_74;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unint64_t v56 = "Failed to create transport!";
    }
LABEL_173:
    _os_log_error_impl(&dword_1A609F000, v37, OS_LOG_TYPE_ERROR, v56, (uint8_t *)&buf, 2u);
    uint64_t v10 = 0;
    if ((SHIBYTE(v109.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v10;
    }
    goto LABEL_75;
  }
  unint64_t v32 = *(NSObject **)(a1 + 40);
  BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  if (v33)
  {
    std::string::size_type v69 = *v25;
    v70 = (capabilities::abs *)capabilities::radio::vendor((capabilities::radio *)v33);
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v70)) {
      int v71 = 16;
    }
    else {
      int v71 = 32;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 134218240;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v69 >> 10;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v71;
    _os_log_error_impl(&dword_1A609F000, v32, OS_LOG_TYPE_ERROR, "Given file size (%zu) KB is beyond the minimum boundary, adjusting to (%u) KB", (uint8_t *)&buf, 0x12u);
  }
  uint64_t v34 = (capabilities::abs *)capabilities::radio::vendor((capabilities::radio *)v33);
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v34)) {
    std::string::size_type v35 = 0x4000;
  }
  else {
    std::string::size_type v35 = 0x8000;
  }
  std::string::size_type *v25 = v35;
  if ((v35 & (v35 - 1)) == 0) {
    goto LABEL_78;
  }
LABEL_70:
  int64_t v36 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
    _os_log_error_impl(&dword_1A609F000, v36, OS_LOG_TYPE_ERROR, "File size (%zu) KB must be the power of 2", (uint8_t *)&buf, 0xCu);
    uint64_t v10 = 0;
    if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_75;
    }
    return v10;
  }
LABEL_74:
  uint64_t v10 = 0;
  if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
LABEL_75:
  }
    operator delete(v109.__r_.__value_.__l.__data_);
  return v10;
}

void sub_1A611AEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (*(char *)(v20 - 137) < 0) {
    operator delete(*(void **)(v20 - 160));
  }
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::getGUID(abm::CellularLoggingEUR *this@<X0>, void *a2@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v4 = (char *)operator new(0x70uLL);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *(void *)xpc_object_t v4 = &unk_1EFB0B390;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 88) = 0u;
  *((void *)v4 + 13) = 0;
  *a2 = v4 + 24;
  a2[1] = v4;
  BOOL v5 = (capabilities::abs *)capabilities::diag::supportsQShrink4((capabilities::diag *)v4);
  if ((v5 & 1) == 0)
  {
    size_t v14 = *((void *)this + 5);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I No GUID supported device!", (uint8_t *)__p, 2u);
    }
    return;
  }
  uint64_t v6 = *((void *)this + 20);
  if (!v6)
  {
    long long v15 = *((void *)this + 5);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(__p[0]) = 0;
    std::string::size_type v16 = "Transport is not created!";
    goto LABEL_23;
  }
  int v24 = 2;
  char v25 = 0;
  uint64_t v26 = 10;
  int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v5);
  if (shouldUseMinBasebandTransportIOReadSize) {
    int v8 = 0x4000;
  }
  else {
    int v8 = 0x8000;
  }
  int v27 = v8;
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize)) {
    int v9 = 4;
  }
  else {
    int v9 = 16;
  }
  int v28 = v9;
  uint64_t v29 = 0;
  char v30 = 0;
  aBlock = 0;
  char v10 = (*(uint64_t (**)(uint64_t, int *, void **))(*(void *)v6 + 48))(v6, &v24, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if ((v10 & 1) == 0)
  {
    long long v15 = *((void *)this + 5);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(__p[0]) = 0;
    std::string::size_type v16 = "Failed to open DIAG transport to get GUID info";
LABEL_23:
    _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, v16, (uint8_t *)__p, 2u);
    return;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v22 = 0;
  BasebandTransport::operator*(*((void *)this + 20));
  char v11 = ETLDIAGGetGUID();
  if ((BasebandTransport::close(*((BasebandTransport **)this + 20)) & 1) == 0)
  {
    uint64_t v12 = *((void *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v13 = "Failed to close transport!";
      goto LABEL_26;
    }
LABEL_28:
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_29;
  }
  if (v11)
  {
    if (*((void *)v4 + 4) == *((void *)v4 + 5))
    {
      uint64_t v12 = *((void *)this + 5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v13 = "Querying GUID returns empty!";
LABEL_26:
        uint64_t v17 = v12;
        uint32_t v18 = 2;
        goto LABEL_34;
      }
    }
    goto LABEL_28;
  }
  std::string::size_type v19 = *((void *)this + 5);
  if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
    goto LABEL_28;
  }
  uint64_t v20 = __p;
  if (v22 < 0) {
    uint64_t v20 = (void **)__p[0];
  }
  *(_DWORD *)std::string buf = 136315138;
  unint64_t v32 = v20;
  uint64_t v13 = "Failed to get GUID and error description: %s";
  uint64_t v17 = v19;
  uint32_t v18 = 12;
LABEL_34:
  _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, v13, buf, v18);
  if (SHIBYTE(v22) < 0) {
LABEL_29:
  }
    operator delete(__p[0]);
}

void sub_1A611B504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *aBlock)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingEUR::startReader(abm::CellularLoggingEUR *this, int a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  memset(&v56, 170, sizeof(v56));
  char v55 = 14;
  strcpy((char *)__p, "TraceOwnership");
  abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)__p, &v56);
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  int v4 = -1431655766;
  *(_DWORD *)std::string buf = -1431655766;
  if ((util::convert<int>(&v56, buf, 0) & 1) == 0 || (int v4 = *(_DWORD *)buf, *(_DWORD *)buf != 1))
  {
    int v9 = *((void *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v4;
      _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Trace Owner: %d, CellularLogging does not own trace transport. Skip creating trace reader", buf, 8u);
    }
    goto LABEL_10;
  }
  BOOL v5 = (atomic_ullong *)operator new(0x40uLL);
  uint64_t v6 = (std::__shared_weak_count *)v5;
  v5[2] = 0;
  v5[1] = 0;
  *BOOL v5 = (atomic_ullong)&unk_1EFB0DB60;
  uint64_t v7 = v5 + 3;
  v5[7] = 0;
  v5[6] = 0;
  v5[4] = (atomic_ullong)v5;
  v5[5] = (atomic_ullong)(v5 + 6);
  atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(v5 + 2, 1uLL, memory_order_relaxed);
  v5[3] = (atomic_ullong)(v5 + 3);
  if (!atomic_fetch_add(v5 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v5 + 16))(v5);
    std::__shared_weak_count::__release_weak(v6);
    int v8 = (std::__shared_weak_count *)*((void *)this + 23);
    *((void *)this + 22) = v7;
    *((void *)this + 23) = v6;
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  int v8 = (std::__shared_weak_count *)*((void *)this + 23);
  *((void *)this + 22) = v7;
  *((void *)this + 23) = v5;
  if (v8)
  {
LABEL_15:
    if (atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (*((void *)this + 22)) {
        goto LABEL_17;
      }
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      if (*((void *)this + 22)) {
        goto LABEL_17;
      }
    }
    unint64_t v32 = *((void *)this + 5);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v32, OS_LOG_TYPE_ERROR, "Failed to create DIAG reader!", buf, 2u);
    }
LABEL_10:
    uint64_t v10 = 0;
    goto LABEL_11;
  }
LABEL_17:
  memset(buf, 170, 16);
  int v12 = *((unsigned __int8 *)this + 131);
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 21);
  uint64_t v52 = *((void *)this + 20);
  size_t v53 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v14 = (std::__shared_weak_count *)*((void *)this + 26);
  uint64_t v50 = *((void *)this + 25);
  unint64_t v51 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v15 = (std::__shared_weak_count *)*((void *)this + 14);
  uint64_t v48 = *((void *)this + 13);
  long long v49 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v16 = *((_DWORD *)this + 54);
  int v17 = capabilities::trace::defaultMemoryFileMaxCount((capabilities::trace *)v5);
  if (v12) {
    int v18 = 15;
  }
  else {
    int v18 = 2;
  }
  diag::DIAGReader::Parameters::create(v18, &v52, &v50, &v48, v16, "/private/var/mobile/Library/Logs/CellularLogging", v17, *((_DWORD *)this + 62), buf);
  std::string::size_type v19 = v49;
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = v51;
  if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  uint64_t v21 = v53;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (!*(void *)buf)
  {
    unint64_t v31 = *((void *)this + 5);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v47 = 0;
      _os_log_error_impl(&dword_1A609F000, v31, OS_LOG_TYPE_ERROR, "Failed to create reader parameters", v47, 2u);
    }
    uint64_t v10 = 0;
    goto LABEL_68;
  }
  memset(v47, 170, sizeof(v47));
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN3abm18CellularLoggingEUR11startReaderEb_block_invoke;
  aBlock[3] = &__block_descriptor_40_e211_v32__0_basic_string_char__std::char_traits_char___std::allocator_char______compressed_pair_std::basic_string_char_::__rep__std::allocator_char______rep_______short__23c__0C_b7b1____long__Qb63b1____raw__3Q______8l;
  aBlock[4] = this;
  uint64_t v22 = _Block_copy(aBlock);
  long long v23 = *((void *)this + 15);
  if (v23) {
    dispatch_retain(*((dispatch_object_t *)this + 15));
  }
  *(void *)uint64_t v47 = v22;
  *(void *)&v47[8] = v23;
  uint64_t v24 = *((void *)this + 22);
  unsigned int v25 = *((_DWORD *)this + 48);
  uint64_t v44 = *(void *)buf;
  long long v45 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
  }
  if (v22)
  {
    uint64_t v42 = _Block_copy(v22);
    dispatch_object_t object = v23;
    if (!v23) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  uint64_t v42 = 0;
  dispatch_object_t object = v23;
  if (v23) {
LABEL_42:
  }
    dispatch_retain(v23);
LABEL_43:
  diag::DIAGReaderManager::addReader(v24, v25, &v44, (uint64_t)&v42);
  if (object) {
    dispatch_release(object);
  }
  if (v42) {
    _Block_release(v42);
  }
  uint64_t v26 = v45;
  if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *((void *)this + 22);
  char v41 = 0;
  LOBYTE(v40) = 0;
  diag::DIAGReaderManager::pushInfo(v27, 4, (uint64_t)&v40);
  if (v41 < 0)
  {
    operator delete(v40);
    uint64_t v33 = *((void *)this + 22);
    uint64_t v29 = *(void **)(v33 + 16);
    char v30 = (void *)(v33 + 24);
    if (v29 == (void *)(v33 + 24)) {
      goto LABEL_62;
    }
  }
  else
  {
    uint64_t v28 = *((void *)this + 22);
    uint64_t v29 = *(void **)(v28 + 16);
    char v30 = (void *)(v28 + 24);
    if (v29 == (void *)(v28 + 24)) {
      goto LABEL_62;
    }
  }
  do
  {
    diag::DIAGReader::start((diag::DIAGReader *)v29[5]);
    int64_t v36 = (void *)v29[1];
    if (v36)
    {
      do
      {
        timespec v37 = v36;
        int64_t v36 = (void *)*v36;
      }
      while (v36);
    }
    else
    {
      do
      {
        timespec v37 = (void *)v29[2];
        BOOL v38 = *v37 == (void)v29;
        uint64_t v29 = v37;
      }
      while (!v38);
    }
    uint64_t v29 = v37;
  }
  while (v37 != v30);
LABEL_62:
  if (!a2 || (abm::CellularLoggingCommon::changeState(this, 1) & 1) != 0)
  {
    uint64_t v10 = 1;
    uint64_t v34 = *(NSObject **)&v47[8];
    if (!*(void *)&v47[8]) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  BOOL v39 = *((void *)this + 5);
  if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = 0;
    uint64_t v34 = *(NSObject **)&v47[8];
    if (!*(void *)&v47[8]) {
      goto LABEL_66;
    }
LABEL_65:
    dispatch_release(v34);
    goto LABEL_66;
  }
  *(_DWORD *)uint64_t v57 = 136315138;
  uint64_t v58 = "true";
  _os_log_error_impl(&dword_1A609F000, v39, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", v57, 0xCu);
  uint64_t v10 = 0;
  uint64_t v34 = *(NSObject **)&v47[8];
  if (*(void *)&v47[8]) {
    goto LABEL_65;
  }
LABEL_66:
  if (*(void *)v47) {
    _Block_release(*(const void **)v47);
  }
LABEL_68:
  std::string::size_type v35 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
LABEL_11:
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  return v10;
}

void sub_1A611BC58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  dispatch::callback<void({block_pointer})(std::string)>::~callback((uint64_t)&a24);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v37 - 96);
  if (*(char *)(v37 - 113) < 0) {
    operator delete(*(void **)(v37 - 136));
  }
  _Unwind_Resume(a1);
}

BOOL abm::CellularLoggingEUR::stopReader(abm::CellularLoggingEUR *this, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  BOOL v5 = (void *)((char *)this + 176);
  uint64_t v4 = *((void *)this + 22);
  if (!v4) {
    goto LABEL_24;
  }
  char v22 = 0;
  LOBYTE(__p) = 0;
  diag::DIAGReaderManager::pushInfo(v4, 6, (uint64_t)&__p);
  if (v22 < 0)
  {
    operator delete(__p);
    uint64_t v6 = *v5;
    uint64_t v7 = *(void **)(*v5 + 16);
    uint64_t v8 = *v5 + 24;
    if (v7 == (void *)v8) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v6 = *v5;
    uint64_t v7 = *(void **)(*v5 + 16);
    uint64_t v8 = *v5 + 24;
    if (v7 == (void *)v8)
    {
LABEL_6:
      uint64_t v9 = v6 + 24;
      if (v7 == (void *)(v6 + 24)) {
        goto LABEL_19;
      }
      goto LABEL_29;
    }
  }
  do
  {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(v7[5] + 16) + 24) + 336);
    usleep(0x7A120u);
    uint64_t v11 = *(void *)(*(void *)(*(void *)(v7[5] + 16) + 24) + 336);
    if (v10 != v11)
    {
      usleep(0x7A120u);
      if (v11 != *(void *)(*(void *)(*(void *)(v7[5] + 16) + 24) + 336)) {
        usleep(0x7A120u);
      }
    }
    int v12 = (void *)v7[1];
    if (v12)
    {
      do
      {
        uint64_t v13 = v12;
        int v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v13 = (void *)v7[2];
        BOOL v14 = *v13 == (void)v7;
        uint64_t v7 = v13;
      }
      while (!v14);
    }
    uint64_t v7 = v13;
  }
  while (v13 != (void *)v8);
  uint64_t v7 = *(void **)(*v5 + 16);
  uint64_t v9 = *v5 + 24;
  if (v7 != (void *)v9)
  {
    do
    {
LABEL_29:
      diag::DIAGReader::stop((diag::DIAGReader *)v7[5]);
      std::string::size_type v19 = (void *)v7[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          std::string::size_type v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v7[2];
          BOOL v14 = *v20 == (void)v7;
          uint64_t v7 = v20;
        }
        while (!v14);
      }
      uint64_t v7 = v20;
    }
    while (v20 != (void *)v9);
  }
LABEL_19:
  long long v15 = (std::__shared_weak_count *)*((void *)this + 23);
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  if (!v15)
  {
    *BOOL v5 = 0;
    v5[1] = 0;
    if (!a2) {
      return 1;
    }
    goto LABEL_25;
  }
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  int v16 = (std::__shared_weak_count *)*((void *)this + 23);
  *BOOL v5 = 0;
  v5[1] = 0;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    if (!a2) {
      return 1;
    }
    goto LABEL_25;
  }
LABEL_24:
  if (!a2) {
    return 1;
  }
LABEL_25:
  if (abm::CellularLoggingCommon::changeState(this, 0)) {
    return 1;
  }
  int v17 = *((void *)this + 5);
  BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v24 = "false";
    _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_1A611C008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingEUR::pause(abm::CellularLoggingEUR *a1)
{
  return abm::CellularLoggingEUR::stopReader(a1, 0);
}

uint64_t abm::CellularLoggingEUR::resume(abm::CellularLoggingEUR *a1)
{
  return abm::CellularLoggingEUR::startReader(a1, 0);
}

void ___ZN3abm18CellularLoggingEUR11startReaderEb_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    int v4 = 136315138;
    BOOL v5 = a2;
    _os_log_error_impl(&dword_1A609F000, v3, OS_LOG_TYPE_ERROR, "Diag Reader Error: %s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t dispatch::callback<void({block_pointer})(std::string)>::~callback(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

void abm::CellularLoggingEUR::getGUIDStrings(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v5 = *(void *)(v4 + 8);
    for (uint64_t i = *(void *)(v4 + 16); v5 != i; v5 += 16)
    {
      while (1)
      {
        while (1)
        {
          ETLDIAGLoggingGetGUIDString();
          unint64_t v8 = *(void *)(a3 + 8);
          if (v8 >= *(void *)(a3 + 16)) {
            break;
          }
          long long v7 = *(_OWORD *)__p;
          *(void *)(v8 + 16) = v13;
          *(_OWORD *)unint64_t v8 = v7;
          *(void *)(a3 + 8) = v8 + 24;
          v5 += 16;
          if (v5 == i) {
            return;
          }
        }
        uint64_t v9 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a3, (uint64_t)__p);
        int v10 = SHIBYTE(v13);
        *(void *)(a3 + 8) = v9;
        if (v10 < 0) {
          break;
        }
        v5 += 16;
        if (v5 == i) {
          return;
        }
      }
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "No DIAG GUID parameter is given", (uint8_t *)__p, 2u);
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
}

void sub_1A611C264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](v14);
    _Unwind_Resume(a1);
  }
  std::vector<std::string>::~vector[abi:ne180100](v14);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::stop(abm::CellularLoggingEUR *this)
{
  if (!abm::CellularLoggingCommon::isStarted(this))
  {
    uint64_t v6 = *((void *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", (uint8_t *)&buf, 2u);
    }
    return;
  }
  abm::CellularLoggingEUR::stopReader(this, 1);
  uint64_t v2 = (const void *)*MEMORY[0x1E4F4C0E0];
  size_t v3 = strlen((const char *)*MEMORY[0x1E4F4C0E0]);
  if (v3 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v4 = (void *)v3;
  if (v3 >= 0x17)
  {
    uint64_t v7 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v7 = v3 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v5 = (void **)operator new(v7 + 1);
    __dst[1] = v4;
    unint64_t v31 = v8 | 0x8000000000000000;
    __dst[0] = v5;
    goto LABEL_11;
  }
  HIBYTE(v31) = v3;
  uint64_t v5 = __dst;
  if (v3) {
LABEL_11:
  }
    memmove(v5, v2, (size_t)v4);
  *((unsigned char *)v4 + (void)v5) = 0;
  std::to_string(&buf, 0);
  std::string v29 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)__dst, (const std::string::value_type *)&v29);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v29.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v31) & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((SHIBYTE(v31) & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(__dst[0]);
LABEL_14:
  char v28 = 14;
  strcpy((char *)v27, "TraceOwnership");
  std::to_string(&buf, 0);
  std::string __p = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v27, (const std::string::value_type *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v27[0]);
LABEL_16:
  char v25 = 4;
  strcpy((char *)v24, "Mode");
  std::to_string(&buf, *((_DWORD *)this + 49));
  std::string v23 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v24, (const std::string::value_type *)&v23);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
    if ((v25 & 0x80000000) == 0) {
      goto LABEL_18;
    }
  }
  else if ((v25 & 0x80000000) == 0)
  {
    goto LABEL_18;
  }
  operator delete(v24[0]);
LABEL_18:
  char v22 = 4;
  strcpy((char *)v21, "File");
  if (*((char *)this + 279) < 0) {
    std::string::__init_copy_ctor_external(&v20, *((const std::string::value_type **)this + 32), *((void *)this + 33));
  }
  else {
    std::string v20 = *(std::string *)((char *)this + 256);
  }
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v21, (const std::string::value_type *)&v20);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if ((v22 & 0x80000000) == 0) {
      goto LABEL_29;
    }
  }
  else if ((v22 & 0x80000000) == 0)
  {
    goto LABEL_29;
  }
  operator delete(v21[0]);
LABEL_29:
  char v19 = 12;
  v17.__r_.__value_.__r.__words[2] = 0;
  strcpy((char *)v18, "Data_Logging");
  std::to_string(&buf, *((unsigned __int8 *)this + 132));
  std::string v17 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v18, (const std::string::value_type *)&v17);
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__r_.__value_.__l.__data_);
    if ((v19 & 0x80000000) == 0)
    {
LABEL_31:
      if (!*((unsigned char *)this + 130)) {
        return;
      }
      goto LABEL_37;
    }
  }
  else if ((v19 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v18[0]);
  if (!*((unsigned char *)this + 130)) {
    return;
  }
LABEL_37:
  size_t v9 = strlen((const char *)v2);
  if (v9 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  int v10 = (void *)v9;
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    uint64_t v11 = operator new(v12 + 1);
    v15[1] = v10;
    unint64_t v16 = v13 | 0x8000000000000000;
    v15[0] = v11;
  }
  else
  {
    HIBYTE(v16) = v9;
    uint64_t v11 = v15;
    if (!v9) {
      goto LABEL_45;
    }
  }
  memmove(v11, v2, (size_t)v10);
LABEL_45:
  *((unsigned char *)v10 + (void)v11) = 0;
  if (!*((unsigned char *)this + 130)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  std::to_string(&buf, *((unsigned __int8 *)this + 129));
  std::string v14 = buf;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v15, (const std::string::value_type *)&v14);
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v16) & 0x80000000) == 0) {
      return;
    }
LABEL_50:
    operator delete(v15[0]);
    return;
  }
  operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v16) < 0) {
    goto LABEL_50;
  }
}

void sub_1A611C710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a44 < 0) {
    operator delete(a39);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A611C874(void *a1)
{
}

void sub_1A611C880()
{
  if ((*(char *)(v0 - 121) & 0x80000000) == 0) {
    JUMPOUT(0x1A611C858);
  }
  JUMPOUT(0x1A611C850);
}

void abm::CellularLoggingEUR::stopWithConfig(abm::CellularLoggingEUR *a1, uint64_t a2)
{
  abm::CellularLoggingEUR::stop(a1);
  xpc_object_t object = xpc_null_create();
  char v5 = 1;
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, char *, xpc_object_t *))(*(void *)v3 + 48))(v3, &v5, &object);
  xpc_release(object);
}

void sub_1A611C918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

void abm::CellularLoggingEUR::getConfigName(abm::CellularLoggingEUR *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 247) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 28), *((void *)this + 29));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 14);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 30);
  }
}

uint64_t abm::CellularLoggingEUR::getConfigHistoryMB(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 54);
}

void abm::CellularLoggingEUR::getFileExtension(abm::CellularLoggingEUR *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 159) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 17), *((void *)this + 18));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 136);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 19);
  }
}

uint64_t abm::CellularLoggingEUR::getMaxNumberOfFiles(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 54);
}

uint64_t abm::CellularLoggingEUR::getFileSize(abm::CellularLoggingEUR *this)
{
  return *((unsigned int *)this + 62);
}

void abm::CellularLoggingEUR::getModemInformation1(abm::CellularLoggingEUR *this@<X0>, xpc_object_t *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 25);
  if (v3)
  {
    std::string v23 = 0;
    unint64_t v24 = 0;
    *(void *)std::string buf = 0;
    uint64_t v4 = *(void *)(v3 + 8);
    for (uint64_t i = *(void *)(v3 + 16); v4 != i; v4 += 16)
    {
      while (1)
      {
        while (1)
        {
          ETLDIAGLoggingGetGUIDString();
          uint64_t v7 = v23;
          if ((unint64_t)v23 >= v24) {
            break;
          }
          long long v6 = *(_OWORD *)__p;
          *((void *)v23 + 2) = v21;
          *uint64_t v7 = v6;
          std::string v23 = (char *)v7 + 24;
          v4 += 16;
          if (v4 == i) {
            goto LABEL_10;
          }
        }
        std::string v23 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)buf, (uint64_t)__p);
        if (SHIBYTE(v21) < 0) {
          break;
        }
        v4 += 16;
        if (v4 == i) {
          goto LABEL_10;
        }
      }
      operator delete(__p[0]);
    }
LABEL_10:
    *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    xpc_object_t v8 = xpc_array_create(0, 0);
    xpc_object_t v9 = v8;
    uint64_t v10 = MEMORY[0x1E4F14568];
    if (v8)
    {
      *a2 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      *a2 = v9;
      if (!v9)
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_21;
      }
    }
    if (MEMORY[0x1A6275E60](v9) == v10)
    {
      xpc_retain(v9);
      goto LABEL_22;
    }
    xpc_object_t v12 = xpc_null_create();
LABEL_21:
    *a2 = v12;
LABEL_22:
    xpc_release(v9);
    uint64_t v13 = MEMORY[0x1A6275E60](*a2);
    std::string v14 = *(char **)buf;
    if (v13 == v10)
    {
      long long v15 = v23;
      if (*(char **)buf != v23)
      {
        do
        {
          unint64_t v16 = v14;
          if (v14[23] < 0) {
            unint64_t v16 = *(const char **)v14;
          }
          xpc_object_t v17 = xpc_string_create(v16);
          if (!v17) {
            xpc_object_t v17 = xpc_null_create();
          }
          xpc_array_append_value(*a2, v17);
          xpc_release(v17);
          v14 += 24;
        }
        while (v14 != v15);
        std::string v14 = *(char **)buf;
      }
    }
    if (v14)
    {
      int v18 = v23;
      char v19 = v14;
      if (v23 != v14)
      {
        do
        {
          if (*(v18 - 1) < 0) {
            operator delete(*((void **)v18 - 3));
          }
          v18 -= 24;
        }
        while (v18 != v14);
        char v19 = *(char **)buf;
      }
      std::string v23 = v14;
      operator delete(v19);
    }
    return;
  }
  uint64_t v11 = *((void *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "GUID Parameter has not been created!", buf, 2u);
  }
  *a2 = xpc_null_create();
}

void sub_1A611CBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  xpc::array::~array(v13);
  std::vector<std::string>::~vector[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

void sub_1A611CC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::vector<std::string>::~vector[abi:ne180100](&a16);
    _Unwind_Resume(a1);
  }
  std::vector<std::string>::~vector[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

void xpc::array::~array(xpc_object_t *this)
{
  *this = 0;
}

void abm::CellularLoggingEUR::getModemInformation2(abm::CellularLoggingEUR *this@<X0>, xpc_object_t *a2@<X8>)
{
  if (*((void *)this + 25))
  {
    *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    xpc_object_t v4 = xpc_array_create(0, 0);
    xpc_object_t v5 = v4;
    uint64_t v6 = MEMORY[0x1E4F14568];
    if (v4)
    {
      *a2 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      *a2 = v5;
      if (!v5)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v5 = 0;
        goto LABEL_12;
      }
    }
    if (MEMORY[0x1A6275E60](v5) == v6)
    {
      xpc_retain(v5);
LABEL_13:
      xpc_release(v5);
      xpc_object_t v9 = *a2;
      if (MEMORY[0x1A6275E60](*a2) == v6)
      {
        uint64_t v10 = *((void *)this + 25);
        uint64_t v11 = *(unsigned __int8 **)(v10 + 32);
        for (uint64_t i = *(unsigned __int8 **)(v10 + 40); v11 != i; ++v11)
        {
          xpc_object_t v13 = xpc_int64_create(*v11);
          if (!v13) {
            xpc_object_t v13 = xpc_null_create();
          }
          xpc_array_append_value(v9, v13);
          xpc_release(v13);
        }
      }
      return;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_12:
    *a2 = v8;
    goto LABEL_13;
  }
  uint64_t v7 = *((void *)this + 5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v14[0] = 0;
    _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "GUID Parameter has not been created!", (uint8_t *)v14, 2u);
  }
  *a2 = xpc_null_create();
}

void sub_1A611CE20(_Unwind_Exception *a1)
{
  xpc::array::~array(v1);
  _Unwind_Resume(a1);
}

void sub_1A611CE48(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc::array::~array(v1);
  _Unwind_Resume(a1);
}

uint64_t abm::CellularLoggingEUR::getCurrentIndex(abm::CellularLoggingEUR *this)
{
  uint64_t v1 = *((void *)this + 22);
  if (!v1)
  {
    uint64_t v10 = *((void *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v12 = 0;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Reader does not exist!", v12, 2u);
      return 0;
    }
    return 0;
  }
  uint64_t v4 = *(void *)(v1 + 24);
  uint64_t v2 = v1 + 24;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *((_DWORD *)this + 48);
  uint64_t v6 = v2;
  do
  {
    unsigned int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      xpc_object_t v9 = (uint64_t *)v3;
    }
    else {
      xpc_object_t v9 = (uint64_t *)(v3 + 8);
    }
    if (v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 == v2 || *(_DWORD *)(v6 + 32) > v5 || !*(void *)(*(void *)(v6 + 40) + 32)) {
    return 0;
  }

  return MEMORY[0x1F410C7E8]();
}

void abm::CellularLoggingEUR::getCandidateConfigNames(void *a1@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(a1, 170, 24);
  ETLDIAGLoggingGetAvailableDMCNames();
  memset(v36, 170, sizeof(v36));
  char v38 = 7;
  strcpy((char *)v37, "Default");
  char v40 = 4;
  strcpy((char *)v39, "Tput");
  char v42 = 4;
  strcpy((char *)v41, "Lite");
  char v44 = 5;
  strcpy((char *)__p, "VoLTE");
  std::vector<std::string>::vector[abi:ne180100](v36, (uint64_t)v37, 4uLL);
  if (v44 < 0)
  {
    operator delete(__p[0]);
    if ((v42 & 0x80000000) == 0)
    {
LABEL_3:
      if ((v40 & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_59:
      operator delete(v39[0]);
      if ((v38 & 0x80000000) == 0) {
        goto LABEL_5;
      }
LABEL_60:
      operator delete(v37[0]);
      goto LABEL_5;
    }
  }
  else if ((v42 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v41[0]);
  if (v40 < 0) {
    goto LABEL_59;
  }
LABEL_4:
  if (v38 < 0) {
    goto LABEL_60;
  }
LABEL_5:
  uint64_t v4 = (unsigned __int8 **)*a1;
  uint64_t v3 = (unsigned __int8 **)a1[1];
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v33 = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v33, (uint64_t)v36[0], (uint64_t)v36[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v36[1] - (char *)v36[0]) >> 3));
  if (v4 == v3) {
    goto LABEL_55;
  }
  unsigned int v5 = (void **)v33;
  uint64_t v6 = v34;
  if (v33 == v34) {
    goto LABEL_28;
  }
  while (2)
  {
    char v7 = *((unsigned char *)v4 + 23);
    if (v7 >= 0) {
      BOOL v8 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 23);
    }
    else {
      BOOL v8 = v4[1];
    }
    if (v7 >= 0) {
      xpc_object_t v9 = (unsigned __int8 *)v4;
    }
    else {
      xpc_object_t v9 = *v4;
    }
    uint64_t v10 = v5;
    while (1)
    {
      uint64_t v11 = *((unsigned __int8 *)v10 + 23);
      if ((v11 & 0x80u) == 0) {
        xpc_object_t v12 = (unsigned __int8 *)*((unsigned __int8 *)v10 + 23);
      }
      else {
        xpc_object_t v12 = (unsigned __int8 *)v10[1];
      }
      if (v12 != v8) {
        goto LABEL_15;
      }
      if ((v11 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*v10, v9, (size_t)v10[1])) {
        goto LABEL_25;
      }
LABEL_15:
      v10 += 3;
      if (v10 == v6) {
        goto LABEL_28;
      }
    }
    if (*((unsigned char *)v10 + 23))
    {
      uint64_t v13 = 0;
      while (*((unsigned __int8 *)v10 + v13) == v9[v13])
      {
        if (v11 == ++v13) {
          goto LABEL_25;
        }
      }
      goto LABEL_15;
    }
LABEL_25:
    if (v10 != v6)
    {
      v4 += 3;
      if (v4 == v3)
      {
        long long v15 = v3;
        uint64_t v26 = (unsigned __int8 **)a1[1];
        if (v3 == v26) {
          goto LABEL_71;
        }
        goto LABEL_67;
      }
      continue;
    }
    break;
  }
LABEL_28:
  if (v4 == v3)
  {
    long long v15 = v4;
LABEL_64:
    uint64_t v26 = (unsigned __int8 **)a1[1];
    if (v15 == v26) {
      goto LABEL_71;
    }
  }
  else
  {
    std::string v14 = (const void **)(v4 + 3);
    if (v4 + 3 != v3)
    {
      long long v15 = v4;
      do
      {
        xpc_object_t v17 = v14;
        int v18 = (void **)v33;
        char v19 = v34;
        if (v33 != v34)
        {
          int v20 = *((char *)v4 + 47);
          if (v20 >= 0) {
            uint64_t v21 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 47);
          }
          else {
            uint64_t v21 = v4[4];
          }
          if (v20 >= 0) {
            char v22 = (unsigned __int8 *)v14;
          }
          else {
            char v22 = (unsigned __int8 *)*v14;
          }
          while (1)
          {
            uint64_t v23 = *((unsigned __int8 *)v18 + 23);
            if ((v23 & 0x80u) == 0) {
              unint64_t v24 = (unsigned __int8 *)*((unsigned __int8 *)v18 + 23);
            }
            else {
              unint64_t v24 = (unsigned __int8 *)v18[1];
            }
            if (v24 == v21)
            {
              if ((v23 & 0x80) != 0)
              {
                if (!memcmp(*v18, v22, (size_t)v18[1])) {
                  break;
                }
              }
              else
              {
                if (!*((unsigned char *)v18 + 23)) {
                  break;
                }
                uint64_t v25 = 0;
                while (*((unsigned __int8 *)v18 + v25) == v22[v25])
                {
                  if (v23 == ++v25) {
                    goto LABEL_51;
                  }
                }
              }
            }
            v18 += 3;
            if (v18 == v19) {
              goto LABEL_32;
            }
          }
        }
LABEL_51:
        if (v18 != v19)
        {
          if (*((char *)v15 + 23) < 0) {
            operator delete(*v15);
          }
          long long v16 = *(_OWORD *)v17;
          v15[2] = (unsigned __int8 *)v17[2];
          *(_OWORD *)long long v15 = v16;
          v15 += 3;
          *((unsigned char *)v4 + 47) = 0;
          *(unsigned char *)xpc_object_t v17 = 0;
        }
LABEL_32:
        std::string v14 = v17 + 3;
        uint64_t v4 = (unsigned __int8 **)v17;
      }
      while (v17 + 3 != (const void **)v3);
      goto LABEL_64;
    }
LABEL_55:
    long long v15 = v4;
    uint64_t v26 = (unsigned __int8 **)a1[1];
    if (v4 == v26) {
      goto LABEL_71;
    }
  }
LABEL_67:
  while (v26 != v15)
  {
    if (*((char *)v26 - 1) < 0) {
      operator delete(*(v26 - 3));
    }
    v26 -= 3;
  }
  a1[1] = v15;
LABEL_71:
  uint64_t v27 = (void **)v33;
  if (v33)
  {
    char v28 = v34;
    std::string v29 = v33;
    if (v34 != v33)
    {
      do
      {
        if (*((char *)v28 - 1) < 0) {
          operator delete(*(v28 - 3));
        }
        v28 -= 3;
      }
      while (v28 != v27);
      std::string v29 = v33;
    }
    uint64_t v34 = v27;
    operator delete(v29);
  }
  char v30 = (void **)v36[0];
  if (v36[0])
  {
    unint64_t v31 = (void **)v36[1];
    unint64_t v32 = v36[0];
    if (v36[1] != v36[0])
    {
      do
      {
        if (*((char *)v31 - 1) < 0) {
          operator delete(*(v31 - 3));
        }
        v31 -= 3;
      }
      while (v31 != v30);
      unint64_t v32 = v36[0];
    }
    v36[1] = v30;
    operator delete(v32);
  }
}

void sub_1A611D400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  std::vector<std::string>::~vector[abi:ne180100](v5);
  _Unwind_Resume(a1);
}

void sub_1A611D41C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_3:
    if (a27 < 0) {
      goto LABEL_4;
    }
    goto LABEL_8;
  }
  operator delete(a28);
  if (a27 < 0)
  {
LABEL_4:
    operator delete(a22);
    if ((a21 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  if ((a21 & 0x80000000) == 0)
  {
LABEL_5:
    std::vector<std::string>::~vector[abi:ne180100](v39);
    _Unwind_Resume(a1);
  }
LABEL_9:
  operator delete(a16);
  std::vector<std::string>::~vector[abi:ne180100](v39);
  _Unwind_Resume(a1);
}

BOOL abm::CellularLoggingEUR::handleAppCrash(abm::CellularLoggingEUR *a1, std::string::size_type a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  abm::CellularLoggingEUR::stopReader(a1, 1);
  memset(v23, 170, sizeof(v23));
  Timestamp::Timestamp((Timestamp *)v23);
  *((unsigned char *)&v21.__r_.__value_.__s + 23) = 1;
  LOWORD(v21.__r_.__value_.__l.__data_) = 47;
  uint64_t v4 = std::string::insert(&v21, 0, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging", 0x47uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  size_t v6 = strlen(abm::trace::kLogDirPrefix[0]);
  char v7 = std::string::append(&v24, abm::trace::kLogDirPrefix[0], v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  Timestamp::asString((uint64_t)v23, 0, 9, __p);
  if ((v20 & 0x80u) == 0) {
    xpc_object_t v9 = __p;
  }
  else {
    xpc_object_t v9 = (void **)__p[0];
  }
  if ((v20 & 0x80u) == 0) {
    std::string::size_type v10 = v20;
  }
  else {
    std::string::size_type v10 = (std::string::size_type)__p[1];
  }
  uint64_t v11 = std::string::append(&v25, (const std::string::value_type *)v9, v10);
  std::string v22 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v20 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_10;
      }
LABEL_19:
      operator delete(v24.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_20;
    }
  }
  else if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_19;
  }
LABEL_10:
  if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_11;
  }
LABEL_20:
  operator delete(v21.__r_.__value_.__l.__data_);
LABEL_11:
  v25.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
  *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A61F74B0;
  strcpy(v25.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging");
  BOOL Dir = support::fs::createDir((const char *)&v25, 0x1EDu, 1);
  BOOL v13 = Dir;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v25.__r_.__value_.__l.__data_);
    if (v13) {
      goto LABEL_13;
    }
LABEL_22:
    long long v15 = *((void *)a1 + 5);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)"/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging";
      _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "Failed to create directory %s", (uint8_t *)&v25, 0xCu);
    }
    goto LABEL_32;
  }
  if (!Dir) {
    goto LABEL_22;
  }
LABEL_13:
  memset(&v25, 170, sizeof(v25));
  v24.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
  *(_OWORD *)&v24.__r_.__value_.__r.__words[1] = xmmword_1A61F8900;
  strcpy(v24.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CellularLogging");
  support::fs::moveDirUnique((const char *)&v24, (uint64_t)&v22, (uint64_t)&v25);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24.__r_.__value_.__l.__data_);
    std::string v14 = *((void *)a1 + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
LABEL_15:
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
  }
  else
  {
    std::string v14 = *((void *)a1 + 5);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
  }
  if (*(char *)(a2 + 23) >= 0) {
    std::string::size_type v16 = a2;
  }
  else {
    std::string::size_type v16 = *(void *)a2;
  }
  xpc_object_t v17 = &v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    xpc_object_t v17 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  LODWORD(v24.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = v16;
  WORD2(v24.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&v24.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
  _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#N Detected %s crash, moving logs to %s", (uint8_t *)&v24, 0x16u);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
LABEL_31:
  }
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_32:
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v23, v23[1]);
  return v13;
}

void sub_1A611D824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingEUR::snapshot(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Telephony log snapshot not supported", buf, 2u);
  }
  xpc_object_t object = xpc_null_create();
  char v8 = 0;
  uint64_t v5 = *(void *)(a3 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, char *, xpc_object_t *))(*(void *)v5 + 48))(v5, &v8, &object);
  xpc_release(object);
}

void sub_1A611D9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig(uint64_t a1)
{
  return MEMORY[0x1F417DA50](a1 + 8);
}

double ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)a1 = v2;
  *(_OWORD *)(a1 + 8) = xmmword_1A61F7580;
  strcpy(v2, "carriercellularlogging.modem");
  return *(double *)"larlogging.modem";
}

uint64_t ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return MEMORY[0x1F417DD10](a1 + 8);
}

char *std::vector<std::string>::__push_back_slow_path<std::string>(void **a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    char v7 = (char *)operator new(24 * v6);
  }
  else
  {
    char v7 = 0;
  }
  char v8 = &v7[24 * v3];
  xpc_object_t v9 = &v7[24 * v6];
  *(_OWORD *)char v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  std::string::size_type v10 = v8 + 24;
  uint64_t v11 = (void **)*a1;
  xpc_object_t v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v12 - 3);
      *((void *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0;
      *(v12 - 1) = 0;
      *(v12 - 3) = 0;
      v12 -= 3;
    }
    while (v12 != v11);
    xpc_object_t v12 = (void **)*a1;
    std::string v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v10;
}

void std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    }
    char v8 = (char *)operator new(24 * a4);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[24 * a4];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        std::string::size_type v10 = (std::string *)&v8[v9];
        uint64_t v11 = a2 + v9;
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)v11, *(void *)(v11 + 8));
        }
        else
        {
          *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)v11;
          v10->__r_.__value_.__r.__words[2] = *(void *)(v11 + 16);
        }
        v9 += 24;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    a1[1] = v8;
  }
}

void sub_1A611DC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1A611DCA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  for (; v11; v11 -= 24)
  {
    if (*(char *)(v10 + v11 - 1) < 0) {
      operator delete(*(void **)(v10 + v11 - 24));
    }
  }
  *(void *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<std::string>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:ne180100]<abm::CellularLoggingEUR,std::allocator<abm::CellularLoggingEUR>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, void *a4@<X8>)
{
  char v8 = (std::__shared_weak_count *)operator new(0x130uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = &v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B340;
  uint64_t v10 = (std::__shared_weak_count_vtbl *)&v8[1];
  std::construct_at[abi:ne180100]<abm::CellularLoggingEUR,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingEUR*>((uint64_t)&v8[1], a1, a2, a3);
  *a4 = v8 + 1;
  a4[1] = v8;
  shared_owners = (std::__shared_weak_count *)v8[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_owners);
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  else
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);

  std::__shared_weak_count::__release_weak(v8);
}

void sub_1A611DE28(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<abm::CellularLoggingEUR>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::CellularLoggingEUR>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B340;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<abm::CellularLoggingEUR>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::construct_at[abi:ne180100]<abm::CellularLoggingEUR,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingEUR*>(uint64_t a1, uint64_t *a2, uint64_t *a3, NSObject **a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  v11[0] = *a2;
  v11[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (std::__shared_weak_count *)a3[1];
  v10[0] = *a3;
  v10[1] = (uint64_t)v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  char v7 = *a4;
  dispatch_object_t v9 = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  abm::CellularLoggingEUR::CellularLoggingEUR(a1, v11, v10, &v9);
  if (v7) {
    dispatch_release(v7);
  }
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (!v5 || atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void sub_1A611DFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v14)
  {
    dispatch_release(v14);
    if (!v13)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
      _Unwind_Resume(a1);
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v13);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B390;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<ETLDIAGGUIDParameter>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }
}

uint64_t _GLOBAL__sub_I_CellularLoggingEUR_mm()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  dword_1EB5EE8FC = result;
  return result;
}

double CoredumpTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  unint64_t v3 = (CoredumpTrace *)operator new(0xF0uLL);
  CoredumpTrace::CoredumpTrace(v3);
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<CoredumpTrace>::shared_ptr[abi:ne180100]<CoredumpTrace,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  double result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A611E158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A611E16C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void CoredumpTrace::CoredumpTrace(CoredumpTrace *this)
{
  char v5 = 14;
  strcpy((char *)__p, "trace.coredump");
  uint64_t v2 = (capabilities::trace *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this = &unk_1EFB0B3E0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((unsigned char *)this + 168) = capabilities::trace::allowed(v2);
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  uint64_t v3 = (*(uint64_t (**)(CoredumpTrace *))(*(void *)this + 160))(this);
  if (*(char *)(v3 + 23) < 0) {
    uint64_t v3 = *(void *)v3;
  }
  *((void *)this + 28) = dispatch_queue_create((const char *)v3, 0);
  *((unsigned char *)this + 232) = 0;
}

void sub_1A611E27C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 223) < 0) {
    operator delete(*(void **)(v1 + 200));
  }
  if (*(char *)(v1 + 199) < 0) {
    operator delete(*v3);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2);
  Trace::~Trace((Trace *)v1);
  _Unwind_Resume(a1);
}

void sub_1A611E2C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *CoredumpTrace::getName(CoredumpTrace *this)
{
  return "trace.coredump";
}

void CoredumpTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 10;
  strcpy(a1, "CoreDump::");
}

BOOL CoredumpTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  uint64_t v18 = 0;
  char v19 = &v18;
  uint64_t v20 = 0x2020000000;
  char v21 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3321888768;
  v13[2] = ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke;
  v13[3] = &unk_1EFB0B4E8;
  v13[4] = &v18;
  v13[5] = a1;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  char v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = *a3;
  std::string::size_type v16 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  char v8 = *a4;
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  std::string v22 = v13;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
  block[3] = &__block_descriptor_48_e5_v8__0l;
  block[4] = a1 + 72;
  block[5] = &v22;
  dispatch_object_t v9 = *(NSObject **)(a1 + 88);
  if (*(void *)(a1 + 96))
  {
    dispatch_async_and_wait(v9, block);
    int v10 = *((unsigned __int8 *)v19 + 24);
    uint64_t v11 = object;
    if (!object) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  dispatch_sync(v9, block);
  int v10 = *((unsigned __int8 *)v19 + 24);
  uint64_t v11 = object;
  if (object) {
LABEL_10:
  }
    dispatch_release(v11);
LABEL_11:
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  _Block_object_dispose(&v18, 8);
  return v10 != 0;
}

void sub_1A611E4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(char *)(a1 + 71) & 0x80000000) == 0)
  {
    std::string v34 = *(std::string *)(a1 + 48);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
    uint64_t v32 = *(void *)(a1 + 72);
    uint64_t v33 = v3;
    if (!v3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)(a1 + 48), *(void *)(a1 + 56));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v32 = *(void *)(a1 + 72);
  uint64_t v33 = v3;
  if (v3) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  unint64_t v4 = *(NSObject **)(a1 + 88);
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Trace::init(v2, (void **)&v34.__r_.__value_.__l.__data_, &v32, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v5 + 24)) {
      goto LABEL_12;
    }
LABEL_18:
    *(unsigned char *)(v5 + 24) = 0;
    char v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    uint64_t v8 = off_1EB5EE540;
    if (off_1EB5EE540) {
      goto LABEL_32;
    }
    goto LABEL_24;
  }
  operator delete(v34.__r_.__value_.__l.__data_);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v5 + 24)) {
    goto LABEL_18;
  }
LABEL_12:
  char v30 = 7;
  strcpy((char *)__p, "Enabled");
  memset(&v35, 0, sizeof(v35));
  if (prop::coredump::get((char *)__p, (uint64_t)&v35))
  {
    char v6 = util::convert<BOOL>(&v35, (BOOL *)(v2 + 168), 0);
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_22;
    }
  }
  else
  {
    char v6 = 0;
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_22;
    }
  }
  operator delete(v35.__r_.__value_.__l.__data_);
LABEL_22:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
  if (v30 < 0)
  {
    operator delete(__p[0]);
    char v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    uint64_t v8 = off_1EB5EE540;
    if (off_1EB5EE540) {
      goto LABEL_32;
    }
  }
  else
  {
    char v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    uint64_t v8 = off_1EB5EE540;
    if (off_1EB5EE540) {
      goto LABEL_32;
    }
  }
LABEL_24:
  CommandDriverFactory::create_default_global((uint64_t *)&v35, v7);
  long long v9 = *(_OWORD *)&v35.__r_.__value_.__l.__data_;
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = 0uLL;
  int v10 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
  off_1EB5EE540 = v9;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  size_t size = (std::__shared_weak_count *)v35.__r_.__value_.__l.__size_;
  if (v35.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v35.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
    std::__shared_weak_count::__release_weak(size);
  }
  uint64_t v8 = off_1EB5EE540;
LABEL_32:
  uint64_t v27 = v8;
  char v28 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
  if (*(&off_1EB5EE540 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE540 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v8 + 136))(__p, v8);
  long long v12 = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  long long v13 = *(std::__shared_weak_count **)(v2 + 160);
  *(_OWORD *)(v2 + 152) = v12;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  std::string v14 = (std::__shared_weak_count *)__p[1];
  if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(v2 + 80);
  if (!v15 || (v16 = *(void *)(v2 + 72), (xpc_object_t v17 = std::__shared_weak_count::lock(v15)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v18 = v17;
  p_shared_weak_owners = &v17->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v18);
  }
  memset(&v35, 170, 16);
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke_2;
  aBlock[3] = &__block_descriptor_56_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE_e5_v8__0l;
  aBlock[4] = v2;
  void aBlock[5] = v16;
  uint64_t v26 = v18;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v20 = _Block_copy(aBlock);
  char v21 = *(NSObject **)(v2 + 88);
  if (v21) {
    dispatch_retain(*(dispatch_object_t *)(v2 + 88));
  }
  v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
  v35.__r_.__value_.__l.__size_ = (std::string::size_type)v21;
  uint64_t v22 = *(void *)(v2 + 152);
  if (v20)
  {
    uint64_t v23 = _Block_copy(v20);
    dispatch_object_t v24 = v21;
    if (!v21) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
  uint64_t v23 = 0;
  dispatch_object_t v24 = v21;
  if (v21) {
LABEL_51:
  }
    dispatch_retain(v21);
LABEL_52:
  (*(void (**)(uint64_t, void **))(*(void *)v22 + 104))(v22, &v23);
  if (v24) {
    dispatch_release(v24);
  }
  if (v23) {
    _Block_release(v23);
  }
  if (v21) {
    dispatch_release(v21);
  }
  if (v20) {
    _Block_release(v20);
  }
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  std::__shared_weak_count::__release_weak(v18);
}

void sub_1A611EA24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,dispatch_object_t object,uint64_t a28,std::__shared_weak_count *a29)
{
}

void ___ZN13CoredumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke_2(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (CoredumpTrace *)a1[4];
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5]) {
        CoredumpTrace::processCrashReason_sync(v3);
      }
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
}

void sub_1A611EBCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CoredumpTrace::processCrashReason_sync(CoredumpTrace *this)
{
  uint64_t v2 = *((void *)this + 18);
  if (v2)
  {
    dispatch_retain(*((dispatch_object_t *)this + 18));
    dispatch_group_enter(v2);
  }
  if (*((unsigned char *)this + 232))
  {
    *((unsigned char *)this + 232) = 0;
    CoredumpTrace::createScratchPath_sync(this);
    if (CoredumpTrace::fetchPostBootCrashReport_sync((int **)this))
    {
      xpc_object_t object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(xpc_object_t *__return_ptr, CoredumpTrace *))(*(void *)this + 192))(&object, this);
      CoredumpTrace::storeCrashReason_sync((NSObject **)this, (const xpc::dict *)&object);
      CoredumpTrace::submitCrashReason_sync(this, &object);
      CoredumpTrace::updateAnalyticsEvent_sync(this, &object);
      xpc_release(object);
    }
    uint64_t v3 = (char *)this + 176;
    support::fs::removeDirContents(v3, 0);
    support::fs::removeDir(v3);
  }
  if (v2)
  {
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

void sub_1A611ECD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::abort(uint64_t a1, const void *a2, ctu **a3)
{
  ctu::cf_to_xpc((uint64_t *)object, *a3, a2);
  xpc_object_t v4 = object[0];
  uint64_t v5 = MEMORY[0x1E4F14590];
  if (object[0] && MEMORY[0x1A6275E60](object[0]) == v5) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  xpc_release(object[0]);
  if (MEMORY[0x1A6275E60](v4) == v5)
  {
    memset(object, 170, sizeof(object));
    xpc_object_t value = xpc_dictionary_get_value(v4, (const char *)*MEMORY[0x1E4F4CA38]);
    xpc_object_t v12 = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      xpc_object_t v12 = xpc_null_create();
    }
    xpc::dyn_cast_or_default();
    xpc_release(v12);
    char v7 = (const char *)*MEMORY[0x1E4F4D130];
    char v8 = HIBYTE(object[2]);
    if (SHIBYTE(object[2]) < 0)
    {
      long long v9 = (xpc_object_t *)object[0];
      if (!strcasecmp(v7, (const char *)object[0]) || !strcasecmp((const char *)*MEMORY[0x1E4F4D1A0], (const char *)v9))
      {
LABEL_21:
        *(unsigned char *)(a1 + 232) = 1;
        uint64_t v11 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
        goto LABEL_17;
      }
    }
    else
    {
      if (!strcasecmp(v7, (const char *)object)) {
        goto LABEL_21;
      }
      long long v9 = object;
      if (!strcasecmp((const char *)*MEMORY[0x1E4F4D1A0], (const char *)object)) {
        goto LABEL_21;
      }
    }
    int v10 = strcasecmp((const char *)*MEMORY[0x1E4F4D030], (const char *)v9);
    *(unsigned char *)(a1 + 232) = v10 == 0;
    if (v10 || (uint64_t v11 = *(NSObject **)(a1 + 40), !os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)))
    {
LABEL_18:
      if (v8 < 0) {
        operator delete(object[0]);
      }
      goto LABEL_20;
    }
LABEL_17:
    LOWORD(v12) = 0;
    _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Baseband crash reason will be parsed", (uint8_t *)&v12, 2u);
    char v8 = HIBYTE(object[2]);
    goto LABEL_18;
  }
LABEL_20:
  xpc_release(v4);
}

void sub_1A611EEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v9);
  _Unwind_Resume(a1);
}

void CoredumpTrace::snapshot(void *a1, dispatch_object_t *a2, const __CFDictionary **a3)
{
  char v6 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v6);
  }
  uint64_t v8 = a1[9];
  char v7 = (std::__shared_weak_count *)a1[10];
  if (!v7 || (long long v9 = std::__shared_weak_count::lock(v7)) == 0) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  v34[0] = 0xAAAAAAAAAAAAAAAALL;
  v34[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v34, *a3);
  memset(v33, 170, sizeof(v33));
  std::string __p = operator new(0x28uLL);
  long long v32 = xmmword_1A61F71C0;
  strcpy((char *)__p, "kCollectTelephonyLogsWithCoredump");
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v35, "kKeyTraceAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v35);
  operator delete(__p);
  uint64_t v11 = (void *)HIBYTE(v33[2]);
  if (SHIBYTE(v33[2]) < 0) {
    uint64_t v11 = v33[1];
  }
  if (v11 != (void *)33) {
    goto LABEL_25;
  }
  xpc_object_t v12 = v33;
  if (SHIBYTE(v33[2]) < 0) {
    xpc_object_t v12 = (void **)v33[0];
  }
  long long v13 = *v12;
  std::string v14 = v12[1];
  uint64_t v15 = v12[2];
  uint64_t v16 = v12[3];
  uint64_t v17 = *((unsigned __int8 *)v12 + 32);
  BOOL v18 = v13 == *(void **)"kCollectTelephonyLogsWithCoredump" && v14 == *(void **)"TelephonyLogsWithCoredump";
  BOOL v19 = v18 && v15 == *(void **)"yLogsWithCoredump";
  BOOL v20 = v19 && v16 == *(void **)"hCoredump";
  if (v20 && v17 == str_68[32])
  {
    v25[0] = MEMORY[0x1E4F143A8];
    v25[1] = 3321888768;
    v25[2] = ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    v25[3] = &__block_descriptor_80_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c21_ZTSN8dispatch5groupE72c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_e5_v8__0l;
    v25[4] = a1;
    dispatch_group_t group = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(group);
    }
    uint64_t v27 = v8;
    char v28 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v23 = *a2;
    dispatch_object_t object = v23;
    if (v23) {
      dispatch_retain(v23);
    }
    CFDictionaryRef v24 = *a3;
    CFTypeRef cf = v24;
    if (v24) {
      CFRetain(v24);
    }
    ctu::SharedSynchronizable<Trace>::execute_wrapped(a1 + 9, (uint64_t)v25);
    if (cf) {
      CFRelease(cf);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  else
  {
LABEL_25:
    uint64_t v22 = a1[5];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl(&dword_1A609F000, v22, OS_LOG_TYPE_DEFAULT, "#I Skipping coredump collection", (uint8_t *)&__p, 2u);
    }
  }
  if (SHIBYTE(v33[2]) < 0) {
    operator delete(v33[0]);
  }
  MEMORY[0x1A6274930](v34);
  std::__shared_weak_count::__release_weak(v10);
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
}

void ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(NSObject **)(v2 + 144);
  if (v3)
  {
    dispatch_retain(*(dispatch_object_t *)(v2 + 144));
    dispatch_group_enter(v3);
  }
  xpc_object_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    BOOL v19 = v5;
    if (v5)
    {
      char v6 = v5;
      if (a1[6])
      {
        if (*(unsigned char *)(v2 + 168)
          || (capabilities::trace::supportsCoredumpCrashReasonOnCustomerBuild((capabilities::trace *)v5) & 1) != 0)
        {
          global_queue = dispatch_get_global_queue(0, 0);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3321888768;
          block[2] = ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_5;
          block[3] = &__block_descriptor_72_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_e5_v8__0l;
          uint64_t v8 = a1[5];
          block[4] = v2;
          dispatch_group_t group = v8;
          if (v8)
          {
            dispatch_retain(v8);
            dispatch_group_enter(group);
          }
          dispatch_group_t v14 = v3;
          if (v3)
          {
            dispatch_retain(v3);
            dispatch_group_enter(v14);
          }
          long long v9 = a1[8];
          dispatch_object_t object = v9;
          if (v9) {
            dispatch_retain(v9);
          }
          int v10 = (const void *)a1[9];
          CFTypeRef cf = v10;
          if (v10) {
            CFRetain(v10);
          }
          dispatch_async(global_queue, block);
          if (cf) {
            CFRelease(cf);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v14)
          {
            dispatch_group_leave(v14);
            if (v14) {
              dispatch_release(v14);
            }
          }
          if (group)
          {
            dispatch_group_leave(group);
            if (group) {
              dispatch_release(group);
            }
          }
        }
        else
        {
          uint64_t v11 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I skipping coredump collection (disabled)", buf, 2u);
          }
        }
      }
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
}

void sub_1A611F4DC(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 64);
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void ___ZN13CoredumpTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_5(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  uint64_t v4 = xmmword_1EB5EE590;
  if (!(void)xmmword_1EB5EE590)
  {
    ctu::XpcJetsamAssertion::create_default_global((uint64_t *)buf, v3);
    long long v5 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    char v6 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
    xmmword_1EB5EE590 = v5;
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    char v7 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v4 = xmmword_1EB5EE590;
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
  uint64_t v17 = v4;
  uint64_t v18 = *((void *)&xmmword_1EB5EE590 + 1);
  if (*((void *)&xmmword_1EB5EE590 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  char v16 = 19;
  strcpy(__p, "coredump collection");
  ctu::XpcJetsamAssertion::createActivity();
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  long long v9 = a1[7];
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  int v10 = (const void *)a1[8];
  CFTypeRef cf = v10;
  if (v10) {
    CFRetain(v10);
  }
  (*(void (**)(void *, dispatch_object_t *, CFTypeRef *))(*v2 + 168))(v2, &object, &cf);
  if (cf) {
    CFRelease(cf);
  }
  if (object) {
    dispatch_release(object);
  }
  uint64_t v11 = v2[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I snapshot complete", buf, 2u);
  }
  xpc_object_t v12 = (std::__shared_weak_count *)v20;
  if (v20)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v20 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_1A611F7B8(_Unwind_Exception *a1)
{
}

void sub_1A611F7DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

void sub_1A611F804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    long long v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  char v6 = a2[6];
  a1[6] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    char v7 = a1[6];
    if (v7) {
      dispatch_group_enter(v7);
    }
  }
  uint64_t v8 = a2[7];
  a1[7] = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  CFTypeRef result = (CFTypeRef)a2[8];
  a1[8] = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c21_ZTSN8dispatch5groupE64c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(void *a1)
{
  uint64_t v2 = (const void *)a1[8];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = a1[7];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = a1[6];
  if (v4)
  {
    dispatch_group_leave(v4);
    long long v5 = a1[6];
    if (v5) {
      dispatch_release(v5);
    }
  }
  char v6 = a1[5];
  if (v6)
  {
    dispatch_group_leave(v6);
    char v7 = a1[5];
    if (v7)
    {
      dispatch_release(v7);
    }
  }
}

void CoredumpTrace::dumpState(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 168)) {
      uint64_t v3 = "True";
    }
    else {
      uint64_t v3 = "False";
    }
    int v4 = 136315138;
    long long v5 = v3;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Enabled: %s", (uint8_t *)&v4, 0xCu);
  }
}

BOOL CoredumpTrace::setProperty(capabilities::trace *a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  char v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (capabilities::trace::allowed(a1))
  {
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2020000000;
    char v20 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3321888768;
    v13[2] = ___ZN13CoredumpTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke;
    v13[3] = &unk_1EFB0B580;
    v13[5] = a1;
    dispatch_group_t group = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(group);
    }
    uint64_t v15 = a3;
    uint64_t v16 = a4;
    v13[4] = &v17;
    char v21 = v13;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
    block[3] = &__block_descriptor_48_e5_v8__0l;
    block[4] = (char *)a1 + 72;
    void block[5] = &v21;
    uint64_t v8 = *((void *)a1 + 11);
    if (*((void *)a1 + 12))
    {
      dispatch_async_and_wait(v8, block);
      BOOL v9 = *((unsigned char *)v18 + 24) != 0;
      int v10 = group;
      if (!group) {
        goto LABEL_14;
      }
    }
    else
    {
      dispatch_sync(v8, block);
      BOOL v9 = *((unsigned char *)v18 + 24) != 0;
      int v10 = group;
      if (!group)
      {
LABEL_14:
        _Block_object_dispose(&v17, 8);
        goto LABEL_15;
      }
    }
    dispatch_group_leave(v10);
    if (group) {
      dispatch_release(group);
    }
    goto LABEL_14;
  }
  uint64_t v11 = *((void *)a1 + 5);
  BOOL v9 = 0;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Set property is not allowed", (uint8_t *)block, 2u);
    BOOL v9 = 0;
  }
LABEL_15:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v9;
}

void sub_1A611FBE4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN13CoredumpTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 56);
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&__p, "Enabled");
  if (*(char *)(v3 + 23) >= 0) {
    int v4 = (const char *)v3;
  }
  else {
    int v4 = *(const char **)v3;
  }
  if (!strcasecmp(v4, (const char *)&__p))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = prop::coredump::set(v3, *(char **)(a1 + 64));
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v5 + 24))
    {
      *(unsigned char *)(v5 + 24) = 0;
      return;
    }
    uint64_t v6 = *(char **)(a1 + 56);
    memset(&__p, 0, sizeof(__p));
    if (prop::coredump::get(v6, (uint64_t)&__p))
    {
      char v7 = util::convert<BOOL>(&__p, (BOOL *)(v2 + 168), 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_11;
      }
    }
    else
    {
      char v7 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_11:
      }
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
  }
}

void sub_1A611FD2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  BOOL v9 = &v8;
  uint64_t v10 = 0x2020000000;
  char v11 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZN13CoredumpTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke;
  v7[3] = &unk_1E5C472D0;
  v7[6] = a2;
  v7[7] = a3;
  v7[4] = &v8;
  v7[5] = a1;
  xpc_object_t v12 = v7;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2;
  block[3] = &__block_descriptor_48_e5_v8__0l;
  block[4] = a1 + 72;
  void block[5] = &v12;
  uint64_t v4 = a1 + 88;
  uint64_t v3 = *(NSObject **)(a1 + 88);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void ___ZN13CoredumpTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke(void *a1)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[5];
  uint64_t v2 = a1[6];
  *((unsigned char *)&v17.__r_.__value_.__s + 23) = 5;
  LODWORD(v17.__r_.__value_.__l.__data_) = *(_DWORD *)"State";
  WORD2(v17.__r_.__value_.__r.__words[0]) = str_23_0[4];
  if (*(char *)(v2 + 23) >= 0) {
    uint64_t v4 = (const char *)v2;
  }
  else {
    uint64_t v4 = *(const char **)v2;
  }
  if (!strcasecmp(v4, (const char *)&v17))
  {
    *((unsigned char *)&v18.__r_.__value_.__s + 23) = 9;
    strcpy((char *)&v18, "Enabled: ");
    std::to_string(&v17, *(unsigned __int8 *)(v3 + 168));
    std::string __p = v17;
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    char v11 = std::string::append(&v18, (const std::string::value_type *)p_p, size);
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[0];
    v19[0] = v11->__r_.__value_.__l.__size_;
    *(void *)((char *)v19 + 7) = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    char v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    uint64_t v14 = a1[7];
    if (*(char *)(v14 + 23) < 0) {
      operator delete(*(void **)v14);
    }
    uint64_t v15 = v19[0];
    *(void *)uint64_t v14 = v12;
    *(void *)(v14 + 8) = v15;
    *(void *)(v14 + 15) = *(void *)((char *)v19 + 7);
    *(unsigned char *)(v14 + 23) = v13;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_19;
      }
    }
    else if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_19;
    }
    operator delete(v18.__r_.__value_.__l.__data_);
    goto LABEL_19;
  }
  *((unsigned char *)&v17.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v17, "Enabled");
  if (strcasecmp(v4, (const char *)&v17)) {
    return;
  }
  int v5 = *(unsigned __int8 *)(v3 + 168);
  v18.__r_.__value_.__r.__words[0] = 0;
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7) = 0;
  std::to_string(&v17, v5);
  v18.__r_.__value_.__r.__words[0] = v17.__r_.__value_.__l.__size_;
  std::string::size_type v6 = v17.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v17.__r_.__value_.__r.__words[1] + 7);
  char v7 = HIBYTE(v17.__r_.__value_.__r.__words[2]);
  uint64_t v8 = a1[7];
  if (*(char *)(v8 + 23) < 0) {
    operator delete(*(void **)v8);
  }
  *(void *)uint64_t v8 = v6;
  *(void *)(v8 + 8) = v18.__r_.__value_.__r.__words[0];
  *(void *)(v8 + 15) = *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 7);
  *(unsigned char *)(v8 + 23) = v7;
LABEL_19:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
}

void sub_1A6120060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    if (*(char *)(*(void *)(v23 + 56) + 23) < 0) {
      JUMPOUT(0x1A611FF24);
    }
    JUMPOUT(0x1A611FF2CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A61200E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((a14 & 0x80000000) == 0) {
    JUMPOUT(0x1A61200A8);
  }
  JUMPOUT(0x1A61200A0);
}

BOOL CoredumpTrace::createScratchPath_sync(CoredumpTrace *this)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*((char *)this + 199) < 0)
  {
    **((unsigned char **)this + 22) = 0;
    *((void *)this + 23) = 0;
  }
  else
  {
    *((unsigned char *)this + 176) = 0;
    *((unsigned char *)this + 199) = 0;
  }
  uint64_t v2 = abm::trace::kScratchFolder[0];
  size_t v3 = strlen(abm::trace::kScratchFolder[0]);
  if (v3 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v4 = v3;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    p_dst = (std::string *)operator new(v6 + 1);
    __dst.__r_.__value_.__l.__size_ = v4;
    __dst.__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_11;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v3;
  p_dst = &__dst;
  if (v3) {
LABEL_11:
  }
    memmove(p_dst, v2, v4);
  p_dst->__r_.__value_.__s.__data_[v4] = 0;
  char v30 = 16;
  strcpy(__s, "CoreDump.scratch");
  uint64_t v8 = std::string::append(&__dst, __s, 0x10uLL);
  BOOL v9 = (std::string::value_type *)v8->__r_.__value_.__r.__words[0];
  std::string::size_type size = v8->__r_.__value_.__l.__size_;
  std::string::size_type v11 = v8->__r_.__value_.__r.__words[2];
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((v30 & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_14;
    }
LABEL_17:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((v11 & 0x8000000000000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  operator delete(*(void **)__s);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_17;
  }
LABEL_14:
  if ((v11 & 0x8000000000000000) == 0)
  {
LABEL_15:
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)v9;
    v28.__r_.__value_.__l.__size_ = size;
    v28.__r_.__value_.__r.__words[2] = v11;
    goto LABEL_19;
  }
LABEL_18:
  std::string::__init_copy_ctor_external(&v28, v9, size);
LABEL_19:
  support::fs::createUniquePath((const char *)&v28, &__dst);
  std::string::size_type v12 = (void **)((char *)this + 176);
  if (*((char *)this + 199) < 0) {
    operator delete(*v12);
  }
  *(_OWORD *)std::string::size_type v12 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *((void *)this + 24) = *((void *)&__dst.__r_.__value_.__l + 2);
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  BOOL Dir = support::fs::createDir((const char *)this + 176, 0x1EDu, 1);
  int v14 = *((char *)this + 199);
  if (v14 >= 0) {
    size_t v15 = *((unsigned __int8 *)this + 199);
  }
  else {
    size_t v15 = *((void *)this + 23);
  }
  unint64_t v16 = v15 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v15 + 1 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  BOOL v17 = Dir;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    std::string v18 = (std::string *)operator new(v19 + 1);
    __dst.__r_.__value_.__l.__size_ = v15 + 1;
    __dst.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    std::string v18 = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v15 + 1;
    if (!v15) {
      goto LABEL_37;
    }
  }
  if (v14 >= 0) {
    char v21 = (char *)this + 176;
  }
  else {
    char v21 = (char *)*v12;
  }
  memmove(v18, v21, v15);
LABEL_37:
  *(_WORD *)((char *)&v18->__r_.__value_.__l.__data_ + v15) = 47;
  uint64_t v22 = std::string::append(&__dst, "report.json", 0xBuLL);
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[0];
  *(void *)__s = v22->__r_.__value_.__l.__size_;
  *(void *)&__s[7] = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
  char v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  uint64_t v25 = *(void *)__s;
  *((void *)this + 25) = v23;
  *((void *)this + 26) = v25;
  *(void *)((char *)this + 215) = *(void *)&__s[7];
  *((unsigned char *)this + 223) = v24;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v17) {
      goto LABEL_44;
    }
  }
  else if (v17)
  {
    goto LABEL_44;
  }
  uint64_t v26 = *((void *)this + 5);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 199) < 0) {
      std::string::size_type v12 = (void **)*v12;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
    _os_log_error_impl(&dword_1A609F000, v26, OS_LOG_TYPE_ERROR, "Failed creating coredump scratch path. fScratchFolder=[%s]", (uint8_t *)&__dst, 0xCu);
    if ((v11 & 0x8000000000000000) != 0) {
      goto LABEL_45;
    }
    return v17;
  }
LABEL_44:
  if ((v11 & 0x8000000000000000) != 0) {
LABEL_45:
  }
    operator delete(v9);
  return v17;
}

void sub_1A612047C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (v29 < 0) {
    operator delete(v28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::fetchPostBootCrashReport_sync(int **this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v10 = -1431655766;
  if (AriHost::RegisterClient((AriHost *)"CoreDumpTrace", (const char *)&v10, this[28], (dispatch_queue_s *)0xFFFFFFFFLL))
  {
    BOOL v9 = GetOsLogContext()[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
      goto LABEL_22;
    }
    *(_DWORD *)std::string::size_type v12 = 136315906;
    *(void *)&v12[4] = "ABM ASSERT";
    *(_WORD *)&v12[12] = 2080;
    *(void *)&v12[14] = "ARI_RESULT_OK == AriHost::RegisterClient( \"CoreDumpTrace\", &ctxId, *fClientQueue)";
    *(_WORD *)&v12[22] = 2080;
    *(void *)&v12[24] = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/CoreDump/CoreDumpTrace.mm";
    LOWORD(v13) = 1024;
    *(_DWORD *)((char *)&v13 + 2) = 880;
    goto LABEL_21;
  }
  if (!v10)
  {
    BOOL v9 = GetOsLogContext()[1];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_FAULT)) {
      goto LABEL_22;
    }
    *(_DWORD *)std::string::size_type v12 = 136315906;
    *(void *)&v12[4] = "ABM ASSERT";
    *(_WORD *)&v12[12] = 2080;
    *(void *)&v12[14] = "ctxId != ARI_AP_SINGLE_MODE_CTX";
    *(_WORD *)&v12[22] = 2080;
    *(void *)&v12[24] = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/CoreDump/CoreDumpTrace.mm";
    LOWORD(v13) = 1024;
    *(_DWORD *)((char *)&v13 + 2) = 881;
LABEL_21:
    _os_log_fault_impl(&dword_1A609F000, v9, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", v12, 0x26u);
LABEL_22:
    __break(1u);
  }
  if (!KTLInitOptions() || !KTLOpenChannel()) {
    goto LABEL_13;
  }
  uint64_t v2 = *((char *)this + 223) >= 0 ? (const char *)(this + 25) : (const char *)this[25];
  int v3 = open(v2, 1537, 420);
  if (v3 < 0) {
    goto LABEL_13;
  }
  int v4 = v3;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v14 = v5;
  long long v15 = v5;
  *(_OWORD *)&uint8_t v12[16] = v5;
  long long v13 = v5;
  *(_OWORD *)std::string::size_type v12 = v5;
  if (TelephonyUtilTransportCreateWithFD())
  {
    KTLSahGetCrashReport();
    uint64_t v6 = this[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109120;
      v11[1] = 0;
      _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Baseband crash report size: %d bytes", (uint8_t *)v11, 8u);
    }
    close(v4);
    TelephonyUtilTransportFree();
    CoredumpTrace::cleanCrashReport_sync((CoredumpTrace *)this);
    KTLCloseChannel();
    AriHost::DeregisterClient((AriHost *)v10);
  }
  else
  {
LABEL_13:
    KTLCloseChannel();
    AriHost::DeregisterClient((AriHost *)v10);
  }
  uint64_t v7 = this[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string::size_type v12 = 0;
    _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Error fetching post-boot Baseband crash report", v12, 2u);
  }
  return 0;
}

void CoredumpTrace::storeCrashReason_sync(NSObject **this, const xpc::dict *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (MEMORY[0x1A6275E60](*(void *)a2) == MEMORY[0x1E4F14590])
  {
    memset(&buf, 170, sizeof(buf));
    ((void (*)(std::string *__return_ptr, NSObject **, const xpc::dict *))(*this)[25].isa)(&buf, this, a2);
    long long v5 = this[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      p_std::string buf = &buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      LODWORD(v14) = 136446210;
      *(void *)((char *)&v14 + 4) = p_buf;
      _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Baseband crash: %{public}s", (uint8_t *)&v14, 0xCu);
    }
    uint64_t v7 = (std::__shared_weak_count *)this[17];
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      *((void *)&v14 + 1) = v8;
      if (v8)
      {
        BOOL v9 = v8;
        uint64_t v10 = (uint64_t)this[16];
        *(void *)&long long v14 = v10;
        if (v10)
        {
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v12, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
          }
          else {
            std::string v12 = buf;
          }
          v11[0] = 0;
          v11[1] = 0;
          abm::BasebandTracingTask::setLastCrashReason(v10, (uint64_t)&v12, (uint64_t)v11);
          if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v12.__r_.__value_.__l.__data_);
          }
        }
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int v4 = this[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Invalid Baseband crash dictionary", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_1A6120AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v23 - 48);
  if (a23 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void CoredumpTrace::submitCrashReason_sync(CoredumpTrace *this, xpc_object_t *a2)
{
  uint64_t v4 = MEMORY[0x1A6275E60](*a2);
  uint64_t v5 = MEMORY[0x1E4F14590];
  uint64_t v6 = *((void *)this + 5);
  if (v4 != MEMORY[0x1E4F14590])
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Invalid Baseband crash dictionary", buf, 2u);
    }
    return;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting AWD of crash info", buf, 2u);
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v7) == v5)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v7 = 0;
  }
  xpc_release(v7);
  xpc_object_t v9 = xpc_array_create(0, 0);
  if (v9 || (xpc_object_t v9 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v9) == MEMORY[0x1E4F14568])
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
    }
    else
    {
      xpc_object_t v10 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v9 = 0;
  }
  xpc_release(v9);
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v11) == v5)
    {
      xpc_retain(v11);
      xpc_object_t v12 = v11;
    }
    else
    {
      xpc_object_t v12 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v11 = 0;
  }
  xpc_release(v11);
  (*(void (**)(uint8_t *__return_ptr, CoredumpTrace *, xpc_object_t *))(*(void *)this + 200))(buf, this, a2);
  if ((buf[23] & 0x80u) == 0) {
    long long v13 = buf;
  }
  else {
    long long v13 = *(uint8_t **)buf;
  }
  xpc_object_t v14 = xpc_string_create((const char *)v13);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E4F4C8C0], v14);
  xpc_object_t v15 = xpc_null_create();
  xpc_release(v14);
  xpc_release(v15);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  memset(buf, 170, 24);
  xpc_object_t value = xpc_dictionary_get_value(*a2, "host_line");
  xpc_object_t object = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  xpc_release(object);
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v17 = buf;
  }
  else {
    uint64_t v17 = *(uint8_t **)buf;
  }
  unsigned int v18 = atoi((const char *)v17);
  xpc_object_t v19 = xpc_int64_create(v18);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E4F4C798], v19);
  xpc_object_t v20 = xpc_null_create();
  xpc_release(v19);
  xpc_release(v20);
  xpc_object_t v21 = xpc_dictionary_get_value(*a2, "host_filename");
  xpc_object_t v36 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v36 = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  if (v39 >= 0) {
    p_xpc_object_t object = (const char *)&object;
  }
  else {
    p_xpc_object_t object = (const char *)object;
  }
  xpc_object_t v23 = xpc_string_create(p_object);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  xpc_dictionary_set_value(v12, (const char *)*MEMORY[0x1E4F4C538], v23);
  xpc_object_t v24 = xpc_null_create();
  xpc_release(v23);
  xpc_release(v24);
  if (v39 < 0) {
    operator delete(object);
  }
  xpc_release(v36);
  xpc_array_append_value(v10, v12);
  xpc_object_t v25 = xpc_string_create((const char *)*MEMORY[0x1E4F4D2D0]);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E4F4C190], v25);
  xpc_object_t v26 = xpc_null_create();
  xpc_release(v25);
  xpc_release(v26);
  xpc_object_t v27 = xpc_int64_create(524365);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E4F4C258], v27);
  xpc_object_t v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  if (v10)
  {
    xpc_retain(v10);
    xpc_object_t v29 = v10;
  }
  else
  {
    xpc_object_t v29 = xpc_null_create();
  }
  xpc_dictionary_set_value(v8, (const char *)*MEMORY[0x1E4F4C188], v29);
  xpc_object_t v30 = xpc_null_create();
  xpc_release(v29);
  xpc_release(v30);
  unint64_t v31 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v31)
  {
    uint64_t v32 = std::__shared_weak_count::lock(v31);
    char v38 = v32;
    if (v32)
    {
      uint64_t v33 = (void *)*((void *)this + 16);
      xpc_object_t object = v33;
      if (!v33)
      {
        std::string v34 = v32;
        goto LABEL_64;
      }
      xpc_object_t v35 = v8;
      if (v8) {
        xpc_retain(v8);
      }
      else {
        xpc_object_t v35 = xpc_null_create();
      }
      abm::BasebandTracingTask::commandReportStatsAWD((uint64_t)v33, &v35);
      xpc_release(v35);
      xpc_object_t v35 = 0;
      std::string v34 = v38;
      if (v38)
      {
LABEL_64:
        if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v12);
  xpc_release(v10);
  xpc_release(v8);
}

void sub_1A61210CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(v22);
  xpc_release(v21);
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void CoredumpTrace::updateAnalyticsEvent_sync(CoredumpTrace *this, xpc_object_t *a2)
{
  uint64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Updating Analytics metric of crash info", buf, 2u);
  }
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  uint64_t v6 = MEMORY[0x1E4F14590];
  if (v5 || (xpc_object_t v5 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v5) == v6)
    {
      xpc_retain(v5);
      xpc_object_t v7 = v5;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v5 = 0;
  }
  xpc_release(v5);
  (*(void (**)(uint8_t *__return_ptr, CoredumpTrace *, xpc_object_t *))(*(void *)this + 200))(buf, this, a2);
  if ((buf[23] & 0x80u) == 0) {
    xpc_object_t v8 = buf;
  }
  else {
    xpc_object_t v8 = *(uint8_t **)buf;
  }
  xpc_object_t v9 = xpc_string_create((const char *)v8);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "resetReason", v9);
  xpc_object_t v10 = xpc_null_create();
  xpc_release(v9);
  xpc_release(v10);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  memset(buf, 170, 24);
  xpc_object_t value = xpc_dictionary_get_value(*a2, "host_line");
  object[0] = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    object[0] = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  xpc_release(object[0]);
  memset(object, 170, sizeof(object));
  xpc_object_t v12 = xpc_dictionary_get_value(*a2, "host_filename");
  v52[1] = v12;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    v52[1] = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  xpc_release((xpc_object_t)v52[1]);
  memset(v52, 170, sizeof(v52));
  if (SHIBYTE(object[2]) >= 0) {
    size_t v13 = HIBYTE(object[2]);
  }
  else {
    size_t v13 = (size_t)object[1];
  }
  unint64_t v14 = v13 + 1;
  std::string __dst = (void **)0xAAAAAAAAAAAAAAAALL;
  unint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
  if (v13 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v14 >= 0x17)
  {
    uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v16 = v14 | 7;
    }
    uint64_t v17 = v16 + 1;
    p_dst = (void **)operator new(v16 + 1);
    unint64_t v51 = v13 + 1;
    v52[0] = v17 | 0x8000000000000000;
    std::string __dst = p_dst;
  }
  else
  {
    unint64_t v51 = 0;
    v52[0] = 0;
    std::string __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v52[0]) = v13 + 1;
    if (!v13) {
      goto LABEL_36;
    }
  }
  if (SHIBYTE(object[2]) >= 0) {
    unsigned int v18 = object;
  }
  else {
    unsigned int v18 = (xpc_object_t *)object[0];
  }
  memmove(p_dst, v18, v13);
LABEL_36:
  *(_WORD *)((char *)p_dst + v13) = 58;
  if ((buf[23] & 0x80u) == 0) {
    xpc_object_t v19 = buf;
  }
  else {
    xpc_object_t v19 = *(uint8_t **)buf;
  }
  if ((buf[23] & 0x80u) == 0) {
    std::string::size_type v20 = buf[23];
  }
  else {
    std::string::size_type v20 = *(void *)&buf[8];
  }
  xpc_object_t v21 = std::string::append((std::string *)&__dst, (const std::string::value_type *)v19, v20);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v52[3] = *((void *)&v21->__r_.__value_.__l + 2);
  *(_OWORD *)&v52[1] = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v52[0]) < 0) {
    operator delete(__dst);
  }
  if (v52[3] >= 0) {
    xpc_object_t v23 = (const char *)&v52[1];
  }
  else {
    xpc_object_t v23 = (const char *)v52[1];
  }
  xpc_object_t v24 = xpc_string_create(v23);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "shortResetReason", v24);
  xpc_object_t v25 = xpc_null_create();
  xpc_release(v24);
  xpc_release(v25);
  if (SHIBYTE(object[2]) >= 0) {
    xpc_object_t v26 = object;
  }
  else {
    xpc_object_t v26 = (xpc_object_t *)object[0];
  }
  xpc_object_t v27 = xpc_string_create((const char *)v26);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "basebandCrashFileName", v27);
  xpc_object_t v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  xpc_object_t v29 = xpc_dictionary_create(0, 0, 0);
  if (v29 || (xpc_object_t v29 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v29) == v6)
    {
      xpc_retain(v29);
      xpc_object_t v30 = v29;
    }
    else
    {
      xpc_object_t v30 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v30 = xpc_null_create();
    xpc_object_t v29 = 0;
  }
  xpc_release(v29);
  xpc_object_t v31 = xpc_string_create("metricsCCBasebandResetInfo");
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E4F4C3C8], v31);
  xpc_object_t v32 = xpc_null_create();
  xpc_release(v31);
  xpc_release(v32);
  xpc_object_t v33 = xpc_string_create("Crash");
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E4F4C548], v33);
  xpc_object_t v34 = xpc_null_create();
  xpc_release(v33);
  xpc_release(v34);
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v35 = v7;
  }
  else
  {
    xpc_object_t v35 = xpc_null_create();
  }
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E4F4CB40], v35);
  xpc_object_t v36 = xpc_null_create();
  xpc_release(v35);
  xpc_release(v36);
  xpc_object_t v37 = xpc_string_create((const char *)*MEMORY[0x1E4F4C5A0]);
  if (!v37) {
    xpc_object_t v37 = xpc_null_create();
  }
  xpc_dictionary_set_value(v30, (const char *)*MEMORY[0x1E4F4C540], v37);
  xpc_object_t v38 = xpc_null_create();
  xpc_release(v37);
  xpc_release(v38);
  xpc_object_t v39 = xpc_dictionary_create(0, 0, 0);
  if (v39 || (xpc_object_t v39 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v39) == v6)
    {
      xpc_retain(v39);
      xpc_object_t v40 = v39;
    }
    else
    {
      xpc_object_t v40 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v40 = xpc_null_create();
    xpc_object_t v39 = 0;
  }
  xpc_release(v39);
  xpc_object_t v41 = xpc_string_create((const char *)*MEMORY[0x1E4F4C158]);
  if (!v41) {
    xpc_object_t v41 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, (const char *)*MEMORY[0x1E4F4C190], v41);
  xpc_object_t v42 = xpc_null_create();
  xpc_release(v41);
  xpc_release(v42);
  if (v30)
  {
    xpc_retain(v30);
    xpc_object_t v43 = v30;
  }
  else
  {
    xpc_object_t v43 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, (const char *)*MEMORY[0x1E4F4C188], v43);
  xpc_object_t v44 = xpc_null_create();
  xpc_release(v43);
  xpc_release(v44);
  uint64_t v45 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v45)
  {
    BOOL v46 = std::__shared_weak_count::lock(v45);
    unint64_t v51 = (unint64_t)v46;
    if (v46)
    {
      uint64_t v47 = (void **)*((void *)this + 16);
      std::string __dst = v47;
      if (!v47)
      {
        uint64_t v48 = v46;
LABEL_88:
        if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
          std::__shared_weak_count::__release_weak(v48);
        }
        goto LABEL_90;
      }
      xpc_object_t v49 = v40;
      if (v40) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v49 = xpc_null_create();
      }
      abm::BasebandTracingTask::commandReportStatsAWD((uint64_t)v47, &v49);
      xpc_release(v49);
      xpc_object_t v49 = 0;
      uint64_t v48 = (std::__shared_weak_count *)v51;
      if (v51) {
        goto LABEL_88;
      }
    }
  }
LABEL_90:
  xpc_release(v40);
  xpc_release(v30);
  if ((SHIBYTE(v52[3]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(object[2]) & 0x80000000) == 0) {
      goto LABEL_92;
    }
LABEL_95:
    operator delete(object[0]);
    if (((char)buf[23] & 0x80000000) == 0) {
      goto LABEL_93;
    }
LABEL_96:
    operator delete(*(void **)buf);
    goto LABEL_93;
  }
  operator delete((void *)v52[1]);
  if (SHIBYTE(object[2]) < 0) {
    goto LABEL_95;
  }
LABEL_92:
  if ((char)buf[23] < 0) {
    goto LABEL_96;
  }
LABEL_93:
  xpc_release(v7);
}

void sub_1A61219A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  xpc_release(v35);
  xpc_release(v34);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  xpc_release(v33);
  _Unwind_Resume(a1);
}

uint64_t CoredumpTrace::crashBasebandARI_sync(CoredumpTrace *this)
{
  char v14 = 0;
  CFTypeRef cf = (CFTypeRef)TelephonyBasebandCreateController();
  if (cf) {
    uint64_t v2 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2)
  {
    int v3 = *((void *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
LABEL_19:
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      goto LABEL_20;
    }
    LOWORD(__p) = 0;
    uint64_t v4 = "Failed to create TelephonyBasebandController";
LABEL_26:
    _os_log_error_impl(&dword_1A609F000, v3, OS_LOG_TYPE_ERROR, v4, (uint8_t *)&__p, 2u);
    goto LABEL_19;
  }
  if ((TelephonyBasebandGetReset() & 1) == 0)
  {
    xpc_object_t v5 = *((void *)this + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A609F000, v5, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", (uint8_t *)&__p, 2u);
    }
    char v14 = 0;
  }
  support::transport::AriRT::create((support::transport::AriRT *)"CoredumpTrace", (dispatch_queue_s *)0x2710, 0, (support::transport::ARI **)&__p);
  uint64_t v6 = __p;
  if (!__p)
  {
    int v3 = *((void *)this + 5);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    LOWORD(__p) = 0;
    uint64_t v4 = "Failed to open ARI interface (is baseband booted and ready?)";
    goto LABEL_26;
  }
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  Bsp::BspCommandDriver::BspCommandDriver();
  std::string __p = operator new(0x28uLL);
  long long v11 = xmmword_1A61F89E0;
  strcpy((char *)__p, "AP triggered baseband reset over ARI");
  uint64_t v7 = Bsp::BspCommandDriver::SwTrap();
  if (SHIBYTE(v11) < 0) {
    operator delete(__p);
  }
  if ((v7 & 1) == 0)
  {
    xpc_object_t v8 = *((void *)this + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to send SW Trap", (uint8_t *)&__p, 2u);
    }
  }
LABEL_20:
  if (cf) {
    CFRelease(cf);
  }
  if (v6) {
    (*(void (**)(void *))(*(void *)v6 + 8))(v6);
  }
  return v7;
}

void sub_1A6121E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(&a16);
  (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  _Unwind_Resume(a1);
}

void sub_1A6121E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1A6121E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get(uint64_t a1)
{
  return *(void *)a1;
}

const void **ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t CoredumpTrace::crashBaseband_sync(CoredumpTrace *a1, const std::string::value_type *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a1 + 5);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    xpc_object_t v19 = a2;
    if (a2[23] < 0) {
      xpc_object_t v19 = *(const std::string::value_type **)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    _os_log_debug_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEBUG, "#D Crashing baseband with reason: \"%s\"", buf, 0xCu);
  }
  if (capabilities::coredump::supportsSPMISignalling((capabilities::coredump *)v5))
  {
    char v22 = 0;
    Controller = (const void *)TelephonyBasebandCreateController();
    xpc_object_t v21 = Controller;
    if (Controller) {
      uint64_t v7 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      if (TelephonyBasebandGetReset())
      {
        xpc_object_t v8 = *((void *)a1 + 5);
      }
      else
      {
        xpc_object_t v8 = *((void *)a1 + 5);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", buf, 2u);
          xpc_object_t v8 = *((void *)a1 + 5);
        }
        char v22 = 0;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (SPMI)", buf, 2u);
      }
      char v27 = -86;
      *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v25 = v14;
      long long v26 = v14;
      *(_OWORD *)std::string buf = v14;
      long long v24 = v14;
      ResetReasonEncoder::encode(a2, (uint64_t)buf);
      if (v27)
      {
        uint64_t v15 = TelephonyBasebandCrashModemWithSPMIWithReason();
      }
      else
      {
        uint64_t v16 = *((void *)a1 + 5);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string::size_type v20 = 0;
          _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Failed to encode reset reason, so crashing baseband with SPMI without specifying reason", v20, 2u);
        }
        uint64_t v15 = TelephonyBasebandCrashModemWithSPMI();
      }
      uint64_t v10 = v15;
      if ((v15 & 1) != 0 || (uint64_t v17 = *((void *)a1 + 5), !os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)))
      {
        char v13 = 1;
        if (!Controller) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      *(_WORD *)std::string::size_type v20 = 0;
      _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, "Failed to crash baseband via SPMI", v20, 2u);
      char v13 = 1;
      if (!Controller)
      {
LABEL_32:
        if ((v13 & 1) == 0) {
          return 0;
        }
        return v10;
      }
    }
    else
    {
      unint64_t v12 = *((void *)a1 + 5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Failed to create TelephonyBasebandController", buf, 2u);
        uint64_t v10 = 0;
        char v13 = 0;
        if (!Controller) {
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v10 = 0;
        char v13 = 0;
        if (!Controller) {
          goto LABEL_32;
        }
      }
    }
LABEL_31:
    CFRelease(Controller);
    goto LABEL_32;
  }
  xpc_object_t v9 = *((void *)a1 + 5);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (ARI)", buf, 2u);
  }
  if ((CoredumpTrace::crashBasebandARI_sync(a1) & 1) == 0)
  {
    long long v11 = *((void *)a1 + 5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "Failed to crash (ARI)", buf, 2u);
    }
    return 0;
  }
  return 1;
}

void sub_1A6122278(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::handleBBULog(CoredumpTrace *this, int a2, const char *__s)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  memset(&__dst, 170, sizeof(__dst));
  size_t v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
  p_dst = &__dst;
  if (v6) {
LABEL_8:
  }
    memcpy(p_dst, __s, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  std::string::size_type v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  char v12 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  std::string::size_type v13 = __dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = &__dst;
  }
  else {
    uint64_t v15 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v16 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t v16 = __dst.__r_.__value_.__l.__size_;
  }
  uint64_t v17 = memchr(v15, 10, v16);
  if (v17) {
    unint64_t v18 = (unint64_t)v17;
  }
  else {
    unint64_t v18 = (unint64_t)v15 + v16;
  }
  xpc_object_t v19 = (std::string *)(v18 + 1);
  if (v18 - (void)v15 != v16 && v19 != (std::string *)((char *)v15 + v16))
  {
    xpc_object_t v21 = (char *)v15 + v16 + ~v18;
    do
    {
      int v22 = v19->__r_.__value_.__s.__data_[0];
      if (v22 != 10) {
        *(unsigned char *)v18++ = v22;
      }
      xpc_object_t v19 = (std::string *)((char *)v19 + 1);
      --v21;
    }
    while (v21);
    std::string::size_type v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    std::string::size_type v13 = __dst.__r_.__value_.__r.__words[0];
    char v12 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  if (v12 >= 0) {
    xpc_object_t v23 = (char *)&__dst + v11;
  }
  else {
    xpc_object_t v23 = (char *)(v13 + size);
  }
  if (v12 >= 0) {
    long long v24 = &__dst;
  }
  else {
    long long v24 = (std::string *)v13;
  }
  if (v12 >= 0) {
    std::string::size_type v25 = v11;
  }
  else {
    std::string::size_type v25 = size;
  }
  std::string::size_type v26 = v18 - (void)v24;
  if (v25 < v18 - (unint64_t)v24) {
    std::string::__throw_out_of_range[abi:ne180100]();
  }
  if (&v23[-v18] == (char *)-1)
  {
    if (v12 < 0)
    {
      __dst.__r_.__value_.__l.__size_ = v18 - (void)v24;
      *(unsigned char *)(v13 + v26) = 0;
      char v27 = *((void *)this + 5);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_45;
      }
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v26 & 0x7F;
      __dst.__r_.__value_.__s.__data_[v26] = 0;
      char v27 = *((void *)this + 5);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_45;
      }
    }
LABEL_39:
    uint64_t v28 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v28 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 67109378;
    int v31 = a2;
    __int16 v32 = 2080;
    xpc_object_t v33 = v28;
    _os_log_impl(&dword_1A609F000, v27, OS_LOG_TYPE_DEFAULT, "#I BBUpdater:  %04x:%s", buf, 0x12u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_42;
    }
    return;
  }
  std::string::__erase_external_with_move(&__dst, v26, (std::string::size_type)&v23[-v18]);
  char v27 = *((void *)this + 5);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_39;
  }
LABEL_45:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
LABEL_42:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_1A6122578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CoredumpTrace::collectBasebandCoreDump_sync(CoredumpTrace *this)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  CFTypeRef v45 = 0;
  CFTypeRef cf = 0;
  uint64_t v2 = (const void *)BBUpdaterExtremeCreate();
  if (!v2)
  {
    uint64_t v7 = 0;
    goto LABEL_80;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    xpc_object_t v8 = *((void *)this + 5);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_74:
      uint64_t v7 = 0;
      goto LABEL_78;
    }
    LOWORD(v43[0]) = 0;
    uint64_t v9 = "Failed to create options dictionary";
LABEL_90:
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, v9, (uint8_t *)v43, 2u);
    uint64_t v7 = 0;
    goto LABEL_78;
  }
  BYTE5(v43[2]) = -86;
  HIWORD(v43[2]) = 5290;
  strcpy((char *)v43, "boot::debugArguments");
  memset(__dst, 0, sizeof(__dst));
  uint64_t v42 = 0;
  CFTypeRef v39 = 0;
  xpc_object_t v40 = (const void *)0xAAAAAAAAAAAAAAAALL;
  pthread_mutex_lock(&ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance);
  if (!(void)xmmword_1EB5EE680)
  {
    size_t v6 = (uint64_t (***)(void *, const void *))operator new(0x18uLL);
    MEMORY[0x1A6274940](v6, @"com.apple.AppleBasebandManager", *MEMORY[0x1E4F1D3F0]);
    BOOL v5 = operator new(0x20uLL);
    *BOOL v5 = &unk_1EFB0B648;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v6;
    uint64_t v10 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE680 + 1);
    *(void *)&xmmword_1EB5EE680 = v6;
    *((void *)&xmmword_1EB5EE680 + 1) = v5;
    if (!v10)
    {
      *(void *)std::string buf = v6;
      *(void *)&uint8_t buf[8] = v5;
      goto LABEL_13;
    }
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  BOOL v5 = (void *)*((void *)&xmmword_1EB5EE680 + 1);
  size_t v6 = (uint64_t (***)(void *, const void *))xmmword_1EB5EE680;
  *(_OWORD *)std::string buf = xmmword_1EB5EE680;
  if (*((void *)&xmmword_1EB5EE680 + 1)) {
LABEL_13:
  }
    atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  pthread_mutex_unlock(&ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance);
  *(void *)std::string __p = 0xAAAAAAAAAAAAAA00;
  *(_OWORD *)&__p[8] = xmmword_1A61F89F0;
  if (SHIBYTE(v43[2]) >= 0) {
    std::string::size_type v11 = (const char *)v43;
  }
  else {
    std::string::size_type v11 = (const char *)v43[0];
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v46, v11);
  char v12 = (const void *)(**v6)(v6, v46);
  if (v12)
  {
    char v13 = ctu::cf::assign();
    CFRelease(v12);
    MEMORY[0x1A62748E0](&v46);
    if (v13) {
      goto LABEL_31;
    }
    size_t v14 = __p[23];
    if ((SHIBYTE(v42) & 0x80000000) == 0) {
      goto LABEL_20;
    }
  }
  else
  {
    MEMORY[0x1A62748E0](&v46);
    size_t v14 = __p[23];
    if ((SHIBYTE(v42) & 0x80000000) == 0)
    {
LABEL_20:
      if ((v14 & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(__dst, *(void **)__p, *(size_t *)&__p[8]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)__p;
        uint64_t v42 = *(void *)&__p[16];
      }
      goto LABEL_31;
    }
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v15 = __p;
  }
  else {
    uint64_t v15 = *(unsigned char **)__p;
  }
  if ((v14 & 0x80u) == 0) {
    size_t v16 = v14;
  }
  else {
    size_t v16 = *(void *)&__p[8];
  }
  std::string::__assign_no_alias<false>((void **)__dst, v15, v16);
LABEL_31:
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v17 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = HIBYTE(v42);
  if (v42 < 0) {
    uint64_t v18 = *(void *)&__dst[8];
  }
  if (v18 && ctu::cf::convert_copy())
  {
    xpc_object_t v19 = *((void *)this + 5);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v20 = __dst;
      if (v42 < 0) {
        std::string::size_type v20 = *(uint8_t **)__dst;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl(&dword_1A609F000, v19, OS_LOG_TYPE_DEFAULT, "#N Retrieved debug args: %s", buf, 0xCu);
    }
    CFMutableDictionaryRef v21 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v21)
    {
      CFTypeRef v22 = cf;
      CFTypeRef cf = v21;
      if (v22) {
        CFRelease(v22);
      }
      CFDictionarySetValue(Mutable, @"Options", v21);
      CFTypeRef v23 = v39;
      long long v24 = v40;
      CFTypeRef v39 = v40;
      if (v23) {
        CFRelease(v23);
      }
      *(void *)std::string buf = @"DebugArgs";
      CFRetain(@"DebugArgs");
      BOOL v46 = v24;
      if (v24)
      {
        CFRetain(v24);
        CFDictionarySetValue(v21, @"DebugArgs", v24);
        CFRelease(v24);
      }
      CFRelease(@"DebugArgs");
    }
  }
  std::string::size_type v25 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDictionarySetValue(Mutable, @"DisallowFusing", (const void *)*MEMORY[0x1E4F1CFD0]);
  int valuePtr = 2;
  CFNumberRef v26 = CFNumberCreate(v3, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, @"BootMode", v26);
  CFRelease(v26);
  BOOL v46 = 0;
  capabilities::radio::personalizedFirmwarePath((uint64_t *)buf, v27);
  int v28 = ctu::cf::convert_copy();
  int v29 = v28;
  if ((char)buf[23] < 0)
  {
    operator delete(*(void **)buf);
    if (!v29) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  if (v28)
  {
LABEL_56:
    CFDictionarySetValue(Mutable, @"firmwareDataFolder", v46);
    CFRelease(v46);
  }
LABEL_57:
  CFDictionaryAddValue(Mutable, @"coreDumpPathNoTimestamp", v25);
  xpc_object_t v30 = (void *)((char *)this + 176);
  uint64_t v7 = ctu::cf::convert_copy();
  if (v7)
  {
    CFDictionarySetValue(Mutable, @"coreDumpPath", 0);
    CFRelease(0);
    goto LABEL_60;
  }
  int v31 = *((void *)this + 5);
  if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
LABEL_60:
    CFTypeRef v32 = v39;
    if (!v39) {
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  if (*((char *)this + 199) < 0) {
    xpc_object_t v30 = (void *)*v30;
  }
  *(_DWORD *)std::string buf = 136315138;
  *(void *)&uint8_t buf[4] = v30;
  _os_log_error_impl(&dword_1A609F000, v31, OS_LOG_TYPE_ERROR, "Failed to convert CoreDump path (%s)", buf, 0xCu);
  CFTypeRef v32 = v39;
  if (v39) {
LABEL_61:
  }
    CFRelease(v32);
LABEL_62:
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v43[2]) & 0x80000000) == 0) {
      goto LABEL_64;
    }
LABEL_67:
    operator delete(v43[0]);
    if (!v7) {
      goto LABEL_78;
    }
    goto LABEL_68;
  }
  operator delete(*(void **)__dst);
  if (SHIBYTE(v43[2]) < 0) {
    goto LABEL_67;
  }
LABEL_64:
  if (!v7) {
    goto LABEL_78;
  }
LABEL_68:
  if (!BBUpdaterSetOptions())
  {
    xpc_object_t v8 = *((void *)this + 5);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_74;
    }
    LOWORD(v43[0]) = 0;
    uint64_t v9 = "Failed to set CoreDump options";
    goto LABEL_90;
  }
  v43[0] = 0;
  int v33 = BBUpdaterExecCommand();
  uint64_t v7 = v33 != 0;
  uint64_t v34 = *((void *)this + 5);
  if (v33)
  {
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __dst = 0;
      _os_log_impl(&dword_1A609F000, v34, OS_LOG_TYPE_DEFAULT, "#I CoreDump success", __dst, 2u);
      xpc_object_t v35 = v43[0];
      if (!v43[0]) {
        goto LABEL_78;
      }
LABEL_77:
      CFRelease(v35);
      goto LABEL_78;
    }
LABEL_76:
    xpc_object_t v35 = v43[0];
    if (!v43[0]) {
      goto LABEL_78;
    }
    goto LABEL_77;
  }
  if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
    goto LABEL_76;
  }
  *(_WORD *)std::string __dst = 0;
  _os_log_error_impl(&dword_1A609F000, v34, OS_LOG_TYPE_ERROR, "Failed to execute CoreDump command", __dst, 2u);
  xpc_object_t v35 = v43[0];
  if (v43[0]) {
    goto LABEL_77;
  }
LABEL_78:
  CFRelease(v2);
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_80:
  if (v45) {
    CFRelease(v45);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v7;
}

void sub_1A6122D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void CoredumpTrace::snapshot_sync(CoredumpTrace *this, uint64_t a2, const __CFDictionary **a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*((char *)this + 199) < 0)
  {
    **((unsigned char **)this + 22) = 0;
    *((void *)this + 23) = 0;
    if (CoredumpTrace::createScratchPath_sync(this))
    {
LABEL_3:
      v16[0] = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v16, *a3);
      memset(&buf, 170, sizeof(buf));
      char v19 = 0;
      v18[0] = 0;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v17, "kKeyTraceDumpStateReason");
      ctu::cf::map_adapter::getString();
      MEMORY[0x1A62748E0](&v17);
      if (v19 < 0)
      {
        operator delete(*(void **)v18);
        if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
      }
      else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_5:
        std::string v14 = buf;
        goto LABEL_11;
      }
      std::string::__init_copy_ctor_external(&v14, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
LABEL_11:
      char v6 = (*(uint64_t (**)(CoredumpTrace *, std::string *))(*(void *)this + 176))(this, &v14);
      char v7 = v6;
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v14.__r_.__value_.__l.__data_);
        if (v7) {
          goto LABEL_17;
        }
      }
      else if (v6)
      {
LABEL_17:
        uint64_t v9 = (capabilities::trace *)(*(uint64_t (**)(CoredumpTrace *))(*(void *)this + 184))(this);
        if (v9 && *((unsigned char *)this + 232))
        {
          *((unsigned char *)this + 232) = 0;
          CoredumpTrace::cleanCrashReport_sync(this);
          *(void *)uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(unsigned char *__return_ptr, CoredumpTrace *))(*(void *)this + 192))(v18, this);
          CoredumpTrace::storeCrashReason_sync((NSObject **)this, (const xpc::dict *)v18);
          CoredumpTrace::submitCrashReason_sync(this, (xpc_object_t *)v18);
          CoredumpTrace::updateAnalyticsEvent_sync(this, (xpc_object_t *)v18);
          xpc_release(*(xpc_object_t *)v18);
        }
        if (*((unsigned char *)this + 168)
          || !capabilities::trace::supportsCoredumpCrashReasonOnCustomerBuild(v9))
        {
          CFDictionaryRef v12 = *a3;
          CFDictionaryRef v13 = v12;
          if (v12) {
            CFRetain(v12);
          }
          CoredumpTrace::moveToSnapshotPath_sync((uint64_t)this, &v13);
          if (v12) {
            CFRelease(v12);
          }
        }
        else
        {
          uint64_t v10 = (void *)((char *)this + 176);
          if (!support::fs::removeDirContents((const char *)this + 176, 0)
            || (support::fs::removeDir((const char *)this + 176) & 1) == 0)
          {
            std::string::size_type v11 = *((void *)this + 5);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              if (*((char *)this + 199) < 0) {
                uint64_t v10 = (void *)*v10;
              }
              *(_DWORD *)uint64_t v18 = 136315138;
              *(void *)&v18[4] = v10;
              _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "Failed to clean up scratch path %s", v18, 0xCu);
            }
          }
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        MEMORY[0x1A6274930](v16);
        return;
      }
      xpc_object_t v8 = *((void *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to crash baseband, continuing with coredump anyway (coredump may be invalid)", v18, 2u);
      }
      goto LABEL_17;
    }
  }
  else
  {
    *((unsigned char *)this + 176) = 0;
    *((unsigned char *)this + 199) = 0;
    if (CoredumpTrace::createScratchPath_sync(this)) {
      goto LABEL_3;
    }
  }
  BOOL v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v5, OS_LOG_TYPE_ERROR, "Failed to create scratch path", (uint8_t *)&buf, 2u);
  }
}

void sub_1A61231D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1A6274930](&a24);
  _Unwind_Resume(a1);
}

void CoredumpTrace::cleanCrashReport_sync(CoredumpTrace *this)
{
  std::string __p = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v2 = (char *)this + 200;
  support::fs::loadFile((uint64_t)this + 200, (uint64_t)&__p);
  memset(__dst, 170, sizeof(__dst));
  CFAllocatorRef v3 = __p;
  size_t v4 = v15 - (unsigned char *)__p;
  if ((unint64_t)(v15 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v6 = v4 | 7;
    }
    uint64_t v7 = v6 + 1;
    BOOL v5 = (void **)operator new(v6 + 1);
    __dst[1] = (void *)v4;
    _OWORD __dst[2] = (void *)(v7 | 0x8000000000000000);
    __dst[0] = v5;
    goto LABEL_8;
  }
  HIBYTE(__dst[2]) = (_BYTE)v15 - (_BYTE)__p;
  BOOL v5 = __dst;
  if (v15 != __p) {
LABEL_8:
  }
    memmove(v5, v3, v4);
  *((unsigned char *)v5 + v4) = 0;
  util::convert_garbage((uint64_t)__dst);
  if (*((char *)this + 223) >= 0) {
    xpc_object_t v8 = v2;
  }
  else {
    xpc_object_t v8 = (const char *)*((void *)this + 25);
  }
  int v9 = open(v8, 1537, 420);
  if ((v9 & 0x80000000) == 0)
  {
    if (SHIBYTE(__dst[2]) >= 0) {
      uint64_t v10 = __dst;
    }
    else {
      uint64_t v10 = (void **)__dst[0];
    }
    if (SHIBYTE(__dst[2]) >= 0) {
      size_t v11 = HIBYTE(__dst[2]);
    }
    else {
      size_t v11 = (size_t)__dst[1];
    }
    do
    {
      if (!v11) {
        break;
      }
      ssize_t v12 = write(v9, v10, v11);
      v11 -= v12;
      uint64_t v10 = (void **)((char *)v10 + v12);
    }
    while ((v12 & 0x8000000000000000) == 0);
    while (close(v9) && *__error() == 4)
      ;
  }
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  if (__p)
  {
    uint64_t v15 = __p;
    operator delete(__p);
  }
}

void sub_1A6123410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  if (a16 < 0)
  {
    operator delete(__p);
    char v19 = a17;
    if (!a17) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    char v19 = a17;
    if (!a17) {
      goto LABEL_3;
    }
  }
  operator delete(v19);
  _Unwind_Resume(exception_object);
}

BOOL CoredumpTrace::moveToSnapshotPath_sync(uint64_t a1, const __CFDictionary **a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  memset(&v69, 0, sizeof(v69));
  v68[0] = 0xAAAAAAAAAAAAAAAALL;
  v68[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v68, *a2);
  memset(v67, 170, sizeof(v67));
  strcpy((char *)&__p, "kTraceFilterActionNone");
  HIBYTE(__p.st_gid) = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v66, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](v66);
  if (SHIBYTE(__p.st_gid) < 0) {
    operator delete(*(void **)&__p.st_dev);
  }
  memset(v66, 170, sizeof(v66));
  CFAllocatorRef v3 = (const void *)*MEMORY[0x1E4F4C3A0];
  size_t v4 = strlen((const char *)*MEMORY[0x1E4F4C3A0]);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __darwin_ino64_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_p = (stat *)operator new(v7 + 1);
    __p.st_ino = v5;
    *(void *)&__p.st_uid = v8 | 0x8000000000000000;
    *(void *)&__p.st_dev = p_p;
    goto LABEL_10;
  }
  HIBYTE(__p.st_gid) = v4;
  p_p = &__p;
  if (v4) {
LABEL_10:
  }
    memmove(p_p, v3, v5);
  int v9 = (const char *)*MEMORY[0x1E4F4C4C8];
  *((unsigned char *)&p_p->st_dev + v5) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v70, v9);
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v70);
  if (SHIBYTE(__p.st_gid) < 0) {
    operator delete(*(void **)&__p.st_dev);
  }
  uint64_t v10 = (void *)HIBYTE(v67[2]);
  if (SHIBYTE(v67[2]) < 0) {
    uint64_t v10 = v67[1];
  }
  if (v10 != (void *)22) {
    goto LABEL_25;
  }
  size_t v11 = v67;
  if (SHIBYTE(v67[2]) < 0) {
    size_t v11 = (void **)v67[0];
  }
  ssize_t v12 = *v11;
  CFDictionaryRef v13 = v11[1];
  uint64_t v14 = *(uint64_t *)((char *)v11 + 14);
  BOOL v15 = v12 == *(void **)"kTraceFilterActionNone" && v13 == *(void **)"lterActionNone";
  if (!v15 || v14 != *(void *)"tionNone")
  {
LABEL_25:
    std::string::__assign_external(&v69, abm::trace::kTrashFolder[0]);
    char v17 = 0;
    goto LABEL_26;
  }
  unint64_t v51 = abm::trace::kSnapshotFolder[0];
  size_t v52 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v52 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v53 = v52;
  if (v52 >= 0x17)
  {
    uint64_t v55 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v52 | 7) != 0x17) {
      uint64_t v55 = v52 | 7;
    }
    uint64_t v56 = v55 + 1;
    unint64_t v54 = operator new(v55 + 1);
    v70.__r_.__value_.__l.__size_ = v53;
    v70.__r_.__value_.__r.__words[2] = v56 | 0x8000000000000000;
    v70.__r_.__value_.__r.__words[0] = (std::string::size_type)v54;
  }
  else
  {
    *((unsigned char *)&v70.__r_.__value_.__s + 23) = v52;
    unint64_t v54 = &v70;
    if (!v52) {
      goto LABEL_84;
    }
  }
  memmove(v54, v51, v53);
LABEL_84:
  *((unsigned char *)v54 + v53) = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&__dst, "kKeyTraceDumpStatePath");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&__dst);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v69.__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&v69.__r_.__value_.__l.__data_ = *(_OWORD *)&__p.st_dev;
  v69.__r_.__value_.__r.__words[2] = *(void *)&__p.st_uid;
  HIBYTE(__p.st_gid) = 0;
  LOBYTE(__p.st_dev) = 0;
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  char v17 = 1;
LABEL_26:
  char v19 = (void *)(a1 + 176);
  uint64_t v18 = *(const char **)(a1 + 176);
  v20.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v20.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&__p.st_blksize_t size = v20;
  *(timespec *)__p.st_qspare = v20;
  __p.st_birthtimespec = v20;
  *(timespec *)&__p.st_size_t size = v20;
  __p.st_mtimespec = v20;
  __p.st_ctimespec = v20;
  *(timespec *)&__p.st_uid = v20;
  __p.st_atimespec = v20;
  *(timespec *)&__p.st_dev = v20;
  if (*(char *)(a1 + 199) >= 0) {
    CFMutableDictionaryRef v21 = (const char *)(a1 + 176);
  }
  else {
    CFMutableDictionaryRef v21 = v18;
  }
  if (!stat(v21, &__p))
  {
    std::string::size_type v25 = *(char *)(a1 + 199) >= 0 ? (const char *)(a1 + 176) : *(const char **)(a1 + 176);
    CFNumberRef v26 = opendir(v25);
    char v27 = v26;
    if (v26)
    {
      int v28 = readdir(v26);
      closedir(v27);
      if (v28)
      {
        char v62 = v17;
        memset(&__p, 170, 24);
        int v29 = abm::trace::kLogDirPrefix[0];
        int v30 = SHIBYTE(v69.__r_.__value_.__r.__words[2]);
        if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t size = v69.__r_.__value_.__l.__size_;
        }
        size_t v32 = strlen(abm::trace::kLogDirPrefix[0]);
        std::string::size_type v33 = size + v32;
        memset(&__dst, 170, sizeof(__dst));
        if (size + v32 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        size_t v34 = v32;
        if (v33 > 0x16)
        {
          uint64_t v57 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v33 | 7) != 0x17) {
            uint64_t v57 = v33 | 7;
          }
          uint64_t v58 = v57 + 1;
          p_dst = (std::string *)operator new(v57 + 1);
          __dst.__r_.__value_.__l.__size_ = v33;
          __dst.__r_.__value_.__r.__words[2] = v58 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          if (!size)
          {
LABEL_51:
            xpc_object_t v37 = (char *)p_dst + size;
            if (v34) {
              memmove(v37, v29, v34);
            }
            v37[v34] = 0;
            if (SHIBYTE(v66[2]) >= 0) {
              xpc_object_t v38 = v66;
            }
            else {
              xpc_object_t v38 = (void **)v66[0];
            }
            if (SHIBYTE(v66[2]) >= 0) {
              std::string::size_type v39 = HIBYTE(v66[2]);
            }
            else {
              std::string::size_type v39 = (std::string::size_type)v66[1];
            }
            xpc_object_t v40 = std::string::append(&__dst, (const std::string::value_type *)v38, v39);
            long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            v70.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            size_t v42 = strlen(abm::trace::kCoreDumpSnapshotDirectorySuffix[0]);
            xpc_object_t v43 = std::string::append(&v70, abm::trace::kCoreDumpSnapshotDirectorySuffix[0], v42);
            long long v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
            std::string::size_type v65 = v43->__r_.__value_.__r.__words[2];
            *(_OWORD *)size_t v64 = v44;
            v43->__r_.__value_.__l.__size_ = 0;
            v43->__r_.__value_.__r.__words[2] = 0;
            v43->__r_.__value_.__r.__words[0] = 0;
            support::fs::createUniquePath((const char *)v64, (std::string *)&__p);
            if (SHIBYTE(v65) < 0)
            {
              operator delete(v64[0]);
              if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_61:
                if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_62:
                  support::fs::createDir((const char *)&__p, 0x1EDu, 1);
                  if (*(char *)(a1 + 199) >= 0) {
                    BOOL v46 = (const std::__fs::filesystem::path *)(a1 + 176);
                  }
                  else {
                    BOOL v46 = *(const std::__fs::filesystem::path **)(a1 + 176);
                  }
                  if ((__p.st_gid & 0x80000000) == 0) {
                    uint64_t v47 = (const std::__fs::filesystem::path *)&__p;
                  }
                  else {
                    uint64_t v47 = *(const std::__fs::filesystem::path **)&__p.st_dev;
                  }
                  rename(v46, v47, v45);
                  BOOL v23 = v48 == 0;
                  xpc_object_t v49 = *(NSObject **)(a1 + 40);
                  if (v48)
                  {
                    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v50 = &__p;
                      if ((__p.st_gid & 0x80000000) != 0) {
                        uint64_t v50 = *(stat **)&__p.st_dev;
                      }
                      LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
                      _os_log_error_impl(&dword_1A609F000, v49, OS_LOG_TYPE_ERROR, "Failed creating coredump snapshot path. snapshotUniquePath=[%s]", (uint8_t *)&v70, 0xCu);
                    }
                  }
                  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
                  {
                    size_t v59 = &__p;
                    if ((__p.st_gid & 0x80000000) != 0) {
                      size_t v59 = *(stat **)&__p.st_dev;
                    }
                    LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
                    _os_log_impl(&dword_1A609F000, v49, OS_LOG_TYPE_DEFAULT, "#I Coredump files are placed in path [%s]", (uint8_t *)&v70, 0xCu);
                  }
                  if ((v62 & 1) == 0)
                  {
                    uint64_t v60 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string v61 = v67;
                      if (SHIBYTE(v67[2]) < 0) {
                        std::string v61 = (void **)v67[0];
                      }
                      LODWORD(v70.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v70.__r_.__value_.__r.__words + 4) = (std::string::size_type)v61;
                      _os_log_impl(&dword_1A609F000, v60, OS_LOG_TYPE_DEFAULT, "#I Trashing coredump logs. Trace filter is '%s'", (uint8_t *)&v70, 0xCu);
                    }
                    support::fs::removeDir((const char *)&__p);
                  }
                  if (SHIBYTE(__p.st_gid) < 0) {
                    operator delete(*(void **)&__p.st_dev);
                  }
                  goto LABEL_32;
                }
LABEL_95:
                operator delete(__dst.__r_.__value_.__l.__data_);
                goto LABEL_62;
              }
            }
            else if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_61;
            }
            operator delete(v70.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_62;
            }
            goto LABEL_95;
          }
        }
        else
        {
          memset(&__dst, 0, sizeof(__dst));
          p_dst = &__dst;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = size + v32;
          if (!size) {
            goto LABEL_51;
          }
        }
        if (v30 >= 0) {
          xpc_object_t v36 = &v69;
        }
        else {
          xpc_object_t v36 = (std::string *)v69.__r_.__value_.__r.__words[0];
        }
        memmove(p_dst, v36, size);
        goto LABEL_51;
      }
    }
  }
  CFTypeRef v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a1 + 199) < 0) {
      char v19 = (void *)*v19;
    }
    __p.st_dev = 136315138;
    *(void *)&__p.st_mode = v19;
    _os_log_error_impl(&dword_1A609F000, v22, OS_LOG_TYPE_ERROR, "Failed: Couldn't find Scratch path [%s] to move to Snapshot path", (uint8_t *)&__p, 0xCu);
  }
  BOOL v23 = 0;
LABEL_32:
  if ((SHIBYTE(v66[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v67[2]) & 0x80000000) == 0) {
      goto LABEL_34;
    }
LABEL_74:
    operator delete(v67[0]);
    MEMORY[0x1A6274930](v68);
    if ((SHIBYTE(v69.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v23;
    }
LABEL_75:
    operator delete(v69.__r_.__value_.__l.__data_);
    return v23;
  }
  operator delete(v66[0]);
  if (SHIBYTE(v67[2]) < 0) {
    goto LABEL_74;
  }
LABEL_34:
  MEMORY[0x1A6274930](v68);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_75;
  }
  return v23;
}

void sub_1A6123C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,_Unwind_Exception *exception_object,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if (a49 < 0)
    {
LABEL_5:
      operator delete(a44);
      if ((a15 & 0x80000000) == 0)
      {
LABEL_9:
        if (a28 < 0) {
          operator delete(a23);
        }
        if (a34 < 0) {
          operator delete(a29);
        }
        MEMORY[0x1A6274930](&a35);
        if (a42 < 0) {
          operator delete(a37);
        }
        _Unwind_Resume(a1);
      }
LABEL_8:
      operator delete(a10);
      goto LABEL_9;
    }
  }
  else if (a49 < 0)
  {
    goto LABEL_5;
  }
  if ((a15 & 0x80000000) == 0) {
    goto LABEL_9;
  }
  goto LABEL_8;
}

void CoredumpTrace::loadRawCrashReport_sync(uint64_t a1, xpc_object_t *a2, uint64_t a3)
{
  uint64_t v18 = 0;
  char v19 = 0;
  uint64_t v20 = 0;
  if (support::fs::loadFile(a1 + 200, (uint64_t)&v18))
  {
    __darwin_ino64_t v5 = v18;
    size_t v6 = v19 - (unsigned char *)v18;
    if ((unint64_t)(v19 - (unsigned char *)v18) >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v6 >= 0x17)
    {
      uint64_t v11 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17) {
        uint64_t v11 = v6 | 7;
      }
      uint64_t v12 = v11 + 1;
      uint64_t v7 = operator new(v11 + 1);
      __p[1] = (void *)v6;
      int64_t v17 = v12 | 0x8000000000000000;
      __p[0] = v7;
    }
    else
    {
      HIBYTE(v17) = (_BYTE)v19 - (_BYTE)v18;
      uint64_t v7 = __p;
      if (v19 == v18) {
        goto LABEL_16;
      }
    }
    memmove(v7, v5, v6);
LABEL_16:
    *((unsigned char *)v7 + v6) = 0;
    if (v17 >= 0) {
      CFDictionaryRef v13 = __p;
    }
    else {
      CFDictionaryRef v13 = (void **)__p[0];
    }
    xpc_object_t v14 = xpc_string_create((const char *)v13);
    if (!v14) {
      xpc_object_t v14 = xpc_null_create();
    }
    xpc_dictionary_set_value(*a2, "fullreport", v14);
    xpc_object_t v15 = xpc_null_create();
    xpc_release(v14);
    xpc_release(v15);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_23;
  }
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v8 = (const char *)a3;
  }
  else {
    uint64_t v8 = *(const char **)a3;
  }
  xpc_object_t v9 = xpc_string_create(v8);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  xpc_dictionary_set_value(*a2, "ioerror", v9);
  xpc_object_t v10 = xpc_null_create();
  xpc_release(v9);
  xpc_release(v10);
LABEL_23:
  if (v18)
  {
    char v19 = v18;
    operator delete(v18);
  }
}

void sub_1A6123F1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CoredumpTrace::parseCrashReason_sync(CoredumpTrace *this@<X0>, xpc_object_t *a2@<X8>)
{
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  xpc_object_t object = xpc_null_create();
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v4 = xpc_null_create();
  *a2 = v4;
  memset(&__p, 0, sizeof(__p));
  v134 = 0;
  __darwin_ino64_t v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    size_t v6 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      size_t v6 = (void *)*v6;
    }
    buf.st_dev = 136315138;
    *(void *)&buf.st_mode = v6;
    _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Looking for crash report file: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v8 = (void *)((char *)this + 200);
  uint64_t v7 = (const char *)*((void *)this + 25);
  v9.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v9.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blkstd::string::size_type size = v9;
  *(timespec *)buf.st_qspare = v9;
  buf.st_birthtimespec = v9;
  *(timespec *)&buf.st_std::string::size_type size = v9;
  buf.st_mtimespec = v9;
  buf.st_ctimespec = v9;
  *(timespec *)&buf.st_uid = v9;
  buf.st_atimespec = v9;
  *(timespec *)&buf.st_dev = v9;
  if (*((char *)this + 223) >= 0) {
    xpc_object_t v10 = (char *)this + 200;
  }
  else {
    xpc_object_t v10 = v7;
  }
  if (!stat(v10, &buf))
  {
    if (*((char *)this + 223) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    xpc_object_t v14 = objc_msgSend(MEMORY[0x1E4F1CA10], "inputStreamWithFileAtPath:", objc_msgSend(NSString, "stringWithUTF8String:", v8));
    xpc_object_t v15 = v14;
    if (v14)
    {
      [v14 open];
      uint64_t v16 = (ctu *)[MEMORY[0x1E4F28D90] JSONObjectWithStream:v15 options:0 error:&v134];
      if (v16)
      {
        ctu::cf_to_xpc((uint64_t *)&buf.st_dev, v16, v17);
        xpc_object_t v18 = *(xpc_object_t *)&buf.st_dev;
        if (*(void *)&buf.st_dev && MEMORY[0x1A6275E60](*(void *)&buf.st_dev) == MEMORY[0x1E4F14590]) {
          xpc_retain(v18);
        }
        else {
          xpc_object_t v18 = xpc_null_create();
        }
        xpc_object_t v33 = xpc_null_create();
        xpc_object_t v34 = object;
        xpc_object_t object = v18;
        xpc_release(v34);
        xpc_release(v33);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        uint64_t v35 = MEMORY[0x1A6275E60](object);
        uint64_t v36 = MEMORY[0x1E4F14590];
        if (v35 != MEMORY[0x1E4F14590]) {
          goto LABEL_44;
        }
        size_t v42 = *((void *)this + 5);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          xpc::object::to_string((uint64_t *)&buf.st_dev, (xpc::object *)&object);
          char v90 = (buf.st_gid & 0x80000000) == 0 ? &buf : *(stat **)&buf.st_dev;
          LODWORD(v147.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v147.__r_.__value_.__r.__words + 4) = (std::string::size_type)v90;
          _os_log_debug_impl(&dword_1A609F000, v42, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v147, 0xCu);
          if (SHIBYTE(buf.st_gid) < 0) {
            operator delete(*(void **)&buf.st_dev);
          }
        }
        xpc_object_t xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        *(void *)&buf.st_dev = &object;
        buf.st_ino = (__darwin_ino64_t)"title";
        xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &xdict);
        uint64_t v43 = MEMORY[0x1A6275E60](xdict);
        if (v43 == v36)
        {
          xpc_object_t value = xpc_dictionary_get_value(xdict, "name");
          xpc_object_t v132 = value;
          if (value) {
            xpc_retain(value);
          }
          else {
            xpc_object_t v132 = xpc_null_create();
          }
          memset(&buf, 0, 24);
          xpc::dyn_cast_or_default();
          if (SHIBYTE(buf.st_gid) < 0) {
            operator delete(*(void **)&buf.st_dev);
          }
        }
        else
        {
          *((unsigned char *)&v147.__r_.__value_.__s + 23) = 7;
          strcpy((char *)&v147, "unknown");
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        std::string __p = v147;
        *((unsigned char *)&v147.__r_.__value_.__s + 23) = 0;
        v147.__r_.__value_.__s.__data_[0] = 0;
        if (v43 == v36) {
          xpc_release(v132);
        }
        xpc_object_t v49 = *((void *)this + 5);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          buf.st_dev = 136315138;
          *(void *)&buf.st_mode = p_p;
          _os_log_impl(&dword_1A609F000, v49, OS_LOG_TYPE_DEFAULT, "#I Found crash '%s'", (uint8_t *)&buf, 0xCu);
        }
        xpc_object_t v131 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        xpc_object_t v51 = xpc_dictionary_get_value(object, "crash_details");
        xpc_object_t v52 = v51;
        uint64_t v53 = MEMORY[0x1E4F14568];
        if (v51)
        {
          xpc_retain(v51);
          xpc_object_t v131 = v52;
        }
        else
        {
          xpc_object_t v52 = xpc_null_create();
          xpc_object_t v131 = v52;
          if (!v52)
          {
            xpc_object_t v54 = xpc_null_create();
            xpc_object_t v52 = 0;
            goto LABEL_86;
          }
        }
        if (MEMORY[0x1A6275E60](v52) == v53)
        {
          xpc_retain(v52);
          goto LABEL_87;
        }
        xpc_object_t v54 = xpc_null_create();
LABEL_86:
        xpc_object_t v131 = v54;
LABEL_87:
        xpc_release(v52);
        if (MEMORY[0x1A6275E60](v131) == v53)
        {
          xpc_object_t __dst = &v131;
          unint64_t v129 = 0;
          xpc::array::object_proxy::operator xpc::dict((uint64_t)&__dst, &buf);
        }
        else
        {
          *(void *)&buf.st_dev = v4;
          if (v4) {
            xpc_retain(v4);
          }
          else {
            *(void *)&buf.st_dev = xpc_null_create();
          }
        }
        xpc_object_t v55 = *(xpc_object_t *)&buf.st_dev;
        *(void *)&buf.st_dev = xpc_null_create();
        *a2 = v55;
        xpc_release(v4);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        uint64_t v56 = MEMORY[0x1A6275E60](v55);
        if (v56 != v36)
        {
          uint64_t v57 = *((void *)this + 5);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.st_dev) = 0;
            _os_log_impl(&dword_1A609F000, v57, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to unrecognized or missing system_details", (uint8_t *)&buf, 2u);
          }
          xpc_object_t v58 = xpc_dictionary_create(0, 0, 0);
          if (v58 || (xpc_object_t v58 = xpc_null_create()) != 0)
          {
            if (MEMORY[0x1A6275E60](v58) == v36)
            {
              xpc_retain(v58);
              xpc_object_t v4 = v58;
            }
            else
            {
              xpc_object_t v4 = xpc_null_create();
            }
          }
          else
          {
            xpc_object_t v4 = xpc_null_create();
            xpc_object_t v58 = 0;
          }
          xpc_release(v58);
          xpc_object_t v64 = xpc_null_create();
          xpc_object_t v65 = *a2;
          *a2 = v4;
          xpc_release(v65);
          xpc_release(v64);
          v147.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x40uLL);
          *(_OWORD *)&v147.__r_.__value_.__r.__words[1] = xmmword_1A61F8A00;
          strcpy(v147.__r_.__value_.__l.__data_, "Coredump invalid, unrecognized or missing crash details: ");
          v66 = std::string::append(&v147, "report.json", 0xBuLL);
          long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          *(void *)&buf.st_uid = *((void *)&v66->__r_.__value_.__l + 2);
          *(_OWORD *)&buf.st_dev = v67;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
          if (SHIBYTE(buf.st_gid) < 0) {
            operator delete(*(void **)&buf.st_dev);
          }
          if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v147.__r_.__value_.__l.__data_);
          }
          [v15 close];
          goto LABEL_245;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v59 = &__p;
        }
        else {
          size_t v59 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v60 = xpc_string_create((const char *)v59);
        if (!v60) {
          xpc_object_t v60 = xpc_null_create();
        }
        xpc_dictionary_set_value(v55, "name", v60);
        xpc_object_t v61 = xpc_null_create();
        xpc_release(v60);
        xpc_release(v61);
        unint64_t v146 = 0xAAAAAAAAAAAAAAAALL;
        v62.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v62.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        timespec v144 = v62;
        timespec v145 = v62;
        timespec v142 = v62;
        timespec v143 = v62;
        timespec v140 = v62;
        timespec v141 = v62;
        timespec v138 = v62;
        timespec v139 = v62;
        *(timespec *)&buf.st_blkstd::string::size_type size = v62;
        *(timespec *)buf.st_qspare = v62;
        buf.st_birthtimespec = v62;
        *(timespec *)&buf.st_std::string::size_type size = v62;
        buf.st_mtimespec = v62;
        buf.st_ctimespec = v62;
        *(timespec *)&buf.st_uid = v62;
        buf.st_atimespec = v62;
        *(timespec *)&buf.st_dev = v62;
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&buf);
        if (!xpc_dictionary_get_value(v55, "log_data"))
        {
LABEL_148:
          if (!xpc_dictionary_get_value(v55, "ucs_crash_id")) {
            goto LABEL_217;
          }
          xpc_object_t v84 = xpc_dictionary_get_value(v55, "ucs_crash_id");
          xpc_object_t __dst = v84;
          if (v84) {
            xpc_retain(v84);
          }
          else {
            xpc_object_t __dst = xpc_null_create();
          }
          xpc::dyn_cast_or_default();
          if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v147.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v147.__r_.__value_.__l.__size_;
          }
          if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v147.__r_.__value_.__l.__data_);
          }
          xpc_release(__dst);
          if (!size) {
            goto LABEL_217;
          }
          if ((buf.st_gen & 0x10) != 0)
          {
            uint64_t tv_nsec = *(void *)&buf.st_blksize;
            if (*(void *)&buf.st_blksize < buf.st_ctimespec.tv_nsec)
            {
              *(void *)&buf.st_blkstd::string::size_type size = buf.st_ctimespec.tv_nsec;
              uint64_t tv_nsec = buf.st_ctimespec.tv_nsec;
            }
            p_st_ctimespec = &buf.st_ctimespec;
          }
          else
          {
            if ((buf.st_gen & 8) == 0)
            {
              std::string::size_type v86 = 0;
              *((unsigned char *)&v147.__r_.__value_.__s + 23) = 0;
              unint64_t v87 = &v147;
              goto LABEL_178;
            }
            p_st_ctimespec = (timespec *)&buf.st_atimespec.tv_nsec;
            uint64_t tv_nsec = buf.st_mtimespec.tv_nsec;
          }
          tv_sec = (const void *)p_st_ctimespec->tv_sec;
          std::string::size_type v86 = tv_nsec - p_st_ctimespec->tv_sec;
          if (v86 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v86 >= 0x17)
          {
            uint64_t v92 = (v86 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v86 | 7) != 0x17) {
              uint64_t v92 = v86 | 7;
            }
            uint64_t v93 = v92 + 1;
            unint64_t v87 = operator new(v92 + 1);
            v147.__r_.__value_.__l.__size_ = v86;
            v147.__r_.__value_.__r.__words[2] = v93 | 0x8000000000000000;
            v147.__r_.__value_.__r.__words[0] = (std::string::size_type)v87;
          }
          else
          {
            *((unsigned char *)&v147.__r_.__value_.__s + 23) = tv_nsec - LOBYTE(p_st_ctimespec->tv_sec);
            unint64_t v87 = &v147;
            if (!v86)
            {
LABEL_178:
              v87[v86] = 0;
              if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::size_type v94 = v147.__r_.__value_.__l.__size_;
                operator delete(v147.__r_.__value_.__l.__data_);
                if (!v94) {
                  goto LABEL_183;
                }
              }
              else if (!*((unsigned char *)&v147.__r_.__value_.__s + 23))
              {
LABEL_183:
                memset(&v147, 170, sizeof(v147));
                xpc_object_t v95 = xpc_dictionary_get_value(*a2, "ucs_crash_id");
                xpc_object_t __dst = v95;
                if (v95) {
                  xpc_retain(v95);
                }
                else {
                  xpc_object_t __dst = xpc_null_create();
                }
                xpc::dyn_cast_or_default();
                xpc_release(__dst);
                std::string::size_type v96 = HIBYTE(v147.__r_.__value_.__r.__words[2]);
                v97 = &v147;
                if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                {
                  std::string::size_type v96 = v147.__r_.__value_.__l.__size_;
                  v97 = (std::string *)v147.__r_.__value_.__r.__words[0];
                }
                v125 = v97;
                std::string::size_type v126 = v96;
                unint64_t first_not_of = ctu::llvm::StringRef::find_first_not_of();
                if (first_not_of >= v126) {
                  unint64_t v99 = v126;
                }
                else {
                  unint64_t v99 = first_not_of;
                }
                if (*MEMORY[0x1E4FBA198] >= v126 - v99) {
                  unint64_t v100 = v126 - v99;
                }
                else {
                  unint64_t v100 = *MEMORY[0x1E4FBA198];
                }
                xpc_object_t __dst = (char *)v125 + v99;
                unint64_t v129 = v100;
                uint64_t last_not_of = ctu::llvm::StringRef::find_last_not_of();
                xpc_object_t v103 = __dst;
                size_t v102 = v129;
                if (last_not_of + 1 < v129) {
                  unint64_t v104 = last_not_of + 1;
                }
                else {
                  unint64_t v104 = v129;
                }
                size_t v105 = v129 - v100 + v104;
                unint64_t v129 = 0xAAAAAAAAAAAAAAAALL;
                int64_t v130 = 0xAAAAAAAAAAAAAAAALL;
                if (v105 >= v102) {
                  size_t v106 = v102;
                }
                else {
                  size_t v106 = v105;
                }
                xpc_object_t __dst = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
                if (v106 > 0x7FFFFFFFFFFFFFF7) {
                  std::string::__throw_length_error[abi:ne180100]();
                }
                if (v106 >= 0x17)
                {
                  uint64_t v108 = (v106 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v106 | 7) != 0x17) {
                    uint64_t v108 = v106 | 7;
                  }
                  uint64_t v109 = v108 + 1;
                  p_dst = operator new(v108 + 1);
                  unint64_t v129 = v106;
                  int64_t v130 = v109 | 0x8000000000000000;
                  xpc_object_t __dst = p_dst;
                }
                else
                {
                  HIBYTE(v130) = v106;
                  p_dst = &__dst;
                  if (!v106) {
                    goto LABEL_208;
                  }
                }
                memmove(p_dst, v103, v106);
LABEL_208:
                *((unsigned char *)p_dst + v106) = 0;
                char v127 = 2;
                strcpy((char *)&v125, "c:");
                uint64_t v110 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)&v125, 2);
                if (v130 >= 0) {
                  v111 = &__dst;
                }
                else {
                  v111 = __dst;
                }
                if (v130 >= 0) {
                  uint64_t v112 = HIBYTE(v130);
                }
                else {
                  uint64_t v112 = v129;
                }
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)v111, v112);
                if (v127 < 0)
                {
                  operator delete(v125);
                  if ((SHIBYTE(v130) & 0x80000000) == 0)
                  {
LABEL_216:
                    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_217;
                    }
LABEL_223:
                    operator delete(v147.__r_.__value_.__l.__data_);
                    char st_gen = buf.st_gen;
                    if ((buf.st_gen & 0x10) == 0) {
                      goto LABEL_218;
                    }
                    goto LABEL_224;
                  }
                }
                else if ((SHIBYTE(v130) & 0x80000000) == 0)
                {
                  goto LABEL_216;
                }
                operator delete(__dst);
                if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
                  goto LABEL_223;
                }
LABEL_217:
                char st_gen = buf.st_gen;
                if ((buf.st_gen & 0x10) == 0)
                {
LABEL_218:
                  if ((st_gen & 8) == 0)
                  {
                    std::string::size_type v114 = 0;
                    *((unsigned char *)&v147.__r_.__value_.__s + 23) = 0;
                    v115 = &v147;
                    goto LABEL_235;
                  }
                  p_uint64_t tv_nsec = (timespec *)&buf.st_atimespec.tv_nsec;
                  uint64_t v117 = buf.st_mtimespec.tv_nsec;
LABEL_227:
                  v118 = (const void *)p_tv_nsec->tv_sec;
                  std::string::size_type v114 = v117 - p_tv_nsec->tv_sec;
                  if (v114 > 0x7FFFFFFFFFFFFFF7) {
                    std::string::__throw_length_error[abi:ne180100]();
                  }
                  if (v114 >= 0x17)
                  {
                    uint64_t v119 = (v114 & 0xFFFFFFFFFFFFFFF8) + 8;
                    if ((v114 | 7) != 0x17) {
                      uint64_t v119 = v114 | 7;
                    }
                    uint64_t v120 = v119 + 1;
                    v115 = operator new(v119 + 1);
                    v147.__r_.__value_.__l.__size_ = v114;
                    v147.__r_.__value_.__r.__words[2] = v120 | 0x8000000000000000;
                    v147.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
                  }
                  else
                  {
                    *((unsigned char *)&v147.__r_.__value_.__s + 23) = v117 - LOBYTE(p_tv_nsec->tv_sec);
                    v115 = &v147;
                    if (!v114) {
                      goto LABEL_235;
                    }
                  }
                  memmove(v115, v118, v114);
LABEL_235:
                  *((unsigned char *)v115 + v114) = 0;
                  if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    v121 = &v147;
                  }
                  else {
                    v121 = (std::string *)v147.__r_.__value_.__r.__words[0];
                  }
                  xpc_object_t v122 = xpc_string_create((const char *)v121);
                  if (!v122) {
                    xpc_object_t v122 = xpc_null_create();
                  }
                  xpc_object_t v4 = *a2;
                  xpc_dictionary_set_value(*a2, "log_data", v122);
                  xpc_object_t v123 = xpc_null_create();
                  xpc_release(v122);
                  xpc_release(v123);
                  if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v147.__r_.__value_.__l.__data_);
                  }
                  *(void *)&buf.st_dev = *MEMORY[0x1E4FBA408];
                  uint64_t v124 = *(void *)(MEMORY[0x1E4FBA408] + 72);
                  *(void *)((char *)&buf.st_dev + *(void *)(*(void *)&buf.st_dev - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
                  *(void *)&buf.st_uid = v124;
                  *(void *)&buf.st_rdev = MEMORY[0x1E4FBA470] + 16;
                  if (SHIBYTE(buf.st_blocks) < 0) {
                    operator delete((void *)buf.st_birthtimespec.tv_nsec);
                  }
                  std::streambuf::~streambuf();
                  std::iostream::~basic_iostream();
                  MEMORY[0x1A62751A0](buf.st_qspare);
LABEL_245:
                  xpc_release(v131);
                  xpc_release(xdict);
                  if (v56 != v36) {
                    goto LABEL_60;
                  }
LABEL_44:
                  uint64_t v37 = MEMORY[0x1A6275E60](v4);
                  uint64_t v38 = MEMORY[0x1E4F14590];
                  if (v37 == MEMORY[0x1E4F14590]) {
                    goto LABEL_58;
                  }
                  std::string::size_type v39 = *((void *)this + 5);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf.st_dev) = 0;
                    _os_log_impl(&dword_1A609F000, v39, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to processing errors", (uint8_t *)&buf, 2u);
                  }
                  xpc_object_t v40 = xpc_dictionary_create(0, 0, 0);
                  if (v40 || (xpc_object_t v40 = xpc_null_create()) != 0)
                  {
                    if (MEMORY[0x1A6275E60](v40) == v38)
                    {
                      xpc_retain(v40);
                      xpc_object_t v41 = v40;
                    }
                    else
                    {
                      xpc_object_t v41 = xpc_null_create();
                    }
                  }
                  else
                  {
                    xpc_object_t v41 = xpc_null_create();
                    xpc_object_t v40 = 0;
                  }
                  xpc_release(v40);
                  xpc_object_t v44 = xpc_null_create();
                  xpc_object_t v45 = *a2;
                  *a2 = v41;
                  xpc_release(v45);
                  xpc_release(v44);
                  v147.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
                  *(_OWORD *)&v147.__r_.__value_.__r.__words[1] = xmmword_1A61F8A10;
                  strcpy(v147.__r_.__value_.__l.__data_, "Coredump invalid, file read error: ");
                  BOOL v46 = std::string::append(&v147, "report.json", 0xBuLL);
                  long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
                  *(void *)&buf.st_uid = *((void *)&v46->__r_.__value_.__l + 2);
                  *(_OWORD *)&buf.st_dev = v47;
                  v46->__r_.__value_.__l.__size_ = 0;
                  v46->__r_.__value_.__r.__words[2] = 0;
                  v46->__r_.__value_.__r.__words[0] = 0;
                  CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
                  if (SHIBYTE(buf.st_gid) < 0)
                  {
                    operator delete(*(void **)&buf.st_dev);
                    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
LABEL_58:
                      if (!v15) {
                        goto LABEL_60;
                      }
                      goto LABEL_59;
                    }
                  }
                  else if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
                    goto LABEL_58;
                  }
                  operator delete(v147.__r_.__value_.__l.__data_);
                  if (!v15) {
                    goto LABEL_60;
                  }
LABEL_59:
                  objc_msgSend(v15, "close", v125);
                  goto LABEL_60;
                }
LABEL_224:
                uint64_t v117 = *(void *)&buf.st_blksize;
                if (*(void *)&buf.st_blksize < buf.st_ctimespec.tv_nsec)
                {
                  *(void *)&buf.st_blkstd::string::size_type size = buf.st_ctimespec.tv_nsec;
                  uint64_t v117 = buf.st_ctimespec.tv_nsec;
                }
                p_uint64_t tv_nsec = &buf.st_ctimespec;
                goto LABEL_227;
              }
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)", ", 2);
              goto LABEL_183;
            }
          }
          memmove(v87, tv_sec, v86);
          goto LABEL_178;
        }
        memset(&v147, 170, sizeof(v147));
        xpc_object_t v63 = xpc_dictionary_get_value(v55, "log_data");
        xpc_object_t __dst = v63;
        if (v63) {
          xpc_retain(v63);
        }
        else {
          xpc_object_t __dst = xpc_null_create();
        }
        xpc::dyn_cast_or_default();
        xpc_release(__dst);
        std::string::size_type v68 = HIBYTE(v147.__r_.__value_.__r.__words[2]);
        std::string v69 = &v147;
        if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        {
          std::string::size_type v68 = v147.__r_.__value_.__l.__size_;
          std::string v69 = (std::string *)v147.__r_.__value_.__r.__words[0];
        }
        v125 = v69;
        std::string::size_type v126 = v68;
        unint64_t v70 = ctu::llvm::StringRef::find_first_not_of();
        if (v70 >= v126) {
          unint64_t v71 = v126;
        }
        else {
          unint64_t v71 = v70;
        }
        if (*MEMORY[0x1E4FBA198] >= v126 - v71) {
          unint64_t v72 = v126 - v71;
        }
        else {
          unint64_t v72 = *MEMORY[0x1E4FBA198];
        }
        xpc_object_t __dst = (char *)v125 + v71;
        unint64_t v129 = v72;
        uint64_t v73 = ctu::llvm::StringRef::find_last_not_of();
        xpc_object_t v75 = __dst;
        size_t v74 = v129;
        if (v73 + 1 < v129) {
          unint64_t v76 = v73 + 1;
        }
        else {
          unint64_t v76 = v129;
        }
        size_t v77 = v129 - v72 + v76;
        unint64_t v129 = 0xAAAAAAAAAAAAAAAALL;
        int64_t v130 = 0xAAAAAAAAAAAAAAAALL;
        if (v77 >= v74) {
          size_t v78 = v74;
        }
        else {
          size_t v78 = v77;
        }
        xpc_object_t __dst = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        if (v78 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        if (v78 >= 0x17)
        {
          uint64_t v80 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v78 | 7) != 0x17) {
            uint64_t v80 = v78 | 7;
          }
          uint64_t v81 = v80 + 1;
          uint64_t v79 = operator new(v80 + 1);
          unint64_t v129 = v78;
          int64_t v130 = v81 | 0x8000000000000000;
          xpc_object_t __dst = v79;
        }
        else
        {
          HIBYTE(v130) = v78;
          uint64_t v79 = &__dst;
          if (!v78) {
            goto LABEL_137;
          }
        }
        memmove(v79, v75, v78);
LABEL_137:
        *((unsigned char *)v79 + v78) = 0;
        if (v130 >= 0) {
          unint64_t v82 = &__dst;
        }
        else {
          unint64_t v82 = __dst;
        }
        if (v130 >= 0) {
          uint64_t v83 = HIBYTE(v130);
        }
        else {
          uint64_t v83 = v129;
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v82, v83);
        if (SHIBYTE(v130) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v147.__r_.__value_.__l.__data_);
        }
        xpc_object_t v55 = *a2;
        goto LABEL_148;
      }
      int v30 = v134;
      if (!v134) {
        goto LABEL_44;
      }
      int v31 = *((void *)this + 5);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
      uint64_t v32 = objc_msgSend((id)objc_msgSend(v30, "localizedDescription"), "UTF8String");
      buf.st_dev = 136315138;
      *(void *)&buf.st_mode = v32;
      uint64_t v20 = "Error parsing file via return code: %s";
      CFMutableDictionaryRef v21 = v31;
      uint32_t v22 = 12;
    }
    else
    {
      char v19 = *((void *)this + 5);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
      LOWORD(buf.st_dev) = 0;
      uint64_t v20 = "Error reading file";
      CFMutableDictionaryRef v21 = v19;
      uint32_t v22 = 2;
    }
    _os_log_error_impl(&dword_1A609F000, v21, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&buf, v22);
    goto LABEL_44;
  }
  uint64_t v11 = *((void *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 223) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    buf.st_dev = 136315138;
    *(void *)&buf.st_mode = v8;
    _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "File not found: %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  if (v12 || (xpc_object_t v12 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v12) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v12);
      xpc_object_t v13 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v12 = 0;
  }
  xpc_release(v12);
  xpc_object_t v23 = xpc_null_create();
  xpc_object_t v24 = *a2;
  *a2 = v13;
  xpc_release(v24);
  xpc_release(v23);
  *((unsigned char *)&v147.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v147, "report.json");
  std::string::size_type v25 = std::string::append(&v147, " missing", 8uLL);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  *(void *)&buf.st_uid = *((void *)&v25->__r_.__value_.__l + 2);
  *(_OWORD *)&buf.st_dev = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((buf.st_gid & 0x80000000) == 0) {
    p_stat buf = (const char *)&buf;
  }
  else {
    p_stat buf = *(const char **)&buf.st_dev;
  }
  xpc_object_t v28 = xpc_string_create(p_buf);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  xpc_dictionary_set_value(v13, "ioerror", v28);
  xpc_object_t v29 = xpc_null_create();
  xpc_release(v28);
  xpc_release(v29);
  if (SHIBYTE(buf.st_gid) < 0)
  {
    operator delete(*(void **)&buf.st_dev);
    if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_60;
    }
  }
  else if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_60;
  }
  operator delete(v147.__r_.__value_.__l.__data_);
LABEL_60:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  xpc_release(object);
}

void sub_1A612517C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,xpc_object_t a22,xpc_object_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,xpc_object_t a31,long long buf)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&buf);
  xpc_release(object);
  xpc_release(a23);
  if (a2 == 2)
  {
    uint64_t v36 = __cxa_begin_catch(a1);
    uint64_t v37 = *(NSObject **)(v33 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      uint64_t v38 = objc_msgSend((id)objc_msgSend(v36, "name"), "UTF8String");
      uint64_t v39 = objc_msgSend((id)objc_msgSend(v36, "reason"), "UTF8String");
      LODWORD(buf) = 136315394;
      *(void *)((char *)&buf + 4) = v38;
      WORD6(buf) = 2080;
      *(void *)((char *)&buf + 14) = v39;
      _os_log_error_impl(&dword_1A609F000, v37, OS_LOG_TYPE_ERROR, "Error parsing file via exception: %s: %s", (uint8_t *)&buf, 0x16u);
    }
    __cxa_end_catch();
    JUMPOUT(0x1A612435CLL);
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  xpc::dict::~dict(v32);
  xpc_release(a31);
  _Unwind_Resume(a1);
}

void xpc::array::object_proxy::operator xpc::dict(uint64_t a1@<X0>, void *a2@<X8>)
{
  xpc_object_t value = xpc_array_get_value(**(xpc_object_t **)a1, *(void *)(a1 + 8));
  if (value)
  {
    xpc_object_t v4 = value;
    xpc_retain(value);
    *a2 = v4;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    *a2 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A6275E60](v4) != MEMORY[0x1E4F14590])
  {
    xpc_object_t v5 = xpc_null_create();
LABEL_8:
    *a2 = v5;
    goto LABEL_9;
  }
  xpc_retain(v4);
LABEL_9:
  xpc_release(v4);
}

uint64_t CoredumpTrace::makeCrashString@<X0>(xpc_object_t *a1@<X1>, unsigned char *a2@<X8>)
{
  unint64_t v66 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v65[7] = v5;
  v65[8] = v5;
  v65[5] = v5;
  v65[6] = v5;
  v65[3] = v5;
  v65[4] = v5;
  v65[1] = v5;
  v65[2] = v5;
  long long v64 = v5;
  v65[0] = v5;
  *(_OWORD *)timespec v62 = v5;
  long long v63 = v5;
  long long v60 = v5;
  long long v61 = v5;
  long long v58 = v5;
  long long v59 = v5;
  long long v57 = v5;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v57);
  if (xpc_dictionary_get_value(*a1, "ioerror"))
  {
    memset(&__p, 170, sizeof(__p));
    xpc_object_t value = xpc_dictionary_get_value(*a1, "ioerror");
    object[0] = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      object[0] = xpc_null_create();
    }
    long long v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v69) < 0) {
      operator delete(v67);
    }
    xpc_release(object[0]);
    uint64_t v8 = &v58;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
LABEL_27:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_93;
  }
  if (xpc_dictionary_get_value(*a1, "fullreport"))
  {
    memset(&__p, 170, sizeof(__p));
    xpc_object_t v7 = xpc_dictionary_get_value(*a1, "fullreport");
    object[0] = v7;
    if (v7) {
      xpc_retain(v7);
    }
    else {
      object[0] = xpc_null_create();
    }
    long long v67 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v69) < 0) {
      operator delete(v67);
    }
    xpc_release(object[0]);
    util::strip_non_printable(&__p);
    uint64_t v8 = (long long *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v58, (uint64_t)"RAW=", 4);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    goto LABEL_27;
  }
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v58, (uint64_t)"TASK=", 5);
  xpc_object_t v12 = xpc_dictionary_get_value(*a1, "host_taskname");
  xpc_object_t v55 = v12;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    xpc_object_t v55 = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0) {
    operator delete(v67);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v13 = &__p;
  }
  else {
    xpc_object_t v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  xpc_object_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v13, v14);
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" @ ", 3);
  xpc_object_t v17 = xpc_dictionary_get_value(*a1, "host_filename");
  xpc_object_t v52 = v17;
  if (v17) {
    xpc_retain(v17);
  }
  else {
    xpc_object_t v52 = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0) {
    operator delete(v67);
  }
  if ((v54 & 0x80u) == 0) {
    xpc_object_t v18 = object;
  }
  else {
    xpc_object_t v18 = (xpc_object_t *)object[0];
  }
  if ((v54 & 0x80u) == 0) {
    uint64_t v19 = v54;
  }
  else {
    uint64_t v19 = (uint64_t)object[1];
  }
  uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v18, v19);
  CFMutableDictionaryRef v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)":", 1);
  xpc_object_t v22 = xpc_dictionary_get_value(*a1, "host_line");
  xpc_object_t v49 = v22;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    xpc_object_t v49 = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0) {
    operator delete(v67);
  }
  if ((v51 & 0x80u) == 0) {
    xpc_object_t v23 = v50;
  }
  else {
    xpc_object_t v23 = (void **)v50[0];
  }
  if ((v51 & 0x80u) == 0) {
    uint64_t v24 = v51;
  }
  else {
    uint64_t v24 = (uint64_t)v50[1];
  }
  std::string::size_type v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v23, v24);
  long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)",CPU=", 5);
  xpc_object_t v27 = xpc_dictionary_get_value(*a1, "subsystem");
  xpc_object_t v46 = v27;
  if (v27) {
    xpc_retain(v27);
  }
  else {
    xpc_object_t v46 = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0) {
    operator delete(v67);
  }
  if ((v48 & 0x80u) == 0) {
    xpc_object_t v28 = v47;
  }
  else {
    xpc_object_t v28 = (void **)v47[0];
  }
  if ((v48 & 0x80u) == 0) {
    uint64_t v29 = v48;
  }
  else {
    uint64_t v29 = (uint64_t)v47[1];
  }
  int v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)v28, v29);
  int v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)",LOG=", 5);
  xpc_object_t v32 = xpc_dictionary_get_value(*a1, "log_data");
  xpc_object_t v43 = v32;
  if (v32) {
    xpc_retain(v32);
  }
  else {
    xpc_object_t v43 = xpc_null_create();
  }
  long long v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v69) < 0) {
    operator delete(v67);
  }
  if ((v45 & 0x80u) == 0) {
    uint64_t v33 = v44;
  }
  else {
    uint64_t v33 = (void **)v44[0];
  }
  if ((v45 & 0x80u) == 0) {
    uint64_t v34 = v45;
  }
  else {
    uint64_t v34 = (uint64_t)v44[1];
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)v33, v34);
  if ((char)v45 < 0) {
    operator delete(v44[0]);
  }
  xpc_release(v43);
  if ((char)v48 < 0) {
    operator delete(v47[0]);
  }
  xpc_release(v46);
  if ((char)v51 < 0) {
    operator delete(v50[0]);
  }
  xpc_release(v49);
  if ((char)v54 < 0) {
    operator delete(object[0]);
  }
  xpc_release(v52);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  xpc_release(v55);
LABEL_93:
  if ((BYTE8(v64) & 0x10) != 0)
  {
    uint64_t v36 = v64;
    if ((unint64_t)v64 < *((void *)&v61 + 1))
    {
      *(void *)&long long v64 = *((void *)&v61 + 1);
      uint64_t v36 = *((void *)&v61 + 1);
    }
    uint64_t v37 = (const void *)v61;
    size_t v35 = v36 - v61;
    if ((unint64_t)(v36 - v61) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_110;
    }
  }
  else
  {
    if ((BYTE8(v64) & 8) == 0)
    {
      size_t v35 = 0;
      a2[23] = 0;
      goto LABEL_106;
    }
    uint64_t v37 = (const void *)*((void *)&v59 + 1);
    size_t v35 = *((void *)&v60 + 1) - *((void *)&v59 + 1);
    if (*((void *)&v60 + 1) - *((void *)&v59 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_110:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v35 >= 0x17)
  {
    uint64_t v38 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17) {
      uint64_t v38 = v35 | 7;
    }
    uint64_t v39 = v38 + 1;
    xpc_object_t v40 = operator new(v38 + 1);
    *((void *)a2 + 1) = v35;
    *((void *)a2 + 2) = v39 | 0x8000000000000000;
    *(void *)a2 = v40;
    a2 = v40;
    goto LABEL_105;
  }
  a2[23] = v35;
  if (v35) {
LABEL_105:
  }
    memmove(a2, v37, v35);
LABEL_106:
  a2[v35] = 0;
  *(void *)&long long v57 = *MEMORY[0x1E4FBA408];
  uint64_t v41 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v57 + *(void *)(v57 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v58 = v41;
  *((void *)&v58 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v63) < 0) {
    operator delete(v62[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v65);
}

void sub_1A6125CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,xpc_object_t a30,xpc_object_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,xpc_object_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  if (a22 < 0) {
    operator delete(a17);
  }
  xpc_release(a16);
  if (a29 < 0) {
    operator delete(a24);
  }
  xpc_release(a23);
  if (a36 < 0) {
    operator delete(a31);
  }
  xpc_release(a30);
  if (a43 < 0) {
    operator delete(a38);
  }
  xpc_release(a37);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void CoredumpTrace::~CoredumpTrace(CoredumpTrace *this)
{
  CoredumpTrace::~CoredumpTrace(this);

  operator delete(v1);
}

{
  NSObject *v2;
  std::__shared_weak_count *v3;
  Trace *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EFB0B3E0;
  uint64_t v2 = *((void *)this + 28);
  if (v2) {
    dispatch_release(v2);
  }
  if (*((char *)this + 223) < 0)
  {
    operator delete(*((void **)this + 25));
    if ((*((char *)this + 199) & 0x80000000) == 0)
    {
LABEL_5:
      CFAllocatorRef v3 = (std::__shared_weak_count *)*((void *)this + 20);
      if (!v3) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }
  else if ((*((char *)this + 199) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*((void **)this + 22));
  CFAllocatorRef v3 = (std::__shared_weak_count *)*((void *)this + 20);
  if (!v3) {
    goto LABEL_6;
  }
LABEL_11:
  if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_6:
    xpc_object_t v4 = this;
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  xpc_object_t v4 = this;

LABEL_8:
  Trace::~Trace(v4);
}

uint64_t ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  CFAllocatorRef v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

void *std::shared_ptr<CoredumpTrace>::shared_ptr[abi:ne180100]<CoredumpTrace,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  xpc_object_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B5F8;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2) {
    return a1;
  }
  size_t v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 72) = a2;
      *(void *)(a2 + 80) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(a2 + 72) = a2;
  *(void *)(a2 + 80) = v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A61261C8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1}::operator() const(CoredumpTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A61261F0(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<CoredumpTrace *,std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace *)#1},std::allocator<CoredumpTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_p"
                                "trIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI13CoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<CoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<CoredumpTrace>(CoredumpTrace*)::{lambda(CoredumpTrace*)#1}::operator() const(CoredumpTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_2(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::__on_zero_shared(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v1 = (void *)MEMORY[0x1A6274950]();
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<ABMProperties *,std::shared_ptr<ABMProperties>::__shared_ptr_default_delete<ABMProperties,ABMProperties>,std::allocator<ABMProperties>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001A61F8BD2) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001A61F8BD2 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A61F8BD2)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A61F8BD2 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t ctu::PthreadMutexGuardPolicy<ABMProperties>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t __cxx_global_var_init_78()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_79()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_80()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_81()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ABMProperties>::~PthreadMutexGuardPolicy, &ctu::Singleton<ABMProperties,ABMProperties,ctu::PthreadMutexGuardPolicy<ABMProperties>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t support::transport::ARI::getLogClient(support::transport::ARI *this)
{
  return (uint64_t)this + 32;
}

BOOL support::transport::ARI::initRT(support::transport::ARI *this, char *__s, dispatch_queue_s *a3)
{
  strcpy((char *)&v52, "com.apple.ARITransport");
  *((unsigned char *)&v52.__r_.__value_.__s + 23) = 22;
  if (!__s || !*__s)
  {
    std::string::size_type v25 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    long long v26 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v25 + 16))(v25, 1, **((void **)this + 10));
    if (v26)
    {
      if (*((void *)v25 + 17))
      {
        support::log::buffer::borrow(v26);
        int v27 = 2;
      }
      else
      {
        int v27 = 0;
      }
      if (v27 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v40 = _os_log_send_and_compose_impl();
        if (v40)
        {
          uint64_t v41 = (char *)v40;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          uint64_t v50 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v25, (const support::log::details *)__p, v41);
        }
      }
    }
    goto LABEL_75;
  }
  size_t v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
  uint64_t v8 = &__dst;
  if (v6) {
LABEL_10:
  }
    memcpy(v8, __s, v7);
  v8->__r_.__value_.__s.__data_[v7] = 0;
  uint64_t v11 = std::string::insert(&__dst, 0, ".", 1uLL);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  uint64_t v50 = (char *)v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v50) >= 0) {
    xpc_object_t v13 = __p;
  }
  else {
    xpc_object_t v13 = (void **)__p[0];
  }
  if (SHIBYTE(v50) >= 0) {
    std::string::size_type v14 = HIBYTE(v50);
  }
  else {
    std::string::size_type v14 = (std::string::size_type)__p[1];
  }
  std::string::append(&v52, (const std::string::value_type *)v13, v14);
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_19;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_19:
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v15 = &v52;
  }
  else {
    xpc_object_t v15 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }
  uint64_t v16 = (AriHost *)dispatch_queue_create((const char *)v15, 0);
  xpc_object_t v17 = *((void *)this + 1);
  *((void *)this + 1) = v16;
  if (v17)
  {
    dispatch_release(v17);
    uint64_t v16 = (AriHost *)*((void *)this + 1);
  }
  if (!v16)
  {
    xpc_object_t v28 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    uint64_t v29 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v28 + 16))(v28, 1, **((void **)this + 10));
    if (v29)
    {
      if (*((void *)v28 + 17))
      {
        support::log::buffer::borrow(v29);
        int v30 = 2;
      }
      else
      {
        int v30 = 0;
      }
      if (v30 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v42 = _os_log_send_and_compose_impl();
        if (v42) {
          goto LABEL_74;
        }
      }
    }
    goto LABEL_75;
  }
  if (AriHost::Init(v16))
  {
    xpc_object_t v28 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    int v31 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v28 + 16))(v28, 1, **((void **)this + 10));
    if (v31)
    {
      if (*((void *)v28 + 17))
      {
        support::log::buffer::borrow(v31);
        int v32 = 2;
      }
      else
      {
        int v32 = 0;
      }
      if (v32 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v42 = _os_log_send_and_compose_impl();
        if (v42) {
          goto LABEL_74;
        }
      }
    }
    goto LABEL_75;
  }
  if (AriHost::RegisterClient((AriHost *)__s, (const char *)this + 16, *((int **)this + 1), a3))
  {
    xpc_object_t v28 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    uint64_t v33 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v28 + 16))(v28, 1, **((void **)this + 10));
    if (v33)
    {
      if (*((void *)v28 + 17))
      {
        support::log::buffer::borrow(v33);
        int v34 = 2;
      }
      else
      {
        int v34 = 0;
      }
      if (v34 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v42 = _os_log_send_and_compose_impl();
        if (v42)
        {
LABEL_74:
          xpc_object_t v43 = (char *)v42;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          uint64_t v50 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v28, (const support::log::details *)__p, v43);
        }
      }
    }
LABEL_75:
    BOOL v23 = 0;
    if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v23;
    }
    goto LABEL_39;
  }
  xpc_object_t v18 = operator new(0x20uLL);
  *xpc_object_t v18 = 0u;
  v18[1] = 0u;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
  if (KTLInitOptions())
  {
    if (KTLOpenChannel())
    {
      __dst.__r_.__value_.__r.__words[0] = 0;
      uint64_t v19 = (void *)*((void *)this + 3);
      *((void *)this + 3) = v18;
      if (!v19)
      {
        BOOL v23 = 1;
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_39;
        }
        return v23;
      }
      if (v19[1])
      {
        TelephonyUtilTransportFree();
        int v20 = 0;
        int v21 = 0;
        xpc_object_t v22 = (void *)v19[1];
        if (!v22) {
          goto LABEL_38;
        }
        goto LABEL_32;
      }
      int v21 = 0;
      goto LABEL_38;
    }
    size_t v35 = (support::log::manager *)*((void *)this + 13);
    char v47 = 1;
    uint64_t v38 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v35 + 16))(v35, 1, **((void **)this + 10));
    if (v38)
    {
      if (*((void *)v35 + 17))
      {
        support::log::buffer::borrow(v38);
        int v39 = 2;
      }
      else
      {
        int v39 = 0;
      }
      if (v39 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v44 = _os_log_send_and_compose_impl();
        if (v44) {
          goto LABEL_84;
        }
      }
    }
  }
  else
  {
    size_t v35 = (support::log::manager *)*((void *)this + 13);
    char v47 = 1;
    uint64_t v36 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v35 + 16))(v35, 1, **((void **)this + 10));
    if (v36)
    {
      if (*((void *)v35 + 17))
      {
        support::log::buffer::borrow(v36);
        int v37 = 2;
      }
      else
      {
        int v37 = 0;
      }
      if (v37 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v44 = _os_log_send_and_compose_impl();
        if (v44)
        {
LABEL_84:
          unsigned __int8 v45 = (char *)v44;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          uint64_t v50 = &v47;
          p_dst = (std::string *)&rep;
          support::log::manager::message_delegates(v35, (const support::log::details *)__p, v45);
        }
      }
    }
  }
  __dst.__r_.__value_.__r.__words[0] = 0;
  if (*((void *)v18 + 1))
  {
    TelephonyUtilTransportFree();
    xpc_object_t v22 = (void *)*((void *)v18 + 1);
    int v20 = 8;
    uint64_t v19 = v18;
    int v21 = 8;
    if (v22)
    {
LABEL_32:
      operator delete(v22);
      int v21 = v20;
    }
  }
  else
  {
    int v21 = 8;
    uint64_t v19 = v18;
  }
LABEL_38:
  operator delete(v19);
  BOOL v23 = v21 == 0;
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
LABEL_39:
  }
    operator delete(v52.__r_.__value_.__l.__data_);
  return v23;
}

void sub_1A6126F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void **std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (v2[1])
    {
      TelephonyUtilTransportFree();
      uint64_t v3 = (void *)v2[1];
      if (v3) {
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t support::transport::ARI::initLibTU(support::transport::ARI *this, const char *__s, int a3)
{
  strcpy((char *)&v60, "com.apple.ARITransport");
  *((unsigned char *)&v60.__r_.__value_.__s + 23) = 22;
  uint64_t v59 = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v54 = 0u;
  if (!__s || !*__s)
  {
    uint64_t v24 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    std::string::size_type v25 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v24 + 16))(v24, 1, **((void **)this + 10));
    if (v25)
    {
      if (*((void *)v24 + 17))
      {
        support::log::buffer::borrow(v25);
        int v26 = 2;
      }
      else
      {
        int v26 = 0;
      }
      if (v26 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v38 = _os_log_send_and_compose_impl();
        if (v38)
        {
          int v39 = (char *)v38;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          std::string v52 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v24, (const support::log::details *)__p, v39);
        }
      }
    }
LABEL_78:
    uint64_t v22 = 0;
    if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v22;
    }
    goto LABEL_37;
  }
  size_t v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    goto LABEL_10;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
  uint64_t v8 = &__dst;
  if (v6) {
LABEL_10:
  }
    memcpy(v8, __s, v7);
  v8->__r_.__value_.__s.__data_[v7] = 0;
  uint64_t v11 = std::string::insert(&__dst, 0, ".", 1uLL);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  std::string v52 = (char *)v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v52) >= 0) {
    xpc_object_t v13 = __p;
  }
  else {
    xpc_object_t v13 = (void **)__p[0];
  }
  if (SHIBYTE(v52) >= 0) {
    std::string::size_type v14 = HIBYTE(v52);
  }
  else {
    std::string::size_type v14 = (std::string::size_type)__p[1];
  }
  std::string::append(&v60, (const std::string::value_type *)v13, v14);
  if (SHIBYTE(v52) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_19;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_19:
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v15 = &v60;
  }
  else {
    xpc_object_t v15 = (std::string *)v60.__r_.__value_.__r.__words[0];
  }
  dispatch_queue_t v16 = dispatch_queue_create((const char *)v15, 0);
  xpc_object_t v17 = *((void *)this + 1);
  *((void *)this + 1) = v16;
  if (v17)
  {
    dispatch_release(v17);
    dispatch_queue_t v16 = (dispatch_queue_t)*((void *)this + 1);
  }
  if (!v16)
  {
    int v27 = (support::log::manager *)*((void *)this + 13);
    LOBYTE(rep) = 1;
    xpc_object_t v28 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v27 + 16))(v27, 1, **((void **)this + 10));
    if (v28)
    {
      if (*((void *)v27 + 17))
      {
        support::log::buffer::borrow(v28);
        int v29 = 2;
      }
      else
      {
        int v29 = 0;
      }
      if (v29 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v40 = _os_log_send_and_compose_impl();
        if (v40)
        {
          uint64_t v41 = (char *)v40;
          __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          std::string v52 = (char *)&rep;
          p_dst = &__dst;
          support::log::manager::message_delegates(v27, (const support::log::details *)__p, v41);
        }
      }
    }
    goto LABEL_78;
  }
  TelephonyBasebandPCITransportInitParameters();
  uint64_t v18 = *((void *)this + 1);
  DWORD2(v55) = a3;
  LODWORD(v56) = v56 | 1;
  LODWORD(v54) = 8;
  v49[0] = MEMORY[0x1E4F143A8];
  v49[1] = 0x40000000;
  v49[2] = ___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke;
  v49[3] = &__block_descriptor_tmp_4;
  v49[4] = this;
  __dst.__r_.__value_.__r.__words[0] = 0;
  *((void *)&v54 + 1) = v18;
  *(void *)&long long v55 = v49;
  operator new(0x58uLL);
  if ((TelephonyBasebandPCITransportCreate() & 1) == 0)
  {
    int v30 = (support::log::manager *)*((void *)this + 13);
    char v48 = 1;
    int v31 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v30 + 16))(v30, 1, **((void **)this + 10));
    if (v31)
    {
      if (*((void *)v30 + 17))
      {
        support::log::buffer::borrow(v31);
        int v32 = 2;
      }
      else
      {
        int v32 = 0;
      }
      if (v32 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        uint64_t v42 = _os_log_send_and_compose_impl();
        if (v42)
        {
          xpc_object_t v43 = (char *)v42;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
          __p[0] = &unk_1EFB0B700;
          __p[1] = (char *)this + 40;
          std::string v52 = &v48;
          p_dst = (std::string *)&rep;
          support::log::manager::message_delegates(v30, (const support::log::details *)__p, v43);
        }
      }
    }
    goto LABEL_78;
  }
  uint64_t v19 = operator new(0x20uLL);
  *uint64_t v19 = 0u;
  v19[1] = 0u;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
  if ((KTLInitOptions() & 1) == 0)
  {
    uint64_t v33 = (support::log::manager *)*((void *)this + 13);
    char v48 = 1;
    int v34 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v33 + 16))(v33, 1, **((void **)this + 10));
    if (!v34) {
      goto LABEL_74;
    }
    if (*((void *)v33 + 17))
    {
      support::log::buffer::borrow(v34);
      int v35 = 2;
    }
    else
    {
      int v35 = 0;
    }
    if (!(v35 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_74;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v44 = _os_log_send_and_compose_impl();
    if (!v44) {
      goto LABEL_74;
    }
LABEL_73:
    unsigned __int8 v45 = (char *)v44;
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
    __p[0] = &unk_1EFB0B700;
    __p[1] = (char *)this + 40;
    std::string v52 = &v48;
    p_dst = (std::string *)&rep;
    support::log::manager::message_delegates(v33, (const support::log::details *)__p, v45);
LABEL_74:
    __dst.__r_.__value_.__r.__words[0] = 0;
    if (*((void *)v19 + 1))
    {
      TelephonyUtilTransportFree();
      xpc_object_t v46 = (void *)*((void *)v19 + 1);
      if (v46) {
        operator delete(v46);
      }
    }
    operator delete(v19);
    goto LABEL_78;
  }
  if ((KTLOpenChannel() & 1) == 0)
  {
    uint64_t v33 = (support::log::manager *)*((void *)this + 13);
    char v48 = 1;
    uint64_t v36 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v33 + 16))(v33, 1, **((void **)this + 10));
    if (!v36) {
      goto LABEL_74;
    }
    if (*((void *)v33 + 17))
    {
      support::log::buffer::borrow(v36);
      int v37 = 2;
    }
    else
    {
      int v37 = 0;
    }
    if (!(v37 | os_log_type_enabled(**((os_log_t **)this + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_74;
    }
    LOWORD(__p[0]) = 0;
    uint64_t v44 = _os_log_send_and_compose_impl();
    if (!v44) {
      goto LABEL_74;
    }
    goto LABEL_73;
  }
  __dst.__r_.__value_.__r.__words[0] = 0;
  int v20 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v19;
  if (v20)
  {
    if (v20[1])
    {
      TelephonyUtilTransportFree();
      int v21 = (void *)v20[1];
      if (v21) {
        operator delete(v21);
      }
    }
    operator delete(v20);
    uint64_t v22 = 1;
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v22 = 1;
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
LABEL_37:
    }
      operator delete(v60.__r_.__value_.__l.__data_);
  }
  return v22;
}

void sub_1A61278C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100]((void **)&a18);
  if (*(char *)(v29 - 73) < 0)
  {
    operator delete(*(void **)(v29 - 96));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void ___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2 == 1)
  {
    std::string::size_type v7 = *(void **)(v2 + 104);
    char v25 = 1;
    uint64_t v8 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v7 + 16))(v7, a2, **(void **)(v2 + 80));
    if (v8)
    {
      if (v7[17])
      {
        int v9 = 2;
        support::log::buffer::borrow(v8);
      }
      else
      {
        int v9 = 0;
      }
      if (v9 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
      {
        LOWORD(v26) = 0;
        uint64_t v18 = _os_log_send_and_compose_impl();
        if (v18)
        {
          std::string::size_type v14 = (char *)v18;
          v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
          int v26 = &unk_1EFB0B700;
          uint64_t v27 = v2 + 40;
          xpc_object_t v28 = &v25;
          p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
          uint64_t v19 = v7 + 15;
          for (uint64_t i = v7[16]; (void *)i != v19; uint64_t i = *(void *)(i + 8))
            v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(i + 16))(*(void *)(i + 16), &v26, v14);
          goto LABEL_29;
        }
      }
    }
  }
  else
  {
    int v3 = a2;
    if (a2)
    {
      uint64_t v10 = *(void **)(v2 + 104);
      char v25 = 1;
      uint64_t v11 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v10 + 16))(v10, 1, **(void **)(v2 + 80));
      if (v11)
      {
        if (v10[17])
        {
          int v12 = 2;
          support::log::buffer::borrow(v11);
        }
        else
        {
          int v12 = 0;
        }
        if (v12 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LODWORD(v26) = 67109120;
          HIDWORD(v26) = v3;
          uint64_t v21 = _os_log_send_and_compose_impl();
          if (v21)
          {
            std::string::size_type v14 = (char *)v21;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
            int v26 = &unk_1EFB0B700;
            uint64_t v27 = v2 + 40;
            xpc_object_t v28 = &v25;
            p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
            uint64_t v22 = v10 + 15;
            for (uint64_t j = v10[16]; (void *)j != v22; uint64_t j = *(void *)(j + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(j + 16))(*(void *)(j + 16), &v26, v14);
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      xpc_object_t v4 = *(void **)(v2 + 104);
      char v25 = 1;
      long long v5 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v4 + 16))(v4, 1, **(void **)(v2 + 80));
      if (v5)
      {
        if (v4[17])
        {
          int v6 = 2;
          support::log::buffer::borrow(v5);
        }
        else
        {
          int v6 = 0;
        }
        if (v6 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LOWORD(v26) = 0;
          uint64_t v13 = _os_log_send_and_compose_impl();
          if (v13)
          {
            std::string::size_type v14 = (char *)v13;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
            int v26 = &unk_1EFB0B700;
            uint64_t v27 = v2 + 40;
            xpc_object_t v28 = &v25;
            p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
            dispatch_queue_t v16 = v4 + 15;
            for (uint64_t k = v4[16]; (void *)k != v16; uint64_t k = *(void *)(k + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(k + 16))(*(void *)(k + 16), &v26, v14);
LABEL_29:
            support::log::manager::release_log_buffer((support::log::manager *)v15.__d_.__rep_, v14);
          }
        }
      }
    }
  }
}

uint64_t support::transport::ARI::getKTLOptions(support::transport::ARI *this)
{
  return *((void *)this + 3);
}

uint64_t support::transport::ARI::getLibTUTransport(support::transport::ARI *this)
{
  return *(void *)(*((void *)this + 3) + 8);
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, dispatch_queue_s *a2@<X1>, char a3@<W3>, const support::log::manager *a4@<X4>, support::transport::ARI **a5@<X8>)
{
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v38 = v11;
  long long v39 = v11;
  v37[1] = v11;
  void v37[2] = v11;
  v37[0] = v11;
  int v35 = operator new(0x30uLL);
  long long v36 = xmmword_1A61F8C20;
  strcpy((char *)v35, "com.apple.telephony.basebandservices.support");
  char v34 = 10;
  strcpy((char *)__p, "ari.create");
  support::log::client::client(v37, (uint64_t)&v35, (uint64_t)__p, (uint64_t)a4);
  if (v34 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v36) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_10:
    operator delete(v35);
    goto LABEL_3;
  }
  if (SHIBYTE(v36) < 0) {
    goto LABEL_10;
  }
LABEL_3:
  *a5 = (support::transport::ARI *)0xAAAAAAAAAAAAAAAALL;
  int v12 = (support::transport::ARI *)operator new(0x70uLL);
  support::transport::ARI::ARI(v12, a4);
  *a5 = v12;
  uint64_t v13 = getprogname();
  if (!strncmp(v13, "CommCenter", 0xAuLL)) {
    goto LABEL_13;
  }
  std::string::size_type v14 = getprogname();
  if (!strncmp(v14, "CommCenter-asan", 0xFuLL)) {
    goto LABEL_13;
  }
  std::chrono::system_clock::time_point v15 = getprogname();
  if (!strncmp(v15, "basebandd", 9uLL)) {
    goto LABEL_13;
  }
  HIBYTE(v28) = 10;
  strcpy((char *)v27, "CommCenter");
  if ((ctu::isProcessRunning() & 1) == 0)
  {
    char v32 = 9;
    strcpy((char *)v31, "basebandd");
    int isProcessRunning = ctu::isProcessRunning();
    if (SHIBYTE(v28) < 0) {
      goto LABEL_19;
    }
    goto LABEL_12;
  }
  int isProcessRunning = 1;
  if ((SHIBYTE(v28) & 0x80000000) == 0)
  {
LABEL_12:
    if (!isProcessRunning) {
      goto LABEL_20;
    }
LABEL_13:
    if (a3)
    {
      if (support::transport::ARI::initRT(v12, (char *)this, a2)) {
        goto LABEL_15;
      }
      char v30 = 1;
      uint64_t v18 = (support::log::manager *)*((void *)&v39 + 1);
      BOOL v23 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v39 + 1) + 16))(*((void *)&v39 + 1), 1, *(void *)v38);
      if (!v23) {
        goto LABEL_38;
      }
      if (*((void *)v18 + 17))
      {
        support::log::buffer::borrow(v23);
        int v24 = 2;
      }
      else
      {
        int v24 = 0;
      }
      if (!(v24 | os_log_type_enabled(*(os_log_t *)v38, OS_LOG_TYPE_ERROR))) {
        goto LABEL_38;
      }
      LOWORD(v27[0]) = 0;
      uint64_t v25 = _os_log_send_and_compose_impl();
      if (!v25) {
        goto LABEL_38;
      }
    }
    else
    {
      char v30 = 1;
      uint64_t v18 = (support::log::manager *)*((void *)&v39 + 1);
      uint64_t v21 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v39 + 1) + 16))(*((void *)&v39 + 1), 1, *(void *)v38);
      if (!v21) {
        goto LABEL_38;
      }
      if (*((void *)v18 + 17))
      {
        support::log::buffer::borrow(v21);
        int v22 = 2;
      }
      else
      {
        int v22 = 0;
      }
      if (!(v22 | os_log_type_enabled(*(os_log_t *)v38, OS_LOG_TYPE_ERROR))) {
        goto LABEL_38;
      }
      LOWORD(v27[0]) = 0;
      uint64_t v25 = _os_log_send_and_compose_impl();
      if (!v25) {
        goto LABEL_38;
      }
    }
    goto LABEL_37;
  }
LABEL_19:
  operator delete(v27[0]);
  if (isProcessRunning) {
    goto LABEL_13;
  }
LABEL_20:
  if (support::transport::ARI::initLibTU(v12, (const char *)this, (int)a2)) {
    goto LABEL_15;
  }
  char v30 = 1;
  uint64_t v18 = (support::log::manager *)*((void *)&v39 + 1);
  uint64_t v19 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v39 + 1) + 16))(*((void *)&v39 + 1), 1, *(void *)v38);
  if (v19)
  {
    if (*((void *)v18 + 17))
    {
      support::log::buffer::borrow(v19);
      int v20 = 2;
    }
    else
    {
      int v20 = 0;
    }
    if (v20 | os_log_type_enabled(*(os_log_t *)v38, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v27[0]) = 0;
      uint64_t v25 = _os_log_send_and_compose_impl();
      if (v25)
      {
LABEL_37:
        int v26 = (char *)v25;
        v31[0] = std::chrono::system_clock::now().__d_.__rep_;
        v27[0] = &unk_1EFB0B700;
        v27[1] = (char *)v37 + 8;
        xpc_object_t v28 = &v30;
        uint64_t v29 = v31;
        support::log::manager::message_delegates(v18, (const support::log::details *)v27, v26);
      }
    }
  }
LABEL_38:
  *a5 = 0;
  (*(void (**)(support::transport::ARI *))(*(void *)v12 + 8))(v12);
LABEL_15:
  *(void *)&v37[0] = &unk_1EFB0B730;
  xpc_object_t v17 = (std::__shared_weak_count *)v39;
  if ((void)v39)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v39 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void sub_1A6128440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  void *v37 = 0;
  (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  support::log::client::~client((support::log::client *)&a37);
  _Unwind_Resume(a1);
}

void support::log::client::~client(support::log::client *this)
{
  *(void *)this = &unk_1EFB0B730;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, dispatch_queue_s *a2@<X1>, const support::log::manager *a3@<X3>, support::transport::ARI **a4@<X8>)
{
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, const char *a2@<X1>, const support::log::manager *a3@<X2>, support::transport::ARI **a4@<X8>)
{
}

support::transport::ARI *support::transport::ARI::ARI(support::transport::ARI *this, const support::log::manager *a2)
{
  *(void *)this = &unk_1EFB0B698;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  std::string::size_type v7 = operator new(0x30uLL);
  long long v8 = xmmword_1A61F8C20;
  strcpy((char *)v7, "com.apple.telephony.basebandservices.support");
  char v6 = 3;
  LODWORD(__p) = 6910561;
  support::log::client::client((void *)this + 4, (uint64_t)&v7, (uint64_t)&__p, (uint64_t)a2);
  if (v6 < 0)
  {
    operator delete(__p);
    if ((SHIBYTE(v8) & 0x80000000) == 0) {
      return this;
    }
  }
  else if ((SHIBYTE(v8) & 0x80000000) == 0)
  {
    return this;
  }
  operator delete(v7);
  return this;
}

void sub_1A61286D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0)
    {
LABEL_3:
      std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](v21);
      BOOL v23 = *(NSObject **)(v20 + 8);
      if (!v23) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](v21);
  BOOL v23 = *(NSObject **)(v20 + 8);
  if (!v23) {
LABEL_4:
  }
    _Unwind_Resume(a1);
LABEL_7:
  dispatch_release(v23);
  _Unwind_Resume(a1);
}

void support::transport::ARI::~ARI(support::transport::ARI *this)
{
  *(void *)this = &unk_1EFB0B698;
  if (*((void *)this + 3)) {
    KTLCloseChannel();
  }
  uint64_t v2 = (AriHost *)*((unsigned int *)this + 4);
  if (v2) {
    AriHost::DeregisterClient(v2);
  }
  *((void *)this + 4) = &unk_1EFB0B730;
  int v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    xpc_object_t v4 = (void *)*((void *)this + 3);
    *((void *)this + 3) = 0;
    if (!v4) {
      goto LABEL_12;
    }
  }
  else
  {
    xpc_object_t v4 = (void *)*((void *)this + 3);
    *((void *)this + 3) = 0;
    if (!v4) {
      goto LABEL_12;
    }
  }
  if (v4[1])
  {
    TelephonyUtilTransportFree();
    long long v5 = (void *)v4[1];
    if (v5) {
      operator delete(v5);
    }
  }
  operator delete(v4);
LABEL_12:
  char v6 = *((void *)this + 1);
  if (v6) {
    dispatch_release(v6);
  }
}

{
  void *v1;
  uint64_t vars8;

  support::transport::ARI::~ARI(this);

  operator delete(v1);
}

support::transport::ARI *support::transport::AriRT::AriRT(support::transport::AriRT *this, const support::log::manager *a2)
{
  uint64_t result = support::transport::ARI::ARI(this, a2);
  *(void *)uint64_t result = &unk_1EFB0B6B8;
  return result;
}

{
  support::transport::ARI *result;

  uint64_t result = support::transport::ARI::ARI(this, a2);
  *(void *)uint64_t result = &unk_1EFB0B6B8;
  return result;
}

void support::transport::AriRT::create(support::transport::AriRT *this@<X0>, dispatch_queue_s *a2@<X1>, const support::log::manager *a3@<X3>, support::transport::ARI **a4@<X8>)
{
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v25 = v9;
  long long v26 = v9;
  v24[2] = v9;
  v24[0] = v9;
  v24[1] = v9;
  int v22 = operator new(0x30uLL);
  long long v23 = xmmword_1A61F8C20;
  strcpy((char *)v22, "com.apple.telephony.basebandservices.support");
  char v21 = 13;
  strcpy((char *)__p, "ari.rt.create");
  support::log::client::client(v24, (uint64_t)&v22, (uint64_t)__p, (uint64_t)a3);
  if (v21 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v23) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v22);
LABEL_3:
  *a4 = (support::transport::ARI *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = (support::transport::ARI *)operator new(0x70uLL);
  support::transport::ARI::ARI(v10, a3);
  *(void *)uint64_t v10 = &unk_1EFB0B6B8;
  *a4 = v10;
  if (support::transport::ARI::initRT(v10, (char *)this, a2))
  {
    *(void *)&v24[0] = &unk_1EFB0B730;
    long long v11 = (std::__shared_weak_count *)v26;
    if (!(void)v26) {
      return;
    }
    goto LABEL_5;
  }
  char v19 = 1;
  int v12 = (support::log::manager *)*((void *)&v26 + 1);
  uint64_t v13 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v26 + 1) + 16))(*((void *)&v26 + 1), 1, *(void *)v25);
  if (v13)
  {
    if (*((void *)v12 + 17))
    {
      support::log::buffer::borrow(v13);
      int v14 = 2;
    }
    else
    {
      int v14 = 0;
    }
    if (v14 | os_log_type_enabled(*(os_log_t *)v25, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18[0]) = 0;
      uint64_t v15 = _os_log_send_and_compose_impl();
      if (v15)
      {
        dispatch_queue_t v16 = (char *)v15;
        std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
        v18[0] = &unk_1EFB0B700;
        v18[1] = (char *)v24 + 8;
        v18[2] = &v19;
        v18[3] = &rep;
        support::log::manager::message_delegates(v12, (const support::log::details *)v18, v16);
      }
    }
  }
  *a4 = 0;
  (*(void (**)(support::transport::ARI *))(*(void *)v10 + 8))(v10);
  *(void *)&v24[0] = &unk_1EFB0B730;
  long long v11 = (std::__shared_weak_count *)v26;
  if ((void)v26)
  {
LABEL_5:
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1A6128C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  void *v17 = 0;
  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  support::log::client::~client((support::log::client *)va);
  _Unwind_Resume(a1);
}

void sub_1A6128C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0)
  {
    operator delete(a25);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A6128C70);
}

void support::transport::AriRT::create(support::transport::AriRT *this@<X0>, const support::log::manager *a2@<X1>, support::transport::ARI **a3@<X8>)
{
}

void support::transport::AriRT::~AriRT(support::transport::AriRT *this)
{
  support::transport::ARI::~ARI(this);

  operator delete(v1);
}

void support::log::client::~client(std::__shared_weak_count **this)
{
  uint64_t v1 = (support::log::client *)this;
  *this = (std::__shared_weak_count *)&unk_1EFB0B730;
  uint64_t v2 = this[8];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    this = (std::__shared_weak_count **)v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  operator delete(this);
}

uint64_t __cxx_global_var_init_1()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t *GetOsLogContext(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE908, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EE908))
  {
    qword_1EB5EE928 = 0;
    qword_1EB5EE920 = 0;
    __cxa_atexit(MEMORY[0x1E4FBA188], &qword_1EB5EE920, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EE908);
  }
  if (_MergedGlobals_9 != -1) {
    dispatch_once(&_MergedGlobals_9, &__block_literal_global_1);
  }
  return &qword_1EB5EE920;
}

void ___Z15GetOsLogContextv_block_invoke()
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v0, "com.apple.telephony.abm", "global");
  ctu::OsLogContext::operator=();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v0);
}

void *GetGlobalLogger(void *a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE918, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EE918))
  {
    MEMORY[0x1A62747C0](&unk_1EB5EE930);
    __cxa_atexit(MEMORY[0x1E4FBA190], &unk_1EB5EE930, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EE918);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 1174405120;
  v5[2] = ___Z15GetGlobalLoggerNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  v5[3] = &__block_descriptor_tmp_3_0;
  uint64_t v2 = (std::__shared_weak_count *)a1[1];
  v5[4] = *a1;
  char v6 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (qword_1EB5EE910 == -1)
  {
    int v3 = v6;
    if (!v6) {
      return &unk_1EB5EE930;
    }
  }
  else
  {
    dispatch_once(&qword_1EB5EE910, v5);
    int v3 = v6;
    if (!v6) {
      return &unk_1EB5EE930;
    }
  }
  if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return &unk_1EB5EE930;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return &unk_1EB5EE930;
}

void sub_1A6129050(_Unwind_Exception *a1)
{
}

void ___Z15GetGlobalLoggerNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE908, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EE908))
  {
    qword_1EB5EE928 = 0;
    qword_1EB5EE920 = 0;
    __cxa_atexit(MEMORY[0x1E4FBA188], &qword_1EB5EE920, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EE908);
  }
  if (_MergedGlobals_9 != -1) {
    dispatch_once(&_MergedGlobals_9, &__block_literal_global_1);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v5, (const ctu::OsLogContext *)&qword_1EB5EE920);
  MEMORY[0x1A62747B0](v6, v5, a1 + 32);
  ctu::LoggerCommonBase::operator=();
  uint64_t v3 = v7;
  uint64_t v2 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v4 = (std::__shared_weak_count *)qword_1EB5EE968;
  qword_1EB5EE960 = v3;
  qword_1EB5EE968 = v2;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  MEMORY[0x1A62747D0](v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v5);
}

void sub_1A61291B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3ctu9LogServerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3ctu9LogServerEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ResetDetection::create(NSObject **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0xAAAAAAAAAAAAAAAALL;
  a4[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = operator new(0xB8uLL);
  long long v9 = *a1;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v12 = *a2;
  uint64_t v13 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ResetDetection::ResetDetection((uint64_t)v8, &object, &v12, a3);
  *a4 = 0xAAAAAAAAAAAAAAAALL;
  a4[1] = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<ResetDetection>::shared_ptr[abi:ne180100]<ResetDetection,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1},void>(a4, (uint64_t)v8);
  ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*a4);
  long long v11 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (object) {
    dispatch_release(object);
  }
}

void sub_1A6129374(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v3);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  if (v2) {
    dispatch_release(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t ResetDetection::ResetDetection(uint64_t a1, NSObject **a2, void *a3, uint64_t a4)
{
  *(void *)a1 = &unk_1EFB0B7B0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v10, "com.apple.telephony.abm", "reset.detect");
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v8 = *a2;
  *(void *)(a1 + 88) = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 96) = 0;
  ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>&>((void *)a1, (uint64_t)v10, a3);
  *(void *)a1 = &unk_1EFB0B970;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v10);
  *(void *)a1 = &unk_1EFB0B7B0;
  *(void *)(a1 + 104) = a4;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = TelephonyBasebandCreateController();
  *(_DWORD *)(a1 + 128) = 2;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = a1 + 144;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  return a1;
}

void sub_1A61294D4(_Unwind_Exception *a1)
{
  ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v1);
  _Unwind_Resume(a1);
}

void sub_1A61294E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

const char *ResetDetection::getName(ResetDetection *this)
{
  return "reset.detect";
}

void *ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  xpc_object_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  xpc_object_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void ResetDetection::~ResetDetection(ResetDetection *this)
{
  *(void *)this = &unk_1EFB0B7B0;
  uint64_t v2 = (const void *)*((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (__CFRunLoop *)*((void *)this + 13);
  uint64_t v4 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  long long v5 = (const void *)*MEMORY[0x1E4F1D418];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN14ResetDetectionD2Ev_block_invoke;
  block[3] = &__block_descriptor_tmp_6;
  block[4] = v4;
  CFRunLoopPerformBlock(v3, v5, block);
  CFRunLoopWakeUp(*((CFRunLoopRef *)this + 13));
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((char **)this + 21));
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((char **)this + 18));
  char v6 = (const void *)*((void *)this + 15);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)this = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710]((char *)this + 8);
  uint64_t v7 = *((void *)this + 12);
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = *((void *)this + 11);
  if (v8) {
    dispatch_release(v8);
  }
  long long v9 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

{
  void *v1;
  uint64_t vars8;

  ResetDetection::~ResetDetection(this);

  operator delete(v1);
}

void ___ZN14ResetDetectionD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[1];
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(v1);
  }
}

void ResetDetection::start(ResetDetection *this)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 0x40000000;
  v1[2] = ___ZN14ResetDetection5startEv_block_invoke;
  v1[3] = &__block_descriptor_tmp_3;
  v1[4] = this;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v1);
}

void ___ZN14ResetDetection5startEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Started", buf, 2u);
  }
  uint64_t v3 = operator new(0x10uLL);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 80);
  if (!v4 || (uint64_t v5 = *(void *)(v1 + 72), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  void *v3 = v5;
  v3[1] = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(v1 + 112) = v3;
  if (atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (TelephonyBasebandRegisterForReset()) {
      goto LABEL_10;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
    if (TelephonyBasebandRegisterForReset()) {
      goto LABEL_10;
    }
  }
  uint64_t v8 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "failed registering for reset detect", v12, 2u);
    if (*(void *)(v1 + 120)) {
      long long v11 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
    }
    else {
      long long v11 = 0;
    }
    if (v11) {
      goto LABEL_14;
    }
    return;
  }
LABEL_10:
  if (*(void *)(v1 + 120)) {
    long long v9 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  }
  else {
    long long v9 = 0;
  }
  if (v9)
  {
LABEL_14:
    unsigned __int8 v15 = 1;
    if (TelephonyBasebandGetReset())
    {
      *(_DWORD *)(v1 + 128) = v15;
    }
    else
    {
      uint64_t v10 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v14 = 0;
        _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "failed to poll for reset detect", v14, 2u);
      }
    }
  }
}

void sub_1A61299B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ResetDetection::sResetDetectCallback(ResetDetection *this, void *a2, int a3, unsigned int a4, void *a5)
{
  if (this)
  {
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v5)
    {
      uint64_t v7 = *(void *)this;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v8 = std::__shared_weak_count::lock(v5);
      if (v8)
      {
        long long v9 = v8;
        if (v7)
        {
          v10[0] = MEMORY[0x1E4F143A8];
          v10[1] = 0x40000000;
          uint64_t v10[2] = ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke;
          v10[3] = &__block_descriptor_tmp_6;
          v10[4] = v7;
          int v11 = a3;
          ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)(v7 + 72), (uint64_t)v10);
        }
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t ResetDetection::poll(ResetDetection *this, BOOL *a2)
{
  if (*((void *)this + 15)) {
    uint64_t v3 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3) {
    return 0;
  }
  BOOL v9 = 1;
  uint64_t Reset = TelephonyBasebandGetReset();
  if (Reset)
  {
    *a2 = v9;
    return Reset;
  }
  uint64_t v7 = *((void *)this + 5);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
    return Reset;
  }
  *(_WORD *)uint64_t v8 = 0;
  _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "failed to poll for reset detect", v8, 2u);
  return Reset;
}

void ResetDetection::add(uint64_t a1, uint64_t a2, char a3, void **a4, uint64_t a5)
{
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1174405120;
  uint64_t v10[2] = ___ZN14ResetDetection3addENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEbN8dispatch5blockIU13block_pointerFviEEEy_block_invoke;
  v10[3] = &__block_descriptor_tmp_4_0;
  v10[4] = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    char v14 = a3;
    BOOL v9 = *a4;
    if (!*a4) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  std::string __p = *(std::string *)a2;
  char v14 = a3;
  BOOL v9 = *a4;
  if (*a4) {
LABEL_5:
  }
    BOOL v9 = _Block_copy(v9);
LABEL_6:
  aBlocuint64_t k = v9;
  uint64_t v13 = a5;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v10);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void ___ZN14ResetDetection3addENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEbN8dispatch5blockIU13block_pointerFviEEEy_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    int v5 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)stat buf = 136315394;
    long long v25 = v4;
    __int16 v26 = 1024;
    int v27 = v5;
    _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Added detection with key '%s', reset=%d", buf, 0x12u);
  }
  int v6 = *(_DWORD *)(v2 + 128);
  int v7 = *(unsigned __int8 *)(a1 + 80);
  if (v6)
  {
    if (v6 != 2)
    {
      BOOL v8 = v6 != 1 || v7 == 0;
      BOOL v9 = !v8;
      BOOL v10 = v6 | v7 || v6 == 1;
      BOOL v11 = !v10 && v7 == 0;
      if (v11 || v9) {
        goto LABEL_28;
      }
    }
  }
  else if (!*(unsigned char *)(a1 + 80))
  {
LABEL_28:
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    return;
  }
  uint64_t v13 = (_OWORD *)(a1 + 40);
  int v14 = *(char *)(a1 + 63);
  if (*(unsigned char *)(a1 + 80))
  {
    if (v14 < 0)
    {
      std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *v13;
      v23.__r_.__value_.__r.__words[2] = *(void *)(a1 + 56);
    }
    unsigned __int8 v15 = *(const void **)(a1 + 64);
    if (v15) {
      dispatch_queue_t v16 = _Block_copy(v15);
    }
    else {
      dispatch_queue_t v16 = 0;
    }
    int v22 = v16;
    ResetDetection::addToBlocks_sync(v2, (uint64_t)&v23, &v22, (uint64_t **)(v2 + 136), *(void *)(a1 + 72));
    if (v16) {
      _Block_release(v16);
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      xpc_object_t v17 = (void *)v23.__r_.__value_.__r.__words[0];
LABEL_47:
      operator delete(v17);
    }
  }
  else
  {
    if (v14 < 0)
    {
      std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *v13;
      v21.__r_.__value_.__r.__words[2] = *(void *)(a1 + 56);
    }
    uint64_t v18 = *(const void **)(a1 + 64);
    if (v18) {
      char v19 = _Block_copy(v18);
    }
    else {
      char v19 = 0;
    }
    uint64_t v20 = v19;
    ResetDetection::addToBlocks_sync(v2, (uint64_t)&v21, &v20, (uint64_t **)(v2 + 160), *(void *)(a1 + 72));
    if (v19) {
      _Block_release(v19);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      xpc_object_t v17 = (void *)v21.__r_.__value_.__r.__words[0];
      goto LABEL_47;
    }
  }
}

void sub_1A6129EF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void ResetDetection::addToBlocks_sync(uint64_t a1, uint64_t a2, void **a3, uint64_t **a4, dispatch_time_t a5)
{
  BOOL v10 = dispatch_source_create(MEMORY[0x1E4F14490], 1uLL, 0, *(dispatch_queue_t *)(a1 + 88));
  dispatch_source_set_timer(v10, a5, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  BOOL v11 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v11 || (uint64_t v12 = *(void *)(a1 + 72), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v14 = v13;
  p_shared_weak_owners = &v13->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v14);
  }
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 1174405120;
  handler[2] = ___ZN14ResetDetection16addToBlocks_syncENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN8dispatch5blockIU13block_pointerFviEEERNS0_3mapIS6_NS0_4pairIP17dispatch_source_sSB_EENS0_4lessIS6_EENS4_INSD_IKS6_SG_EEEEEEy_block_invoke;
  handler[3] = &__block_descriptor_tmp_5_3;
  handler[4] = a1;
  handler[5] = v12;
  long long v39 = v14;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  uint64_t v40 = a4;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  dispatch_source_set_event_handler(v10, handler);
  dispatch_activate(v10);
  dispatch_queue_t v16 = *a3;
  if (*a3) {
    dispatch_queue_t v16 = _Block_copy(v16);
  }
  int v37 = (uint64_t *)v16;
  uint64_t v18 = a4 + 1;
  xpc_object_t v17 = a4[1];
  if (v17)
  {
    int v19 = *(char *)(a2 + 23);
    if (v19 >= 0) {
      uint64_t v20 = (const std::string::value_type *)a2;
    }
    else {
      uint64_t v20 = *(const std::string::value_type **)a2;
    }
    if (v19 >= 0) {
      size_t v21 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      size_t v21 = *(void *)(a2 + 8);
    }
    while (1)
    {
      int v22 = (uint64_t **)v17;
      long long v25 = (const void *)v17[4];
      std::string v23 = v17 + 4;
      int v24 = v25;
      int v26 = *((char *)v23 + 23);
      if (v26 >= 0) {
        int v27 = v23;
      }
      else {
        int v27 = v24;
      }
      if (v26 >= 0) {
        size_t v28 = *((unsigned __int8 *)v23 + 23);
      }
      else {
        size_t v28 = v23[1];
      }
      if (v28 >= v21) {
        size_t v29 = v21;
      }
      else {
        size_t v29 = v28;
      }
      int v30 = memcmp(v20, v27, v29);
      if (v30)
      {
        if (v30 < 0) {
          goto LABEL_17;
        }
LABEL_31:
        int v31 = memcmp(v27, v20, v29);
        if (v31)
        {
          if ((v31 & 0x80000000) == 0) {
            goto LABEL_45;
          }
        }
        else if (v28 >= v21)
        {
LABEL_45:
          long long v36 = v22[8];
          v22[7] = (uint64_t *)v10;
          v22[8] = v37;
          if (v36) {
            goto LABEL_46;
          }
          goto LABEL_47;
        }
        xpc_object_t v17 = v22[1];
        if (!v17)
        {
          uint64_t v18 = v22 + 1;
          goto LABEL_38;
        }
      }
      else
      {
        if (v21 >= v28) {
          goto LABEL_31;
        }
LABEL_17:
        xpc_object_t v17 = *v22;
        uint64_t v18 = v22;
        if (!*v22) {
          goto LABEL_38;
        }
      }
    }
  }
  int v22 = a4 + 1;
LABEL_38:
  char v32 = operator new(0x48uLL);
  uint64_t v33 = (std::string *)(v32 + 4);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v33, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v33->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v32[6] = *(void *)(a2 + 16);
  }
  v32[7] = 0;
  v32[8] = 0;
  *char v32 = 0;
  v32[1] = 0;
  v32[2] = v22;
  *uint64_t v18 = v32;
  char v34 = (uint64_t *)**a4;
  int v35 = v32;
  if (v34)
  {
    *a4 = v34;
    int v35 = *v18;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a4[1], v35);
  a4[2] = (uint64_t *)((char *)a4[2] + 1);
  long long v36 = (uint64_t *)v32[8];
  v32[7] = v10;
  v32[8] = v37;
  if (v36) {
LABEL_46:
  }
    _Block_release(v36);
LABEL_47:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v39) {
    std::__shared_weak_count::__release_weak(v39);
  }
  std::__shared_weak_count::__release_weak(v14);
}

void sub_1A612A29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  operator delete(v26);
  std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>::~pair((uint64_t)&a10);
  if (a25 < 0)
  {
    operator delete(__p);
    size_t v28 = a18;
    if (a18) {
      goto LABEL_3;
    }
  }
  else
  {
    size_t v28 = a18;
    if (a18)
    {
LABEL_3:
      std::__shared_weak_count::__release_weak(v28);
      std::__shared_weak_count::__release_weak(v25);
      _Unwind_Resume(a1);
    }
  }
  std::__shared_weak_count::__release_weak(v25);
  _Unwind_Resume(a1);
}

void *__copy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE64c43_ZTSN8dispatch5blockIU13block_pointerFviEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::string *)(a1 + 40);
  if ((*(char *)(a2 + 63) & 0x80000000) == 0)
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    v4->__r_.__value_.__r.__words[2] = *(void *)(a2 + 56);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
    uint64_t result = *(void **)(a2 + 64);
    if (!result) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
  uint64_t result = *(void **)(a2 + 64);
  if (result) {
LABEL_5:
  }
    uint64_t result = _Block_copy(result);
LABEL_6:
  *(void *)(a1 + 64) = result;
  return result;
}

void __destroy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE64c43_ZTSN8dispatch5blockIU13block_pointerFviEEE(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 64);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    operator delete(v3);
  }
}

void ___ZN14ResetDetection16addToBlocks_syncENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN8dispatch5blockIU13block_pointerFviEEERNS0_3mapIS6_NS0_4pairIP17dispatch_source_sSB_EENS0_4lessIS6_EENS4_INSD_IKS6_SG_EEEEEEy_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  long long v5 = v4;
  if (!*(void *)(a1 + 40)) {
    goto LABEL_54;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v9 = *(uint64_t ***)(v6 + 8);
  int v7 = (uint64_t *)(v6 + 8);
  BOOL v8 = v9;
  if (!v9) {
    goto LABEL_54;
  }
  int v10 = *(char *)(a1 + 87);
  if (v10 >= 0) {
    BOOL v11 = (const void *)(a1 + 64);
  }
  else {
    BOOL v11 = *(const void **)(a1 + 64);
  }
  if (v10 >= 0) {
    size_t v12 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    size_t v12 = *(void *)(a1 + 72);
  }
  uint64_t v13 = v7;
  do
  {
    while (1)
    {
      int v14 = *((char *)v8 + 55);
      unsigned __int8 v15 = v14 >= 0 ? (uint64_t *)(v8 + 4) : v8[4];
      size_t v16 = v14 >= 0 ? *((unsigned __int8 *)v8 + 55) : (size_t)v8[5];
      size_t v17 = v12 >= v16 ? v16 : v12;
      int v18 = memcmp(v15, v11, v17);
      if (v18) {
        break;
      }
      if (v16 >= v12) {
        goto LABEL_26;
      }
LABEL_12:
      BOOL v8 = (uint64_t **)v8[1];
      if (!v8) {
        goto LABEL_27;
      }
    }
    if (v18 < 0) {
      goto LABEL_12;
    }
LABEL_26:
    uint64_t v13 = (uint64_t *)v8;
    BOOL v8 = (uint64_t **)*v8;
  }
  while (v8);
LABEL_27:
  if (v13 != v7)
  {
    int v19 = *((char *)v13 + 55);
    if (v19 >= 0) {
      uint64_t v20 = v13 + 4;
    }
    else {
      uint64_t v20 = (const void *)v13[4];
    }
    if (v19 >= 0) {
      size_t v21 = *((unsigned __int8 *)v13 + 55);
    }
    else {
      size_t v21 = v13[5];
    }
    if (v21 >= v12) {
      size_t v22 = v12;
    }
    else {
      size_t v22 = v21;
    }
    int v23 = memcmp(v11, v20, v22);
    if (v23)
    {
      if (v23 < 0) {
        goto LABEL_54;
      }
LABEL_41:
      ResetDetection::invokeBlock_sync(v3, (uint64_t)(v13 + 4), 3760250883);
      int v24 = *(uint64_t ***)(a1 + 56);
      long long v25 = (uint64_t *)v13[1];
      if (v25)
      {
        do
        {
          int v26 = v25;
          long long v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        int v27 = v13;
        do
        {
          int v26 = (uint64_t *)v27[2];
          BOOL v28 = *v26 == (void)v27;
          int v27 = v26;
        }
        while (!v28);
      }
      if (*v24 == v13) {
        const void *v24 = v26;
      }
      size_t v29 = v24[1];
      v24[2] = (uint64_t *)((char *)v24[2] - 1);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v29, v13);
      int v30 = (const void *)v13[8];
      if (v30) {
        _Block_release(v30);
      }
      if (*((char *)v13 + 55) < 0) {
        operator delete((void *)v13[4]);
      }
      operator delete(v13);
    }
    else if (v12 >= v21)
    {
      goto LABEL_41;
    }
  }
LABEL_54:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_1A612A624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ResetDetection::invokeBlock_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(&__p, 170, sizeof(__p));
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  int v7 = *(NSObject **)(a2 + 24);
  uint64_t v6 = *(const void **)(a2 + 32);
  if (v6)
  {
    BOOL v8 = (void (**)(void *, void))_Block_copy(v6);
    *(void *)(a2 + 24) = 0;
    if (!v7) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  BOOL v8 = 0;
  *(void *)(a2 + 24) = 0;
  if (v7)
  {
LABEL_6:
    dispatch_source_cancel(v7);
    dispatch_release(v7);
  }
LABEL_7:
  BOOL v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)stat buf = 136315138;
    uint64_t v13 = p_p;
    _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Signalling %s", buf, 0xCu);
  }
  v8[2](v8, a3);
  _Block_release(v8);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1A612A79C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14ResetDetectionEE64c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (std::string *)(a1 + 8);
  if (*(char *)(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 64);
    a1[10] = *(void *)(a2 + 80);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }
}

void sub_1A612A850(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14ResetDetectionEE64c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0)
  {
    operator delete(*(void **)(a1 + 64));
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v2) {
      return;
    }
  }
  else
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
    if (!v2) {
      return;
    }
  }

  std::__shared_weak_count::__release_weak(v2);
}

uint64_t std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void ResetDetection::notifyResetDetectBlocks_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = &v15;
  uint64_t v4 = *(char **)(a2 + 8);
  unsigned __int8 v15 = *(void **)a2;
  v16[0] = v4;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  v16[1] = v5;
  if (v5) {
    uint64_t v3 = v4 + 16;
  }
  void *v3 = v16;
  *(void *)a2 = a2 + 8;
  uint64_t v6 = v15;
  if (v15 != v16)
  {
    while (1)
    {
      aBlocuint64_t k = (void *)0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)std::string __p = v7;
      long long v13 = v7;
      if (*((char *)v6 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)__p, (const std::string::value_type *)v6[4], v6[5]);
      }
      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)v6 + 2);
        *(void *)&long long v13 = v6[6];
      }
      BOOL v8 = (void *)v6[8];
      *((void *)&v13 + 1) = v6[7];
      if (v8) {
        BOOL v8 = _Block_copy(v8);
      }
      aBlocuint64_t k = v8;
      ResetDetection::invokeBlock_sync(a1, (uint64_t)__p, 0);
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (SBYTE7(v13) < 0)
      {
        operator delete(__p[0]);
        BOOL v9 = (void *)v6[1];
        if (v9)
        {
          do
          {
LABEL_17:
            int v10 = v9;
            BOOL v9 = (void *)*v9;
          }
          while (v9);
          goto LABEL_5;
        }
      }
      else
      {
        BOOL v9 = (void *)v6[1];
        if (v9) {
          goto LABEL_17;
        }
      }
      do
      {
        int v10 = (void *)v6[2];
        BOOL v11 = *v10 == (void)v6;
        uint64_t v6 = v10;
      }
      while (!v11);
LABEL_5:
      uint64_t v6 = v10;
      if (v10 == v16)
      {
        uint64_t v4 = (char *)v16[0];
        break;
      }
    }
  }
  std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(v4);
}

void sub_1A612AA40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15)
{
}

void sub_1A612AA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15)
{
}

uint64_t std::pair<std::string const,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ResetDetection::resetDetectCallback(ResetDetection *this, void *a2, unsigned int a3, int a4, void *a5)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke;
  v5[3] = &__block_descriptor_tmp_6;
  v5[4] = this;
  int v6 = a4;
  ctu::SharedSynchronizable<ResetDetection>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v5);
}

void ___ZN14ResetDetection19resetDetectCallbackEPvjjS0__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 40);
  if (v2 == -469794815)
  {
    uint64_t v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(state.opaque[0]) = 0;
      _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I baseband alive detected", (uint8_t *)&state, 2u);
    }
    *(_DWORD *)(v1 + 128) = 0;
    ResetDetection::notifyResetDetectBlocks_sync(v1, v1 + 160);
  }
  else if (v2 == -469794816)
  {
    uint64_t v3 = _os_activity_create(&dword_1A609F000, "Baseband state: reset detected", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v3, &state);
    os_activity_scope_leave(&state);
    uint64_t v4 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(state.opaque[0]) = 0;
      _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I baseband reset detected", (uint8_t *)&state, 2u);
    }
    *(_DWORD *)(v1 + 128) = 1;
    ResetDetection::notifyResetDetectBlocks_sync(v1, v1 + 136);
    if (v3) {
      os_release(v3);
    }
  }
}

void sub_1A612AC98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::os::scoped_activity::~scoped_activity((void **)va);
  _Unwind_Resume(a1);
}

void ctu::os::scoped_activity::~scoped_activity(void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    os_release(v1);
  }
}

uint64_t ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig(uint64_t a1)
{
  return MEMORY[0x1F417DA50](a1 + 8);
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName(char *a1@<X8>)
{
  a1[23] = 12;
  strcpy(a1, "reset.detect");
}

uint64_t ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return MEMORY[0x1F417DD10](a1 + 8);
}

void *ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710](a1 + 1);
  return a1;
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710](a1 + 1);

  operator delete(a1);
}

void ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(uint64_t a1)
{
  uint64_t v1 = a1 + 56;
  if (*(void *)(a1 + 56))
  {
    if (!*(void *)(a1 + 80) || (int v2 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 80))) == 0) {
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
    uint64_t v3 = v2;
    ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v1 - 48));
    ctu::TrackedLogger::registerLoggerToServer();
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1A612AED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1A612AEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::shared_ptr<ResetDetection>::shared_ptr[abi:ne180100]<ResetDetection,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0B920;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2) {
    return a1;
  }
  int v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 72) = a2;
      *(void *)(a2 + 80) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(a2 + 72) = a2;
  *(void *)(a2 + 80) = v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A612B020(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1}::operator() const(ResetDetection*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A612B048(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<ResetDetection *,std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection *)#1},std::allocator<ResetDetection>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptr"
                                "IT_EEPS6_EUlPS1_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI14ResetDetectionE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<ResetDetection> ctu::SharedSynchronizable<ResetDetection>::make_shared_ptr<ResetDetection>(ResetDetection*)::{lambda(ResetDetection*)#1}::operator() const(ResetDetection*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *ctu::Loggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>&>(void *a1, uint64_t a2, void *a3)
{
  *a1 = &unk_1EFB0B8E0;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  a1[1] = &unk_1EFB08838;
  a1[7] = *a3;
  uint64_t v5 = a3[1];
  a1[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  return a1;
}

void sub_1A612B208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ctu::SharedLoggable<ResetDetection,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0B8E0;
  MEMORY[0x1A6274710](a1 + 1);
  int v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(a1);
}

void std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::pair<dispatch_source_s *,dispatch::block<void({block_pointer})(int)>>>>>::destroy(*((void *)a1 + 1));
    int v2 = (const void *)*((void *)a1 + 8);
    if (v2) {
      _Block_release(v2);
    }
    if (a1[55] < 0)
    {
      operator delete(*((void **)a1 + 4));
      unint64_t v3 = a1;
    }
    else
    {
      unint64_t v3 = a1;
    }
    operator delete(v3);
  }
}

void ctu::SharedSynchronizable<ResetDetection>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (uint64_t v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  BOOL v8 = a1[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI14ResetDetectionE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1EFB0B9A8;
  void block[5] = v5;
  size_t v12 = v7;
  p_shared_owners = &v7->__shared_owners_;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = a2;
  dispatch_async(v8, block);
  int v10 = v12;
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
LABEL_8:
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
  std::__shared_weak_count::__release_weak(v10);
  if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_8;
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI14ResetDetectionE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrIK14ResetDetectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrIK14ResetDetectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *diag::DIAGConfigurerPCI::DIAGConfigurerPCI(void *a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  uint64_t v22 = *a2;
  int v23 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v16 = *a3;
  BOOL v8 = (const void *)*((void *)a3 + 1);
  CFTypeRef cf = v8;
  if (v8) {
    CFRetain(v8);
  }
  BOOL v9 = (std::__shared_weak_count *)*((void *)a3 + 3);
  uint64_t v18 = *((void *)a3 + 2);
  int v19 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *((void *)a3 + 4);
  BOOL v11 = (std::__shared_weak_count *)*((void *)a3 + 5);
  uint64_t v20 = v10;
  size_t v21 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  diag::DIAGConfigurer::DIAGConfigurer((uint64_t)a1, &v22, (uint64_t)&v16, a4);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  size_t v12 = v19;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    CFTypeRef v13 = cf;
    if (!cf) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  CFTypeRef v13 = cf;
  if (cf) {
LABEL_15:
  }
    CFRelease(v13);
LABEL_16:
  uint64_t v14 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  *a1 = &unk_1EFB0B9E8;
  a1[22] = 0;
  a1[23] = 0;
  return a1;
}

void sub_1A612B764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void diag::DIAGConfigurer::Parameters_t::~Parameters_t(diag::DIAGConfigurer::Parameters_t *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (const void *)*((void *)this + 1);
    if (!v4) {
      return;
    }
  }
  else
  {
    uint64_t v4 = (const void *)*((void *)this + 1);
    if (!v4) {
      return;
    }
  }
  CFRelease(v4);
}

void diag::DIAGConfigurerPCI::~DIAGConfigurerPCI(std::__shared_weak_count **this)
{
  uint64_t v1 = (diag::DIAGConfigurerPCI *)this;
  *this = (std::__shared_weak_count *)&unk_1EFB0B9E8;
  uint64_t v2 = this[23];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    this = (std::__shared_weak_count **)v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  diag::DIAGConfigurer::~DIAGConfigurer((diag::DIAGConfigurer *)this);
}

{
  diag::DIAGConfigurerPCI *v1;
  std::__shared_weak_count *v2;
  uint64_t vars8;

  uint64_t v1 = (diag::DIAGConfigurerPCI *)this;
  *this = (std::__shared_weak_count *)&unk_1EFB0B9E8;
  uint64_t v2 = this[23];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    this = (std::__shared_weak_count **)v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  diag::DIAGConfigurer::~DIAGConfigurer((diag::DIAGConfigurer *)this);
}

void diag::DIAGConfigurerPCI::~DIAGConfigurerPCI(diag::DIAGConfigurerPCI *this)
{
  *(void *)this = &unk_1EFB0B9E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  else
  {
    diag::DIAGConfigurer::~DIAGConfigurer(this);
  }
  operator delete(v3);
}

void diag::DIAGConfigurerPCI::reset(diag::DIAGConfigurerPCI *this)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  void v3[2] = ___ZN4diag17DIAGConfigurerPCI5resetEv_block_invoke;
  v3[3] = &__block_descriptor_tmp_7;
  v3[4] = this;
  uint64_t v4 = v3;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN4diag14DIAGConfigurerEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke_0;
  block[3] = &__block_descriptor_tmp_13_0;
  block[4] = (char *)this + 72;
  void block[5] = &v4;
  uint64_t v2 = (char *)this + 88;
  uint64_t v1 = *((void *)this + 11);
  if (*((void *)v2 + 1)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
}

void ___ZN4diag17DIAGConfigurerPCI5resetEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v3 = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting DIAG configuration", v3, 2u);
  }
  if ((*(_DWORD *)(v1 + 104) | 4) == 4) {
    BasebandTransport::close(*(BasebandTransport **)(v1 + 120));
  }
}

void diag::DIAGConfigurerPCI::starting(uint64_t a1, uint64_t a2)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI8startingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_3_1;
  v7[4] = a1;
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(v4);
  }
  uint64_t v5 = (uint64_t *)(a1 + 72);
  int v6 = *(NSObject **)(a2 + 8);
  aBlocuint64_t k = v4;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void ___ZN4diag17DIAGConfigurerPCI8startingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(capabilities::abs *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a1 + 4);
  if ((*(_DWORD *)(v2 + 104) | 4) == 4)
  {
    uint64_t v3 = *(void *)(v2 + 120);
    int v24 = 2;
    char v25 = 0;
    uint64_t v26 = 10;
    int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1);
    if (shouldUseMinBasebandTransportIOReadSize) {
      int v5 = 0x4000;
    }
    else {
      int v5 = 0x8000;
    }
    int v27 = v5;
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize)) {
      int v6 = 4;
    }
    else {
      int v6 = 16;
    }
    int v28 = v6;
    uint64_t v29 = 0;
    char v30 = 0;
    aBlocuint64_t k = 0;
    char v7 = (*(uint64_t (**)(uint64_t, int *, void **))(*(void *)v3 + 48))(v3, &v24, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v7)
    {
      LOBYTE(v8) = 1;
      goto LABEL_32;
    }
    CFTypeRef v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1A609F000, v13, OS_LOG_TYPE_ERROR, "Failed to opening transport.", buf, 2u);
    }
    BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
LABEL_31:
    LOBYTE(v8) = 0;
    goto LABEL_32;
  }
  BOOL v9 = *(SoftwareBypassShim **)(v2 + 176);
  if (!v9)
  {
    SoftwareBypassShim::create((std::__shared_weak_count **)buf);
    long long v14 = *(_OWORD *)buf;
    *(void *)stat buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    unsigned __int8 v15 = *(std::__shared_weak_count **)(v2 + 184);
    *(_OWORD *)(v2 + 176) = v14;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    int v16 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    BOOL v9 = *(SoftwareBypassShim **)(v2 + 176);
    if (*((void *)v9 + 2)) {
      goto LABEL_14;
    }
LABEL_29:
    size_t v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)stat buf = 0;
      _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, "Expected to use software bypass, but it is not supported", buf, 2u);
    }
    goto LABEL_31;
  }
  if (!*((void *)v9 + 2)) {
    goto LABEL_29;
  }
LABEL_14:
  if (*(unsigned char *)(*(void *)(v2 + 168) + 22)) {
    uint64_t v10 = 11;
  }
  else {
    uint64_t v10 = 13;
  }
  int v8 = SoftwareBypassShim::bypassCtl(v9, v10);
  BOOL v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    size_t v12 = SoftwareBypassShim::bypassInterfaceMaskAsString(*(SoftwareBypassShim **)(v2 + 176), v10);
    *(_DWORD *)stat buf = 136315394;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I bypassCtl( %s): success: %d", buf, 0x12u);
  }
LABEL_32:
  uint64_t v18 = (const void *)*((void *)a1 + 5);
  if (v18 && *((void *)a1 + 6))
  {
    int v19 = _Block_copy(v18);
    uint64_t v20 = v19;
    size_t v21 = *((void *)a1 + 6);
    *(void *)stat buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 1174405120;
    *(void *)&uint8_t buf[16] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    char v32 = &__block_descriptor_tmp_14_1;
    if (v19) {
      uint64_t v22 = _Block_copy(v19);
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v33 = v22;
    char v34 = v8;
    dispatch_async(v21, buf);
    if (v33) {
      _Block_release(v33);
    }
    if (v20) {
      _Block_release(v20);
    }
  }
}

void sub_1A612C024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_40c46_ZTSN8dispatch8callbackIU13block_pointerFvbEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 40);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  int v5 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v5;
  if (v5)
  {
    dispatch_retain(v5);
  }
}

void __destroy_helper_block_e8_40c46_ZTSN8dispatch8callbackIU13block_pointerFvbEEE(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    _Block_release(v3);
  }
}

void diag::DIAGConfigurerPCI::started(uint64_t a1, uint64_t a2)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI7startedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_6_3;
  v7[4] = a1;
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(v4);
  }
  int v5 = (uint64_t *)(a1 + 72);
  int v6 = *(NSObject **)(a2 + 8);
  aBlocuint64_t k = v4;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void ___ZN4diag17DIAGConfigurerPCI7startedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (*(_DWORD *)(v2 + 104) == 4)
  {
    char v3 = BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
    uint64_t v4 = (const void *)a1[5];
    if (!v4) {
      return;
    }
  }
  else
  {
    char v3 = 1;
    uint64_t v4 = (const void *)a1[5];
    if (!v4) {
      return;
    }
  }
  if (a1[6])
  {
    int v5 = _Block_copy(v4);
    int v6 = v5;
    char v7 = a1[6];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 1174405120;
    v9[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    v9[3] = &__block_descriptor_tmp_14_1;
    if (v5) {
      int v8 = _Block_copy(v5);
    }
    else {
      int v8 = 0;
    }
    aBlocuint64_t k = v8;
    char v11 = v3;
    dispatch_async(v7, v9);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v6) {
      _Block_release(v6);
    }
  }
}

void diag::DIAGConfigurerPCI::stopping(uint64_t a1, uint64_t a2)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI8stoppingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_9_3;
  v7[4] = a1;
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(v4);
  }
  int v5 = (uint64_t *)(a1 + 72);
  int v6 = *(NSObject **)(a2 + 8);
  aBlocuint64_t k = v4;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void ___ZN4diag17DIAGConfigurerPCI8stoppingEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(capabilities::abs *a1)
{
  uint64_t v2 = *((void *)a1 + 4);
  if ((*(_DWORD *)(v2 + 104) | 4) != 4)
  {
    char v7 = 1;
    int v8 = (const void *)*((void *)a1 + 5);
    if (!v8) {
      return;
    }
    goto LABEL_13;
  }
  uint64_t v3 = *(void *)(v2 + 120);
  int v14 = 2;
  char v15 = 0;
  uint64_t v16 = 10;
  int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1);
  if (shouldUseMinBasebandTransportIOReadSize) {
    int v5 = 0x4000;
  }
  else {
    int v5 = 0x8000;
  }
  int v17 = v5;
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize)) {
    int v6 = 4;
  }
  else {
    int v6 = 16;
  }
  int v18 = v6;
  uint64_t v19 = 0;
  char v20 = 0;
  aBlocuint64_t k = 0;
  char v7 = (*(uint64_t (**)(uint64_t, int *, void **))(*(void *)v3 + 48))(v3, &v14, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  int v8 = (const void *)*((void *)a1 + 5);
  if (v8)
  {
LABEL_13:
    if (*((void *)a1 + 6))
    {
      BOOL v9 = _Block_copy(v8);
      uint64_t v10 = v9;
      char v11 = *((void *)a1 + 6);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 1174405120;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
      block[3] = &__block_descriptor_tmp_14_1;
      if (v9) {
        size_t v12 = _Block_copy(v9);
      }
      else {
        size_t v12 = 0;
      }
      uint64_t v22 = v12;
      char v23 = v7;
      dispatch_async(v11, block);
      if (v22) {
        _Block_release(v22);
      }
      if (v10) {
        _Block_release(v10);
      }
    }
  }
}

void sub_1A612C534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void diag::DIAGConfigurerPCI::stopped(uint64_t a1, uint64_t a2)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 1174405120;
  v7[2] = ___ZN4diag17DIAGConfigurerPCI7stoppedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_12_2;
  v7[4] = a1;
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(v4);
  }
  int v5 = (uint64_t *)(a1 + 72);
  int v6 = *(NSObject **)(a2 + 8);
  aBlocuint64_t k = v4;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::execute_wrapped(v5, (uint64_t)v7);
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void ___ZN4diag17DIAGConfigurerPCI7stoppedEN8dispatch8callbackIU13block_pointerFvbEEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if ((*(_DWORD *)(v2 + 104) | 4) == 4)
  {
    char v3 = BasebandTransport::close(*(BasebandTransport **)(v2 + 120));
    uint64_t v4 = (const void *)a1[5];
    if (!v4) {
      return;
    }
  }
  else
  {
    char v3 = 1;
    uint64_t v4 = (const void *)a1[5];
    if (!v4) {
      return;
    }
  }
  if (a1[6])
  {
    int v5 = _Block_copy(v4);
    int v6 = v5;
    char v7 = a1[6];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 1174405120;
    v9[2] = ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0;
    v9[3] = &__block_descriptor_tmp_14_1;
    if (v5) {
      int v8 = _Block_copy(v5);
    }
    else {
      int v8 = 0;
    }
    aBlocuint64_t k = v8;
    char v11 = v3;
    dispatch_async(v7, v9);
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v6) {
      _Block_release(v6);
    }
  }
}

void *___ZNK3ctu20SharedSynchronizableIN4diag14DIAGConfigurerEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke_0(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t ___ZNK8dispatch8callbackIU13block_pointerFvbEEclIJbEEEvDpT__block_invoke_0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t _GLOBAL__sub_I_DIAGConfigurerPCI_cpp()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  dword_1EB5EE974 = result;
  return result;
}

_DWORD *BasebandTransport::getSupportedProtocols@<X0>(BasebandTransport *this@<X0>, void *a2@<X8>)
{
  *a2 = a2;
  a2[1] = a2;
  a2[2] = 0;
  uint64_t result = (_DWORD *)capabilities::radio::vendor(this);
  if (result == 1)
  {
    CFTypeRef v13 = operator new(0x18uLL);
    v13[4] = 0;
    *(void *)CFTypeRef v13 = &v33;
    *((void *)v13 + 1) = &v33;
    char v34 = v13;
    int v14 = operator new(0x18uLL);
    v14[4] = 1;
    *(void *)int v14 = v13;
    *((void *)v14 + 1) = &v33;
    *((void *)v13 + 1) = v14;
    char v15 = operator new(0x18uLL);
    v15[4] = 2;
    *(void *)char v15 = v14;
    *((void *)v15 + 1) = &v33;
    *((void *)v14 + 1) = v15;
    uint64_t v16 = operator new(0x18uLL);
    v16[4] = 3;
    *(void *)uint64_t v16 = v15;
    *((void *)v16 + 1) = &v33;
    *((void *)v15 + 1) = v16;
    int v17 = operator new(0x18uLL);
    v17[4] = 4;
    *(void *)int v17 = v16;
    *((void *)v17 + 1) = &v33;
    *((void *)v16 + 1) = v17;
    int v18 = operator new(0x18uLL);
    v18[4] = 5;
    *(void *)int v18 = v17;
    *((void *)v18 + 1) = &v33;
    *((void *)v17 + 1) = v18;
    uint64_t v19 = operator new(0x18uLL);
    v19[4] = 10;
    *(void *)uint64_t v19 = v18;
    *((void *)v19 + 1) = &v33;
    *((void *)v18 + 1) = v19;
    char v20 = operator new(0x18uLL);
    v20[4] = 12;
    *(void *)char v20 = v19;
    *((void *)v20 + 1) = &v33;
    *((void *)v19 + 1) = v20;
    size_t v21 = operator new(0x18uLL);
    v21[4] = 14;
    *(void *)size_t v21 = v20;
    *((void *)v21 + 1) = &v33;
    *((void *)v20 + 1) = v21;
    uint64_t v33 = v21;
    uint64_t v35 = 9;
    uint64_t result = (_DWORD *)capabilities::radio::mav20Plus((capabilities::radio *)v21);
    if (result)
    {
      uint64_t v22 = operator new(0x18uLL);
      v22[4] = 11;
      char v23 = v33;
      *(void *)uint64_t v22 = v33;
      *((void *)v22 + 1) = &v33;
      v23[1] = v22;
      uint64_t v24 = v35;
      uint64_t v33 = v22;
      ++v35;
      uint64_t result = operator new(0x18uLL);
      result[4] = 15;
      *(void *)uint64_t result = v22;
      *((void *)result + 1) = &v33;
      *((void *)v22 + 1) = result;
      uint64_t v33 = result;
      uint64_t v35 = v24 + 2;
    }
    if (a2[2])
    {
      uint64_t v25 = *a2;
      uint64_t result = (_DWORD *)a2[1];
      uint64_t v26 = *(void *)result;
      *(void *)(v26 + 8) = *(void *)(*a2 + 8);
      **(void **)(v25 + 8) = v26;
      a2[2] = 0;
      if (result != (_DWORD *)a2)
      {
        do
        {
          int v27 = (void *)*((void *)result + 1);
          operator delete(result);
          uint64_t result = v27;
        }
        while (v27 != a2);
      }
    }
  }
  else
  {
    if (result != 2) {
      return result;
    }
    uint64_t v4 = operator new(0x18uLL);
    v4[4] = 6;
    *(void *)uint64_t v4 = &v33;
    *((void *)v4 + 1) = &v33;
    char v34 = v4;
    int v5 = operator new(0x18uLL);
    v5[4] = 7;
    *(void *)int v5 = v4;
    *((void *)v5 + 1) = &v33;
    *((void *)v4 + 1) = v5;
    int v6 = operator new(0x18uLL);
    v6[4] = 8;
    *(void *)int v6 = v5;
    *((void *)v6 + 1) = &v33;
    *((void *)v5 + 1) = v6;
    char v7 = operator new(0x18uLL);
    v7[4] = 9;
    *(void *)char v7 = v6;
    *((void *)v7 + 1) = &v33;
    *((void *)v6 + 1) = v7;
    int v8 = operator new(0x18uLL);
    v8[4] = 10;
    *(void *)int v8 = v7;
    *((void *)v8 + 1) = &v33;
    *((void *)v7 + 1) = v8;
    uint64_t v33 = v8;
    uint64_t v35 = 5;
    uint64_t result = (_DWORD *)capabilities::abs::supportsETSProtocol((capabilities::abs *)v8);
    if (result)
    {
      uint64_t result = operator new(0x18uLL);
      result[4] = 13;
      BOOL v9 = v33;
      *(void *)uint64_t result = v33;
      *((void *)result + 1) = &v33;
      v9[1] = result;
      uint64_t v33 = result;
      ++v35;
    }
    if (a2[2])
    {
      uint64_t v10 = *a2;
      uint64_t result = (_DWORD *)a2[1];
      uint64_t v11 = *(void *)result;
      *(void *)(v11 + 8) = *(void *)(*a2 + 8);
      **(void **)(v10 + 8) = v11;
      a2[2] = 0;
      if (result != (_DWORD *)a2)
      {
        do
        {
          size_t v12 = (void *)*((void *)result + 1);
          operator delete(result);
          uint64_t result = v12;
        }
        while (v12 != a2);
      }
    }
  }
  uint64_t v28 = v35;
  if (v35)
  {
    char v30 = v33;
    uint64_t v29 = v34;
    uint64_t v31 = *v34;
    *(void *)(v31 + 8) = v33[1];
    *(void *)v30[1] = v31;
    uint64_t v32 = *a2;
    *(void *)(v32 + 8) = v29;
    *uint64_t v29 = v32;
    *a2 = v30;
    v30[1] = a2;
    a2[2] += v28;
  }
  return result;
}

void sub_1A612CAD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::list<BasebandTransport::Protocol>::~list((uint64_t *)va);
  std::list<BasebandTransport::Protocol>::~list(v2);
  _Unwind_Resume(a1);
}

void sub_1A612CB04(_Unwind_Exception *a1)
{
  std::list<BasebandTransport::Protocol>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A612CB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  do
  {
    uint64_t v16 = (void *)v13[1];
    operator delete(v13);
    CFTypeRef v13 = v16;
  }
  while (v16 != v14);
  std::list<BasebandTransport::Protocol>::~list(v12);
  _Unwind_Resume(a1);
}

uint64_t *std::list<BasebandTransport::Protocol>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        int v5 = (uint64_t *)v2[1];
        operator delete(v2);
        uint64_t v2 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void BasebandTransport::getSupportedProtocolsAsStringLowerCase(BasebandTransport *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = (uint64_t)a2;
  a2[1] = (uint64_t)a2;
  a2[2] = 0;
  memset(v20, 170, sizeof(v20));
  BasebandTransport::getSupportedProtocols(this, v20);
  for (uint64_t i = v20[1]; (void *)i != v20; uint64_t i = *(void *)(i + 8))
  {
    int v4 = *(_DWORD *)(i + 16);
    memset(v19, 170, sizeof(v19));
    switch(v4)
    {
      case 0:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 4997712;
        goto LABEL_30;
      case 1:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 4997715;
        goto LABEL_30;
      case 2:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1195460932;
        goto LABEL_26;
      case 3:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1397114194;
        goto LABEL_26;
      case 4:
        char v5 = 0;
        char v10 = 0;
        char v6 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "QMUX1");
        char v7 = 1;
        break;
      case 5:
        char v5 = 0;
        char v10 = 0;
        char v6 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "QMUX2");
        char v7 = 1;
        break;
      case 6:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 5066578;
        goto LABEL_30;
      case 7:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1414483778;
        goto LABEL_26;
      case 8:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 4805185;
        goto LABEL_30;
      case 9:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 5526611;
        goto LABEL_30;
      case 10:
        char v10 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 2;
        strcpy((char *)v19, "AT");
        char v5 = 1;
        break;
      case 11:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1280328769;
        goto LABEL_26;
      case 12:
        char v5 = 0;
        char v10 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 8;
        strcpy((char *)v19, "MEDIACTL");
        break;
      case 13:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 5461061;
        goto LABEL_30;
      case 14:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        strcpy((char *)v19, "GNSS");
        char v6 = 1;
        break;
      case 15:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1397965905;
        goto LABEL_26;
      case 16:
        char v5 = 0;
        char v10 = 0;
        char v6 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 5;
        strcpy((char *)v19, "RCTTH");
        char v7 = 1;
        break;
      case 17:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 5260097;
        goto LABEL_30;
      case 18:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1297040214;
        goto LABEL_26;
      case 19:
        char v5 = 0;
        char v10 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 4;
        __darwin_ct_rune_t v11 = 1129335117;
LABEL_26:
        v19[0] = v11;
        char v6 = 1;
        LOBYTE(v19[1]) = 0;
        break;
      case 20:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 4999236;
        goto LABEL_30;
      case 21:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 5789005;
        goto LABEL_30;
      case 22:
        char v5 = 0;
        char v6 = 0;
        char v7 = 0;
        char v8 = 0;
        HIBYTE(v19[5]) = 3;
        __darwin_ct_rune_t v9 = 4407622;
LABEL_30:
        v19[0] = v9;
        char v10 = 1;
        break;
      default:
        char v5 = 0;
        char v10 = 0;
        char v6 = 0;
        char v7 = 0;
        HIBYTE(v19[5]) = 7;
        strcpy((char *)v19, "Unknown");
        char v8 = 1;
        break;
    }
    LOBYTE(v19[0]) = __tolower(SLOBYTE(v19[0]));
    BYTE1(v19[0]) = __tolower(SBYTE1(v19[0]));
    if ((v5 & 1) == 0)
    {
      BYTE2(v19[0]) = __tolower(SBYTE2(v19[0]));
      if ((v10 & 1) == 0)
      {
        HIBYTE(v19[0]) = __tolower(SHIBYTE(v19[0]));
        if ((v6 & 1) == 0)
        {
          LOBYTE(v19[1]) = __tolower(SLOBYTE(v19[1]));
          if ((v7 & 1) == 0)
          {
            BYTE1(v19[1]) = __tolower(SBYTE1(v19[1]));
            BYTE2(v19[1]) = __tolower(SBYTE2(v19[1]));
            if ((v8 & 1) == 0) {
              HIBYTE(v19[1]) = __tolower(SHIBYTE(v19[1]));
            }
          }
        }
      }
    }
    size_t v12 = operator new(0x28uLL);
    CFTypeRef v13 = (std::string *)(v12 + 2);
    *size_t v12 = 0;
    v12[1] = 0;
    if (SHIBYTE(v19[5]) < 0)
    {
      std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)v19, *(std::string::size_type *)&v19[2]);
    }
    else
    {
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)v19;
      v12[4] = *(void *)&v19[4];
    }
    uint64_t v14 = *a2;
    *size_t v12 = *a2;
    v12[1] = a2;
    *(void *)(v14 + 8) = v12;
    *a2 = (uint64_t)v12;
    ++a2[2];
    if (SHIBYTE(v19[5]) < 0) {
      operator delete(*(void **)v19);
    }
  }
  if (v20[2])
  {
    uint64_t v16 = v20[0];
    char v15 = (void *)v20[1];
    uint64_t v17 = *(void *)v20[1];
    *(void *)(v17 + 8) = *(void *)(v20[0] + 8);
    **(void **)(v16 + 8) = v17;
    v20[2] = 0;
    if (v15 != v20)
    {
      do
      {
        int v18 = (void *)v15[1];
        operator delete(v15);
        char v15 = v18;
      }
      while (v18 != v20);
    }
  }
}

void sub_1A612D17C(_Unwind_Exception *a1)
{
  std::list<std::string>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A612D190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  uint64_t v17 = v16;
  operator delete(v17);
  if (a14 < 0) {
    operator delete(__p);
  }
  std::list<BasebandTransport::Protocol>::~list(&a15);
  std::list<std::string>::~list(v15);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::asStringLowerCase@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  memset(a2, 170, 24);
  uint64_t result = BasebandTransport::asString(a1, (char *)a2);
  uint64_t v4 = *((unsigned __int8 *)a2 + 23);
  int v5 = (char)v4;
  char v6 = (char *)a2 + v4;
  if (v5 >= 0) {
    char v7 = v6;
  }
  else {
    char v7 = (unsigned char *)(*a2 + a2[1]);
  }
  if (v5 >= 0) {
    char v8 = a2;
  }
  else {
    char v8 = (unsigned char *)*a2;
  }
  for (; v8 != v7; ++v8)
  {
    uint64_t result = __tolower((char)*v8);
    unsigned char *v8 = result;
  }
  return result;
}

void sub_1A612D2A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *std::list<std::string>::~list(char *a1)
{
  if (*((void *)a1 + 2))
  {
    uint64_t v2 = *(void *)a1;
    uint64_t v3 = (char *)*((void *)a1 + 1);
    uint64_t v4 = *(void *)v3;
    *(void *)(v4 + 8) = *(void *)(*(void *)a1 + 8);
    **(void **)(v2 + 8) = v4;
    *((void *)a1 + 2) = 0;
    if (v3 != a1)
    {
      do
      {
        char v6 = (char *)*((void *)v3 + 1);
        if (v3[39] < 0) {
          operator delete(*((void **)v3 + 2));
        }
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6 != a1);
    }
  }
  return a1;
}

void BasebandTransport::getSupportedProtocolsAsString(BasebandTransport *this@<X0>, void *a2@<X8>)
{
  *a2 = a2;
  a2[1] = a2;
  a2[2] = 0;
  memset(v18, 170, sizeof(v18));
  BasebandTransport::getSupportedProtocols(this, v18);
  uint64_t v3 = (uint64_t *)v18[1];
  if ((void *)v18[1] != v18)
  {
    unint64_t v4 = a2[2];
    unint64_t v5 = v4 + 1;
    char v6 = (void *)*a2;
    uint64_t v7 = v18[1];
    do
    {
      char v8 = 8;
      unint64_t v9 = 0x4C5443414944454DLL;
      switch(*(_DWORD *)(v7 + 16))
      {
        case 0:
          unint64_t v9 = v4 & 0xFFFFFFFF00000000 | 0x4C4250;
          char v8 = 3;
          break;
        case 1:
          unint64_t v9 = (v4 & 0xFFFFFFFF00000000 | 0x4C4250) + 3;
          char v8 = 3;
          break;
        case 2:
          uint64_t v10 = 1195460932;
          goto LABEL_25;
        case 3:
          uint64_t v10 = 1397114194;
          goto LABEL_25;
        case 4:
          uint64_t v11 = 0x3158554D51;
          goto LABEL_21;
        case 5:
          uint64_t v11 = 0x3258554D51;
          goto LABEL_21;
        case 6:
          unsigned int v12 = 5066578;
          goto LABEL_29;
        case 7:
          uint64_t v10 = 1414483778;
          goto LABEL_25;
        case 8:
          unsigned int v12 = 4805185;
          goto LABEL_29;
        case 9:
          unsigned int v12 = 5526611;
          goto LABEL_29;
        case 0xA:
          unint64_t v13 = v4 & 0xFFFFFFFFFF000000 | 0x5441;
          char v8 = 2;
          goto LABEL_30;
        case 0xB:
          uint64_t v10 = 1280328769;
          goto LABEL_25;
        case 0xC:
          break;
        case 0xD:
          unsigned int v12 = 5461061;
          goto LABEL_29;
        case 0xE:
          unint64_t v9 = (v4 & 0xFFFFFF0000000000 | 0x53534451) + 2550;
          char v8 = 4;
          break;
        case 0xF:
          unint64_t v9 = v4 & 0xFFFFFF0000000000 | 0x53534451;
          char v8 = 4;
          break;
        case 0x10:
          uint64_t v11 = 0x4854544352;
LABEL_21:
          unint64_t v13 = v4 & 0xFFFF000000000000 | v11 & 0xFFFFFFFFFFFFLL;
          char v8 = 5;
          goto LABEL_30;
        case 0x11:
          unsigned int v12 = 5260097;
          goto LABEL_29;
        case 0x12:
          uint64_t v10 = 1297040214;
          goto LABEL_25;
        case 0x13:
          uint64_t v10 = 1129335117;
LABEL_25:
          unint64_t v13 = v4 & 0xFFFFFF0000000000 | v10 & 0xFFFFFFFFFFLL;
          char v8 = 4;
          goto LABEL_30;
        case 0x14:
          unint64_t v9 = (v4 & 0xFFFFFFFF00000000 | 0x4C4250) + 1524;
          char v8 = 3;
          break;
        case 0x15:
          unsigned int v12 = 5789005;
          goto LABEL_29;
        case 0x16:
          unsigned int v12 = 4407622;
LABEL_29:
          unint64_t v13 = v4 & 0xFFFFFFFF00000000 | v12;
          char v8 = 3;
LABEL_30:
          unint64_t v9 = v13;
          break;
        default:
          char v8 = 7;
          unint64_t v9 = 0x6E776F6E6B6E55;
          break;
      }
      uint64_t v14 = operator new(0x28uLL);
      v14[2] = v9;
      v14[3] = 0;
      *((unsigned char *)v14 + 39) = v8;
      *uint64_t v14 = v6;
      v14[1] = a2;
      v6[1] = v14;
      *a2 = v14;
      a2[2] = v5;
      uint64_t v7 = *(void *)(v7 + 8);
      ++v5;
      unint64_t v4 = v9;
      char v6 = v14;
    }
    while ((void *)v7 != v18);
  }
  if (v18[2])
  {
    uint64_t v15 = v18[0];
    uint64_t v16 = *v3;
    *(void *)(v16 + 8) = *(void *)(v18[0] + 8);
    **(void **)(v15 + 8) = v16;
    v18[2] = 0;
    if (v3 != v18)
    {
      do
      {
        uint64_t v17 = (uint64_t *)v3[1];
        operator delete(v3);
        uint64_t v3 = v17;
      }
      while (v17 != v18);
    }
  }
}

void sub_1A612D608(_Unwind_Exception *a1)
{
  std::list<std::string>::~list(v1);
  _Unwind_Resume(a1);
}

void sub_1A612D61C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::list<BasebandTransport::Protocol>::~list((uint64_t *)va);
  std::list<std::string>::~list(v2);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::asString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      a2[23] = 3;
      *(_DWORD *)a2 = 4997712;
      break;
    case 1:
      a2[23] = 3;
      *(_DWORD *)a2 = 4997715;
      break;
    case 2:
      a2[23] = 4;
      strcpy(a2, "DIAG");
      break;
    case 3:
      a2[23] = 4;
      strcpy(a2, "REFS");
      break;
    case 4:
      a2[23] = 5;
      strcpy(a2, "QMUX1");
      break;
    case 5:
      a2[23] = 5;
      strcpy(a2, "QMUX2");
      break;
    case 6:
      a2[23] = 3;
      *(_DWORD *)a2 = 5066578;
      break;
    case 7:
      a2[23] = 4;
      strcpy(a2, "BOOT");
      break;
    case 8:
      a2[23] = 3;
      *(_DWORD *)a2 = 4805185;
      break;
    case 9:
      a2[23] = 3;
      *(_DWORD *)a2 = 5526611;
      break;
    case 10:
      a2[23] = 2;
      strcpy(a2, "AT");
      break;
    case 11:
      a2[23] = 4;
      strcpy(a2, "ADPL");
      break;
    case 12:
      a2[23] = 8;
      strcpy(a2, "MEDIACTL");
      break;
    case 13:
      a2[23] = 3;
      *(_DWORD *)a2 = 5461061;
      break;
    case 14:
      a2[23] = 4;
      strcpy(a2, "GNSS");
      break;
    case 15:
      a2[23] = 4;
      strcpy(a2, "QDSS");
      break;
    case 16:
      a2[23] = 5;
      strcpy(a2, "RCTTH");
      break;
    case 17:
      a2[23] = 3;
      *(_DWORD *)a2 = 5260097;
      break;
    case 18:
      a2[23] = 4;
      strcpy(a2, "VCOM");
      break;
    case 19:
      a2[23] = 4;
      strcpy(a2, "MIPC");
      break;
    case 20:
      a2[23] = 3;
      *(_DWORD *)a2 = 4999236;
      break;
    case 21:
      a2[23] = 3;
      *(_DWORD *)a2 = 5789005;
      break;
    case 22:
      a2[23] = 3;
      *(_DWORD *)a2 = 4407622;
      break;
    default:
      a2[23] = 7;
      strcpy(a2, "Unknown");
      break;
  }
  return result;
}

{
  switch((int)result)
  {
    case 0:
      a2[23] = 8;
      strcpy(a2, "NotReady");
      break;
    case 1:
      a2[23] = 5;
      strcpy(a2, "Ready");
      break;
    case 2:
      a2[23] = 5;
      strcpy(a2, "Error");
      break;
    case 3:
      a2[23] = 7;
      strcpy(a2, "Stalled");
      break;
    default:
      a2[23] = 7;
      strcpy(a2, "Unknown");
      break;
  }
  return result;
}

uint64_t BasebandTransport::asProtocol(char *__s1)
{
  uint64_t v1 = __s1;
  if ((__s1[23] & 0x80000000) == 0)
  {
    uint64_t result = strcmp(__s1, "PBL");
    if (!result) {
      return result;
    }
    if (!strcmp(v1, "SBL")) {
      return 1;
    }
    if (strcasecmp(v1, "DIAG"))
    {
      if (strcasecmp(v1, "REFS"))
      {
        if (strcasecmp(v1, "QMUX1"))
        {
          if (strcasecmp(v1, "QMUX2"))
          {
            if (strcasecmp(v1, "ROM"))
            {
              if (strcasecmp(v1, "BOOT"))
              {
                if (strcasecmp(v1, "ARI"))
                {
                  if (strcasecmp(v1, "STT"))
                  {
                    if (strcasecmp(v1, "AT"))
                    {
                      if (strcasecmp(v1, "ADPL"))
                      {
                        if (strcasecmp(v1, "MEDIACTL"))
                        {
                          if (strcasecmp(v1, "ETS"))
                          {
                            if (strcasecmp(v1, "GNSS"))
                            {
                              if (strcasecmp(v1, "QDSS"))
                              {
                                if (strcasecmp(v1, "RCTTH"))
                                {
                                  if (strcasecmp(v1, "ACP"))
                                  {
                                    if (strcasecmp(v1, "VCOM"))
                                    {
                                      if (strcasecmp(v1, "MIPC"))
                                      {
                                        if (strcasecmp(v1, "DHL"))
                                        {
                                          if (strcasecmp(v1, "MUX")) {
                                            goto LABEL_24;
                                          }
                                          return 21;
                                        }
                                        return 20;
                                      }
                                      return 19;
                                    }
                                    return 18;
                                  }
                                  return 17;
                                }
                                return 16;
                              }
                              return 15;
                            }
                            return 14;
                          }
                          return 13;
                        }
                        return 12;
                      }
                      return 11;
                    }
                    return 10;
                  }
                  return 9;
                }
                return 8;
              }
              return 7;
            }
            return 6;
          }
          return 5;
        }
        return 4;
      }
      return 3;
    }
    return 2;
  }
  uint64_t v1 = *(const char **)__s1;
  uint64_t result = strcmp(*(const char **)__s1, "PBL");
  if (!result) {
    return result;
  }
  if (!strcmp(v1, "SBL")) {
    return 1;
  }
  if (!strcasecmp(v1, "DIAG")) {
    return 2;
  }
  if (!strcasecmp(v1, "REFS")) {
    return 3;
  }
  if (!strcasecmp(v1, "QMUX1")) {
    return 4;
  }
  if (!strcasecmp(v1, "QMUX2")) {
    return 5;
  }
  if (!strcasecmp(v1, "ROM")) {
    return 6;
  }
  if (!strcasecmp(v1, "BOOT")) {
    return 7;
  }
  if (!strcasecmp(v1, "ARI")) {
    return 8;
  }
  if (!strcasecmp(v1, "STT")) {
    return 9;
  }
  if (!strcasecmp(v1, "AT")) {
    return 10;
  }
  if (!strcasecmp(v1, "ADPL")) {
    return 11;
  }
  if (!strcasecmp(v1, "MEDIACTL")) {
    return 12;
  }
  if (!strcasecmp(v1, "ETS")) {
    return 13;
  }
  if (!strcasecmp(v1, "GNSS")) {
    return 14;
  }
  if (!strcasecmp(v1, "QDSS")) {
    return 15;
  }
  if (!strcasecmp(v1, "RCTTH")) {
    return 16;
  }
  if (!strcasecmp(v1, "ACP")) {
    return 17;
  }
  if (!strcasecmp(v1, "VCOM")) {
    return 18;
  }
  if (!strcasecmp(v1, "MIPC")) {
    return 19;
  }
  if (!strcasecmp(v1, "DHL")) {
    return 20;
  }
  if (!strcasecmp(v1, "MUX")) {
    return 21;
  }
LABEL_24:
  if (!strcasecmp(v1, "FAC")) {
    return 22;
  }
  else {
    return 23;
  }
}

uint64_t BasebandTransport::getDefaultTransportIOReadSize(capabilities::abs *a1)
{
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(a1)) {
    return 0x4000;
  }
  else {
    return 0x8000;
  }
}

uint64_t BasebandTransport::getDefaultTransportIOReadCount(capabilities::abs *a1)
{
  int v1 = (int)a1;
  char shouldUseMinBasebandTransportIOReadCount = capabilities::abs::shouldUseMinBasebandTransportIOReadCount(a1);
  if (v1 == 15) {
    int v3 = 36;
  }
  else {
    int v3 = 4;
  }
  if (v1 == 16) {
    int v4 = 36;
  }
  else {
    int v4 = v3;
  }
  if (v1 == 2) {
    unsigned int v5 = 16;
  }
  else {
    unsigned int v5 = v4;
  }
  if (shouldUseMinBasebandTransportIOReadCount) {
    return 4;
  }
  else {
    return v5;
  }
}

double BasebandTransport::Status::Status(BasebandTransport::Status *this)
{
  *(_DWORD *)this = 0;
  *((unsigned char *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(_DWORD *)this = 0;
  *((unsigned char *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

double BasebandTransport::Status::init(BasebandTransport::Status *this)
{
  *(_DWORD *)this = 0;
  *((unsigned char *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

uint64_t BasebandTransport::Status::toString@<X0>(BasebandTransport::Status *this@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35[7] = v4;
  v35[8] = v4;
  v35[5] = v4;
  v35[6] = v4;
  v35[3] = v4;
  v35[4] = v4;
  v35[1] = v4;
  v35[2] = v4;
  long long v34 = v4;
  v35[0] = v4;
  *(_OWORD *)uint64_t v32 = v4;
  long long v33 = v4;
  long long v30 = v4;
  long long v31 = v4;
  long long v28 = v4;
  long long v29 = v4;
  long long v27 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v27);
  unsigned int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v28, (uint64_t)"State: ", 7);
  switch(*(_DWORD *)this)
  {
    case 0:
      uint64_t v6 = 8;
      char v26 = 8;
      strcpy((char *)__p, "NotReady");
      break;
    case 1:
      uint64_t v6 = 5;
      char v26 = 5;
      strcpy((char *)__p, "Ready");
      break;
    case 2:
      uint64_t v6 = 5;
      char v26 = 5;
      strcpy((char *)__p, "Error");
      break;
    case 3:
      uint64_t v6 = 7;
      char v26 = 7;
      LODWORD(__p[0]) = 1818326099;
      int v7 = 1684368492;
      goto LABEL_7;
    default:
      uint64_t v6 = 7;
      char v26 = 7;
      LODWORD(__p[0]) = 1852534357;
      int v7 = 1853321070;
LABEL_7:
      *(_DWORD *)((char *)__p + 3) = v7;
      HIBYTE(__p[0]) = 0;
      break;
  }
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)__p, v6);
  unint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)", ", 2);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"Async: ", 7);
  *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) |= 1u;
  uint64_t v11 = (void *)std::ostream::operator<<();
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"Total Rx: ", 10);
  unint64_t v13 = (void *)std::ostream::operator<<();
  uint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" KB, ", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"Total Tx: ", 10);
  uint64_t v15 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" KB", 3);
  if ((v26 & 0x80000000) == 0)
  {
    char v16 = BYTE8(v34);
    if ((BYTE8(v34) & 0x10) == 0) {
      goto LABEL_10;
    }
LABEL_13:
    uint64_t v18 = v34;
    if ((unint64_t)v34 < *((void *)&v31 + 1))
    {
      *(void *)&long long v34 = *((void *)&v31 + 1);
      uint64_t v18 = *((void *)&v31 + 1);
    }
    uint64_t v19 = (const void *)v31;
    size_t v17 = v18 - v31;
    if ((unint64_t)(v18 - v31) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_27;
    }
    goto LABEL_16;
  }
  operator delete(__p[0]);
  char v16 = BYTE8(v34);
  if ((BYTE8(v34) & 0x10) != 0) {
    goto LABEL_13;
  }
LABEL_10:
  if ((v16 & 8) == 0)
  {
    size_t v17 = 0;
    a2[23] = 0;
    goto LABEL_23;
  }
  uint64_t v19 = (const void *)*((void *)&v29 + 1);
  size_t v17 = *((void *)&v30 + 1) - *((void *)&v29 + 1);
  if (*((void *)&v30 + 1) - *((void *)&v29 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_27:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_16:
  if (v17 >= 0x17)
  {
    uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v20 = v17 | 7;
    }
    uint64_t v21 = v20 + 1;
    uint64_t v22 = operator new(v20 + 1);
    *((void *)a2 + 1) = v17;
    *((void *)a2 + 2) = v21 | 0x8000000000000000;
    *(void *)a2 = v22;
    a2 = v22;
    goto LABEL_22;
  }
  a2[23] = v17;
  if (v17) {
LABEL_22:
  }
    memmove(a2, v19, v17);
LABEL_23:
  a2[v17] = 0;
  *(void *)&long long v27 = *MEMORY[0x1E4FBA408];
  uint64_t v23 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v27 + *(void *)(v27 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v28 = v23;
  *((void *)&v28 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v35);
}

void sub_1A612E3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A612E3B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::Parameters::toString@<X0>(BasebandTransport::Parameters *this@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v4;
  v40[8] = v4;
  v40[5] = v4;
  v40[6] = v4;
  v40[3] = v4;
  v40[4] = v4;
  v40[1] = v4;
  v40[2] = v4;
  long long v39 = v4;
  v40[0] = v4;
  *(_OWORD *)int v37 = v4;
  long long v38 = v4;
  long long v35 = v4;
  long long v36 = v4;
  long long v33 = v4;
  long long v34 = v4;
  long long v32 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v32);
  switch(*(_DWORD *)this)
  {
    case 0:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "PBL");
      break;
    case 1:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "SBL");
      break;
    case 2:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1195460932;
      goto LABEL_25;
    case 3:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1397114194;
      goto LABEL_25;
    case 4:
      size_t v5 = 5;
      char v28 = 5;
      strcpy((char *)v27, "QMUX1");
      break;
    case 5:
      size_t v5 = 5;
      char v28 = 5;
      strcpy((char *)v27, "QMUX2");
      break;
    case 6:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "ROM");
      break;
    case 7:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1414483778;
      goto LABEL_25;
    case 8:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "ARI");
      break;
    case 9:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "STT");
      break;
    case 0xA:
      size_t v5 = 2;
      char v28 = 2;
      strcpy((char *)v27, "AT");
      break;
    case 0xB:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1280328769;
      goto LABEL_25;
    case 0xC:
      size_t v5 = 8;
      char v28 = 8;
      strcpy((char *)v27, "MEDIACTL");
      break;
    case 0xD:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "ETS");
      break;
    case 0xE:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1397968455;
      goto LABEL_25;
    case 0xF:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1397965905;
      goto LABEL_25;
    case 0x10:
      size_t v5 = 5;
      char v28 = 5;
      strcpy((char *)v27, "RCTTH");
      break;
    case 0x11:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "ACP");
      break;
    case 0x12:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1297040214;
      goto LABEL_25;
    case 0x13:
      size_t v5 = 4;
      char v28 = 4;
      int v6 = 1129335117;
LABEL_25:
      LODWORD(v27[0]) = v6;
      BYTE4(v27[0]) = 0;
      break;
    case 0x14:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "DHL");
      break;
    case 0x15:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "MUX");
      break;
    case 0x16:
      size_t v5 = 3;
      char v28 = 3;
      strcpy((char *)v27, "FAC");
      break;
    default:
      size_t v5 = 7;
      char v28 = 7;
      strcpy((char *)v27, "Unknown");
      break;
  }
  uint64_t v30 = 8250;
  uint64_t v31 = 0;
  HIBYTE(v31) = v5 + 10;
  std::string __p = *(void **)"Protocol: ";
  memcpy((char *)&v30 + 2, v27, v5);
  *((unsigned char *)&v30 + v5 + 2) = 0;
  if (v31 >= 0) {
    uint64_t p_p = (uint64_t)&__p;
  }
  else {
    uint64_t p_p = 0x6C6F636F746F7250;
  }
  if (v31 >= 0) {
    uint64_t v8 = HIBYTE(v31);
  }
  else {
    uint64_t v8 = v30;
  }
  unint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, p_p, v8);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"Powersave: ", 11);
  *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24) + 8) |= 1u;
  unsigned int v12 = (void *)std::ostream::operator<<();
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)", ", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"Create Timeout: ", 16);
  uint64_t v14 = (void *)std::ostream::operator<<();
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" sec, ", 6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"IO Size: ", 9);
  char v16 = (void *)std::ostream::operator<<();
  size_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" KB, ", 5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"Num Pending Reads: ", 19);
  std::ostream::operator<<();
  if (SHIBYTE(v31) < 0)
  {
    operator delete(__p);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_34:
      char v18 = BYTE8(v39);
      if ((BYTE8(v39) & 0x10) == 0) {
        goto LABEL_35;
      }
LABEL_39:
      uint64_t v20 = v39;
      if ((unint64_t)v39 < *((void *)&v36 + 1))
      {
        *(void *)&long long v39 = *((void *)&v36 + 1);
        uint64_t v20 = *((void *)&v36 + 1);
      }
      uint64_t v21 = (const void *)v36;
      size_t v19 = v20 - v36;
      if ((unint64_t)(v20 - v36) >= 0x7FFFFFFFFFFFFFF8) {
        goto LABEL_53;
      }
      goto LABEL_42;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_34;
  }
  operator delete(v27[0]);
  char v18 = BYTE8(v39);
  if ((BYTE8(v39) & 0x10) != 0) {
    goto LABEL_39;
  }
LABEL_35:
  if ((v18 & 8) == 0)
  {
    size_t v19 = 0;
    a2[23] = 0;
    goto LABEL_49;
  }
  uint64_t v21 = (const void *)*((void *)&v34 + 1);
  size_t v19 = *((void *)&v35 + 1) - *((void *)&v34 + 1);
  if (*((void *)&v35 + 1) - *((void *)&v34 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_53:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_42:
  if (v19 >= 0x17)
  {
    uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v22 = v19 | 7;
    }
    uint64_t v23 = v22 + 1;
    uint64_t v24 = operator new(v22 + 1);
    *((void *)a2 + 1) = v19;
    *((void *)a2 + 2) = v23 | 0x8000000000000000;
    *(void *)a2 = v24;
    a2 = v24;
    goto LABEL_48;
  }
  a2[23] = v19;
  if (v19) {
LABEL_48:
  }
    memmove(a2, v21, v19);
LABEL_49:
  a2[v19] = 0;
  *(void *)&long long v32 = *MEMORY[0x1E4FBA408];
  uint64_t v25 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v32 + *(void *)(v32 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v33 = v25;
  *((void *)&v33 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v38) < 0) {
    operator delete(v37[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v40);
}

void sub_1A612EB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A612EB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0)
  {
    operator delete(__p);
    if ((a14 & 0x80000000) == 0)
    {
LABEL_3:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
      _Unwind_Resume(a1);
    }
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransport::BasebandTransport(uint64_t a1, void *a2, NSObject **a3)
{
  *(void *)a1 = &unk_1EFB0BB90;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v15, "com.apple.telephony.abm", "ipc.bb");
  int v6 = dispatch_queue_create("ipc.bb", 0);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = v6;
  if (v6)
  {
    int v7 = v6;
    dispatch_retain(v6);
    *(void *)(a1 + 96) = 0;
    dispatch_release(v7);
  }
  else
  {
    *(void *)(a1 + 96) = 0;
  }
  *(void *)a1 = &unk_1EFB0BE58;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v17);
  *(void *)(a1 + 8) = &unk_1EFB08838;
  *(void *)(a1 + 56) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 64) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v16);
  *(void *)a1 = &unk_1EFB0BF50;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v15);
  *(void *)a1 = &unk_1EFB0BB90;
  *(_DWORD *)(a1 + 104) = 23;
  *(unsigned char *)(a1 + 108) = 0;
  *(void *)(a1 + 112) = 10;
  int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v9);
  if (shouldUseMinBasebandTransportIOReadSize) {
    int v11 = 0x4000;
  }
  else {
    int v11 = 0x8000;
  }
  *(_DWORD *)(a1 + 120) = v11;
  capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
  *(_DWORD *)(a1 + 124) = 4;
  *(void *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  unsigned int v12 = *a3;
  *(void *)(a1 + 152) = *a3;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  uint64_t Controller = TelephonyBasebandCreateController();
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 264) = Controller;
  *(void *)(a1 + 285) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 320) = dispatch_group_create();
  *(_DWORD *)(a1 + 328) = 0;
  *(unsigned char *)(a1 + 332) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(void *)(a1 + 365) = 0;
  return a1;
}

void sub_1A612EE14(_Unwind_Exception *a1)
{
  long long v4 = (const void *)v1[21];
  if (v4) {
    _Block_release(v4);
  }
  if (*v2) {
    _Block_release(*v2);
  }
  size_t v5 = v1[19];
  if (v5) {
    dispatch_release(v5);
  }
  int v6 = (const void *)v1[18];
  if (v6) {
    _Block_release(v6);
  }
  ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v1);
  _Unwind_Resume(a1);
}

const char *BasebandTransport::getName(BasebandTransport *this)
{
  return "ipc.bb";
}

void *ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0BE58;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  int v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = &unk_1EFB0BE58;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  int v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void BasebandTransport::~BasebandTransport(BasebandTransport *this)
{
  *(void *)this = &unk_1EFB0BB90;
  uint64_t v2 = *((void *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((void *)this + 35) = 0;
    int v3 = *((void *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v16 = 0;
      _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v16, 2u);
    }
  }
  (*(void (**)(BasebandTransport *))(*(void *)this + 80))(this);
  long long v4 = (const void *)*((void *)this + 33);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 33) = 0;
  }
  size_t v5 = (void *)*((void *)this + 37);
  if (v5)
  {
    operator delete[](v5);
    *((void *)this + 37) = 0;
  }
  int v6 = *((void *)this + 40);
  if (v6) {
    dispatch_release(v6);
  }
  int v7 = *((void *)this + 39);
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 34);
  if (v8) {
    _Block_release(v8);
  }
  unint64_t v9 = (const void *)*((void *)this + 21);
  if (v9) {
    _Block_release(v9);
  }
  uint64_t v10 = (const void *)*((void *)this + 20);
  if (v10) {
    _Block_release(v10);
  }
  int v11 = *((void *)this + 19);
  if (v11) {
    dispatch_release(v11);
  }
  unsigned int v12 = (const void *)*((void *)this + 18);
  if (v12) {
    _Block_release(v12);
  }
  *(void *)this = &unk_1EFB0BE58;
  MEMORY[0x1A6274710]((char *)this + 8);
  unint64_t v13 = *((void *)this + 12);
  if (v13) {
    dispatch_release(v13);
  }
  uint64_t v14 = *((void *)this + 11);
  if (v14) {
    dispatch_release(v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
}

{
  void *v1;
  uint64_t vars8;

  BasebandTransport::~BasebandTransport(this);

  operator delete(v1);
}

void BasebandTransport::timerOff_sync(BasebandTransport *this)
{
  uint64_t v2 = *((void *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((void *)this + 35) = 0;
    int v3 = *((void *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v4, 2u);
    }
  }
}

void BasebandTransport::create(NSObject **a1@<X0>, uint64_t a2@<X8>)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZL14sLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke;
  block[3] = &__block_descriptor_tmp_90_0;
  void block[4] = &qword_1EB5EE980;
  if (_MergedGlobals_11 == -1)
  {
    long long v4 = *(std::__shared_weak_count **)algn_1EB5EE988;
    uint64_t v7 = qword_1EB5EE980;
    uint64_t v8 = *(void *)algn_1EB5EE988;
    if (!*(void *)algn_1EB5EE988) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  dispatch_once(&_MergedGlobals_11, block);
  long long v4 = *(std::__shared_weak_count **)algn_1EB5EE988;
  uint64_t v7 = qword_1EB5EE980;
  uint64_t v8 = *(void *)algn_1EB5EE988;
  if (*(void *)algn_1EB5EE988) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  size_t v5 = *a1;
  int v6 = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  BasebandTransport::create((capabilities::radio *)&v7, &v6, a2);
  if (v5) {
    dispatch_release(v5);
  }
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A612F2AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10) {
    dispatch_release(v10);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void BasebandTransport::create(capabilities::radio *a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  int v6 = capabilities::radio::vendor(a1);
  if (v6 != 1)
  {
    if (v6 != 2)
    {
      if (v6 != 3) {
        return;
      }
      uint64_t v7 = (std::__shared_weak_count_vtbl *)operator new(0x198uLL);
      uint64_t v8 = (std::__shared_weak_count *)*((void *)a1 + 1);
      uint64_t v33 = *(void *)a1;
      long long v34 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v9 = *a2;
      long long v32 = v9;
      if (v9) {
        dispatch_retain(v9);
      }
      BasebandTransport::BasebandTransport((uint64_t)v7, &v33, &v32);
      unint64_t v41 = &v7->~__shared_weak_count;
      unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
      v10->__shared_owners_ = 0;
      p_shared_owners = &v10->__shared_owners_;
      v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C030;
      v10->__shared_weak_owners_ = 0;
      v10[1].__vftable = v7;
      unint64_t v42 = (unint64_t)v10;
      unsigned int v12 = (std::__shared_weak_count *)v7[2].~__shared_weak_count;
      if (v12)
      {
        if (v12->__shared_owners_ != -1
          || (atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed),
              atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed),
              v7[1].__on_zero_shared_weauint64_t k = (void (__cdecl *)(std::__shared_weak_count *__hidden))v7,
              v7[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v10,
              std::__shared_weak_count::__release_weak(v12),
              atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)))
        {
LABEL_42:
          uint64_t v30 = (uint64_t)v41;
          ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v41);
          unint64_t v31 = v42;
          unint64_t v41 = 0;
          unint64_t v42 = 0;
          *(void *)a3 = v30;
          *(void *)(a3 + 8) = v31;
          if (v9) {
            dispatch_release(v9);
          }
          long long v27 = v34;
          if (!v34) {
            goto LABEL_47;
          }
          goto LABEL_45;
        }
      }
      else
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v7[1].__on_zero_shared_weauint64_t k = (void (__cdecl *)(std::__shared_weak_count *__hidden))v7;
        v7[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v10;
        if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_42;
        }
      }
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      goto LABEL_42;
    }
    unint64_t v13 = (BasebandTransportICE *)operator new(0x208uLL);
    uint64_t v14 = (std::__shared_weak_count *)*((void *)a1 + 1);
    uint64_t v36 = *(void *)a1;
    int v37 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v15 = *a2;
    dispatch_object_t object = v15;
    if (v15) {
      dispatch_retain(v15);
    }
    BasebandTransportICE::BasebandTransportICE(v13, &v36, &object);
    unint64_t v41 = v13;
    unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
    char v16 = (std::__shared_weak_count *)operator new(0x20uLL);
    v16->__shared_owners_ = 0;
    size_t v17 = &v16->__shared_owners_;
    v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0BFE0;
    v16->__shared_weak_owners_ = 0;
    v16[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
    unint64_t v42 = (unint64_t)v16;
    char v18 = (std::__shared_weak_count *)*((void *)v13 + 10);
    if (v18)
    {
      if (v18->__shared_owners_ != -1
        || (atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed),
            atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed),
            *((void *)v13 + 9) = v13,
            *((void *)v13 + 10) = v16,
            std::__shared_weak_count::__release_weak(v18),
            atomic_fetch_add(v17, 0xFFFFFFFFFFFFFFFFLL)))
      {
LABEL_30:
        uint64_t v25 = (uint64_t)v41;
        ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v41);
        unint64_t v26 = v42;
        unint64_t v41 = 0;
        unint64_t v42 = 0;
        *(void *)a3 = v25;
        *(void *)(a3 + 8) = v26;
        if (object) {
          dispatch_release(object);
        }
        long long v27 = v37;
        if (!v37) {
          goto LABEL_47;
        }
        goto LABEL_45;
      }
    }
    else
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *((void *)v13 + 9) = v13;
      *((void *)v13 + 10) = v16;
      if (atomic_fetch_add(v17, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_30;
      }
    }
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    goto LABEL_30;
  }
  size_t v19 = (std::__shared_weak_count_vtbl *)operator new(0x198uLL);
  uint64_t v20 = (std::__shared_weak_count *)*((void *)a1 + 1);
  uint64_t v39 = *(void *)a1;
  uint64_t v40 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = *a2;
  dispatch_object_t v38 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  BasebandTransportMAV::BasebandTransportMAV(v19, &v39, &v38);
  unint64_t v41 = &v19->~__shared_weak_count;
  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v22 = (std::__shared_weak_count *)operator new(0x20uLL);
  v22->__shared_owners_ = 0;
  uint64_t v23 = &v22->__shared_owners_;
  v22->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0BF90;
  v22->__shared_weak_owners_ = 0;
  v22[1].__vftable = v19;
  unint64_t v42 = (unint64_t)v22;
  uint64_t v24 = (std::__shared_weak_count *)v19[2].~__shared_weak_count;
  if (!v24)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v19[1].__on_zero_shared_weauint64_t k = (void (__cdecl *)(std::__shared_weak_count *__hidden))v19;
    v19[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v22;
    if (atomic_fetch_add(v23, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  if (v24->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v19[1].__on_zero_shared_weauint64_t k = (void (__cdecl *)(std::__shared_weak_count *__hidden))v19;
    v19[2].~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v22;
    std::__shared_weak_count::__release_weak(v24);
    if (!atomic_fetch_add(v23, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_35:
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
LABEL_36:
  uint64_t v28 = (uint64_t)v41;
  ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v41);
  unint64_t v29 = v42;
  unint64_t v41 = 0;
  unint64_t v42 = 0;
  *(void *)a3 = v28;
  *(void *)(a3 + 8) = v29;
  if (v38) {
    dispatch_release(v38);
  }
  long long v27 = v40;
  if (!v40) {
    goto LABEL_47;
  }
LABEL_45:
  if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
LABEL_47:
  BasebandTransport::init(*(BasebandTransport **)a3);
}

void sub_1A612F754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, dispatch_object_t a13, char a14, uint64_t a15, dispatch_object_t object, char a17)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v19 - 64);
  if (v18) {
    dispatch_release(v18);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v17);
  _Unwind_Resume(a1);
}

void BasebandTransport::init(BasebandTransport *this)
{
  uint64_t v5 = *((void *)this + 9);
  int v3 = (std::__shared_weak_count *)*((void *)this + 10);
  long long v4 = (char *)this + 72;
  if (!v3 || (int v6 = std::__shared_weak_count::lock(v3)) == 0) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  p_shared_weak_owners = &v6->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 1174405120;
  void v11[2] = ___ZN17BasebandTransport4initEv_block_invoke;
  v11[3] = &__block_descriptor_tmp_51_0;
  _DWORD v11[4] = this;
  v11[5] = v5;
  unsigned int v12 = v7;
  unint64_t v13 = v11;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = v4;
  void block[5] = &v13;
  unint64_t v9 = *((void *)this + 11);
  if (!*((void *)this + 12))
  {
    dispatch_sync(v9, block);
    uint64_t v10 = v12;
    if (!v12) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  dispatch_async_and_wait(v9, block);
  uint64_t v10 = v12;
  if (v12) {
LABEL_7:
  }
    std::__shared_weak_count::__release_weak(v10);
LABEL_8:
  std::__shared_weak_count::__release_weak(v7);
}

void ___ZN17BasebandTransport4initEv_block_invoke(capabilities::ipc *a1)
{
  uint64_t v2 = *((void *)a1 + 4);
  if (capabilities::ipc::supportsPCI(a1))
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN17BasebandTransport4initEv_block_invoke_2;
    aBlock[3] = &__block_descriptor_tmp_20;
    uint64_t v4 = *((void *)a1 + 5);
    int v3 = (std::__shared_weak_count *)*((void *)a1 + 6);
    aBlock[4] = v2;
    void aBlock[5] = v4;
    uint64_t v14 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = _Block_copy(aBlock);
    int v6 = *(const void **)(v2 + 160);
    *(void *)(v2 + 160) = v5;
    if (v6) {
      _Block_release(v6);
    }
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 1174405120;
    void v11[2] = ___ZN17BasebandTransport4initEv_block_invoke_43;
    v11[3] = &__block_descriptor_tmp_47_0;
    uint64_t v8 = *((void *)a1 + 5);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)a1 + 6);
    _DWORD v11[4] = v2;
    v11[5] = v8;
    unsigned int v12 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v9 = _Block_copy(v11);
    uint64_t v10 = *(const void **)(v2 + 168);
    *(void *)(v2 + 168) = v9;
    if (v10) {
      _Block_release(v10);
    }
    if (v12) {
      std::__shared_weak_count::__release_weak(v12);
    }
    if (v14) {
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void ___ZN17BasebandTransport4initEv_block_invoke_2(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = a1[4];
    uint64_t v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      int v11 = v10;
      if (a1[5])
      {
        unsigned int v12 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v21 = 67109632;
          *(_DWORD *)&v21[4] = a2;
          *(_WORD *)&v21[8] = 2048;
          *(void *)&v21[10] = a3;
          *(_WORD *)&v21[18] = 2048;
          *(void *)&v21[20] = a4;
          _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "PCI Transport Status: 0x%x (0x%08lx, 0x%08lx)", v21, 0x1Cu);
        }
        *(_DWORD *)(v9 + 328) = 2 * (a2 != 0);
        *(int64x2_t *)(v9 + 352) = vsubq_s64(*(int64x2_t *)(v9 + 336), *(int64x2_t *)(v9 + 376));
        unint64_t v13 = *(const void **)(v9 + 272);
        if (v13)
        {
          uint64_t v14 = _Block_copy(v13);
          uint64_t v15 = v14;
          long long v16 = *(_OWORD *)(v9 + 344);
          *(_OWORD *)uint64_t v21 = *(_OWORD *)(v9 + 328);
          *(_OWORD *)&v21[16] = v16;
          uint64_t v22 = *(void *)(v9 + 360);
          uint64_t v17 = *(NSObject **)(v9 + 152);
          if (v14) {
            char v18 = _Block_copy(v14);
          }
          else {
            char v18 = 0;
          }
          uint64_t v19 = (char *)operator new(0x30uLL);
          *(void *)uint64_t v19 = v18;
          long long v20 = *(_OWORD *)&v21[16];
          *(_OWORD *)(v19 + 8) = *(_OWORD *)v21;
          *(_OWORD *)(v19 + 24) = v20;
          *((void *)v19 + 5) = v22;
          dispatch_async_f(v17, v19, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb0_E3__0EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          if (v15) {
            _Block_release(v15);
          }
        }
      }
      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
}

void sub_1A612FD80(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

int64x2_t BasebandTransport::updateDeltas_sync(BasebandTransport *this)
{
  int64x2_t result = vsubq_s64(*((int64x2_t *)this + 21), *(int64x2_t *)((char *)this + 376));
  *((int64x2_t *)this + 22) = result;
  return result;
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrI17BasebandTransportEE(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN17BasebandTransport4initEv_block_invoke_43(void *a1, int a2, void *a3, unsigned int a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1[4];
  uint64_t v31 = 0;
  long long v32 = 0;
  uint64_t v7 = (std::__shared_weak_count *)a1[6];
  if (v7 && (v32 = std::__shared_weak_count::lock(v7)) != 0 && (uint64_t v10 = a1[5], (v31 = v10) != 0))
  {
    int v11 = *(NSObject **)(v10 + 320);
    if (v11)
    {
      dispatch_retain(*(dispatch_object_t *)(v10 + 320));
      dispatch_group_enter(v11);
    }
    if (a2)
    {
      unsigned int v12 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)stat buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a2;
        _os_log_debug_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEBUG, "#D Async read error 0x%08x", buf, 8u);
      }
    }
    else
    {
      *(void *)(v6 + 336) += a4;
      uint64_t v14 = *(const void **)(v6 + 144);
      if (v14)
      {
        uint64_t v15 = _Block_copy(v14);
        uint64_t v16 = *(void *)(v6 + 128);
        if (v16)
        {
          std::string __p = 0;
          unint64_t v29 = 0;
          uint64_t v30 = 0;
          (*(void (**)(uint64_t, void *, void, void **))(*(void *)v16 + 8))(v16, a3, a4, &__p);
          uint64_t v17 = *(NSObject **)(v6 + 152);
          if (v15) {
            char v18 = _Block_copy(v15);
          }
          else {
            char v18 = 0;
          }
          *(void *)stat buf = v18;
          long long v34 = 0;
          long long v35 = 0;
          uint64_t v36 = 0;
          uint64_t v22 = __p;
          size_t v23 = v29 - (unsigned char *)__p;
          if (v29 == __p)
          {
            uint64_t v25 = 0;
            uint64_t v24 = 0;
          }
          else
          {
            if ((v23 & 0x8000000000000000) != 0) {
              std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v24 = (char *)operator new(v29 - (unsigned char *)__p);
            uint64_t v25 = &v24[v23];
            long long v34 = v24;
            uint64_t v36 = &v24[v23];
            memcpy(v24, v22, v23);
            long long v35 = &v24[v23];
          }
          unint64_t v26 = operator new(0x20uLL);
          *unint64_t v26 = v18;
          v26[1] = v24;
          v26[2] = v25;
          v26[3] = v25;
          dispatch_async_f(v17, v26, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          if (__p)
          {
            unint64_t v29 = __p;
            operator delete(__p);
          }
        }
        else
        {
          char v19 = *(unsigned char *)(v6 + 136);
          long long v20 = *(NSObject **)(v6 + 152);
          if (v15) {
            uint64_t v21 = _Block_copy(v15);
          }
          else {
            uint64_t v21 = 0;
          }
          long long v27 = operator new(0x18uLL);
          *long long v27 = v21;
          v27[1] = a3;
          *((_DWORD *)v27 + 4) = a4;
          *((unsigned char *)v27 + 20) = v19;
          dispatch_async_f(v20, v27, (dispatch_function_t)_ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_);
          a3 = 0;
        }
        if (v15) {
          _Block_release(v15);
        }
      }
    }
    if (a3 && !*(unsigned char *)(v6 + 136)) {
      free(a3);
    }
    if (v11)
    {
      dispatch_group_leave(v11);
      dispatch_release(v11);
    }
  }
  else if (a3)
  {
    free(a3);
  }
  unint64_t v13 = v32;
  if (v32)
  {
    if (!atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void sub_1A61300F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *aBlock, void *a16, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

BOOL BasebandTransport::open(BasebandTransport *a1, long long *a2, void **a3)
{
  uint64_t v17 = 0;
  char v18 = &v17;
  uint64_t v19 = 0x2000000000;
  char v20 = 0;
  BasebandTransport::stopReader(a1);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 1174405120;
  v12[2] = ___ZN17BasebandTransport4openENS_10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke;
  v12[3] = &unk_1EFB0BC80;
  v12[5] = a1;
  long long v6 = a2[1];
  long long v13 = *a2;
  long long v14 = v6;
  uint64_t v15 = *((void *)a2 + 4);
  uint64_t v7 = *a3;
  if (*a3) {
    uint64_t v7 = _Block_copy(v7);
  }
  aBlocuint64_t k = v7;
  v12[4] = &v17;
  uint64_t v21 = v12;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = (char *)a1 + 72;
  void block[5] = &v21;
  uint64_t v8 = *((void *)a1 + 11);
  if (*((void *)a1 + 12))
  {
    dispatch_async_and_wait(v8, block);
    int v9 = *((unsigned __int8 *)v18 + 24);
    uint64_t v10 = aBlock;
    if (!aBlock) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  dispatch_sync(v8, block);
  int v9 = *((unsigned __int8 *)v18 + 24);
  uint64_t v10 = aBlock;
  if (aBlock) {
LABEL_7:
  }
    _Block_release(v10);
LABEL_8:
  _Block_object_dispose(&v17, 8);
  return v9 != 0;
}

void sub_1A6130300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void BasebandTransport::stopReader(BasebandTransport *this)
{
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2000000000;
  char v15 = 0;
  uint64_t v2 = (uint64_t *)((char *)this + 72);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  v13[2] = ___ZN17BasebandTransport10stopReaderEv_block_invoke;
  v13[3] = &unk_1E5C47528;
  v13[4] = v14;
  v13[5] = this;
  uint64_t v16 = v13;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = (char *)this + 72;
  void block[5] = &v16;
  uint64_t v4 = (char *)this + 88;
  int v3 = *((void *)this + 11);
  if (*((void *)v4 + 1)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  v12[2] = ___ZN17BasebandTransport10stopReaderEv_block_invoke_2;
  v12[3] = &unk_1E5C47550;
  v12[4] = v14;
  v12[5] = this;
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v2, (uint64_t)v12);
  uint64_t v5 = *((void *)this + 40);
  if (v5)
  {
    long long v6 = *((void *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Waiting for reader to be stopped", (uint8_t *)block, 2u);
      uint64_t v5 = *((void *)this + 40);
    }
    dispatch_time_t v7 = dispatch_time(0, 3000000000);
    if (dispatch_group_wait(v5, v7))
    {
      (*(void (**)(BasebandTransport *))(*(void *)this + 80))(this);
      uint64_t v8 = *((void *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(block[0]) = 0;
        _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Timeout waiting for read to unblock, freed transport to force read unblock", (uint8_t *)block, 2u);
      }
    }
    else
    {
      uint64_t v10 = (void *)*((void *)this + 37);
      if (v10)
      {
        operator delete[](v10);
        *((void *)this + 37) = 0;
        int v11 = *((void *)this + 39);
        *((void *)this + 39) = 0;
        if (v11) {
          dispatch_release(v11);
        }
      }
    }
    int v9 = *((void *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Reader stopped", (uint8_t *)block, 2u);
    }
  }
  _Block_object_dispose(v14, 8);
}

void sub_1A613059C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN17BasebandTransport4openENS_10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  int v3 = *(NSObject **)(v2 + 280);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v2 + 280));
    *(void *)(v2 + 280) = 0;
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9[0]) = 0;
      _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", (uint8_t *)v9, 2u);
    }
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 80))(v2);
  *(_DWORD *)(v2 + 328) = 0;
  *(unsigned char *)(v2 + 332) = 0;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 352) = 0u;
  *(void *)(v2 + 365) = 0;
  char v5 = *(unsigned char *)(a1 + 80);
  long long v6 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(v2 + 104) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(v2 + 120) = v6;
  *(unsigned char *)(v2 + 136) = v5;
  dispatch_time_t v7 = *(void **)(a1 + 88);
  if (v7) {
    dispatch_time_t v7 = _Block_copy(v7);
  }
  uint64_t v8 = *(const void **)(v2 + 144);
  *(void *)(v2 + 144) = v7;
  if (v8) {
    _Block_release(v8);
  }
  if (*(_DWORD *)(v2 + 104) != 23)
  {
    if (capabilities::ipc::supportsPCI((capabilities::ipc *)v7)) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = BasebandTransport::openPCI_sync((BasebandTransport *)v2);
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      BasebandTransport::timerOn_sync((BasebandTransport *)v2);
    }
    else {
      (*(void (**)(uint64_t))(*(void *)v2 + 80))(v2);
    }
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    v9[2] = ___ZN17BasebandTransport9dumpStateEb_block_invoke;
    v9[3] = &__block_descriptor_tmp_80;
    void v9[4] = v2;
    char v10 = 0;
    ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped((uint64_t *)(v2 + 72), (uint64_t)v9);
  }
}

uint64_t BasebandTransport::openPCI_sync(BasebandTransport *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (int v3 = std::__shared_weak_count::lock(v2)) == 0) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v4 = v3;
  atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
  }
  inited = (capabilities::abs *)TelephonyBasebandPCITransportInitParameters();
  int v6 = *((_DWORD *)this + 28);
  uint64_t shouldUseMinBasebandTransportIOReadCount = capabilities::abs::traceTransportTimeoutScalingFactor(inited);
  int v8 = 1000 * v6;
  if ((((1000 * v6) * (unint64_t)shouldUseMinBasebandTransportIOReadCount) & 0xFFFFFFFF00000000) != 0)
  {
    int v9 = *((void *)this + 5);
    uint64_t shouldUseMinBasebandTransportIOReadCount = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (shouldUseMinBasebandTransportIOReadCount)
    {
      *(_DWORD *)stat buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Scaled create timeout overflowed, falling back to unscaled value: %u", buf, 8u);
    }
  }
  int v10 = *((_DWORD *)this + 31);
  if (v10) {
    goto LABEL_16;
  }
  int v11 = *((_DWORD *)this + 26);
  uint64_t shouldUseMinBasebandTransportIOReadCount = capabilities::abs::shouldUseMinBasebandTransportIOReadCount((capabilities::abs *)shouldUseMinBasebandTransportIOReadCount);
  if (shouldUseMinBasebandTransportIOReadCount) {
    goto LABEL_10;
  }
  if (v11 != 2)
  {
    if (v11 != 16 && v11 != 15)
    {
LABEL_10:
      unsigned int v27 = 4;
      unsigned int v12 = *((_DWORD *)this + 30);
      if (!v12) {
        goto LABEL_17;
      }
      goto LABEL_20;
    }
    int v10 = 36;
LABEL_16:
    unsigned int v27 = v10;
    unsigned int v12 = *((_DWORD *)this + 30);
    if (!v12) {
      goto LABEL_17;
    }
    goto LABEL_20;
  }
  unsigned int v27 = 16;
  unsigned int v12 = *((_DWORD *)this + 30);
  if (!v12)
  {
LABEL_17:
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)shouldUseMinBasebandTransportIOReadCount)) {
      unsigned int v12 = 0x4000;
    }
    else {
      unsigned int v12 = 0x8000;
    }
  }
LABEL_20:
  unsigned int v28 = v12;
  int v13 = *((_DWORD *)this + 26);
  switch(v13)
  {
    case 0:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 1:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 2:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 3:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 4:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 5:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 6:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 7:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 8:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 9:
    case 17:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 10:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 11:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 12:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 13:
    case 18:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 14:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 15:
      uint64_t v14 = v27;
      if (v27 < 0x41) {
        goto LABEL_56;
      }
      goto LABEL_26;
    case 16:
      uint64_t v14 = v27;
      if (v27 >= 0x41)
      {
LABEL_26:
        char v15 = *((void *)this + 5);
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          goto LABEL_144;
        }
        switch(v13)
        {
          case 0:
            char v30 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            char v30 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            char v30 = 4;
            int v24 = 1195460932;
            goto LABEL_118;
          case 3:
            char v30 = 4;
            int v24 = 1397114194;
            goto LABEL_118;
          case 4:
            char v30 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            char v30 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            char v30 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            char v30 = 4;
            int v24 = 1414483778;
            goto LABEL_118;
          case 8:
            char v30 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            char v30 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 10:
            char v30 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 11:
            char v30 = 4;
            int v24 = 1280328769;
            goto LABEL_118;
          case 12:
            char v30 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 13:
            char v30 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 14:
            char v30 = 4;
            int v24 = 1397968455;
            goto LABEL_118;
          case 15:
            char v30 = 4;
            int v24 = 1397965905;
            goto LABEL_118;
          case 16:
            char v30 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 17:
            char v30 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 18:
            char v30 = 4;
            int v24 = 1297040214;
LABEL_118:
            *(_DWORD *)stat buf = v24;
            uint8_t buf[4] = 0;
            break;
          default:
            char v30 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)uint64_t v31 = 136315394;
        long long v32 = buf;
        __int16 v33 = 2048;
        uint64_t v34 = v14;
        char v20 = "%s: invalid transport io read count (%lu)";
LABEL_141:
        uint64_t v21 = v15;
        uint32_t v22 = 22;
LABEL_142:
        _os_log_error_impl(&dword_1A609F000, v21, OS_LOG_TYPE_ERROR, v20, v31, v22);
        if (v30 < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_144;
      }
LABEL_56:
      if (v12 - 0x4000 > 0xFC000)
      {
        char v15 = *((void *)this + 5);
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          goto LABEL_144;
        }
        switch(v13)
        {
          case 0:
            char v30 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            char v30 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            char v30 = 4;
            int v25 = 1195460932;
            goto LABEL_139;
          case 3:
            char v30 = 4;
            int v25 = 1397114194;
            goto LABEL_139;
          case 4:
            char v30 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            char v30 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            char v30 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            char v30 = 4;
            int v25 = 1414483778;
            goto LABEL_139;
          case 8:
            char v30 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            char v30 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 10:
            char v30 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 11:
            char v30 = 4;
            int v25 = 1280328769;
            goto LABEL_139;
          case 12:
            char v30 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 13:
            char v30 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 14:
            char v30 = 4;
            int v25 = 1397968455;
            goto LABEL_139;
          case 15:
            char v30 = 4;
            int v25 = 1397965905;
            goto LABEL_139;
          case 16:
            char v30 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 17:
            char v30 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 18:
            char v30 = 4;
            int v25 = 1297040214;
LABEL_139:
            *(_DWORD *)stat buf = v25;
            uint8_t buf[4] = 0;
            break;
          default:
            char v30 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)uint64_t v31 = 136315394;
        long long v32 = buf;
        __int16 v33 = 2048;
        uint64_t v34 = v12;
        char v20 = "%s: invalid transport io read size (%lu)";
        goto LABEL_141;
      }
      if (*((void *)this + 18)) {
        *((unsigned char *)this + 332) = 1;
      }
      if (!TelephonyBasebandPCITransportCreate())
      {
        *((_DWORD *)this + 82) = 2;
        char v18 = *((void *)this + 5);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          BasebandTransport::asString(*((unsigned int *)this + 26), (char *)buf);
          if (v30 >= 0) {
            uint64_t v19 = buf;
          }
          else {
            uint64_t v19 = *(uint8_t **)buf;
          }
          *(_DWORD *)uint64_t v31 = 136315138;
          long long v32 = v19;
          char v20 = "%s: transport open failed";
          uint64_t v21 = v18;
          uint32_t v22 = 12;
          goto LABEL_142;
        }
LABEL_144:
        uint64_t v16 = 0;
        goto LABEL_145;
      }
      uint64_t v16 = 1;
      *((_DWORD *)this + 82) = 1;
      uint64_t v17 = *((void *)this + 5);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        switch(*((_DWORD *)this + 26))
        {
          case 0:
            char v30 = 3;
            strcpy((char *)buf, "PBL");
            break;
          case 1:
            char v30 = 3;
            strcpy((char *)buf, "SBL");
            break;
          case 2:
            char v30 = 4;
            int v23 = 1195460932;
            goto LABEL_93;
          case 3:
            char v30 = 4;
            int v23 = 1397114194;
            goto LABEL_93;
          case 4:
            char v30 = 5;
            strcpy((char *)buf, "QMUX1");
            break;
          case 5:
            char v30 = 5;
            strcpy((char *)buf, "QMUX2");
            break;
          case 6:
            char v30 = 3;
            strcpy((char *)buf, "ROM");
            break;
          case 7:
            char v30 = 4;
            int v23 = 1414483778;
            goto LABEL_93;
          case 8:
            char v30 = 3;
            strcpy((char *)buf, "ARI");
            break;
          case 9:
            char v30 = 3;
            strcpy((char *)buf, "STT");
            break;
          case 0xA:
            char v30 = 2;
            strcpy((char *)buf, "AT");
            break;
          case 0xB:
            char v30 = 4;
            int v23 = 1280328769;
            goto LABEL_93;
          case 0xC:
            char v30 = 8;
            strcpy((char *)buf, "MEDIACTL");
            break;
          case 0xD:
            char v30 = 3;
            strcpy((char *)buf, "ETS");
            break;
          case 0xE:
            char v30 = 4;
            int v23 = 1397968455;
            goto LABEL_93;
          case 0xF:
            char v30 = 4;
            int v23 = 1397965905;
            goto LABEL_93;
          case 0x10:
            char v30 = 5;
            strcpy((char *)buf, "RCTTH");
            break;
          case 0x11:
            char v30 = 3;
            strcpy((char *)buf, "ACP");
            break;
          case 0x12:
            char v30 = 4;
            int v23 = 1297040214;
            goto LABEL_93;
          case 0x13:
            char v30 = 4;
            int v23 = 1129335117;
LABEL_93:
            *(_DWORD *)stat buf = v23;
            uint8_t buf[4] = 0;
            break;
          case 0x14:
            char v30 = 3;
            strcpy((char *)buf, "DHL");
            break;
          case 0x15:
            char v30 = 3;
            strcpy((char *)buf, "MUX");
            break;
          case 0x16:
            char v30 = 3;
            strcpy((char *)buf, "FAC");
            break;
          default:
            char v30 = 7;
            strcpy((char *)buf, "Unknown");
            break;
        }
        *(_DWORD *)uint64_t v31 = 136315394;
        long long v32 = buf;
        __int16 v33 = 1024;
        LODWORD(v34) = v28;
        _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I %s: transport successfully opened with read io size as %u", v31, 0x12u);
        if (v30 < 0) {
          operator delete(*(void **)buf);
        }
      }
LABEL_145:
      std::__shared_weak_count::__release_weak(v4);
      return v16;
    default:
      goto LABEL_144;
  }
}

void sub_1A6131450(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_1A6131464(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void BasebandTransport::timerOn_sync(BasebandTransport *this)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 35);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((void *)this + 35) = 0;
    int v3 = *((void *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", buf, 2u);
    }
  }
  if (*((_DWORD *)this + 82) == 1)
  {
    unsigned int v4 = *((_DWORD *)this + 72);
    if (v4 && *((void *)this + 34))
    {
      uint64_t v5 = 1000000000 * v4;
      int v6 = dispatch_source_create(MEMORY[0x1E4F14490], 1uLL, 0, *((dispatch_queue_t *)this + 11));
      *((void *)this + 35) = v6;
      dispatch_time_t v7 = dispatch_time(0, v5);
      dispatch_source_set_timer(v6, v7, v5, 0xBEBC200uLL);
      int v8 = (std::__shared_weak_count *)*((void *)this + 10);
      if (!v8 || (uint64_t v9 = *((void *)this + 9), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      int v11 = v10;
      p_shared_weak_owners = &v10->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v11);
      }
      int v13 = *((void *)this + 35);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 1174405120;
      handler[2] = ___ZN17BasebandTransport12timerOn_syncEv_block_invoke;
      handler[3] = &__block_descriptor_tmp_79_0;
      handler[4] = this;
      handler[5] = v9;
      char v18 = v11;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      dispatch_source_set_event_handler(v13, handler);
      dispatch_activate(*((dispatch_object_t *)this + 35));
      uint64_t v14 = *((void *)this + 5);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = *((_DWORD *)this + 72);
        *(_DWORD *)stat buf = 67109120;
        int v20 = v15;
        _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Status report enabled(%d sec)", buf, 8u);
      }
      if (v18) {
        std::__shared_weak_count::__release_weak(v18);
      }
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
    uint64_t v16 = *((void *)this + 5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Invalid state for status report enable.  Ignoring enable request.", buf, 2u);
    }
  }
}

void BasebandTransport::dumpState(BasebandTransport *this, char a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 0x40000000;
  v2[2] = ___ZN17BasebandTransport9dumpStateEb_block_invoke;
  v2[3] = &__block_descriptor_tmp_80;
  v2[4] = this;
  char v3 = a2;
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped((uint64_t *)this + 9, (uint64_t)v2);
}

void *__copy_helper_block_e8_88c45_ZTSN8dispatch5blockIU13block_pointerFvPhjEEE(uint64_t a1, uint64_t a2)
{
  int64x2_t result = *(void **)(a2 + 88);
  if (result) {
    int64x2_t result = _Block_copy(result);
  }
  *(void *)(a1 + 88) = result;
  return result;
}

void __destroy_helper_block_e8_88c45_ZTSN8dispatch5blockIU13block_pointerFvPhjEEE(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 88);
  if (v1) {
    _Block_release(v1);
  }
}

BOOL BasebandTransport::write(BasebandTransport *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v39 = 0;
  uint64_t v40 = &v39;
  uint64_t v41 = 0x2000000000;
  char v42 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = &v35;
  uint64_t v37 = 0x2000000000;
  uint64_t v38 = 0;
  dispatch_time_t v7 = (char *)this + 72;
  v34[0] = MEMORY[0x1E4F143A8];
  v34[1] = 0x40000000;
  void v34[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke;
  v34[3] = &unk_1E5C473F8;
  v34[5] = &v39;
  v34[6] = this;
  v34[4] = &v35;
  uint64_t v44 = v34;
  blocuint64_t k = MEMORY[0x1E4F143A8];
  p_blocuint64_t k = 0x40000000;
  uint64_t v28 = (uint64_t)___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  unint64_t v29 = (__n128 (*)(void *, uint64_t))&__block_descriptor_tmp_98;
  char v30 = (void (*)(uint64_t))((char *)this + 72);
  std::string __p = &v44;
  uint64_t v9 = (char *)this + 88;
  int v8 = *((void *)this + 11);
  if (*((void *)v9 + 1))
  {
    dispatch_async_and_wait(v8, &block);
    if (*((unsigned char *)v40 + 24)) {
      goto LABEL_3;
    }
LABEL_10:
    BOOL v14 = 0;
    goto LABEL_19;
  }
  dispatch_sync(v8, &block);
  if (!*((unsigned char *)v40 + 24)) {
    goto LABEL_10;
  }
LABEL_3:
  blocuint64_t k = 0;
  p_blocuint64_t k = (uint64_t)&block;
  uint64_t v28 = 0x4002000000;
  unint64_t v29 = __Block_byref_object_copy_;
  char v30 = __Block_byref_object_dispose_;
  std::string __p = 0;
  long long v32 = 0;
  uint64_t v33 = 0;
  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x2000000000;
  int v25 = a2;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = a3;
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  v17[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_54;
  v17[3] = &unk_1E5C47420;
  v17[8] = a2;
  v17[9] = a3;
  v17[4] = &block;
  v17[5] = &v22;
  v17[6] = &v18;
  v17[7] = this;
  xpc_object_t v43 = v17;
  uint64_t v44 = (void *)MEMORY[0x1E4F143A8];
  uint64_t v45 = 0x40000000;
  xpc_object_t v46 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  char v47 = &__block_descriptor_tmp_98;
  char v48 = v7;
  xpc_object_t v49 = &v43;
  int v10 = *((void *)this + 11);
  if (*((void *)this + 12))
  {
    dispatch_async_and_wait(v10, &v44);
    if (v19[3]) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_sync(v10, &v44);
    if (v19[3])
    {
LABEL_5:
      int v11 = (uint64_t (**)(void, uint64_t))v36[3];
      if (*v11)
      {
        int v12 = (*v11)(v11, v23[3]);
        *((unsigned char *)v40 + 24) = v12;
        if (v12)
        {
          v16[0] = MEMORY[0x1E4F143A8];
          v16[1] = 0x40000000;
          void v16[2] = ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_2;
          v16[3] = &unk_1E5C47448;
          v16[4] = &v18;
          v16[5] = this;
          xpc_object_t v43 = v16;
          uint64_t v44 = (void *)MEMORY[0x1E4F143A8];
          uint64_t v45 = 0x40000000;
          xpc_object_t v46 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
          char v47 = &__block_descriptor_tmp_98;
          char v48 = v7;
          xpc_object_t v49 = &v43;
          int v13 = *((void *)this + 11);
          if (*((void *)this + 12)) {
            dispatch_async_and_wait(v13, &v44);
          }
          else {
            dispatch_sync(v13, &v44);
          }
          BOOL v14 = *((unsigned char *)v40 + 24) != 0;
        }
        else
        {
          BOOL v14 = 0;
        }
      }
      else
      {
        BOOL v14 = 0;
        *((unsigned char *)v40 + 24) = 0;
      }
      goto LABEL_17;
    }
  }
  BOOL v14 = 1;
LABEL_17:
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&block, 8);
  if (__p)
  {
    long long v32 = __p;
    operator delete(__p);
  }
LABEL_19:
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v39, 8);
  return v14;
}

void sub_1A6131CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  if (__p)
  {
    a39 = (uint64_t)__p;
    operator delete(__p);
  }
  _Block_object_dispose((const void *)(v39 - 216), 8);
  _Block_object_dispose((const void *)(v39 - 184), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  *(void *)(*(void *)(a1[4] + 8) + 24) = v2 + 176;
  char v3 = *(uint64_t (**)(void))(v2 + 232);
  if (v3)
  {
    uint64_t result = v3();
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = result;
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
  }
  return result;
}

__n128 __Block_byref_object_copy_(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

uint64_t (***___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_54(void *a1))(void, void, void, uint64_t)
{
  __n128 result = *(uint64_t (****)(void, void, void, uint64_t))(a1[7] + 128);
  if (result)
  {
    __n128 result = (uint64_t (***)(void, void, void, uint64_t))(**result)(result, a1[8], a1[9], *(void *)(a1[4] + 8) + 40);
    *(void *)(*(void *)(a1[5] + 8) + 24) = *(void *)(*(void *)(a1[4] + 8) + 40);
    *(void *)(*(void *)(a1[6] + 8) + 24) = *(void *)(*(void *)(a1[4] + 8) + 48)
                                                 - *(void *)(*(void *)(a1[4] + 8) + 40);
  }
  return result;
}

void ___ZN17BasebandTransport5writeEPKhmPjbj_block_invoke_2(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(v2 + 344) + *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  *(void *)(v2 + 344) = v3;
  unsigned int v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v6 = 134218240;
    uint64_t v7 = v5;
    __int16 v8 = 2048;
    uint64_t v9 = v3;
    _os_log_debug_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEBUG, "#D Written: %zu bytes, for a total of: %llu", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t BasebandTransport::read(BasebandTransport *this, unsigned __int8 *a2, unint64_t a3, unsigned int *a4)
{
  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x2000000000;
  char v25 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  int v6 = (uint64_t *)((char *)this + 72);
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 0x40000000;
  v17[2] = ___ZN17BasebandTransport4readEPhmPjbj_block_invoke;
  v17[3] = &unk_1E5C47470;
  v17[5] = &v22;
  v17[6] = this;
  v17[4] = &v18;
  unint64_t v26 = v17;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = (char *)this + 72;
  void block[5] = &v26;
  __int16 v8 = (char *)this + 88;
  uint64_t v7 = *((void *)this + 11);
  if (*((void *)v8 + 1))
  {
    dispatch_async_and_wait(v7, block);
    uint64_t v9 = v23;
    if (!*((unsigned char *)v23 + 24)) {
      goto LABEL_13;
    }
LABEL_5:
    uint64_t v10 = v19[3];
    if (v10 && (int v11 = *(uint64_t (**)(void))(v10 + 8)) != 0)
    {
      char v12 = v11();
      *((unsigned char *)v23 + 24) = v12;
      if (v12)
      {
        v16[0] = MEMORY[0x1E4F143A8];
        v16[1] = 0x40000000;
        void v16[2] = ___ZN17BasebandTransport4readEPhmPjbj_block_invoke_58;
        v16[3] = &__block_descriptor_tmp_59;
        v16[4] = this;
        v16[5] = a4;
        ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v6, (uint64_t)v16);
        goto LABEL_13;
      }
      int v13 = *(void (**)(void))(v19[3] + 24);
      if (!v13) {
        goto LABEL_13;
      }
    }
    else
    {
      *((unsigned char *)v9 + 24) = 0;
      int v13 = *(void (**)(void))(v10 + 24);
      if (!v13) {
        goto LABEL_13;
      }
    }
    v13();
    goto LABEL_13;
  }
  dispatch_sync(v7, block);
  uint64_t v9 = v23;
  if (*((unsigned char *)v23 + 24)) {
    goto LABEL_5;
  }
LABEL_13:
  uint64_t v14 = *((unsigned __int8 *)v23 + 24);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v14;
}

void sub_1A613216C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void ___ZN17BasebandTransport4readEPhmPjbj_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  *(void *)(*(void *)(a1[4] + 8) + 24) = v2 + 176;
  uint64_t v3 = *(unsigned int (**)(void))(v2 + 232);
  if (v3)
  {
    if (!v3())
    {
      *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
      if (!*(unsigned char *)(v2 + 332)) {
        return;
      }
      goto LABEL_7;
    }
    LOBYTE(v3) = *(unsigned char *)(v2 + 332) == 0;
  }
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = (_BYTE)v3;
  if (!*(unsigned char *)(v2 + 332)) {
    return;
  }
LABEL_7:
  unsigned int v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Explicit reads not allowed in async mode", v5, 2u);
  }
}

uint64_t ___ZN17BasebandTransport4readEPhmPjbj_block_invoke_58(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 336) += **(unsigned int **)(result + 40);
  return result;
}

uint64_t BasebandTransport::close(BasebandTransport *this)
{
  uint64_t v10 = 0;
  int v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 1;
  *((_DWORD *)this + 72) = 0;
  uint64_t v2 = (char *)this + 72;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  v9[2] = ___ZN17BasebandTransport5closeEv_block_invoke;
  v9[3] = &__block_descriptor_tmp_60_0;
  void v9[4] = this;
  uint64_t v14 = v9;
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v16 = 0x40000000;
  uint64_t v17 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  uint64_t v18 = &__block_descriptor_tmp_98;
  uint64_t v19 = (char *)this + 72;
  uint64_t v20 = &v14;
  unsigned int v4 = (char *)this + 88;
  uint64_t v3 = *((void *)this + 11);
  if (*((void *)v4 + 1)) {
    dispatch_async_and_wait(v3, &block);
  }
  else {
    dispatch_sync(v3, &block);
  }
  BasebandTransport::stopReader(this);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = ___ZN17BasebandTransport5closeEv_block_invoke_2;
  v8[3] = &unk_1E5C474D8;
  v8[4] = &v10;
  v8[5] = this;
  uint64_t v14 = v8;
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v16 = 0x40000000;
  uint64_t v17 = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  uint64_t v18 = &__block_descriptor_tmp_98;
  uint64_t v19 = v2;
  uint64_t v20 = &v14;
  uint64_t v5 = *((void *)this + 11);
  if (*((void *)this + 12)) {
    dispatch_async_and_wait(v5, &block);
  }
  else {
    dispatch_sync(v5, &block);
  }
  uint64_t v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v6;
}

void sub_1A6132438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN17BasebandTransport5closeEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 280);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(v1 + 280));
    *(void *)(v1 + 280) = 0;
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Status report disabled", v4, 2u);
    }
  }
}

uint64_t ___ZN17BasebandTransport5closeEv_block_invoke_2(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 80))(*(void *)(a1 + 40));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t BasebandTransport::operator*(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZN17BasebandTransportdeEv_block_invoke;
  v5[3] = &unk_1E5C47500;
  v5[4] = &v6;
  void v5[5] = a1;
  uint64_t v10 = v5;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = a1 + 72;
  void block[5] = &v10;
  uint64_t v2 = a1 + 88;
  uint64_t v1 = *(NSObject **)(a1 + 88);
  if (*(void *)(v2 + 8)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZN17BasebandTransportdeEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(result + 40) + 176;
  return result;
}

uint64_t BasebandTransport::switchDIAG_sync(BasebandTransport *this)
{
  return 0;
}

uint64_t BasebandTransport::getIOSizeRx(BasebandTransport *this)
{
  return *((unsigned int *)this + 30);
}

uint64_t BasebandTransport::close_sync(BasebandTransport *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 29);
  if (v2 && (uint64_t v3 = (_OWORD *)((char *)this + 176), v2((char *)this + 176)))
  {
    *((_DWORD *)this + 82) = 0;
    uint64_t v4 = TelephonyUtilTransportFree();
    _OWORD *v3 = 0u;
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 13) = 0u;
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
    *((void *)this + 32) = 0;
    uint64_t v5 = *((void *)this + 5);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return v4;
    }
  }
  else
  {
    uint64_t v4 = 1;
    uint64_t v5 = *((void *)this + 5);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return v4;
    }
  }
  switch(*((_DWORD *)this + 26))
  {
    case 0:
      char v10 = 3;
      LODWORD(__p[0]) = 4997712;
      break;
    case 1:
      char v10 = 3;
      LODWORD(__p[0]) = 4997715;
      break;
    case 2:
      char v10 = 4;
      int v6 = 1195460932;
      goto LABEL_28;
    case 3:
      char v10 = 4;
      int v6 = 1397114194;
      goto LABEL_28;
    case 4:
      char v10 = 5;
      strcpy((char *)__p, "QMUX1");
      break;
    case 5:
      char v10 = 5;
      strcpy((char *)__p, "QMUX2");
      break;
    case 6:
      char v10 = 3;
      LODWORD(__p[0]) = 5066578;
      break;
    case 7:
      char v10 = 4;
      int v6 = 1414483778;
      goto LABEL_28;
    case 8:
      char v10 = 3;
      LODWORD(__p[0]) = 4805185;
      break;
    case 9:
      char v10 = 3;
      LODWORD(__p[0]) = 5526611;
      break;
    case 0xA:
      char v10 = 2;
      strcpy((char *)__p, "AT");
      break;
    case 0xB:
      char v10 = 4;
      int v6 = 1280328769;
      goto LABEL_28;
    case 0xC:
      char v10 = 8;
      strcpy((char *)__p, "MEDIACTL");
      break;
    case 0xD:
      char v10 = 3;
      LODWORD(__p[0]) = 5461061;
      break;
    case 0xE:
      char v10 = 4;
      int v6 = 1397968455;
      goto LABEL_28;
    case 0xF:
      char v10 = 4;
      int v6 = 1397965905;
      goto LABEL_28;
    case 0x10:
      char v10 = 5;
      strcpy((char *)__p, "RCTTH");
      break;
    case 0x11:
      char v10 = 3;
      LODWORD(__p[0]) = 5260097;
      break;
    case 0x12:
      char v10 = 4;
      int v6 = 1297040214;
      goto LABEL_28;
    case 0x13:
      char v10 = 4;
      int v6 = 1129335117;
LABEL_28:
      LODWORD(__p[0]) = v6;
      BYTE4(__p[0]) = 0;
      break;
    case 0x14:
      char v10 = 3;
      LODWORD(__p[0]) = 4999236;
      break;
    case 0x15:
      char v10 = 3;
      LODWORD(__p[0]) = 5789005;
      break;
    case 0x16:
      char v10 = 3;
      LODWORD(__p[0]) = 4407622;
      break;
    default:
      char v10 = 7;
      strcpy((char *)__p, "Unknown");
      break;
  }
  uint64_t v7 = "error";
  if (v4) {
    uint64_t v7 = "success";
  }
  *(_DWORD *)stat buf = 136315394;
  uint64_t v12 = __p;
  __int16 v13 = 2080;
  uint64_t v14 = v7;
  _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Transport close %s: %s", buf, 0x16u);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t BasebandTransport::startReader_sync(NSObject **this)
{
  if (!this[37])
  {
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)this)) {
      size_t v2 = 0x4000;
    }
    else {
      size_t v2 = 0x8000;
    }
    this[38] = v2;
    this[37] = operator new[](v2);
    dispatch_queue_t v3 = dispatch_queue_create("ipc.bb", 0);
    uint64_t v4 = this[39];
    this[39] = v3;
    if (v4) {
      dispatch_release(v4);
    }
  }
  *((unsigned char *)this + 292) = 1;
  *((unsigned char *)this + 332) = 1;
  BasebandTransport::queueRead_sync((BasebandTransport *)this);
  return *((unsigned __int8 *)this + 292);
}

void BasebandTransport::queueRead_sync(BasebandTransport *this)
{
  size_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (v3 = *((void *)this + 9), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v5 = v4;
  int v6 = *((void *)this + 40);
  if (v6)
  {
    dispatch_retain(*((dispatch_object_t *)this + 40));
    dispatch_group_enter(v6);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 1174405120;
  v8[2] = ___ZN17BasebandTransport14queueRead_syncEv_block_invoke;
  v8[3] = &__block_descriptor_tmp_67_1;
  v8[4] = this;
  v8[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_group_t group = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(group);
  }
  dispatch_async(*((dispatch_queue_t *)this + 39), v8);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v7 = v9;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t ___ZN17BasebandTransport10stopReaderEv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(v1 + 292);
  *(unsigned char *)(v1 + 292) = 0;
  *(unsigned char *)(v1 + 332) = 0;
  return result;
}

uint64_t ___ZN17BasebandTransport10stopReaderEv_block_invoke_2(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  size_t v2 = *(uint64_t (**)(uint64_t))(v1 + 232);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t result = v2(v1 + 176);
    if (result)
    {
      if (*(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + 24))
      {
        uint64_t v4 = *(uint64_t (**)(uint64_t))(v1 + 192);
        if (v4)
        {
          return v4(v1 + 176);
        }
      }
    }
  }
  return result;
}

void ___ZN17BasebandTransport14queueRead_syncEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  size_t v2 = *(NSObject **)(a1 + 56);
  uint64_t v3 = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  BasebandTransport::read_sync(v1, &v3);
  if (v2)
  {
    dispatch_group_leave(v2);
    dispatch_release(v2);
  }
}

void sub_1A6132DA8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void BasebandTransport::read_sync(uint64_t a1, NSObject **a2)
{
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v5 = (uint64_t *)(a1 + 72);
  uint64_t v28 = v6;
  if (!v4 || (v8 = std::__shared_weak_count::lock(v4), (unint64_t v29 = v8) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v27 = 0;
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, void, uint64_t, void))(a1 + 184);
  if (v9)
  {
    char v10 = v8;
    uint64_t v11 = *(void *)(a1 + 296);
    uint64_t v12 = capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v8)
        ? 0x4000
        : 0x8000;
    int v13 = v9(a1 + 176, v11, v12, &v27, 0, 0xFFFFFFFFLL, 0);
    int v14 = v27 ? v13 : 0;
    if (v14 == 1)
    {
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 0x40000000;
      v25[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke;
      v25[3] = &__block_descriptor_tmp_68;
      v25[4] = a1;
      int v26 = v27;
      ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v5, (uint64_t)v25);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 1174405120;
      block[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_2;
      block[3] = &__block_descriptor_tmp_71;
      void block[4] = a1;
      void block[5] = v6;
      uint64_t v22 = v10;
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v15 = *a2;
      dispatch_group_t group = v15;
      if (v15)
      {
        dispatch_retain(v15);
        dispatch_group_enter(group);
      }
      int v24 = v27;
      dispatch_sync(*(dispatch_queue_t *)(a1 + 152), block);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      uint64_t v16 = v22;
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 1174405120;
  v19[2] = ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_72;
  void v19[3] = &__block_descriptor_tmp_73_0;
  v19[4] = a1;
  v19[5] = v28;
  uint64_t v20 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(v5, (uint64_t)v19);
  uint64_t v17 = v20;
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v18 = v29;
  if (v29)
  {
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_1A61330C8(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 96);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE56c30_ZTSN8dispatch13group_sessionE(void *a1, void *a2)
{
  uint64_t v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[7];
  a1[7] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[7];
    if (v5)
    {
      dispatch_group_enter(v5);
    }
  }
}

void __destroy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE56c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  size_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 336) += *(unsigned int *)(result + 40);
  return result;
}

void ___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_2(uint64_t a1)
{
  size_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[16];
  if (v3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    (*(void (**)(uint64_t, void, void, void **))(*(void *)v3 + 8))(v3, v2[37], *(unsigned int *)(a1 + 64), &__p);
    (*(void (**)(void))(v2[18] + 16))();
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v4 = *(void (**)(void))(v2[18] + 16);
    v4();
  }
}

void sub_1A61332C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BasebandTransport *___ZN17BasebandTransport9read_syncEN8dispatch13group_sessionE_block_invoke_72(uint64_t a1)
{
  uint64_t result = *(BasebandTransport **)(a1 + 32);
  if (*((unsigned char *)result + 292)) {
    return (BasebandTransport *)BasebandTransport::queueRead_sync(result);
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c45_ZTSNSt3__110shared_ptrI17BasebandTransportEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN17BasebandTransport12timerOn_syncEv_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2) {
    return;
  }
  uint64_t v3 = a1[4];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[5];
  if (!v6) {
    goto LABEL_14;
  }
  uint64_t v7 = (int *)(v3 + 328);
  uint64_t v8 = *(void *)(v3 + 336);
  uint64_t v9 = *(void *)(v3 + 376);
  uint64_t v10 = *(void *)(v3 + 344) - *(void *)(v3 + 384);
  *(void *)(v3 + 352) = v8 - v9;
  *(void *)(v3 + 360) = v10;
  if (v10) {
    BOOL v11 = 0;
  }
  else {
    BOOL v11 = v8 == v9;
  }
  if (v11)
  {
    int v12 = 3;
  }
  else
  {
    if (*v7 != 3) {
      goto LABEL_12;
    }
    int v12 = 1;
  }
  *uint64_t v7 = v12;
LABEL_12:
  long long v13 = *(_OWORD *)(v3 + 344);
  *(_OWORD *)(v3 + 368) = *(_OWORD *)v7;
  *(_OWORD *)(v3 + 384) = v13;
  *(void *)(v3 + 400) = *(void *)(v3 + 360);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 1174405120;
  block[2] = ___ZN17BasebandTransport12timerOn_syncEv_block_invoke_2;
  block[3] = &__block_descriptor_tmp_76_1;
  void block[4] = v3;
  void block[5] = v6;
  uint64_t v16 = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_async(*(dispatch_queue_t *)(v3 + 152), block);
  int v14 = v16;
  if (!v16 || atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_14:
    if (atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
LABEL_17:
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
  std::__shared_weak_count::__release_weak(v14);
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_17;
  }
}

uint64_t ___ZN17BasebandTransport12timerOn_syncEv_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v5 + 272);
  uint64_t v10 = *(void *)(v5 + 400);
  long long v7 = *(_OWORD *)(v5 + 384);
  v9[0] = *(_OWORD *)(v5 + 368);
  v9[1] = v7;
  return (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(v6 + 16))(v6, v9, a3, a4, a5);
}

__n128 BasebandTransport::getStatus@<Q0>(BasebandTransport *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = *((void *)this + 45);
  __n128 result = *(__n128 *)((char *)this + 328);
  long long v3 = *(_OWORD *)((char *)this + 344);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

void ___ZN17BasebandTransport9dumpStateEb_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  *(int64x2_t *)(v2 + 352) = vsubq_s64(*(int64x2_t *)(v2 + 336), *(int64x2_t *)(v2 + 376));
  long long v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    BasebandTransport::Parameters::toString((BasebandTransport::Parameters *)(v2 + 104), __p);
    if (v7 >= 0) {
      uint64_t v4 = __p;
    }
    else {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)stat buf = 136315138;
    uint64_t v9 = v4;
    _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    long long v3 = *(NSObject **)(v2 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)
    && ((BasebandTransport::Status::toString((BasebandTransport::Status *)(v2 + 328), __p), v7 >= 0)
      ? (uint64_t v5 = __p)
      : (uint64_t v5 = (void **)__p[0]),
        *(_DWORD *)stat buf = 136315138,
        uint64_t v9 = v5,
        _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu),
        v7 < 0))
  {
    operator delete(__p[0]);
    if (!*(unsigned char *)(a1 + 40)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 40))
  {
    return;
  }
  *(_DWORD *)(v2 + 328) = 0;
  *(unsigned char *)(v2 + 332) = 0;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 336) = 0u;
  *(_OWORD *)(v2 + 352) = 0u;
  *(void *)(v2 + 365) = 0;
  BasebandTransport::timerOn_sync((BasebandTransport *)v2);
}

void BasebandTransport::reportStatus(uint64_t a1, int a2, void **a3)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 1174405120;
  v7[2] = ___ZN17BasebandTransport12reportStatusEjN8dispatch5blockIU13block_pointerFvNS_6StatusEEEE_block_invoke;
  v7[3] = &__block_descriptor_tmp_81;
  v7[4] = a1;
  int v9 = a2;
  uint64_t v4 = *a3;
  if (*a3) {
    uint64_t v4 = _Block_copy(v4);
  }
  aBlocuint64_t k = v4;
  uint64_t v10 = v7;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_98;
  void block[4] = a1 + 72;
  void block[5] = &v10;
  uint64_t v5 = *(NSObject **)(a1 + 88);
  if (!*(void *)(a1 + 96))
  {
    dispatch_sync(v5, block);
    uint64_t v6 = aBlock;
    if (!aBlock) {
      return;
    }
    goto LABEL_7;
  }
  dispatch_async_and_wait(v5, block);
  uint64_t v6 = aBlock;
  if (aBlock) {
LABEL_7:
  }
    _Block_release(v6);
}

void ___ZN17BasebandTransport12reportStatusEjN8dispatch5blockIU13block_pointerFvNS_6StatusEEEE_block_invoke(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  *(_DWORD *)(v3 + 288) = v1;
  if (v2) {
    uint64_t v2 = _Block_copy(v2);
  }
  uint64_t v4 = *(const void **)(v3 + 272);
  *(void *)(v3 + 272) = v2;
  if (v4) {
    _Block_release(v4);
  }

  BasebandTransport::timerOn_sync((BasebandTransport *)v3);
}

void *__copy_helper_block_e8_40c70_ZTSN8dispatch5blockIU13block_pointerFvN17BasebandTransport6StatusEEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)(a2 + 40);
  if (result) {
    __n128 result = _Block_copy(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_e8_40c70_ZTSN8dispatch5blockIU13block_pointerFvN17BasebandTransport6StatusEEEE(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

uint64_t ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig(uint64_t a1)
{
  return MEMORY[0x1F417DA50](a1 + 8);
}

double ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 0x600000000000000;
  double result = *(double *)"ipc.bb";
  *(_OWORD *)a1 = *(_OWORD *)"ipc.bb";
  return result;
}

uint64_t ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return MEMORY[0x1F417DD10](a1 + 8);
}

void *ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0BE58;
  MEMORY[0x1A6274710](a1 + 1);
  return a1;
}

void ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0BE58;
  MEMORY[0x1A6274710](a1 + 1);

  operator delete(a1);
}

void ___ZL14sLogServerInitRNSt3__110shared_ptrIN3ctu9LogServerEEE_block_invoke(uint64_t a1)
{
  char v9 = 18;
  strcpy(__p, "baseband.transport");
  ctu::LogServer::create();
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v10;
  long long v10 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (*((void *)&v10 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v10 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(void))(**((void **)&v10 + 1) + 16))(*((void *)&v10 + 1));
    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v10 + 1));
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  if (v9 < 0) {
LABEL_7:
  }
    operator delete(*(void **)__p);
LABEL_8:
  uint64_t v5 = (std::__shared_weak_count_vtbl *)operator new(8uLL);
  v5->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))&unk_1EFB0BE98;
  *(void *)std::string __p = v5;
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  v6->__shared_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0BF00;
  v6->__shared_weak_owners_ = 0;
  v6[1].__vftable = v5;
  *(void *)&__p[8] = v6;
  char v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  ctu::LogServer::addWriter();
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  ctu::LogServer::start(**(ctu::LogServer ***)(a1 + 32));
  ctu::LogServer::setEnabled(**(ctu::LogServer ***)(a1 + 32));
  if (*(void *)&__p[8])
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__p[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**(void **)&__p[8] + 16))(*(void *)&__p[8]);
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&__p[8]);
    }
  }
}

void sub_1A6133C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1A6133C34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_1A6133C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<EmptyLogWriter *,std::shared_ptr<ctu::LogWriter>::__shared_ptr_default_delete<ctu::LogWriter,EmptyLogWriter>,std::allocator<EmptyLogWriter>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001A61F90D7) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001A61F90D7 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A61F90D7)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A61F90D7 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void ctu::SharedLoggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0BE58;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(a1);
}

void ctu::Loggable<BasebandTransport,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(uint64_t a1)
{
  uint64_t v1 = a1 + 56;
  if (*(void *)(a1 + 56))
  {
    if (!*(void *)(a1 + 80) || (uint64_t v2 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(a1 + 80))) == 0) {
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
    uint64_t v3 = v2;
    ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v1 - 48));
    ctu::TrackedLogger::registerLoggerToServer();
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void sub_1A6133F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1A6133F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<BasebandTransportMAV *,std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV *)#1},std::allocator<BasebandTransportMAV>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__11"
                     "0shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMA"
                                "VEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportMAVEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<BasebandTransportMAV> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportMAV>(BasebandTransportMAV*)::{lambda(BasebandTransportMAV*)#1}::operator() const(BasebandTransportMAV*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<BasebandTransportICE *,std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE *)#1},std::allocator<BasebandTransportICE>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__11"
                     "0shared_ptrIT_EEPS7_EUlPS4_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportIC"
                                "EEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrI20BasebandTransportICEEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<BasebandTransportICE> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransportICE>(BasebandTransportICE*)::{lambda(BasebandTransportICE*)#1}::operator() const(BasebandTransportICE*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<BasebandTransport *,std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport *)#1},std::allocator<BasebandTransport>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_"
                                "ptrIT_EEPS6_EUlPS1_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI17BasebandTransportE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<BasebandTransport> ctu::SharedSynchronizable<BasebandTransport>::make_shared_ptr<BasebandTransport>(BasebandTransport*)::{lambda(BasebandTransport*)#1}::operator() const(BasebandTransport*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb0_E3__0EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void (***)(const void *, _OWORD *, uint64_t, uint64_t, uint64_t))a1;
  long long v7 = *(_OWORD *)(a1 + 24);
  uint64_t v9 = *(void *)(a1 + 40);
  v8[0] = *(_OWORD *)(a1 + 8);
  v8[1] = v7;
  v6[2](v6, v8, a3, a4, a5);
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  operator delete((void *)a1);
}

void sub_1A61342B0(_Unwind_Exception *a1)
{
  if (*v1) {
    _Block_release(*v1);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(const void **a1)
{
  (*((void (**)(void))*a1 + 2))();
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  if (*a1) {
    _Block_release(*a1);
  }

  operator delete(a1);
}

void sub_1A6134340(_Unwind_Exception *a1)
{
  unint64_t v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(void *)(v1 + 16) = v3;
    operator delete(v3);
  }
  if (*(void *)v1) {
    _Block_release(*(const void **)v1);
  }
  operator delete((void *)v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZZN17BasebandTransport4initEvEUb_EUb1_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS5_14default_deleteIS7_EEEEENUlPvE_8__invokeESB_(void **a1)
{
  (*((void (**)(void))*a1 + 2))();
  if (!*((unsigned char *)a1 + 20))
  {
    free(a1[1]);
    uint64_t v2 = *a1;
    if (!*a1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v2 = *a1;
  if (*a1) {
LABEL_5:
  }
    _Block_release(v2);
LABEL_6:

  operator delete(a1);
}

void sub_1A61343E8(_Unwind_Exception *a1)
{
  if (*v1) {
    _Block_release(*v1);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void ctu::SharedSynchronizable<BasebandTransport>::execute_wrapped(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (!v3 || (uint64_t v5 = *a1, (v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  long long v7 = v6;
  uint64_t v8 = a1[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 1174405120;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE15execute_wrappedEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_1EFB0C078;
  void block[5] = v5;
  int v12 = v7;
  p_shared_owners = &v7->__shared_owners_;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  void block[4] = a2;
  dispatch_async(v8, block);
  long long v10 = v12;
  if (!v12 || atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
LABEL_8:
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
  std::__shared_weak_count::__release_weak(v10);
  if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_8;
  }
}

uint64_t ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE15execute_wrappedEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __copy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17BasebandTransportEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c46_ZTSNSt3__110shared_ptrIK17BasebandTransportEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void Timestamp::Timestamp(Timestamp *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  uint64_t v2 = (void *)((char *)this + 8);
  *((void *)this + 2) = 0;
  *(void *)this = (char *)this + 8;
  unsigned long long v12 = 0uLL;
  if ((gettimeofday((timeval *)&v12, 0) & 0x80000000) == 0
    || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    uint64_t v3 = *v2;
    uint64_t v4 = v2;
    if (*v2) {
      goto LABEL_4;
    }
LABEL_10:
    long long v7 = (char *)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = 0;
    *((void *)v7 + 5) = 0;
    *((void *)v7 + 6) = 0;
    *(void *)long long v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v4;
    *uint64_t v2 = v7;
    uint64_t v8 = **(void **)this;
    uint64_t v9 = (uint64_t *)v7;
    if (v8)
    {
      *(void *)this = v8;
      uint64_t v9 = (uint64_t *)*v2;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 1), v9);
    ++*((void *)this + 2);
    goto LABEL_13;
  }
  long long v10 = __error();
  BOOL v11 = strerror(*v10);
  *(_DWORD *)stat buf = 136315138;
  int v14 = v11;
  _os_log_error_impl(&dword_1A609F000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to get current time. Error: %s\n", buf, 0xCu);
  uint64_t v3 = *v2;
  uint64_t v4 = v2;
  if (!*v2) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t v5 = v3;
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (void *)v5;
      int v6 = *(_DWORD *)(v5 + 32);
      if (v6 < 1) {
        break;
      }
      uint64_t v5 = *v4;
      uint64_t v2 = v4;
      if (!*v4) {
        goto LABEL_10;
      }
    }
    if ((v6 & 0x80000000) == 0) {
      break;
    }
    uint64_t v5 = v4[1];
    if (!v5)
    {
      uint64_t v2 = v4 + 1;
      goto LABEL_10;
    }
  }
  long long v7 = (char *)v4;
LABEL_13:
  *(_OWORD *)(v7 + 40) = v12;
}

void sub_1A61347B8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

void sub_1A61347D4(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, v2);
  _Unwind_Resume(a1);
}

void Timestamp::Timestamp(Timestamp *this, const Timestamp *a2)
{
  *((void *)this + 2) = 0;
  *((void *)this + 1) = 0;
  *(void *)this = (char *)this + 8;
  std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>((uint64_t *)this, *(int **)a2, (int *)a2 + 2);
}

{
  *((void *)this + 2) = 0;
  *((void *)this + 1) = 0;
  *(void *)this = (char *)this + 8;
  std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>((uint64_t *)this, *(int **)a2, (int *)a2 + 2);
}

void sub_1A6134830(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1A6134888(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void *Timestamp::Timestamp(void *a1, _OWORD *a2, int a3)
{
  a1[2] = 0;
  a1[1] = 0;
  int v6 = a1 + 1;
  *a1 = a1 + 1;
  long long v7 = (char *)operator new(0x38uLL);
  *((_DWORD *)v7 + 8) = a3;
  *(void *)long long v7 = 0;
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = v6;
  void *v6 = v7;
  *a1 = v7;
  v7[24] = 1;
  a1[2] = 1;
  *(_OWORD *)(v7 + 40) = *a2;
  return a1;
}

{
  void *v6;
  char *v7;

  a1[2] = 0;
  a1[1] = 0;
  int v6 = a1 + 1;
  *a1 = a1 + 1;
  long long v7 = (char *)operator new(0x38uLL);
  *((_DWORD *)v7 + 8) = a3;
  *(void *)long long v7 = 0;
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = v6;
  void *v6 = v7;
  *a1 = v7;
  v7[24] = 1;
  a1[2] = 1;
  *(_OWORD *)(v7 + 40) = *a2;
  return a1;
}

__n128 Timestamp::set(uint64_t **a1, __n128 *a2, int a3)
{
  long long v7 = a1 + 1;
  int v6 = (char *)a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v6;
        int v9 = *((_DWORD *)v6 + 8);
        if (v9 <= a3) {
          break;
        }
        int v6 = *(char **)v8;
        long long v7 = (uint64_t **)v8;
        if (!*(void *)v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a3) {
        break;
      }
      int v6 = (char *)*((void *)v8 + 1);
      if (!v6)
      {
        long long v7 = (uint64_t **)(v8 + 8);
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v8 = (char *)(a1 + 1);
LABEL_8:
    long long v10 = v8;
    uint64_t v8 = (char *)operator new(0x38uLL);
    *((_DWORD *)v8 + 8) = a3;
    *((void *)v8 + 5) = 0;
    *((void *)v8 + 6) = 0;
    *(void *)uint64_t v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = v10;
    *long long v7 = (uint64_t *)v8;
    BOOL v11 = (uint64_t *)**a1;
    unsigned long long v12 = (uint64_t *)v8;
    if (v11)
    {
      *a1 = v11;
      unsigned long long v12 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  __n128 result = *a2;
  *(__n128 *)(v8 + 40) = *a2;
  return result;
}

void *Timestamp::Timestamp(void *a1, uint64_t a2, int a3)
{
  a1[2] = 0;
  a1[1] = 0;
  int v6 = a1 + 1;
  *a1 = a1 + 1;
  long long v7 = operator new(0x38uLL);
  void v7[8] = a3;
  *(void *)long long v7 = 0;
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = v6;
  void *v6 = v7;
  *a1 = v7;
  *((unsigned char *)v7 + 24) = 1;
  a1[2] = 1;
  *((void *)v7 + 5) = a2;
  *((void *)v7 + 6) = 0xAAAAAAAAAAAAAAAALL;
  return a1;
}

{
  void *v6;
  _DWORD *v7;

  a1[2] = 0;
  a1[1] = 0;
  int v6 = a1 + 1;
  *a1 = a1 + 1;
  long long v7 = operator new(0x38uLL);
  void v7[8] = a3;
  *(void *)long long v7 = 0;
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = v6;
  void *v6 = v7;
  *a1 = v7;
  *((unsigned char *)v7 + 24) = 1;
  a1[2] = 1;
  *((void *)v7 + 5) = a2;
  *((void *)v7 + 6) = 0xAAAAAAAAAAAAAAAALL;
  return a1;
}

uint64_t **Timestamp::Timestamp(uint64_t **a1, char *a2, char a3, int a4)
{
  uint64_t v5 = a2;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  a1[1] = 0;
  long long v7 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  __p[2] = (void *)0x11AAAAAAAAAA0053;
  *(_OWORD *)std::string __p = *(_OWORD *)"%Y-%m-%d-%H-%M-%S";
  if ((a3 & 0x10) != 0)
  {
    HIBYTE(__p[2]) = 19;
    strcpy((char *)__p, "%Y.%m.%d_%H-%M-%S%z");
  }
  *((void *)&v23 + 1) = 0xAAAAAAAA00000000;
  memset(&v24, 0, sizeof(v24));
  if (a2[23] < 0) {
    uint64_t v5 = *(const char **)a2;
  }
  if (strptime(v5, (const char *)__p, &v24))
  {
    v24.tm_isdst = -1;
    *(void *)&unsigned long long v23 = mktime(&v24);
    if ((void)v23 != -1) {
      goto LABEL_15;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = __error();
      uint64_t v20 = strerror(*v19);
      *(_DWORD *)stat buf = 136315138;
      int v27 = v20;
      _os_log_error_impl(&dword_1A609F000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to convert to absolute time. Error: %s\n", buf, 0xCu);
      unsigned long long v23 = 0uLL;
      if ((gettimeofday((timeval *)&v23, 0) & 0x80000000) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      unsigned long long v23 = 0uLL;
      if ((gettimeofday((timeval *)&v23, 0) & 0x80000000) == 0) {
        goto LABEL_15;
      }
    }
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    uint64_t v8 = __error();
    int v9 = strerror(*v8);
    *(_DWORD *)stat buf = 136315138;
    int v27 = v9;
    long long v10 = MEMORY[0x1E4F14500];
    BOOL v11 = "Failed to get current time after absolute time conversion failed. Error: %s\n";
    goto LABEL_32;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl(&dword_1A609F000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to convert time from string format\n", buf, 2u);
  }
  unsigned long long v23 = 0uLL;
  if (gettimeofday((timeval *)&v23, 0) < 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = __error();
    uint64_t v22 = strerror(*v21);
    *(_DWORD *)stat buf = 136315138;
    int v27 = v22;
    long long v10 = MEMORY[0x1E4F14500];
    BOOL v11 = "Failed to get current time after conversion failure. Error: %s\n";
LABEL_32:
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0xCu);
  }
LABEL_15:
  unsigned long long v12 = *v7;
  long long v13 = v7;
  if (*v7)
  {
    while (1)
    {
      while (1)
      {
        long long v13 = (uint64_t **)v12;
        int v14 = *((_DWORD *)v12 + 8);
        if (v14 <= a4) {
          break;
        }
        unsigned long long v12 = *v13;
        long long v7 = v13;
        if (!*v13) {
          goto LABEL_22;
        }
      }
      if (v14 >= a4) {
        break;
      }
      unsigned long long v12 = v13[1];
      if (!v12)
      {
        long long v7 = v13 + 1;
        goto LABEL_22;
      }
    }
    *(_OWORD *)(v13 + 5) = v23;
    if (SHIBYTE(__p[2]) < 0) {
      goto LABEL_25;
    }
  }
  else
  {
LABEL_22:
    uint64_t v15 = (char *)operator new(0x38uLL);
    *((_DWORD *)v15 + 8) = a4;
    *((void *)v15 + 5) = 0;
    *((void *)v15 + 6) = 0;
    *(void *)uint64_t v15 = 0;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = v13;
    *long long v7 = (uint64_t *)v15;
    uint64_t v16 = (uint64_t *)**a1;
    uint64_t v17 = (uint64_t *)v15;
    if (v16)
    {
      *a1 = v16;
      uint64_t v17 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v17);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    *(_OWORD *)(v15 + 40) = v23;
    if (SHIBYTE(__p[2]) < 0) {
LABEL_25:
    }
      operator delete(__p[0]);
  }
  return a1;
}

void sub_1A6134EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v24, *(void **)(v24 + 8));
  _Unwind_Resume(a1);
}

uint64_t Timestamp::get(uint64_t a1, void *a2, int a3)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  uint64_t v4 = v5;
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a3;
    if (v7 >= a3) {
      int v9 = (uint64_t *)v4;
    }
    else {
      int v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 == v3 || *(_DWORD *)(v6 + 32) > a3) {
    return 0;
  }
  *(_OWORD *)a2 = *(_OWORD *)(v6 + 40);
  return 1;
}

uint64_t Timestamp::now(timeval *this, timeval *a2)
{
  return gettimeofday(this, 0);
}

uint64_t Timestamp::asString@<X0>(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, unsigned char *a4@<X8>)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[7] = v8;
  v41[8] = v8;
  v41[5] = v8;
  v41[6] = v8;
  v41[3] = v8;
  v41[4] = v8;
  v41[1] = v8;
  v41[2] = v8;
  long long v40 = v8;
  v41[0] = v8;
  *(_OWORD *)std::string __p = v8;
  long long v39 = v8;
  long long v36 = v8;
  long long v37 = v8;
  long long v34 = v8;
  long long v35 = v8;
  long long v33 = v8;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v33);
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v10 = a1 + 8;
  uint64_t v9 = v11;
  if (!v11) {
    goto LABEL_11;
  }
  uint64_t v12 = v10;
  do
  {
    int v13 = *(_DWORD *)(v9 + 32);
    BOOL v14 = v13 < a2;
    if (v13 >= a2) {
      uint64_t v15 = (uint64_t *)v9;
    }
    else {
      uint64_t v15 = (uint64_t *)(v9 + 8);
    }
    if (!v14) {
      uint64_t v12 = v9;
    }
    uint64_t v9 = *v15;
  }
  while (*v15);
  if (v12 != v10 && *(_DWORD *)(v12 + 32) <= a2)
  {
    time_t v16 = *(void *)(v12 + 40);
    if ((a3 & 0x11) != 0)
    {
LABEL_12:
      v31.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
      time_t v32 = v16;
      *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v31.tm_mon = v17;
      *(_OWORD *)&v31.tm_isdst = v17;
      *(_OWORD *)&v31.tm_sec = v17;
      localtime_r(&v32, &v31);
      long long v46 = 0u;
      long long v47 = 0u;
      *(_OWORD *)__s = 0u;
      long long v45 = 0u;
      if ((a3 & 0x10) != 0) {
        uint64_t v18 = "%Y.%m.%d_%H-%M-%S%z";
      }
      else {
        uint64_t v18 = "%Y-%m-%d-%H-%M-%S";
      }
      strftime(__s, 0x40uLL, v18, &v31);
      size_t v19 = strlen(__s);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)__s, v19);
      if ((a3 & 8) != 0)
      {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)"-", 1);
        uint64_t v20 = v34;
        uint64_t v21 = (char *)&v34 + *(void *)(v34 - 24);
        if (*((_DWORD *)v21 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v34 + *(void *)(v34 - 24)));
          uint64_t v22 = std::locale::use_facet(&v43, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 32);
          std::locale::~locale(&v43);
          uint64_t v20 = v34;
        }
        *((_DWORD *)v21 + 36) = 48;
        *(void *)((char *)&v35 + *(void *)(v20 - 24) + 8) = 3;
        std::ostream::operator<<();
      }
      goto LABEL_23;
    }
  }
  else
  {
LABEL_11:
    time_t v16 = 0;
    if ((a3 & 0x11) != 0) {
      goto LABEL_12;
    }
  }
  std::ostream::operator<<();
  if ((a3 & 4) != 0 || (a3 & 8) != 0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)".", 1);
    std::ostream::operator<<();
  }
LABEL_23:
  if ((BYTE8(v40) & 0x10) != 0)
  {
    uint64_t v24 = v40;
    if ((unint64_t)v40 < *((void *)&v37 + 1))
    {
      *(void *)&long long v40 = *((void *)&v37 + 1);
      uint64_t v24 = *((void *)&v37 + 1);
    }
    char v25 = (const void *)v37;
    size_t v23 = v24 - v37;
    if ((unint64_t)(v24 - v37) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_40;
    }
  }
  else
  {
    if ((BYTE8(v40) & 8) == 0)
    {
      size_t v23 = 0;
      a4[23] = 0;
      goto LABEL_36;
    }
    char v25 = (const void *)*((void *)&v35 + 1);
    size_t v23 = *((void *)&v36 + 1) - *((void *)&v35 + 1);
    if (*((void *)&v36 + 1) - *((void *)&v35 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_40:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v23 >= 0x17)
  {
    uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v26 = v23 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v28 = operator new(v26 + 1);
    *((void *)a4 + 1) = v23;
    *((void *)a4 + 2) = v27 | 0x8000000000000000;
    *(void *)a4 = v28;
    a4 = v28;
    goto LABEL_35;
  }
  a4[23] = v23;
  if (v23) {
LABEL_35:
  }
    memmove(a4, v25, v23);
LABEL_36:
  a4[v23] = 0;
  *(void *)&long long v33 = *MEMORY[0x1E4FBA408];
  uint64_t v29 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v33 + *(void *)(v33 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v34 = v29;
  *((void *)&v34 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v41);
}

void sub_1A61353D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A61353EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::locale::~locale((std::locale *)(v9 - 136));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6135408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6135420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6135434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *Timestamp::convert(uint64_t a1)
{
  memset(v11, 170, sizeof(v11));
  if (*(char *)(a1 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  Timestamp::Timestamp(v11, (char *)&__p, 9, 0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    uint64_t v1 = v11[1];
    if (!v11[1])
    {
LABEL_18:
      long long v8 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v1 = v11[1];
    if (!v11[1]) {
      goto LABEL_18;
    }
  }
  uint64_t v2 = &v11[1];
  uint64_t v3 = v1;
  do
  {
    uint64_t v4 = (uint64_t **)v3;
    uint64_t v5 = v2;
    int v6 = *((_DWORD *)v3 + 8);
    if (v6 >= 0) {
      uint64_t v2 = (uint64_t **)v3;
    }
    else {
      ++v3;
    }
    uint64_t v3 = (uint64_t *)*v3;
  }
  while (v3);
  if (v2 == &v11[1]) {
    goto LABEL_18;
  }
  int v7 = v6 >= 0 ? v4 : v5;
  if (*((int *)v7 + 8) > 0) {
    goto LABEL_18;
  }
  if (v6 < 0) {
    uint64_t v4 = v5;
  }
  long long v8 = v4[5];
LABEL_19:
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v11, v1);
  return v8;
}

void sub_1A6135548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    v19[9] = v3;
    v19[10] = v4;
    int v6 = a2;
    int v7 = result;
    long long v8 = result + 1;
    do
    {
      uint64_t v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      v19[0] = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      __n128 result = std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::__find_equal<Timestamp::TimeDomain>(v7, v8, v19, &v18, v6 + 8);
      if (*result)
      {
        uint64_t v9 = (int *)*((void *)v6 + 1);
        if (v9) {
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v10 = result;
        uint64_t v11 = operator new(0x38uLL);
        uint64_t v12 = *((void *)v6 + 6);
        void v11[2] = *((_OWORD *)v6 + 2);
        *((void *)v11 + 6) = v12;
        int v13 = v19[0];
        *(void *)uint64_t v11 = 0;
        *((void *)v11 + 1) = 0;
        *((void *)v11 + 2) = v13;
        *uint64_t v10 = (uint64_t)v11;
        BOOL v14 = *(void **)*v7;
        if (v14)
        {
          *int v7 = (uint64_t)v14;
          uint64_t v15 = (uint64_t *)*v10;
        }
        else
        {
          uint64_t v15 = (uint64_t *)v11;
        }
        __n128 result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], v15);
        ++v7[2];
        uint64_t v9 = (int *)*((void *)v6 + 1);
        if (v9)
        {
          do
          {
LABEL_11:
            time_t v16 = v9;
            uint64_t v9 = *(int **)v9;
          }
          while (v9);
          goto LABEL_3;
        }
      }
      do
      {
        time_t v16 = (int *)*((void *)v6 + 2);
        BOOL v17 = *(void *)v16 == (void)v6;
        int v6 = v16;
      }
      while (!v17);
LABEL_3:
      int v6 = v16;
    }
    while (v16 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::__find_equal<Timestamp::TimeDomain>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    long long v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      BOOL v14 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v14[2];
        BOOL v15 = *v10 == (void)v14;
        BOOL v14 = v10;
      }
      while (v15);
    }
    int v16 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          size_t v19 = (uint64_t *)v18;
          int v20 = *(_DWORD *)(v18 + 32);
          if (v16 >= v20) {
            break;
          }
          uint64_t v18 = *v19;
          uint64_t v5 = v19;
          if (!*v19) {
            goto LABEL_25;
          }
        }
        if (v20 >= v16) {
          break;
        }
        uint64_t v5 = v19 + 1;
        uint64_t v18 = v19[1];
      }
      while (v18);
LABEL_25:
      *a3 = v19;
      return v5;
    }
    else
    {
      *a3 = v5;
      return a1 + 1;
    }
  }
  else if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  else
  {
    uint64_t v11 = a2[1];
    if (v11)
    {
      uint64_t v12 = (uint64_t *)a2[1];
      do
      {
        int v13 = v12;
        uint64_t v12 = (uint64_t *)*v12;
      }
      while (v12);
    }
    else
    {
      uint64_t v21 = a2;
      do
      {
        int v13 = (uint64_t *)v21[2];
        BOOL v15 = *v13 == (void)v21;
        uint64_t v21 = v13;
      }
      while (!v15);
    }
    if (v13 == v5 || v6 < *((_DWORD *)v13 + 8))
    {
      if (v11)
      {
        *a3 = v13;
        return v13;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
    }
    else
    {
      uint64_t v22 = *v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            size_t v23 = (uint64_t *)v22;
            int v24 = *(_DWORD *)(v22 + 32);
            if (v6 >= v24) {
              break;
            }
            uint64_t v22 = *v23;
            uint64_t v5 = v23;
            if (!*v23) {
              goto LABEL_41;
            }
          }
          if (v24 >= v6) {
            break;
          }
          uint64_t v5 = v23 + 1;
          uint64_t v22 = v23[1];
        }
        while (v22);
LABEL_41:
        *a3 = v23;
        return v5;
      }
      else
      {
        *a3 = v5;
        return a1 + 1;
      }
    }
  }
}

void SoftwareBypassShim::create(std::__shared_weak_count **a1@<X8>)
{
  uint64_t v3 = (std::__shared_weak_count *)operator new(0x40uLL);
  v3->__shared_owners_ = 0;
  p_shared_owners = &v3->__shared_owners_;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C0D0;
  uint64_t v5 = v3 + 1;
  SoftwareBypassShim::SoftwareBypassShim((SoftwareBypassShim *)&v3[1]);
  shared_owners = (std::__shared_weak_count *)v3[1].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v3[1].__vftable = (std::__shared_weak_count_vtbl *)&v3[1];
      v3[1].__shared_owners_ = (uint64_t)v3;
      std::__shared_weak_count::__release_weak(shared_owners);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_7;
      }
    }
LABEL_3:
    *a1 = v5;
    a1[1] = v3;
    return;
  }
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&v3[1];
  v3[1].__shared_owners_ = (uint64_t)v3;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_3;
  }
LABEL_7:
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  *a1 = v5;
  a1[1] = v3;
}

void sub_1A613595C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void SoftwareBypassShim::SoftwareBypassShim(SoftwareBypassShim *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v2 = dlopen("/usr/local/lib/libSWBypassClient.dylib", 1);
  *((void *)this + 2) = v2;
  if (v2)
  {
    *((void *)this + 3) = dlsym(v2, "bypassCtl");
    *((void *)this + 4) = dlsym(*((void **)this + 2), "BypassInterfaceMaskAsString");
  }
  else
  {
    uint64_t v3 = dlerror();
    uint64_t v4 = GetOsLogContext()[1];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = "unknown";
      if (v3) {
        uint64_t v5 = v3;
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "dlopen error: %s ", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_1A6135AB4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void SoftwareBypassShim::~SoftwareBypassShim(SoftwareBypassShim *this)
{
  uint64_t v3 = (void *)((char *)this + 16);
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2) {
    dlclose(v2);
  }
  void *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

{
  void *v2;
  void *v3;
  std::__shared_weak_count *v4;

  uint64_t v3 = (void *)((char *)this + 16);
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2) {
    dlclose(v2);
  }
  void *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

BOOL SoftwareBypassShim::isSupported(SoftwareBypassShim *this)
{
  return *((void *)this + 2) != 0;
}

uint64_t SoftwareBypassShim::bypassCtl(SoftwareBypassShim *this, uint64_t a2)
{
  uint64_t v2 = (uint64_t (*)(uint64_t))*((void *)this + 3);
  if (v2)
  {
    return v2(a2);
  }
  else
  {
    uint64_t v4 = GetOsLogContext()[1];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "bypassCtl is not found", v5, 2u);
    }
    return 0;
  }
}

const char *SoftwareBypassShim::bypassInterfaceMaskAsString(SoftwareBypassShim *this, uint64_t a2)
{
  uint64_t v2 = (uint64_t (*)(uint64_t))*((void *)this + 4);
  if (v2)
  {
    return (const char *)v2(a2);
  }
  else
  {
    uint64_t v4 = GetOsLogContext()[1];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "BypassInterfaceMaskAsString is not found", v5, 2u);
    }
    return "unknown";
  }
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C0D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C0D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate,std::allocator<SoftwareBypassShim::create(void)::SoftwareBypassShimNoPrivate>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v3 = (void *)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {
    dlclose(v2);
  }
  void *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void KernelPCIABPTrace::PipeContext::stop(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    (*(void (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 5);
    *((void *)this + 4) = 0;
    *((void *)this + 5) = 0;
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

void KernelPCIABPTrace::PipeContext::start(KernelPCIABPTrace::PipeContext *this, CircularFileLogWriter::Params *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 5);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = operator new(0xB8uLL);
  CircularFileLogWriter::CircularFileLogWriter((uint64_t)v5, (long long *)a2);
  std::shared_ptr<CircularFileLogWriter>::shared_ptr[abi:ne180100]<CircularFileLogWriter,std::shared_ptr<CircularFileLogWriter> ctu::SharedSynchronizable<CircularFileLogWriter>::make_shared_ptr<CircularFileLogWriter>(CircularFileLogWriter*)::{lambda(CircularFileLogWriter*)#1},void>(&block, (uint64_t)v5);
  long long v6 = block;
  blocuint64_t k = 0uLL;
  int v7 = (std::__shared_weak_count *)*((void *)this + 5);
  *((_OWORD *)this + 2) = v6;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)&block + 1);
  if (*((void *)&block + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&block + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *((void *)this + 4);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  void v11[2] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
  v11[3] = &__block_descriptor_tmp;
  _DWORD v11[4] = v9;
  uint64_t v12 = v11;
  *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
  *((void *)&block + 1) = 0x40000000;
  BOOL v14 = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  BOOL v15 = &__block_descriptor_tmp_21;
  uint64_t v16 = v9 + 8;
  BOOL v17 = &v12;
  uint64_t v10 = *(NSObject **)(v9 + 24);
  if (*(void *)(v9 + 32)) {
    dispatch_async_and_wait(v10, &block);
  }
  else {
    dispatch_sync(v10, &block);
  }
}

void sub_1A6136070(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::PipeContext::write(KernelPCIABPTrace::PipeContext *this, const char *a2)
{
  uint64_t result = *((void *)this + 4);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const char *))(*(void *)result + 72))(result, a2);
  }
  return result;
}

uint64_t KernelPCIABPTrace::PipeContext::pause(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t result = *((void *)this + 4);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void KernelPCIABPTrace::PipeContext::resume(KernelPCIABPTrace::PipeContext *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    void v3[2] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
    v3[3] = &__block_descriptor_tmp;
    v3[4] = v1;
    uint64_t v4 = v3;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    block[3] = &__block_descriptor_tmp_21;
    void block[4] = v1 + 8;
    void block[5] = &v4;
    uint64_t v2 = *(NSObject **)(v1 + 24);
    if (*(void *)(v1 + 32)) {
      dispatch_async_and_wait(v2, block);
    }
    else {
      dispatch_sync(v2, block);
    }
  }
}

void KernelPCIABPTrace::PipeContext::setFileCapacity(KernelPCIABPTrace::PipeContext *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    void v3[2] = ___ZN21CircularFileLogWriter11setCapacityEm_block_invoke;
    v3[3] = &__block_descriptor_tmp_8;
    v3[4] = v2;
    void v3[5] = a2;
    ctu::SharedSynchronizable<CircularFileLogWriter>::execute_wrapped((uint64_t *)(v2 + 8), (uint64_t)v3);
  }
}

void KernelPCIABPTrace::KernelPCIABPTrace(KernelPCIABPTrace *this)
{
  char v4 = 13;
  strcpy((char *)__p, "trace.pci.bin");
  uint64_t v2 = (capabilities::ipc *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this = &unk_1EFB0C120;
  *((_WORD *)this + 76) = 0;
  *((_DWORD *)this + 39) = capabilities::ipc::defaultPCIBinaryTraceHistorySizeMB(v2);
  *((void *)this + 20) = 0x400000000004;
  *((void *)this + 22) = 0;
  *((void *)this + 21) = (char *)this + 176;
  *((void *)this + 26) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = (char *)this + 200;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
}

void sub_1A61362F8(_Unwind_Exception *a1)
{
  Trace::~Trace(v1);
  _Unwind_Resume(a1);
}

void sub_1A613630C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::~KernelPCIABPTrace(KernelPCIABPTrace *this)
{
  *(void *)this = &unk_1EFB0C120;
  uint64_t v2 = *((void *)this + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *((void *)this + 32);
    if (v3) {
      dispatch_release(v3);
    }
  }
  if (*((char *)this + 255) < 0)
  {
    operator delete(*((void **)this + 29));
    char v4 = (std::__shared_weak_count *)*((void *)this + 28);
    if (!v4) {
      goto LABEL_10;
    }
  }
  else
  {
    char v4 = (std::__shared_weak_count *)*((void *)this + 28);
    if (!v4) {
      goto LABEL_10;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_10:
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*((void **)this + 25));
  std::__tree<KernelPCITrace::BuffContext *>::destroy(*((void **)this + 22));

  Trace::~Trace(this);
}

{
  void *v1;
  uint64_t vars8;

  KernelPCIABPTrace::~KernelPCIABPTrace(this);

  operator delete(v1);
}

double KernelPCIABPTrace::createInternal@<D0>(void *a1@<X8>)
{
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = (KernelPCIABPTrace *)operator new(0x110uLL);
  KernelPCIABPTrace::KernelPCIABPTrace(v3);
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  double result = *(double *)&v5;
  *(_OWORD *)a1 = v5;
  return result;
}

void sub_1A613649C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A61364B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  *(unsigned char *)(a1 + 264) = 0;
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    std::string v16 = *(std::string *)a2;
    int v7 = (std::__shared_weak_count *)a3[1];
    uint64_t v14 = *a3;
    BOOL v15 = v7;
    if (!v7) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&v16, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  int v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v14 = *a3;
  BOOL v15 = v7;
  if (v7) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  uint64_t v8 = *a4;
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  uint64_t v9 = Trace::init(a1, (void **)&v16.__r_.__value_.__l.__data_, &v14, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v16.__r_.__value_.__l.__data_);
    if (!v9) {
      return v9;
    }
  }
  else if (!v9)
  {
    return v9;
  }
  uint64_t v12 = a1;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke;
  block[3] = &__block_descriptor_tmp_67;
  void block[4] = a1 + 72;
  void block[5] = &v12;
  uint64_t v11 = *(NSObject **)(a1 + 88);
  if (*(void *)(a1 + 96)) {
    dispatch_async_and_wait(v11, block);
  }
  else {
    dispatch_sync(v11, block);
  }
  return v9;
}

void sub_1A6136644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (object)
  {
    dispatch_release(object);
    size_t v19 = a12;
    if (!a12)
    {
LABEL_3:
      if ((a18 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    size_t v19 = a12;
    if (!a12) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v19);
  if ((a18 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::initProperty_sync(KernelPCIABPTrace *this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"initProperty_sync";
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&buf, 0xCu);
  }
  char v7 = 7;
  strcpy((char *)v6, "Enabled");
  memset(&__p, 0, sizeof(__p));
  char v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_42[2];
  memset(&buf, 0, sizeof(buf));
  BOOL v3 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v3)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_9;
    }
LABEL_12:
    operator delete(v9[0]);
    if (!v3) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0) {
    goto LABEL_12;
  }
LABEL_9:
  if (v3) {
LABEL_13:
  }
    util::convert<BOOL>(&__p, (BOOL *)this + 152, 0);
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((v7 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v6[0]);
LABEL_16:
  char v7 = 7;
  strcpy((char *)v6, "History");
  memset(&__p, 0, sizeof(__p));
  char v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_42[2];
  memset(&buf, 0, sizeof(buf));
  BOOL v4 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v4)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_22;
    }
LABEL_27:
    operator delete(v9[0]);
    if (!v4) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0) {
    goto LABEL_27;
  }
LABEL_22:
  if (v4) {
LABEL_28:
  }
    util::convert<int>(&__p, (_DWORD *)this + 39, 0);
LABEL_29:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_31;
    }
  }
  else if ((v7 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v6[0]);
LABEL_31:
  char v7 = 11;
  strcpy((char *)v6, "BufferCount");
  memset(&__p, 0, sizeof(__p));
  char v10 = 3;
  LOWORD(v9[0]) = *(_WORD *)"IPC";
  WORD1(v9[0]) = str_42[2];
  memset(&buf, 0, sizeof(buf));
  BOOL v5 = defaults::get((char *)v9, (char *)v6, &buf);
  if (v5)
  {
    prop::file::get<std::string>((const void **)v9, (uint64_t)v6, (uint64_t)&buf, &v11);
    std::string __p = v11;
  }
  if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_35;
    }
LABEL_40:
    operator delete(v9[0]);
    if (!v5) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
  if (v10 < 0) {
    goto LABEL_40;
  }
LABEL_35:
  if (v5) {
LABEL_41:
  }
    util::convert<unsigned int>(&__p, (_DWORD *)this + 40, 0);
LABEL_42:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_46:
    operator delete(v6[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v7 < 0) {
    goto LABEL_46;
  }
}

void sub_1A6136A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::dumpCodeRegistry_sync(KernelPCIABPTrace *this)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  unint64_t v83 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  uint64_t v3 = xmmword_1EB5EE590;
  if (!(void)xmmword_1EB5EE590)
  {
    ctu::XpcJetsamAssertion::create_default_global((uint64_t *)buf, v2);
    long long v4 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    BOOL v5 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
    xmmword_1EB5EE590 = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    long long v6 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v3 = xmmword_1EB5EE590;
  }
  char v7 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
  *(void *)size_t v78 = v3;
  *(void *)&v78[8] = *((void *)&xmmword_1EB5EE590 + 1);
  if (*((void *)&xmmword_1EB5EE590 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  *(void *)&value[1] = operator new(0x20uLL);
  long long v82 = xmmword_1A61F9520;
  strcpy(*(char **)&value[1], "Kernel PCI Dump Code Registry");
  ctu::XpcJetsamAssertion::createActivity();
  operator delete(*(void **)&value[1]);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *((void *)this + 5);
  if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    if (!*((void *)this + 27)) {
      goto LABEL_68;
    }
LABEL_16:
    xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
    uint64_t v10 = MEMORY[0x1E4F14590];
    if (v9 || (xpc_object_t v9 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v9) == v10)
      {
        xpc_retain(v9);
        xpc_object_t v11 = v9;
      }
      else
      {
        xpc_object_t v11 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v9 = 0;
    }
    xpc_release(v9);
    if (MEMORY[0x1A6275E60](v11) != v10) {
      goto LABEL_67;
    }
    value[0] = -1431655766;
    if ((*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 104))(*((void *)this + 27), value))
    {
      xpc_object_t v12 = xpc_int64_create(value[0]);
      if (!v12) {
        xpc_object_t v12 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "TraceCodeSize", v12);
      xpc_object_t v13 = xpc_null_create();
      xpc_release(v12);
      xpc_release(v13);
    }
    if ((*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 112))(*((void *)this + 27), value))
    {
      xpc_object_t v14 = xpc_int64_create(value[0]);
      if (!v14) {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "MinTraceBufferSize", v14);
      xpc_object_t v15 = xpc_null_create();
      xpc_release(v14);
      xpc_release(v15);
    }
    if ((*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 120))(*((void *)this + 27), value))
    {
      xpc_object_t v16 = xpc_int64_create(value[0]);
      if (!v16) {
        xpc_object_t v16 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "MaxTraceBufferSize", v16);
      xpc_object_t v17 = xpc_null_create();
      xpc_release(v16);
      xpc_release(v17);
    }
    if ((*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 136))(*((void *)this + 27), value))
    {
      xpc_object_t v18 = xpc_int64_create(value[0]);
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "MaxTraceBuffersInFlight", v18);
      xpc_object_t v19 = xpc_null_create();
      xpc_release(v18);
      xpc_release(v19);
    }
    if ((*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 128))(*((void *)this + 27), value))
    {
      xpc_object_t v20 = xpc_int64_create(value[0]);
      if (!v20) {
        xpc_object_t v20 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "SnapshotBufferSize", v20);
      xpc_object_t v21 = xpc_null_create();
      xpc_release(v20);
      xpc_release(v21);
    }
    v80.tv_sec = 0;
    *(void *)&v80.tv_usec = 0;
    int64_t v79 = 0;
    if (!gettimeofday(&v80, &v79))
    {
      xpc_object_t v22 = xpc_int64_create((int)v79);
      if (!v22) {
        xpc_object_t v22 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "TimeZoneMinutesWest", v22);
      xpc_object_t v23 = xpc_null_create();
      xpc_release(v22);
      xpc_release(v23);
      xpc_object_t v24 = xpc_int64_create(SHIDWORD(v79));
      if (!v24) {
        xpc_object_t v24 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, "TimeZoneAdjust", v24);
      xpc_object_t v25 = xpc_null_create();
      xpc_release(v24);
      xpc_release(v25);
    }
    xpc_object_t v26 = xpc_array_create(0, 0);
    uint64_t v27 = MEMORY[0x1E4F14568];
    if (v26 || (xpc_object_t v26 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v26) == v27)
      {
        xpc_retain(v26);
        xpc_object_t object = v26;
      }
      else
      {
        xpc_object_t object = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t object = xpc_null_create();
      xpc_object_t v26 = 0;
    }
    xpc_release(v26);
    if (!(*(unsigned int (**)(void, _DWORD *))(**((void **)this + 27) + 96))(*((void *)this + 27), value)|| MEMORY[0x1A6275E60](object) != v27)
    {
      goto LABEL_59;
    }
    int64_t v88 = 0xAAAAAAAAAAAAAAAALL;
    std::string __p = 0;
    char v90 = 0;
    uint64_t v91 = 0;
    *(_OWORD *)std::string buf = 0u;
    *(_OWORD *)string = 0u;
    long long v87 = 0u;
    if (value[0])
    {
      uint64_t v41 = 0;
      xpc_object_t v76 = v11;
      do
      {
        unint64_t v42 = (void **)__p;
        for (uint64_t i = v90; i != v42; i -= 4)
        {
          if (*((char *)i - 9) < 0) {
            operator delete(*(i - 4));
          }
        }
        char v90 = v42;
        if (((*(uint64_t (**)(void, uint64_t, uint8_t *))(**((void **)this + 27) + 144))(*((void *)this + 27), v41, buf) & 1) == 0)goto LABEL_74; {
        xpc_object_t v44 = xpc_dictionary_create(0, 0, 0);
        }
        if (v44 || (xpc_object_t v44 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v44) == v10)
          {
            xpc_retain(v44);
            xpc_object_t v45 = v44;
          }
          else
          {
            xpc_object_t v45 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v45 = xpc_null_create();
          xpc_object_t v44 = 0;
        }
        xpc_release(v44);
        if (MEMORY[0x1A6275E60](v45) != v10)
        {
          int v46 = 6;
          goto LABEL_144;
        }
        xpc_object_t v47 = xpc_array_create(0, 0);
        uint64_t v48 = MEMORY[0x1E4F14568];
        if (v47 || (xpc_object_t v47 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v47) == v48)
          {
            xpc_retain(v47);
            xpc_object_t v49 = v47;
          }
          else
          {
            xpc_object_t v49 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v49 = xpc_null_create();
          xpc_object_t v47 = 0;
        }
        xpc_release(v47);
        if (MEMORY[0x1A6275E60](v49) == v48)
        {
          unsigned __int8 v51 = (char *)__p;
          uint64_t v50 = (char *)v90;
          while (v51 != v50)
          {
            *(void *)&long long v52 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v52 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)size_t v78 = v52;
            *(_OWORD *)&v78[16] = v52;
            if (v51[23] < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)v78, *(const std::string::value_type **)v51, *((void *)v51 + 1));
            }
            else
            {
              long long v53 = *(_OWORD *)v51;
              *(void *)&v78[16] = *((void *)v51 + 2);
              *(_OWORD *)size_t v78 = v53;
            }
            *(_DWORD *)&v78[24] = *((_DWORD *)v51 + 6);
            xpc_object_t v54 = xpc_dictionary_create(0, 0, 0);
            if (v54 || (xpc_object_t v54 = xpc_null_create()) != 0)
            {
              if (MEMORY[0x1A6275E60](v54) == v10)
              {
                xpc_retain(v54);
                xpc_object_t v55 = v54;
              }
              else
              {
                xpc_object_t v55 = xpc_null_create();
              }
            }
            else
            {
              xpc_object_t v55 = xpc_null_create();
              xpc_object_t v54 = 0;
            }
            xpc_release(v54);
            if (MEMORY[0x1A6275E60](v55) != v10)
            {
              xpc_release(v55);
              xpc_object_t v11 = v76;
              if ((v78[23] & 0x80000000) != 0) {
                operator delete(*(void **)v78);
              }
              int v46 = 1;
              goto LABEL_143;
            }
            if (v78[23] >= 0) {
              long long v56 = v78;
            }
            else {
              long long v56 = *(const char **)v78;
            }
            xpc_object_t v57 = xpc_string_create(v56);
            if (!v57) {
              xpc_object_t v57 = xpc_null_create();
            }
            xpc_dictionary_set_value(v55, "TypeName", v57);
            xpc_object_t v58 = xpc_null_create();
            xpc_release(v57);
            xpc_release(v58);
            xpc_object_t v59 = xpc_int64_create(*(unsigned int *)&v78[24]);
            if (!v59) {
              xpc_object_t v59 = xpc_null_create();
            }
            xpc_dictionary_set_value(v55, "Size", v59);
            xpc_object_t v60 = xpc_null_create();
            xpc_release(v59);
            xpc_release(v60);
            xpc_array_append_value(v49, v55);
            xpc_release(v55);
            if ((v78[23] & 0x80000000) != 0) {
              operator delete(*(void **)v78);
            }
            v51 += 32;
          }
          xpc_object_t v11 = v76;
          if (MEMORY[0x1A6275E60](v49) == MEMORY[0x1E4F14568] && xpc_array_get_count(v49))
          {
            if (v49)
            {
              xpc_retain(v49);
              xpc_object_t v61 = v49;
            }
            else
            {
              xpc_object_t v61 = xpc_null_create();
            }
            xpc_dictionary_set_value(v45, "Attachments", v61);
            xpc_object_t v62 = xpc_null_create();
            xpc_release(v61);
            xpc_release(v62);
          }
        }
        xpc_object_t v63 = xpc_int64_create(v88);
        if (!v63) {
          xpc_object_t v63 = xpc_null_create();
        }
        xpc_dictionary_set_value(v45, "Code", v63);
        xpc_object_t v64 = xpc_null_create();
        xpc_release(v63);
        xpc_release(v64);
        if (SHIBYTE(string[0]) >= 0) {
          xpc_object_t v65 = buf;
        }
        else {
          xpc_object_t v65 = *(uint8_t **)buf;
        }
        xpc_object_t v66 = xpc_string_create((const char *)v65);
        if (!v66) {
          xpc_object_t v66 = xpc_null_create();
        }
        xpc_dictionary_set_value(v45, "Text", v66);
        xpc_object_t v67 = xpc_null_create();
        xpc_release(v66);
        xpc_release(v67);
        if (SHIBYTE(v87) < 0)
        {
          if (!(void)v87) {
            goto LABEL_142;
          }
          uint64_t v68 = string[1];
        }
        else
        {
          uint64_t v68 = (const char *)&string[1];
          if (!HIBYTE(v87)) {
            goto LABEL_142;
          }
        }
        xpc_object_t v69 = xpc_string_create(v68);
        if (!v69) {
          xpc_object_t v69 = xpc_null_create();
        }
        xpc_dictionary_set_value(v45, "Location", v69);
        xpc_object_t v70 = xpc_null_create();
        xpc_release(v69);
        xpc_release(v70);
LABEL_142:
        xpc_array_append_value(object, v45);
        int v46 = 0;
LABEL_143:
        xpc_release(v49);
LABEL_144:
        xpc_release(v45);
        if (v46 != 6 && v46) {
          goto LABEL_151;
        }
LABEL_74:
        uint64_t v41 = (v41 + 1);
      }
      while (v41 < value[0]);
    }
    xpc_object_t v71 = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t v71 = xpc_null_create();
    }
    xpc_dictionary_set_value(v11, "TraceCodes", v71);
    xpc_object_t v72 = xpc_null_create();
    xpc_release(v71);
    xpc_release(v72);
    int v46 = 0;
LABEL_151:
    uint64_t v73 = (void **)__p;
    if (__p)
    {
      size_t v74 = v90;
      xpc_object_t v75 = __p;
      if (v90 != __p)
      {
        do
        {
          if (*((char *)v74 - 9) < 0) {
            operator delete(*(v74 - 4));
          }
          v74 -= 4;
        }
        while (v74 != v73);
        xpc_object_t v75 = __p;
      }
      char v90 = v73;
      operator delete(v75);
    }
    if (SHIBYTE(v87) < 0)
    {
      operator delete(string[1]);
      if ((SHIBYTE(string[0]) & 0x80000000) == 0)
      {
LABEL_161:
        if (!v46) {
          goto LABEL_59;
        }
        goto LABEL_165;
      }
    }
    else if ((SHIBYTE(string[0]) & 0x80000000) == 0)
    {
      goto LABEL_161;
    }
    operator delete(*(void **)buf);
    if (!v46)
    {
LABEL_59:
      xpc_object_t v28 = xpc_null_create();
      unint64_t v29 = v83;
      unint64_t v30 = v84;
      if (v84) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v84 + 8), 1uLL, memory_order_relaxed);
      }
      tm v31 = (std::__shared_weak_count *)*((void *)this + 10);
      if (!v31 || (uint64_t v32 = *((void *)this + 9), (v33 = std::__shared_weak_count::lock(v31)) == 0)) {
        std::__throw_bad_weak_ptr[abi:ne180100]();
      }
      long long v34 = v33;
      long long v35 = operator new(0x20uLL);
      void *v35 = this;
      v35[1] = v11;
      xpc_object_t v36 = xpc_null_create();
      v35[2] = v29;
      v35[3] = v30;
      long long v37 = *((void *)this + 11);
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v38 = operator new(0x18uLL);
      *uint64_t v38 = v35;
      v38[1] = v32;
      void v38[2] = v34;
      dispatch_async_f(v37, v38, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>(KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke);
      if (!atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
      xpc_release(v36);
      xpc_object_t v11 = v28;
      long long v39 = object;
      goto LABEL_66;
    }
LABEL_165:
    long long v39 = object;
LABEL_66:
    xpc_release(v39);
LABEL_67:
    xpc_release(v11);
    goto LABEL_68;
  }
  *(_DWORD *)std::string buf = 136315138;
  *(void *)&uint8_t buf[4] = "dumpCodeRegistry_sync";
  _os_log_debug_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  if (*((void *)this + 27)) {
    goto LABEL_16;
  }
LABEL_68:
  long long v40 = (std::__shared_weak_count *)v84;
  if (v84)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v84 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }
}

void sub_1A6137854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,char a33)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void pci::transport::kernelTrace::traceCodeDict::~traceCodeDict(pci::transport::kernelTrace::traceCodeDict *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 8);
    long long v4 = (void *)*((void *)this + 7);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 9) < 0) {
          operator delete(*(void **)(v3 - 32));
        }
        v3 -= 32;
      }
      while (v3 != v2);
      long long v4 = (void *)*((void *)this + 7);
    }
    *((void *)this + 8) = v2;
    operator delete(v4);
  }
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
LABEL_13:
    operator delete(*(void **)this);
    return;
  }
  operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0) {
    goto LABEL_13;
  }
}

void *KernelPCIABPTrace::createBuffContext_sync(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long v6 = operator new(0x30uLL);
  char v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v7 || (v8 = *(void *)(a1 + 72), (xpc_object_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = *a3;
  xpc_object_t v12 = (std::__shared_weak_count *)a3[1];
  if (!v12)
  {
    void *v6 = 0;
    v6[1] = a2;
    v6[3] = v10;
    v6[2] = v8;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[4] = v11;
    v6[5] = 0;
LABEL_23:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  void *v6 = 0;
  v6[1] = a2;
  v6[3] = v10;
  v6[2] = v8;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v6[4] = v11;
  xpc_object_t v13 = std::__shared_weak_count::lock(v12);
  v6[5] = v13;
  if (!v13) {
    goto LABEL_23;
  }
  size_t v14 = v6[1];
  if (v14) {
    void *v6 = malloc_type_malloc(v14, 0x4D6292B9uLL);
  }
  std::__shared_weak_count::__release_weak(v12);
  std::__shared_weak_count::__release_weak(v10);
  xpc_object_t v16 = (uint64_t **)(a1 + 176);
  xpc_object_t v15 = *(uint64_t **)(a1 + 176);
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        xpc_object_t v17 = (uint64_t **)v15;
        unint64_t v18 = v15[4];
        if ((unint64_t)v6 >= v18) {
          break;
        }
        xpc_object_t v15 = *v17;
        xpc_object_t v16 = v17;
        if (!*v17) {
          goto LABEL_16;
        }
      }
      if (v18 >= (unint64_t)v6) {
        break;
      }
      xpc_object_t v15 = v17[1];
      if (!v15)
      {
        xpc_object_t v16 = v17 + 1;
        goto LABEL_16;
      }
    }
  }
  else
  {
    xpc_object_t v17 = (uint64_t **)(a1 + 176);
LABEL_16:
    xpc_object_t v19 = (uint64_t *)operator new(0x28uLL);
    v19[4] = (uint64_t)v6;
    *xpc_object_t v19 = 0;
    v19[1] = 0;
    v19[2] = (uint64_t)v17;
    int *v16 = v19;
    uint64_t v20 = **(void **)(a1 + 168);
    if (v20)
    {
      *(void *)(a1 + 168) = v20;
      xpc_object_t v21 = *v16;
    }
    else
    {
      xpc_object_t v21 = v19;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 176), v21);
    ++*(void *)(a1 + 184);
  }
  return v6;
}

void sub_1A6137DAC(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v4);
  if (*v5) {
    std::__shared_weak_count::__release_weak(*v5);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  std::__shared_weak_count::__release_weak(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A6137DF0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::deleteBuffContext_sync(void *a1, unint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (uint64_t *)a1[22];
    if (v2)
    {
      uint64_t v4 = a1 + 22;
      BOOL v5 = (void *)a1[22];
      do
      {
        unint64_t v6 = v5[4];
        BOOL v7 = v6 >= a2;
        if (v6 >= a2) {
          uint64_t v8 = v5;
        }
        else {
          uint64_t v8 = v5 + 1;
        }
        if (v7) {
          uint64_t v4 = v5;
        }
        BOOL v5 = (void *)*v8;
      }
      while (*v8);
      if (v4 != a1 + 22 && v4[4] <= a2)
      {
        xpc_object_t v9 = (uint64_t *)v4[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            xpc_object_t v9 = (uint64_t *)*v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v11 = v4;
          do
          {
            uint64_t v10 = (uint64_t *)v11[2];
            BOOL v12 = *v10 == (void)v11;
            uint64_t v11 = v10;
          }
          while (!v12);
        }
        if ((uint64_t *)a1[21] == v4) {
          a1[21] = v10;
        }
        --a1[23];
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v2, v4);
        operator delete(v4);
        if (*(void *)a2) {
          free(*(void **)a2);
        }
        xpc_object_t v13 = *(std::__shared_weak_count **)(a2 + 40);
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        size_t v14 = *(std::__shared_weak_count **)(a2 + 24);
        if (v14) {
          std::__shared_weak_count::__release_weak(v14);
        }
        operator delete((void *)a2);
      }
    }
  }
}

void KernelPCIABPTrace::deleteAllBuffContext_sync(KernelPCIABPTrace *this)
{
  uint64_t v2 = (char *)*((void *)this + 21);
  uint64_t v3 = (char *)this + 176;
  if (v2 != (char *)this + 176)
  {
    while (1)
    {
      uint64_t v4 = *((void *)v2 + 4);
      if (v4) {
        break;
      }
LABEL_12:
      BOOL v7 = (char *)*((void *)v2 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (char *)*((void *)v2 + 2);
          BOOL v9 = *(void *)v8 == (void)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = v8;
      if (v8 == v3) {
        goto LABEL_20;
      }
    }
    if (*(void *)v4) {
      free(*(void **)v4);
    }
    BOOL v5 = *(std::__shared_weak_count **)(v4 + 40);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      unint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
      if (!v6) {
        goto LABEL_11;
      }
    }
    else
    {
      unint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
      if (!v6)
      {
LABEL_11:
        operator delete((void *)v4);
        goto LABEL_12;
      }
    }
    std::__shared_weak_count::__release_weak(v6);
    goto LABEL_11;
  }
LABEL_20:
  std::__tree<KernelPCITrace::BuffContext *>::destroy(*((void **)this + 22));
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 21) = v3;
}

void KernelPCIABPTrace::updateTraceState_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (*(unsigned char *)(a1 + 152)) {
      goto LABEL_3;
    }
LABEL_6:
    KernelPCIABPTrace::stopTrace(a1, a2);
    return;
  }
  int v5 = 136315138;
  unint64_t v6 = "updateTraceState_sync";
  _os_log_debug_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v5, 0xCu);
  if (!*(unsigned char *)(a1 + 152)) {
    goto LABEL_6;
  }
LABEL_3:
  if (!*(unsigned char *)(a1 + 153)) {
    KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)a1);
  }
}

void KernelPCIABPTrace::startTrace_sync(KernelPCIABPTrace *this)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)xpc_object_t v19 = 136315138;
    *(void *)&v19[4] = "startTrace_sync";
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D %s", v19, 0xCu);
  }
  *((unsigned char *)this + 153) = 1;
  if (KernelPCIABPTrace::registerWithKernel_sync(this))
  {
    uint64_t v3 = (KernelPCIABPTrace *)*((void *)this + 24);
    if (v3 != (KernelPCIABPTrace *)((char *)this + 200))
    {
      while (1)
      {
        int v5 = (long long *)*((void *)v3 + 4);
        uint64_t v4 = (std::__shared_weak_count *)*((void *)v3 + 5);
        xpc_object_t v17 = v5;
        unint64_t v18 = v4;
        if (v4) {
          atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v22 = v6;
        long long v23 = v6;
        long long v20 = v6;
        *(_OWORD *)std::string __p = v6;
        *(_OWORD *)xpc_object_t v19 = v6;
        *(_OWORD *)&v19[16] = v6;
        if (*((char *)v5 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v16, *(const std::string::value_type **)v5, *((void *)v5 + 1));
        }
        else
        {
          long long v7 = *v5;
          v16.__r_.__value_.__r.__words[2] = *((void *)v5 + 2);
          *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v7;
        }
        uint64_t v8 = (char *)operator new(0x48uLL);
        strcpy(v8, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
        uint64_t v9 = *((int *)this + 39);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external((std::string *)v19, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
        }
        else {
          *(std::string *)xpc_object_t v19 = v16;
        }
        std::string::__init_copy_ctor_external((std::string *)&v19[24], v8, 0x40uLL);
        __p[1] = 0;
        *(void *)&long long v22 = 0xB00000000000000;
        *((void *)&v22 + 1) = v9 << 20;
        *(void *)&long long v23 = 0x100000;
        BYTE8(v23) = 0;
        *(_DWORD *)((char *)__p + 7) = 1701011826;
        __p[0] = *(void **)".acipctrace";
        operator delete(v8);
        if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          break;
        }
        operator delete(v16.__r_.__value_.__l.__data_);
        uint64_t v10 = *((void *)this + 5);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_17;
        }
LABEL_18:
        KernelPCIABPTrace::PipeContext::start((KernelPCIABPTrace::PipeContext *)v5, (CircularFileLogWriter::Params *)v19);
        if (SBYTE7(v22) < 0)
        {
          operator delete(__p[0]);
          if ((SHIBYTE(v20) & 0x80000000) == 0)
          {
LABEL_20:
            if ((v19[23] & 0x80000000) == 0) {
              goto LABEL_21;
            }
            goto LABEL_27;
          }
        }
        else if ((SHIBYTE(v20) & 0x80000000) == 0)
        {
          goto LABEL_20;
        }
        operator delete(*(void **)&v19[24]);
        if ((v19[23] & 0x80000000) == 0)
        {
LABEL_21:
          if (!v4) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
LABEL_27:
        operator delete(*(void **)v19);
        if (!v4) {
          goto LABEL_29;
        }
LABEL_28:
        if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_29:
          uint64_t v11 = (KernelPCIABPTrace *)*((void *)v3 + 1);
          if (!v11) {
            goto LABEL_33;
          }
          goto LABEL_30;
        }
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
        uint64_t v11 = (KernelPCIABPTrace *)*((void *)v3 + 1);
        if (!v11)
        {
          do
          {
LABEL_33:
            BOOL v12 = (KernelPCIABPTrace *)*((void *)v3 + 2);
            BOOL v13 = *(void *)v12 == (void)v3;
            uint64_t v3 = v12;
          }
          while (!v13);
          goto LABEL_6;
        }
        do
        {
LABEL_30:
          BOOL v12 = v11;
          uint64_t v11 = *(KernelPCIABPTrace **)v11;
        }
        while (v11);
LABEL_6:
        uint64_t v3 = v12;
        if (v12 == (KernelPCIABPTrace *)((char *)this + 200)) {
          goto LABEL_39;
        }
      }
      uint64_t v10 = *((void *)this + 5);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
LABEL_17:
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Create and open log writer", buf, 2u);
      goto LABEL_18;
    }
LABEL_39:
    KernelPCIABPTrace::dumpCodeRegistry_sync(this);
  }
  else
  {
    size_t v14 = *((void *)this + 5);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v19 = 0;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#E Registering with Kernel driver failed. De-register to cleanup", v19, 2u);
    }
    KernelPCIABPTrace::deregisterWithKernel_sync(this);
  }
}

void sub_1A61384C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  operator delete(v27);
  if (a18 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::stopTrace(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 136315138;
    BOOL v13 = "stopTrace";
    _os_log_debug_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  }
  int v5 = *(void **)(a1 + 200);
  *(unsigned char *)(a1 + 153) = 0;
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(v5);
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  long long v6 = dispatch_group_create();
  long long v7 = v6;
  uint64_t v11 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v7);
  }
  CFDictionaryRef v10 = 0;
  KernelPCIABPTrace::snapshot_sync(a1, &v11, &v10);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  uint64_t v8 = *(NSObject **)(a1 + 88);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  _OWORD v9[2] = ___ZN17KernelPCIABPTrace9stopTraceERKN8dispatch13group_sessionE_block_invoke;
  v9[3] = &__block_descriptor_tmp_8;
  void v9[4] = a1;
  void v9[5] = a2;
  dispatch_group_notify(v7, v8, v9);
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_1A61386B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
    dispatch_release(v7);
  }
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::snapshot_sync(uint64_t a1, NSObject **a2, const __CFDictionary **a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  long long v6 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    if (!*(void *)(a1 + 216)) {
      return;
    }
LABEL_3:
    v64[0] = 0xAAAAAAAAAAAAAAAALL;
    v64[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v64, *a3);
    memset(buf, 170, sizeof(buf));
    __p[0] = operator new(0x28uLL);
    *(_OWORD *)&__p[1] = xmmword_1A61F71C0;
    strcpy((char *)__p[0], "kCollectTelephonyLogsWithCoredump");
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v62, "kKeyTraceAction");
    ctu::cf::map_adapter::getString();
    MEMORY[0x1A62748E0](v62);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    memset(__p, 170, sizeof(__p));
    long long v7 = (const char *)*MEMORY[0x1E4F4C4C8];
    memset(v62, 0, sizeof(v62));
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&__dst, v7);
    ctu::cf::map_adapter::getString();
    MEMORY[0x1A62748E0](&__dst);
    if (SHIBYTE(v62[2]) < 0) {
      operator delete(v62[0]);
    }
    memset(v62, 170, sizeof(v62));
    uint64_t v8 = (void *)HIBYTE(__p[2]);
    if (SHIBYTE(__p[2]) < 0) {
      uint64_t v8 = __p[1];
    }
    if (v8) {
      uint64_t v9 = abm::trace::kSnapshotFolder;
    }
    else {
      uint64_t v9 = abm::trace::kTrashFolder;
    }
    CFDictionaryRef v10 = *v9;
    size_t v11 = strlen(*v9);
    if (v11 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v12 = v11;
    if (v11 >= 0x17)
    {
      uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v14 = v11 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_dst = (std::string *)operator new(v14 + 1);
      __dst.__r_.__value_.__l.__size_ = v12;
      __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v11;
      p_dst = &__dst;
      if (!v11)
      {
LABEL_20:
        p_dst->__r_.__value_.__s.__data_[v12] = 0;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v60, "kKeyTraceDumpStatePath");
        ctu::cf::map_adapter::getString();
        MEMORY[0x1A62748E0](&v60);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        std::string v16 = abm::trace::kLogDirPrefix[0];
        size_t v17 = strlen(abm::trace::kLogDirPrefix[0]);
        if (v17 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v18 = v17;
        if (v17 >= 0x17)
        {
          uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v17 | 7) != 0x17) {
            uint64_t v20 = v17 | 7;
          }
          uint64_t v21 = v20 + 1;
          xpc_object_t v19 = operator new(v20 + 1);
          v58.__r_.__value_.__l.__size_ = v18;
          v58.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
          v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
        }
        else
        {
          *((unsigned char *)&v58.__r_.__value_.__s + 23) = v17;
          xpc_object_t v19 = &v58;
          if (!v17)
          {
LABEL_30:
            v19[v18] = 0;
            if (SHIBYTE(v62[2]) >= 0) {
              long long v22 = v62;
            }
            else {
              long long v22 = (void **)v62[0];
            }
            if (SHIBYTE(v62[2]) >= 0) {
              std::string::size_type v23 = HIBYTE(v62[2]);
            }
            else {
              std::string::size_type v23 = (std::string::size_type)v62[1];
            }
            uint64_t v24 = std::string::insert(&v58, 0, (const std::string::value_type *)v22, v23);
            long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
            v59.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v25;
            v24->__r_.__value_.__l.__size_ = 0;
            v24->__r_.__value_.__r.__words[2] = 0;
            v24->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(__p[2]) >= 0) {
              xpc_object_t v26 = __p;
            }
            else {
              xpc_object_t v26 = (void **)__p[0];
            }
            if (SHIBYTE(__p[2]) >= 0) {
              std::string::size_type v27 = HIBYTE(__p[2]);
            }
            else {
              std::string::size_type v27 = (std::string::size_type)__p[1];
            }
            xpc_object_t v28 = std::string::append(&v59, (const std::string::value_type *)v26, v27);
            long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
            v60.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v29;
            v28->__r_.__value_.__l.__size_ = 0;
            v28->__r_.__value_.__r.__words[2] = 0;
            v28->__r_.__value_.__r.__words[0] = 0;
            unint64_t v30 = std::string::append(&v60, "-", 1uLL);
            long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v31;
            v30->__r_.__value_.__l.__size_ = 0;
            v30->__r_.__value_.__r.__words[2] = 0;
            v30->__r_.__value_.__r.__words[0] = 0;
            char v57 = 7;
            strcpy((char *)v56, "pci-bin");
            uint64_t v32 = std::string::append(&__dst, (const std::string::value_type *)v56, 7uLL);
            std::string::size_type v33 = v32->__r_.__value_.__r.__words[0];
            v65[0] = v32->__r_.__value_.__l.__size_;
            *(void *)((char *)v65 + 7) = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
            char v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
            v32->__r_.__value_.__l.__size_ = 0;
            v32->__r_.__value_.__r.__words[2] = 0;
            v32->__r_.__value_.__r.__words[0] = 0;
            if (*(char *)(a1 + 255) < 0) {
              operator delete(*(void **)(a1 + 232));
            }
            uint64_t v35 = v65[0];
            *(void *)(a1 + 232) = v33;
            *(void *)(a1 + 240) = v35;
            *(void *)(a1 + 247) = *(void *)((char *)v65 + 7);
            *(unsigned char *)(a1 + 255) = v34;
            if (v57 < 0)
            {
              operator delete(v56[0]);
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_46:
                if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_47;
                }
                goto LABEL_97;
              }
            }
            else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_46;
            }
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v60.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_47:
              if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_48;
              }
              goto LABEL_98;
            }
LABEL_97:
            operator delete(v60.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_48:
              if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_49;
              }
LABEL_99:
              operator delete(v58.__r_.__value_.__l.__data_);
LABEL_49:
              uint64_t v36 = buf[23];
              if ((buf[23] & 0x80u) != 0) {
                uint64_t v36 = *(void *)&buf[8];
              }
              if (v36 == 17)
              {
                long long v37 = buf;
                if ((buf[23] & 0x80u) != 0) {
                  long long v37 = *(uint8_t **)buf;
                }
                uint64_t v38 = *(void *)v37;
                uint64_t v39 = *((void *)v37 + 1);
                uint64_t v40 = v37[16];
                BOOL v41 = v38 == *(void *)"kShutdownAllTrace" && v39 == *(void *)"nAllTrace";
                if (v41 && v40 == str_72[16])
                {
                  std::locale v43 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl(&dword_1A609F000, v43, OS_LOG_TYPE_DEFAULT, "#I Snapshot requested as part of shutdown", (uint8_t *)&__dst, 2u);
                  }
                  *(unsigned char *)(a1 + 153) = 0;
                }
              }
              xpc_object_t v44 = *a2;
              if (v44)
              {
                dispatch_retain(v44);
                dispatch_group_enter(v44);
              }
              xpc_object_t v45 = *(NSObject **)(a1 + 256);
              *(void *)(a1 + 256) = v44;
              if (v45)
              {
                dispatch_group_leave(v45);
                dispatch_release(v45);
              }
              int v46 = *(void **)(a1 + 192);
              if (v46 != (void *)(a1 + 200))
              {
                do
                {
                  std::string::size_type v48 = v46[4];
                  xpc_object_t v47 = (std::__shared_weak_count *)v46[5];
                  __dst.__r_.__value_.__r.__words[0] = v48;
                  __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v47;
                  if (v47) {
                    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  BuffContext_sync = KernelPCIABPTrace::createBuffContext_sync(a1, 0, (uint64_t *)&__dst);
                  int v50 = (*(uint64_t (**)(void, void, uint64_t, void (*)(void *, int, uint64_t), void *))(**(void **)(a1 + 216) + 80))(*(void *)(a1 + 216), *(unsigned int *)(v48 + 24), 1, flushLogsCompletionCB, BuffContext_sync);
                  unsigned __int8 v51 = *(NSObject **)(a1 + 40);
                  BOOL v52 = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
                  if (v50)
                  {
                    if (v52)
                    {
                      LOWORD(v60.__r_.__value_.__l.__data_) = 0;
                      _os_log_impl(&dword_1A609F000, v51, OS_LOG_TYPE_DEFAULT, "#E Failed assigning null-buffer to trigger snapshot", (uint8_t *)&v60, 2u);
                    }
                    KernelPCIABPTrace::deleteBuffContext_sync((void *)a1, (unint64_t)BuffContext_sync);
                    long long v53 = *(NSObject **)(a1 + 256);
                    *(void *)(a1 + 256) = 0;
                    if (v53)
                    {
                      dispatch_group_leave(v53);
                      dispatch_release(v53);
                    }
                  }
                  else if (v52)
                  {
                    LOWORD(v60.__r_.__value_.__l.__data_) = 0;
                    _os_log_impl(&dword_1A609F000, v51, OS_LOG_TYPE_DEFAULT, "#I Assign null-buffer to trigger snapshot", (uint8_t *)&v60, 2u);
                  }
                  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                    std::__shared_weak_count::__release_weak(v47);
                    xpc_object_t v54 = (void *)v46[1];
                    if (!v54)
                    {
                      do
                      {
LABEL_87:
                        xpc_object_t v55 = (void *)v46[2];
                        BOOL v41 = *v55 == (void)v46;
                        int v46 = v55;
                      }
                      while (!v41);
                      goto LABEL_71;
                    }
                  }
                  else
                  {
                    xpc_object_t v54 = (void *)v46[1];
                    if (!v54) {
                      goto LABEL_87;
                    }
                  }
                  do
                  {
                    xpc_object_t v55 = v54;
                    xpc_object_t v54 = (void *)*v54;
                  }
                  while (v54);
LABEL_71:
                  int v46 = v55;
                }
                while (v55 != (void *)(a1 + 200));
              }
              if (SHIBYTE(v62[2]) < 0)
              {
                operator delete(v62[0]);
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                {
LABEL_92:
                  if (((char)buf[23] & 0x80000000) == 0)
                  {
LABEL_93:
                    MEMORY[0x1A6274930](v64);
                    return;
                  }
LABEL_102:
                  operator delete(*(void **)buf);
                  goto LABEL_93;
                }
              }
              else if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
              {
                goto LABEL_92;
              }
              operator delete(__p[0]);
              if (((char)buf[23] & 0x80000000) == 0) {
                goto LABEL_93;
              }
              goto LABEL_102;
            }
LABEL_98:
            operator delete(v59.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_49;
            }
            goto LABEL_99;
          }
        }
        memmove(v19, v16, v18);
        goto LABEL_30;
      }
    }
    memmove(p_dst, v10, v12);
    goto LABEL_20;
  }
  *(_DWORD *)std::string buf = 136315138;
  *(void *)&uint8_t buf[4] = "snapshot_sync";
  _os_log_debug_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  if (*(void *)(a1 + 216)) {
    goto LABEL_3;
  }
}

void sub_1A6138E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a40 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a33 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((a40 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a35);
  if ((a33 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a26 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(a28);
  if ((a26 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a20 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a21);
  if ((a20 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a47 & 0x80000000) == 0)
    {
LABEL_14:
      if (a53 < 0) {
        operator delete(a48);
      }
      if (*(char *)(v53 - 105) < 0) {
        operator delete(*(void **)(v53 - 128));
      }
      MEMORY[0x1A6274930](v53 - 160);
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a42);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a15);
  if ((a47 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

void ___ZN17KernelPCIABPTrace9stopTraceERKN8dispatch13group_sessionE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(KernelPCIABPTrace **)(a1 + 32);
  KernelPCIABPTrace::deregisterWithKernel_sync(v1);
  uint64_t v2 = (void *)*((void *)v1 + 24);
  uint64_t v3 = (void *)((char *)v1 + 200);
  if (v2 != (void *)((char *)v1 + 200))
  {
    do
    {
      uint64_t v5 = v2[4];
      uint64_t v4 = (std::__shared_weak_count *)v2[5];
      std::string::size_type v12 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v6 = *(void *)(v5 + 32);
      if (v6
        && ((*(void (**)(uint64_t))(*(void *)v6 + 16))(v6),
            (*(void (**)(void))(**(void **)(v5 + 32) + 64))(*(void *)(v5 + 32)),
            long long v7 = *(std::__shared_weak_count **)(v5 + 40),
            *(void *)(v5 + 32) = 0,
            *(void *)(v5 + 40) = 0,
            v7)
        && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        uint64_t v8 = v12;
        if (v12)
        {
LABEL_10:
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      else
      {
        uint64_t v8 = v12;
        if (v12) {
          goto LABEL_10;
        }
      }
      uint64_t v9 = (void *)v2[1];
      if (v9)
      {
        do
        {
          CFDictionaryRef v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          CFDictionaryRef v10 = (void *)v2[2];
          BOOL v11 = *v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v11);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
  }
}

void sub_1A61391C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void KernelPCIABPTrace::deregisterWithKernel_sync(KernelPCIABPTrace *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v7 = 136315138;
    uint64_t v8 = "deregisterWithKernel_sync";
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v7, 0xCu);
    uint64_t v3 = *((void *)this + 27);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 27);
    if (!v3) {
      return;
    }
  }
  uint64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Stop Kernel Trace interface", (uint8_t *)&v7, 2u);
    uint64_t v3 = *((void *)this + 27);
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  uint64_t v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Destroy Kernel Trace object", (uint8_t *)&v7, 2u);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 28);
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  if (*((unsigned char *)this + 264))
  {
    dispatch_group_leave(*((dispatch_group_t *)this + 18));
    *((unsigned char *)this + 264) = 0;
  }
}

void KernelPCIABPTrace::start(void *a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (uint64_t v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v7 = v6;
  uint64_t v8 = operator new(0x10uLL);
  void *v8 = a1;
  v8[1] = v3;
  uint64_t v9 = a1[11];
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  CFDictionaryRef v10 = operator new(0x18uLL);
  *CFDictionaryRef v10 = v8;
  v10[1] = v5;
  uint64_t v10[2] = v7;
  dispatch_async_f(v9, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t KernelPCIABPTrace::registerWithKernel_sync(KernelPCIABPTrace *this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "registerWithKernel_sync";
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&buf, 0xCu);
    if (*((unsigned char *)this + 264)) {
      goto LABEL_5;
    }
  }
  else if (*((unsigned char *)this + 264))
  {
    goto LABEL_5;
  }
  uint64_t v3 = *((void *)this + 18);
  if (v3)
  {
    dispatch_group_enter(v3);
    *((unsigned char *)this + 264) = 1;
  }
LABEL_5:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 28);
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (uint64_t **)((char *)this + 200);
  std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*((void **)this + 25));
  *((void *)this + 24) = (char *)this + 200;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  pci::transport::kernelTrace::create((uint64_t *)&buf, v6);
  uint64_t v7 = buf;
  if ((void)buf)
  {
    uint64_t v8 = operator new(0x20uLL);
    void *v8 = &unk_1EFB0C238;
    v8[1] = 0;
    _OWORD v8[2] = 0;
    v8[3] = v7;
    *(void *)&long long buf = 0;
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 28);
    *((void *)this + 27) = v7;
    *((void *)this + 28) = v8;
    if (v9) {
      goto LABEL_10;
    }
  }
  else
  {
    *(void *)&long long buf = 0;
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 28);
    *((void *)this + 27) = 0;
    *((void *)this + 28) = 0;
    if (v9)
    {
LABEL_10:
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      uint64_t v10 = buf;
      *(void *)&long long buf = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
      if (!*((void *)this + 27)) {
        goto LABEL_15;
      }
      goto LABEL_19;
    }
  }
  if (!v7)
  {
LABEL_15:
    BOOL v11 = *((void *)this + 5);
    uint64_t v12 = 0;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return v12;
    }
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#E ABP Trace object creation failed", (uint8_t *)&buf, 2u);
    return 0;
  }
LABEL_19:
  BOOL v13 = (std::__shared_weak_count *)*((void *)this + 17);
  if (!v13) {
    return 0;
  }
  uint64_t v14 = std::__shared_weak_count::lock(v13);
  *((void *)&buf + 1) = v14;
  if (!v14) {
    return 0;
  }
  uint64_t v15 = v14;
  uint64_t v16 = *((void *)this + 16);
  *(void *)&long long buf = v16;
  if (!v16)
  {
LABEL_45:
    uint64_t v12 = 0;
    goto LABEL_52;
  }
  uint64_t v17 = *((void *)this + 27);
  std::string::size_type v18 = *(std::__shared_weak_count **)(v16 + 128);
  if (!v18 || (xpc_object_t v19 = std::__shared_weak_count::lock(v18)) == 0)
  {
    uint64_t v22 = 0;
    goto LABEL_30;
  }
  uint64_t v20 = v19;
  uint64_t v21 = *(void *)(v16 + 120);
  if (v21)
  {
    uint64_t v22 = *(void *)(v21 + 168);
    if (atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v22 = 0;
    if (atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_30;
    }
  }
  ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
  std::__shared_weak_count::__release_weak(v20);
LABEL_30:
  char v24 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, v22);
  long long v25 = *((void *)this + 5);
  BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
  if ((v24 & 1) == 0)
  {
    if (v26)
    {
      *(_WORD *)xpc_object_t v55 = 0;
      _os_log_impl(&dword_1A609F000, v25, OS_LOG_TYPE_DEFAULT, "#E Kernel Trace start failed", v55, 2u);
    }
    goto LABEL_45;
  }
  if (v26)
  {
    *(_WORD *)xpc_object_t v55 = 0;
    _os_log_impl(&dword_1A609F000, v25, OS_LOG_TYPE_DEFAULT, "#I Started Kernel Trace interface", v55, 2u);
  }
  unsigned int v54 = 0;
  char v27 = (*(uint64_t (**)(void, unsigned int *))(**((void **)this + 27) + 112))(*((void *)this + 27), &v54);
  unsigned int v28 = v54;
  if (v54) {
    char v29 = v27;
  }
  else {
    char v29 = 0;
  }
  if ((v29 & 1) == 0)
  {
    std::string::size_type v33 = *((void *)this + 5);
    uint64_t v12 = 0;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_51;
    }
    *(_WORD *)xpc_object_t v55 = 0;
    _os_log_impl(&dword_1A609F000, v33, OS_LOG_TYPE_DEFAULT, "#E Failed to get buffer constraints from kernel", v55, 2u);
LABEL_50:
    uint64_t v12 = 0;
LABEL_51:
    uint64_t v15 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (*((void *)&buf + 1)) {
      goto LABEL_52;
    }
    return v12;
  }
  *((_DWORD *)this + 41) = v54;
  unint64_t v30 = *((void *)this + 5);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)xpc_object_t v55 = 67109120;
    *(_DWORD *)&v55[4] = v28 >> 10;
    _os_log_impl(&dword_1A609F000, v30, OS_LOG_TYPE_DEFAULT, "#I Set buffer size to '%d KB'", v55, 8u);
  }
  if (!(*(unsigned int (**)(void, unsigned int *))(**((void **)this + 27) + 136))(*((void *)this + 27), &v54)|| (unsigned int v31 = v54, v31 < *((_DWORD *)this + 40)* (*(unsigned int (**)(void))(**((void **)this + 27) + 40))(*((void *)this + 27))))
  {
    uint64_t v32 = *((void *)this + 5);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v55 = 0;
      _os_log_error_impl(&dword_1A609F000, v32, OS_LOG_TYPE_ERROR, "Buffer count exceeded kernel limits", v55, 2u);
    }
    goto LABEL_50;
  }
  for (uint64_t i = 0;
        i < (*(unsigned int (**)(void))(**((void **)this + 27) + 40))(*((void *)this + 27));
        uint64_t i = (i + 1))
  {
    int v53 = -1431655766;
    if (((*(uint64_t (**)(void, uint64_t, int *, uint64_t *, uint64_t))(**((void **)this + 27) + 48))(*((void *)this + 27), i, &v53, &KernelPCIABPTrace::registerWithKernel_sync(void)::name, 256) & 1) == 0)continue; {
    byte_1EB5EE7DF = 0;
    }
    if (KernelPCIABPTrace::registerWithKernel_sync(void)::name == 0x76655F7374617473 && dword_1EB5EE6E8 == 7630437) {
      continue;
    }
    int v36 = v53;
    long long v37 = operator new(0x48uLL);
    v37[1] = 0;
    void v37[2] = 0;
    void *v37 = &unk_1EFB0C288;
    uint64_t v38 = (char *)(v37 + 3);
    size_t v39 = strlen((const char *)&KernelPCIABPTrace::registerWithKernel_sync(void)::name);
    if (v39 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v40 = v39;
    if (v39 >= 0x17)
    {
      uint64_t v42 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v39 | 7) != 0x17) {
        uint64_t v42 = v39 | 7;
      }
      uint64_t v43 = v42 + 1;
      BOOL v41 = operator new(v42 + 1);
      v37[4] = v40;
      v37[5] = v43 | 0x8000000000000000;
      _OWORD v37[3] = v41;
LABEL_72:
      memcpy(v41, &KernelPCIABPTrace::registerWithKernel_sync(void)::name, v40);
      goto LABEL_73;
    }
    *((unsigned char *)v37 + 47) = v39;
    BOOL v41 = v37 + 3;
    if (v39) {
      goto LABEL_72;
    }
LABEL_73:
    *((unsigned char *)v41 + v40) = 0;
    *((_DWORD *)v37 + 12) = v36;
    v37[7] = 0;
    v37[8] = 0;
    *(void *)xpc_object_t v55 = v37 + 3;
    long long v56 = (std::__shared_weak_count *)v37;
    xpc_object_t v44 = (uint64_t **)((char *)this + 200);
    xpc_object_t v45 = (uint64_t **)((char *)this + 200);
    int v46 = *v5;
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          xpc_object_t v45 = (uint64_t **)v46;
          unint64_t v47 = v46[4];
          if ((unint64_t)v38 >= v47) {
            break;
          }
          int v46 = *v45;
          xpc_object_t v44 = v45;
          if (!*v45) {
            goto LABEL_80;
          }
        }
        if (v47 >= (unint64_t)v38) {
          break;
        }
        int v46 = v45[1];
        if (!v46)
        {
          xpc_object_t v44 = v45 + 1;
          goto LABEL_80;
        }
      }
    }
    else
    {
LABEL_80:
      std::string::size_type v48 = (uint64_t *)operator new(0x30uLL);
      v48[4] = (uint64_t)v38;
      v48[5] = (uint64_t)v37;
      atomic_fetch_add_explicit(v37 + 1, 1uLL, memory_order_relaxed);
      uint64_t *v48 = 0;
      v48[1] = 0;
      v48[2] = (uint64_t)v45;
      *xpc_object_t v44 = v48;
      uint64_t v49 = **((void **)this + 24);
      if (v49)
      {
        *((void *)this + 24) = v49;
        std::string::size_type v48 = *v44;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 25), v48);
      ++*((void *)this + 26);
    }
    char BufferQueue_sync = KernelPCIABPTrace::allocateBufferQueue_sync((uint64_t)this, (uint64_t *)v55);
    unsigned __int8 v51 = v56;
    if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    if ((BufferQueue_sync & 1) == 0) {
      goto LABEL_50;
    }
  }
  RunLoop = (__CFRunLoop *)abm::BasebandTracingTask::getRunLoop((abm::BasebandTracingTask *)buf);
  CFRunLoopWakeUp(RunLoop);
  uint64_t v12 = 1;
  uint64_t v15 = (std::__shared_weak_count *)*((void *)&buf + 1);
  if (!*((void *)&buf + 1)) {
    return v12;
  }
LABEL_52:
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v12;
}

void sub_1A6139CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v15);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1A6139CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6139CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A6139D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6139D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6139D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6139D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6139D68(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::flushLogsCompletion(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v16 = 136315138;
    uint64_t v17 = "flushLogsCompletion";
    _os_log_debug_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v16, 0xCu);
    uint64_t v9 = (std::__shared_weak_count *)a1[10];
    if (!v9) {
LABEL_8:
    }
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  else
  {
    uint64_t v9 = (std::__shared_weak_count *)a1[10];
    if (!v9) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = a1[9];
  BOOL v11 = std::__shared_weak_count::lock(v9);
  if (!v11) {
    goto LABEL_8;
  }
  uint64_t v12 = v11;
  BOOL v13 = operator new(0x20uLL);
  *BOOL v13 = a1;
  v13[1] = a2;
  *((_DWORD *)v13 + 4) = a4;
  v13[3] = a3;
  uint64_t v14 = a1[11];
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v15 = operator new(0x18uLL);
  void *v15 = v13;
  v15[1] = v10;
  v15[2] = v12;
  dispatch_async_f(v14, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A6139F24(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void KernelPCIABPTrace::fileSnapshot_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!*(void *)a2) {
    return;
  }
  uint64_t v4 = *(void *)(*(void *)a2 + 32);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  if (*(unsigned char *)(a1 + 153))
  {
    *(void *)std::string __p = operator new(0x48uLL);
    *(_OWORD *)&__p[8] = xmmword_1A61F7560;
    strcpy(*(char **)__p, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
    qmemcpy(v27, "pci-bin.scratch/BasebandManager/brary/Logs/Apple/var/wireless/Li", sizeof(v27));
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&block.st_blkstd::string::size_type size = v5;
    *(timespec *)block.st_qspare = v5;
    block.st_birthtimespec = v5;
    *(timespec *)&block.st_std::string::size_type size = v5;
    block.st_mtimespec = v5;
    block.st_ctimespec = v5;
    *(timespec *)&block.st_uid = v5;
    block.st_atimespec = v5;
    *(timespec *)&block.st_dev = v5;
    if (stat(*(const char **)__p, &block))
    {
      LODWORD(v6) = 0;
    }
    else
    {
      if (__p[23] >= 0) {
        uint64_t v7 = __p;
      }
      else {
        uint64_t v7 = *(const char **)__p;
      }
      uint64_t v8 = opendir(v7);
      uint64_t v6 = v8;
      if (v8)
      {
        uint64_t v9 = readdir(v8);
        closedir(v6);
        LODWORD(v6) = v9 != 0;
      }
    }
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if (v6)
      {
LABEL_14:
        support::fs::getBasePath((unsigned __int8 *)(a1 + 232), (uint64_t)&block);
        support::fs::createDir((const char *)&block, 0x1EDu, 1);
        if (SHIBYTE(block.st_gid) < 0)
        {
          operator delete(*(void **)&block.st_dev);
          memset(&block, 170, 24);
          if ((*(char *)(a1 + 255) & 0x80000000) == 0) {
            goto LABEL_16;
          }
        }
        else
        {
          memset(&block, 170, 24);
          if ((*(char *)(a1 + 255) & 0x80000000) == 0)
          {
LABEL_16:
            std::string v28 = *(std::string *)(a1 + 232);
            goto LABEL_22;
          }
        }
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(a1 + 232), *(void *)(a1 + 240));
LABEL_22:
        support::fs::createUniquePath((const char *)&v28, (std::string *)&block);
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v28.__r_.__value_.__l.__data_);
        }
        BOOL v11 = (std::__fs::filesystem::path *)operator new(0x48uLL);
        BOOL v13 = v11;
        *(_OWORD *)&v11->__pn_.__r_.__value_.__l.__data_ = v27[3];
        *(_OWORD *)&v11->__pn_.__r_.__value_.__r.__words[2] = v27[2];
        *(_OWORD *)&v11[1].__pn_.__r_.__value_.__r.__words[1] = v27[1];
        *(_OWORD *)&v11[2].__pn_.__r_.__value_.__l.__data_ = v27[0];
        v11[2].__pn_.__r_.__value_.__s.__data_[16] = 0;
        if ((block.st_gid & 0x80000000) == 0) {
          p_blocuint64_t k = &block;
        }
        else {
          p_blocuint64_t k = *(stat **)&block.st_dev;
        }
        rename(v11, (const std::__fs::filesystem::path *)p_block, v12);
        int v16 = v15;
        operator delete(v13);
        uint64_t v17 = *(NSObject **)(a1 + 40);
        BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        if (v16)
        {
          if (!v18) {
            goto LABEL_37;
          }
          xpc_object_t v19 = &block;
          if ((block.st_gid & 0x80000000) != 0) {
            xpc_object_t v19 = *(stat **)&block.st_dev;
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v19;
          uint64_t v20 = "#E Failed to move scratch logs to snapshot path [%s]";
        }
        else
        {
          if (!v18) {
            goto LABEL_37;
          }
          uint64_t v21 = &block;
          if ((block.st_gid & 0x80000000) != 0) {
            uint64_t v21 = *(stat **)&block.st_dev;
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v21;
          uint64_t v20 = "#I Snapshot files are in path [%s]";
        }
        _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, v20, __p, 0xCu);
LABEL_37:
        if (SHIBYTE(block.st_gid) < 0) {
          operator delete(*(void **)&block.st_dev);
        }
LABEL_39:
        uint64_t v22 = *(void *)(*(void *)a2 + 32);
        if (v22)
        {
          char v29 = __p;
          *(void *)std::string __p = MEMORY[0x1E4F143A8];
          *(void *)&__p[8] = 0x40000000;
          *(void *)&__p[16] = ___ZN21CircularFileLogWriter4openEv_block_invoke;
          unsigned int v31 = &__block_descriptor_tmp;
          uint64_t v32 = v22;
          *(void *)&block.st_dev = MEMORY[0x1E4F143A8];
          block.st_ino = 0x40000000;
          *(void *)&block.st_uid = ___ZNK3ctu20SharedSynchronizableI21CircularFileLogWriterE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
          *(void *)&block.st_rdev = &__block_descriptor_tmp_21;
          block.st_atimespec.tv_sec = v22 + 8;
          block.st_atimespec.uint64_t tv_nsec = (uint64_t)&v29;
          std::string::size_type v23 = *(NSObject **)(v22 + 24);
          if (*(void *)(v22 + 32)) {
            dispatch_async_and_wait(v23, &block);
          }
          else {
            dispatch_sync(v23, &block);
          }
        }
        goto LABEL_43;
      }
    }
    else if (v6)
    {
      goto LABEL_14;
    }
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      block.st_dev = 136315138;
      *(void *)&block.st_mode = "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/";
      _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#E Couldn't find scratch path [%s]", (uint8_t *)&block, 0xCu);
    }
    goto LABEL_39;
  }
LABEL_43:
  v24.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v24.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&block.st_blkstd::string::size_type size = v24;
  *(timespec *)block.st_qspare = v24;
  block.st_birthtimespec = v24;
  *(timespec *)&block.st_std::string::size_type size = v24;
  block.st_mtimespec = v24;
  block.st_ctimespec = v24;
  *(timespec *)&block.st_uid = v24;
  block.st_atimespec = v24;
  *(timespec *)&block.st_dev = v24;
  if (byte_1EB5EE9A0[23] >= 0) {
    long long v25 = byte_1EB5EE9A0;
  }
  else {
    long long v25 = *(const char **)byte_1EB5EE9A0;
  }
  if (stat(v25, &block)) {
    KernelPCIABPTrace::dumpCodeRegistry_sync((KernelPCIABPTrace *)a1);
  }
  if (*(char *)(a1 + 255) < 0)
  {
    **(unsigned char **)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    BOOL v26 = *(NSObject **)(a1 + 256);
    *(void *)(a1 + 256) = 0;
    if (!v26) {
      return;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 232) = 0;
    *(unsigned char *)(a1 + 255) = 0;
    BOOL v26 = *(NSObject **)(a1 + 256);
    *(void *)(a1 + 256) = 0;
    if (!v26) {
      return;
    }
  }
  dispatch_group_leave(v26);
  dispatch_release(v26);
}

void sub_1A613A3A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::readLogsCompletion(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v16 = 136315138;
    uint64_t v17 = "readLogsCompletion";
    _os_log_debug_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v16, 0xCu);
    uint64_t v9 = (std::__shared_weak_count *)a1[10];
    if (!v9) {
LABEL_8:
    }
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  else
  {
    uint64_t v9 = (std::__shared_weak_count *)a1[10];
    if (!v9) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = a1[9];
  BOOL v11 = std::__shared_weak_count::lock(v9);
  if (!v11) {
    goto LABEL_8;
  }
  uint64_t v12 = v11;
  BOOL v13 = operator new(0x20uLL);
  *BOOL v13 = a1;
  v13[1] = a2;
  *((_DWORD *)v13 + 4) = a4;
  v13[3] = a3;
  uint64_t v14 = a1[11];
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  int v15 = operator new(0x18uLL);
  void *v15 = v13;
  v15[1] = v10;
  v15[2] = v12;
  dispatch_async_f(v14, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A613A5A8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t KernelPCIABPTrace::allocateBufferQueue_sync(uint64_t a1, uint64_t *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    if (!*(_DWORD *)(a1 + 160)) {
      return 1;
    }
    unsigned int v4 = 0;
    while (1)
    {
      BuffContext_sync = KernelPCIABPTrace::createBuffContext_sync(a1, *(unsigned int *)(a1 + 164), a2);
      int v6 = (*(uint64_t (**)(void, void, void, void, void, void (*)(void *, int, uint64_t), void *))(**(void **)(a1 + 216) + 72))(*(void *)(a1 + 216), *(unsigned int *)(*a2 + 24), *BuffContext_sync, *((unsigned int *)BuffContext_sync + 2), 0, readLogsCompletionCB, BuffContext_sync);
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (v6) {
        break;
      }
      ++v4;
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *(_DWORD *)(a1 + 164) >> 10;
        *(_DWORD *)long long buf = 67109376;
        unsigned int v13 = v4;
        __int16 v14 = 1024;
        int v15 = v8;
        _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Pre-assign buffer # %d of size '%d KB' to fetch logs", buf, 0xEu);
      }
      if (v4 >= *(_DWORD *)(a1 + 160)) {
        return 1;
      }
    }
    int v10 = v6;
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      int v11 = *(_DWORD *)(a1 + 164) >> 10;
      *(_DWORD *)long long buf = 67109632;
      unsigned int v13 = v4 + 1;
      __int16 v14 = 1024;
      int v15 = v11;
      __int16 v16 = 1024;
      int v17 = v10;
      _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Failed pre-assigning buffer # %d of size '%d KB' to fetch logs. Status [0x%x]", buf, 0x14u);
    }
    KernelPCIABPTrace::deleteBuffContext_sync((void *)a1, (unint64_t)BuffContext_sync);
  }
  return 0;
}

void sub_1A613A8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t KernelPCIABPTrace::historyAsString@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  uint64_t v2 = a2;
  if (!*(_DWORD *)(this + 156))
  {
    a2[23] = 8;
    strcpy(a2, "Infinite");
    return this;
  }
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[7] = v3;
  v18[8] = v3;
  void v18[5] = v3;
  v18[6] = v3;
  void v18[3] = v3;
  v18[4] = v3;
  v18[1] = v3;
  v18[2] = v3;
  long long v17 = v3;
  v18[0] = v3;
  *(_OWORD *)std::string __p = v3;
  long long v16 = v3;
  long long v13 = v3;
  *(_OWORD *)stat __src = v3;
  long long v11 = v3;
  long long v12 = v3;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v11);
  unsigned int v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)" MB", 3);
  if ((BYTE8(v17) & 0x10) != 0)
  {
    int v6 = (unsigned char *)v17;
    if ((void *)v17 < __src[1])
    {
      *(void **)&long long v17 = __src[1];
      int v6 = __src[1];
    }
    uint64_t v7 = __src[0];
    size_t v5 = v6 - (char *)__src[0];
    if ((unint64_t)(v6 - (char *)__src[0]) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_20;
    }
  }
  else
  {
    if ((BYTE8(v17) & 8) == 0)
    {
      size_t v5 = 0;
      v2[23] = 0;
      goto LABEL_16;
    }
    uint64_t v7 = (const void *)*((void *)&v12 + 1);
    size_t v5 = *((void *)&v13 + 1) - *((void *)&v12 + 1);
    if (*((void *)&v13 + 1) - *((void *)&v12 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_20:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    int v10 = (char *)operator new(v8 + 1);
    *((void *)v2 + 1) = v5;
    *((void *)v2 + 2) = v9 | 0x8000000000000000;
    *(void *)uint64_t v2 = v10;
    uint64_t v2 = v10;
  }
  else
  {
    v2[23] = v5;
    if (!v5) {
      goto LABEL_16;
    }
  }
  memmove(v2, v7, v5);
LABEL_16:
  v2[v5] = 0;
  *(void *)&long long v11 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v11 + *(void *)(v11 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v11 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62751A0](v18);
}

void sub_1A613AB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void KernelPCIABPTrace::shutdown(void *a1, dispatch_object_t *a2)
{
  long long v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (uint64_t v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  uint64_t v8 = operator new(0x10uLL);
  void *v8 = a1;
  v8[1] = v3;
  uint64_t v9 = a1[11];
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  int v10 = operator new(0x18uLL);
  *int v10 = v8;
  v10[1] = v5;
  uint64_t v10[2] = v7;
  dispatch_async_f(v9, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

void KernelPCIABPTrace::snapshot(void *a1, dispatch_object_t *a2, const void **a3)
{
  uint64_t v5 = *a2;
  if (!*a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *a3;
    if (!*a3) {
      goto LABEL_8;
    }
LABEL_7:
    CFRetain(v8);
    goto LABEL_8;
  }
  dispatch_retain(*a2);
  dispatch_group_enter(v5);
  uint64_t v7 = *a2;
  if (v7) {
    dispatch_retain(v7);
  }
  uint64_t v8 = *a3;
  if (*a3) {
    goto LABEL_7;
  }
LABEL_8:
  uint64_t v9 = (std::__shared_weak_count *)a1[10];
  if (!v9 || (uint64_t v10 = a1[9], (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  long long v12 = v11;
  long long v13 = operator new(0x20uLL);
  *long long v13 = a1;
  v13[1] = v5;
  v13[2] = v7;
  v13[3] = v8;
  __int16 v14 = a1[11];
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  int v15 = operator new(0x18uLL);
  void *v15 = v13;
  v15[1] = v10;
  v15[2] = v12;
  dispatch_async_f(v14, v15, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A613AED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void KernelPCIABPTrace::dumpState(NSObject *a1, NSObject **a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  group[0] = a1;
  group[1] = *a2;
  if (*a2)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __p = *(std::string *)a3;
  }
  isa = (std::__shared_weak_count *)a1[10].isa;
  if (!isa || (Class v7 = a1[9].isa, (v8 = std::__shared_weak_count::lock(isa)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v9 = v8;
  uint64_t v10 = (char *)operator new(0x28uLL);
  *(_OWORD *)uint64_t v10 = *(_OWORD *)group;
  long long v11 = (std::string *)(v10 + 16);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v11, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *((void *)v10 + 4) = *((void *)&__p.__r_.__value_.__l + 2);
  }
  long long v12 = a1[11].isa;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  long long v13 = operator new(0x18uLL);
  *long long v13 = v10;
  v13[1] = v7;
  v13[2] = v9;
  dispatch_async_f(v12, v13, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>(KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_15:
    operator delete(__p.__r_.__value_.__l.__data_);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_15;
  }
}

void sub_1A613B094(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  long long v12 = *(NSObject **)(v10 + 8);
  if (v12)
  {
    dispatch_group_leave(v12);
    long long v13 = *(NSObject **)(v10 + 8);
    if (v13)
    {
      dispatch_release(v13);
      __clang_call_terminate(a1);
    }
  }
  __clang_call_terminate(a1);
}

uint64_t KernelPCIABPTrace::dumpState_sync@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, unsigned char *a5@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE998, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EE998))
  {
    std::string::basic_string[abi:ne180100]<0>(&qword_1EB5EE9B8, "\n----- KernelPCI Trace Dump State -----\n");
    __cxa_atexit(MEMORY[0x1E4FBA210], &qword_1EB5EE9B8, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EE998);
  }
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45[7] = v10;
  v45[8] = v10;
  v45[5] = v10;
  v45[6] = v10;
  v45[3] = v10;
  v45[4] = v10;
  v45[1] = v10;
  v45[2] = v10;
  v45[0] = v10;
  long long v43 = v10;
  long long v44 = v10;
  long long v41 = v10;
  *(_OWORD *)uint64_t v42 = v10;
  long long v39 = v10;
  long long v40 = v10;
  long long v38 = v10;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v38);
  if (a3)
  {
    if (byte_1EB5EE9CF >= 0) {
      long long v11 = &qword_1EB5EE9B8;
    }
    else {
      long long v11 = (uint64_t *)qword_1EB5EE9B8;
    }
    if (byte_1EB5EE9CF >= 0) {
      uint64_t v12 = byte_1EB5EE9CF;
    }
    else {
      uint64_t v12 = unk_1EB5EE9C0;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v38, (uint64_t)v11, v12);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v38, (uint64_t)"Enabled: ", 9);
  long long v13 = (void *)std::ostream::operator<<();
  LOBYTE(__p[0]) = a4;
  __int16 v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)__p, 1);
  int v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"History: ", 9);
  KernelPCIABPTrace::historyAsString(a1, (char *)__p);
  if ((v37 & 0x80u) == 0) {
    long long v16 = __p;
  }
  else {
    long long v16 = (void **)__p[0];
  }
  if ((v37 & 0x80u) == 0) {
    uint64_t v17 = v37;
  }
  else {
    uint64_t v17 = (uint64_t)__p[1];
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)v16, v17);
  char v47 = a4;
  unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)&v47, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Buffer size: ", 13);
  uint64_t v20 = (void *)std::ostream::operator<<();
  uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" bytes", 6);
  char v47 = a4;
  uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)&v47, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"Buffer count: ", 14);
  std::ostream::operator<<();
  if ((char)v37 < 0)
  {
    operator delete(__p[0]);
    int v23 = *(char *)(a2 + 23);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_18:
      if (!(_BYTE)v23) {
        goto LABEL_29;
      }
      goto LABEL_22;
    }
  }
  else
  {
    int v23 = *(char *)(a2 + 23);
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_18;
    }
  }
  if (!*(void *)(a2 + 8)) {
    goto LABEL_29;
  }
LABEL_22:
  LOBYTE(__p[0]) = a4;
  timespec v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v38, (uint64_t)__p, 1);
  long long v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Reason: ", 8);
  int v26 = *(char *)(a2 + 23);
  if (v26 >= 0) {
    uint64_t v27 = a2;
  }
  else {
    uint64_t v27 = *(void *)a2;
  }
  if (v26 >= 0) {
    uint64_t v28 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v28 = *(void *)(a2 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, v27, v28);
LABEL_29:
  if (a3) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v38, (uint64_t)"\n--------------------------------------\n", 40);
  }
  if ((BYTE8(v44) & 0x10) != 0)
  {
    uint64_t v30 = v44;
    if ((unint64_t)v44 < *((void *)&v41 + 1))
    {
      *(void *)&long long v44 = *((void *)&v41 + 1);
      uint64_t v30 = *((void *)&v41 + 1);
    }
    unsigned int v31 = (const void *)v41;
    size_t v29 = v30 - v41;
    if ((unint64_t)(v30 - v41) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_48;
    }
  }
  else
  {
    if ((BYTE8(v44) & 8) == 0)
    {
      size_t v29 = 0;
      a5[23] = 0;
      goto LABEL_44;
    }
    unsigned int v31 = (const void *)*((void *)&v39 + 1);
    size_t v29 = *((void *)&v40 + 1) - *((void *)&v39 + 1);
    if (*((void *)&v40 + 1) - *((void *)&v39 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_48:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v29 >= 0x17)
  {
    uint64_t v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v32 = v29 | 7;
    }
    uint64_t v33 = v32 + 1;
    uint64_t v34 = operator new(v32 + 1);
    *((void *)a5 + 1) = v29;
    *((void *)a5 + 2) = v33 | 0x8000000000000000;
    *(void *)a5 = v34;
    a5 = v34;
    goto LABEL_43;
  }
  a5[23] = v29;
  if (v29) {
LABEL_43:
  }
    memmove(a5, v31, v29);
LABEL_44:
  a5[v29] = 0;
  *(void *)&long long v38 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v38 + *(void *)(v38 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v38 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62751A0](v45);
}

void sub_1A613B50C(_Unwind_Exception *a1)
{
}

void sub_1A613B524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

BOOL KernelPCIABPTrace::setProperty(uint64_t a1, NSObject **a2, uint64_t a3, uint64_t a4)
{
  char v21 = 0;
  char v20 = 9;
  strcpy((char *)__p, "KernelPCI");
  char isSupported = abm::trace::isSupported((uint64_t)__p);
  char v9 = isSupported;
  if ((v20 & 0x80000000) == 0)
  {
    if (isSupported) {
      goto LABEL_3;
    }
    return 0;
  }
  operator delete(__p[0]);
  if ((v9 & 1) == 0) {
    return 0;
  }
LABEL_3:
  long long v10 = *a2;
  uint64_t v14 = a1;
  dispatch_group_t group = v10;
  if (v10)
  {
    dispatch_retain(v10);
    dispatch_group_enter(v10);
  }
  uint64_t v16 = a3;
  uint64_t v17 = a4;
  uint64_t v18 = &v21;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke;
  block[3] = &__block_descriptor_tmp_82;
  void block[4] = a1 + 72;
  void block[5] = &v14;
  long long v11 = *(NSObject **)(a1 + 88);
  if (*(void *)(a1 + 96))
  {
    dispatch_async_and_wait(v11, block);
    uint64_t v12 = group;
    if (!group) {
      return v21 != 0;
    }
LABEL_11:
    dispatch_group_leave(v12);
    if (group) {
      dispatch_release(group);
    }
    return v21 != 0;
  }
  dispatch_sync(v11, block);
  uint64_t v12 = group;
  if (group) {
    goto LABEL_11;
  }
  return v21 != 0;
}

void sub_1A613B6C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t KernelPCIABPTrace::setProperty_sync(uint64_t a1, NSObject **a2, char *a3, char *a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"setProperty_sync";
    _os_log_debug_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&__p, 0xCu);
  }
  if (prop::ipc::set(a3, a4))
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&__p, "Enabled");
    if (a3[23] >= 0) {
      char v9 = a3;
    }
    else {
      char v9 = *(const char **)a3;
    }
    if (strcasecmp(v9, (const char *)&__p))
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&__p, "History");
      if (strcasecmp(v9, (const char *)&__p))
      {
        *((unsigned char *)&__p.__r_.__value_.__s + 23) = 11;
        strcpy((char *)&__p, "BufferCount");
        if (strcasecmp(v9, (const char *)&__p))
        {
          long long v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            if (a4[23] >= 0) {
              std::string::size_type v29 = (std::string::size_type)a4;
            }
            else {
              std::string::size_type v29 = *(void *)a4;
            }
            LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
            WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v29;
            _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Unrecognized Set property request. Key=%s, Value=%s", (uint8_t *)&__p, 0x16u);
          }
          return 1;
        }
        memset(&v32, 0, sizeof(v32));
        char v34 = 3;
        LOWORD(v33[0]) = *(_WORD *)"IPC";
        WORD1(v33[0]) = str_42[2];
        memset(&__p, 0, sizeof(__p));
        BOOL v16 = defaults::get((char *)v33, a3, &__p);
        if (v16)
        {
          prop::file::get<std::string>((const void **)v33, (uint64_t)a3, (uint64_t)&__p, &v35);
          std::string v32 = v35;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if ((v34 & 0x80000000) == 0)
          {
LABEL_33:
            if (v16) {
              goto LABEL_34;
            }
            goto LABEL_79;
          }
        }
        else if ((v34 & 0x80000000) == 0)
        {
          goto LABEL_33;
        }
        operator delete(v33[0]);
        if (v16)
        {
LABEL_34:
          uint64_t v11 = util::convert<unsigned int>(&v32, (_DWORD *)(a1 + 160), 0);
          if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            return v11;
          }
LABEL_80:
          operator delete(v32.__r_.__value_.__l.__data_);
          return v11;
        }
LABEL_79:
        uint64_t v11 = 0;
        if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v11;
        }
        goto LABEL_80;
      }
      int v30 = -1431655766;
      memset(&v32, 0, sizeof(v32));
      char v34 = 3;
      LOWORD(v33[0]) = *(_WORD *)"IPC";
      WORD1(v33[0]) = str_42[2];
      memset(&__p, 0, sizeof(__p));
      BOOL v15 = defaults::get((char *)v33, a3, &__p);
      if (v15)
      {
        prop::file::get<std::string>((const void **)v33, (uint64_t)a3, (uint64_t)&__p, &v35);
        std::string v32 = v35;
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if ((v34 & 0x80000000) == 0)
        {
LABEL_26:
          if (v15) {
            goto LABEL_27;
          }
          goto LABEL_50;
        }
      }
      else if ((v34 & 0x80000000) == 0)
      {
        goto LABEL_26;
      }
      operator delete(v33[0]);
      if (v15)
      {
LABEL_27:
        uint64_t v11 = util::convert<int>(&v32, &v30, 0);
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_51;
        }
        goto LABEL_52;
      }
LABEL_50:
      uint64_t v11 = 0;
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
LABEL_51:
      }
        operator delete(v32.__r_.__value_.__l.__data_);
LABEL_52:
      if (!v11) {
        return v11;
      }
      if (*(_DWORD *)(a1 + 156) == v30) {
        return v11;
      }
      *(_DWORD *)(a1 + 156) = v30;
      unint64_t v19 = *(void **)(a1 + 192);
      if (v19 == (void *)(a1 + 200)) {
        return v11;
      }
      while (1)
      {
        uint64_t v20 = v19[4];
        char v21 = (std::__shared_weak_count *)v19[5];
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v22 = *(void *)(v20 + 32);
        if (v22)
        {
          uint64_t v23 = (uint64_t)*(int *)(a1 + 156) << 20;
          __p.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
          __p.__r_.__value_.__l.__size_ = 0x40000000;
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN21CircularFileLogWriter11setCapacityEm_block_invoke;
          unsigned __int8 v37 = &__block_descriptor_tmp_8;
          uint64_t v38 = v22;
          uint64_t v39 = v23;
          ctu::SharedSynchronizable<CircularFileLogWriter>::execute_wrapped((uint64_t *)(v22 + 8), (uint64_t)&__p);
        }
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
          timespec v24 = (void *)v19[1];
          if (!v24)
          {
            do
            {
LABEL_67:
              long long v25 = (void *)v19[2];
              BOOL v26 = *v25 == (void)v19;
              unint64_t v19 = v25;
            }
            while (!v26);
            goto LABEL_56;
          }
        }
        else
        {
          timespec v24 = (void *)v19[1];
          if (!v24) {
            goto LABEL_67;
          }
        }
        do
        {
          long long v25 = v24;
          timespec v24 = (void *)*v24;
        }
        while (v24);
LABEL_56:
        unint64_t v19 = v25;
        if (v25 == (void *)(a1 + 200)) {
          return v11;
        }
      }
    }
    LOBYTE(v30) = -86;
    memset(&v32, 0, sizeof(v32));
    char v34 = 3;
    LOWORD(v33[0]) = *(_WORD *)"IPC";
    WORD1(v33[0]) = str_42[2];
    memset(&__p, 0, sizeof(__p));
    BOOL v14 = defaults::get((char *)v33, a3, &__p);
    if (v14)
    {
      prop::file::get<std::string>((const void **)v33, (uint64_t)a3, (uint64_t)&__p, &v35);
      std::string v32 = v35;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v34 & 0x80000000) == 0)
      {
LABEL_19:
        if (v14) {
          goto LABEL_20;
        }
        goto LABEL_38;
      }
    }
    else if ((v34 & 0x80000000) == 0)
    {
      goto LABEL_19;
    }
    operator delete(v33[0]);
    if (v14)
    {
LABEL_20:
      uint64_t v11 = util::convert<BOOL>(&v32, (BOOL *)&v30, 0);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_39;
      }
      goto LABEL_40;
    }
LABEL_38:
    uint64_t v11 = 0;
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
LABEL_39:
    }
      operator delete(v32.__r_.__value_.__l.__data_);
LABEL_40:
    if (!v11 || v30 == *(unsigned __int8 *)(a1 + 152)) {
      return v11;
    }
    *(unsigned char *)(a1 + 152) = v30;
    uint64_t v17 = *a2;
    dispatch_object_t object = v17;
    if (v17)
    {
      dispatch_retain(v17);
      dispatch_group_enter(v17);
    }
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateTraceState_sync";
      _os_log_debug_impl(&dword_1A609F000, v18, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&__p, 0xCu);
      if (*(unsigned char *)(a1 + 152))
      {
LABEL_46:
        if (!*(unsigned char *)(a1 + 153)) {
          KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)a1);
        }
        goto LABEL_87;
      }
    }
    else if (*(unsigned char *)(a1 + 152))
    {
      goto LABEL_46;
    }
    KernelPCIABPTrace::stopTrace(a1, (uint64_t)&object);
    uint64_t v17 = object;
LABEL_87:
    if (v17)
    {
      dispatch_group_leave(v17);
      if (object) {
        dispatch_release(object);
      }
    }
    return v11;
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (a3[23] >= 0) {
      std::string::size_type v27 = (std::string::size_type)a3;
    }
    else {
      std::string::size_type v27 = *(void *)a3;
    }
    if (a4[23] >= 0) {
      std::string::size_type v28 = (std::string::size_type)a4;
    }
    else {
      std::string::size_type v28 = *(void *)a4;
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v27;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v28;
    _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Set property to file failed; key=%s value=%s",
      (uint8_t *)&__p,
      0x16u);
  }
  return 0;
}

void sub_1A613BE04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t KernelPCIABPTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v7 = 0;
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = a3;
  v6[3] = &v7;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke;
  block[3] = &__block_descriptor_tmp_84;
  void block[4] = a1 + 72;
  void block[5] = v6;
  uint64_t v4 = a1 + 88;
  long long v3 = *(NSObject **)(a1 + 88);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
  return v7;
}

uint64_t KernelPCIABPTrace::getProperty_sync(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = "getProperty_sync";
    _os_log_debug_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)__p, 0xCu);
  }
  HIBYTE(v15) = 5;
  LODWORD(__p[0]) = *(_DWORD *)"State";
  WORD2(__p[0]) = str_23_0[4];
  if (a2[23] >= 0) {
    unsigned __int8 v7 = a2;
  }
  else {
    unsigned __int8 v7 = *(const char **)a2;
  }
  if (!strcasecmp(v7, (const char *)__p))
  {
    char v13 = 0;
    LOBYTE(v12) = 0;
    KernelPCIABPTrace::dumpState_sync(a1, (uint64_t)&v12, 0, 10, __p);
    if (__p != (void **)a3)
    {
      if (*(char *)(a3 + 23) < 0)
      {
        if (v15 >= 0) {
          char v9 = __p;
        }
        else {
          char v9 = (void **)__p[0];
        }
        if (v15 >= 0) {
          size_t v10 = HIBYTE(v15);
        }
        else {
          size_t v10 = (size_t)__p[1];
        }
        std::string::__assign_no_alias<false>((void **)a3, v9, v10);
      }
      else if (v15 < 0)
      {
        std::string::__assign_no_alias<true>((void *)a3, __p[0], (size_t)__p[1]);
      }
      else
      {
        *(_OWORD *)a3 = *(_OWORD *)__p;
        *(void *)(a3 + 16) = v15;
      }
    }
    if (SHIBYTE(v15) < 0)
    {
      operator delete(__p[0]);
      if ((v13 & 0x80000000) == 0) {
        return 1;
      }
    }
    else if ((v13 & 0x80000000) == 0)
    {
      return 1;
    }
    operator delete(v12);
    return 1;
  }
  HIBYTE(v15) = 3;
  LOWORD(__p[0]) = *(_WORD *)"IPC";
  WORD1(__p[0]) = str_42[2];
  BOOL v8 = prop::get_from_file((char *)__p, a2, a3);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return v8;
}

void sub_1A613C134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void KernelPCIABPTrace::getSettingPrefix(uint64_t a1@<X8>)
{
  *(void *)(a1 + 8) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)(a1 + 16) = 0xAAAAAAAAAAAAAAAALL;
  *(unsigned char *)(a1 + 23) = 11;
  strcpy((char *)a1, "KernelPCI::");
}

void std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(*a1);
    std::__tree<std::shared_ptr<KernelPCIABPTrace::PipeContext>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[5];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      long long v3 = a1;
    }
    else
    {
      long long v3 = a1;
    }
    operator delete(v3);
  }
}

void *std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C1E8;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2) {
    return a1;
  }
  int v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 72) = a2;
      *(void *)(a2 + 80) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(a2 + 72) = a2;
  *(void *)(a2 + 80) = v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A613C394(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1}::operator() const(KernelPCIABPTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A613C3BC(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<KernelPCIABPTrace *,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace *)#1},std::allocator<KernelPCIABPTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shar"
                                "ed_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI17KernelPCIABPTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1}::operator() const(KernelPCIABPTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = **(void **)(a1 + 40);
  KernelPCIABPTrace::initProperty_sync((KernelPCIABPTrace *)v1);
  dispatch_group_t group = 0;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v5 = "updateTraceState_sync";
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
    if (*(unsigned char *)(v1 + 152))
    {
LABEL_3:
      if (!*(unsigned char *)(v1 + 153)) {
        KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)v1);
      }
      return;
    }
  }
  else if (*(unsigned char *)(v1 + 152))
  {
    goto LABEL_3;
  }
  KernelPCIABPTrace::stopTrace(v1, (uint64_t)&group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_1A613C5B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>(KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::dumpCodeRegistry_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v4 = **a1;
  unint64_t v3 = (void *)(*a1)[1];
  xpc_object_t object = v3;
  if (v3)
  {
    xpc_retain(v3);
    if ((byte_1EB5EE9A0[23] & 0x80000000) == 0)
    {
LABEL_3:
      std::string __p = *(std::string *)byte_1EB5EE9A0;
      goto LABEL_6;
    }
  }
  else
  {
    xpc_object_t object = xpc_null_create();
    if ((byte_1EB5EE9A0[23] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)byte_1EB5EE9A0, *(std::string::size_type *)&byte_1EB5EE9A0[8]);
LABEL_6:
  BOOL v5 = util::writeJSON((ctu **)&object, (uint64_t *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v6 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (MEMORY[0x1A6275E60](v2[1]) == MEMORY[0x1E4F14590] && v5) {
      unsigned __int8 v7 = "Succeeded";
    }
    else {
      unsigned __int8 v7 = "Failed";
    }
    if (byte_1EB5EE9A0[23] >= 0) {
      BOOL v8 = byte_1EB5EE9A0;
    }
    else {
      BOOL v8 = *(char **)byte_1EB5EE9A0;
    }
    *(_DWORD *)long long buf = 136315394;
    BOOL v14 = v7;
    __int16 v15 = 2080;
    uint64_t v16 = v8;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I %s to dump CodeRegistry: %s", buf, 0x16u);
  }
  char v9 = (std::__shared_weak_count *)v2[3];
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  xpc_release((xpc_object_t)v2[1]);
  operator delete(v2);
  size_t v10 = (std::__shared_weak_count *)a1[2];
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  operator delete(a1);
}

void sub_1A613C808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t object)
{
  xpc_release(object);
  uint64_t v18 = *(std::__shared_weak_count **)(v16 + 24);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  xpc_release(*(xpc_object_t *)(v16 + 8));
  operator delete((void *)v16);
  unint64_t v19 = (std::__shared_weak_count *)v15[2];
  if (v19)
  {
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_1A613C8F4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)a1;
  uint64_t v4 = **(void **)a1;
  unint64_t v3 = *(NSObject **)(*(void *)a1 + 8);
  dispatch_object_t object = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  BOOL v5 = *(NSObject **)(v4 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if (*(unsigned char *)(v4 + 152)) {
      goto LABEL_5;
    }
LABEL_8:
    KernelPCIABPTrace::stopTrace(v4, (uint64_t)&object);
    unint64_t v3 = object;
    goto LABEL_9;
  }
  *(_DWORD *)long long buf = 136315138;
  uint64_t v11 = "updateTraceState_sync";
  _os_log_debug_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
  if (!*(unsigned char *)(v4 + 152)) {
    goto LABEL_8;
  }
LABEL_5:
  if (!*(unsigned char *)(v4 + 153)) {
    KernelPCIABPTrace::startTrace_sync((KernelPCIABPTrace *)v4);
  }
LABEL_9:
  if (v3)
  {
    dispatch_group_leave(v3);
    if (object) {
      dispatch_release(object);
    }
  }
  uint64_t v6 = v2[1];
  if (v6)
  {
    dispatch_group_leave(v6);
    unsigned __int8 v7 = v2[1];
    if (v7) {
      dispatch_release(v7);
    }
  }
  operator delete(v2);
  BOOL v8 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  operator delete(a1);
}

void sub_1A613CA9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  char v13 = v11[1];
  if (v13)
  {
    dispatch_group_leave(v13);
    BOOL v14 = v11[1];
    if (v14) {
      dispatch_release(v14);
    }
  }
  operator delete(v11);
  __int16 v15 = (std::__shared_weak_count *)v10[2];
  if (v15)
  {
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::flushLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)a1;
  uint64_t v3 = **(void **)a1;
  uint64_t v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(unsigned char *)(v3 + 152))
  {
    BOOL v5 = (unint64_t *)(v2 + 1);
    uint64_t v6 = (void *)v2[1];
    if (*v6)
    {
      int v7 = *((_DWORD *)v2 + 4);
      BOOL v8 = *(NSObject **)(v3 + 40);
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        if (v9)
        {
          int v16 = 67109120;
          LODWORD(v17) = v7;
          _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#E Flush logs completion returned error. Error [0x%x]", (uint8_t *)&v16, 8u);
        }
      }
      else
      {
        if (v9)
        {
          uint64_t v13 = v2[3];
          int v16 = 134217984;
          uint64_t v17 = v13;
          _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Flush logs completion of size '%ld' bytes", (uint8_t *)&v16, 0xCu);
          uint64_t v6 = (void *)v2[1];
        }
        uint64_t v14 = *(void *)(v6[4] + 32);
        if (v14) {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v14 + 72))(v14, *v6, v2[3]);
        }
      }
    }
    else
    {
      uint64_t v12 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v16) = 0;
        _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Snapshot received (flush completion with null-log)", (uint8_t *)&v16, 2u);
        uint64_t v6 = (void *)*v5;
      }
      KernelPCIABPTrace::fileSnapshot_sync(v3, (uint64_t)(v6 + 4));
    }
  }
  else
  {
    size_t v10 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Flush logs completion for Disabled case", (uint8_t *)&v16, 2u);
    }
    uint64_t v11 = *(NSObject **)(v3 + 256);
    *(void *)(v3 + 256) = 0;
    if (v11)
    {
      dispatch_group_leave(v11);
      dispatch_release(v11);
    }
    BOOL v5 = (unint64_t *)(v2 + 1);
  }
  KernelPCIABPTrace::deleteBuffContext_sync((void *)v3, *v5);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  operator delete(v2);
  __int16 v15 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  operator delete(a1);
}

void sub_1A613CDC8(_Unwind_Exception *a1)
{
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  operator delete(v2);
  BOOL v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>(KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::readLogsCompletion(KernelPCIABPTrace::BuffContext *,unsigned long,int)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  uint64_t v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (!*(unsigned char *)(v3 + 152))
  {
    uint64_t v11 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Read log completion for Disabled case", (uint8_t *)&v18, 2u);
    }
    goto LABEL_14;
  }
  int v5 = *((_DWORD *)v2 + 4);
  if (v5 || (uint64_t v12 = (void *)v2[1], !*v12))
  {
    uint64_t v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v18 = 67109120;
      LODWORD(v19) = v5;
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Read logs completion has some failure. Error [0x%x]", (uint8_t *)&v18, 8u);
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *(void *)(v12[4] + 32);
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_18;
    }
    uint64_t v16 = v2[3];
    int v18 = 134217984;
    uint64_t v19 = v16;
    _os_log_debug_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEBUG, "#D Read logs completion of size '%ld' bytes", (uint8_t *)&v18, 0xCu);
    uint64_t v12 = (void *)v2[1];
    uint64_t v14 = *(void *)(v12[4] + 32);
    if (v14) {
LABEL_18:
    }
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v14 + 72))(v14, *v12, v2[3]);
  }
LABEL_7:
  unint64_t v7 = v2[1];
  if (!*(unsigned char *)(v3 + 153))
  {
LABEL_14:
    KernelPCIABPTrace::deleteBuffContext_sync((void *)v3, v2[1]);
    goto LABEL_21;
  }
  int v8 = (*(uint64_t (**)(void, void, void, void, void, uint64_t (*)(void *, int, void *), uint64_t))(**(void **)(v3 + 216) + 72))(*(void *)(v3 + 216), *(unsigned int *)(*(void *)(v7 + 32) + 24), *(void *)v7, *(unsigned int *)(v7 + 8), 0, readLogsCompletionCB, v2[1]);
  BOOL v9 = *(NSObject **)(v3 + 40);
  if (v8)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(v7 + 8) >> 10;
      int v18 = 134218240;
      uint64_t v19 = v10;
      __int16 v20 = 1024;
      int v21 = v8;
      _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#E Failed re-assigning new buffer of size '%ld KB' to fetch logs. Error [0x%x]", (uint8_t *)&v18, 0x12u);
    }
    KernelPCIABPTrace::deleteBuffContext_sync((void *)v3, v7);
  }
  else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v17 = *(void *)(v7 + 8) >> 10;
    int v18 = 134217984;
    uint64_t v19 = v17;
    _os_log_debug_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEBUG, "#D Assign new buffer of size '%ld KB' to fetch logs", (uint8_t *)&v18, 0xCu);
    if (!v4) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_21:
  if (v4)
  {
LABEL_22:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_23:
  operator delete(v2);
  __int16 v15 = (std::__shared_weak_count *)a1[2];
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  operator delete(a1);
}

void sub_1A613D1B8(_Unwind_Exception *a1)
{
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  operator delete(v2);
  int v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<pci::transport::kernelTrace  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x80000001A61F96C3) {
    return a1 + 24;
  }
  if (((v3 & 0x80000001A61F96C3 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x80000001A61F96C3)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x80000001A61F96C3 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C288;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C288;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<KernelPCIABPTrace::PipeContext>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((*(char *)(a1 + 47) & 0x80000000) == 0) {
      return;
    }
  }
  else if ((*(char *)(a1 + 47) & 0x80000000) == 0)
  {
    return;
  }
  uint64_t v3 = *(void **)(a1 + 24);

  operator delete(v3);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  uint64_t v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(unsigned char *)(v3 + 152)) {
    KernelPCIABPTrace::deregisterWithKernel_sync((KernelPCIABPTrace *)v3);
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  int v5 = v2[1];
  if (v5)
  {
    dispatch_group_leave(v5);
    uint64_t v6 = v2[1];
    if (v6) {
      dispatch_release(v6);
    }
  }
  operator delete(v2);
  unint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    int v8 = a1;
  }
  else
  {
    int v8 = a1;
  }
  operator delete(v8);
}

void sub_1A613D524(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  if (v4)
  {
    uint64_t v6 = v4;
    dispatch_group_leave(v4);
    dispatch_release(v6);
  }
  unint64_t v7 = v2[1];
  if (v7)
  {
    dispatch_group_leave(v7);
    int v8 = v2[1];
    if (v8) {
      dispatch_release(v8);
    }
  }
  operator delete(v2);
  BOOL v9 = (std::__shared_weak_count *)v1[2];
  if (v9)
  {
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  __p[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  BOOL v26 = (void *)v2;
  uint64_t v3 = *(void *)v2;
  uint64_t v4 = *(NSObject **)(*(void *)v2 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(*(void *)v2 + 144));
    dispatch_group_enter(v4);
  }
  v32[0] = 0xAAAAAAAAAAAAAAAALL;
  v32[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v32, *(const __CFDictionary **)(v2 + 24));
  memset(v31, 170, sizeof(v31));
  strcpy((char *)__p, "kTraceFilterActionNone");
  HIBYTE(__p[2]) = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v29, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v29);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  int v5 = (void *)HIBYTE(v31[2]);
  int v6 = SHIBYTE(v31[2]);
  if (SHIBYTE(v31[2]) < 0) {
    int v5 = v31[1];
  }
  if (v5 != (void *)22) {
    goto LABEL_17;
  }
  unint64_t v7 = (void **)v31[0];
  if (SHIBYTE(v31[2]) >= 0) {
    unint64_t v7 = v31;
  }
  int v8 = *v7;
  BOOL v9 = v7[1];
  uint64_t v10 = *(uint64_t *)((char *)v7 + 14);
  BOOL v11 = v8 == *(void **)"kTraceFilterActionNone" && v9 == *(void **)"lterActionNone";
  if (v11 && v10 == *(void *)"tionNone")
  {
    uint64_t v16 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(unsigned __int8 *)(v3 + 152);
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v17;
      _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Snapshot requested. Enabled = %d", (uint8_t *)__p, 8u);
    }
    if (*(unsigned char *)(v3 + 152))
    {
      unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
      int v18 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
      if (!(void)xmmword_1EB5EE590)
      {
        ctu::XpcJetsamAssertion::create_default_global((uint64_t *)__p, v18);
        long long v19 = *(_OWORD *)__p;
        __p[0] = 0;
        __p[1] = 0;
        __int16 v20 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
        xmmword_1EB5EE590 = v19;
        if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
        int v21 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      uint64_t v22 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
      if (*((void *)&xmmword_1EB5EE590 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
      __p[0] = operator new(0x20uLL);
      *(_OWORD *)&__p[1] = xmmword_1A61F9520;
      strcpy((char *)__p[0], "Kernel PCI ABP Trace Snapshot");
      ctu::XpcJetsamAssertion::createActivity();
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      uint64_t v23 = *(NSObject **)(v2 + 8);
      std::string::size_type v28 = v23;
      if (v23)
      {
        dispatch_retain(v23);
        dispatch_group_enter(v23);
      }
      CFDictionaryRef v24 = *(const __CFDictionary **)(v2 + 24);
      CFDictionaryRef v27 = v24;
      if (v24) {
        CFRetain(v24);
      }
      KernelPCIABPTrace::snapshot_sync(v3, &v28, &v27);
      if (v24) {
        CFRelease(v24);
      }
      if (v23)
      {
        dispatch_group_leave(v23);
        dispatch_release(v23);
      }
      long long v25 = (std::__shared_weak_count *)v30;
      if (v30 && !atomic_fetch_add((atomic_ullong *volatile)(v30 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  else
  {
LABEL_17:
    uint64_t v13 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = (void **)v31[0];
      if (v6 >= 0) {
        uint64_t v14 = v31;
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v14;
      _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Skipping snapshot as trace filter is '%s'", (uint8_t *)__p, 0xCu);
    }
  }
  if (SHIBYTE(v31[2]) < 0) {
    operator delete(v31[0]);
  }
  MEMORY[0x1A6274930](v32);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](&v26);
  __int16 v15 = (std::__shared_weak_count *)a1[2];
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  operator delete(a1);
}

void sub_1A613DA6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  if (a19 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1A6274930](&a20);
  if (v28)
  {
    dispatch_group_leave(v28);
    dispatch_release(v28);
  }
  std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100]((void **)&a9);
  unint64_t v30 = (std::__shared_weak_count *)v27[2];
  if (v30)
  {
    if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  operator delete(v27);
  _Unwind_Resume(a1);
}

void sub_1A613DBE8()
{
  if (!v0) {
    JUMPOUT(0x1A613DB88);
  }
  JUMPOUT(0x1A613DB78);
}

void **std::unique_ptr<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<KernelPCIABPTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = (const void *)v2[3];
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = v2[2];
    if (v4) {
      dispatch_release(v4);
    }
    int v5 = v2[1];
    if (v5)
    {
      dispatch_group_leave(v5);
      int v6 = v2[1];
      if (v6) {
        dispatch_release(v6);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>(KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<KernelPCIABPTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)a1;
  uint64_t v3 = **(void **)a1;
  uint64_t v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  int v5 = *(NSObject **)(v3 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_12;
  }
  if (*((char *)v2 + 39) < 0) {
    std::string::__init_copy_ctor_external(&v10, (const std::string::value_type *)v2[2], v2[3]);
  }
  else {
    std::string v10 = *(std::string *)(v2 + 2);
  }
  KernelPCIABPTrace::dumpState_sync(v3, (uint64_t)&v10, 1, 10, __p);
  if (v12 >= 0) {
    int v6 = __p;
  }
  else {
    int v6 = (void **)__p[0];
  }
  *(_DWORD *)long long buf = 136315138;
  uint64_t v14 = v6;
  _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
  if (v12 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_24;
    }
LABEL_12:
    if (!v4) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_12;
  }
LABEL_24:
  operator delete(v10.__r_.__value_.__l.__data_);
  if (v4)
  {
LABEL_13:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_14:
  if (*((char *)v2 + 39) < 0) {
    operator delete((void *)v2[2]);
  }
  unint64_t v7 = v2[1];
  if (v7)
  {
    dispatch_group_leave(v7);
    int v8 = v2[1];
    if (v8) {
      dispatch_release(v8);
    }
  }
  operator delete(v2);
  BOOL v9 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  operator delete(a1);
}

void sub_1A613DE50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (v16)
  {
    dispatch_group_leave(v16);
    dispatch_release(v16);
    if ((*(char *)(v15 + 39) & 0x80000000) == 0)
    {
LABEL_3:
      long long v19 = *(NSObject **)(v15 + 8);
      if (!v19) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  else if ((*(char *)(v15 + 39) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v17);
  long long v19 = *(NSObject **)(v15 + 8);
  if (!v19) {
    goto LABEL_9;
  }
LABEL_7:
  dispatch_group_leave(v19);
  __int16 v20 = *(NSObject **)(v15 + 8);
  if (v20) {
    dispatch_release(v20);
  }
LABEL_9:
  operator delete((void *)v15);
  int v21 = (std::__shared_weak_count *)v14[2];
  if (v21)
  {
    if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  operator delete(v14);
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(v1 + 8);
  uint64_t v13 = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  int v4 = KernelPCIABPTrace::setProperty_sync(v2, &v13, *(char **)(v1 + 16), *(char **)(v1 + 24));
  **(unsigned char **)(v1 + 32) = v4;
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
    int v4 = **(unsigned __int8 **)(v1 + 32);
  }
  if (v4) {
    int v5 = "Success";
  }
  else {
    int v5 = "Failed";
  }
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  int64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  if (v4) {
    size_t v6 = 7;
  }
  else {
    size_t v6 = 6;
  }
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v12) = v6;
  memcpy(__p, v5, v6);
  *(unsigned char *)((unint64_t)__p | v6) = 0;
  unint64_t v7 = *(NSObject **)(v2 + 40);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if ((SHIBYTE(v12) & 0x80000000) == 0) {
      return;
    }
LABEL_19:
    operator delete(__p[0]);
    return;
  }
  int v8 = (void **)__p[0];
  if (v12 >= 0) {
    int v8 = __p;
  }
  BOOL v9 = *(uint64_t **)(v1 + 16);
  if (*((char *)v9 + 23) < 0)
  {
    BOOL v9 = (uint64_t *)*v9;
    std::string v10 = *(uint64_t **)(v1 + 24);
    if ((*((char *)v10 + 23) & 0x80000000) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    std::string v10 = *(uint64_t **)(v1 + 24);
    if ((*((char *)v10 + 23) & 0x80000000) == 0) {
      goto LABEL_18;
    }
  }
  std::string v10 = (uint64_t *)*v10;
LABEL_18:
  *(_DWORD *)long long buf = 136315650;
  uint64_t v15 = v8;
  __int16 v16 = 2080;
  int v17 = v9;
  __int16 v18 = 2080;
  long long v19 = v10;
  _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Set property [%s], Key=%s, Value=%s", buf, 0x20u);
  if (SHIBYTE(v12) < 0) {
    goto LABEL_19;
  }
}

void sub_1A613E0E4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN17KernelPCIABPTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int Property_sync = KernelPCIABPTrace::getProperty_sync(*(void *)v1, *(char **)(v1 + 8), *(void *)(v1 + 16));
  **(unsigned char **)(v1 + 24) = Property_sync;
  if (Property_sync) {
    int v4 = "Success";
  }
  else {
    int v4 = "Failed";
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  int64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  if (Property_sync) {
    size_t v5 = 7;
  }
  else {
    size_t v5 = 6;
  }
  __dst[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(v11) = v5;
  memcpy(__dst, v4, v5);
  *(unsigned char *)((unint64_t)__dst | v5) = 0;
  size_t v6 = *(NSObject **)(v2 + 40);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((SHIBYTE(v11) & 0x80000000) == 0) {
      return;
    }
LABEL_15:
    operator delete(__dst[0]);
    return;
  }
  unint64_t v7 = (void **)__dst[0];
  if (v11 >= 0) {
    unint64_t v7 = __dst;
  }
  int v8 = *(uint64_t **)(v1 + 8);
  if (*((char *)v8 + 23) < 0)
  {
    int v8 = (uint64_t *)*v8;
    BOOL v9 = *(uint64_t **)(v1 + 16);
    if ((*((char *)v9 + 23) & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else
  {
    BOOL v9 = *(uint64_t **)(v1 + 16);
    if ((*((char *)v9 + 23) & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  BOOL v9 = (uint64_t *)*v9;
LABEL_14:
  *(_DWORD *)long long buf = 136315650;
  uint64_t v13 = v7;
  __int16 v14 = 2080;
  uint64_t v15 = v8;
  __int16 v16 = 2080;
  int v17 = v9;
  _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Get property [%s], Key=%s, Value=%s", buf, 0x20u);
  if (SHIBYTE(v11) < 0) {
    goto LABEL_15;
  }
}

uint64_t __cxx_global_var_init_37()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t _GLOBAL__sub_I_KernelPCIABPTrace_cpp()
{
  v3.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
  *(_OWORD *)&v3.__r_.__value_.__r.__words[1] = xmmword_1A61F7560;
  strcpy(v3.__r_.__value_.__l.__data_, "/var/wireless/Library/Logs/AppleBasebandManager/pci-bin.scratch/");
  uint64_t v0 = std::string::append(&v3, "code-registry.json", 0x12uLL);
  long long v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  *(void *)&byte_1EB5EE9A0[16] = *((void *)&v0->__r_.__value_.__l + 2);
  *(_OWORD *)byte_1EB5EE9A0 = v1;
  v0->__r_.__value_.__l.__size_ = 0;
  v0->__r_.__value_.__r.__words[2] = 0;
  v0->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v3.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v3.__r_.__value_.__l.__data_);
  }
  return __cxa_atexit(MEMORY[0x1E4FBA210], byte_1EB5EE9A0, &dword_1A609F000);
}

void sub_1A613E38C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *abm::LogManagementTask::LogManagementTask(void *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  size_t v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v12 = *a3;
  uint64_t v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v10 = *a4;
  int64_t v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v12, &v10);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  unint64_t v7 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *a1 = &unk_1EFB0C2D8;
  int v8 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  a1[17] = dispatch_queue_create("log.mgr.task.queue", v8);
  ctu::LoggerCommonBase::setLogLevel();
  return a1;
}

void sub_1A613E4B4(_Unwind_Exception *a1)
{
  std::string v3 = *((void *)v1 + 17);
  if (v3) {
    dispatch_release(v3);
  }
  abm::HelperTask::~HelperTask(v1);
  _Unwind_Resume(a1);
}

void sub_1A613E4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::HelperTask::~HelperTask(abm::HelperTask *this)
{
  *(void *)this = &unk_1EFB0FCB8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  std::string v3 = *((void *)this + 14);
  if (v3) {
    dispatch_release(v3);
  }
  *(void *)this = &unk_1EFB09350;
  MEMORY[0x1A6274710]((char *)this + 8);
  int v4 = *((void *)this + 12);
  if (v4) {
    dispatch_release(v4);
  }
  size_t v5 = *((void *)this + 11);
  if (v5) {
    dispatch_release(v5);
  }
  size_t v6 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void abm::LogManagementTask::~LogManagementTask(abm::LogManagementTask *this)
{
  *(void *)this = &unk_1EFB0C2D8;
  uint64_t v2 = *((void *)this + 17);
  if (v2) {
    dispatch_release(v2);
  }
  *(void *)this = &unk_1EFB0FCB8;
  std::string v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  int v4 = *((void *)this + 14);
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)this = &unk_1EFB09350;
  MEMORY[0x1A6274710]((char *)this + 8);
  size_t v5 = *((void *)this + 12);
  if (v5) {
    dispatch_release(v5);
  }
  size_t v6 = *((void *)this + 11);
  if (v6) {
    dispatch_release(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

{
  void *v1;
  uint64_t vars8;

  abm::LogManagementTask::~LogManagementTask(this);

  operator delete(v1);
}

void *abm::LogManagementTask::getName(abm::LogManagementTask *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_13, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&_MergedGlobals_13))
  {
    return qword_1EB5EE9E8;
  }
  unsigned int v3 = *((_DWORD *)this + 26) - 1;
  if (v3 > 9) {
    int v4 = "invalid";
  }
  else {
    int v4 = off_1E5C47690[v3];
  }
  std::string::basic_string[abi:ne180100]<0>(qword_1EB5EE9E8, v4);
  __cxa_atexit(MEMORY[0x1E4FBA210], qword_1EB5EE9E8, &dword_1A609F000);
  __cxa_guard_release(&_MergedGlobals_13);
  return qword_1EB5EE9E8;
}

void sub_1A613E748(_Unwind_Exception *a1)
{
}

void abm::LogManagementTask::init_sync(abm::LogManagementTask *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (v3 = *((void *)this + 9), (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  size_t v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    size_t v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v6) {
      goto LABEL_51;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    size_t v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v6) {
      goto LABEL_51;
    }
  }
  unint64_t v7 = std::__shared_weak_count::lock(v6);
  char v47 = v7;
  if (v7)
  {
    int v8 = v7;
    uint64_t v9 = *((void *)this + 15);
    uint64_t v46 = v9;
    if (v9)
    {
      v44[0] = MEMORY[0x1E4F143A8];
      v44[1] = 3321888768;
      v44[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke;
      v44[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e45_____CFDictionary__20__0i8____CFDictionary__12l;
      v44[4] = this;
      v44[5] = v3;
      xpc_object_t v45 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      +[ABMCacheDelete RegisterCallback:@"com.apple.abm.cache-delete" :0 :0 :0 :v44];
      uint64_t v10 = *((void *)this + 5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I CacheDelete Call back is registered. Check if there are purgeable log files.", buf, 2u);
      }
      abm::LogManagementTask::markPurgeableLogs(this);
      int64_t v11 = (char *)operator new(0x20uLL);
      long long v41 = v11;
      long long v42 = xmmword_1A61F7FE0;
      strcpy(v11, "CommandGetBasebandSnapshotLogs");
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_4;
      aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      aBlock[4] = this;
      void aBlock[5] = v3;
      uint64_t v39 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v12 = _Block_copy(aBlock);
      uint64_t v13 = *((void *)this + 11);
      if (v13) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v40[0] = v12;
      v40[1] = v13;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v41, (uint64_t)v40);
      if (v13) {
        dispatch_release(v13);
      }
      if (v12) {
        _Block_release(v12);
      }
      operator delete(v11);
      v37[23] = 14;
      strcpy(v37, "CommandLogMove");
      v34[0] = MEMORY[0x1E4F143A8];
      v34[1] = 3321888768;
      void v34[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_11;
      v34[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v34[4] = this;
      v34[5] = v3;
      std::string v35 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      __int16 v14 = _Block_copy(v34);
      uint64_t v15 = *((void *)this + 11);
      if (v15) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v36[0] = v14;
      v36[1] = v15;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)v37, (uint64_t)v36);
      if (v15) {
        dispatch_release(v15);
      }
      if (v14) {
        _Block_release(v14);
      }
      v33[23] = 16;
      strcpy(v33, "CommandLogDelete");
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 3321888768;
      v30[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_20;
      v30[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v30[4] = this;
      v30[5] = v3;
      unsigned int v31 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      __int16 v16 = _Block_copy(v30);
      int v17 = *((void *)this + 11);
      if (v17) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v32[0] = v16;
      v32[1] = v17;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)v33, (uint64_t)v32);
      if (v17) {
        dispatch_release(v17);
      }
      if (v16) {
        _Block_release(v16);
      }
      uint64_t v18 = (char *)operator new(0x20uLL);
      std::string::size_type v28 = v18;
      long long v29 = xmmword_1A61F7580;
      strcpy(v18, "CommandMobileLogHouseKeeping");
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_29;
      v26[3] = &__block_descriptor_40_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v26[4] = this;
      long long v19 = _Block_copy(v26);
      uint64_t v20 = *((void *)this + 11);
      if (v20) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v27[0] = v19;
      v27[1] = v20;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v28, (uint64_t)v27);
      if (v20) {
        dispatch_release(v20);
      }
      if (v19) {
        _Block_release(v19);
      }
      operator delete(v18);
      v25[23] = 17;
      strcpy(v25, "CommandLogPrepare");
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      v23[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_30;
      v23[3] = &__block_descriptor_40_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v23[4] = this;
      int v21 = _Block_copy(v23);
      uint64_t v22 = *((void *)this + 11);
      if (v22) {
        dispatch_retain(v22);
      }
      v24[0] = v21;
      v24[1] = v22;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)v25, (uint64_t)v24);
      if (v22) {
        dispatch_release(v22);
      }
      if (v21) {
        _Block_release(v21);
      }
      if (v31) {
        std::__shared_weak_count::__release_weak(v31);
      }
      if (v35) {
        std::__shared_weak_count::__release_weak(v35);
      }
      if (v39) {
        std::__shared_weak_count::__release_weak(v39);
      }
      if (v45) {
        std::__shared_weak_count::__release_weak(v45);
      }
    }
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
LABEL_51:
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A613ED44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,std::__shared_weak_count *a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,std::__shared_weak_count *a61)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a15);
  if (a36)
  {
    std::__shared_weak_count::__release_weak(a36);
    xpc_object_t v64 = a49;
    if (!a49)
    {
LABEL_3:
      xpc_object_t v65 = a61;
      if (!a61) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else
  {
    xpc_object_t v64 = a49;
    if (!a49) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v64);
  xpc_object_t v65 = a61;
  if (!a61)
  {
LABEL_4:
    xpc_object_t v66 = *(std::__shared_weak_count **)(v62 - 120);
    if (!v66) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  std::__shared_weak_count::__release_weak(v65);
  xpc_object_t v66 = *(std::__shared_weak_count **)(v62 - 120);
  if (!v66)
  {
LABEL_5:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v62 - 112);
    std::__shared_weak_count::__release_weak(v61);
    _Unwind_Resume(a1);
  }
LABEL_9:
  std::__shared_weak_count::__release_weak(v66);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v62 - 112);
  std::__shared_weak_count::__release_weak(v61);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3abm17LogManagementTask9init_syncEv_block_invoke(void *a1, int a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    unint64_t v7 = (void *)a1[4];
    int v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[5])
      {
        uint64_t v10 = v7[5];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v12[0] = 67109378;
          v12[1] = a2;
          __int16 v13 = 2112;
          uint64_t v14 = a3;
          _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I CacheDelete Purge Periodic Callback: urgency: %d, info: %@", (uint8_t *)v12, 0x12u);
        }
        abm::LogManagementTask::markPurgeableLogs(v7);
      }
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  return 0;
}

uint64_t abm::LogManagementTask::markPurgeableLogs(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (!v2 || (v3 = a1[9], (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  size_t v5 = v4;
  size_t v6 = operator new(8uLL);
  void *v6 = a1;
  unint64_t v7 = a1[11];
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  int v8 = operator new(0x18uLL);
  void *v8 = v6;
  v8[1] = v3;
  _OWORD v8[2] = v5;
  dispatch_async_f(v7, v8, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<abm::HelperTask>::execute_wrapped<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>(abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0,dispatch_queue_s *::default_delete<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return 0;
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_4(void *a1, TelephonyXPC::ServerClientState *a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[4];
  uint64_t v123 = 0;
  uint64_t v124 = 0;
  size_t v6 = (std::__shared_weak_count *)a1[6];
  if (!v6) {
    goto LABEL_255;
  }
  uint64_t v124 = std::__shared_weak_count::lock(v6);
  if (!v124) {
    return;
  }
  uint64_t v123 = a1[5];
  if (!v123) {
    goto LABEL_255;
  }
  uint64_t v106 = v5;
  uint64_t v107 = a4;
  uint64_t v10 = *(NSObject **)(v5 + 112);
  if (v10)
  {
    dispatch_retain(*(dispatch_object_t *)(v5 + 112));
    dispatch_group_enter(v10);
  }
  TelephonyXPC::ServerClientState::getName((uint64_t *)&block.st_dev, a2);
  int st_gid_high = SHIBYTE(block.st_gid);
  uint64_t v12 = *(void **)&block.st_dev;
  if ((block.st_gid & 0x80000000) == 0) {
    p_blocuint64_t k = (const char *)&block;
  }
  else {
    p_blocuint64_t k = *(const char **)&block.st_dev;
  }
  int v14 = strncasecmp(p_block, "BasebandLog.DEHelper", 0x14uLL);
  int v15 = v14;
  if (st_gid_high < 0)
  {
    operator delete(v12);
    if (v15) {
      goto LABEL_11;
    }
  }
  else if (v14)
  {
LABEL_11:
    __int16 v16 = *(NSObject **)(v106 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      TelephonyXPC::ServerClientState::getName((uint64_t *)&block.st_dev, a2);
      int v17 = (block.st_gid & 0x80000000) == 0 ? &block : *(stat **)&block.st_dev;
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Getting baseband snapshot logs is not allowed for %s", buf, 0xCu);
      if (SHIBYTE(block.st_gid) < 0) {
        operator delete(*(void **)&block.st_dev);
      }
    }
    xpc_object_t v18 = xpc_null_create();
    if (*(void *)a4) {
      long long v19 = _Block_copy(*(const void **)a4);
    }
    else {
      long long v19 = 0;
    }
    int v21 = *(NSObject **)(a4 + 8);
    *(void *)&block.st_dev = MEMORY[0x1E4F143A8];
    block.__darwin_ino64_t st_ino = 3321888768;
    *(void *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    *(void *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v19)
    {
      uint64_t v22 = _Block_copy(v19);
      LODWORD(block.st_mtimespec.tv_sec) = -534716414;
      block.st_atimespec.tv_sec = (__darwin_time_t)v22;
      block.st_atimespec.uint64_t tv_nsec = (uint64_t)v18;
      if (v18)
      {
LABEL_25:
        xpc_retain(v18);
LABEL_28:
        dispatch_async(v21, &block);
        xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
        block.st_atimespec.uint64_t tv_nsec = 0;
        if (block.st_atimespec.tv_sec) {
          _Block_release((const void *)block.st_atimespec.tv_sec);
        }
        if (v19) {
          _Block_release(v19);
        }
        xpc_release(v18);
        goto LABEL_253;
      }
    }
    else
    {
      LODWORD(block.st_mtimespec.tv_sec) = -534716414;
      block.st_atimespec.tv_sec = 0;
      block.st_atimespec.uint64_t tv_nsec = (uint64_t)v18;
      if (v18) {
        goto LABEL_25;
      }
    }
    block.st_atimespec.uint64_t tv_nsec = (uint64_t)xpc_null_create();
    goto LABEL_28;
  }
  size_t v105 = v10;
  xpc_object_t value = xpc_dictionary_get_value(*a3, "AllowToDelete");
  *(void *)&block.st_dev = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    *(void *)&block.st_dev = xpc_null_create();
  }
  int v109 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)&block.st_dev);
  xpc_object_t v23 = xpc_dictionary_get_value(*a3, "MatchingPattern");
  xpc_object_t v24 = v23;
  if (v23) {
    xpc_retain(v23);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  xpc_object_t v25 = xpc_null_create();
  if (v24 && MEMORY[0x1A6275E60](v24) == MEMORY[0x1E4F14568])
  {
    xpc_retain(v24);
    xpc_object_t v26 = v24;
  }
  else
  {
    xpc_object_t v26 = xpc_null_create();
  }
  if (MEMORY[0x1A6275E60](v26) != MEMORY[0x1E4F14568])
  {
    if (v25)
    {
      xpc_retain(v25);
      xpc_object_t v27 = v25;
    }
    else
    {
      xpc_object_t v27 = xpc_null_create();
    }
    xpc_release(v26);
    xpc_object_t v26 = v27;
  }
  xpc_release(v25);
  xpc_release(v24);
  memset(&__dst, 170, sizeof(__dst));
  std::string::size_type v28 = (const void *)qword_1EB5EEC60;
  size_t v29 = strlen((const char *)qword_1EB5EEC60);
  if (v29 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v30 = v29;
  if (v29 >= 0x17)
  {
    uint64_t v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v32 = v29 | 7;
    }
    uint64_t v33 = v32 + 1;
    p_dst = (std::string *)operator new(v32 + 1);
    __dst.__r_.__value_.__l.__size_ = v30;
    __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_53;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v29;
  p_dst = &__dst;
  if (v29) {
LABEL_53:
  }
    memmove(p_dst, v28, v30);
  p_dst->__r_.__value_.__s.__data_[v30] = 0;
  v121.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v121.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v121.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v26)
  {
    xpc_retain(v26);
    xpc_object_t v34 = v26;
  }
  else
  {
    xpc_object_t v34 = xpc_null_create();
    if (!v34)
    {
      xpc_object_t v34 = xpc_null_create();
      std::string v35 = 0;
      goto LABEL_58;
    }
  }
  xpc_retain(v34);
  std::string v35 = v34;
LABEL_58:
  xpc_release(v35);
  for (size_t i = 0; ; ++i)
  {
    if (v26)
    {
      xpc_retain(v26);
      xpc_object_t v38 = v26;
    }
    else
    {
      xpc_object_t v38 = xpc_null_create();
    }
    if (MEMORY[0x1A6275E60](v26) == MEMORY[0x1E4F14568])
    {
      size_t count = xpc_array_get_count(v26);
      if (!v38)
      {
LABEL_68:
        xpc_object_t v40 = xpc_null_create();
        goto LABEL_69;
      }
    }
    else
    {
      size_t count = 0;
      if (!v38) {
        goto LABEL_68;
      }
    }
    xpc_retain(v38);
    xpc_object_t v40 = v38;
LABEL_69:
    xpc_release(v38);
    xpc_release(v40);
    if (i == count && v34 == v40) {
      break;
    }
    memset(&block, 170, 24);
    xpc_object_t v41 = xpc_array_get_value(v34, i);
    *(void *)long long buf = v41;
    if (v41) {
      xpc_retain(v41);
    }
    else {
      *(void *)long long buf = xpc_null_create();
    }
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)buf);
    std::string::size_type v42 = HIBYTE(block.st_gid);
    char v43 = HIBYTE(block.st_gid);
    __darwin_ino64_t st_ino = block.st_ino;
    if ((block.st_gid & 0x80000000) == 0) {
      __darwin_ino64_t v45 = HIBYTE(block.st_gid);
    }
    else {
      __darwin_ino64_t v45 = block.st_ino;
    }
    if (v45)
    {
      std::string::size_type size = HIBYTE(v121.__r_.__value_.__r.__words[2]);
      if ((v121.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v121.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        std::string::append(&v121, "|", 1uLL);
        std::string::size_type v42 = HIBYTE(block.st_gid);
        __darwin_ino64_t st_ino = block.st_ino;
        char v43 = HIBYTE(block.st_gid);
      }
      if (v43 >= 0) {
        char v47 = (const std::string::value_type *)&block;
      }
      else {
        char v47 = *(const std::string::value_type **)&block.st_dev;
      }
      if (v43 >= 0) {
        std::string::size_type v48 = v42;
      }
      else {
        std::string::size_type v48 = st_ino;
      }
      std::string::append(&v121, v47, v48);
      char v43 = HIBYTE(block.st_gid);
    }
    if (v43 < 0)
    {
      operator delete(*(void **)&block.st_dev);
      if (!v34)
      {
LABEL_59:
        xpc_object_t v37 = xpc_null_create();
        goto LABEL_60;
      }
    }
    else if (!v34)
    {
      goto LABEL_59;
    }
    xpc_retain(v34);
    xpc_object_t v37 = v34;
LABEL_60:
    xpc_release(v37);
  }
  xpc_release(v34);
  xpc_object_t v49 = xpc_dictionary_create(0, 0, 0);
  if (v49 || (xpc_object_t v49 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v49) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v49);
      xpc_object_t v50 = v49;
    }
    else
    {
      xpc_object_t v50 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v50 = xpc_null_create();
    xpc_object_t v49 = 0;
  }
  xpc_release(v49);
  xpc_object_t v51 = xpc_array_create(0, 0);
  if (v51 || (xpc_object_t v51 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v51) == MEMORY[0x1E4F14568])
    {
      xpc_retain(v51);
      xpc_object_t v52 = v51;
    }
    else
    {
      xpc_object_t v52 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v52 = xpc_null_create();
    xpc_object_t v51 = 0;
  }
  xpc_release(v51);
  v118 = 0;
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  *(void *)&long long v53 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&uint8_t buf[32] = v53;
  long long v126 = v53;
  *(_OWORD *)long long buf = v53;
  *(_OWORD *)&uint8_t buf[16] = v53;
  xpc_object_t v108 = v52;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)buf, (uint64_t)&v121, 0);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v117, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v117 = __dst;
  }
  std::locale::locale(&v111, (const std::locale *)buf);
  long long v112 = *(_OWORD *)&buf[8];
  long long v113 = *(_OWORD *)&buf[24];
  uint64_t v114 = *(void *)&buf[40];
  v115 = (std::__shared_weak_count *)v126;
  if ((void)v126) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v126 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v116 = *((void *)&v126 + 1);
  BOOL FilteredFiles = support::fs::getFilteredFiles((const char *)&v117, (uint64_t)&v111, (uint64_t)&v118, 0);
  xpc_object_t v55 = v115;
  if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  std::locale::~locale(&v111);
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v117.__r_.__value_.__l.__data_);
    if (FilteredFiles) {
      goto LABEL_119;
    }
  }
  else
  {
    if (!FilteredFiles) {
      goto LABEL_195;
    }
LABEL_119:
    long long v56 = (const void **)v118;
    if (v118 != v119)
    {
      while (2)
      {
        memset(__p, 170, sizeof(__p));
        int v57 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v58 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t v58 = __dst.__r_.__value_.__l.__size_;
        }
        int v59 = *((char *)v56 + 23);
        if (v59 >= 0) {
          size_t v60 = *((unsigned __int8 *)v56 + 23);
        }
        else {
          size_t v60 = (size_t)v56[1];
        }
        unint64_t v61 = v60 + v58;
        if (v60 + v58 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        if (v61 > 0x16)
        {
          uint64_t v73 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v61 | 7) != 0x17) {
            uint64_t v73 = v61 | 7;
          }
          uint64_t v74 = v73 + 1;
          uint64_t v62 = (char *)operator new(v73 + 1);
          __p[1] = (void *)(v60 + v58);
          __p[2] = (void *)(v74 | 0x8000000000000000);
          __p[0] = v62;
          if (v58)
          {
LABEL_131:
            if (v57 >= 0) {
              xpc_object_t v63 = &__dst;
            }
            else {
              xpc_object_t v63 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            memmove(v62, v63, v58);
          }
        }
        else
        {
          memset(__p, 0, sizeof(__p));
          uint64_t v62 = (char *)__p;
          HIBYTE(__p[2]) = v60 + v58;
          if (v58) {
            goto LABEL_131;
          }
        }
        if (v60)
        {
          if (v59 >= 0) {
            xpc_object_t v64 = v56;
          }
          else {
            xpc_object_t v64 = *v56;
          }
          memmove(&v62[v58], v64, v60);
        }
        v62[v58 + v60] = 0;
        int v65 = SHIBYTE(__p[2]);
        if (v109)
        {
          if (SHIBYTE(__p[2]) >= 0) {
            xpc_object_t v66 = (unsigned char *)HIBYTE(__p[2]);
          }
          else {
            xpc_object_t v66 = __p[1];
          }
          uint64_t v67 = (char *)strlen(abm::trace::kLogArchiveSuffix[0]);
          uint64_t v68 = (char *)(v66 - v67);
          size_t v69 = strlen(abm::trace::kLogArchiveSuffix[0]);
          xpc_object_t v70 = (char *)v69;
          if (SHIBYTE(__p[2]) < 0)
          {
            if (v69 == -1 || __p[1] < v68) {
LABEL_260:
            }
              std::string::__throw_out_of_range[abi:ne180100]();
            if ((char *)((char *)__p[1] - (char *)v68) < v67) {
              uint64_t v67 = (char *)((char *)__p[1] - (char *)v68);
            }
            xpc_object_t v72 = (void **)__p[0];
          }
          else
          {
            if (v69 == -1 || HIBYTE(__p[2]) < (unint64_t)v68) {
              goto LABEL_260;
            }
            if (HIBYTE(__p[2]) - (unint64_t)v68 < (unint64_t)v67) {
              uint64_t v67 = (char *)(HIBYTE(__p[2]) - (void)v68);
            }
            xpc_object_t v72 = __p;
          }
          xpc_object_t v52 = v108;
          if ((unint64_t)v67 >= v69) {
            size_t v76 = v69;
          }
          else {
            size_t v76 = (size_t)v67;
          }
          if (memcmp(&v68[(void)v72], abm::trace::kLogArchiveSuffix[0], v76) || v67 != v70)
          {
            size_t v78 = *(NSObject **)(v106 + 40);
            BOOL v79 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
            timeval v80 = (void **)__p[0];
            if (v79)
            {
              if (v65 >= 0) {
                timeval v80 = __p;
              }
              block.st_dev = 136315138;
              *(void *)&block.st_mode = v80;
              _os_log_impl(&dword_1A609F000, v78, OS_LOG_TYPE_DEFAULT, "#I Updating mode: %s", (uint8_t *)&block, 0xCu);
              LOBYTE(v65) = HIBYTE(__p[2]);
              timeval v80 = (void **)__p[0];
            }
            v81.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v81.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&block.st_blkstd::string::size_type size = v81;
            *(timespec *)block.st_qspare = v81;
            block.st_birthtimespec = v81;
            *(timespec *)&block.st_std::string::size_type size = v81;
            block.st_mtimespec = v81;
            block.st_ctimespec = v81;
            *(timespec *)&block.st_uid = v81;
            block.st_atimespec = v81;
            if ((v65 & 0x80u) == 0) {
              long long v82 = __p;
            }
            else {
              long long v82 = v80;
            }
            *(timespec *)&block.st_dev = v81;
            if (!stat((const char *)v82, &block))
            {
              unint64_t v83 = SHIBYTE(__p[2]) >= 0 ? (const char *)__p : (const char *)__p[0];
              unint64_t v84 = opendir(v83);
              std::string v85 = v84;
              if (v84)
              {
                readdir(v84);
                closedir(v85);
              }
            }
            ctu::fs::chmod();
            LOBYTE(v65) = HIBYTE(__p[2]);
          }
        }
        else
        {
          xpc_object_t v52 = v108;
        }
        if ((v65 & 0x80u) == 0) {
          std::string::size_type v86 = __p;
        }
        else {
          std::string::size_type v86 = (void **)__p[0];
        }
        xpc_object_t v87 = xpc_string_create((const char *)v86);
        if (!v87) {
          xpc_object_t v87 = xpc_null_create();
        }
        xpc_array_append_value(v52, v87);
        xpc_release(v87);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        v56 += 3;
        if (v56 == (const void **)v119) {
          break;
        }
        continue;
      }
    }
  }
LABEL_195:
  uint64_t v10 = v105;
  if (MEMORY[0x1A6275E60](v52) == MEMORY[0x1E4F14568] && xpc_array_get_count(v52))
  {
    if (v109) {
      ctu::fs::chmod();
    }
    if (v52)
    {
      xpc_retain(v52);
      xpc_object_t v93 = v52;
    }
    else
    {
      xpc_object_t v93 = xpc_null_create();
    }
    xpc_dictionary_set_value(v50, "FoundList", v93);
    xpc_object_t v96 = xpc_null_create();
    xpc_release(v93);
    xpc_release(v96);
    if (v50)
    {
      xpc_retain(v50);
      xpc_object_t v90 = v50;
    }
    else
    {
      xpc_object_t v90 = xpc_null_create();
    }
    if (*(void *)v107) {
      v97 = _Block_copy(*(const void **)v107);
    }
    else {
      v97 = 0;
    }
    v98 = *(NSObject **)(v107 + 8);
    *(void *)&block.st_dev = MEMORY[0x1E4F143A8];
    block.__darwin_ino64_t st_ino = 3321888768;
    *(void *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    *(void *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v97) {
      unint64_t v99 = _Block_copy(v97);
    }
    else {
      unint64_t v99 = 0;
    }
    LODWORD(block.st_mtimespec.tv_sec) = 0;
    block.st_atimespec.tv_sec = (__darwin_time_t)v99;
    block.st_atimespec.uint64_t tv_nsec = (uint64_t)v90;
    if (v90) {
      xpc_retain(v90);
    }
    else {
      block.st_atimespec.uint64_t tv_nsec = (uint64_t)xpc_null_create();
    }
    dispatch_async(v98, &block);
    xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
    block.st_atimespec.uint64_t tv_nsec = 0;
    if (block.st_atimespec.tv_sec) {
      _Block_release((const void *)block.st_atimespec.tv_sec);
    }
    if (v97) {
      _Block_release(v97);
    }
    goto LABEL_237;
  }
  int64_t v88 = *(NSObject **)(v106 + 40);
  if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v89 = &v121;
    if ((v121.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v89 = (std::string *)v121.__r_.__value_.__r.__words[0];
    }
    block.st_dev = 136315138;
    *(void *)&block.st_mode = v89;
    _os_log_impl(&dword_1A609F000, v88, OS_LOG_TYPE_DEFAULT, "#I Snapshot for pattern %s not found", (uint8_t *)&block, 0xCu);
  }
  if (v50)
  {
    xpc_retain(v50);
    xpc_object_t v90 = v50;
    uint64_t v91 = *(const void **)v107;
    if (*(void *)v107) {
      goto LABEL_202;
    }
LABEL_209:
    uint64_t v92 = 0;
  }
  else
  {
    xpc_object_t v90 = xpc_null_create();
    uint64_t v91 = *(const void **)v107;
    if (!*(void *)v107) {
      goto LABEL_209;
    }
LABEL_202:
    uint64_t v92 = _Block_copy(v91);
  }
  std::string::size_type v94 = *(NSObject **)(v107 + 8);
  *(void *)&block.st_dev = MEMORY[0x1E4F143A8];
  block.__darwin_ino64_t st_ino = 3321888768;
  *(void *)&block.st_uid = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  *(void *)&block.st_rdev = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (v92)
  {
    xpc_object_t v95 = _Block_copy(v92);
    LODWORD(block.st_mtimespec.tv_sec) = -534716416;
    block.st_atimespec.tv_sec = (__darwin_time_t)v95;
    block.st_atimespec.uint64_t tv_nsec = (uint64_t)v90;
    if (v90) {
      goto LABEL_212;
    }
LABEL_214:
    block.st_atimespec.uint64_t tv_nsec = (uint64_t)xpc_null_create();
  }
  else
  {
    LODWORD(block.st_mtimespec.tv_sec) = -534716416;
    block.st_atimespec.tv_sec = 0;
    block.st_atimespec.uint64_t tv_nsec = (uint64_t)v90;
    if (!v90) {
      goto LABEL_214;
    }
LABEL_212:
    xpc_retain(v90);
  }
  dispatch_async(v94, &block);
  xpc_release((xpc_object_t)block.st_atimespec.tv_nsec);
  block.st_atimespec.uint64_t tv_nsec = 0;
  if (block.st_atimespec.tv_sec) {
    _Block_release((const void *)block.st_atimespec.tv_sec);
  }
  if (v92) {
    _Block_release(v92);
  }
LABEL_237:
  xpc_release(v90);
  unint64_t v100 = (std::__shared_weak_count *)v126;
  if ((void)v126 && !atomic_fetch_add((atomic_ullong *volatile)(v126 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
    std::__shared_weak_count::__release_weak(v100);
  }
  std::locale::~locale((std::locale *)buf);
  char v101 = (void **)v118;
  if (v118)
  {
    size_t v102 = v119;
    xpc_object_t v103 = v118;
    if (v119 != v118)
    {
      do
      {
        if (*((char *)v102 - 1) < 0) {
          operator delete(*(v102 - 3));
        }
        v102 -= 3;
      }
      while (v102 != v101);
      xpc_object_t v103 = v118;
    }
    uint64_t v119 = v101;
    operator delete(v103);
  }
  xpc_release(v52);
  xpc_release(v50);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v121.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  xpc_release(v26);
LABEL_253:
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
LABEL_255:
  unint64_t v104 = v124;
  if (v124)
  {
    if (!atomic_fetch_add(&v124->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }
}

void sub_1A613FFF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, dispatch_group_t group, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,char a53,uint64_t a54,xpc_object_t a55)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_11(void *a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = a1[5];
      if (!v11)
      {
LABEL_19:
        if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      uint64_t v12 = *(NSObject **)(v8 + 112);
      __int16 v13 = *(NSObject **)(v8 + 88);
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3321888768;
      v18[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2;
      void v18[3] = &__block_descriptor_80_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
      v18[4] = v8;
      void v18[5] = v11;
      int v14 = (std::__shared_weak_count *)a1[6];
      long long v19 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      int v15 = *a3;
      xpc_object_t v20 = v15;
      if (v15)
      {
        xpc_retain(v15);
        __int16 v16 = *(void **)a4;
        if (!*(void *)a4) {
          goto LABEL_11;
        }
      }
      else
      {
        xpc_object_t v20 = xpc_null_create();
        __int16 v16 = *(void **)a4;
        if (!*(void *)a4)
        {
LABEL_11:
          int v17 = *(NSObject **)(a4 + 8);
          aBlocuint64_t k = v16;
          dispatch_object_t object = v17;
          if (v17) {
            dispatch_retain(v17);
          }
          dispatch_group_notify(v12, v13, v18);
          if (object) {
            dispatch_release(object);
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          xpc_release(v20);
          xpc_object_t v20 = 0;
          if (v19) {
            std::__shared_weak_count::__release_weak(v19);
          }
          goto LABEL_19;
        }
      }
      __int16 v16 = _Block_copy(v16);
      goto LABEL_11;
    }
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2(uint64_t a1)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2) {
    return;
  }
  size_t v69 = *(NSObject ***)(a1 + 32);
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  uint64_t v91 = v3;
  if (!v3) {
    return;
  }
  if (!*(void *)(a1 + 40))
  {
    uint64_t v9 = v3;
LABEL_175:
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  int v4 = v69[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)MEMORY[0x1A6275DF0](*(void *)(a1 + 56));
    memset(__dst, 170, 24);
    size_t v6 = strlen(v5);
    if (v6 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v7 = v6;
    if (v6 >= 0x17)
    {
      uint64_t v10 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17) {
        uint64_t v10 = v6 | 7;
      }
      uint64_t v11 = v10 + 1;
      uint64_t v8 = operator new(v10 + 1);
      *(void *)&__dst[8] = v7;
      *(void *)&uint8_t __dst[16] = v11 | 0x8000000000000000;
      *(void *)std::string __dst = v8;
    }
    else
    {
      __dst[23] = v6;
      uint64_t v8 = __dst;
      if (!v6) {
        goto LABEL_14;
      }
    }
    memcpy(v8, v5, v7);
LABEL_14:
    v8[v7] = 0;
    free(v5);
    uint64_t v12 = __dst;
    if (__dst[23] < 0) {
      uint64_t v12 = *(unsigned char **)__dst;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I LogMove requested: %s", (uint8_t *)&buf, 0xCu);
    if ((__dst[23] & 0x80000000) != 0) {
      operator delete(*(void **)__dst);
    }
  }
  xpc_object_t value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "MatchingPattern");
  xpc_object_t v14 = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  xpc_object_t v15 = xpc_null_create();
  if (v14 && MEMORY[0x1A6275E60](v14) == MEMORY[0x1E4F14568])
  {
    xpc_retain(v14);
    xpc_object_t v16 = v14;
  }
  else
  {
    xpc_object_t v16 = xpc_null_create();
  }
  if (MEMORY[0x1A6275E60](v16) != MEMORY[0x1E4F14568])
  {
    if (v15)
    {
      xpc_retain(v15);
      xpc_object_t v17 = v15;
    }
    else
    {
      xpc_object_t v17 = xpc_null_create();
    }
    xpc_release(v16);
    xpc_object_t v16 = v17;
  }
  xpc_release(v15);
  xpc_release(v14);
  xpc_object_t v18 = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "SrcBaseDirectoryIndex");
  *(void *)std::string __dst = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    *(void *)std::string __dst = xpc_null_create();
  }
  int v19 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)__dst);
  memset(&buf, 170, sizeof(buf));
  xpc_object_t v20 = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "DstDirectory");
  *(void *)std::string __dst = v20;
  if (v20) {
    xpc_retain(v20);
  }
  else {
    *(void *)std::string __dst = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)__dst);
  if (v19 >= 8)
  {
    int v21 = v69[5];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __dst = 67109120;
      *(_DWORD *)&__dst[4] = v19;
      _os_log_error_impl(&dword_1A609F000, v21, OS_LOG_TYPE_ERROR, "Invalid BaseDir [%d]. Cannot process it", __dst, 8u);
    }
    goto LABEL_172;
  }
  v89.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v89.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v89.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v16)
  {
    xpc_retain(v16);
    xpc_object_t v22 = v16;
  }
  else
  {
    xpc_object_t v22 = xpc_null_create();
    if (!v22)
    {
      xpc_object_t v22 = xpc_null_create();
      xpc_object_t v23 = 0;
      goto LABEL_43;
    }
  }
  xpc_retain(v22);
  xpc_object_t v23 = v22;
LABEL_43:
  xpc_release(v23);
  for (size_t i = 0; ; ++i)
  {
    if (v16)
    {
      xpc_retain(v16);
      xpc_object_t v26 = v16;
    }
    else
    {
      xpc_object_t v26 = xpc_null_create();
    }
    if (MEMORY[0x1A6275E60](v16) == MEMORY[0x1E4F14568])
    {
      size_t count = xpc_array_get_count(v16);
      if (!v26)
      {
LABEL_53:
        xpc_object_t v28 = xpc_null_create();
        goto LABEL_54;
      }
    }
    else
    {
      size_t count = 0;
      if (!v26) {
        goto LABEL_53;
      }
    }
    xpc_retain(v26);
    xpc_object_t v28 = v26;
LABEL_54:
    xpc_release(v26);
    xpc_release(v28);
    if (i == count && v22 == v28) {
      break;
    }
    memset(__dst, 170, 24);
    xpc_object_t v29 = xpc_array_get_value(v22, i);
    *(void *)int64_t v88 = v29;
    if (v29) {
      xpc_retain(v29);
    }
    else {
      *(void *)int64_t v88 = xpc_null_create();
    }
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)v88);
    std::string::size_type v30 = __dst[23];
    char v31 = __dst[23];
    std::string::size_type v32 = *(void *)&__dst[8];
    if (__dst[23] >= 0) {
      uint64_t v33 = __dst[23];
    }
    else {
      uint64_t v33 = *(void *)&__dst[8];
    }
    if (v33)
    {
      std::string::size_type size = HIBYTE(v89.__r_.__value_.__r.__words[2]);
      if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v89.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        std::string::append(&v89, "|", 1uLL);
        std::string::size_type v30 = __dst[23];
        std::string::size_type v32 = *(void *)&__dst[8];
        char v31 = __dst[23];
      }
      *((unsigned char *)&v86.__r_.__value_.__s + 23) = 2;
      strcpy((char *)&v86, ".*");
      if (v31 >= 0) {
        std::string v35 = __dst;
      }
      else {
        std::string v35 = *(const std::string::value_type **)__dst;
      }
      if (v31 >= 0) {
        std::string::size_type v36 = v30;
      }
      else {
        std::string::size_type v36 = v32;
      }
      xpc_object_t v37 = std::string::append(&v86, v35, v36);
      long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v87.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      char v85 = 2;
      strcpy(__s, ".*");
      uint64_t v39 = std::string::append(&v87, __s, 2uLL);
      long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      *(void *)&v88[16] = *((void *)&v39->__r_.__value_.__l + 2);
      *(_OWORD *)int64_t v88 = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      if (v88[23] >= 0) {
        xpc_object_t v41 = v88;
      }
      else {
        xpc_object_t v41 = *(const std::string::value_type **)v88;
      }
      if (v88[23] >= 0) {
        std::string::size_type v42 = v88[23];
      }
      else {
        std::string::size_type v42 = *(void *)&v88[8];
      }
      std::string::append(&v89, v41, v42);
      if ((v88[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)v88);
        if (v85 < 0) {
          goto LABEL_90;
        }
LABEL_81:
        if ((SHIBYTE(v87.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_82;
        }
LABEL_91:
        operator delete(v87.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_83:
          char v31 = __dst[23];
          goto LABEL_84;
        }
      }
      else
      {
        if ((v85 & 0x80000000) == 0) {
          goto LABEL_81;
        }
LABEL_90:
        operator delete(*(void **)__s);
        if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_91;
        }
LABEL_82:
        if ((SHIBYTE(v86.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_83;
        }
      }
      operator delete(v86.__r_.__value_.__l.__data_);
      goto LABEL_83;
    }
LABEL_84:
    if (v31 < 0)
    {
      operator delete(*(void **)__dst);
      if (!v22)
      {
LABEL_44:
        xpc_object_t v25 = xpc_null_create();
        goto LABEL_45;
      }
    }
    else if (!v22)
    {
      goto LABEL_44;
    }
    xpc_retain(v22);
    xpc_object_t v25 = v22;
LABEL_45:
    xpc_release(v25);
  }
  xpc_release(v22);
  char v43 = v69[14];
  if (v43)
  {
    dispatch_retain(v69[14]);
    dispatch_group_enter(v43);
  }
  v87.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v87.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  long long v44 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  uint64_t v45 = xmmword_1EB5EE590;
  if (!(void)xmmword_1EB5EE590)
  {
    ctu::XpcJetsamAssertion::create_default_global((uint64_t *)__dst, v44);
    long long v46 = *(_OWORD *)__dst;
    *(void *)std::string __dst = 0;
    *(void *)&__dst[8] = 0;
    char v47 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
    xmmword_1EB5EE590 = v46;
    if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
    std::string::size_type v48 = *(std::__shared_weak_count **)&__dst[8];
    if (*(void *)&__dst[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__dst[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
    uint64_t v45 = xmmword_1EB5EE590;
  }
  xpc_object_t v49 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
  *(void *)int64_t v88 = v45;
  *(void *)&v88[8] = *((void *)&xmmword_1EB5EE590 + 1);
  if (*((void *)&xmmword_1EB5EE590 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  char v83 = 8;
  strcpy((char *)__p, "Log Move");
  ctu::XpcJetsamAssertion::createActivity();
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  memset(v88, 170, sizeof(v88));
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v81, v89.__r_.__value_.__l.__data_, v89.__r_.__value_.__l.__size_);
  }
  else {
    std::string v81 = v89;
  }
  *(_DWORD *)std::string __dst = v19;
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external((std::string *)&__dst[8], v81.__r_.__value_.__l.__data_, v81.__r_.__value_.__l.__size_);
  }
  else {
    *(std::string *)&__dst[8] = v81;
  }
  int v93 = 0;
  std::vector<abm::DirectoryQuery>::vector[abi:ne180100](v88, (uint64_t)__dst, 1uLL);
  if ((__dst[31] & 0x80000000) != 0) {
    operator delete(*(void **)&__dst[8]);
  }
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v81.__r_.__value_.__l.__data_);
  }
  memset(__dst, 170, 16);
  abm::findFiles((unsigned int **)v88, 1u, (char ***)__dst);
  uint64_t v50 = *(void *)__dst;
  uint64_t v51 = **(void **)__dst;
  if (**(void **)__dst != *(void *)(*(void *)__dst + 8))
  {
    uint64_t v52 = MEMORY[0x1E4F143A8];
    uint64_t v53 = **(void **)__dst;
    do
    {
      block[0] = v52;
      block[1] = 3321888768;
      block[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_14;
      block[3] = &__block_descriptor_96_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE_e5_v8__0l;
      uint64_t v55 = *(void *)(a1 + 40);
      unsigned int v54 = *(std::__shared_weak_count **)(a1 + 48);
      void block[4] = v69;
      void block[5] = v55;
      size_t v77 = v54;
      if (v54) {
        atomic_fetch_add_explicit(&v54->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_group_t group = v43;
      if (v43)
      {
        dispatch_retain(v43);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      uint64_t v79 = v51;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v80, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string v80 = buf;
      }
      dispatch_async(v69[17], block);
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v80.__r_.__value_.__l.__data_);
        long long v56 = group;
        if (group)
        {
LABEL_133:
          dispatch_group_leave(v56);
          if (group) {
            dispatch_release(group);
          }
        }
      }
      else
      {
        long long v56 = group;
        if (group) {
          goto LABEL_133;
        }
      }
      if (v77) {
        std::__shared_weak_count::__release_weak(v77);
      }
      v53 += 16;
      uint64_t v50 = *(void *)__dst;
      v51 += 16;
    }
    while (v53 != *(void *)(*(void *)__dst + 8));
  }
  int v57 = v69[14];
  size_t v58 = v69[11];
  v70[0] = MEMORY[0x1E4F143A8];
  v70[1] = 3321888768;
  v70[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_17;
  v70[3] = &__block_descriptor_88_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
  uint64_t v60 = *(void *)(a1 + 40);
  int v59 = *(std::__shared_weak_count **)(a1 + 48);
  v70[4] = v69;
  v70[5] = v60;
  xpc_object_t v71 = v59;
  if (v59) {
    atomic_fetch_add_explicit(&v59->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v72 = v50;
  uint64_t v73 = *(std::__shared_weak_count **)&__dst[8];
  if (*(void *)&__dst[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&__dst[8] + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v61 = *(void **)(a1 + 64);
  if (v61) {
    unint64_t v61 = _Block_copy(v61);
  }
  uint64_t v62 = *(NSObject **)(a1 + 72);
  aBlocuint64_t k = v61;
  dispatch_object_t object = v62;
  if (v62) {
    dispatch_retain(v62);
  }
  dispatch_group_notify(v57, v58, v70);
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  xpc_object_t v63 = v73;
  if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
  }
  if (v71) {
    std::__shared_weak_count::__release_weak(v71);
  }
  xpc_object_t v64 = *(std::__shared_weak_count **)&__dst[8];
  if (*(void *)&__dst[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&__dst[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
    std::__shared_weak_count::__release_weak(v64);
  }
  uint64_t v65 = *(void *)v88;
  if (*(void *)v88)
  {
    uint64_t v66 = *(void *)&v88[8];
    uint64_t v67 = *(void **)v88;
    if (*(void *)&v88[8] != *(void *)v88)
    {
      do
      {
        if (*(char *)(v66 - 9) < 0) {
          operator delete(*(void **)(v66 - 32));
        }
        v66 -= 40;
      }
      while (v66 != v65);
      uint64_t v67 = *(void **)v88;
    }
    *(void *)&v88[8] = v65;
    operator delete(v67);
  }
  uint64_t v68 = (std::__shared_weak_count *)v87.__r_.__value_.__l.__size_;
  if (v87.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v87.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  if (v43)
  {
    dispatch_group_leave(v43);
    dispatch_release(v43);
  }
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v89.__r_.__value_.__l.__data_);
  }
LABEL_172:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  xpc_release(v16);
  uint64_t v9 = v91;
  if (v91) {
    goto LABEL_175;
  }
}

void sub_1A6141074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,dispatch_group_t group,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *a50)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a50);
  if (v51)
  {
    dispatch_group_leave(v51);
    dispatch_release(v51);
  }
  if (*(char *)(v52 - 209) < 0) {
    operator delete(*(void **)(v52 - 232));
  }
  if (*(char *)(v52 - 121) < 0) {
    operator delete(*(void **)(v52 - 144));
  }
  xpc_release(v50);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v52 - 208);
  _Unwind_Resume(a1);
}

void sub_1A614134C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_14(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = std::__shared_weak_count::lock(v2);
    uint64_t v53 = v4;
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v52 = *(void *)(a1 + 40);
      if (!v52 || (size_t v6 = *(abm::FileProperties ***)(a1 + 64), !*v6))
      {
LABEL_94:
        if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        return;
      }
      memset(&v51, 170, sizeof(v51));
      abm::FileProperties::getPath(*v6, &v51);
      memset(&__dst, 170, sizeof(__dst));
      size_t v7 = *(uint64_t **)(a1 + 64);
      uint64_t v8 = *v7;
      uint64_t v9 = (std::__shared_weak_count *)v7[1];
      uint64_t v48 = *v7;
      xpc_object_t v49 = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v54, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v8 + 8);
        v54.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = *(char *)(a1 + 95);
      if (v11 >= 0) {
        size_t v12 = *(unsigned __int8 *)(a1 + 95);
      }
      else {
        size_t v12 = *(void *)(a1 + 80);
      }
      int v13 = SHIBYTE(v54.__r_.__value_.__r.__words[2]);
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t size = v54.__r_.__value_.__l.__size_;
      }
      unint64_t v15 = size + v12;
      memset(&__dst, 170, sizeof(__dst));
      if (size + v12 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v15 > 0x16)
      {
        uint64_t v34 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v15 | 7) != 0x17) {
          uint64_t v34 = v15 | 7;
        }
        uint64_t v35 = v34 + 1;
        xpc_object_t v16 = (std::string *)operator new(v34 + 1);
        __dst.__r_.__value_.__l.__size_ = size + v12;
        __dst.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
        if (!v12)
        {
LABEL_23:
          if (size)
          {
            if (v13 >= 0) {
              xpc_object_t v18 = &v54;
            }
            else {
              xpc_object_t v18 = (std::string *)v54.__r_.__value_.__r.__words[0];
            }
            memmove((char *)v16 + v12, v18, size);
          }
          v16->__r_.__value_.__s.__data_[v12 + size] = 0;
          if (v13 < 0) {
            operator delete(v54.__r_.__value_.__l.__data_);
          }
          if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
          int v19 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            xpc_object_t v20 = &v51;
            if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              xpc_object_t v20 = (std::string *)v51.__r_.__value_.__r.__words[0];
            }
            p_dst = &__dst;
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            LODWORD(v54.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v54.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
            WORD2(v54.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v54.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_dst;
            _os_log_impl(&dword_1A609F000, v19, OS_LOG_TYPE_DEFAULT, "#I Move %s to %s", (uint8_t *)&v54, 0x16u);
          }
          *(&__ec.__val_ + 1) = -1431655766;
          __ec.__val_ = 0;
          __ec.__cat_ = std::system_category();
          memset(&v54, 0, sizeof(v54));
          std::string::size_type v22 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
          if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            xpc_object_t v23 = &v51;
          }
          else {
            xpc_object_t v23 = (std::string *)v51.__r_.__value_.__r.__words[0];
          }
          if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v22 = v51.__r_.__value_.__l.__size_;
          }
          std::string::append[abi:ne180100]<char const*,0>((unint64_t)&v54, (char *)v23, (char *)v23 + v22);
          memset(&__to, 0, sizeof(__to));
          std::string::size_type v24 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            xpc_object_t v25 = &__dst;
          }
          else {
            xpc_object_t v25 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v24 = __dst.__r_.__value_.__l.__size_;
          }
          std::string::append[abi:ne180100]<char const*,0>((unint64_t)&__to, (char *)v25, (char *)v25 + v24);
          std::__fs::filesystem::__copy((const std::__fs::filesystem::path *)&v54, &__to, recursive|update_existing, &__ec);
          if (SHIBYTE(__to.__pn_.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__to.__pn_.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_51:
              if (__ec.__val_) {
                goto LABEL_52;
              }
              goto LABEL_68;
            }
          }
          else if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_51;
          }
          operator delete(v54.__r_.__value_.__l.__data_);
          if (__ec.__val_)
          {
LABEL_52:
            xpc_object_t v26 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              int v27 = SHIBYTE(v51.__r_.__value_.__r.__words[2]);
              std::string::size_type v28 = v51.__r_.__value_.__r.__words[0];
              int v29 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
              std::string::size_type v30 = __dst.__r_.__value_.__r.__words[0];
              std::error_code::message(&__to.__pn_, &__ec);
              char v31 = &__dst;
              if (v29 < 0) {
                char v31 = (std::string *)v30;
              }
              std::string::size_type v32 = &v51;
              if (v27 < 0) {
                std::string::size_type v32 = (std::string *)v28;
              }
              LODWORD(v54.__r_.__value_.__l.__data_) = 136315650;
              if ((__to.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_to = &__to;
              }
              else {
                p_to = (std::__fs::filesystem::path *)__to.__pn_.__r_.__value_.__r.__words[0];
              }
              *(std::string::size_type *)((char *)v54.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
              WORD2(v54.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v54.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v31;
              HIWORD(v54.__r_.__value_.__r.__words[2]) = 2080;
              uint64_t v55 = p_to;
              _os_log_error_impl(&dword_1A609F000, v26, OS_LOG_TYPE_ERROR, "Failed to copy from %s to %s: %s\n", (uint8_t *)&v54, 0x20u);
              if (SHIBYTE(__to.__pn_.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__to.__pn_.__r_.__value_.__l.__data_);
              }
            }
            goto LABEL_88;
          }
LABEL_68:
          gid_t v45 = -1431655766;
          LODWORD(__to.__pn_.__r_.__value_.__l.__data_) = -1431655766;
          if (support::fs::getUidGid(1, (uid_t *)&__to, &v45))
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              std::string::__init_copy_ctor_external(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string __p = __dst;
            }
            int updated = support::fs::updateOwner((const char *)&__p, LODWORD(__to.__pn_.__r_.__value_.__l.__data_), v45);
            char v37 = updated;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__p.__r_.__value_.__l.__data_);
              if (v37)
              {
LABEL_74:
                unsigned int v38 = support::fs::isDir((const char *)&__dst);
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v39 = &__dst;
                }
                else {
                  uint64_t v39 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                }
                if (v38) {
                  mode_t v40 = 495;
                }
                else {
                  mode_t v40 = 422;
                }
                if (chmod((const char *)v39, v40))
                {
                  xpc_object_t v41 = *(NSObject **)(v3 + 40);
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                  {
                    std::string::size_type v42 = &__dst;
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                      std::string::size_type v42 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    }
                    LODWORD(v54.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)v54.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
                    _os_log_error_impl(&dword_1A609F000, v41, OS_LOG_TYPE_ERROR, "Failed to change file permission: %s", (uint8_t *)&v54, 0xCu);
                  }
                }
                goto LABEL_88;
              }
            }
            else if (updated)
            {
              goto LABEL_74;
            }
          }
          char v43 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v54.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl(&dword_1A609F000, v43, OS_LOG_TYPE_ERROR, "Failed to update owner", (uint8_t *)&v54, 2u);
          }
LABEL_88:
          abm::LogManagementTask::remove_sync(v3, (std::string::size_type)&v51);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_90:
              uint64_t v5 = v53;
              if (!v53) {
                return;
              }
              goto LABEL_94;
            }
          }
          else if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_90;
          }
          operator delete(v51.__r_.__value_.__l.__data_);
          uint64_t v5 = v53;
          if (!v53) {
            return;
          }
          goto LABEL_94;
        }
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        xpc_object_t v16 = &__dst;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = size + v12;
        if (!v12) {
          goto LABEL_23;
        }
      }
      if (v11 >= 0) {
        xpc_object_t v17 = (const void *)(a1 + 72);
      }
      else {
        xpc_object_t v17 = *(const void **)(a1 + 72);
      }
      memmove(v16, v17, v12);
      goto LABEL_23;
    }
  }
}

void sub_1A614196C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if (a32 < 0)
  {
    operator delete(__p);
    if ((a38 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a38 & 0x80000000) == 0)
  {
LABEL_3:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a39);
    _Unwind_Resume(a1);
  }
  operator delete(a33);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a39);
  _Unwind_Resume(a1);
}

void sub_1A6141A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1A6141A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (*(char *)(v29 - 121) < 0) {
    operator delete(*(void **)(v29 - 144));
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a19);
  if (a29 < 0) {
    JUMPOUT(0x1A61419FCLL);
  }
  JUMPOUT(0x1A61419E4);
}

BOOL abm::LogManagementTask::remove_sync(uint64_t a1, std::string::size_type a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(void *)&v12.__val_ = 0xAAAAAAAA00000000;
  v12.__cat_ = std::system_category();
  memset(&v17, 0, sizeof(v17));
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = (char *)a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  std::string::append[abi:ne180100]<char const*,0>((unint64_t)&v17, v5, &v5[v4]);
  std::__fs::filesystem::__remove_all(&v17, &v12);
  if (SHIBYTE(v17.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__pn_.__r_.__value_.__l.__data_);
    int val = v12.__val_;
    size_t v7 = *(NSObject **)(a1 + 40);
    uint64_t v8 = v7;
    if (v12.__val_)
    {
LABEL_8:
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) < 0) {
          a2 = *(void *)a2;
        }
        std::error_code::message(&v17.__pn_, &v12);
        if ((v17.__pn_.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v9 = &v17;
        }
        else {
          uint64_t v9 = (std::__fs::filesystem::path *)v17.__pn_.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        std::string::size_type v14 = a2;
        __int16 v15 = 2080;
        xpc_object_t v16 = v9;
        _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Failed to remove %s: %s\n", buf, 0x16u);
        if (SHIBYTE(v17.__pn_.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v17.__pn_.__r_.__value_.__l.__data_);
        }
      }
      return val == 0;
    }
  }
  else
  {
    int val = v12.__val_;
    size_t v7 = *(NSObject **)(a1 + 40);
    uint64_t v8 = v7;
    if (v12.__val_) {
      goto LABEL_8;
    }
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v10 = a2;
    }
    else {
      std::string::size_type v10 = *(void *)a2;
    }
    LODWORD(v17.__pn_.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v17.__pn_.__r_.__value_.__r.__words + 4) = v10;
    _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I File removed: %s\n", (uint8_t *)&v17, 0xCu);
  }
  return val == 0;
}

void sub_1A6141C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(std::string *a1, uint64_t a2)
{
  std::string::size_type v4 = *(void *)(a2 + 48);
  a1[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
  a1[2].__r_.__value_.__r.__words[0] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(NSObject **)(a2 + 56);
  a1[2].__r_.__value_.__l.__size_ = (std::string::size_type)v5;
  if (v5)
  {
    dispatch_retain(v5);
    size_t size = a1[2].__r_.__value_.__l.__size_;
    if (size) {
      dispatch_group_enter(size);
    }
  }
  size_t v7 = a1 + 3;
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 72);
    a1[3].__r_.__value_.__r.__words[2] = *(void *)(a2 + 88);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_1A6141CC4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 + 56);
  if (v3)
  {
    dispatch_group_leave(v3);
    std::string::size_type v4 = *(NSObject **)(v1 + 56);
    if (v4) {
      dispatch_release(v4);
    }
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 48);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE72c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0)
  {
    operator delete(*(void **)(a1 + 72));
    uint64_t v2 = *(NSObject **)(a1 + 56);
    if (!v2) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v2 = *(NSObject **)(a1 + 56);
    if (!v2) {
      goto LABEL_7;
    }
  }
  dispatch_group_leave(v2);
  uint64_t v3 = *(NSObject **)(a1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
LABEL_7:
  std::string::size_type v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_17(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    std::string::size_type v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_27:
        if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        return;
      }
      size_t v6 = (uint64_t *)a1[7];
      if (v6)
      {
        uint64_t v7 = *v6;
        uint64_t v8 = v6[1];
        if (v8 != *v6)
        {
          do
          {
            uint64_t v9 = *(std::__shared_weak_count **)(v8 - 8);
            if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
            v8 -= 16;
          }
          while (v8 != v7);
        }
        v6[1] = v7;
      }
      std::string::size_type v10 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v16[0]) = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Moving Done", (uint8_t *)v16, 2u);
      }
      xpc_object_t v11 = xpc_null_create();
      std::error_code v12 = (const void *)a1[9];
      if (v12) {
        int v13 = _Block_copy(v12);
      }
      else {
        int v13 = 0;
      }
      std::string::size_type v14 = a1[10];
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3321888768;
      void v16[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
      v16[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v13)
      {
        __int16 v15 = _Block_copy(v13);
        int v19 = 0;
        aBlocuint64_t k = v15;
        xpc_object_t object = v11;
        if (v11)
        {
LABEL_19:
          xpc_retain(v11);
LABEL_22:
          dispatch_async(v14, v16);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v13) {
            _Block_release(v13);
          }
          xpc_release(v11);
          goto LABEL_27;
        }
      }
      else
      {
        int v19 = 0;
        aBlocuint64_t k = 0;
        xpc_object_t object = v11;
        if (v11) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(void *a1, void *a2)
{
  uint64_t v4 = a2[6];
  a1[5] = a2[5];
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[8];
  a1[7] = a2[7];
  a1[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  size_t v6 = (void *)a2[9];
  if (v6) {
    size_t v6 = _Block_copy(v6);
  }
  uint64_t v7 = a2[10];
  a1[9] = v6;
  a1[10] = v7;
  if (v7)
  {
    dispatch_retain(v7);
  }
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(void *a1)
{
  uint64_t v2 = a1[10];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = (const void *)a1[9];
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    if (!v5) {
      return;
    }
  }

  std::__shared_weak_count::__release_weak(v5);
}

void **std::vector<abm::DirectoryQuery>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 9) < 0) {
          operator delete(*(v3 - 4));
        }
        v3 -= 5;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(void *a1, void *a2)
{
  uint64_t v4 = a2[6];
  a1[5] = a2[5];
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (void *)a2[7];
  a1[7] = v5;
  if (!v5)
  {
    a1[7] = xpc_null_create();
    size_t v6 = (void *)a2[8];
    if (!v6) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  xpc_retain(v5);
  size_t v6 = (void *)a2[8];
  if (v6) {
LABEL_7:
  }
    size_t v6 = _Block_copy(v6);
LABEL_8:
  uint64_t v7 = a2[9];
  a1[8] = v6;
  a1[9] = v7;
  if (v7)
  {
    dispatch_retain(v7);
  }
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 72);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3) {
    _Block_release(v3);
  }
  xpc_release(*(xpc_object_t *)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_20(void *a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      std::string::size_type v10 = v9;
      uint64_t v11 = a1[5];
      if (!v11)
      {
LABEL_19:
        if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      std::error_code v12 = *(NSObject **)(v8 + 112);
      int v13 = *(NSObject **)(v8 + 88);
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3321888768;
      v18[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2_21;
      void v18[3] = &__block_descriptor_80_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c15_ZTSN3xpc4dictE64c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
      v18[4] = v8;
      void v18[5] = v11;
      std::string::size_type v14 = (std::__shared_weak_count *)a1[6];
      int v19 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      __int16 v15 = *a3;
      xpc_object_t v20 = v15;
      if (v15)
      {
        xpc_retain(v15);
        xpc_object_t v16 = *(void **)a4;
        if (!*(void *)a4) {
          goto LABEL_11;
        }
      }
      else
      {
        xpc_object_t v20 = xpc_null_create();
        xpc_object_t v16 = *(void **)a4;
        if (!*(void *)a4)
        {
LABEL_11:
          std::__fs::filesystem::path v17 = *(NSObject **)(a4 + 8);
          aBlocuint64_t k = v16;
          dispatch_object_t object = v17;
          if (v17) {
            dispatch_retain(v17);
          }
          dispatch_group_notify(v12, v13, v18);
          if (object) {
            dispatch_release(object);
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          xpc_release(v20);
          xpc_object_t v20 = 0;
          if (v19) {
            std::__shared_weak_count::__release_weak(v19);
          }
          goto LABEL_19;
        }
      }
      xpc_object_t v16 = _Block_copy(v16);
      goto LABEL_11;
    }
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_2_21(uint64_t a1)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2) {
    return;
  }
  size_t v76 = *(NSObject ***)(a1 + 32);
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  char v101 = v3;
  if (!v3) {
    return;
  }
  if (!*(void *)(a1 + 40))
  {
    size_t v6 = v3;
    goto LABEL_200;
  }
  xpc_object_t value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "MatchingPattern");
  xpc_object_t v5 = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  xpc_object_t v7 = xpc_null_create();
  if (v5 && MEMORY[0x1A6275E60](v5) == MEMORY[0x1E4F14568])
  {
    xpc_retain(v5);
    xpc_object_t v8 = v5;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
  }
  if (MEMORY[0x1A6275E60](v8) != MEMORY[0x1E4F14568])
  {
    if (v7)
    {
      xpc_retain(v7);
      xpc_object_t v9 = v7;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
    xpc_release(v8);
    xpc_object_t v8 = v9;
  }
  xpc_release(v7);
  xpc_release(v5);
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v98 = v10;
  long long v99 = v10;
  *(_OWORD *)&v96[0].__locale_ = v10;
  long long v97 = v10;
  xpc_object_t v74 = v8;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)v96, "[0-9]{4}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2}.[0-9]{2}", 0);
  v95.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v95.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
  v95.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
  if (v8)
  {
    xpc_retain(v8);
    xpc_object_t v11 = v8;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    if (!v11)
    {
      xpc_object_t v11 = xpc_null_create();
      std::error_code v12 = 0;
      goto LABEL_21;
    }
  }
  xpc_retain(v11);
  std::error_code v12 = v11;
LABEL_21:
  xpc_object_t v75 = (void *)a1;
  xpc_release(v12);
  size_t v13 = 0;
  p_end_cap = &__p[1].__end_cap_;
  while (1)
  {
    if (v8)
    {
      xpc_retain(v8);
      xpc_object_t v16 = v8;
    }
    else
    {
      xpc_object_t v16 = xpc_null_create();
    }
    if (MEMORY[0x1A6275E60](v8) == MEMORY[0x1E4F14568])
    {
      size_t count = xpc_array_get_count(v8);
      if (!v16)
      {
LABEL_31:
        xpc_object_t v18 = xpc_null_create();
        goto LABEL_32;
      }
    }
    else
    {
      size_t count = 0;
      if (!v16) {
        goto LABEL_31;
      }
    }
    xpc_retain(v16);
    xpc_object_t v18 = v16;
LABEL_32:
    xpc_release(v16);
    xpc_release(v18);
    if (v13 == count && v11 == v18) {
      break;
    }
    memset(&v94, 170, sizeof(v94));
    xpc_object_t v19 = xpc_array_get_value(v11, v13);
    *(void *)dispatch_object_t object = v19;
    if (v19) {
      xpc_retain(v19);
    }
    else {
      *(void *)dispatch_object_t object = xpc_null_create();
    }
    xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)object);
    std::vector<std::ssub_match>::pointer value_high = (std::vector<std::ssub_match>::pointer)HIBYTE(v94.__end_cap_.__value_);
    if (SHIBYTE(v94.__end_cap_.__value_) < 0) {
      std::vector<std::ssub_match>::pointer value_high = v94.__end_;
    }
    if (!value_high) {
      goto LABEL_86;
    }
    if (SHIBYTE(v94.__end_cap_.__value_) >= 0) {
      begin = (std::sub_match<const char *> *)&v94;
    }
    else {
      begin = (std::sub_match<const char *> *)v94.__begin_;
    }
    std::string::size_type v22 = (std::vector<std::ssub_match>::pointer)((char *)value_high + (void)begin);
    *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&p_end_cap[4].__value_ = v23;
    *(_OWORD *)&p_end_cap[6].__value_ = v23;
    *(_OWORD *)&p_end_cap->__value_ = v23;
    *(_OWORD *)&p_end_cap[2].__value_ = v23;
    uint64_t v103 = 0;
    uint64_t v104 = 0;
    char v105 = 0;
    uint64_t v106 = 0;
    uint64_t v107 = 0;
    char v108 = 0;
    char v109 = 0;
    uint64_t v110 = 0;
    memset(__p, 0, 41);
    *(_OWORD *)&v115.__r_.__value_.__l.__data_ = v23;
    v112.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&object[40] = 0xAAAAAAAAAAAAAAAALL;
    memset(&v112, 0, 17);
    uint64_t v113 = 0;
    uint64_t v114 = 0;
    v115.__r_.__value_.__s.__data_[0] = 0;
    v115.__r_.__value_.__s.__data_[8] = 0;
    v115.__r_.__value_.__r.__words[2] = 0;
    memset(object, 0, 41);
    int v24 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)v96, begin, (std::sub_match<const char *> *)((char *)value_high + (void)begin), (std::vector<std::csub_match> *)object, 4160);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(__p, (uint64_t)begin, v22, (uint64_t *)object, 0);
    if (*(void *)object)
    {
      *(void *)&object[8] = *(void *)object;
      operator delete(*(void **)object);
    }
    if (v108) {
      int v25 = v24 ^ 1;
    }
    else {
      int v25 = 1;
    }
    if (__p[0].__begin_)
    {
      __p[0].__end_ = __p[0].__begin_;
      operator delete(__p[0].__begin_);
    }
    if ((v24 & v25 & 1) == 0)
    {
LABEL_86:
      if ((SHIBYTE(v94.__end_cap_.__value_) & 0x80000000) == 0) {
        goto LABEL_87;
      }
      goto LABEL_96;
    }
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)object, "-|_", 0);
    memset(__p, 0, 24);
    unint64_t end = HIBYTE(v94.__end_cap_.__value_);
    if (SHIBYTE(v94.__end_cap_.__value_) >= 0) {
      v27.__i_ = (std::__wrap_iter<const char *>::iterator_type)&v94;
    }
    else {
      v27.__i_ = (std::__wrap_iter<const char *>::iterator_type)v94.__begin_;
    }
    if (SHIBYTE(v94.__end_cap_.__value_) < 0) {
      unint64_t end = (unint64_t)v94.__end_;
    }
    v28.__i_ = &v27.__i_[end];
    std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>((std::string *)__p, v27, v28, (const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *)object, ".", 0);
    if (SHIBYTE(v94.__end_cap_.__value_) < 0) {
      operator delete(v94.__begin_);
    }
    std::vector<std::ssub_match> v94 = __p[0];
    HIBYTE(__p[0].__end_cap_.__value_) = 0;
    LOBYTE(__p[0].__begin_) = 0;
    uint64_t v29 = (std::__shared_weak_count *)v112.__r_.__value_.__r.__words[0];
    if (v112.__r_.__value_.__r.__words[0]
      && !atomic_fetch_add((atomic_ullong *volatile)(v112.__r_.__value_.__r.__words[0] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    std::string::size_type v30 = p_end_cap;
    std::locale::~locale((std::locale *)object);
    std::string::size_type size = HIBYTE(v95.__r_.__value_.__r.__words[2]);
    if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v95.__r_.__value_.__l.__size_;
    }
    if (size) {
      std::string::append(&v95, "|", 1uLL);
    }
    std::string::size_type v32 = abm::trace::kLogDirPrefix[0];
    size_t v33 = strlen(abm::trace::kLogDirPrefix[0]);
    int v34 = SHIBYTE(v94.__end_cap_.__value_);
    if (SHIBYTE(v94.__end_cap_.__value_) >= 0) {
      size_t v35 = HIBYTE(v94.__end_cap_.__value_);
    }
    else {
      size_t v35 = (size_t)v94.__end_;
    }
    size_t v36 = v35 + v33;
    memset(__p, 170, 24);
    if (v35 + v33 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v37 = v33;
    if (v36 <= 0x16)
    {
      memset(__p, 0, 24);
      unsigned int v38 = (std::sub_match<std::__wrap_iter<const char *>> *)__p;
      HIBYTE(__p[0].__end_cap_.__value_) = v35 + v33;
      p_end_cap = v30;
      if (!v33) {
        goto LABEL_72;
      }
LABEL_71:
      memcpy(v38, v32, v37);
      goto LABEL_72;
    }
    uint64_t v45 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v45 = v36 | 7;
    }
    uint64_t v46 = v45 + 1;
    unsigned int v38 = (std::sub_match<std::__wrap_iter<const char *>> *)operator new(v45 + 1);
    __p[0].__end_cap_.__value_ = (std::sub_match<std::__wrap_iter<const char *>> *)(v46 | 0x8000000000000000);
    __p[0].__begin_ = v38;
    __p[0].__end_ = (std::vector<std::ssub_match>::pointer)v36;
    xpc_object_t v8 = v74;
    p_end_cap = v30;
    if (v37) {
      goto LABEL_71;
    }
LABEL_72:
    uint64_t v39 = (char *)v38 + v37;
    if (v35)
    {
      if (v34 >= 0) {
        std::vector<std::ssub_match>::pointer v40 = (std::vector<std::ssub_match>::pointer)&v94;
      }
      else {
        std::vector<std::ssub_match>::pointer v40 = v94.__begin_;
      }
      memmove(v39, v40, v35);
    }
    v39[v35] = 0;
    char v93 = 2;
    strcpy(__s, ".*");
    xpc_object_t v41 = std::string::append((std::string *)__p, __s, 2uLL);
    long long v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    *(void *)&object[16] = *((void *)&v41->__r_.__value_.__l + 2);
    *(_OWORD *)dispatch_object_t object = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    if (object[23] >= 0) {
      char v43 = object;
    }
    else {
      char v43 = *(const std::string::value_type **)object;
    }
    if (object[23] >= 0) {
      std::string::size_type v44 = object[23];
    }
    else {
      std::string::size_type v44 = *(void *)&object[8];
    }
    std::string::append(&v95, v43, v44);
    if ((object[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)object);
      if ((v93 & 0x80000000) == 0)
      {
LABEL_85:
        if ((SHIBYTE(__p[0].__end_cap_.__value_) & 0x80000000) == 0) {
          goto LABEL_86;
        }
        goto LABEL_95;
      }
    }
    else if ((v93 & 0x80000000) == 0)
    {
      goto LABEL_85;
    }
    operator delete(*(void **)__s);
    if ((SHIBYTE(__p[0].__end_cap_.__value_) & 0x80000000) == 0) {
      goto LABEL_86;
    }
LABEL_95:
    operator delete(__p[0].__begin_);
    if ((SHIBYTE(v94.__end_cap_.__value_) & 0x80000000) == 0)
    {
LABEL_87:
      if (!v11) {
        goto LABEL_22;
      }
      goto LABEL_97;
    }
LABEL_96:
    operator delete(v94.__begin_);
    if (!v11)
    {
LABEL_22:
      xpc_object_t v15 = xpc_null_create();
      goto LABEL_23;
    }
LABEL_97:
    xpc_retain(v11);
    xpc_object_t v15 = v11;
LABEL_23:
    ++v13;
    xpc_release(v15);
  }
  xpc_release(v11);
  char v47 = v76[14];
  if (v47)
  {
    dispatch_retain(v76[14]);
    dispatch_group_enter(v47);
  }
  v94.__begin_ = (std::vector<std::ssub_match>::pointer)0xAAAAAAAAAAAAAAAALL;
  v94.__end_ = (std::vector<std::ssub_match>::pointer)0xAAAAAAAAAAAAAAAALL;
  uint64_t v48 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  xpc_object_t v49 = (std::sub_match<std::__wrap_iter<const char *>> *)xmmword_1EB5EE590;
  if (!(void)xmmword_1EB5EE590)
  {
    ctu::XpcJetsamAssertion::create_default_global((uint64_t *)object, v48);
    long long v50 = *(_OWORD *)object;
    *(void *)&object[8] = 0;
    *(void *)dispatch_object_t object = 0;
    std::string v51 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
    xmmword_1EB5EE590 = v50;
    if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    uint64_t v52 = *(std::__shared_weak_count **)&object[8];
    if (*(void *)&object[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&object[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
    xpc_object_t v49 = (std::sub_match<std::__wrap_iter<const char *>> *)xmmword_1EB5EE590;
  }
  uint64_t v53 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
  __p[0].__begin_ = v49;
  __p[0].__end_ = (std::vector<std::ssub_match>::pointer)*((void *)&xmmword_1EB5EE590 + 1);
  if (*((void *)&xmmword_1EB5EE590 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  v91[23] = 10;
  strcpy(v91, "Log Delete");
  ctu::XpcJetsamAssertion::createActivity();
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  std::string v54 = v76[5];
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_object_t object = 0;
    _os_log_impl(&dword_1A609F000, v54, OS_LOG_TYPE_DEFAULT, "#I Deleting Telephony and Baseband logs", object, 2u);
  }
  memset(__p, 170, 24);
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v90, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
  }
  else {
    std::string v90 = v95;
  }
  *(_DWORD *)dispatch_object_t object = 4;
  if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external((std::string *)&object[8], v90.__r_.__value_.__l.__data_, v90.__r_.__value_.__l.__size_);
  }
  else {
    *(std::string *)&object[8] = v90;
  }
  *(_DWORD *)&object[32] = 0;
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v89, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
  }
  else {
    std::string v89 = v95;
  }
  *(_DWORD *)&object[40] = 3;
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v112, v89.__r_.__value_.__l.__data_, v89.__r_.__value_.__l.__size_);
  }
  else {
    std::string v112 = v89;
  }
  LODWORD(v113) = 0;
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v88, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
  }
  else {
    std::string v88 = v95;
  }
  LODWORD(v114) = 5;
  if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v115, v88.__r_.__value_.__l.__data_, v88.__r_.__value_.__l.__size_);
  }
  else {
    std::string v115 = v88;
  }
  int v116 = 0;
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v87, v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
  }
  else {
    std::string v87 = v95;
  }
  int v117 = 6;
  if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v118, v87.__r_.__value_.__l.__data_, v87.__r_.__value_.__l.__size_);
  }
  else {
    std::string v118 = v87;
  }
  int v119 = 0;
  std::vector<abm::DirectoryQuery>::vector[abi:ne180100](__p, (uint64_t)object, 4uLL);
  if ((SHIBYTE(v118.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v115.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_141;
    }
LABEL_204:
    operator delete(v115.__r_.__value_.__l.__data_);
    if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_205;
    }
LABEL_142:
    if ((object[31] & 0x80000000) == 0) {
      goto LABEL_143;
    }
LABEL_206:
    operator delete(*(void **)&object[8]);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_207;
    }
LABEL_144:
    if ((SHIBYTE(v88.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_145;
    }
LABEL_208:
    operator delete(v88.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_209;
    }
LABEL_146:
    if ((SHIBYTE(v90.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_147;
    }
LABEL_210:
    operator delete(v90.__r_.__value_.__l.__data_);
    goto LABEL_147;
  }
  operator delete(v118.__r_.__value_.__l.__data_);
  if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_204;
  }
LABEL_141:
  if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_142;
  }
LABEL_205:
  operator delete(v112.__r_.__value_.__l.__data_);
  if ((object[31] & 0x80000000) != 0) {
    goto LABEL_206;
  }
LABEL_143:
  if ((SHIBYTE(v87.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_144;
  }
LABEL_207:
  operator delete(v87.__r_.__value_.__l.__data_);
  if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_208;
  }
LABEL_145:
  if ((SHIBYTE(v89.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_146;
  }
LABEL_209:
  operator delete(v89.__r_.__value_.__l.__data_);
  if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_210;
  }
LABEL_147:
  memset(object, 170, 16);
  abm::findFiles((unsigned int **)__p, 1u, (char ***)object);
  uint64_t v55 = *(void *)object;
  uint64_t v56 = **(void **)object;
  if (**(void **)object != *(void *)(*(void *)object + 8))
  {
    uint64_t v57 = MEMORY[0x1E4F143A8];
    uint64_t v58 = **(void **)object;
    do
    {
      block[0] = v57;
      block[1] = 3321888768;
      block[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_26;
      block[3] = &__block_descriptor_72_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE_e5_v8__0l;
      uint64_t v60 = v75[5];
      int v59 = (std::__shared_weak_count *)v75[6];
      void block[4] = v76;
      void block[5] = v60;
      unint64_t v84 = v59;
      if (v59) {
        atomic_fetch_add_explicit(&v59->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_group_t group = v47;
      if (v47)
      {
        dispatch_retain(v47);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      uint64_t v86 = v56;
      dispatch_async(v76[17], block);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      if (v84) {
        std::__shared_weak_count::__release_weak(v84);
      }
      v58 += 16;
      uint64_t v55 = *(void *)object;
      v56 += 16;
    }
    while (v58 != *(void *)(*(void *)object + 8));
    xpc_object_t v8 = v74;
  }
  unint64_t v61 = v76[14];
  uint64_t v62 = v76[11];
  v77[0] = MEMORY[0x1E4F143A8];
  v77[1] = 3321888768;
  v77[2] = ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_28;
  v77[3] = &__block_descriptor_88_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c87_ZTSNSt3__110shared_ptrINS_6vectorINS0_IN3abm14FilePropertiesEEENS_9allocatorIS4_EEEEEE72c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
  uint64_t v64 = v75[5];
  xpc_object_t v63 = (std::__shared_weak_count *)v75[6];
  v77[4] = v76;
  v77[5] = v64;
  size_t v78 = v63;
  if (v63) {
    atomic_fetch_add_explicit(&v63->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v79 = v55;
  std::string v80 = *(std::__shared_weak_count **)&object[8];
  if (*(void *)&object[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&object[8] + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v65 = (void *)v75[8];
  if (v65) {
    uint64_t v65 = _Block_copy(v65);
  }
  uint64_t v66 = v75[9];
  aBlocuint64_t k = v65;
  dispatch_object_t v82 = v66;
  if (v66) {
    dispatch_retain(v66);
  }
  dispatch_group_notify(v61, v62, v77);
  if (v82) {
    dispatch_release(v82);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  uint64_t v67 = v80;
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
    std::__shared_weak_count::__release_weak(v67);
  }
  if (v78) {
    std::__shared_weak_count::__release_weak(v78);
  }
  uint64_t v68 = *(std::__shared_weak_count **)&object[8];
  if (*(void *)&object[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&object[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
    std::__shared_weak_count::__release_weak(v68);
  }
  size_t v69 = __p[0].__begin_;
  if (__p[0].__begin_)
  {
    std::vector<std::ssub_match>::pointer v70 = __p[0].__end_;
    std::vector<std::ssub_match>::pointer v71 = __p[0].__begin_;
    if (__p[0].__end_ != __p[0].__begin_)
    {
      do
      {
        if (SHIBYTE(v70[-1].second.__i_) < 0) {
          operator delete(*(void **)&v70[-2].matched);
        }
        std::vector<std::ssub_match>::pointer v70 = (std::vector<std::ssub_match>::pointer)((char *)v70 - 40);
      }
      while (v70 != v69);
      std::vector<std::ssub_match>::pointer v71 = __p[0].__begin_;
    }
    __p[0].__end_ = v69;
    operator delete(v71);
  }
  uint64_t v72 = (std::__shared_weak_count *)v94.__end_;
  if (v94.__end_ && !atomic_fetch_add((atomic_ullong *volatile)&v94.__end_->second, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
  }
  if (v47)
  {
    dispatch_group_leave(v47);
    dispatch_release(v47);
  }
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v95.__r_.__value_.__l.__data_);
  }
  uint64_t v73 = (std::__shared_weak_count *)v99;
  if ((void)v99 && !atomic_fetch_add((atomic_ullong *volatile)(v99 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
    std::__shared_weak_count::__release_weak(v73);
  }
  std::locale::~locale(v96);
  xpc_release(v8);
  size_t v6 = v101;
  if (v101)
  {
LABEL_200:
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1A6143314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a42 < 0)
  {
    operator delete(__p);
    if ((a49 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a56 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((a49 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a44);
  if ((a56 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a63 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(a51);
  if ((a63 & 0x80000000) == 0)
  {
LABEL_5:
    if (&STACK[0x280] == v74) {
      goto LABEL_11;
    }
    goto LABEL_14;
  }
LABEL_10:
  operator delete(a58);
  if (&STACK[0x280] == v74) {
    goto LABEL_11;
  }
  do
  {
LABEL_14:
    if (*((char *)v74 - 9) < 0) {
      operator delete((void *)*(v74 - 4));
    }
    v74 -= 5;
  }
  while (v74 != &STACK[0x280]);
LABEL_11:
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a71);
  if (v75)
  {
    dispatch_group_leave(v75);
    dispatch_release(v75);
  }
  if (a73 < 0) {
    operator delete(a72);
  }
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a74);
  xpc_release(object);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_1A61436B4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_26(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[4];
  xpc_object_t v11 = 0;
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    xpc_object_t v11 = std::__shared_weak_count::lock(v3);
    if (!v11) {
      return;
    }
    if (a1[5])
    {
      uint64_t v4 = (uint64_t *)a1[8];
      uint64_t v5 = *v4;
      if (*v4)
      {
        size_t v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v7 = (std::__shared_weak_count *)v4[1];
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (*(char *)(v5 + 31) < 0)
          {
            std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)(v5 + 8), *(void *)(v5 + 16));
          }
          else
          {
            long long v8 = *(_OWORD *)(v5 + 8);
            v12.__r_.__value_.__r.__words[2] = *(void *)(v5 + 24);
            *(_OWORD *)&v12.__r_.__value_.__l.__data_ = v8;
          }
          xpc_object_t v9 = &v12;
          if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            xpc_object_t v9 = (std::string *)v12.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315138;
          std::string::size_type v14 = v9;
          _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Deleting: %s", buf, 0xCu);
          if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v12.__r_.__value_.__l.__data_);
          }
          if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
          uint64_t v4 = (uint64_t *)a1[8];
          uint64_t v5 = *v4;
        }
        long long v10 = (std::__shared_weak_count *)v4[1];
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v5)
        {
          abm::FileProperties::getPath((abm::FileProperties *)v5, &v12);
          abm::LogManagementTask::remove_sync(v2, (std::string::size_type)&v12);
          if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v12.__r_.__value_.__l.__data_);
          }
        }
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
    }
  }
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_1A6143930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A614394C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

BOOL abm::LogManagementTask::remove_sync(uint64_t a1, abm::FileProperties **a2)
{
  if (!*a2) {
    return 0;
  }
  abm::FileProperties::getPath(*a2, &__p);
  BOOL result = abm::LogManagementTask::remove_sync(a1, (std::string::size_type)&__p);
  BOOL v4 = result;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    return v4;
  }
  return result;
}

void sub_1A6143A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE(void *a1, void *a2)
{
  uint64_t v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  BOOL v4 = a2[7];
  a1[7] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[7];
    if (v5)
    {
      dispatch_group_enter(v5);
    }
  }
}

void __destroy_helper_block_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE56c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_28(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_27:
        if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        return;
      }
      uint64_t v6 = (uint64_t *)a1[7];
      if (v6)
      {
        uint64_t v7 = *v6;
        uint64_t v8 = v6[1];
        if (v8 != *v6)
        {
          do
          {
            xpc_object_t v9 = *(std::__shared_weak_count **)(v8 - 8);
            if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
            v8 -= 16;
          }
          while (v8 != v7);
        }
        v6[1] = v7;
      }
      long long v10 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v16[0]) = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Deleting Done", (uint8_t *)v16, 2u);
      }
      xpc_object_t v11 = xpc_null_create();
      std::string v12 = (const void *)a1[9];
      if (v12) {
        size_t v13 = _Block_copy(v12);
      }
      else {
        size_t v13 = 0;
      }
      std::string::size_type v14 = a1[10];
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3321888768;
      void v16[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
      v16[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v13)
      {
        uint64_t v15 = _Block_copy(v13);
        int v19 = 0;
        aBlocuint64_t k = v15;
        xpc_object_t object = v11;
        if (v11)
        {
LABEL_19:
          xpc_retain(v11);
LABEL_22:
          dispatch_async(v14, v16);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v13) {
            _Block_release(v13);
          }
          xpc_release(v11);
          goto LABEL_27;
        }
      }
      else
      {
        int v19 = 0;
        aBlocuint64_t k = 0;
        xpc_object_t object = v11;
        if (v11) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_29(uint64_t a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 32);
  memset(&v27, 170, sizeof(v27));
  xpc_object_t value = xpc_dictionary_get_value(*a3, "TimestampString");
  *(void *)&long long object = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    *(void *)&long long object = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  xpc_release((xpc_object_t)object);
  uint64_t v7 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = &v27;
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v8 = (std::string *)v27.__r_.__value_.__r.__words[0];
    }
    LODWORD(object) = 136315138;
    *(void *)((char *)&object + 4) = v8;
    _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Log HouseKeeping requested - timestamp %s", (uint8_t *)&object, 0xCu);
  }
  std::string::size_type size = HIBYTE(v27.__r_.__value_.__r.__words[2]);
  if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v27.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    long long v10 = abm::trace::kMobileBasebandServicesFolder[0];
    size_t v11 = strlen(abm::trace::kMobileBasebandServicesFolder[0]);
    if (v11 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string v12 = (void *)v11;
    if (v11 >= 0x17)
    {
      uint64_t v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v16 = v11 | 7;
      }
      uint64_t v17 = v16 + 1;
      size_t v13 = (void **)operator new(v16 + 1);
      __dst[1] = v12;
      unint64_t v26 = v17 | 0x8000000000000000;
      __dst[0] = v13;
    }
    else
    {
      HIBYTE(v26) = v11;
      size_t v13 = __dst;
      if (!v11)
      {
        LOBYTE(__dst[0]) = 0;
        if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_15:
          std::string __p = v27;
          goto LABEL_23;
        }
LABEL_22:
        std::string::__init_copy_ctor_external(&__p, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
LABEL_23:
        abm::LogManagementTask::cleanUpLogs(v5, (uint64_t)__dst, (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v26) & 0x80000000) == 0) {
            goto LABEL_25;
          }
        }
        else if ((SHIBYTE(v26) & 0x80000000) == 0)
        {
          goto LABEL_25;
        }
        operator delete(__dst[0]);
LABEL_25:
        xpc_object_t v18 = xpc_null_create();
        if (*(void *)a4) {
          int v19 = _Block_copy(*(const void **)a4);
        }
        else {
          int v19 = 0;
        }
        xpc_object_t v20 = *(NSObject **)(a4 + 8);
        *(void *)&long long object = MEMORY[0x1E4F143A8];
        *((void *)&object + 1) = 3321888768;
        uint64_t v29 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
        std::string::size_type v30 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          int v21 = _Block_copy(v19);
          int v33 = 0;
          aBlocuint64_t k = v21;
          xpc_object_t v32 = v18;
          if (v18)
          {
LABEL_32:
            xpc_retain(v18);
LABEL_35:
            dispatch_async(v20, &object);
            xpc_release(v32);
            xpc_object_t v32 = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v19) {
              _Block_release(v19);
            }
            xpc_release(v18);
            goto LABEL_51;
          }
        }
        else
        {
          int v33 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t v32 = v18;
          if (v18) {
            goto LABEL_32;
          }
        }
        xpc_object_t v32 = xpc_null_create();
        goto LABEL_35;
      }
    }
    memmove(v13, v10, (size_t)v12);
    *((unsigned char *)v12 + (void)v13) = 0;
    if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_22;
  }
  xpc_object_t v14 = xpc_null_create();
  if (*(void *)a4) {
    uint64_t v15 = _Block_copy(*(const void **)a4);
  }
  else {
    uint64_t v15 = 0;
  }
  std::string::size_type v22 = *(NSObject **)(a4 + 8);
  *(void *)&long long object = MEMORY[0x1E4F143A8];
  *((void *)&object + 1) = 3321888768;
  uint64_t v29 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  std::string::size_type v30 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v15)
  {
    int v33 = -534716414;
    aBlocuint64_t k = 0;
    xpc_object_t v32 = v14;
    if (v14) {
      goto LABEL_43;
    }
LABEL_45:
    xpc_object_t v32 = xpc_null_create();
    goto LABEL_46;
  }
  long long v23 = _Block_copy(v15);
  int v33 = -534716414;
  aBlocuint64_t k = v23;
  xpc_object_t v32 = v14;
  if (!v14) {
    goto LABEL_45;
  }
LABEL_43:
  xpc_retain(v14);
LABEL_46:
  dispatch_async(v22, &object);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v15) {
    _Block_release(v15);
  }
  xpc_release(v14);
LABEL_51:
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
}

void sub_1A614414C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void abm::LogManagementTask::cleanUpLogs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  char v109 = 0;
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v105 + 1) = 0xAAAAAAAAAAAAAA00;
  *(void *)&v104[40] = 0xAAAAAAAAAAAAAAAALL;
  long long v107 = v6;
  *(void *)&v104[48] = 0;
  *(void *)&long long v105 = 0;
  long long v106 = 0uLL;
  LOBYTE(v107) = 0;
  BYTE8(v107) = 0;
  uint64_t v108 = 0;
  long long v7 = 0uLL;
  memset(v104, 0, 41);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9D8, memory_order_acquire) & 1) == 0)
  {
    int v92 = __cxa_guard_acquire(&qword_1EB5EE9D8);
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v7 = 0uLL;
    if (v92)
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA00, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
      __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA00, &dword_1A609F000);
      __cxa_guard_release(&qword_1EB5EE9D8);
      long long v7 = 0uLL;
      *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }
  }
  unint64_t v121 = 0xAAAAAAAAAAAAAA00;
  *((void *)&v118[1] + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v124 = v6;
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  uint64_t v122 = 0;
  uint64_t v123 = 0;
  LOBYTE(v124) = 0;
  BYTE8(v124) = 0;
  uint64_t v125 = 0;
  *(_OWORD *)std::string buf = v7;
  v118[0] = v7;
  uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  if ((v8 & 0x80u) == 0) {
    xpc_object_t v9 = (std::sub_match<const char *> *)a3;
  }
  else {
    xpc_object_t v9 = *(std::sub_match<const char *> **)a3;
  }
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a3 + 8);
  }
  *(_OWORD *)((char *)v118 + 9) = v7;
  char v10 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&unk_1EB5EEA00, v9, (std::sub_match<const char *> *)((char *)v9 + v8), (std::vector<std::csub_match> *)buf, 0);
  uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
  if ((v11 & 0x80u) == 0) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = *(void *)a3;
  }
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *(void *)(a3 + 8);
  }
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)v104, v12, (std::sub_match<std::__wrap_iter<const char *>> *)(v12 + v11), (uint64_t *)buf, 0);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v10)
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v102, ".*", 0);
    ctu::fs::get_filtered_files();
    size_t v13 = v103;
    if (v103 && !atomic_fetch_add(&v103->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    std::locale::~locale(&v102);
    xpc_object_t v14 = (unsigned __int8 *)v109;
    char v93 = (unsigned __int8 *)v110;
    xpc_object_t v96 = 0;
    std::string v95 = 0;
    uint64_t v15 = *(const void **)v104;
    uint64_t v16 = *(void *)&v104[8] - *(void *)v104;
    if (*(void *)&v104[8] != *(void *)v104)
    {
      if (0xAAAAAAAAAAAAAAABLL * (v16 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
        std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
      }
      std::string v95 = (char *)operator new(*(void *)&v104[8] - *(void *)v104);
      size_t v17 = 24 * ((v16 - 24) / 0x18uLL) + 24;
      memcpy(v95, v15, v17);
      xpc_object_t v96 = &v95[v17];
    }
    v98[1] = v105;
    v98[2] = v106;
    v98[3] = v107;
    long long v97 = *(_OWORD *)&v104[24];
    v98[0] = *(_OWORD *)&v104[40];
    uint64_t v99 = v108;
    uint64_t v100 = a1;
    if (*(char *)(a2 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v101, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string v101 = *(std::string *)a2;
    }
    while (v14 != v93)
    {
      uint64_t v19 = v100;
      uint64_t v20 = v14[23];
      int v21 = (char)v20;
      if ((v20 & 0x80u) != 0) {
        uint64_t v20 = *((void *)v14 + 1);
      }
      if (v20 == 2)
      {
        if (v21 >= 0) {
          long long v23 = v14;
        }
        else {
          long long v23 = *(_WORD **)v14;
        }
        if (*v23 != 11822)
        {
LABEL_44:
          *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v115 = v24;
          v114[6] = 0xAAAAAAAAAAAAAA00;
          v114[3] = 0xAAAAAAAAAAAAAAAALL;
          v114[4] = 0;
          v114[5] = 0;
          v114[7] = 0;
          v114[8] = 0;
          LOBYTE(v115) = 0;
          BYTE8(v115) = 0;
          uint64_t v116 = 0;
          long long v25 = 0uLL;
          *(_OWORD *)std::string __p = 0u;
          memset(v114, 0, 25);
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9D8, memory_order_acquire) & 1) == 0)
          {
            int v86 = __cxa_guard_acquire(&qword_1EB5EE9D8);
            long long v25 = 0uLL;
            *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
            if (v86)
            {
              std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA00, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
              __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA00, &dword_1A609F000);
              __cxa_guard_release(&qword_1EB5EE9D8);
              *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
              long long v25 = 0uLL;
            }
          }
          long long v124 = v24;
          unint64_t v121 = *((void *)&v24 + 1);
          *((void *)&v118[1] + 1) = v24;
          uint64_t v119 = 0;
          uint64_t v120 = 0;
          LOBYTE(v121) = 0;
          uint64_t v122 = 0;
          uint64_t v123 = 0;
          LOBYTE(v124) = 0;
          BYTE8(v124) = 0;
          uint64_t v125 = 0;
          *(_OWORD *)std::string buf = v25;
          v118[0] = v25;
          *(_OWORD *)((char *)v118 + 9) = v25;
          uint64_t v26 = v14[23];
          if ((v26 & 0x80u) == 0) {
            std::string v27 = (std::sub_match<const char *> *)v14;
          }
          else {
            std::string v27 = *(std::sub_match<const char *> **)v14;
          }
          if ((v26 & 0x80u) != 0) {
            uint64_t v26 = *((void *)v14 + 1);
          }
          int v28 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&unk_1EB5EEA00, v27, (std::sub_match<const char *> *)((char *)v27 + v26), (std::vector<std::csub_match> *)buf, 0);
          uint64_t v29 = v14[23];
          if ((v29 & 0x80u) == 0) {
            uint64_t v30 = (uint64_t)v14;
          }
          else {
            uint64_t v30 = *(void *)v14;
          }
          if ((v29 & 0x80u) != 0) {
            uint64_t v29 = *((void *)v14 + 1);
          }
          std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)__p, v30, (std::sub_match<std::__wrap_iter<const char *>> *)(v30 + v29), (uint64_t *)buf, 0);
          uint64_t v94 = v19;
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          if (v28)
          {
            unint64_t v31 = 1;
            while (1)
            {
              unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
              int v33 = (char *)__p[0] + 24 * v31 + 16;
              if (v32 <= v31) {
                int v33 = &v114[3];
              }
              if (!*v33)
              {
                memset(buf, 0, sizeof(buf));
                *(void *)&v118[0] = 0;
                goto LABEL_83;
              }
              BOOL v34 = v32 > v31;
              size_t v35 = &v114[1];
              if (v34) {
                size_t v35 = (uint64_t *)((char *)__p[0] + 24 * v31);
              }
              uint64_t v36 = *v35;
              size_t v37 = (char **)((char *)__p[0] + 24 * v31 + 8);
              if (!v34) {
                size_t v37 = (char **)&v114[2];
              }
              unsigned int v38 = *v37;
              unint64_t v39 = (unint64_t)&(*v37)[-v36];
              if (v39 > 0x7FFFFFFFFFFFFFF7) {
                std::string::__throw_length_error[abi:ne180100]();
              }
              if (v39 > 0x16)
              {
                uint64_t v47 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v39 | 7) != 0x17) {
                  uint64_t v47 = v39 | 7;
                }
                uint64_t v48 = v47 + 1;
                std::vector<std::ssub_match>::pointer v40 = operator new(v47 + 1);
                *(void *)&uint8_t buf[8] = v39;
                *(void *)&v118[0] = v48 | 0x8000000000000000;
                *(void *)std::string buf = v40;
                if ((char *)v36 == v38)
                {
LABEL_79:
                  *std::vector<std::ssub_match>::pointer v40 = 0;
                  goto LABEL_83;
                }
              }
              else
              {
                BYTE7(v118[0]) = *(unsigned char *)v37 - v36;
                std::vector<std::ssub_match>::pointer v40 = buf;
                if ((char *)v36 == v38) {
                  goto LABEL_79;
                }
              }
              if (v39 < 0x20 || (unint64_t)&v40[-v36] < 0x20)
              {
                xpc_object_t v41 = v40;
                long long v42 = (char *)v36;
              }
              else
              {
                xpc_object_t v41 = &v40[v39 & 0xFFFFFFFFFFFFFFE0];
                long long v42 = (char *)(v36 + (v39 & 0xFFFFFFFFFFFFFFE0));
                char v43 = (long long *)(v36 + 16);
                std::string::size_type v44 = v40 + 16;
                unint64_t v45 = v39 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  long long v46 = *v43;
                  *(v44 - 1) = *(v43 - 1);
                  *std::string::size_type v44 = v46;
                  v43 += 2;
                  v44 += 2;
                  v45 -= 32;
                }
                while (v45);
                if (v39 == (v39 & 0x7FFFFFFFFFFFFFE0)) {
                  goto LABEL_82;
                }
              }
              do
              {
                char v49 = *v42++;
                *v41++ = v49;
              }
              while (v42 != v38);
LABEL_82:
              *xpc_object_t v41 = 0;
LABEL_83:
              int v50 = std::stoi((const std::string *)buf, 0, 10);
              unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((v96 - v95) >> 3);
              uint64_t v52 = &v95[24 * v31 + 16];
              if (v51 <= v31) {
                uint64_t v52 = (char *)v98;
              }
              if (!*v52)
              {
                memset(&__str, 0, sizeof(__str));
                goto LABEL_107;
              }
              BOOL v53 = v51 > v31;
              std::string v54 = (char *)&v97;
              if (v53) {
                std::string v54 = &v95[24 * v31];
              }
              uint64_t v55 = *(void *)v54;
              uint64_t v56 = &v95[24 * v31 + 8];
              if (!v53) {
                uint64_t v56 = (char *)&v97 + 8;
              }
              uint64_t v57 = *(char **)v56;
              std::string::size_type v58 = *(void *)v56 - v55;
              if (v58 > 0x7FFFFFFFFFFFFFF7) {
                std::string::__throw_length_error[abi:ne180100]();
              }
              if (v58 > 0x16)
              {
                uint64_t v66 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v58 | 7) != 0x17) {
                  uint64_t v66 = v58 | 7;
                }
                uint64_t v67 = v66 + 1;
                p_str = operator new(v66 + 1);
                __str.__r_.__value_.__l.__size_ = v58;
                __str.__r_.__value_.__r.__words[2] = v67 | 0x8000000000000000;
                __str.__r_.__value_.__r.__words[0] = (std::string::size_type)p_str;
                if ((char *)v55 == v57)
                {
LABEL_103:
                  unsigned char *p_str = 0;
                  goto LABEL_107;
                }
              }
              else
              {
                *((unsigned char *)&__str.__r_.__value_.__s + 23) = *v56 - v55;
                p_str = &__str;
                if ((char *)v55 == v57) {
                  goto LABEL_103;
                }
              }
              if (v58 < 0x20 || (unint64_t)&p_str[-v55] < 0x20)
              {
                uint64_t v60 = p_str;
                unint64_t v61 = (char *)v55;
              }
              else
              {
                uint64_t v60 = &p_str[v58 & 0xFFFFFFFFFFFFFFE0];
                unint64_t v61 = (char *)(v55 + (v58 & 0xFFFFFFFFFFFFFFE0));
                uint64_t v62 = (long long *)(v55 + 16);
                xpc_object_t v63 = p_str + 16;
                unint64_t v64 = v58 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  long long v65 = *v62;
                  *(v63 - 1) = *(v62 - 1);
                  *xpc_object_t v63 = v65;
                  v62 += 2;
                  v63 += 2;
                  v64 -= 32;
                }
                while (v64);
                if (v58 == (v58 & 0x7FFFFFFFFFFFFFE0)) {
                  goto LABEL_106;
                }
              }
              do
              {
                char v68 = *v61++;
                *v60++ = v68;
              }
              while (v61 != v57);
LABEL_106:
              *uint64_t v60 = 0;
LABEL_107:
              int v69 = std::stoi(&__str, 0, 10);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(__str.__r_.__value_.__l.__data_);
                if ((SBYTE7(v118[0]) & 0x80000000) == 0)
                {
LABEL_109:
                  BOOL v70 = v50 == v69;
                  if (v50 > v69) {
                    goto LABEL_140;
                  }
                  goto LABEL_113;
                }
              }
              else if ((SBYTE7(v118[0]) & 0x80000000) == 0)
              {
                goto LABEL_109;
              }
              operator delete(*(void **)buf);
              BOOL v70 = v50 == v69;
              if (v50 > v69)
              {
LABEL_140:
                unint64_t v84 = *(NSObject **)(v94 + 40);
                if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                {
                  if ((v14[23] & 0x80u) == 0) {
                    char v85 = v14;
                  }
                  else {
                    char v85 = *(unsigned __int8 **)v14;
                  }
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v85;
                  _os_log_impl(&dword_1A609F000, v84, OS_LOG_TYPE_DEFAULT, "#I Not remove: %s", buf, 0xCu);
                }
                goto LABEL_145;
              }
LABEL_113:
              if (v70 && ++v31 != 7) {
                continue;
              }
              break;
            }
          }
          int v71 = SHIBYTE(v101.__r_.__value_.__r.__words[2]);
          if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t size = HIBYTE(v101.__r_.__value_.__r.__words[2]);
          }
          else {
            size_t size = v101.__r_.__value_.__l.__size_;
          }
          unint64_t v73 = size + 1;
          memset(&__str, 170, sizeof(__str));
          if (size + 1 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          if (v73 >= 0x17)
          {
            uint64_t v76 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v73 | 7) != 0x17) {
              uint64_t v76 = v73 | 7;
            }
            uint64_t v77 = v76 + 1;
            xpc_object_t v74 = (char *)operator new(v76 + 1);
            __str.__r_.__value_.__l.__size_ = size + 1;
            __str.__r_.__value_.__r.__words[2] = v77 | 0x8000000000000000;
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
            uint64_t v75 = v94;
          }
          else
          {
            memset(&__str, 0, sizeof(__str));
            xpc_object_t v74 = (char *)&__str;
            *((unsigned char *)&__str.__r_.__value_.__s + 23) = size + 1;
            uint64_t v75 = v94;
            if (!size) {
              goto LABEL_130;
            }
          }
          if (v71 >= 0) {
            size_t v78 = &v101;
          }
          else {
            size_t v78 = (std::string *)v101.__r_.__value_.__r.__words[0];
          }
          memmove(v74, v78, size);
LABEL_130:
          *(_WORD *)&v74[size] = 47;
          int v79 = (char)v14[23];
          if (v79 >= 0) {
            std::string v80 = (const std::string::value_type *)v14;
          }
          else {
            std::string v80 = *(const std::string::value_type **)v14;
          }
          if (v79 >= 0) {
            std::string::size_type v81 = v14[23];
          }
          else {
            std::string::size_type v81 = *((void *)v14 + 1);
          }
          dispatch_object_t v82 = std::string::append(&__str, v80, v81);
          long long v83 = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
          *(void *)&v118[0] = *((void *)&v82->__r_.__value_.__l + 2);
          *(_OWORD *)std::string buf = v83;
          v82->__r_.__value_.__l.__size_ = 0;
          v82->__r_.__value_.__r.__words[2] = 0;
          v82->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          abm::LogManagementTask::remove_sync(v75, (std::string::size_type)buf);
          if (SBYTE7(v118[0]) < 0) {
            operator delete(*(void **)buf);
          }
LABEL_145:
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
      }
      else
      {
        if (v20 != 1) {
          goto LABEL_44;
        }
        std::string::size_type v22 = v21 >= 0 ? v14 : *(unsigned __int8 **)v14;
        if (*v22 != 46) {
          goto LABEL_44;
        }
      }
      v14 += 24;
    }
    std::string v87 = (void *)v101.__r_.__value_.__r.__words[0];
    int v88 = SHIBYTE(v101.__r_.__value_.__r.__words[2]);
    memset(&v101, 0, sizeof(v101));
    if (v88 < 0) {
      operator delete(v87);
    }
    if (v95) {
      operator delete(v95);
    }
    if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v101.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    xpc_object_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) < 0) {
        a3 = *(void *)a3;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a3;
      _os_log_error_impl(&dword_1A609F000, v18, OS_LOG_TYPE_ERROR, "Timestamp not provided: %s", buf, 0xCu);
    }
  }
  if (*(void *)v104)
  {
    *(void *)&v104[8] = *(void *)v104;
    operator delete(*(void **)v104);
  }
  std::string v89 = (void **)v109;
  if (v109)
  {
    std::string v90 = v110;
    uint64_t v91 = v109;
    if (v110 != v109)
    {
      do
      {
        if (*((char *)v90 - 1) < 0) {
          operator delete(*(v90 - 3));
        }
        v90 -= 3;
      }
      while (v90 != v89);
      uint64_t v91 = v109;
    }
    uint64_t v110 = v89;
    operator delete(v91);
  }
}

void sub_1A6144D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,std::locale a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  __cxa_guard_abort(&qword_1EB5EE9D8);
  if (__p) {
    operator delete(__p);
  }
  std::vector<std::string>::~vector[abi:ne180100](&a65);
  _Unwind_Resume(a1);
}

void sub_1A6144E88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a73 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1A6144E40);
}

void ___ZN3abm17LogManagementTask9init_syncEv_block_invoke_30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  strlen(abm::trace::kMobileBasebandServicesFolder[0]);
  int directory = ctu::fs::create_directory();
  long long v7 = *(NSObject **)(v5 + 40);
  if (directory)
  {
    if (os_log_type_enabled(*(os_log_t *)(v5 + 40), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__pn_.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I BasebandServices folder created", (uint8_t *)&__p, 2u);
    }
    memset(&__p, 0, sizeof(__p));
    uint64_t v8 = abm::trace::kMobileBasebandServicesFolder[0] - 1;
    while (*++v8)
      ;
    std::string::append[abi:ne180100]<char const*,0>((unint64_t)&__p, abm::trace::kMobileBasebandServicesFolder[0], v8);
    std::__fs::filesystem::__permissions(&__p, all, add, 0);
    if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__pn_.__r_.__value_.__l.__data_);
    }
    xpc_object_t v10 = xpc_null_create();
    if (*(void *)a4) {
      uint64_t v11 = _Block_copy(*(const void **)a4);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v15 = *(NSObject **)(a4 + 8);
    __p.__pn_.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
    __p.__pn_.__r_.__value_.__l.__size_ = 3321888768;
    __p.__pn_.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
    xpc_object_t v18 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v11)
    {
      uint64_t v16 = _Block_copy(v11);
      int v21 = 0;
      aBlocuint64_t k = v16;
      xpc_object_t object = v10;
      if (v10)
      {
LABEL_28:
        xpc_retain(v10);
LABEL_31:
        dispatch_async(v15, &__p);
        xpc_release(object);
        xpc_object_t object = 0;
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v11) {
          _Block_release(v11);
        }
        goto LABEL_35;
      }
    }
    else
    {
      int v21 = 0;
      aBlocuint64_t k = 0;
      xpc_object_t object = v10;
      if (v10) {
        goto LABEL_28;
      }
    }
    xpc_object_t object = xpc_null_create();
    goto LABEL_31;
  }
  if (os_log_type_enabled(*(os_log_t *)(v5 + 40), OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__pn_.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Failed to create BasebandServices folder", (uint8_t *)&__p, 2u);
  }
  xpc_object_t v10 = xpc_null_create();
  if (*(void *)a4) {
    uint64_t v12 = _Block_copy(*(const void **)a4);
  }
  else {
    uint64_t v12 = 0;
  }
  size_t v13 = *(NSObject **)(a4 + 8);
  __p.__pn_.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
  __p.__pn_.__r_.__value_.__l.__size_ = 3321888768;
  __p.__pn_.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke;
  xpc_object_t v18 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v12)
  {
    int v21 = -534716416;
    aBlocuint64_t k = 0;
    xpc_object_t object = v10;
    if (v10) {
      goto LABEL_17;
    }
LABEL_19:
    xpc_object_t object = xpc_null_create();
    goto LABEL_20;
  }
  xpc_object_t v14 = _Block_copy(v12);
  int v21 = -534716416;
  aBlocuint64_t k = v14;
  xpc_object_t object = v10;
  if (!v10) {
    goto LABEL_19;
  }
LABEL_17:
  xpc_retain(v10);
LABEL_20:
  dispatch_async(v13, &__p);
  xpc_release(object);
  xpc_object_t object = 0;
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v12) {
    _Block_release(v12);
  }
LABEL_35:
  xpc_release(v10);
}

void sub_1A61451C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::LogManagementTask::cleanUpLogs(std::string,std::string)::$_0::~$_0(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0)
  {
    operator delete(*(void **)(a1 + 120));
    uint64_t v2 = *(void **)a1;
    if (!*(void *)a1) {
      return a1;
    }
    goto LABEL_3;
  }
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
LABEL_3:
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void *std::vector<abm::DirectoryQuery>::vector[abi:ne180100](void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >= 0x666666666666667) {
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = 40 * a3;
    long long v6 = (char *)operator new(40 * a3);
    uint64_t v7 = 0;
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[v5];
    uint64_t v8 = a2 + v5;
    do
    {
      uint64_t v10 = a2 + v7;
      *(_DWORD *)&v6[v7] = *(_DWORD *)(a2 + v7);
      uint64_t v11 = (std::string *)&v6[v7 + 8];
      uint64_t v12 = (const std::string::value_type **)(a2 + v7 + 8);
      if (*(char *)(a2 + v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v11, *v12, *(void *)(v10 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)v12;
        *(void *)&v6[v7 + 24] = *(void *)(a2 + v7 + 24);
        *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v9;
      }
      *(_DWORD *)&v6[v7 + 32] = *(_DWORD *)(v10 + 32);
      v7 += 40;
    }
    while (v10 + 40 != v8);
    a1[1] = &v6[v7];
  }
  return a1;
}

void sub_1A6145338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1A614534C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  for (; v11; v11 -= 40)
  {
    if (*(char *)(v10 + v11 - 9) < 0) {
      operator delete(*(void **)(v10 + v11 - 32));
    }
  }
  *(void *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<abm::DirectoryQuery>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ***std::__exception_guard_exceptions<std::vector<abm::DirectoryQuery>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***result)
{
  uint64_t v1 = result;
  if (!*((unsigned char *)result + 8))
  {
    uint64_t v2 = *result;
    uint64_t v3 = (void **)**result;
    if (v3)
    {
      BOOL v4 = (void **)v2[1];
      uint64_t v5 = **result;
      if (v4 != v3)
      {
        do
        {
          if (*((char *)v4 - 9) < 0) {
            operator delete(*(v4 - 4));
          }
          v4 -= 5;
        }
        while (v4 != v3);
        uint64_t v5 = **v1;
      }
      v2[1] = v3;
      operator delete(v5);
      return v1;
    }
  }
  return result;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__1ES2_EEEvDpT__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A6145488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

unint64_t std::string::append[abi:ne180100]<char const*,0>(unint64_t a1, char *__src, char *a3)
{
  int v6 = *(char *)(a1 + 23);
  size_t v7 = a3 - __src;
  if (v6 < 0)
  {
    if (a3 == __src) {
      return a1;
    }
    size_t v8 = *(void *)(a1 + 8);
    unint64_t v12 = *(void *)(a1 + 16);
    unint64_t v9 = (v12 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    uint64_t v11 = *(unsigned char **)a1;
    unint64_t v10 = HIBYTE(v12);
    if (*(void *)a1 > (unint64_t)__src) {
      goto LABEL_11;
    }
  }
  else
  {
    if (a3 == __src) {
      return a1;
    }
    size_t v8 = *(unsigned __int8 *)(a1 + 23);
    unint64_t v9 = 22;
    LOBYTE(v10) = *(unsigned char *)(a1 + 23);
    uint64_t v11 = (unsigned char *)a1;
    if (a1 > (unint64_t)__src)
    {
LABEL_11:
      if (v9 - v8 >= v7)
      {
        uint64_t v16 = (unsigned char *)a1;
        if ((v10 & 0x80) != 0)
        {
          uint64_t v16 = *(unsigned char **)a1;
          size_t v17 = (unsigned char *)(*(void *)a1 + v8);
          if (v7 >= 0x20) {
            goto LABEL_36;
          }
        }
        else
        {
          size_t v17 = (unsigned char *)(a1 + v8);
          if (v7 >= 0x20) {
            goto LABEL_36;
          }
        }
        goto LABEL_23;
      }
      size_t v14 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - v9 < v8 + v7 - v9) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = (unsigned char *)a1;
      if (v6 < 0)
      {
        uint64_t v15 = *(unsigned char **)a1;
        if (v9 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_15:
          uint64_t v16 = operator new(0x7FFFFFFFFFFFFFF7uLL);
          if (!v8) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }
      }
      else if (v9 > 0x3FFFFFFFFFFFFFF2)
      {
        goto LABEL_15;
      }
      unint64_t v30 = 2 * v9;
      if (v8 + v7 > 2 * v9) {
        unint64_t v30 = v8 + v7;
      }
      uint64_t v31 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17) {
        uint64_t v31 = v30 | 7;
      }
      if (v30 >= 0x17) {
        size_t v14 = v31 + 1;
      }
      else {
        size_t v14 = 23;
      }
      uint64_t v16 = operator new(v14);
      if (!v8)
      {
LABEL_17:
        if (v9 != 22) {
          operator delete(v15);
        }
        *(void *)(a1 + 8) = v8;
        *(void *)(a1 + 16) = v14 | 0x8000000000000000;
        *(void *)a1 = v16;
        size_t v17 = &v16[v8];
        if (v7 >= 0x20)
        {
LABEL_36:
          if ((unint64_t)(&v16[v8] - __src) >= 0x20)
          {
            xpc_object_t v18 = &__src[v7 & 0xFFFFFFFFFFFFFFE0];
            v17 += v7 & 0xFFFFFFFFFFFFFFE0;
            long long v23 = &v16[v8 + 16];
            long long v24 = (long long *)(__src + 16);
            unint64_t v25 = v7 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v26 = *v24;
              *(v23 - 1) = *(v24 - 1);
              *long long v23 = v26;
              v23 += 2;
              v24 += 2;
              v25 -= 32;
            }
            while (v25);
            if (v7 == (v7 & 0xFFFFFFFFFFFFFFE0)) {
              goto LABEL_42;
            }
          }
          else
          {
            xpc_object_t v18 = __src;
          }
          do
          {
LABEL_41:
            char v27 = *v18++;
            *v17++ = v27;
          }
          while (v18 != a3);
LABEL_42:
          unsigned char *v17 = 0;
          size_t v28 = v8 + v7;
          if (*(char *)(a1 + 23) < 0) {
            *(void *)(a1 + 8) = v28;
          }
          else {
            *(unsigned char *)(a1 + 23) = v28 & 0x7F;
          }
          return a1;
        }
LABEL_23:
        xpc_object_t v18 = __src;
        goto LABEL_41;
      }
LABEL_16:
      memmove(v16, v15, v8);
      goto LABEL_17;
    }
  }
  if (&v11[v8 + 1] <= __src) {
    goto LABEL_11;
  }
  memset(__dst, 170, sizeof(__dst));
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 > 0x16)
  {
    uint64_t v19 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v19 = v7 | 7;
    }
    uint64_t v20 = v19 + 1;
    size_t v13 = (void **)operator new(v19 + 1);
    __dst[1] = (void *)v7;
    _OWORD __dst[2] = (void *)(v20 | 0x8000000000000000);
    __dst[0] = v13;
  }
  else
  {
    HIBYTE(__dst[2]) = (_BYTE)a3 - (_BYTE)__src;
    size_t v13 = __dst;
  }
  memcpy(v13, __src, v7);
  *((unsigned char *)v13 + v7) = 0;
  if (SHIBYTE(__dst[2]) >= 0) {
    int v21 = (const std::string::value_type *)__dst;
  }
  else {
    int v21 = (const std::string::value_type *)__dst[0];
  }
  if (SHIBYTE(__dst[2]) >= 0) {
    std::string::size_type v22 = HIBYTE(__dst[2]);
  }
  else {
    std::string::size_type v22 = (std::string::size_type)__dst[1];
  }
  std::string::append((std::string *)a1, v21, v22);
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  return a1;
}

void sub_1A614579C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void dispatch::async<void ctu::SharedSynchronizable<abm::HelperTask>::execute_wrapped<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>(abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0,dispatch_queue_s *::default_delete<abm::LogManagementTask::markPurgeableLogs(CacheDeleteUrgency,__CFDictionary const*)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(uint64_t **)a1;
  uint64_t v63 = **(void **)a1;
  int v81 = 0;
  memset(&v80, 0, sizeof(v80));
  HIBYTE(v79) = 4;
  strcpy((char *)&__p, "Time");
  HIBYTE(v83) = 8;
  strcpy((char *)v82, "Settings");
  memset(&v71, 0, sizeof(v71));
  int v59 = v1;
  if (defaults::get((char *)v82, (char *)&__p, &v71))
  {
    prop::file::get<std::string>(v82, (uint64_t)&__p, (uint64_t)&v71, &v65);
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v80.__r_.__value_.__l.__data_);
    }
    std::string v80 = v65;
  }
  if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v83) & 0x80000000) == 0) {
      goto LABEL_7;
    }
LABEL_77:
    operator delete((void *)v82[0]);
    if ((SHIBYTE(v79) & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_78;
  }
  operator delete(v71.__r_.__value_.__l.__data_);
  if (SHIBYTE(v83) < 0) {
    goto LABEL_77;
  }
LABEL_7:
  if ((SHIBYTE(v79) & 0x80000000) == 0) {
    goto LABEL_8;
  }
LABEL_78:
  operator delete(__p);
LABEL_8:
  util::convert<unsigned int>(&v80, &v81, 0);
  v76.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v76.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v76, 0);
  uint64_t v2 = (char *)operator new(0x38uLL);
  *((_DWORD *)v2 + 8) = 0;
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = &v82[1];
  v82[0] = v2;
  v82[1] = v2;
  v2[24] = 1;
  uint64_t v83 = 1;
  *(timeval *)(v2 + 40) = v76;
  int v3 = v81;
  __darwin_time_t tv_sec = v76.tv_sec;
  uint64_t v5 = operator new(0x38uLL);
  int64_t v6 = (86400 * v3);
  v5[8] = 0;
  *(void *)uint64_t v5 = 0;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = &v78;
  std::__fs::filesystem::path __p = v5;
  size_t v78 = v5;
  *((unsigned char *)v5 + 24) = 1;
  uint64_t v79 = 1;
  *((void *)v5 + 5) = tv_sec - v6;
  *((void *)v5 + 6) = 0xAAAAAAAAAAAAAAAALL;
  size_t v7 = *(NSObject **)(v63 + 40);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_16;
  }
  Timestamp::asString((uint64_t)v82, 0, 9, &v71);
  int v8 = SHIBYTE(v71.__r_.__value_.__r.__words[2]);
  std::string::size_type v9 = v71.__r_.__value_.__r.__words[0];
  Timestamp::asString((uint64_t)&__p, 0, 9, &v65);
  unint64_t v10 = &v71;
  if (v8 < 0) {
    unint64_t v10 = (std::string *)v9;
  }
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v65;
  }
  else {
    uint64_t v11 = (std::string *)v65.__r_.__value_.__r.__words[0];
  }
  *(_DWORD *)std::string buf = 136315394;
  *(void *)&uint8_t buf[4] = v10;
  *(_WORD *)&buf[12] = 2080;
  *(void *)&buf[14] = v11;
  _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Now: %s. Searching files older than %s", buf, 0x16u);
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v65.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(v71.__r_.__value_.__l.__data_);
LABEL_16:
  memset(buf, 0, sizeof(buf));
  int64_t v62 = (86400 * v3);
  if (TelephonyUtilIsInternalBuild())
  {
    strlen(abm::trace::kSnapshotFolder[0]);
    goto LABEL_19;
  }
  int IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  size_t v13 = (const char **)abm::trace::kSnapshotFolder;
  strlen(abm::trace::kSnapshotFolder[0]);
  if (IsCarrierBuild)
  {
LABEL_19:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB5EE9E0))
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA40, "[^\\.].*([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2}).*\\.(?!json).*", 0);
      __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA40, &dword_1A609F000);
      __cxa_guard_release(&qword_1EB5EE9E0);
      int64_t v6 = (86400 * v3);
    }
    std::locale::locale((std::locale *)&v71, (const std::locale *)&unk_1EB5EEA40);
    *(_OWORD *)&v71.__r_.__value_.__r.__words[1] = unk_1EB5EEA48;
    long long v72 = unk_1EB5EEA58;
    uint64_t v73 = qword_1EB5EEA68;
    xpc_object_t v74 = (std::__shared_weak_count *)unk_1EB5EEA70;
    if (unk_1EB5EEA70) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(unk_1EB5EEA70 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v14 = 0x1EB5EE000uLL;
    uint64_t v75 = qword_1EB5EEA78;
    ctu::fs::get_filtered_files();
    uint64_t v15 = v74;
    if (!v74 || atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      std::locale::~locale((std::locale *)&v71);
      uint64_t v16 = *(long long **)buf;
      size_t v17 = *(long long **)&buf[8];
      if (*(void *)buf != *(void *)&buf[8]) {
        goto LABEL_30;
      }
      goto LABEL_127;
    }
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    std::locale::~locale((std::locale *)&v71);
    uint64_t v16 = *(long long **)buf;
    size_t v17 = *(long long **)&buf[8];
    if (*(void *)buf == *(void *)&buf[8]) {
      goto LABEL_127;
    }
    while (1)
    {
LABEL_30:
      if (*((char *)v16 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v70, *(const std::string::value_type **)v16, *((void *)v16 + 1));
      }
      else
      {
        long long v19 = *v16;
        v70.__r_.__value_.__r.__words[2] = *((void *)v16 + 2);
        *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v19;
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9E0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB5EE9E0))
      {
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA40, "[^\\.].*([[:digit:]]{4})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2})-([[:digit:]]{2}).*\\.(?!json).*", 0);
        __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA40, &dword_1A609F000);
        __cxa_guard_release(&qword_1EB5EE9E0);
        int64_t v6 = v62;
        unint64_t v14 = 0x1EB5EE000;
      }
      std::locale::locale((std::locale *)&v65, (const std::locale *)&unk_1EB5EEA40);
      *(_OWORD *)&v65.__r_.__value_.__r.__words[1] = unk_1EB5EEA48;
      long long v66 = unk_1EB5EEA58;
      uint64_t v67 = qword_1EB5EEA68;
      char v68 = (std::__shared_weak_count *)unk_1EB5EEA70;
      if (unk_1EB5EEA70) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(unk_1EB5EEA70 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v69 = *(void *)(v14 + 2680);
      BOOL v20 = util::checkLogFileAge((uint64_t)&v70, v6, (uint64_t)&v65);
      int v21 = v68;
      if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
        std::locale::~locale((std::locale *)&v65);
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_42:
          operator delete(v70.__r_.__value_.__l.__data_);
          if (!v20) {
            goto LABEL_29;
          }
          goto LABEL_43;
        }
      }
      else
      {
        std::locale::~locale((std::locale *)&v65);
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_42;
        }
      }
      if (!v20) {
        goto LABEL_29;
      }
LABEL_43:
      memset(&__dst, 170, sizeof(__dst));
      std::string::size_type v22 = abm::trace::kSnapshotFolder[0];
      size_t v23 = strlen(abm::trace::kSnapshotFolder[0]);
      int v24 = *((char *)v16 + 23);
      if (v24 >= 0) {
        size_t v25 = *((unsigned __int8 *)v16 + 23);
      }
      else {
        size_t v25 = *((void *)v16 + 1);
      }
      std::string::size_type v26 = v25 + v23;
      if (v25 + v23 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v27 = v23;
      if (v26 <= 0x16)
      {
        memset(&__dst, 0, sizeof(__dst));
        p_dst = &__dst;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v25 + v23;
        if (!v23) {
          goto LABEL_50;
        }
LABEL_49:
        memcpy(p_dst, v22, v27);
        goto LABEL_50;
      }
      uint64_t v31 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v26 | 7) != 0x17) {
        uint64_t v31 = v26 | 7;
      }
      uint64_t v32 = v31 + 1;
      p_dst = (std::string *)operator new(v31 + 1);
      __dst.__r_.__value_.__l.__size_ = v26;
      __dst.__r_.__value_.__r.__words[2] = v32 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      int64_t v6 = v62;
      if (v27) {
        goto LABEL_49;
      }
LABEL_50:
      uint64_t v29 = (char *)p_dst + v27;
      if (v25)
      {
        if (v24 >= 0) {
          unint64_t v30 = (const std::string::value_type *)v16;
        }
        else {
          unint64_t v30 = *(const std::string::value_type **)v16;
        }
        memmove(v29, v30, v25);
      }
      v29[v25] = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(&v86, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        unint64_t v14 = 0x1EB5EE000uLL;
      }
      else
      {
        std::string v86 = __dst;
        unint64_t v14 = 0x1EB5EE000;
      }
      BOOL v33 = util::markPurgeableFile((uint64_t *)&v86);
      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v86.__r_.__value_.__l.__data_);
        BOOL v34 = *(NSObject **)(v63 + 40);
        size_t v35 = v34;
        if (!v33)
        {
LABEL_67:
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v36 = &__dst;
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)unint64_t v84 = 136315138;
            char v85 = v36;
            _os_log_error_impl(&dword_1A609F000, v34, OS_LOG_TYPE_ERROR, "Failed to mark %s to be purgeable", v84, 0xCu);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_29;
            }
LABEL_69:
            operator delete(__dst.__r_.__value_.__l.__data_);
            goto LABEL_29;
          }
          goto LABEL_68;
        }
      }
      else
      {
        BOOL v34 = *(NSObject **)(v63 + 40);
        size_t v35 = v34;
        if (!v33) {
          goto LABEL_67;
        }
      }
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v18 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          xpc_object_t v18 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)unint64_t v84 = 136315138;
        char v85 = v18;
        _os_log_impl(&dword_1A609F000, v34, OS_LOG_TYPE_DEFAULT, "#I %s is marked to be purgeable", v84, 0xCu);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_29;
        }
        goto LABEL_69;
      }
LABEL_68:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_69;
      }
LABEL_29:
      uint64_t v16 = (long long *)((char *)v16 + 24);
      if (v16 == v17) {
        goto LABEL_126;
      }
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EE9D8))
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA00, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
    __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA00, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EE9D8);
  }
  std::locale::locale((std::locale *)&v71, (const std::locale *)&unk_1EB5EEA00);
  *(_OWORD *)&v71.__r_.__value_.__r.__words[1] = unk_1EB5EEA08;
  long long v72 = unk_1EB5EEA18;
  uint64_t v73 = qword_1EB5EEA28;
  xpc_object_t v74 = (std::__shared_weak_count *)unk_1EB5EEA30;
  if (unk_1EB5EEA30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(unk_1EB5EEA30 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v75 = qword_1EB5EEA38;
  ctu::fs::get_filtered_files();
  size_t v37 = v74;
  if (v74 && !atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    std::locale::~locale((std::locale *)&v71);
    uint64_t v16 = *(long long **)buf;
    unint64_t v61 = *(long long **)&buf[8];
    if (*(void *)buf == *(void *)&buf[8]) {
      goto LABEL_127;
    }
    while (1)
    {
LABEL_89:
      memset(&v70, 170, sizeof(v70));
      unsigned int v38 = *v13;
      size_t v39 = strlen(*v13);
      int v40 = *((char *)v16 + 23);
      if (v40 >= 0) {
        size_t v41 = *((unsigned __int8 *)v16 + 23);
      }
      else {
        size_t v41 = *((void *)v16 + 1);
      }
      std::string::size_type v42 = v41 + v39;
      if (v41 + v39 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v43 = v39;
      if (v42 <= 0x16) {
        break;
      }
      char v49 = v13;
      uint64_t v50 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v42 | 7) != 0x17) {
        uint64_t v50 = v42 | 7;
      }
      uint64_t v51 = v50 + 1;
      std::string::size_type v44 = (char *)operator new(v50 + 1);
      v70.__r_.__value_.__l.__size_ = v42;
      v70.__r_.__value_.__r.__words[2] = v51 | 0x8000000000000000;
      v70.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
      size_t v13 = v49;
      if (v43) {
        goto LABEL_95;
      }
LABEL_96:
      unint64_t v45 = &v44[v43];
      if (v41)
      {
        if (v40 >= 0) {
          long long v46 = (const std::string::value_type *)v16;
        }
        else {
          long long v46 = *(const std::string::value_type **)v16;
        }
        memmove(v45, v46, v41);
      }
      v45[v41] = 0;
      if (*((char *)v16 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)v16, *((void *)v16 + 1));
      }
      else
      {
        long long v47 = *v16;
        __dst.__r_.__value_.__r.__words[2] = *((void *)v16 + 2);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v47;
      }
      int64_t v48 = v62;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EE9D8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB5EE9D8))
      {
        std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&unk_1EB5EEA00, ".*([[:digit:]]{4}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).([[:digit:]]{2}).*", 0);
        __cxa_atexit((void (*)(void *))std::basic_regex<char,std::regex_traits<char>>::~basic_regex, &unk_1EB5EEA00, &dword_1A609F000);
        __cxa_guard_release(&qword_1EB5EE9D8);
        int64_t v48 = v62;
      }
      std::locale::locale((std::locale *)&v65, (const std::locale *)&unk_1EB5EEA00);
      *(_OWORD *)&v65.__r_.__value_.__r.__words[1] = unk_1EB5EEA08;
      long long v66 = unk_1EB5EEA18;
      uint64_t v67 = qword_1EB5EEA28;
      char v68 = (std::__shared_weak_count *)unk_1EB5EEA30;
      if (unk_1EB5EEA30) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(unk_1EB5EEA30 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v69 = qword_1EB5EEA38;
      BOOL v52 = util::checkLogFileAge((uint64_t)&__dst, v48, (uint64_t)&v65);
      BOOL v53 = v68;
      if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
        std::locale::~locale((std::locale *)&v65);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_114:
          if (v52) {
            goto LABEL_120;
          }
          goto LABEL_87;
        }
      }
      else
      {
        std::locale::~locale((std::locale *)&v65);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_114;
        }
      }
      operator delete(__dst.__r_.__value_.__l.__data_);
      if (v52)
      {
LABEL_120:
        std::string v54 = *(NSObject **)(v63 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v55 = &v70;
          if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v55 = (std::string *)v70.__r_.__value_.__r.__words[0];
          }
          LODWORD(v86.__r_.__value_.__l.__data_) = 67109378;
          HIDWORD(v86.__r_.__value_.__r.__words[0]) = v81;
          LOWORD(v86.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v86.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v55;
          _os_log_impl(&dword_1A609F000, v54, OS_LOG_TYPE_DEFAULT, "#I Removing log files older than %u days: %s ", (uint8_t *)&v86, 0x12u);
        }
        abm::LogManagementTask::remove_sync(v63, (std::string::size_type)&v70);
      }
LABEL_87:
      if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v70.__r_.__value_.__l.__data_);
        uint64_t v16 = (long long *)((char *)v16 + 24);
        if (v16 == v61)
        {
LABEL_126:
          uint64_t v16 = *(long long **)buf;
          goto LABEL_127;
        }
      }
      else
      {
        uint64_t v16 = (long long *)((char *)v16 + 24);
        if (v16 == v61) {
          goto LABEL_126;
        }
      }
    }
    memset(&v70, 0, sizeof(v70));
    std::string::size_type v44 = (char *)&v70;
    *((unsigned char *)&v70.__r_.__value_.__s + 23) = v41 + v39;
    if (!v39) {
      goto LABEL_96;
    }
LABEL_95:
    memcpy(v44, v38, v43);
    goto LABEL_96;
  }
  std::locale::~locale((std::locale *)&v71);
  uint64_t v16 = *(long long **)buf;
  unint64_t v61 = *(long long **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8]) {
    goto LABEL_89;
  }
LABEL_127:
  if (v16)
  {
    uint64_t v56 = *(long long **)&buf[8];
    uint64_t v57 = v16;
    if (*(long long **)&buf[8] != v16)
    {
      do
      {
        if (*((char *)v56 - 1) < 0) {
          operator delete(*((void **)v56 - 3));
        }
        uint64_t v56 = (long long *)((char *)v56 - 24);
      }
      while (v56 != v16);
      uint64_t v57 = *(long long **)buf;
    }
    *(void *)&uint8_t buf[8] = v16;
    operator delete(v57);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&__p, v78);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v82, (void *)v82[1]);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v80.__r_.__value_.__l.__data_);
  }
  operator delete(v59);
  std::string::size_type v58 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
    std::__shared_weak_count::__release_weak(v58);
  }
  operator delete(a1);
}

void sub_1A6146528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,std::locale a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,std::locale a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,void *a54,int a55,__int16 a56,char a57,char a58)
{
  __cxa_guard_abort(&qword_1EB5EE9D8);
  uint64_t v62 = *(void *)(v58 - 128);
  if (v62)
  {
    uint64_t v63 = *(void *)(v58 - 120);
    unint64_t v64 = *(void **)(v58 - 128);
    if (v63 != v62)
    {
      do
      {
        if (*(char *)(v63 - 1) < 0) {
          operator delete(*(void **)(v63 - 24));
        }
        v63 -= 24;
      }
      while (v63 != v62);
      unint64_t v64 = *(void **)(v58 - 128);
    }
    *(void *)(v58 - 120) = v62;
    operator delete(v64);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a53, a54);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v58 - 200, *(void **)(v58 - 192));
  if (*(char *)(v58 - 217) < 0)
  {
    operator delete(*(void **)(v58 - 240));
    operator delete(__p);
    uint64_t v60 = a12;
    unint64_t v61 = (std::__shared_weak_count *)a12[2];
    if (!v61) {
      goto LABEL_16;
    }
  }
  else
  {
    operator delete(__p);
    uint64_t v60 = a12;
    unint64_t v61 = (std::__shared_weak_count *)a12[2];
    if (!v61) {
      goto LABEL_16;
    }
  }
  if (!atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
    std::__shared_weak_count::__release_weak(v61);
  }
LABEL_16:
  operator delete(v60);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_31()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t abm::asString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      a2[23] = 2;
      strcpy(a2, "UI");
      break;
    case 1:
      a2[23] = 7;
      strcpy(a2, "ABMtool");
      break;
    case 2:
      a2[23] = 7;
      strcpy(a2, "Profile");
      break;
    case 3:
      a2[23] = 10;
      strcpy(a2, "24hr_Timer");
      break;
    default:
      a2[23] = 11;
      strcpy(a2, "UnSpecified");
      break;
  }
  return result;
}

{
  if (result == 1)
  {
    a2[23] = 9;
    strcpy(a2, "Last_Used");
  }
  else if (result)
  {
    a2[23] = 11;
    strcpy(a2, "UnSpecified");
  }
  else
  {
    a2[23] = 7;
    strcpy(a2, "Default");
  }
  return result;
}

{
  if (result == 1)
  {
    a2[23] = 4;
    strcpy(a2, "lite");
  }
  else if (result)
  {
    a2[23] = 3;
    *(_DWORD *)a2 = 4144959;
  }
  else
  {
    a2[23] = 4;
    strcpy(a2, "main");
  }
  return result;
}

void INTTrace::createInternal(INTTrace **a1@<X8>)
{
  int v3 = (INTTrace *)operator new(0x170uLL);
  INTTrace::INTTrace(v3);
  BOOL v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C5D0;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  int64_t v6 = (std::__shared_weak_count *)*((void *)v3 + 10);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *((void *)v3 + 9) = v3;
      *((void *)v3 + 10) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_6;
      }
    }
  }
  else
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *((void *)v3 + 9) = v3;
    *((void *)v3 + 10) = v4;
    if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_6:
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync((uint64_t)v3);
  *a1 = v3;
  a1[1] = (INTTrace *)v4;
}

void sub_1A6146B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A6146B88(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace*)#1}::operator() const(INTTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A6146BB0(_Unwind_Exception *a1)
{
}

void sub_1A6146BC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void INTTrace::INTTrace(INTTrace *this)
{
  char v13 = 8;
  strcpy((char *)__p, "trace.bb");
  uint64_t v2 = (capabilities::trace *)Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this = &unk_1EFB0C440;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 160) = 0;
  int v3 = (capabilities::trace *)capabilities::trace::defaultHistorySizeMB(v2);
  *((_DWORD *)this + 42) = v3;
  BOOL v4 = (capabilities::radio *)capabilities::trace::defaultFileSizeBytes(v3);
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 22) = v4;
  *((unsigned char *)this + 207) = 0;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((unsigned char *)this + 248) = 0;
  uint64_t v5 = (capabilities::abs *)capabilities::radio::vendor(v4);
  int shouldUseMinBasebandTransportIOReadSize = (capabilities::radio *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v5);
  if (shouldUseMinBasebandTransportIOReadSize) {
    int v7 = 0x4000;
  }
  else {
    int v7 = 0x8000;
  }
  *((_DWORD *)this + 63) = v7;
  int v8 = (capabilities::abs *)capabilities::radio::vendor(shouldUseMinBasebandTransportIOReadSize);
  if ((v8 - 1) > 2) {
    int v9 = 23;
  }
  else {
    int v9 = dword_1A61F98A4[(int)v8 - 1];
  }
  uint64_t shouldUseMinBasebandTransportIOReadCount = (capabilities::trace *)capabilities::abs::shouldUseMinBasebandTransportIOReadCount(v8);
  if (shouldUseMinBasebandTransportIOReadCount) {
    goto LABEL_10;
  }
  if (v9 == 2)
  {
    int v11 = 16;
    goto LABEL_16;
  }
  if (v9 == 16 || v9 == 15) {
    int v11 = 36;
  }
  else {
LABEL_10:
  }
    int v11 = 4;
LABEL_16:
  *((_DWORD *)this + 64) = v11;
  *((unsigned char *)this + 260) = 0;
  *((_DWORD *)this + 66) = capabilities::trace::defaultSleepTraceMode(shouldUseMinBasebandTransportIOReadCount);
  *(_WORD *)((char *)this + 295) = 0;
  *((unsigned char *)this + 272) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((unsigned char *)this + 352) = 0;
  *((_DWORD *)this + 89) = 1;
  *((unsigned char *)this + 360) = 0;
}

void sub_1A6146D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::init(void *a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  unsigned __int8 v25 = 0;
  v20[0] = &v25;
  v20[1] = a1;
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    std::string __p = *(std::string *)a2;
    int v7 = a1 + 9;
    int v8 = (std::__shared_weak_count *)a3[1];
    uint64_t v22 = *a3;
    size_t v23 = v8;
    if (!v8) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  int v7 = a1 + 9;
  int v8 = (std::__shared_weak_count *)a3[1];
  uint64_t v22 = *a3;
  size_t v23 = v8;
  if (v8) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  int v9 = *a4;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke;
  block[3] = &__block_descriptor_tmp_90_1;
  void block[4] = v7;
  void block[5] = v20;
  unint64_t v10 = a1[11];
  if (a1[12])
  {
    dispatch_async_and_wait(v10, block);
    int v11 = object;
    if (!object) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  dispatch_sync(v10, block);
  int v11 = object;
  if (object) {
LABEL_8:
  }
    dispatch_release(v11);
LABEL_9:
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unint64_t v12 = (std::__shared_weak_count *)a1[10];
  if (!v12 || (uint64_t v13 = a1[9], (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v15 = v14;
  uint64_t v16 = operator new(8uLL);
  void *v16 = a1;
  size_t v17 = a1[11];
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  xpc_object_t v18 = operator new(0x18uLL);
  *xpc_object_t v18 = v16;
  v18[1] = v13;
  v18[2] = v15;
  dispatch_async_f(v17, v18, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>(INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1,std::default_delete<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  return v25;
}

void INTTrace::~INTTrace(INTTrace *this)
{
  *(void *)this = &unk_1EFB0C440;
  uint64_t v2 = (char *)dispatch_group_create();
  int v3 = v2;
  uint64_t v4 = *((void *)this + 29);
  if (v4)
  {
    v13.gr_passwd = v2;
    if (v2) {
      dispatch_retain((dispatch_object_t)v2);
    }
    (*(void (**)(uint64_t, char **))(*(void *)v4 + 144))(v4, &v13.gr_passwd);
    if (v13.gr_passwd) {
      dispatch_release((dispatch_object_t)v13.gr_passwd);
    }
  }
  v13.gr_name = v3;
  if (v3) {
    dispatch_retain((dispatch_object_t)v3);
  }
  INTTrace::stop_sync(this, &v13);
  if (v3) {
    dispatch_release((dispatch_object_t)v3);
  }
  dispatch_time_t v5 = dispatch_time(0, 1000000000);
  if (dispatch_group_wait((dispatch_group_t)v3, v5))
  {
    int64_t v6 = *((void *)this + 5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v12 = 0;
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Timeout for stopping trace service!", v12, 2u);
      *((unsigned char *)this + 160) = 0;
      if (!v3) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }
  *((unsigned char *)this + 160) = 0;
  if (v3) {
LABEL_13:
  }
    dispatch_release((dispatch_object_t)v3);
LABEL_14:
  int v7 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  int v8 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  int v9 = (std::__shared_weak_count *)*((void *)this + 39);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((*((char *)this + 295) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  if (*((char *)this + 295) < 0) {
LABEL_23:
  }
    operator delete(*((void **)this + 34));
LABEL_24:
  unint64_t v10 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  int v11 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    if ((*((char *)this + 207) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (*((char *)this + 207) < 0) {
LABEL_30:
  }
    operator delete(*((void **)this + 23));
LABEL_31:
  Trace::~Trace(this);
}

{
  void *v1;
  uint64_t vars8;

  INTTrace::~INTTrace(this);

  operator delete(v1);
}

void INTTrace::stop_sync(INTTrace *this, group *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping BB Trace", buf, 2u);
  }
  if (!*((void *)this + 38)) {
    goto LABEL_5;
  }
  char v43 = 0;
  LOBYTE(v42) = 0;
  Timestamp::Timestamp((Timestamp *)v40);
  char v39 = 0;
  LOWORD(v38) = 0;
  LOBYTE(v37) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v40, v41);
  if (v43 < 0)
  {
    operator delete(v42);
    if (!*((void *)this + 40)) {
      goto LABEL_9;
    }
  }
  else
  {
LABEL_5:
    if (!*((void *)this + 40)) {
      goto LABEL_9;
    }
  }
  char v36 = 0;
  LOBYTE(v35) = 0;
  Timestamp::Timestamp((Timestamp *)v33);
  char v32 = 0;
  LOBYTE(v31) = 0;
  char v30 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v33, v34);
  if (v36 < 0) {
    operator delete(v35);
  }
LABEL_9:
  if (*((char *)this + 207) < 0)
  {
    if (!*((void *)this + 24)) {
      goto LABEL_24;
    }
  }
  else if (!*((unsigned char *)this + 207))
  {
    goto LABEL_24;
  }
  uint64_t v5 = *((void *)this + 29);
  if (!v5 || !(*(unsigned int (**)(uint64_t))(*(void *)v5 + 152))(v5))
  {
LABEL_24:
    unint64_t v12 = *((void *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      int v9 = "#I Skip the configuration for the trace";
      unint64_t v10 = v12;
      uint32_t v11 = 2;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  gr_name = a2->gr_name;
  size_t v28 = gr_name;
  if (gr_name) {
    dispatch_retain((dispatch_object_t)gr_name);
  }
  char v27 = 4;
  strcpy((char *)v26, "Stop");
  char v7 = INTTrace::sendConfig_sync((uint64_t)this, (dispatch_object_t *)&v28, (const std::string::value_type *)v26, 0, 0, 1);
  if (v27 < 0) {
    operator delete(v26[0]);
  }
  if (gr_name) {
    dispatch_release((dispatch_object_t)gr_name);
  }
  int v8 = *((void *)this + 5);
  if (v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      unint64_t v45 = "Stop";
      int v9 = "#I Succeeded sending config: %s";
      unint64_t v10 = v8;
      uint32_t v11 = 12;
LABEL_26:
      _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
    }
  }
  else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 136315138;
    unint64_t v45 = "Stop";
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to send config: %s", buf, 0xCu);
  }
LABEL_27:
  INTTrace::stopReader_sync(this);
  group v13 = (std::__shared_weak_count *)*((void *)this + 30);
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    *((unsigned char *)this + 260) = 0;
    if (!*((void *)this + 38)) {
      goto LABEL_33;
    }
  }
  else
  {
    *((unsigned char *)this + 260) = 0;
    if (!*((void *)this + 38)) {
      goto LABEL_33;
    }
  }
  char v25 = 0;
  LOBYTE(v24) = 0;
  Timestamp::Timestamp((Timestamp *)v22);
  char v21 = 0;
  LOBYTE(v20) = 0;
  char v19 = 0;
  LOBYTE(v18) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v22, v23);
  if (v25 < 0) {
    operator delete(v24);
  }
LABEL_33:
  if (*((void *)this + 40))
  {
    char v17 = 0;
    LOBYTE(v16) = 0;
    Timestamp::Timestamp((Timestamp *)v14);
    abm::trace::TraceInfo::push();
    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v14, v15);
    if (v17 < 0) {
      operator delete(v16);
    }
  }
}

void sub_1A61477C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (v38)
  {
    dispatch_release(v38);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

const char *INTTrace::getName(INTTrace *this)
{
  return "trace.bb";
}

void INTTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 15;
  strcpy(a1, "BasebandTrace::");
}

void INTTrace::reinit(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl(&dword_1A609F000, v1, OS_LOG_TYPE_DEFAULT, "#I Not implemented yet: reinit", v2, 2u);
  }
}

void INTTrace::prepare(void *a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (!v4 || (uint64_t v5 = a1[9], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  char v7 = v6;
  int v8 = operator new(0x10uLL);
  void *v8 = v3;
  v8[1] = a1;
  int v9 = a1[11];
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = v8;
  v10[1] = v5;
  uint64_t v10[2] = v7;
  dispatch_async_f(v9, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v3) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!v3) {
      return;
    }
  }
  dispatch_group_leave(v3);

  dispatch_release(v3);
}

void INTTrace::start(void *a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_object_t v5 = *a2;
    if (*a2) {
      dispatch_retain(*a2);
    }
  }
  else
  {
    dispatch_object_t v5 = 0;
  }
  int64_t v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (uint64_t v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v9 = v8;
  unint64_t v10 = operator new(0x10uLL);
  *unint64_t v10 = a1;
  v10[1] = v5;
  uint32_t v11 = a1[11];
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v12 = operator new(0x18uLL);
  *unint64_t v12 = v10;
  v12[1] = v7;
  _DWORD v12[2] = v9;
  dispatch_async_f(v11, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v3) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v3) {
      return;
    }
  }
  dispatch_group_leave(v3);

  dispatch_release(v3);
}

void INTTrace::stop(void *a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_object_t v5 = *a2;
    if (*a2) {
      dispatch_retain(*a2);
    }
  }
  else
  {
    dispatch_object_t v5 = 0;
  }
  int64_t v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (uint64_t v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v9 = v8;
  unint64_t v10 = operator new(0x10uLL);
  *unint64_t v10 = a1;
  v10[1] = v5;
  uint32_t v11 = a1[11];
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v12 = operator new(0x18uLL);
  *unint64_t v12 = v10;
  v12[1] = v7;
  _DWORD v12[2] = v9;
  dispatch_async_f(v11, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v3) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v3) {
      return;
    }
  }
  dispatch_group_leave(v3);

  dispatch_release(v3);
}

void INTTrace::abort(void *a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_object_t v5 = *a2;
    if (*a2) {
      dispatch_retain(*a2);
    }
  }
  else
  {
    dispatch_object_t v5 = 0;
  }
  int64_t v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (uint64_t v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v9 = v8;
  unint64_t v10 = operator new(0x10uLL);
  *unint64_t v10 = a1;
  v10[1] = v5;
  uint32_t v11 = a1[11];
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v12 = operator new(0x18uLL);
  *unint64_t v12 = v10;
  v12[1] = v7;
  _DWORD v12[2] = v9;
  dispatch_async_f(v11, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v3) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v3) {
      return;
    }
  }
  dispatch_group_leave(v3);

  dispatch_release(v3);
}

void INTTrace::shutdown(void *a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    dispatch_retain(v3);
    dispatch_group_enter(v3);
    dispatch_object_t v5 = *a2;
    if (*a2) {
      dispatch_retain(*a2);
    }
  }
  else
  {
    dispatch_object_t v5 = 0;
  }
  int64_t v6 = (std::__shared_weak_count *)a1[10];
  if (!v6 || (uint64_t v7 = a1[9], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  int v9 = v8;
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = v3;
  v10[1] = a1;
  uint64_t v10[2] = v5;
  uint32_t v11 = a1[11];
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v12 = operator new(0x18uLL);
  *unint64_t v12 = v10;
  v12[1] = v7;
  _DWORD v12[2] = v9;
  dispatch_async_f(v11, v12, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v3) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v3) {
      return;
    }
  }
  dispatch_group_leave(v3);

  dispatch_release(v3);
}

void INTTrace::enterLowPower(INTTrace *this, group *a2)
{
  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v4 || (uint64_t v5 = *((void *)this + 9), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  int v8 = operator new(0x10uLL);
  void *v8 = gr_name;
  v8[1] = this;
  int v9 = *((void *)this + 11);
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = v8;
  v10[1] = v5;
  uint64_t v10[2] = v7;
  dispatch_async_f(v9, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::enterLowPower(dispatch::group)::$_0>(INTTrace::enterLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::enterLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::enterLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!gr_name) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!gr_name) {
      return;
    }
  }
  dispatch_group_leave((dispatch_group_t)gr_name);

  dispatch_release((dispatch_object_t)gr_name);
}

void INTTrace::exitLowPower(INTTrace *this, group *a2)
{
  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v4 || (uint64_t v5 = *((void *)this + 9), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v7 = v6;
  int v8 = operator new(0x10uLL);
  void *v8 = gr_name;
  v8[1] = this;
  int v9 = *((void *)this + 11);
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = v8;
  v10[1] = v5;
  uint64_t v10[2] = v7;
  dispatch_async_f(v9, v10, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::exitLowPower(dispatch::group)::$_0>(INTTrace::exitLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::exitLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::exitLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!gr_name) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    if (!gr_name) {
      return;
    }
  }
  dispatch_group_leave((dispatch_group_t)gr_name);

  dispatch_release((dispatch_object_t)gr_name);
}

uint64_t INTTrace::snapshot(NSObject *a1, NSObject **a2, const __CFDictionary **a3)
{
  isa = a1[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl(&dword_1A609F000, isa, OS_LOG_TYPE_DEFAULT, "#I Snapshotting!", (uint8_t *)group, 2u);
  }
  v25[0] = 0xAAAAAAAAAAAAAAAALL;
  v25[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v25, *a3);
  memset(&v24, 170, sizeof(v24));
  group[0] = 0;
  group[1] = 0;
  __p.__r_.__value_.__r.__words[0] = 0;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v26, "kKeyTraceDumpStateReason");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v26);
  if (__p.__r_.__value_.__s.__data_[7] < 0)
  {
    operator delete(group[0]);
    uint64_t v7 = *a2;
    if (v7)
    {
LABEL_5:
      dispatch_retain(v7);
      dispatch_group_enter(v7);
      group[0] = v7;
      dispatch_retain(v7);
      if (group[0]) {
        dispatch_group_enter(group[0]);
      }
      group[1] = a1;
      if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v7 = *a2;
    if (v7) {
      goto LABEL_5;
    }
  }
  group[0] = 0;
  group[1] = a1;
  if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_8:
    std::string __p = v24;
    goto LABEL_12;
  }
LABEL_11:
  std::string::__init_copy_ctor_external(&__p, v24.__r_.__value_.__l.__data_, v24.__r_.__value_.__l.__size_);
LABEL_12:
  CFDictionaryRef v8 = *a3;
  CFTypeRef cf = v8;
  if (v8) {
    CFRetain(v8);
  }
  int v9 = (std::__shared_weak_count *)a1[10].isa;
  if (!v9 || (Class v10 = a1[9].isa, (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  unint64_t v12 = v11;
  group v13 = operator new(0x30uLL);
  long long v14 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *group v13 = *(_OWORD *)group;
  v13[1] = v14;
  std::string::size_type v15 = __p.__r_.__value_.__r.__words[2];
  memset(&__p, 0, sizeof(__p));
  CFTypeRef v16 = cf;
  *((void *)v13 + 4) = v15;
  *((void *)v13 + 5) = v16;
  group[0] = 0;
  CFTypeRef cf = 0;
  char v17 = a1[11].isa;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  xpc_object_t v18 = operator new(0x18uLL);
  *xpc_object_t v18 = v13;
  v18[1] = v10;
  v18[2] = v12;
  dispatch_async_f(v17, v18, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    CFTypeRef v19 = cf;
    if (!cf) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  CFTypeRef v19 = cf;
  if (cf) {
LABEL_20:
  }
    CFRelease(v19);
LABEL_21:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (group[0])
  {
    dispatch_group_leave(group[0]);
    if (group[0]) {
      dispatch_release(group[0]);
    }
  }
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  return MEMORY[0x1A6274930](v25);
}

void sub_1A61485D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (v24)
  {
    dispatch_group_leave(v24);
    dispatch_release(v24);
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  MEMORY[0x1A6274930](&a24);
  _Unwind_Resume(a1);
}

void INTTrace::dumpState(void *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    uint64_t v4 = (std::__shared_weak_count *)a1[10];
    if (!v4) {
      goto LABEL_14;
    }
  }
  else
  {
    std::string __p = *(std::string *)a3;
    uint64_t v4 = (std::__shared_weak_count *)a1[10];
    if (!v4) {
LABEL_14:
    }
      std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v5 = a1[9];
  int64_t v6 = std::__shared_weak_count::lock(v4);
  if (!v6) {
    goto LABEL_14;
  }
  uint64_t v7 = v6;
  CFDictionaryRef v8 = operator new(0x20uLL);
  void *v8 = a1;
  int v9 = (std::string *)(v8 + 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v9, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v8[3] = *((void *)&__p.__r_.__value_.__l + 2);
  }
  Class v10 = a1[11];
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  uint32_t v11 = operator new(0x18uLL);
  *uint32_t v11 = v8;
  v11[1] = v5;
  void v11[2] = v7;
  dispatch_async_f(v10, v11, (dispatch_function_t)dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::dumpState(dispatch::group,std::string)::$_0>(INTTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<INTTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke);
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_13:
    operator delete(__p.__r_.__value_.__l.__data_);
    return;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_13;
  }
}

BOOL INTTrace::setProperty(void *a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v8 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v8);
    unsigned __int8 v16 = 0;
    *(void *)std::string buf = &v16;
    *(void *)&uint8_t buf[8] = v8;
    dispatch_retain(v8);
    if (*(void *)&buf[8]) {
      dispatch_group_enter(*(dispatch_group_t *)&buf[8]);
    }
    if ((*(char *)(a3 + 23) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    unsigned __int8 v16 = 0;
    *(void *)std::string buf = &v16;
    *(void *)&uint8_t buf[8] = 0;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0)
    {
LABEL_5:
      *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)a3;
      uint64_t v19 = *(void *)(a3 + 16);
      goto LABEL_8;
    }
  }
  std::string::__init_copy_ctor_external((std::string *)&buf[16], *(const std::string::value_type **)a3, *(void *)(a3 + 8));
LABEL_8:
  int v9 = *a2;
  BOOL v20 = a1;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __p = *(std::string *)a4;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke;
  block[3] = &__block_descriptor_tmp_94;
  void block[4] = a1 + 9;
  void block[5] = buf;
  Class v10 = a1[11];
  if (a1[12])
  {
    dispatch_async_and_wait(v10, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  dispatch_sync(v10, block);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_15:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_16:
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(*(void **)&buf[16]);
  }
  if (*(void *)&buf[8])
  {
    dispatch_group_leave(*(dispatch_group_t *)&buf[8]);
    if (*(void *)&buf[8]) {
      dispatch_release(*(dispatch_object_t *)&buf[8]);
    }
  }
  if (v16)
  {
    int v11 = 1;
    if (!v8) {
      return v11 != 0;
    }
    goto LABEL_30;
  }
  unint64_t v12 = a1[5];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a3 + 23) >= 0) {
      long long v14 = (const std::string::value_type *)a3;
    }
    else {
      long long v14 = *(const std::string::value_type **)a3;
    }
    if (*(char *)(a4 + 23) >= 0) {
      std::string::size_type v15 = (const std::string::value_type *)a4;
    }
    else {
      std::string::size_type v15 = *(const std::string::value_type **)a4;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v15;
    _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Setting %s to %s failed", buf, 0x16u);
    int v11 = v16;
    if (v8) {
      goto LABEL_30;
    }
  }
  else
  {
    int v11 = 0;
    if (v8)
    {
LABEL_30:
      dispatch_group_leave(v8);
      dispatch_release(v8);
    }
  }
  return v11 != 0;
}

void sub_1A6148A6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_group_t group, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,dispatch_object_t object)
{
  if (object)
  {
    dispatch_release(object);
    if ((a24 & 0x80000000) == 0)
    {
LABEL_3:
      size_t v28 = group;
      if (!group)
      {
LABEL_8:
        if (v26)
        {
          dispatch_group_leave(v26);
          dispatch_release(v26);
        }
        _Unwind_Resume(exception_object);
      }
LABEL_7:
      dispatch_group_leave(v28);
      dispatch_release(group);
      goto LABEL_8;
    }
  }
  else if ((a24 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(__p);
  size_t v28 = group;
  if (!group) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t INTTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v10 = 1;
  uint64_t v4 = a1 + 72;
  v7[0] = &v10;
  v7[1] = a3;
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  uint64_t v9 = a1;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke;
  block[3] = &__block_descriptor_tmp_96;
  void block[4] = v4;
  void block[5] = v7;
  uint64_t v5 = *(NSObject **)(a1 + 88);
  if (*(void *)(a1 + 96))
  {
    dispatch_async_and_wait(v5, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v10;
    }
  }
  else
  {
    dispatch_sync(v5, block);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v10;
    }
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  return v10;
}

void INTTrace::initBootSessionPrefs_sync(INTTrace *this)
{
  HIBYTE(v19[2]) = 15;
  strcpy((char *)v19, "Reset_Mode_Boot");
  memset(&__p, 0, sizeof(__p));
  *((unsigned char *)&v21.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v21, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  uint64_t v2 = defaults::get((char *)&v21, (char *)v19, &buf);
  int v3 = v2;
  if (v2)
  {
    prop::file::get<std::string>((const void **)&v21.__r_.__value_.__l.__data_, (uint64_t)v19, (uint64_t)&buf, &v22);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      if (!v3) {
        goto LABEL_13;
      }
      goto LABEL_11;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (!v3) {
    goto LABEL_13;
  }
LABEL_11:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  uint64_t v2 = util::convert<int>(&__p, &buf, 0);
  if (v2) {
    *((_DWORD *)this + 39) = buf.__r_.__value_.__l.__data_;
  }
LABEL_13:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v19[2]) & 0x80000000) == 0) {
      goto LABEL_15;
    }
LABEL_18:
    operator delete(v19[0]);
    if (!sys::isBootSessionChanged(v4)) {
      goto LABEL_20;
    }
LABEL_19:
    if (*((_DWORD *)this + 39)) {
      goto LABEL_20;
    }
    unint64_t v12 = *((void *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I AP reboot detected, resetting trace properties", (uint8_t *)&buf, 2u);
    }
    *((unsigned char *)&v22.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&v22, "Mode");
    memset(&v21, 0, sizeof(v21));
    std::to_string(&buf, 0);
    std::string v21 = buf;
    char v13 = prop::bbtrace::set((char *)&v22, (const char *)&v21);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v21.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_79:
        if (v13) {
          goto LABEL_85;
        }
        goto LABEL_83;
      }
    }
    else if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_79;
    }
    operator delete(v22.__r_.__value_.__l.__data_);
    if (v13) {
      goto LABEL_85;
    }
LABEL_83:
    long long v14 = *((void *)this + 5);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "Failed to reset trace mode for new boot instance", (uint8_t *)&buf, 2u);
    }
LABEL_85:
    *((_DWORD *)this + 38) = 0;
    *((unsigned char *)&v22.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&v22, "TraceOwnership");
    memset(&v21, 0, sizeof(v21));
    std::to_string(&buf, 0);
    std::string v21 = buf;
    char v15 = prop::bbtrace::set((char *)&v22, (const char *)&v21);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v21.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_87:
        if (v15) {
          goto LABEL_93;
        }
        goto LABEL_91;
      }
    }
    else if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_87;
    }
    operator delete(v22.__r_.__value_.__l.__data_);
    if (v15) {
      goto LABEL_93;
    }
LABEL_91:
    unsigned __int8 v16 = *((void *)this + 5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v16, OS_LOG_TYPE_ERROR, "Failed to reset trace transport owner id for new boot instance", (uint8_t *)&buf, 2u);
    }
LABEL_93:
    *((_DWORD *)this + 52) = 0;
    *((unsigned char *)&v22.__r_.__value_.__s + 23) = 19;
    strcpy((char *)&v22, "Live_Filter_Setting");
    memset(&v21, 0, sizeof(v21));
    std::to_string(&buf, 0);
    std::string v21 = buf;
    char v17 = prop::bbtrace::set((char *)&v22, (const char *)&v21);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v21.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_95:
        if (v17) {
          goto LABEL_101;
        }
        goto LABEL_99;
      }
    }
    else if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_95;
    }
    operator delete(v22.__r_.__value_.__l.__data_);
    if (v17)
    {
LABEL_101:
      *((_DWORD *)this + 43) = 0;
      return;
    }
LABEL_99:
    xpc_object_t v18 = *((void *)this + 5);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v18, OS_LOG_TYPE_ERROR, "Failed to reset trace live filter setting for new boot instance", (uint8_t *)&buf, 2u);
    }
    goto LABEL_101;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19[2]) < 0) {
    goto LABEL_18;
  }
LABEL_15:
  if (sys::isBootSessionChanged((sys *)v2)) {
    goto LABEL_19;
  }
LABEL_20:
  HIBYTE(v19[2]) = 4;
  strcpy((char *)v19, "Mode");
  memset(&__p, 0, sizeof(__p));
  *((unsigned char *)&v21.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v21, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v5 = defaults::get((char *)&v21, (char *)v19, &buf);
  if (v5)
  {
    prop::file::get<std::string>((const void **)&v21.__r_.__value_.__l.__data_, (uint64_t)v19, (uint64_t)&buf, &v22);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_26:
      if (!v5) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_26;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (!v5) {
    goto LABEL_32;
  }
LABEL_30:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v6 = util::convert<int>(&__p, &buf, 0);
  LOBYTE(v5) = v6;
  if (v6) {
    *((_DWORD *)this + 38) = buf.__r_.__value_.__l.__data_;
  }
LABEL_32:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v19[2]) & 0x80000000) == 0)
    {
LABEL_34:
      if (v5) {
        goto LABEL_40;
      }
      goto LABEL_38;
    }
  }
  else if ((SHIBYTE(v19[2]) & 0x80000000) == 0)
  {
    goto LABEL_34;
  }
  operator delete(v19[0]);
  if (v5) {
    goto LABEL_40;
  }
LABEL_38:
  uint64_t v7 = *((void *)this + 5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Failed to get trace mode from preferences for same boot instance", (uint8_t *)&buf, 2u);
  }
LABEL_40:
  HIBYTE(v19[2]) = 14;
  strcpy((char *)v19, "TraceOwnership");
  memset(&__p, 0, sizeof(__p));
  *((unsigned char *)&v21.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v21, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v8 = defaults::get((char *)&v21, (char *)v19, &buf);
  if (v8)
  {
    prop::file::get<std::string>((const void **)&v21.__r_.__value_.__l.__data_, (uint64_t)v19, (uint64_t)&buf, &v22);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_46:
      if (!v8) {
        goto LABEL_52;
      }
      goto LABEL_50;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_46;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (!v8) {
    goto LABEL_52;
  }
LABEL_50:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v9 = util::convert<int>(&__p, &buf, 0);
  LOBYTE(v8) = v9;
  if (v9) {
    *((_DWORD *)this + 52) = buf.__r_.__value_.__l.__data_;
  }
LABEL_52:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v19[2]) & 0x80000000) == 0)
    {
LABEL_54:
      if (v8) {
        goto LABEL_60;
      }
      goto LABEL_58;
    }
  }
  else if ((SHIBYTE(v19[2]) & 0x80000000) == 0)
  {
    goto LABEL_54;
  }
  operator delete(v19[0]);
  if (v8) {
    goto LABEL_60;
  }
LABEL_58:
  unsigned __int8 v10 = *((void *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to get transport owner id from preferences for same boot instance", (uint8_t *)&buf, 2u);
  }
LABEL_60:
  HIBYTE(v19[2]) = 19;
  strcpy((char *)v19, "Live_Filter_Setting");
  memset(&__p, 0, sizeof(__p));
  *((unsigned char *)&v21.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v21, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v11 = defaults::get((char *)&v21, (char *)v19, &buf);
  if (v11)
  {
    prop::file::get<std::string>((const void **)&v21.__r_.__value_.__l.__data_, (uint64_t)v19, (uint64_t)&buf, &v22);
    std::string __p = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_64:
      if (!v11) {
        goto LABEL_70;
      }
      goto LABEL_68;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_64;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (!v11) {
    goto LABEL_70;
  }
LABEL_68:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &buf, 0)) {
    *((_DWORD *)this + 43) = buf.__r_.__value_.__l.__data_;
  }
LABEL_70:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v19[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_74:
    operator delete(v19[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19[2]) < 0) {
    goto LABEL_74;
  }
}

void sub_1A61493E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void INTTrace::prepare_sync(INTTrace *this)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((int *)this + 38);
    if (v3 > 7) {
      uint64_t v4 = "Unknown";
    }
    else {
      uint64_t v4 = off_1E5C47A78[v3];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Preparing BB Trace with mode: %s", (uint8_t *)&buf, 0xCu);
  }
  if (!*((void *)this + 27) && !*((_DWORD *)this + 38))
  {
    memset(v142, 0, sizeof(v142));
    memset(key, 0, sizeof(key));
    switch(*((_DWORD *)this + 43))
    {
      case 0:
        xpc_object_t v18 = abm::trace::kScratchFolder[0];
        size_t v19 = strlen(abm::trace::kScratchFolder[0]);
        if (v19 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v20 = v19;
        if (v19 >= 0x17)
        {
          uint64_t v94 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v94 = v19 | 7;
          }
          uint64_t v95 = v94 + 1;
          p_std::string buf = (std::string *)operator new(v94 + 1);
          buf.__r_.__value_.__l.__size_ = v20;
          buf.__r_.__value_.__r.__words[2] = v95 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
        }
        else
        {
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = v19;
          p_std::string buf = &buf;
          if (!v19)
          {
LABEL_165:
            p_buf->__r_.__value_.__s.__data_[v20] = 0;
            xpc_object_t v96 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            long long v97 = (void *)v96->__r_.__value_.__r.__words[0];
            v145.__r_.__value_.__r.__words[0] = v96->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v96->__r_.__value_.__r.__words[1] + 7);
            char v98 = HIBYTE(v96->__r_.__value_.__r.__words[2]);
            v96->__r_.__value_.__l.__size_ = 0;
            v96->__r_.__value_.__r.__words[2] = 0;
            v96->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v142[2]) < 0) {
              operator delete(v142[0]);
            }
            v142[0] = v97;
            v142[1] = v145.__r_.__value_.__l.__data_;
            *(void **)((char *)&v142[1] + 7) = *(void **)((char *)v145.__r_.__value_.__r.__words + 7);
            HIBYTE(v142[2]) = v98;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            uint64_t v99 = *((void *)this + 5);
            if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v100 = v142;
              if (SHIBYTE(v142[2]) < 0) {
                uint64_t v100 = (void **)v142[0];
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v100;
              std::string v101 = "#I Live filtering is disabled; primaryScratchPath is %s";
              goto LABEL_185;
            }
            goto LABEL_216;
          }
        }
        memmove(p_buf, v18, v20);
        goto LABEL_165;
      case 1:
        long long v72 = abm::trace::kScratchFolder[0];
        size_t v73 = strlen(abm::trace::kScratchFolder[0]);
        if (v73 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v74 = v73;
        if (v73 >= 0x17)
        {
          uint64_t v102 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v73 | 7) != 0x17) {
            uint64_t v102 = v73 | 7;
          }
          uint64_t v103 = v102 + 1;
          uint64_t v75 = (std::string *)operator new(v102 + 1);
          buf.__r_.__value_.__l.__size_ = v74;
          buf.__r_.__value_.__r.__words[2] = v103 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v75;
        }
        else
        {
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = v73;
          uint64_t v75 = &buf;
          if (!v73)
          {
LABEL_177:
            v75->__r_.__value_.__s.__data_[v74] = 0;
            uint64_t v104 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
            long long v105 = (void *)v104->__r_.__value_.__r.__words[0];
            v145.__r_.__value_.__r.__words[0] = v104->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v104->__r_.__value_.__r.__words[1] + 7);
            char v106 = HIBYTE(v104->__r_.__value_.__r.__words[2]);
            v104->__r_.__value_.__l.__size_ = 0;
            v104->__r_.__value_.__r.__words[2] = 0;
            v104->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v142[2]) < 0) {
              operator delete(v142[0]);
            }
            v142[0] = v105;
            v142[1] = v145.__r_.__value_.__l.__data_;
            *(void **)((char *)&v142[1] + 7) = *(void **)((char *)v145.__r_.__value_.__r.__words + 7);
            HIBYTE(v142[2]) = v106;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            uint64_t v99 = *((void *)this + 5);
            if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
            {
              long long v107 = v142;
              if (SHIBYTE(v142[2]) < 0) {
                long long v107 = (void **)v142[0];
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v107;
              std::string v101 = "#I Live filtering is enabled; primaryScratchPath is %s";
LABEL_185:
              uint64_t v108 = v99;
              uint32_t v109 = 12;
              goto LABEL_215;
            }
            goto LABEL_216;
          }
        }
        memmove(v75, v72, v74);
        goto LABEL_177;
      case 2:
        unint64_t v64 = abm::trace::kScratchFolder[0];
        size_t v65 = strlen(abm::trace::kScratchFolder[0]);
        if (v65 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v66 = v65;
        if (v65 >= 0x17)
        {
          uint64_t v76 = (v65 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v65 | 7) != 0x17) {
            uint64_t v76 = v65 | 7;
          }
          uint64_t v77 = v76 + 1;
          uint64_t v67 = (std::string *)operator new(v76 + 1);
          buf.__r_.__value_.__l.__size_ = v66;
          buf.__r_.__value_.__r.__words[2] = v77 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
        }
        else
        {
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = v65;
          uint64_t v67 = &buf;
          if (!v65)
          {
LABEL_141:
            v67->__r_.__value_.__s.__data_[v66] = 0;
            size_t v78 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            uint64_t v79 = (void *)v78->__r_.__value_.__r.__words[0];
            v145.__r_.__value_.__r.__words[0] = v78->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v78->__r_.__value_.__r.__words[1] + 7);
            char v80 = HIBYTE(v78->__r_.__value_.__r.__words[2]);
            v78->__r_.__value_.__l.__size_ = 0;
            v78->__r_.__value_.__r.__words[2] = 0;
            v78->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v142[2]) < 0) {
              operator delete(v142[0]);
            }
            v142[0] = v79;
            v142[1] = v145.__r_.__value_.__l.__data_;
            *(void **)((char *)&v142[1] + 7) = *(void **)((char *)v145.__r_.__value_.__r.__words + 7);
            HIBYTE(v142[2]) = v80;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            int v81 = abm::trace::kScratchFolder[0];
            size_t v82 = strlen(abm::trace::kScratchFolder[0]);
            if (v82 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            std::string::size_type v83 = v82;
            if (v82 >= 0x17)
            {
              uint64_t v110 = (v82 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v82 | 7) != 0x17) {
                uint64_t v110 = v82 | 7;
              }
              uint64_t v111 = v110 + 1;
              unint64_t v84 = (std::string *)operator new(v110 + 1);
              buf.__r_.__value_.__l.__size_ = v83;
              buf.__r_.__value_.__r.__words[2] = v111 | 0x8000000000000000;
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v84;
            }
            else
            {
              *((unsigned char *)&buf.__r_.__value_.__s + 23) = v82;
              unint64_t v84 = &buf;
              if (!v82)
              {
LABEL_190:
                v84->__r_.__value_.__s.__data_[v83] = 0;
                std::string v112 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
                CFStringRef v113 = (const __CFString *)v112->__r_.__value_.__r.__words[0];
                v145.__r_.__value_.__r.__words[0] = v112->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v112->__r_.__value_.__r.__words[1] + 7);
                char v114 = HIBYTE(v112->__r_.__value_.__r.__words[2]);
                v112->__r_.__value_.__l.__size_ = 0;
                v112->__r_.__value_.__r.__words[2] = 0;
                v112->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(key[2]) < 0) {
                  operator delete((void *)key[0]);
                }
                key[0] = v113;
                key[1] = (CFStringRef)v145.__r_.__value_.__l.__data_;
                *(CFStringRef *)((char *)&key[1] + 7) = *(CFStringRef *)((char *)v145.__r_.__value_.__r.__words + 7);
                HIBYTE(key[2]) = v114;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                long long v115 = *((void *)this + 5);
                if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v116 = v142;
                  if (SHIBYTE(v142[2]) < 0) {
                    uint64_t v116 = (void **)v142[0];
                  }
                  int v117 = key;
                  if (SHIBYTE(key[2]) < 0) {
                    int v117 = (CFStringRef *)key[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v116;
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v117;
                  std::string v101 = "#I Hybrid trace collection is active; primaryScratchPath is %s, secondaryScratchPath is %s";
                  goto LABEL_214;
                }
                goto LABEL_216;
              }
            }
            memmove(v84, v81, v83);
            goto LABEL_190;
          }
        }
        memmove(v67, v64, v66);
        goto LABEL_141;
      case 3:
        char v68 = abm::trace::kScratchFolder[0];
        size_t v69 = strlen(abm::trace::kScratchFolder[0]);
        if (v69 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v70 = v69;
        if (v69 >= 0x17)
        {
          uint64_t v85 = (v69 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v69 | 7) != 0x17) {
            uint64_t v85 = v69 | 7;
          }
          uint64_t v86 = v85 + 1;
          std::string v71 = (std::string *)operator new(v85 + 1);
          buf.__r_.__value_.__l.__size_ = v70;
          buf.__r_.__value_.__r.__words[2] = v86 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v71;
        }
        else
        {
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = v69;
          std::string v71 = &buf;
          if (!v69)
          {
LABEL_153:
            v71->__r_.__value_.__s.__data_[v70] = 0;
            std::string v87 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
            uint64_t v88 = (void *)v87->__r_.__value_.__r.__words[0];
            v145.__r_.__value_.__r.__words[0] = v87->__r_.__value_.__l.__size_;
            *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v87->__r_.__value_.__r.__words[1] + 7);
            char v89 = HIBYTE(v87->__r_.__value_.__r.__words[2]);
            v87->__r_.__value_.__l.__size_ = 0;
            v87->__r_.__value_.__r.__words[2] = 0;
            v87->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(v142[2]) < 0) {
              operator delete(v142[0]);
            }
            v142[0] = v88;
            v142[1] = v145.__r_.__value_.__l.__data_;
            *(void **)((char *)&v142[1] + 7) = *(void **)((char *)v145.__r_.__value_.__r.__words + 7);
            HIBYTE(v142[2]) = v89;
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            std::string v90 = abm::trace::kScratchFolder[0];
            size_t v91 = strlen(abm::trace::kScratchFolder[0]);
            if (v91 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            std::string::size_type v92 = v91;
            if (v91 >= 0x17)
            {
              uint64_t v118 = (v91 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v91 | 7) != 0x17) {
                uint64_t v118 = v91 | 7;
              }
              uint64_t v119 = v118 + 1;
              char v93 = (std::string *)operator new(v118 + 1);
              buf.__r_.__value_.__l.__size_ = v92;
              buf.__r_.__value_.__r.__words[2] = v119 | 0x8000000000000000;
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v93;
            }
            else
            {
              *((unsigned char *)&buf.__r_.__value_.__s + 23) = v91;
              char v93 = &buf;
              if (!v91)
              {
LABEL_204:
                v93->__r_.__value_.__s.__data_[v92] = 0;
                uint64_t v120 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
                CFStringRef v121 = (const __CFString *)v120->__r_.__value_.__r.__words[0];
                v145.__r_.__value_.__r.__words[0] = v120->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v120->__r_.__value_.__r.__words[1] + 7);
                char v122 = HIBYTE(v120->__r_.__value_.__r.__words[2]);
                v120->__r_.__value_.__l.__size_ = 0;
                v120->__r_.__value_.__r.__words[2] = 0;
                v120->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(key[2]) < 0) {
                  operator delete((void *)key[0]);
                }
                key[0] = v121;
                key[1] = (CFStringRef)v145.__r_.__value_.__l.__data_;
                *(CFStringRef *)((char *)&key[1] + 7) = *(CFStringRef *)((char *)v145.__r_.__value_.__r.__words + 7);
                HIBYTE(key[2]) = v122;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                long long v115 = *((void *)this + 5);
                if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v123 = v142;
                  if (SHIBYTE(v142[2]) < 0) {
                    uint64_t v123 = (void **)v142[0];
                  }
                  long long v124 = key;
                  if (SHIBYTE(key[2]) < 0) {
                    long long v124 = (CFStringRef *)key[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v123;
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v124;
                  std::string v101 = "#I Streaming Mode is enabled; primaryScratchPath is %s,  secondaryScratchPath is %s";
LABEL_214:
                  uint64_t v108 = v115;
                  uint32_t v109 = 22;
LABEL_215:
                  _os_log_impl(&dword_1A609F000, v108, OS_LOG_TYPE_DEFAULT, v101, (uint8_t *)&buf, v109);
                }
LABEL_216:
                HIBYTE(v140[2]) = 18;
                strcpy((char *)v140, "MaxMemoryFileCount");
                memset(&v143, 0, sizeof(v143));
                HIBYTE(__p[2]) = 7;
                strcpy((char *)__p, "BBTrace");
                memset(&buf, 0, sizeof(buf));
                BOOL v125 = defaults::get((char *)__p, (char *)v140, &buf);
                if (v125)
                {
                  prop::file::get<std::string>((const void **)__p, (uint64_t)v140, (uint64_t)&buf, &v145);
                  if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v143.__r_.__value_.__l.__data_);
                  }
                  std::string v143 = v145;
                }
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(buf.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                  {
LABEL_222:
                    if (!v125)
                    {
LABEL_227:
                      if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v143.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(v140[2]) < 0) {
                        operator delete(v140[0]);
                      }
                      buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
                      *(void *)&long long v155 = 0;
                      *((void *)&v155 + 1) = 0xAAAAAAAA00100000;
                      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
                      long long v152 = 0u;
                      long long v153 = 0u;
                      memset(v154, 0, sizeof(v154));
                      if (SHIBYTE(v142[2]) < 0)
                      {
                        std::string::__assign_no_alias<true>(&v154[3], v142[0], (size_t)v142[1]);
                        if (SHIBYTE(v154[2]) < 0)
                        {
                          v154[1] = (void *)4;
                          uint64_t v126 = (char *)v154[0];
LABEL_235:
                          strcpy(v126, ".acp");
                          LODWORD(v155) = *((_DWORD *)this + 42);
                          *(int32x2_t *)((char *)&v155 + 4) = vrev64_s32(*(int32x2_t *)((char *)this + 176));
                          v145.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
                          long long v149 = 0xAAAAAAAAAAAAAAAALL;
                          *(_OWORD *)&v145.__r_.__value_.__r.__words[1] = 0u;
                          long long v146 = 0u;
                          *(_OWORD *)std::string v147 = 0u;
                          memset(v148, 0, sizeof(v148));
                          unint64_t v150 = 0xAAAAAAAA00100000;
                          if (SHIBYTE(key[2]) < 0)
                          {
                            std::string::__assign_no_alias<true>(&v148[3], (void *)key[0], (size_t)key[1]);
                            if (SHIBYTE(v148[2]) < 0)
                            {
                              v148[1] = (void *)4;
                              char v127 = (char *)v148[0];
                              goto LABEL_239;
                            }
                          }
                          else
                          {
                            *(_OWORD *)&v148[3] = *(_OWORD *)key;
                            *(CFStringRef *)&long long v149 = key[2];
                          }
                          char v127 = (char *)v148;
                          HIBYTE(v148[2]) = 4;
LABEL_239:
                          strcpy(v127, ".acp");
                          int v128 = *((_DWORD *)this + 44);
                          int v129 = *((_DWORD *)this + 45) >> 2;
                          DWORD2(v149) = *((_DWORD *)this + 42) / 16;
                          HIDWORD(v149) = v129;
                          LODWORD(v150) = v128;
                          GetABMLogServer(&v138);
                          (*(void (**)(INTTrace *))(*(void *)this + 160))(this);
                          abm::trace::TraceReader::create();
                          long long v130 = *(_OWORD *)__p;
                          __p[0] = 0;
                          __p[1] = 0;
                          xpc_object_t v131 = (std::__shared_weak_count *)*((void *)this + 28);
                          *(_OWORD *)((char *)this + 216) = v130;
                          if (v131 && !atomic_fetch_add(&v131->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
                            std::__shared_weak_count::__release_weak(v131);
                          }
                          xpc_object_t v132 = (std::__shared_weak_count *)__p[1];
                          if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
                            std::__shared_weak_count::__release_weak(v132);
                          }
                          v133 = v139;
                          if (v139 && !atomic_fetch_add(&v139->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                          {
                            ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
                            std::__shared_weak_count::__release_weak(v133);
                          }
                          v134 = *((void *)this + 5);
                          if (*((void *)this + 27))
                          {
                            if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
                            {
                              LOWORD(__p[0]) = 0;
                              _os_log_debug_impl(&dword_1A609F000, v134, OS_LOG_TYPE_DEBUG, "#D Created file reader!", (uint8_t *)__p, 2u);
                              if (SBYTE7(v149) < 0) {
                                goto LABEL_251;
                              }
LABEL_256:
                              if (SHIBYTE(v148[2]) < 0)
                              {
LABEL_252:
                                operator delete(v148[0]);
                                v135 = (void *)*((void *)&v146 + 1);
                                if (!*((void *)&v146 + 1))
                                {
LABEL_259:
                                  if (SBYTE7(v146) < 0)
                                  {
                                    operator delete((void *)v145.__r_.__value_.__l.__size_);
                                    if ((SHIBYTE(v154[5]) & 0x80000000) == 0)
                                    {
LABEL_261:
                                      if ((SHIBYTE(v154[2]) & 0x80000000) == 0) {
                                        goto LABEL_262;
                                      }
                                      goto LABEL_270;
                                    }
                                  }
                                  else if ((SHIBYTE(v154[5]) & 0x80000000) == 0)
                                  {
                                    goto LABEL_261;
                                  }
                                  operator delete(v154[3]);
                                  if ((SHIBYTE(v154[2]) & 0x80000000) == 0)
                                  {
LABEL_262:
                                    v136 = (void *)*((void *)&v152 + 1);
                                    if (!*((void *)&v152 + 1)) {
                                      goto LABEL_264;
                                    }
                                    goto LABEL_263;
                                  }
LABEL_270:
                                  operator delete(v154[0]);
                                  v136 = (void *)*((void *)&v152 + 1);
                                  if (!*((void *)&v152 + 1))
                                  {
LABEL_264:
                                    if (SBYTE7(v152) < 0)
                                    {
                                      operator delete((void *)buf.__r_.__value_.__l.__size_);
                                      if ((SHIBYTE(key[2]) & 0x80000000) == 0)
                                      {
LABEL_266:
                                        if ((SHIBYTE(v142[2]) & 0x80000000) == 0) {
                                          goto LABEL_10;
                                        }
LABEL_274:
                                        operator delete(v142[0]);
                                        goto LABEL_10;
                                      }
                                    }
                                    else if ((SHIBYTE(key[2]) & 0x80000000) == 0)
                                    {
                                      goto LABEL_266;
                                    }
                                    operator delete((void *)key[0]);
                                    if ((SHIBYTE(v142[2]) & 0x80000000) == 0) {
                                      goto LABEL_10;
                                    }
                                    goto LABEL_274;
                                  }
LABEL_263:
                                  *(void *)&long long v153 = v136;
                                  operator delete(v136);
                                  goto LABEL_264;
                                }
LABEL_258:
                                v147[0] = v135;
                                operator delete(v135);
                                goto LABEL_259;
                              }
LABEL_257:
                              v135 = (void *)*((void *)&v146 + 1);
                              if (!*((void *)&v146 + 1)) {
                                goto LABEL_259;
                              }
                              goto LABEL_258;
                            }
                          }
                          else if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(__p[0]) = 0;
                            _os_log_error_impl(&dword_1A609F000, v134, OS_LOG_TYPE_ERROR, "Failed to create file reader", (uint8_t *)__p, 2u);
                            if ((SBYTE7(v149) & 0x80000000) == 0) {
                              goto LABEL_256;
                            }
LABEL_251:
                            operator delete(v148[3]);
                            if (SHIBYTE(v148[2]) < 0) {
                              goto LABEL_252;
                            }
                            goto LABEL_257;
                          }
                          if ((SBYTE7(v149) & 0x80000000) == 0) {
                            goto LABEL_256;
                          }
                          goto LABEL_251;
                        }
                      }
                      else
                      {
                        *(_OWORD *)&v154[3] = *(_OWORD *)v142;
                        v154[5] = v142[2];
                      }
                      uint64_t v126 = (char *)v154;
                      HIBYTE(v154[2]) = 4;
                      goto LABEL_235;
                    }
LABEL_226:
                    util::convert<unsigned int>(&v143, (_DWORD *)this + 45, 0);
                    goto LABEL_227;
                  }
                }
                else if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
                {
                  goto LABEL_222;
                }
                operator delete(__p[0]);
                if (!v125) {
                  goto LABEL_227;
                }
                goto LABEL_226;
              }
            }
            memmove(v93, v90, v92);
            goto LABEL_204;
          }
        }
        memmove(v71, v68, v70);
        goto LABEL_153;
      default:
        goto LABEL_216;
    }
  }
  BOOL v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_debug_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEBUG, "#D Skipped creating new file reader instance", (uint8_t *)&buf, 2u);
  }
LABEL_10:
  unsigned int v6 = *((_DWORD *)this + 38);
  if (v6 != 7 && v6 != 2)
  {
    if (!v6)
    {
      memset(&v145, 170, sizeof(v145));
      uint64_t v7 = abm::trace::kScratchFolder[0];
      size_t v8 = strlen(abm::trace::kScratchFolder[0]);
      if (v8 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v9 = v8;
      if (v8 >= 0x17)
      {
        uint64_t v22 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v8 | 7) != 0x17) {
          uint64_t v22 = v8 | 7;
        }
        uint64_t v23 = v22 + 1;
        unsigned __int8 v10 = (std::string *)operator new(v22 + 1);
        buf.__r_.__value_.__l.__size_ = v9;
        buf.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
      }
      else
      {
        *((unsigned char *)&buf.__r_.__value_.__s + 23) = v8;
        unsigned __int8 v10 = &buf;
        if (!v8)
        {
LABEL_34:
          v10->__r_.__value_.__s.__data_[v9] = 0;
          std::string v24 = std::string::append(&buf, "BBTrace.scratch/", 0x10uLL);
          long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
          v145.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v25;
          v24->__r_.__value_.__l.__size_ = 0;
          v24->__r_.__value_.__r.__words[2] = 0;
          v24->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          memset(__p, 170, 24);
          uint64_t v26 = abm::trace::kScratchFolder[0];
          size_t v27 = strlen(abm::trace::kScratchFolder[0]);
          if (v27 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          std::string::size_type v28 = v27;
          if (v27 >= 0x17)
          {
            uint64_t v30 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v27 | 7) != 0x17) {
              uint64_t v30 = v27 | 7;
            }
            uint64_t v31 = v30 + 1;
            uint64_t v29 = (std::string *)operator new(v30 + 1);
            buf.__r_.__value_.__l.__size_ = v28;
            buf.__r_.__value_.__r.__words[2] = v31 | 0x8000000000000000;
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
          }
          else
          {
            *((unsigned char *)&buf.__r_.__value_.__s + 23) = v27;
            uint64_t v29 = &buf;
            if (!v27)
            {
LABEL_44:
              v29->__r_.__value_.__s.__data_[v28] = 0;
              char v32 = std::string::append(&buf, "BBTrace.scratch.filtered/", 0x19uLL);
              long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
              std::vector<std::ssub_match> __p[2] = (void *)v32->__r_.__value_.__r.__words[2];
              *(_OWORD *)std::string __p = v33;
              v32->__r_.__value_.__l.__size_ = 0;
              v32->__r_.__value_.__r.__words[2] = 0;
              v32->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              LOBYTE(key[0]) = 0;
              pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
              std::string::size_type v34 = off_1EB5EE4F0;
              if (!off_1EB5EE4F0)
              {
                SharedData::create_default_global(&buf);
                long long v35 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
                char v36 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
                off_1EB5EE4F0 = v35;
                if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                  std::__shared_weak_count::__release_weak(v36);
                }
                size_t size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
                if (buf.__r_.__value_.__l.__size_
                  && !atomic_fetch_add((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
                  std::__shared_weak_count::__release_weak(size);
                }
                std::string::size_type v34 = off_1EB5EE4F0;
              }
              v143.__r_.__value_.__r.__words[0] = v34;
              v143.__r_.__value_.__l.__size_ = *(&off_1EB5EE4F0 + 1);
              if (*(&off_1EB5EE4F0 + 1)) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
              }
              pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
              *(_WORD *)&v137[50] = 0;
              *(_DWORD *)&v137[52] = 0;
              *(void *)&v137[56] = 0x8000000000000038;
              *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = xmmword_1A61F9770;
              strcpy(buf.__r_.__value_.__l.__data_, "Firmware version changed since last commcenter launch");
              strcpy(v137, "ast commcenter l changed since lFirmware version5");
              uint64_t v38 = (os_unfair_lock_s *)(v34 + 40);
              os_unfair_lock_lock((os_unfair_lock_t)(v34 + 40));
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                char v39 = &buf;
              }
              else {
                char v39 = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v142, (const char *)v39);
              int v40 = (BOOL *)(**(uint64_t (***)(std::string::size_type, void *))v34)(v34, v142[0]);
              size_t v41 = v40;
              if (v40)
              {
                CFTypeID v42 = CFGetTypeID(v40);
                if (v42 == CFBooleanGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)key, v41, v43);
                }
                CFRelease(v41);
              }
              MEMORY[0x1A62748E0](v142);
              os_unfair_lock_unlock(v38);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(buf.__r_.__value_.__l.__data_);
                std::string::size_type v44 = (std::__shared_weak_count *)v143.__r_.__value_.__l.__size_;
                if (!v143.__r_.__value_.__l.__size_) {
                  goto LABEL_68;
                }
              }
              else
              {
                std::string::size_type v44 = (std::__shared_weak_count *)v143.__r_.__value_.__l.__size_;
                if (!v143.__r_.__value_.__l.__size_) {
                  goto LABEL_68;
                }
              }
              if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
                std::__shared_weak_count::__release_weak(v44);
                if (LOBYTE(key[0])) {
                  goto LABEL_69;
                }
                goto LABEL_102;
              }
LABEL_68:
              if (LOBYTE(key[0]))
              {
LABEL_69:
                unint64_t v45 = *((void *)this + 5);
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v46 = &v145;
                  if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    uint64_t v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v46;
                  _os_log_impl(&dword_1A609F000, v45, OS_LOG_TYPE_DEFAULT, "#I Removing scratch folder %s because firmware version change detected", (uint8_t *)&buf, 0xCu);
                }
                if ((*((_DWORD *)this + 43) & 0xFFFFFFFE) == 2)
                {
                  long long v47 = *((void *)this + 5);
                  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
                  {
                    int64_t v48 = __p;
                    if (SHIBYTE(__p[2]) < 0) {
                      int64_t v48 = (void **)__p[0];
                    }
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
                    _os_log_impl(&dword_1A609F000, v47, OS_LOG_TYPE_DEFAULT, "#I Removing filtered scratch folder %s because firmware version change detected", (uint8_t *)&buf, 0xCu);
                  }
                }
                abm::trace::TraceReader::clearFiles(*((abm::trace::TraceReader **)this + 27));
                pthread_mutex_lock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
                std::string::size_type v49 = off_1EB5EE4F0;
                if (!off_1EB5EE4F0)
                {
                  SharedData::create_default_global(&buf);
                  long long v50 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                  *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
                  uint64_t v51 = (std::__shared_weak_count *)*(&off_1EB5EE4F0 + 1);
                  off_1EB5EE4F0 = v50;
                  if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
                    std::__shared_weak_count::__release_weak(v51);
                  }
                  BOOL v52 = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
                  if (buf.__r_.__value_.__l.__size_
                    && !atomic_fetch_add((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
                    std::__shared_weak_count::__release_weak(v52);
                  }
                  std::string::size_type v49 = off_1EB5EE4F0;
                }
                v143.__r_.__value_.__r.__words[0] = v49;
                v143.__r_.__value_.__l.__size_ = *(&off_1EB5EE4F0 + 1);
                if (*(&off_1EB5EE4F0 + 1)) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE4F0 + 1) + 8), 1uLL, memory_order_relaxed);
                }
                pthread_mutex_unlock(&ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance);
                BOOL v53 = operator new(0x38uLL);
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v53;
                *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = *(_OWORD *)&v137[48];
                *(_OWORD *)BOOL v53 = *(_OWORD *)&v137[32];
                *((_OWORD *)v53 + 1) = *(_OWORD *)&v137[16];
                *((_OWORD *)v53 + 2) = *(_OWORD *)v137;
                strcpy((char *)v53 + 45, "r launch");
                os_unfair_lock_lock((os_unfair_lock_t)(v49 + 40));
                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string v54 = &buf;
                }
                else {
                  std::string v54 = (std::string *)buf.__r_.__value_.__r.__words[0];
                }
                ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, (const char *)v54);
                uint64_t v55 = (void *)*MEMORY[0x1E4F1CFC8];
                v142[0] = v55;
                if (v55)
                {
                  CFStringRef v56 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
                  CFPreferencesSetValue(key[0], v55, *(CFStringRef *)(v49 + 8), *(CFStringRef *)(v49 + 16), (CFStringRef)*MEMORY[0x1E4F1D3E0]);
                  CFPreferencesSynchronize(*(CFStringRef *)(v49 + 8), *(CFStringRef *)(v49 + 16), v56);
                  CFRelease(v55);
                }
                MEMORY[0x1A62748E0](key);
                os_unfair_lock_unlock((os_unfair_lock_t)(v49 + 40));
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                uint64_t v57 = (std::__shared_weak_count *)v143.__r_.__value_.__l.__size_;
                if (v143.__r_.__value_.__l.__size_)
                {
                  if (!atomic_fetch_add((atomic_ullong *volatile)(v143.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                    std::__shared_weak_count::__release_weak(v57);
                  }
                }
                goto LABEL_113;
              }
LABEL_102:
              if (!*((unsigned char *)this + 360))
              {
                uint64_t v58 = *((void *)this + 5);
                if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                {
                  int v59 = &v145;
                  if ((v145.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    int v59 = (std::string *)v145.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
                  _os_log_impl(&dword_1A609F000, v58, OS_LOG_TYPE_DEFAULT, "#I Removing scratch folder %s because retain previous trace property is set to false", (uint8_t *)&buf, 0xCu);
                }
                if ((*((_DWORD *)this + 43) & 0xFFFFFFFE) == 2)
                {
                  uint64_t v60 = *((void *)this + 5);
                  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                  {
                    unint64_t v61 = __p;
                    if (SHIBYTE(__p[2]) < 0) {
                      unint64_t v61 = (void **)__p[0];
                    }
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v61;
                    _os_log_impl(&dword_1A609F000, v60, OS_LOG_TYPE_DEFAULT, "#I Removing filtered scratch folder %s because retain previous trace property is set to false", (uint8_t *)&buf, 0xCu);
                  }
                }
                abm::trace::TraceReader::clearFiles(*((abm::trace::TraceReader **)this + 27));
              }
LABEL_113:
              char started = INTTrace::startReader_sync(this);
              uint64_t v63 = *((void *)this + 5);
              if (started)
              {
                if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl(&dword_1A609F000, v63, OS_LOG_TYPE_DEFAULT, "#I Succeeded opening trace transport", (uint8_t *)&buf, 2u);
                  if (SHIBYTE(__p[2]) < 0) {
                    goto LABEL_116;
                  }
LABEL_121:
                  if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_117:
                    operator delete(v145.__r_.__value_.__l.__data_);
                    if ((started & 1) == 0) {
                      return;
                    }
                    goto LABEL_123;
                  }
LABEL_122:
                  if ((started & 1) == 0) {
                    return;
                  }
                  goto LABEL_123;
                }
              }
              else if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl(&dword_1A609F000, v63, OS_LOG_TYPE_ERROR, "Failed to open TRACE transport during prepare stage; ignore this failure and proceed",
                  (uint8_t *)&buf,
                  2u);
                if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
                  goto LABEL_121;
                }
LABEL_116:
                operator delete(__p[0]);
                if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0) {
                  goto LABEL_117;
                }
                goto LABEL_122;
              }
              if ((SHIBYTE(__p[2]) & 0x80000000) == 0) {
                goto LABEL_121;
              }
              goto LABEL_116;
            }
          }
          memmove(v29, v26, v28);
          goto LABEL_44;
        }
      }
      memmove(v10, v7, v9);
      goto LABEL_34;
    }
    unsigned __int8 v16 = *((void *)this + 5);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      if (v6 > 6) {
        char v17 = "Unknown";
      }
      else {
        char v17 = off_1E5C47A00[v6];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      char v13 = "#I trace mode (%s)";
      long long v14 = v16;
      uint32_t v15 = 12;
      goto LABEL_100;
    }
    goto LABEL_123;
  }
  char v11 = INTTrace::startTraceWithUSBBridgeInterface(this);
  unint64_t v12 = *((void *)this + 5);
  if (v11)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      char v13 = "#I Succeeded in starting trace via usb bridge";
      long long v14 = v12;
      uint32_t v15 = 2;
LABEL_100:
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&buf, v15);
    }
LABEL_123:
    *((unsigned char *)this + 260) = 1;
    return;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Failed to start trace via usb bridge", (uint8_t *)&buf, 2u);
  }
}

void sub_1A614ACA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (*(char *)(v57 - 201) < 0) {
    operator delete(*(void **)(v57 - 224));
  }
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a37 < 0)
  {
    operator delete(a32);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](uint64_t result, long long *a2)
{
  uint64_t v2 = result;
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(result + 8);
  *(_OWORD *)uint64_t result = v3;
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      return v2;
    }
  }
  return result;
}

uint64_t INTTrace::startReader_sync(INTTrace *this)
{
  if (*((_DWORD *)this + 38))
  {
    uint64_t v2 = *((void *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    *(_WORD *)std::string buf = 0;
    long long v3 = "#I Trace Mode is not set to AP. Skip starting trace reader";
LABEL_4:
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, v3, buf, 2u);
    return 1;
  }
  if (!*((unsigned char *)this + 160))
  {
    uint64_t v2 = *((void *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    *(_WORD *)std::string buf = 0;
    long long v3 = "#I Trace is not enabled. Skip starting trace reader";
    goto LABEL_4;
  }
  if (*((void *)this + 27))
  {
    BOOL v5 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v5 || (v6 = *((void *)this + 9), (uint64_t v7 = std::__shared_weak_count::lock(v5)) == 0)) {
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
    size_t v8 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v8);
    }
    *(_DWORD *)&uint8_t buf[4] = -1431655936;
    long long v20 = 0xAAAAAAAAAAAAAAAALL;
    *(_DWORD *)std::string buf = 17;
    unint64_t v21 = 0xAAAAAAAAAAAAAA00;
    *(void *)&uint8_t buf[8] = 10;
    int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v7);
    capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
    *(void *)&long long v20 = *(void *)((char *)this + 252);
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN8INTTrace16startReader_syncEv_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_21;
    aBlock[4] = this;
    void aBlock[5] = v6;
    xpc_object_t v18 = v8;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    unsigned __int8 v16 = _Block_copy(aBlock);
    uint64_t v10 = abm::trace::TraceReader::start();
    if (v16) {
      _Block_release(v16);
    }
    if (v10
      && !*((unsigned char *)this + 248)
      && (char v11 = *((void *)this + 18)) != 0
      && (dispatch_group_enter(v11),
          *((unsigned char *)this + 248) = 1,
          unint64_t v12 = *((void *)this + 5),
          os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)))
    {
      *(_WORD *)uint32_t v15 = 0;
      _os_log_debug_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEBUG, "#D Holding task group", v15, 2u);
      char v13 = v18;
      if (!v18) {
        goto LABEL_20;
      }
    }
    else
    {
      char v13 = v18;
      if (!v18)
      {
LABEL_20:
        std::__shared_weak_count::__release_weak(v8);
        return v10;
      }
    }
    std::__shared_weak_count::__release_weak(v13);
    goto LABEL_20;
  }
  long long v14 = *((void *)this + 5);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "Failed to start Trace reader. Object does not exist", buf, 2u);
  }
  return 0;
}

void sub_1A614B248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a18)
  {
    std::__shared_weak_count::__release_weak(a18);
    std::__shared_weak_count::__release_weak(v18);
    _Unwind_Resume(a1);
  }
  std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::startTraceWithUSBBridgeInterface(INTTrace *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *((_DWORD *)this + 38);
  if (v2 != 2 && v2 != 7)
  {
    uint64_t v10 = *((void *)this + 5);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    if (v2 > 6) {
      unint64_t v12 = "Unknown";
    }
    else {
      unint64_t v12 = off_1E5C47A00[v2];
    }
    *(_DWORD *)uint64_t v22 = 136315138;
    *(void *)&v22[4] = v12;
    long long v14 = "Invalid trace mode (%s) to start trace via USB interface";
    goto LABEL_36;
  }
  uint64_t v4 = (SoftwareBypassShim *)*((void *)this + 42);
  if (!v4)
  {
    SoftwareBypassShim::create((std::__shared_weak_count **)v22);
    long long v5 = *(_OWORD *)v22;
    *(_OWORD *)uint64_t v22 = 0uLL;
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 43);
    *((_OWORD *)this + 21) = v5;
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v7 = *(std::__shared_weak_count **)&v22[8];
    if (!*(void *)&v22[8]
      || atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v22[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      uint64_t v4 = (SoftwareBypassShim *)*((void *)this + 42);
      if (v4) {
        goto LABEL_13;
      }
LABEL_29:
      char v13 = *((void *)this + 5);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_WORD *)uint64_t v22 = 0;
      long long v14 = "Failed to create bypass control object";
      goto LABEL_31;
    }
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v4 = (SoftwareBypassShim *)*((void *)this + 42);
    if (!v4) {
      goto LABEL_29;
    }
  }
LABEL_13:
  if (!*((void *)v4 + 2))
  {
    char v13 = *((void *)this + 5);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)uint64_t v22 = 0;
    long long v14 = "expected to use software bypass, but it is not supported";
LABEL_31:
    size_t v19 = v13;
    uint32_t v20 = 2;
LABEL_37:
    _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, v14, v22, v20);
    return 0;
  }
  unsigned int v8 = *((_DWORD *)this + 38);
  if (v8 != 2)
  {
    if (v8 == 7)
    {
      uint64_t v9 = 32;
      goto LABEL_23;
    }
    uint64_t v10 = *((void *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if (v8 > 6) {
        xpc_object_t v18 = "Unknown";
      }
      else {
        xpc_object_t v18 = off_1E5C47A00[v8];
      }
      *(_DWORD *)uint64_t v22 = 136315138;
      *(void *)&v22[4] = v18;
      long long v14 = "Unexpected trace mode: %s";
LABEL_36:
      size_t v19 = v10;
      uint32_t v20 = 12;
      goto LABEL_37;
    }
    return 0;
  }
  uint64_t v9 = 41;
LABEL_23:
  uint64_t v15 = SoftwareBypassShim::bypassCtl(v4, v9);
  unsigned __int8 v16 = *((void *)this + 5);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    char v17 = SoftwareBypassShim::bypassInterfaceMaskAsString(*((SoftwareBypassShim **)this + 42), 41);
    *(_DWORD *)uint64_t v22 = 136315394;
    *(void *)&v22[4] = v17;
    *(_WORD *)&v22[12] = 1024;
    *(_DWORD *)&v22[14] = v15;
    _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I bypassCtl( %s): success: %d", v22, 0x12u);
  }
  return v15;
}

void ___ZN8INTTrace16startReader_syncEv_block_invoke(void *a1, _DWORD *a2)
{
  long long v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    long long v50 = v6;
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        if (*a2 == 3)
        {
          long long v14 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#E No Logging Traffic detected (Stalled?)", (uint8_t *)&buf, 2u);
          }
        }
        else if (*a2 == 2)
        {
          unsigned int v8 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#E TRACE transport error", (uint8_t *)&buf, 2u);
          }
          *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v47 = v9;
          long long v48 = v9;
          long long v45 = v9;
          long long v46 = v9;
          long long v43 = v9;
          long long v44 = v9;
          long long buf = v9;
          uint64_t v10 = (const void *)*MEMORY[0x1E4F4C6E8];
          size_t v11 = strlen((const char *)*MEMORY[0x1E4F4C6E8]);
          if (v11 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          size_t v12 = v11;
          if (v11 >= 0x17)
          {
            uint64_t v15 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v11 | 7) != 0x17) {
              uint64_t v15 = v11 | 7;
            }
            uint64_t v16 = v15 + 1;
            p_dst = (long long *)operator new(v15 + 1);
            *((void *)&__dst + 1) = v12;
            unint64_t v41 = v16 | 0x8000000000000000;
            *(void *)&long long __dst = p_dst;
          }
          else
          {
            HIBYTE(v41) = v11;
            p_dst = &__dst;
            if (!v11)
            {
LABEL_18:
              *((unsigned char *)p_dst + v12) = 0;
              char v17 = (const void *)*MEMORY[0x1E4F4D1A0];
              size_t v18 = strlen((const char *)*MEMORY[0x1E4F4D1A0]);
              if (v18 > 0x7FFFFFFFFFFFFFF7) {
                std::string::__throw_length_error[abi:ne180100]();
              }
              size_t v19 = v18;
              if (v18 >= 0x17)
              {
                uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v18 | 7) != 0x17) {
                  uint64_t v21 = v18 | 7;
                }
                uint64_t v22 = v21 + 1;
                uint32_t v20 = operator new(v21 + 1);
                *((void *)&v38 + 1) = v19;
                unint64_t v39 = v22 | 0x8000000000000000;
                *(void *)&long long v38 = v20;
              }
              else
              {
                HIBYTE(v39) = v18;
                uint32_t v20 = &v38;
                if (!v18)
                {
LABEL_26:
                  v20[v19] = 0;
                  v37[23] = 21;
                  strcpy(v37, "TRACE transport error");
                  Timestamp::Timestamp((Timestamp *)v33);
                  Timestamp::asString((uint64_t)v33, 0, 9, __p);
                  char v32 = 0;
                  LOBYTE(v31) = 0;
                  ResetInfo::ResetInfo((std::string *)&buf, &__dst, &v38, (long long *)v37, (uint64_t)__p, 7, &v31);
                  if (v36 < 0)
                  {
                    operator delete(__p[0]);
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v33, v34);
                    if ((SHIBYTE(v39) & 0x80000000) == 0)
                    {
LABEL_28:
                      if ((SHIBYTE(v41) & 0x80000000) == 0) {
                        goto LABEL_29;
                      }
                      goto LABEL_33;
                    }
                  }
                  else
                  {
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v33, v34);
                    if ((SHIBYTE(v39) & 0x80000000) == 0) {
                      goto LABEL_28;
                    }
                  }
                  operator delete((void *)v38);
                  if ((SHIBYTE(v41) & 0x80000000) == 0)
                  {
LABEL_29:
                    if (*(_DWORD *)(v5 + 356) != 2)
                    {
LABEL_40:
                      if ((SHIBYTE(v48) & 0x80000000) == 0) {
                        goto LABEL_41;
                      }
                      goto LABEL_50;
                    }
LABEL_34:
                    uint64_t v23 = *(NSObject **)(v5 + 40);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__dst) = 0;
                      _os_log_impl(&dword_1A609F000, v23, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for Trace transport error", (uint8_t *)&__dst, 2u);
                    }
                    ResetInfo::ResetInfo(&v24, &buf);
                    INTTrace::commandResetModem_sync(v5, (long long *)&v24);
                    if (v30 < 0)
                    {
                      operator delete(v29);
                      if ((v28 & 0x80000000) == 0)
                      {
LABEL_38:
                        if ((v26 & 0x80000000) == 0) {
                          goto LABEL_39;
                        }
                        goto LABEL_48;
                      }
                    }
                    else if ((v28 & 0x80000000) == 0)
                    {
                      goto LABEL_38;
                    }
                    operator delete(v27);
                    if ((v26 & 0x80000000) == 0)
                    {
LABEL_39:
                      if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_40;
                      }
                      goto LABEL_49;
                    }
LABEL_48:
                    operator delete(v25);
                    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_40;
                    }
LABEL_49:
                    operator delete(v24.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v48) & 0x80000000) == 0)
                    {
LABEL_41:
                      if ((SBYTE7(v46) & 0x80000000) == 0) {
                        goto LABEL_42;
                      }
                      goto LABEL_51;
                    }
LABEL_50:
                    operator delete(*((void **)&v47 + 1));
                    if ((SBYTE7(v46) & 0x80000000) == 0)
                    {
LABEL_42:
                      if ((SHIBYTE(v44) & 0x80000000) == 0) {
                        goto LABEL_43;
                      }
                      goto LABEL_52;
                    }
LABEL_51:
                    operator delete((void *)v45);
                    if ((SHIBYTE(v44) & 0x80000000) == 0)
                    {
LABEL_43:
                      if ((SBYTE7(v43) & 0x80000000) == 0) {
                        goto LABEL_44;
                      }
                      goto LABEL_53;
                    }
LABEL_52:
                    operator delete(*((void **)&v43 + 1));
                    if ((SBYTE7(v43) & 0x80000000) == 0)
                    {
LABEL_44:
                      uint64_t v7 = v50;
                      if (!v50) {
                        return;
                      }
                      goto LABEL_54;
                    }
LABEL_53:
                    operator delete((void *)buf);
                    uint64_t v7 = v50;
                    if (!v50) {
                      return;
                    }
                    goto LABEL_54;
                  }
LABEL_33:
                  operator delete((void *)__dst);
                  if (*(_DWORD *)(v5 + 356) != 2) {
                    goto LABEL_40;
                  }
                  goto LABEL_34;
                }
              }
              memmove(v20, v17, v19);
              goto LABEL_26;
            }
          }
          memmove(p_dst, v10, v12);
          goto LABEL_18;
        }
      }
LABEL_54:
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A614B9EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ResetInfo::~ResetInfo((void **)va);
  ResetInfo::~ResetInfo((void **)(v2 - 192));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 80);
  _Unwind_Resume(a1);
}

void sub_1A614BA18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  if (a44 < 0)
  {
    operator delete(a39);
    if ((*(char *)(v44 - 201) & 0x80000000) == 0)
    {
LABEL_5:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
      _Unwind_Resume(a1);
    }
  }
  else if ((*(char *)(v44 - 201) & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(*(void **)(v44 - 224));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
  _Unwind_Resume(a1);
}

void sub_1A614BAA0(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 80);
  _Unwind_Resume(a1);
}

void INTTrace::commandResetModem_sync(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 144));
    dispatch_group_enter(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 136);
  if (!v5) {
    goto LABEL_18;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  char v32 = v6;
  if (!v6) {
    goto LABEL_18;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a1 + 128);
  uint64_t v31 = v8;
  if (!v8) {
    goto LABEL_16;
  }
  if (!*(void *)(a1 + 304)) {
    goto LABEL_8;
  }
  char v30 = 0;
  LOBYTE(v29) = 0;
  Timestamp::Timestamp((Timestamp *)v27);
  char v26 = 0;
  LOWORD(v25) = 0;
  LOBYTE(v24) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v27, v28);
  if (v30 < 0)
  {
    operator delete(v29);
    if (!*(void *)(a1 + 320)) {
      goto LABEL_12;
    }
  }
  else
  {
LABEL_8:
    if (!*(void *)(a1 + 320)) {
      goto LABEL_12;
    }
  }
  char v23 = 0;
  LOBYTE(v22) = 0;
  Timestamp::Timestamp((Timestamp *)v20);
  char v19 = 0;
  LOBYTE(v18) = 0;
  char v17 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v20, v21);
  if (v23 < 0) {
    operator delete(v22);
  }
LABEL_12:
  ResetInfo::ResetInfo(&v9, a2);
  abm::BasebandTracingTask::commandResetModem(v8, (ResetInfo *)&v9);
  if (v15 < 0)
  {
    operator delete(v14);
    if ((v13 & 0x80000000) == 0)
    {
LABEL_14:
      if ((v11 & 0x80000000) == 0) {
        goto LABEL_15;
      }
LABEL_23:
      operator delete(v10);
      if ((SHIBYTE(v9.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_16:
        if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_18;
        }
        goto LABEL_17;
      }
      goto LABEL_24;
    }
  }
  else if ((v13 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v12);
  if (v11 < 0) {
    goto LABEL_23;
  }
LABEL_15:
  if ((SHIBYTE(v9.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_16;
  }
LABEL_24:
  operator delete(v9.__r_.__value_.__l.__data_);
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_17:
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_18:
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
}

void sub_1A614BD50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,void *a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a28 < 0)
  {
    operator delete(__p);
    if ((a34 & 0x80000000) == 0)
    {
LABEL_3:
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a35, a36);
      if ((a43 & 0x80000000) == 0)
      {
LABEL_8:
        std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v44 - 80);
        if (v43)
        {
          dispatch_group_leave(v43);
          dispatch_release(v43);
        }
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a38);
      goto LABEL_8;
    }
  }
  else if ((a34 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a29);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a35, a36);
  if ((a43 & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void INTTrace::stopReader_sync(INTTrace *this)
{
  uint64_t v2 = (abm::trace::TraceReader *)*((void *)this + 27);
  if (!v2) {
    goto LABEL_7;
  }
  char v3 = abm::trace::TraceReader::stop(v2);
  uint64_t v4 = *((void *)this + 5);
  if (v3)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Succeeded stopping reader.", v5, 2u);
      if (!*((unsigned char *)this + 248)) {
        return;
      }
      goto LABEL_8;
    }
LABEL_7:
    if (!*((unsigned char *)this + 248)) {
      return;
    }
    goto LABEL_8;
  }
  if (!os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR)) {
    goto LABEL_7;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Failed to stop reader", buf, 2u);
  if (!*((unsigned char *)this + 248)) {
    return;
  }
LABEL_8:
  dispatch_group_leave(*((dispatch_group_t *)this + 18));
  *((unsigned char *)this + 248) = 0;
}

void INTTrace::start_sync(INTTrace *this, group *a2)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((int *)this + 38);
    if (v5 > 7) {
      uint64_t v6 = "Unknown";
    }
    else {
      uint64_t v6 = off_1E5C47A78[v5];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Starting BB Trace with mode: %s", buf, 0xCu);
  }
  if (!*((unsigned char *)this + 260)) {
    INTTrace::prepare_sync(this);
  }
  if (!*((void *)this + 38)) {
    goto LABEL_10;
  }
  char v78 = 0;
  LOBYTE(v77) = 0;
  Timestamp::Timestamp((Timestamp *)v75);
  char v74 = 0;
  LOWORD(v73) = 0;
  LOBYTE(v72) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v75, v76);
  if (v78 < 0)
  {
    operator delete(v77);
    if (!*((void *)this + 40)) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_10:
    if (!*((void *)this + 40)) {
      goto LABEL_14;
    }
  }
  char v71 = 0;
  LOBYTE(v70) = 0;
  Timestamp::Timestamp((Timestamp *)v68);
  char v67 = 0;
  LOBYTE(v66) = 0;
  char v65 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v68, v69);
  if (v71 < 0) {
    operator delete(v70);
  }
LABEL_14:
  uint64_t v7 = *((void *)this + 29);
  if (!v7)
  {
    std::string v9 = *((void *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Trace Command Driver is creating!", buf, 2u);
    }
    uint64_t v10 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    uint64_t v11 = off_1EB5EE540;
    if (!off_1EB5EE540)
    {
      CommandDriverFactory::create_default_global((uint64_t *)buf, v10);
      long long v12 = *(_OWORD *)buf;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      char v13 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
      off_1EB5EE540 = v12;
      if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
      long long v14 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      uint64_t v11 = off_1EB5EE540;
    }
    uint64_t v61 = v11;
    uint64_t v62 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
    if (*(&off_1EB5EE540 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE540 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v11 + 136))(&v63, v11);
    long long v15 = v63;
    long long v63 = 0uLL;
    uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 30);
    *(_OWORD *)((char *)this + 232) = v15;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    char v17 = (std::__shared_weak_count *)*((void *)&v63 + 1);
    if (*((void *)&v63 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v63 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    if (v62 && !atomic_fetch_add(&v62->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
    if (!*((void *)this + 29))
    {
      char v36 = GetOsLogContext()[1];
      if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl(&dword_1A609F000, v36, OS_LOG_TYPE_FAULT, "Trace command driver must be present!", buf, 2u);
      }
      uint64_t v37 = GetOsLogContext()[1];
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = "ABM ASSERT";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "fTraceCommandDriver";
        __int16 v80 = 2080;
        int v81 = "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHelper/Server/"
              "Tasks/Wireless/Trace/INTTrace/INTTrace.cpp";
        __int16 v82 = 1024;
        int v83 = 830;
        _os_log_fault_impl(&dword_1A609F000, v37, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", buf, 0x26u);
      }
      __break(1u);
      return;
    }
    size_t v18 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v18 || (uint64_t v19 = *((void *)this + 9), (v20 = std::__shared_weak_count::lock(v18)) == 0)) {
      std::__throw_bad_weak_ptr[abi:ne180100]();
    }
    uint64_t v21 = v20;
    p_shared_weak_owners = &v20->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v21);
    }
    memset(buf, 170, 16);
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_15_0;
    aBlock[4] = this;
    void aBlock[5] = v19;
    int v59 = v21;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    gr_name = a2->gr_name;
    dispatch_object_t v60 = (dispatch_object_t)gr_name;
    if (gr_name) {
      dispatch_retain((dispatch_object_t)gr_name);
    }
    uint64_t v24 = _Block_copy(aBlock);
    uint64_t v25 = *((void *)this + 11);
    if (v25) {
      dispatch_retain(*((dispatch_object_t *)this + 11));
    }
    *(void *)long long buf = v24;
    *(void *)&uint8_t buf[8] = v25;
    *(void *)&long long v63 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v56[0] = MEMORY[0x1E4F143A8];
    v56[1] = 1174405120;
    v56[2] = ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke_16;
    v56[3] = &__block_descriptor_tmp_21_1;
    v56[4] = this;
    v56[5] = v19;
    uint64_t v57 = v21;
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    char v26 = _Block_copy(v56);
    size_t v27 = *((void *)this + 11);
    if (v27) {
      dispatch_retain(*((dispatch_object_t *)this + 11));
    }
    *(void *)&long long v63 = v26;
    *((void *)&v63 + 1) = v27;
    uint64_t v28 = *((void *)this + 29);
    if (v24)
    {
      std::string v54 = _Block_copy(v24);
      dispatch_object_t object = v25;
      if (!v25) {
        goto LABEL_53;
      }
    }
    else
    {
      std::string v54 = 0;
      dispatch_object_t object = v25;
      if (!v25)
      {
LABEL_53:
        (*(void (**)(uint64_t, void **))(*(void *)v28 + 112))(v28, &v54);
        if (object) {
          dispatch_release(object);
        }
        if (v54) {
          _Block_release(v54);
        }
        uint64_t v29 = *((void *)this + 29);
        if (v26)
        {
          BOOL v52 = _Block_copy(v26);
          dispatch_object_t v53 = v27;
          if (!v27)
          {
LABEL_60:
            (*(void (**)(uint64_t, void **))(*(void *)v29 + 120))(v29, &v52);
            if (v53) {
              dispatch_release(v53);
            }
            if (v52) {
              _Block_release(v52);
            }
            if (v27) {
              dispatch_release(v27);
            }
            if (v26) {
              _Block_release(v26);
            }
            if (v57) {
              std::__shared_weak_count::__release_weak(v57);
            }
            if (v25) {
              dispatch_release(v25);
            }
            if (v24) {
              _Block_release(v24);
            }
            if (v60) {
              dispatch_release(v60);
            }
            if (v59) {
              std::__shared_weak_count::__release_weak(v59);
            }
            std::__shared_weak_count::__release_weak(v21);
            goto LABEL_79;
          }
        }
        else
        {
          BOOL v52 = 0;
          dispatch_object_t v53 = v27;
          if (!v27) {
            goto LABEL_60;
          }
        }
        dispatch_retain(v27);
        goto LABEL_60;
      }
    }
    dispatch_retain(v25);
    goto LABEL_53;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v7 + 152))(v7) & 1) == 0)
  {
    uint64_t v8 = *((void *)this + 5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Trace Command Driver has not been started!", buf, 2u);
    }
    return;
  }
LABEL_79:
  if (*((char *)this + 207) < 0)
  {
    if (*((void *)this + 24)) {
      goto LABEL_81;
    }
  }
  else if (*((unsigned char *)this + 207))
  {
LABEL_81:
    uint64_t v30 = *((void *)this + 29);
    if (v30 && ((*(uint64_t (**)(uint64_t))(*(void *)v30 + 152))(v30) & 1) == 0) {
      (*(void (**)(void))(**((void **)this + 29) + 136))(*((void *)this + 29));
    }
    uint64_t v31 = a2->gr_name;
    uint64_t v51 = v31;
    if (v31) {
      dispatch_retain((dispatch_object_t)v31);
    }
    char v32 = (_OWORD *)((char *)this + 184);
    if (*((char *)this + 207) < 0)
    {
      std::string::__init_copy_ctor_external(&v50, *((const std::string::value_type **)this + 23), *((void *)this + 24));
    }
    else
    {
      *(_OWORD *)&v50.__r_.__value_.__l.__data_ = *v32;
      v50.__r_.__value_.__r.__words[2] = *((void *)this + 25);
    }
    char v34 = INTTrace::sendConfig_sync((uint64_t)this, (dispatch_object_t *)&v51, (const std::string::value_type *)&v50, 0, 0, 0);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    if (v31) {
      dispatch_release((dispatch_object_t)v31);
    }
    if ((v34 & 1) == 0)
    {
      long long v35 = *((void *)this + 5);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)this + 207) < 0) {
          char v32 = *(_OWORD **)v32;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v32;
        _os_log_error_impl(&dword_1A609F000, v35, OS_LOG_TYPE_ERROR, "Failed to send config: %s", buf, 0xCu);
      }
      return;
    }
    goto LABEL_97;
  }
  long long v33 = *((void *)this + 5);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1A609F000, v33, OS_LOG_TYPE_DEFAULT, "#I No config is given. Skip to send the configuration", buf, 2u);
  }
  if (!*((void *)this + 38)) {
    goto LABEL_99;
  }
LABEL_97:
  char v49 = 0;
  LOBYTE(v48) = 0;
  Timestamp::Timestamp((Timestamp *)v46);
  char v45 = 0;
  LOBYTE(v44) = 0;
  char v43 = 0;
  LOBYTE(v42) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v46, v47);
  if (v49 < 0)
  {
    operator delete(v48);
    if (!*((void *)this + 40)) {
      return;
    }
  }
  else
  {
LABEL_99:
    if (!*((void *)this + 40)) {
      return;
    }
  }
  char v41 = 0;
  LOBYTE(v40) = 0;
  Timestamp::Timestamp((Timestamp *)v38);
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v38, v39);
  if (v41 < 0) {
    operator delete(v40);
  }
}

void sub_1A614CA50(_Unwind_Exception *a1)
{
}

void ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke(void *a1, NSObject **a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  char v3 = (std::__shared_weak_count *)a1[6];
  if (!v3) {
    return;
  }
  uint64_t v5 = a1[4];
  uint64_t v6 = std::__shared_weak_count::lock(v3);
  if (!v6) {
    return;
  }
  uint64_t v7 = v6;
  uint64_t v8 = a1[5];
  if (atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v8) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
    if (!v8) {
      return;
    }
  }
  std::string v9 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I ARI Low Power enter event received", buf, 2u);
  }
  *(void *)&uint8_t buf[8] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v45 = 0xAAAAAAAAAAAAAALL;
  *(void *)long long buf = 0xAAAAAAAAAAAAAA00;
  if (!*(void *)(v5 + 304)) {
    goto LABEL_11;
  }
  char v43 = 0;
  LOBYTE(v42) = 0;
  Timestamp::Timestamp((Timestamp *)v40);
  char v39 = 0;
  LOBYTE(v38) = 0;
  char v37 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v40, v41);
  if (v43 < 0)
  {
    operator delete(v42);
    if (!*(void *)(v5 + 320)) {
      goto LABEL_15;
    }
  }
  else
  {
LABEL_11:
    if (!*(void *)(v5 + 320)) {
      goto LABEL_15;
    }
  }
  char v35 = 0;
  LOBYTE(v34) = 0;
  Timestamp::Timestamp((Timestamp *)v32);
  char v31 = 0;
  LOBYTE(v30) = 0;
  char v29 = 0;
  LOBYTE(v28) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v32, v33);
  if (v35 < 0) {
    operator delete(v34);
  }
LABEL_15:
  *(unsigned char *)(v5 + 296) = 1;
  int v10 = *(_DWORD *)(v5 + 264);
  if (v10)
  {
    int v11 = *(char *)(v5 + 295);
    if (v11 < 0)
    {
      if (*(void *)(v5 + 280)) {
        goto LABEL_18;
      }
    }
    else if (*(unsigned char *)(v5 + 295))
    {
LABEL_18:
      long long v12 = (uint8_t *)(v5 + 272);
      char v13 = *a2;
      dispatch_object_t v27 = v13;
      if (v13)
      {
        dispatch_retain(v13);
        LOBYTE(v11) = *(unsigned char *)(v5 + 295);
      }
      if ((v11 & 0x80) != 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v5 + 272), *(void *)(v5 + 280));
      }
      else
      {
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)v12;
        v26.__r_.__value_.__r.__words[2] = *(void *)(v5 + 288);
      }
      *(unsigned char *)(v5 + 296) = INTTrace::sendConfig_sync(v5, &v27, (const std::string::value_type *)&v26, v10 == 2, 1u, 0);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
      if (v13) {
        dispatch_release(v13);
      }
      if (buf != v12)
      {
        char v19 = *(unsigned char *)(v5 + 295);
        if (SHIBYTE(v45) < 0)
        {
          if (v19 >= 0) {
            uint32_t v20 = (void *)(v5 + 272);
          }
          else {
            uint32_t v20 = *(void **)(v5 + 272);
          }
          if (v19 >= 0) {
            size_t v21 = *(unsigned __int8 *)(v5 + 295);
          }
          else {
            size_t v21 = *(void *)(v5 + 280);
          }
          std::string::__assign_no_alias<false>((void **)buf, v20, v21);
        }
        else if ((*(unsigned char *)(v5 + 295) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(buf, *(void **)(v5 + 272), *(void *)(v5 + 280));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v12;
          uint64_t v45 = *(void *)(v5 + 288);
        }
      }
      goto LABEL_33;
    }
  }
  long long v14 = a1[7];
  dispatch_object_t v25 = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  char v24 = 4;
  strcpy((char *)v23, "Stop");
  *(unsigned char *)(v5 + 296) = INTTrace::sendConfig_sync(v5, &v25, (const std::string::value_type *)v23, 0, 1u, 0);
  if (v24 < 0) {
    operator delete(v23[0]);
  }
  if (v14) {
    dispatch_release(v14);
  }
  if (SHIBYTE(v45) < 0)
  {
    *(void *)&uint8_t buf[8] = 4;
    long long v15 = *(char **)buf;
  }
  else
  {
    HIBYTE(v45) = 4;
    long long v15 = (char *)buf;
  }
  strcpy(v15, "Stop");
  INTTrace::stopReader_sync((INTTrace *)v5);
LABEL_33:
  int v16 = *(unsigned __int8 *)(v5 + 296);
  char v17 = *(NSObject **)(v5 + 40);
  if (!v16)
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = buf;
      if (v45 < 0) {
        uint64_t v22 = *(uint8_t **)buf;
      }
      *(_DWORD *)long long v46 = 136315138;
      long long v47 = v22;
      _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, "Last sleep entry failed with config: %s", v46, 0xCu);
      if (SHIBYTE(v45) < 0) {
        goto LABEL_41;
      }
      return;
    }
LABEL_40:
    if ((SHIBYTE(v45) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_41;
  }
  if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_40;
  }
  size_t v18 = buf;
  if (v45 < 0) {
    size_t v18 = *(uint8_t **)buf;
  }
  *(_DWORD *)long long v46 = 136315138;
  long long v47 = v18;
  _os_log_debug_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEBUG, "#D Last sleep entry succeeded with config: %s", v46, 0xCu);
  if (SHIBYTE(v45) < 0) {
LABEL_41:
  }
    operator delete(*(void **)buf);
}

void sub_1A614D1D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (*(char *)(v55 - 89) < 0) {
    operator delete(*(void **)(v55 - 112));
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::sendConfig_sync(uint64_t a1, dispatch_object_t *a2, const std::string::value_type *a3, unsigned int a4, unsigned int a5, int a6)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  unsigned int v62 = *(_DWORD *)(a1 + 164);
  unint64_t v85 = 0;
  uint64_t v86 = 0;
  uint64_t v87 = 0;
  __int16 v82 = 0;
  size_t v83 = 0;
  uint8_t buf[23] = 19;
  uint64_t v84 = 0;
  strcpy(buf, "kKeyTraceConfigPath");
  defaults::bbtrace::get(buf, (std::string::size_type *)&v82);
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    std::string v9 = a3;
    if ((a3[23] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    std::string v9 = a3;
    if ((a3[23] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  std::string v9 = *(const char **)a3;
LABEL_3:
  KTLGetTraceConfigFilename((uint64_t *)buf, v9);
  int v10 = SHIBYTE(v84);
  uint64_t v81 = *(void *)&buf[16];
  long long v80 = *(_OWORD *)buf;
  if (v84 >= 0) {
    size_t v11 = HIBYTE(v84);
  }
  else {
    size_t v11 = v83;
  }
  int v12 = SHIBYTE(v81);
  if (v81 >= 0) {
    size_t v13 = HIBYTE(v81);
  }
  else {
    size_t v13 = *((void *)&v80 + 1);
  }
  unint64_t v14 = v13 + v11;
  memset(__dst, 170, sizeof(__dst));
  if (v13 + v11 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v61 = a2;
  if (v14 <= 0x16)
  {
    memset(__dst, 0, sizeof(__dst));
    long long v15 = __dst;
    HIBYTE(__dst[2]) = v13 + v11;
    if (!v11) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  uint64_t v25 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v14 | 7) != 0x17) {
    uint64_t v25 = v14 | 7;
  }
  uint64_t v26 = v25 + 1;
  long long v15 = (void **)operator new(v25 + 1);
  __dst[1] = (void *)(v13 + v11);
  _OWORD __dst[2] = (void *)(v26 | 0x8000000000000000);
  __dst[0] = v15;
  if (v11)
  {
LABEL_12:
    if (v10 >= 0) {
      int v16 = (void **)&v82;
    }
    else {
      int v16 = v82;
    }
    memmove(v15, v16, v11);
  }
LABEL_16:
  if (v13)
  {
    if (v12 >= 0) {
      char v17 = &v80;
    }
    else {
      char v17 = (long long *)v80;
    }
    memmove((char *)v15 + v11, v17, v13);
  }
  *((unsigned char *)v15 + v11 + v13) = 0;
  if (ctu::fs::load_file())
  {
    unint64_t v18 = v85;
    char v19 = v86;
    if (v86 == (char *)v85)
    {
      unint64_t v18 = (unint64_t)v86;
      char v29 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_69;
      }
    }
    else
    {
      int v20 = v86[v85 + ~v85];
      if (v20 == 13 || v20 == 10)
      {
        while (1)
        {
          uint64_t v86 = --v19;
          uint64_t v22 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1A609F000, v22, OS_LOG_TYPE_DEFAULT, "#I Trailing EOL character removed", buf, 2u);
            unint64_t v18 = v85;
            char v19 = v86;
          }
          if (v19 == (char *)v18) {
            break;
          }
          int v23 = v19[v18 + ~v18];
          if (v23 != 13 && v23 != 10) {
            goto LABEL_45;
          }
        }
        char v19 = (char *)v18;
      }
LABEL_45:
      char v29 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
LABEL_69:
        char v43 = *v61;
        if (*v61)
        {
          dispatch_retain(*v61);
          dispatch_group_enter(v43);
        }
        uint64_t v44 = *(std::__shared_weak_count **)(a1 + 80);
        if (!v44 || (uint64_t v45 = *(void *)(a1 + 72), (v46 = std::__shared_weak_count::lock(v44)) == 0)) {
          std::__throw_bad_weak_ptr[abi:ne180100]();
        }
        long long v47 = v46;
        atomic_fetch_add_explicit(&v46->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        if (atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v48 = *(void *)(a1 + 232);
          if (v48) {
            goto LABEL_75;
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v47);
          uint64_t v48 = *(void *)(a1 + 232);
          if (v48)
          {
LABEL_75:
            if (a6)
            {
              char v49 = dispatch_group_create();
              dispatch_group_enter(v49);
              uint64_t v48 = *(void *)(a1 + 232);
              char v74 = 0;
              uint64_t v75 = 0;
              uint64_t v76 = 0;
              std::string v50 = (const void *)v85;
              size_t v51 = (size_t)&v86[-v85];
              if (v86 == (char *)v85) {
                goto LABEL_84;
              }
            }
            else
            {
              char v49 = 0;
              char v74 = 0;
              uint64_t v75 = 0;
              uint64_t v76 = 0;
              std::string v50 = (const void *)v85;
              size_t v51 = (size_t)&v86[-v85];
              if (v86 == (char *)v85) {
                goto LABEL_84;
              }
            }
            if ((v51 & 0x8000000000000000) != 0) {
              std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
            }
            char v74 = operator new(v51);
            uint64_t v76 = (char *)v74 + v51;
            memcpy(v74, v50, v51);
            uint64_t v75 = (char *)v74 + v51;
LABEL_84:
            dispatch_object_t v73 = v49;
            if (v49) {
              dispatch_retain(v49);
            }
            aBlock[0] = MEMORY[0x1E4F143A8];
            aBlock[1] = 1174405120;
            aBlock[2] = ___ZN8INTTrace15sendConfig_syncEN8dispatch5groupENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEbbb_block_invoke;
            aBlock[3] = &__block_descriptor_tmp_24_0;
            aBlock[4] = a1;
            dispatch_group_t group = v43;
            if (v43)
            {
              dispatch_retain(v43);
              dispatch_group_enter(group);
            }
            uint64_t v68 = v45;
            size_t v69 = v47;
            atomic_fetch_add_explicit(&v47->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            if (a3[23] < 0) {
              std::string::__init_copy_ctor_external(&v70, *(const std::string::value_type **)a3, *((void *)a3 + 1));
            }
            else {
              std::string v70 = *(std::string *)a3;
            }
            dispatch_object_t v53 = _Block_copy(aBlock);
            std::string v54 = *(NSObject **)(a1 + 88);
            if (v54) {
              dispatch_retain(*(dispatch_object_t *)(a1 + 88));
            }
            char v71 = v53;
            dispatch_object_t object = v54;
            uint64_t v28 = (*(uint64_t (**)(uint64_t, void **, dispatch_object_t *, void, void, void, void **))(*(void *)v48 + 160))(v48, &v74, &v73, a4, a5, v62, &v71);
            if (object) {
              dispatch_release(object);
            }
            if (v71) {
              _Block_release(v71);
            }
            if (v73) {
              dispatch_release(v73);
            }
            if (v74)
            {
              uint64_t v75 = (char *)v74;
              operator delete(v74);
            }
            if (!a6 || (dispatch_time_t v55 = dispatch_time(0, 5000000000), !dispatch_group_wait(v49, v55)))
            {
              if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v70.__r_.__value_.__l.__data_);
              }
              if (v69) {
                std::__shared_weak_count::__release_weak(v69);
              }
              if (group)
              {
                dispatch_group_leave(group);
                if (group) {
                  dispatch_release(group);
                }
              }
              if (v49) {
                dispatch_release(v49);
              }
              goto LABEL_122;
            }
            CFStringRef v56 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              if (a3[23] < 0) {
                a3 = *(const std::string::value_type **)a3;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = a3;
              _os_log_error_impl(&dword_1A609F000, v56, OS_LOG_TYPE_ERROR, "Timeout waiting for confirmation while sending %s config", buf, 0xCu);
              if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_105:
                uint64_t v57 = v69;
                if (!v69) {
                  goto LABEL_107;
                }
                goto LABEL_106;
              }
            }
            else if ((SHIBYTE(v70.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_105;
            }
            operator delete(v70.__r_.__value_.__l.__data_);
            uint64_t v57 = v69;
            if (!v69)
            {
LABEL_107:
              if (group)
              {
                dispatch_group_leave(group);
                if (group) {
                  dispatch_release(group);
                }
              }
              if (v49) {
                dispatch_release(v49);
              }
LABEL_112:
              uint64_t v28 = 0;
LABEL_122:
              std::__shared_weak_count::__release_weak(v47);
              if (v43)
              {
                dispatch_group_leave(v43);
                dispatch_release(v43);
              }
              goto LABEL_124;
            }
LABEL_106:
            std::__shared_weak_count::__release_weak(v57);
            goto LABEL_107;
          }
        }
        BOOL v52 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl(&dword_1A609F000, v52, OS_LOG_TYPE_ERROR, "Trace command driver is not ready!", buf, 2u);
        }
        goto LABEL_112;
      }
    }
    unint64_t v30 = (unint64_t)&v19[-v18];
    if ((unint64_t)&v19[-v18] > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v30 > 0x16)
    {
      uint64_t v38 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v30 | 7) != 0x17) {
        uint64_t v38 = v30 | 7;
      }
      uint64_t v39 = v38 + 1;
      char v31 = operator new(v38 + 1);
      __p[1] = &v19[-v18];
      int64_t v78 = v39 | 0x8000000000000000;
      __p[0] = v31;
      if ((char *)v18 != v19) {
        goto LABEL_51;
      }
    }
    else
    {
      HIBYTE(v78) = (_BYTE)v19 - v18;
      char v31 = __p;
      if ((char *)v18 != v19)
      {
LABEL_51:
        if (v30 < 0x20 || (unint64_t)v31 - v18 < 0x20)
        {
          char v32 = v31;
          long long v33 = (char *)v18;
        }
        else
        {
          char v32 = (char *)v31 + (v30 & 0xFFFFFFFFFFFFFFE0);
          long long v33 = (char *)(v18 + (v30 & 0xFFFFFFFFFFFFFFE0));
          char v34 = (long long *)(v18 + 16);
          char v35 = v31 + 1;
          unint64_t v36 = v30 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            long long v37 = *v34;
            *(v35 - 1) = *(v34 - 1);
            _OWORD *v35 = v37;
            v34 += 2;
            v35 += 2;
            v36 -= 32;
          }
          while (v36);
          if (v30 == (v30 & 0xFFFFFFFFFFFFFFE0)) {
            goto LABEL_63;
          }
        }
        do
        {
          char v40 = *v33++;
          *v32++ = v40;
        }
        while (v33 != v19);
LABEL_63:
        *char v32 = 0;
        char v41 = __p;
        if (v78 < 0) {
          char v41 = (void **)__p[0];
        }
        CFTypeID v42 = __dst;
        if (SHIBYTE(__dst[2]) < 0) {
          CFTypeID v42 = (void **)__dst[0];
        }
        *(_DWORD *)long long buf = 136316162;
        *(void *)&uint8_t buf[4] = v41;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v42;
        *(_WORD *)&unsigned char buf[22] = 1024;
        unsigned int v89 = a4;
        __int16 v90 = 1024;
        unsigned int v91 = a5;
        __int16 v92 = 1024;
        unsigned int v93 = v62;
        _os_log_impl(&dword_1A609F000, v29, OS_LOG_TYPE_DEFAULT, "#I Sending trace config to BB: %s (%s), background tracing: %d, wait for idle indication: %d, privacy level: %d", buf, 0x28u);
        if (SHIBYTE(v78) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_69;
      }
    }
    char v32 = v31;
    goto LABEL_63;
  }
  dispatch_object_t v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    dispatch_object_t v60 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      dispatch_object_t v60 = (void **)__dst[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v60;
    _os_log_error_impl(&dword_1A609F000, v27, OS_LOG_TYPE_ERROR, "Failed to load from %s", buf, 0xCu);
  }
  uint64_t v28 = 0;
LABEL_124:
  if (SHIBYTE(__dst[2]) < 0)
  {
    operator delete(__dst[0]);
    if ((SHIBYTE(v81) & 0x80000000) == 0)
    {
LABEL_126:
      if ((SHIBYTE(v84) & 0x80000000) == 0) {
        goto LABEL_127;
      }
LABEL_132:
      operator delete(v82);
      uint64_t v58 = (char *)v85;
      if (!v85) {
        return v28;
      }
      goto LABEL_128;
    }
  }
  else if ((SHIBYTE(v81) & 0x80000000) == 0)
  {
    goto LABEL_126;
  }
  operator delete((void *)v80);
  if (SHIBYTE(v84) < 0) {
    goto LABEL_132;
  }
LABEL_127:
  uint64_t v58 = (char *)v85;
  if (v85)
  {
LABEL_128:
    uint64_t v86 = v58;
    operator delete(v58);
  }
  return v28;
}

void sub_1A614DBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t group, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,dispatch_object_t object,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a19)
  {
    std::__shared_weak_count::__release_weak(a19);
    size_t v51 = group;
    if (!group) {
      goto LABEL_6;
    }
  }
  else
  {
    size_t v51 = group;
    if (!group)
    {
LABEL_6:
      if (object)
      {
        dispatch_release(object);
        BOOL v52 = __p;
        if (!__p)
        {
LABEL_8:
          if (!v48) {
            goto LABEL_9;
          }
          goto LABEL_13;
        }
      }
      else
      {
        BOOL v52 = __p;
        if (!__p) {
          goto LABEL_8;
        }
      }
      operator delete(v52);
      if (!v48)
      {
LABEL_9:
        std::__shared_weak_count::__release_weak(v47);
        if (!v46)
        {
LABEL_15:
          if (a40 < 0) {
            operator delete(a35);
          }
          if (a46 < 0) {
            operator delete(a41);
          }
          if (*(char *)(v49 - 169) < 0) {
            operator delete(*(void **)(v49 - 192));
          }
          dispatch_object_t v53 = *(void **)(v49 - 168);
          if (v53)
          {
            *(void *)(v49 - 160) = v53;
            operator delete(v53);
          }
          _Unwind_Resume(a1);
        }
LABEL_14:
        dispatch_group_leave(v46);
        dispatch_release(v46);
        goto LABEL_15;
      }
LABEL_13:
      dispatch_release(v48);
      std::__shared_weak_count::__release_weak(v47);
      if (!v46) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  dispatch_group_leave(v51);
  dispatch_release(group);
  goto LABEL_6;
}

void __copy_helper_block_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE56c21_ZTSN8dispatch5groupE(void *a1, void *a2)
{
  uint64_t v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  char v3 = a2[7];
  a1[7] = v3;
  if (v3) {
    dispatch_retain(v3);
  }
}

void __destroy_helper_block_e8_40c29_ZTSNSt3__18weak_ptrI5TraceEE56c21_ZTSN8dispatch5groupE(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2) {
    dispatch_release(v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void ___ZN8INTTrace10start_syncEN8dispatch5groupE_block_invoke_16(void *a1)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2) {
    return;
  }
  uint64_t v3 = a1[4];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[5];
  if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!v6) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    if (!v6) {
      return;
    }
  }
  if (!*(void *)(v3 + 304)) {
    goto LABEL_9;
  }
  char v68 = 0;
  LOBYTE(v67) = 0;
  Timestamp::Timestamp((Timestamp *)v65);
  char v64 = 0;
  LOBYTE(v63) = 0;
  char v62 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v65, v66);
  if (v68 < 0)
  {
    operator delete(v67);
    if (!*(void *)(v3 + 320)) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_9:
    if (!*(void *)(v3 + 320)) {
      goto LABEL_13;
    }
  }
  char v60 = 0;
  LOBYTE(v59) = 0;
  Timestamp::Timestamp((Timestamp *)v57);
  char v56 = 0;
  LOBYTE(v55) = 0;
  char v54 = 0;
  LOBYTE(v53) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v57, v58);
  if (v60 < 0) {
    operator delete(v59);
  }
LABEL_13:
  if ((INTTrace::startReader_sync((INTTrace *)v3) & 1) == 0)
  {
    size_t v13 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v14 = "Failed to open TRACE transport during sleep exit";
    long long v15 = v13;
    uint32_t v16 = 2;
    goto LABEL_86;
  }
  if (!*(unsigned char *)(v3 + 296))
  {
    uint64_t v7 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (*(_DWORD *)(v3 + 356) != 2) {
        goto LABEL_61;
      }
LABEL_17:
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v74 = v8;
      long long v75 = v8;
      long long v72 = v8;
      long long v73 = v8;
      long long v70 = v8;
      long long v71 = v8;
      *(_OWORD *)long long buf = v8;
      std::string v9 = (const void *)*MEMORY[0x1E4F4C6E8];
      size_t v10 = strlen((const char *)*MEMORY[0x1E4F4C6E8]);
      if (v10 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v11 = v10;
      if (v10 >= 0x17)
      {
        uint64_t v17 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v10 | 7) != 0x17) {
          uint64_t v17 = v10 | 7;
        }
        uint64_t v18 = v17 + 1;
        p_dst = (long long *)operator new(v17 + 1);
        *((void *)&__dst + 1) = v11;
        unint64_t v52 = v18 | 0x8000000000000000;
        *(void *)&long long __dst = p_dst;
      }
      else
      {
        HIBYTE(v52) = v10;
        p_dst = &__dst;
        if (!v10)
        {
LABEL_27:
          *((unsigned char *)p_dst + v11) = 0;
          char v19 = (const void *)*MEMORY[0x1E4F4D038];
          size_t v20 = strlen((const char *)*MEMORY[0x1E4F4D038]);
          if (v20 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          size_t v21 = v20;
          if (v20 >= 0x17)
          {
            uint64_t v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v20 | 7) != 0x17) {
              uint64_t v23 = v20 | 7;
            }
            uint64_t v24 = v23 + 1;
            uint64_t v22 = operator new(v23 + 1);
            *((void *)&v49 + 1) = v21;
            unint64_t v50 = v24 | 0x8000000000000000;
            *(void *)&long long v49 = v22;
          }
          else
          {
            HIBYTE(v50) = v20;
            uint64_t v22 = &v49;
            if (!v20)
            {
LABEL_35:
              v22[v21] = 0;
              uint64_t v25 = (char *)operator new(0x28uLL);
              long long v47 = v25;
              long long v48 = xmmword_1A61F7FF0;
              strcpy(v25, "Detected failure on last LPM entry");
              Timestamp::Timestamp((Timestamp *)v43);
              Timestamp::asString((uint64_t)v43, 0, 9, v45);
              char v42 = 0;
              LOBYTE(v41) = 0;
              ResetInfo::ResetInfo((std::string *)buf, &__dst, &v49, (long long *)&v47, (uint64_t)v45, 7, &v41);
              if (v46 < 0) {
                operator delete(v45[0]);
              }
              std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v43, v44);
              operator delete(v25);
              if (SHIBYTE(v50) < 0)
              {
                operator delete((void *)v49);
                if ((SHIBYTE(v52) & 0x80000000) == 0)
                {
LABEL_39:
                  uint64_t v26 = *(NSObject **)(v3 + 40);
                  if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_41;
                  }
                  goto LABEL_40;
                }
              }
              else if ((SHIBYTE(v52) & 0x80000000) == 0)
              {
                goto LABEL_39;
              }
              operator delete((void *)__dst);
              uint64_t v26 = *(NSObject **)(v3 + 40);
              if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
LABEL_41:
                ResetInfo::ResetInfo(&v34, (long long *)buf);
                INTTrace::commandResetModem_sync(v3, (long long *)&v34);
                if (v40 < 0)
                {
                  operator delete(v39);
                  if ((v38 & 0x80000000) == 0)
                  {
LABEL_43:
                    if ((v36 & 0x80000000) == 0) {
                      goto LABEL_44;
                    }
                    goto LABEL_55;
                  }
                }
                else if ((v38 & 0x80000000) == 0)
                {
                  goto LABEL_43;
                }
                operator delete(v37);
                if ((v36 & 0x80000000) == 0)
                {
LABEL_44:
                  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_45;
                  }
                  goto LABEL_56;
                }
LABEL_55:
                operator delete(v35);
                if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_45:
                  if ((SHIBYTE(v75) & 0x80000000) == 0) {
                    goto LABEL_46;
                  }
                  goto LABEL_57;
                }
LABEL_56:
                operator delete(v34.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v75) & 0x80000000) == 0)
                {
LABEL_46:
                  if ((SBYTE7(v73) & 0x80000000) == 0) {
                    goto LABEL_47;
                  }
                  goto LABEL_58;
                }
LABEL_57:
                operator delete(*((void **)&v74 + 1));
                if ((SBYTE7(v73) & 0x80000000) == 0)
                {
LABEL_47:
                  if ((SHIBYTE(v71) & 0x80000000) == 0) {
                    goto LABEL_48;
                  }
                  goto LABEL_59;
                }
LABEL_58:
                operator delete((void *)v72);
                if ((SHIBYTE(v71) & 0x80000000) == 0)
                {
LABEL_48:
                  if ((SBYTE7(v70) & 0x80000000) == 0) {
                    goto LABEL_61;
                  }
LABEL_60:
                  operator delete(*(void **)buf);
                  goto LABEL_61;
                }
LABEL_59:
                operator delete(*((void **)&v70 + 1));
                if ((SBYTE7(v70) & 0x80000000) == 0) {
                  goto LABEL_61;
                }
                goto LABEL_60;
              }
LABEL_40:
              LOWORD(__dst) = 0;
              _os_log_impl(&dword_1A609F000, v26, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for LPM Entry Failure", (uint8_t *)&__dst, 2u);
              goto LABEL_41;
            }
          }
          memmove(v22, v19, v21);
          goto LABEL_35;
        }
      }
      memmove(p_dst, v9, v11);
      goto LABEL_27;
    }
    *(_WORD *)long long buf = 0;
    _os_log_error_impl(&dword_1A609F000, v7, OS_LOG_TYPE_ERROR, "Detected failure on last LPM entry", buf, 2u);
    if (*(_DWORD *)(v3 + 356) == 2) {
      goto LABEL_17;
    }
  }
LABEL_61:
  int v27 = *(char *)(v3 + 207);
  if (v27 < 0)
  {
    if (!*(void *)(v3 + 192)) {
      return;
    }
  }
  else if (!*(unsigned char *)(v3 + 207))
  {
    return;
  }
  uint64_t v28 = *(NSObject **)(v3 + 144);
  dispatch_object_t v33 = v28;
  if (v28)
  {
    dispatch_retain(v28);
    LOBYTE(v27) = *(unsigned char *)(v3 + 207);
  }
  char v29 = (_OWORD *)(v3 + 184);
  if ((v27 & 0x80) != 0)
  {
    std::string::__init_copy_ctor_external(&v32, *(const std::string::value_type **)(v3 + 184), *(void *)(v3 + 192));
  }
  else
  {
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *v29;
    v32.__r_.__value_.__r.__words[2] = *(void *)(v3 + 200);
  }
  char v30 = INTTrace::sendConfig_sync(v3, &v33, (const std::string::value_type *)&v32, 0, 0, 0);
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (v28) {
    dispatch_release(v28);
  }
  char v31 = *(NSObject **)(v3 + 40);
  if ((v30 & 1) == 0)
  {
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(v3 + 207) < 0) {
      char v29 = *(_OWORD **)v29;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v29;
    unint64_t v14 = "Failed to send config: %s";
    long long v15 = v31;
    uint32_t v16 = 12;
LABEL_86:
    _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, v14, buf, v16);
    return;
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(v3 + 207) < 0) {
      char v29 = *(_OWORD **)v29;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v29;
    _os_log_debug_impl(&dword_1A609F000, v31, OS_LOG_TYPE_DEBUG, "#D Succeeded sending config: %s", buf, 0xCu);
  }
}

void sub_1A614E520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  ResetInfo::~ResetInfo((void **)va);
  ResetInfo::~ResetInfo((void **)(v6 - 192));
  _Unwind_Resume(a1);
}

void sub_1A614E53C(_Unwind_Exception *a1)
{
  ResetInfo::~ResetInfo((void **)(v1 - 192));
  _Unwind_Resume(a1);
}

void sub_1A614E550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a31, (void *)a32);
  operator delete(v54);
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a54 < 0)
  {
    operator delete(a49);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t INTTrace::sendFlushRequest_sync(INTTrace *this)
{
  uint64_t result = *((void *)this + 29);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 29) + 168);
      return v3();
    }
  }
  return result;
}

void ___ZN8INTTrace15sendConfig_syncEN8dispatch5groupENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEbbb_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    uint64_t v45 = v6;
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 48))
      {
        uint64_t v8 = *a2;
        if (*a2) {
          std::string v9 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
        }
        else {
          std::string v9 = 0;
        }
        size_t v10 = *(NSObject **)(v5 + 40);
        if (v9)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v8;
            _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to send config: %@", (uint8_t *)&buf, 0xCu);
          }
          *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v51 = v11;
          long long v52 = v11;
          long long v49 = v11;
          long long v50 = v11;
          long long v47 = v11;
          long long v48 = v11;
          long long buf = v11;
          int v12 = (const void *)*MEMORY[0x1E4F4C6E8];
          size_t v13 = strlen((const char *)*MEMORY[0x1E4F4C6E8]);
          if (v13 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          size_t v14 = v13;
          if (v13 >= 0x17)
          {
            uint64_t v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v13 | 7) != 0x17) {
              uint64_t v17 = v13 | 7;
            }
            uint64_t v18 = v17 + 1;
            p_dst = (long long *)operator new(v17 + 1);
            *((void *)&__dst + 1) = v14;
            unint64_t v43 = v18 | 0x8000000000000000;
            *(void *)&long long __dst = p_dst;
          }
          else
          {
            HIBYTE(v43) = v13;
            p_dst = &__dst;
            if (!v13)
            {
LABEL_22:
              *((unsigned char *)p_dst + v14) = 0;
              char v19 = (const void *)*MEMORY[0x1E4F4D038];
              size_t v20 = strlen((const char *)*MEMORY[0x1E4F4D038]);
              if (v20 > 0x7FFFFFFFFFFFFFF7) {
                std::string::__throw_length_error[abi:ne180100]();
              }
              size_t v21 = v20;
              if (v20 >= 0x17)
              {
                uint64_t v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v20 | 7) != 0x17) {
                  uint64_t v23 = v20 | 7;
                }
                uint64_t v24 = v23 + 1;
                uint64_t v22 = operator new(v23 + 1);
                *((void *)&v40 + 1) = v21;
                unint64_t v41 = v24 | 0x8000000000000000;
                *(void *)&long long v40 = v22;
              }
              else
              {
                HIBYTE(v41) = v20;
                uint64_t v22 = &v40;
                if (!v20)
                {
LABEL_30:
                  v22[v21] = 0;
                  v39[23] = 21;
                  strcpy(v39, "Failed to send config");
                  Timestamp::Timestamp((Timestamp *)v35);
                  Timestamp::asString((uint64_t)v35, 0, 9, __p);
                  char v34 = 0;
                  LOBYTE(v33) = 0;
                  ResetInfo::ResetInfo((std::string *)&buf, &__dst, &v40, (long long *)v39, (uint64_t)__p, 7, &v33);
                  if (v38 < 0)
                  {
                    operator delete(__p[0]);
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v35, v36);
                    if ((SHIBYTE(v41) & 0x80000000) == 0)
                    {
LABEL_32:
                      if ((SHIBYTE(v43) & 0x80000000) == 0) {
                        goto LABEL_33;
                      }
                      goto LABEL_37;
                    }
                  }
                  else
                  {
                    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v35, v36);
                    if ((SHIBYTE(v41) & 0x80000000) == 0) {
                      goto LABEL_32;
                    }
                  }
                  operator delete((void *)v40);
                  if ((SHIBYTE(v43) & 0x80000000) == 0)
                  {
LABEL_33:
                    if ((*(_DWORD *)(v5 + 356) - 1) > 1)
                    {
LABEL_44:
                      if ((SHIBYTE(v52) & 0x80000000) == 0) {
                        goto LABEL_45;
                      }
                      goto LABEL_54;
                    }
LABEL_38:
                    uint64_t v25 = *(NSObject **)(v5 + 40);
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(__dst) = 0;
                      _os_log_impl(&dword_1A609F000, v25, OS_LOG_TYPE_DEFAULT, "#I Triggering modem reset for failure to send config", (uint8_t *)&__dst, 2u);
                    }
                    ResetInfo::ResetInfo(&v26, &buf);
                    INTTrace::commandResetModem_sync(v5, (long long *)&v26);
                    if (v32 < 0)
                    {
                      operator delete(v31);
                      if ((v30 & 0x80000000) == 0)
                      {
LABEL_42:
                        if ((v28 & 0x80000000) == 0) {
                          goto LABEL_43;
                        }
                        goto LABEL_52;
                      }
                    }
                    else if ((v30 & 0x80000000) == 0)
                    {
                      goto LABEL_42;
                    }
                    operator delete(v29);
                    if ((v28 & 0x80000000) == 0)
                    {
LABEL_43:
                      if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_44;
                      }
                      goto LABEL_53;
                    }
LABEL_52:
                    operator delete(v27);
                    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_44;
                    }
LABEL_53:
                    operator delete(v26.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v52) & 0x80000000) == 0)
                    {
LABEL_45:
                      if ((SBYTE7(v50) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_55;
                    }
LABEL_54:
                    operator delete(*((void **)&v51 + 1));
                    if ((SBYTE7(v50) & 0x80000000) == 0)
                    {
LABEL_46:
                      if ((SHIBYTE(v48) & 0x80000000) == 0) {
                        goto LABEL_47;
                      }
                      goto LABEL_56;
                    }
LABEL_55:
                    operator delete((void *)v49);
                    if ((SHIBYTE(v48) & 0x80000000) == 0)
                    {
LABEL_47:
                      if ((SBYTE7(v47) & 0x80000000) == 0) {
                        goto LABEL_48;
                      }
                      goto LABEL_57;
                    }
LABEL_56:
                    operator delete(*((void **)&v47 + 1));
                    if ((SBYTE7(v47) & 0x80000000) == 0)
                    {
LABEL_48:
                      uint64_t v7 = v45;
                      if (!v45) {
                        return;
                      }
                      goto LABEL_58;
                    }
LABEL_57:
                    operator delete((void *)buf);
                    uint64_t v7 = v45;
                    if (!v45) {
                      return;
                    }
                    goto LABEL_58;
                  }
LABEL_37:
                  operator delete((void *)__dst);
                  if ((*(_DWORD *)(v5 + 356) - 1) > 1) {
                    goto LABEL_44;
                  }
                  goto LABEL_38;
                }
              }
              memmove(v22, v19, v21);
              goto LABEL_30;
            }
          }
          memmove(p_dst, v12, v14);
          goto LABEL_22;
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint32_t v16 = (void *)(a1 + 64);
          if (*(char *)(a1 + 87) < 0) {
            uint32_t v16 = (void *)*v16;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v16;
          _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Succeeded to send config - %s", (uint8_t *)&buf, 0xCu);
        }
      }
LABEL_58:
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A614EBF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ResetInfo::~ResetInfo((void **)va);
  ResetInfo::~ResetInfo((void **)(v2 - 192));
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 208);
  _Unwind_Resume(a1);
}

void sub_1A614EC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a27, a28);
  if (a44 < 0)
  {
    operator delete(a39);
    if ((a50 & 0x80000000) == 0)
    {
LABEL_5:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v50 - 208);
      _Unwind_Resume(a1);
    }
  }
  else if ((a50 & 0x80000000) == 0)
  {
    goto LABEL_5;
  }
  operator delete(a45);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v50 - 208);
  _Unwind_Resume(a1);
}

void sub_1A614ECAC(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 208);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(void *a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a2 + 40);
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = *(void *)(a2 + 56);
  a1[6] = *(void *)(a2 + 48);
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::string *)(a1 + 8);
  if (*(char *)(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 64);
    a1[10] = *(void *)(a2 + 80);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_1A614ED4C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 56);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(NSObject **)(v1 + 40);
  if (v4)
  {
    dispatch_group_leave(v4);
    uint64_t v5 = *(NSObject **)(v1 + 40);
    if (v5) {
      dispatch_release(v5);
    }
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c29_ZTSNSt3__18weak_ptrI5TraceEE64c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0)
  {
    operator delete(*(void **)(a1 + 64));
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
LABEL_3:
  }
    std::__shared_weak_count::__release_weak(v2);
LABEL_4:
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_release(v4);
    }
  }
}

void INTTrace::getStateAsDict_sync(uint64_t a1@<X0>, uint64_t a2@<X1>, xpc_object_t *a3@<X8>)
{
  *a3 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v7 = v6;
  uint64_t v8 = MEMORY[0x1E4F14590];
  if (v6)
  {
    *a3 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    *a3 = v7;
    if (!v7)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A6275E60](v7) == v8)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_8:
  *a3 = v9;
LABEL_9:
  xpc_release(v7);
  xpc_object_t v10 = *a3;
  if (MEMORY[0x1A6275E60](*a3) != v8)
  {
    long long v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "Failed to create state dump dictionary", (uint8_t *)&buf, 2u);
    }
    return;
  }
  if (*(unsigned char *)(a1 + 160)) {
    int v12 = "true";
  }
  else {
    int v12 = "false";
  }
  xpc_object_t v13 = xpc_string_create(v12);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  xpc_dictionary_set_value(v10, "Enabled", v13);
  xpc_object_t v14 = xpc_null_create();
  xpc_release(v13);
  xpc_release(v14);
  uint64_t v15 = *(int *)(a1 + 172);
  if (v15 > 3) {
    uint32_t v16 = "unknown";
  }
  else {
    uint32_t v16 = off_1E5C47A58[v15];
  }
  xpc_object_t v17 = xpc_string_create(v16);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  xpc_dictionary_set_value(v10, "Live_Filter_Setting", v17);
  xpc_object_t v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  uint64_t v19 = *(int *)(a1 + 152);
  if (v19 > 7) {
    size_t v20 = "Unknown";
  }
  else {
    size_t v20 = off_1E5C47A78[v19];
  }
  xpc_object_t v21 = xpc_string_create(v20);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_dictionary_set_value(v10, "Mode", v21);
  xpc_object_t v22 = xpc_null_create();
  xpc_release(v21);
  xpc_release(v22);
  int v23 = *(_DWORD *)(a1 + 156);
  if (v23 == 1)
  {
    uint64_t v24 = 9;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 9;
    qmemcpy(&buf, "Last_Used", 9);
  }
  else if (v23)
  {
    uint64_t v24 = 11;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 11;
    qmemcpy(&buf, "UnSpecified", 11);
  }
  else
  {
    uint64_t v24 = 7;
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 7;
    qmemcpy(&buf, "Default", 7);
  }
  buf.__r_.__value_.__s.__data_[v24] = 0;
  xpc_object_t v25 = xpc_string_create((const char *)&buf);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_dictionary_set_value(v10, "Reset_Mode_Boot", v25);
  xpc_object_t v26 = xpc_null_create();
  xpc_release(v25);
  xpc_release(v26);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  std::to_string(&buf, *(_DWORD *)(a1 + 208));
  std::string __p = buf;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v28 = xpc_string_create((const char *)p_p);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  xpc_object_t v29 = *a3;
  xpc_dictionary_set_value(*a3, "TraceOwnership", v28);
  xpc_object_t v30 = xpc_null_create();
  xpc_release(v28);
  xpc_release(v30);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  INTTrace::historyAsString_sync(a1, (char *)&buf);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_std::string buf = &buf;
  }
  else {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v32 = xpc_string_create((const char *)p_buf);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  xpc_dictionary_set_value(v29, "History", v32);
  xpc_object_t v33 = xpc_null_create();
  xpc_release(v32);
  xpc_release(v33);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    char v34 = (const char *)(a1 + 184);
    if ((*(char *)(a1 + 207) & 0x80000000) == 0) {
      goto LABEL_50;
    }
  }
  else
  {
    char v34 = (const char *)(a1 + 184);
    if ((*(char *)(a1 + 207) & 0x80000000) == 0) {
      goto LABEL_50;
    }
  }
  char v34 = *(const char **)v34;
LABEL_50:
  xpc_object_t v35 = xpc_string_create(v34);
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  xpc_dictionary_set_value(v29, "File", v35);
  xpc_object_t v36 = xpc_null_create();
  xpc_release(v35);
  xpc_release(v36);
  unsigned int v37 = *(_DWORD *)(a1 + 176);
  memset(&__p, 0, sizeof(__p));
  std::to_string(&buf, v37);
  std::string __p = buf;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v38 = &__p;
  }
  else {
    char v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v39 = xpc_string_create((const char *)v38);
  if (!v39) {
    xpc_object_t v39 = xpc_null_create();
  }
  xpc_object_t v40 = *a3;
  xpc_dictionary_set_value(*a3, "FileSize", v39);
  xpc_object_t v41 = xpc_null_create();
  xpc_release(v39);
  xpc_release(v41);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  capabilities::trace::asString();
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v42 = &buf;
  }
  else {
    char v42 = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v43 = xpc_string_create((const char *)v42);
  if (!v43) {
    xpc_object_t v43 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, "Enabled_During_Sleep", v43);
  xpc_object_t v44 = xpc_null_create();
  xpc_release(v43);
  xpc_release(v44);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    uint64_t v45 = (const char *)(a1 + 272);
    if ((*(char *)(a1 + 295) & 0x80000000) == 0) {
      goto LABEL_66;
    }
LABEL_88:
    uint64_t v45 = *(const char **)v45;
    goto LABEL_66;
  }
  uint64_t v45 = (const char *)(a1 + 272);
  if (*(char *)(a1 + 295) < 0) {
    goto LABEL_88;
  }
LABEL_66:
  xpc_object_t v46 = xpc_string_create(v45);
  if (!v46) {
    xpc_object_t v46 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, "File_Sleep", v46);
  xpc_object_t v47 = xpc_null_create();
  xpc_release(v46);
  xpc_release(v47);
  uint64_t v48 = *(int *)(a1 + 356);
  if (v48 > 2) {
    long long v49 = "Unknown";
  }
  else {
    long long v49 = off_1E5C47AF8[v48];
  }
  xpc_object_t v50 = xpc_string_create(v49);
  if (!v50) {
    xpc_object_t v50 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, "Error_Handling", v50);
  xpc_object_t v51 = xpc_null_create();
  xpc_release(v50);
  xpc_release(v51);
  if (*(unsigned char *)(a1 + 360)) {
    long long v52 = "true";
  }
  else {
    long long v52 = "false";
  }
  xpc_object_t v53 = xpc_string_create(v52);
  if (!v53) {
    xpc_object_t v53 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, "Retain_Previous_Trace", v53);
  xpc_object_t v54 = xpc_null_create();
  xpc_release(v53);
  xpc_release(v54);
  if (*(char *)(a2 + 23) >= 0) {
    dispatch_time_t v55 = (const char *)a2;
  }
  else {
    dispatch_time_t v55 = *(const char **)a2;
  }
  xpc_object_t v56 = xpc_string_create(v55);
  if (!v56) {
    xpc_object_t v56 = xpc_null_create();
  }
  xpc_dictionary_set_value(v40, (const char *)*MEMORY[0x1E4F4CA90], v56);
  xpc_object_t v57 = xpc_null_create();
  xpc_release(v56);
  xpc_release(v57);
}

void sub_1A614F554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  xpc::dict::~dict(v14);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::historyAsString_sync@<X0>(uint64_t this@<X0>, char *a2@<X8>)
{
  uint64_t v2 = a2;
  if (!*(_DWORD *)(this + 168))
  {
    a2[23] = 8;
    strcpy(a2, "Infinite");
    return this;
  }
  uint64_t v3 = this;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[7] = v4;
  v23[8] = v4;
  void v23[5] = v4;
  v23[6] = v4;
  v23[3] = v4;
  v23[4] = v4;
  v23[1] = v4;
  v23[2] = v4;
  long long v22 = v4;
  v23[0] = v4;
  *(_OWORD *)size_t v20 = v4;
  long long v21 = v4;
  long long v18 = v4;
  long long v19 = v4;
  long long v16 = v4;
  long long v17 = v4;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v16);
  std::to_string(&v25, *(_DWORD *)(v3 + 168));
  std::string __p = v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  xpc_object_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)p_p, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)" MB", 3);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    char v8 = BYTE8(v22);
    if ((BYTE8(v22) & 0x10) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    uint64_t v10 = v22;
    if ((unint64_t)v22 < *((void *)&v19 + 1))
    {
      *(void *)&long long v22 = *((void *)&v19 + 1);
      uint64_t v10 = *((void *)&v19 + 1);
    }
    long long v11 = (const void *)v19;
    size_t v9 = v10 - v19;
    if ((unint64_t)(v10 - v19) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_28;
    }
    goto LABEL_17;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  char v8 = BYTE8(v22);
  if ((BYTE8(v22) & 0x10) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if ((v8 & 8) == 0)
  {
    size_t v9 = 0;
    v2[23] = 0;
    goto LABEL_24;
  }
  long long v11 = (const void *)*((void *)&v17 + 1);
  size_t v9 = *((void *)&v18 + 1) - *((void *)&v17 + 1);
  if (*((void *)&v18 + 1) - *((void *)&v17 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_28:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_17:
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    xpc_object_t v14 = (char *)operator new(v12 + 1);
    *((void *)v2 + 1) = v9;
    *((void *)v2 + 2) = v13 | 0x8000000000000000;
    *(void *)uint64_t v2 = v14;
    uint64_t v2 = v14;
  }
  else
  {
    v2[23] = v9;
    if (!v9) {
      goto LABEL_24;
    }
  }
  memmove(v2, v11, v9);
LABEL_24:
  v2[v9] = 0;
  *(void *)&long long v16 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v16 + *(void *)(v16 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v16 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62751A0](v23);
}

void sub_1A614F928(void *a1)
{
}

void sub_1A614F934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::dumpState_sync@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  unint64_t v106 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v105[7] = v6;
  v105[8] = v6;
  v105[5] = v6;
  v105[6] = v6;
  v105[3] = v6;
  v105[4] = v6;
  v105[1] = v6;
  v105[2] = v6;
  long long v104 = v6;
  v105[0] = v6;
  *(_OWORD *)uint64_t v102 = v6;
  long long v103 = v6;
  long long v100 = v6;
  long long v101 = v6;
  long long v98 = v6;
  long long v99 = v6;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v98);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v98, (uint64_t)"\n----- BB Trace Dump State -----\n", 33);
  xpc_object_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v98, (uint64_t)"Trace Enabled         : ", 24);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) |= 1u;
  char v8 = (void *)std::ostream::operator<<();
  v107.__r_.__value_.__s.__data_[0] = 10;
  size_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)&v107, 1);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"Live Enabled Setting  : ", 24);
  uint64_t v11 = *(int *)(a1 + 172);
  if (v11 > 3) {
    uint64_t v12 = "unknown";
  }
  else {
    uint64_t v12 = off_1E5C47A58[v11];
  }
  size_t v13 = strlen(v12);
  xpc_object_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v12, v13);
  v107.__r_.__value_.__s.__data_[0] = 10;
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)&v107, 1);
  long long v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"Mode                  : ", 24);
  uint64_t v17 = *(int *)(a1 + 152);
  if (v17 > 7) {
    long long v18 = "Unknown";
  }
  else {
    long long v18 = off_1E5C47A78[v17];
  }
  size_t v19 = strlen(v18);
  size_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v18, v19);
  v107.__r_.__value_.__s.__data_[0] = 10;
  long long v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)&v107, 1);
  long long v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"Reset Mode On Reboot  : ", 24);
  int v23 = *(_DWORD *)(a1 + 156);
  if (v23 == 1)
  {
    uint64_t v24 = 9;
    char v97 = 9;
    qmemcpy(v96, "Last_Used", 9);
  }
  else if (v23)
  {
    uint64_t v24 = 11;
    char v97 = 11;
    qmemcpy(v96, "UnSpecified", 11);
  }
  else
  {
    uint64_t v24 = 7;
    char v97 = 7;
    qmemcpy(v96, "Default", 7);
  }
  *((unsigned char *)v96 + v24) = 0;
  std::string v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v96, v24);
  v107.__r_.__value_.__s.__data_[0] = 10;
  xpc_object_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)&v107, 1);
  int v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"Trace Ownership       : ", 24);
  std::to_string(&v107, *(_DWORD *)(a1 + 208));
  std::string v95 = v107;
  if ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v28 = &v95;
  }
  else {
    xpc_object_t v28 = (std::string *)v95.__r_.__value_.__r.__words[0];
  }
  if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v95.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v95.__r_.__value_.__l.__size_;
  }
  xpc_object_t v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)v28, size);
  v107.__r_.__value_.__s.__data_[0] = 10;
  char v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)&v107, 1);
  xpc_object_t v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"History (MB)          : ", 24);
  INTTrace::historyAsString_sync(a1, (char *)v93);
  if ((v94 & 0x80u) == 0) {
    xpc_object_t v33 = v93;
  }
  else {
    xpc_object_t v33 = (void **)v93[0];
  }
  if ((v94 & 0x80u) == 0) {
    uint64_t v34 = v94;
  }
  else {
    uint64_t v34 = (uint64_t)v93[1];
  }
  xpc_object_t v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)v33, v34);
  v107.__r_.__value_.__s.__data_[0] = 10;
  xpc_object_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)&v107, 1);
  unsigned int v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"Privacy Level         : ", 24);
  uint64_t v38 = *(int *)(a1 + 164);
  if (v38 > 3) {
    xpc_object_t v39 = "Unknown";
  }
  else {
    xpc_object_t v39 = off_1E5C47A38[v38];
  }
  size_t v40 = strlen(v39);
  xpc_object_t v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)v39, v40);
  v107.__r_.__value_.__s.__data_[0] = 10;
  char v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)&v107, 1);
  xpc_object_t v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"Config File           : ", 24);
  int v44 = *(char *)(a1 + 207);
  if (v44 >= 0) {
    uint64_t v45 = a1 + 184;
  }
  else {
    uint64_t v45 = *(void *)(a1 + 184);
  }
  if (v44 >= 0) {
    uint64_t v46 = *(unsigned __int8 *)(a1 + 207);
  }
  else {
    uint64_t v46 = *(void *)(a1 + 192);
  }
  xpc_object_t v47 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, v45, v46);
  v107.__r_.__value_.__s.__data_[0] = 10;
  uint64_t v48 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)&v107, 1);
  long long v49 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)"Max memory file count : ", 24);
  unsigned int v50 = *(_DWORD *)(a1 + 180);
  if (v50)
  {
    std::to_string(&v107, v50);
    std::string __p = v107;
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&__p, "No limit");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v52 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v52 = __p.__r_.__value_.__l.__size_;
  }
  xpc_object_t v53 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, (uint64_t)p_p, v52);
  v107.__r_.__value_.__s.__data_[0] = 10;
  xpc_object_t v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v53, (uint64_t)&v107, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)"File Size (Bytes)     : ", 24);
  dispatch_time_t v55 = (void *)std::ostream::operator<<();
  v107.__r_.__value_.__s.__data_[0] = 10;
  xpc_object_t v56 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)&v107, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"Transport Read Size   : ", 24);
  xpc_object_t v57 = (void *)std::ostream::operator<<();
  v107.__r_.__value_.__s.__data_[0] = 10;
  uint64_t v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)&v107, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)"Transport Read Count  : ", 24);
  int v59 = (void *)std::ostream::operator<<();
  v107.__r_.__value_.__s.__data_[0] = 10;
  char v60 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v59, (uint64_t)&v107, 1);
  uint64_t v61 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)"Sleep Trace Mode      : ", 24);
  capabilities::trace::asString();
  if ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v62 = &v107;
  }
  else {
    char v62 = (std::string *)v107.__r_.__value_.__r.__words[0];
  }
  if ((v107.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v63 = HIBYTE(v107.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v63 = v107.__r_.__value_.__l.__size_;
  }
  char v64 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v61, (uint64_t)v62, v63);
  char v108 = 10;
  char v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v64, (uint64_t)&v108, 1);
  std::string::size_type v66 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)"Sleep Config File     : ", 24);
  int v67 = *(char *)(a1 + 295);
  if (v67 >= 0) {
    uint64_t v68 = a1 + 272;
  }
  else {
    uint64_t v68 = *(void *)(a1 + 272);
  }
  if (v67 >= 0) {
    uint64_t v69 = *(unsigned __int8 *)(a1 + 295);
  }
  else {
    uint64_t v69 = *(void *)(a1 + 280);
  }
  long long v70 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v66, v68, v69);
  char v108 = 10;
  long long v71 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v70, (uint64_t)&v108, 1);
  long long v72 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v71, (uint64_t)"Trace Error Handling  : ", 24);
  uint64_t v73 = *(int *)(a1 + 356);
  if (v73 > 2) {
    long long v74 = "Unknown";
  }
  else {
    long long v74 = off_1E5C47AF8[v73];
  }
  size_t v75 = strlen(v74);
  uint64_t v76 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v72, (uint64_t)v74, v75);
  char v108 = 10;
  uint64_t v77 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v76, (uint64_t)&v108, 1);
  int64_t v78 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)"Retain Previous Trace : ", 24);
  *(_DWORD *)((char *)v78 + *(void *)(*v78 - 24) + 8) |= 1u;
  uint64_t v79 = (void *)std::ostream::operator<<();
  char v108 = 10;
  long long v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v79, (uint64_t)&v108, 1);
  uint64_t v81 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)"Reason                : ", 24);
  int v82 = *(char *)(a2 + 23);
  if (v82 >= 0) {
    uint64_t v83 = a2;
  }
  else {
    uint64_t v83 = *(void *)a2;
  }
  if (v82 >= 0) {
    uint64_t v84 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v84 = *(void *)(a2 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v81, v83, v84);
  if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v107.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_65:
      if (((char)v94 & 0x80000000) == 0) {
        goto LABEL_66;
      }
      goto LABEL_79;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_65;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (((char)v94 & 0x80000000) == 0)
  {
LABEL_66:
    if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_67;
    }
LABEL_80:
    operator delete(v95.__r_.__value_.__l.__data_);
    if ((v97 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    goto LABEL_81;
  }
LABEL_79:
  operator delete(v93[0]);
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_80;
  }
LABEL_67:
  if ((v97 & 0x80000000) == 0) {
    goto LABEL_68;
  }
LABEL_81:
  operator delete(v96[0]);
LABEL_68:
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v98, (uint64_t)"\n---------------------------------\n", 35);
  if ((BYTE8(v104) & 0x10) != 0)
  {
    uint64_t v86 = v104;
    if ((unint64_t)v104 < *((void *)&v101 + 1))
    {
      *(void *)&long long v104 = *((void *)&v101 + 1);
      uint64_t v86 = *((void *)&v101 + 1);
    }
    uint64_t v87 = (const void *)v101;
    size_t v85 = v86 - v101;
    if ((unint64_t)(v86 - v101) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_90;
    }
  }
  else
  {
    if ((BYTE8(v104) & 8) == 0)
    {
      size_t v85 = 0;
      a3[23] = 0;
      goto LABEL_86;
    }
    uint64_t v87 = (const void *)*((void *)&v99 + 1);
    size_t v85 = *((void *)&v100 + 1) - *((void *)&v99 + 1);
    if (*((void *)&v100 + 1) - *((void *)&v99 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_90:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v85 >= 0x17)
  {
    uint64_t v88 = (v85 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v85 | 7) != 0x17) {
      uint64_t v88 = v85 | 7;
    }
    uint64_t v89 = v88 + 1;
    __int16 v90 = operator new(v88 + 1);
    *((void *)a3 + 1) = v85;
    *((void *)a3 + 2) = v89 | 0x8000000000000000;
    *(void *)a3 = v90;
    a3 = v90;
    goto LABEL_85;
  }
  a3[23] = v85;
  if (v85) {
LABEL_85:
  }
    memmove(a3, v87, v85);
LABEL_86:
  a3[v85] = 0;
  *(void *)&long long v98 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v98 + *(void *)(v98 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  *((void *)&v98 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v103) < 0) {
    operator delete(v102[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62751A0](v105);
}

void sub_1A61501FC(void *a1)
{
}

void sub_1A6150208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a26 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  if ((a26 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a32 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a21);
  if ((a32 & 0x80000000) == 0)
  {
LABEL_5:
    std::ostringstream::~ostringstream((uint64_t)&a33);
    _Unwind_Resume(a1);
  }
LABEL_9:
  operator delete(a27);
  std::ostringstream::~ostringstream((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_1A6150328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t INTTrace::setPropEnabled_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(v21, 0, 28);
    char v23 = 7;
    strcpy((char *)v22, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    uint64_t v7 = defaults::get((char *)v22, a3, &buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)v22, (uint64_t)a3, (uint64_t)&buf, &v24);
      if (SHIBYTE(v21[6]) < 0) {
        operator delete(*(void **)&v21[1]);
      }
      *(std::string *)&v21[1] = v24;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v23 & 0x80000000) == 0)
      {
LABEL_8:
        if (!v7) {
          goto LABEL_9;
        }
        goto LABEL_21;
      }
    }
    else if ((v23 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(v22[0]);
    if (!v7)
    {
LABEL_9:
      if ((SHIBYTE(v21[6]) & 0x80000000) == 0) {
        goto LABEL_10;
      }
      goto LABEL_22;
    }
LABEL_21:
    uint64_t v7 = util::convert<int>((const std::string *)&v21[1], v21, 0);
    if ((SHIBYTE(v21[6]) & 0x80000000) == 0)
    {
LABEL_10:
      if (v7) {
        goto LABEL_11;
      }
LABEL_23:
      xpc_object_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "Failed to get enabled property!", (uint8_t *)&buf, 2u);
      }
      return v7;
    }
LABEL_22:
    operator delete(*(void **)&v21[1]);
    if (v7)
    {
LABEL_11:
      int v8 = v21[0];
      int v9 = *(unsigned __int8 *)(a1 + 160);
      uint64_t v10 = *(NSObject **)(a1 + 40);
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v8 == v9)
      {
        if (v11)
        {
          uint64_t v12 = "enabled";
          if (!v9) {
            uint64_t v12 = "disabled";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
          _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I It is already %s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        if (v11)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v9;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
          _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Setting enable from %d to %d", (uint8_t *)&buf, 0xEu);
          int v8 = v21[0];
        }
        *(unsigned char *)(a1 + 160) = v8 != 0;
        if (v8)
        {
          long long v16 = *a2;
          size_t v20 = v16;
          if (v16) {
            dispatch_retain(v16);
          }
          INTTrace::start_sync((INTTrace *)a1, (group *)&v20);
          if (v16) {
            dispatch_release(v16);
          }
        }
        else if (*(void *)(a1 + 232))
        {
          uint64_t v17 = *a2;
          size_t v19 = v17;
          if (v17) {
            dispatch_retain(v17);
          }
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v19);
          if (v17) {
            dispatch_release(v17);
          }
          long long v18 = *(abm::trace::TraceReader **)(a1 + 216);
          if (v18)
          {
            if (*(_DWORD *)(a1 + 172) != 3) {
              abm::trace::TraceReader::clearFiles(v18);
            }
            std::shared_ptr<TraceFileCollection>::reset[abi:ne180100]((void *)(a1 + 216));
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
            std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](a1 + 216, (long long *)&buf);
            std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&buf);
          }
        }
      }
      return v7;
    }
    goto LABEL_23;
  }
  size_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v13, OS_LOG_TYPE_ERROR, "Failed to set enabled property!", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A61506A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropLiveFilterSetting_sync(uint64_t a1, char **a2, char *a3, const char *a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(&v52.gr_passwd, 0, 24);
    char v54 = 7;
    strcpy((char *)v53, "BBTrace");
    memset(buf, 0, 24);
    BOOL v7 = defaults::get((char *)v53, a3, (std::string *)buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)v53, (uint64_t)a3, (uint64_t)buf, &__dst);
      if (SHIBYTE(v52.gr_mem) < 0) {
        operator delete(v52.gr_passwd);
      }
      *(std::string *)&v52.gr_passwd = __dst;
    }
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if ((v54 & 0x80000000) == 0)
      {
LABEL_8:
        if (v7) {
          goto LABEL_9;
        }
        goto LABEL_21;
      }
    }
    else if ((v54 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(v53[0]);
    if (v7)
    {
LABEL_9:
      *(_DWORD *)std::string buf = -1431655766;
      int v8 = util::convert<int>((const std::string *)&v52.gr_passwd, buf, 0);
      LOBYTE(v7) = v8;
      if (v8) {
        unsigned int v9 = *(_DWORD *)buf;
      }
      else {
        unsigned int v9 = 0;
      }
      if (SHIBYTE(v52.gr_mem) < 0)
      {
LABEL_13:
        operator delete(v52.gr_passwd);
        if (!v7) {
          goto LABEL_14;
        }
        goto LABEL_23;
      }
LABEL_22:
      if (!v7)
      {
LABEL_14:
        uint64_t v10 = *(NSObject **)(a1 + 40);
        BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        if (result)
        {
          *(_WORD *)std::string buf = 0;
          uint64_t v12 = "Failed to get trace live filter enable property!";
LABEL_18:
          _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, v12, buf, 2u);
          return 0;
        }
        return result;
      }
LABEL_23:
      unsigned int v13 = *(_DWORD *)(a1 + 172);
      xpc_object_t v14 = *(NSObject **)(a1 + 40);
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v9 == v13)
      {
        if (v15)
        {
          if (v9 > 3) {
            long long v16 = "unknown";
          }
          else {
            long long v16 = off_1E5C47A58[v9];
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v9;
          _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Live filter setting is already %s (%d)", buf, 0x12u);
          unsigned int v9 = *(_DWORD *)(a1 + 172);
        }
        if (v9 == 3)
        {
          size_t v19 = *(abm::trace::TraceReader **)(a1 + 216);
          if (v19)
          {
            abm::trace::TraceReader::notifyCellularLoggingPortNumber(v19);
            size_t v20 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl(&dword_1A609F000, v20, OS_LOG_TYPE_DEFAULT, "#I Notifying streaming port number", buf, 2u);
            }
          }
        }
        return 1;
      }
      if (!v15)
      {
LABEL_40:
        *(_DWORD *)(a1 + 172) = v9;
        if (!*(unsigned char *)(a1 + 160)) {
          return 1;
        }
        long long v21 = *a2;
        v52.gr_name = v21;
        if (v21) {
          dispatch_retain((dispatch_object_t)v21);
        }
        INTTrace::stop_sync((INTTrace *)a1, &v52);
        if (v21) {
          dispatch_release((dispatch_object_t)v21);
        }
        long long v22 = (void *)(a1 + 216);
        if (*(void *)(a1 + 216))
        {
          char v23 = *(std::__shared_weak_count **)(a1 + 224);
          *(void *)(a1 + 216) = 0;
          *(void *)(a1 + 224) = 0;
          if (v23)
          {
            if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
              std::__shared_weak_count::__release_weak(v23);
            }
            std::string v24 = *(std::__shared_weak_count **)(a1 + 224);
            *long long v22 = 0;
            *(void *)(a1 + 224) = 0;
            if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }
          }
          else
          {
            *long long v22 = 0;
            *(void *)(a1 + 224) = 0;
          }
        }
        if (*(void *)(a1 + 304))
        {
          std::string v25 = *(std::__shared_weak_count **)(a1 + 312);
          *(void *)(a1 + 304) = 0;
          *(void *)(a1 + 312) = 0;
          if (v25)
          {
            if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
              std::__shared_weak_count::__release_weak(v25);
            }
          }
        }
        if (*(void *)(a1 + 320))
        {
          uint64_t v26 = *(std::__shared_weak_count **)(a1 + 328);
          *(void *)(a1 + 320) = 0;
          *(void *)(a1 + 328) = 0;
          if (v26)
          {
            if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }
        }
        int v27 = *(_DWORD *)(a1 + 172);
        if ((v27 - 2) >= 2)
        {
          if (v27 == 1)
          {
            std::string::basic_string[abi:ne180100]<0>(&__dst, abm::trace::kScratchFolder[0]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("BBTrace.scratch.filtered/", &__dst, (std::string *)buf);
            abm::trace::TraceInfo::create();
          }
          else
          {
            if (v27)
            {
LABEL_101:
              unsigned int v50 = *a2;
              xpc_object_t v51 = v50;
              if (v50) {
                dispatch_retain(v50);
              }
              INTTrace::start_sync((INTTrace *)a1, (group *)&v51);
              if (v50) {
                dispatch_release(v50);
              }
              return 1;
            }
            std::string::basic_string[abi:ne180100]<0>(&__dst, abm::trace::kScratchFolder[0]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("BBTrace.scratch/", &__dst, (std::string *)buf);
            abm::trace::TraceInfo::create();
          }
          std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100](a1 + 304, (long long *)v53);
          std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)v53);
LABEL_97:
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          goto LABEL_101;
        }
        xpc_object_t v28 = abm::trace::kScratchFolder[0];
        size_t v29 = strlen(abm::trace::kScratchFolder[0]);
        if (v29 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v30 = v29;
        if (v29 >= 0x17)
        {
          uint64_t v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v29 | 7) != 0x17) {
            uint64_t v32 = v29 | 7;
          }
          uint64_t v33 = v32 + 1;
          p_dst = (std::string *)operator new(v32 + 1);
          __dst.__r_.__value_.__l.__size_ = v30;
          __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v29;
          p_dst = &__dst;
          if (!v29) {
            goto LABEL_75;
          }
        }
        memmove(p_dst, v28, v30);
LABEL_75:
        p_dst->__r_.__value_.__s.__data_[v30] = 0;
        uint64_t v34 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
        long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
        *(void *)&uint8_t buf[16] = *((void *)&v34->__r_.__value_.__l + 2);
        *(_OWORD *)std::string buf = v35;
        v34->__r_.__value_.__l.__size_ = 0;
        v34->__r_.__value_.__r.__words[2] = 0;
        v34->__r_.__value_.__r.__words[0] = 0;
        abm::trace::TraceInfo::create();
        long long v36 = *(_OWORD *)v53;
        v53[0] = 0;
        v53[1] = 0;
        unsigned int v37 = *(std::__shared_weak_count **)(a1 + 312);
        *(_OWORD *)(a1 + 304) = v36;
        if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
        uint64_t v38 = (std::__shared_weak_count *)v53[1];
        if (v53[1] && !atomic_fetch_add((atomic_ullong *volatile)v53[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)buf);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_83:
            xpc_object_t v39 = abm::trace::kScratchFolder[0];
            size_t v40 = strlen(abm::trace::kScratchFolder[0]);
            if (v40 <= 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_84;
            }
            goto LABEL_109;
          }
        }
        else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_83;
        }
        operator delete(__dst.__r_.__value_.__l.__data_);
        xpc_object_t v39 = abm::trace::kScratchFolder[0];
        size_t v40 = strlen(abm::trace::kScratchFolder[0]);
        if (v40 <= 0x7FFFFFFFFFFFFFF7)
        {
LABEL_84:
          std::string::size_type v41 = v40;
          if (v40 >= 0x17)
          {
            uint64_t v43 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v40 | 7) != 0x17) {
              uint64_t v43 = v40 | 7;
            }
            uint64_t v44 = v43 + 1;
            char v42 = (std::string *)operator new(v43 + 1);
            __dst.__r_.__value_.__l.__size_ = v41;
            __dst.__r_.__value_.__r.__words[2] = v44 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v40;
            char v42 = &__dst;
            if (!v40)
            {
LABEL_91:
              v42->__r_.__value_.__s.__data_[v41] = 0;
              uint64_t v45 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
              long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
              *(void *)&uint8_t buf[16] = *((void *)&v45->__r_.__value_.__l + 2);
              *(_OWORD *)std::string buf = v46;
              v45->__r_.__value_.__l.__size_ = 0;
              v45->__r_.__value_.__r.__words[2] = 0;
              v45->__r_.__value_.__r.__words[0] = 0;
              abm::trace::TraceInfo::create();
              long long v47 = *(_OWORD *)v53;
              v53[0] = 0;
              v53[1] = 0;
              uint64_t v48 = *(std::__shared_weak_count **)(a1 + 328);
              *(_OWORD *)(a1 + 320) = v47;
              if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
              long long v49 = (std::__shared_weak_count *)v53[1];
              if (v53[1] && !atomic_fetch_add((atomic_ullong *volatile)v53[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                std::__shared_weak_count::__release_weak(v49);
              }
              goto LABEL_97;
            }
          }
          memmove(v42, v39, v41);
          goto LABEL_91;
        }
LABEL_109:
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v13 > 3)
      {
        uint64_t v17 = "unknown";
        if (v9 > 3) {
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v17 = off_1E5C47A58[v13];
        if (v9 > 3)
        {
LABEL_30:
          long long v18 = "unknown";
LABEL_39:
          *(_DWORD *)std::string buf = 136315906;
          *(void *)&uint8_t buf[4] = v17;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v13;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v18;
          __int16 v57 = 1024;
          unsigned int v58 = v9;
          _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace live filter setting from %s (%d) to %s (%d)", buf, 0x22u);
          goto LABEL_40;
        }
      }
      long long v18 = off_1E5C47A58[v9];
      goto LABEL_39;
    }
LABEL_21:
    unsigned int v9 = 0;
    if (SHIBYTE(v52.gr_mem) < 0) {
      goto LABEL_13;
    }
    goto LABEL_22;
  }
  uint64_t v10 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v12 = "Failed to set trace live filter enable property!";
    goto LABEL_18;
  }
  return result;
}

void sub_1A6151000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a29 < 0)
  {
    operator delete(a24);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropPrivacyLevel_sync(uint64_t a1, NSObject **a2, char *a3, const std::string *a4)
{
  long long v4 = (char *)a4;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if ((util::convert<int>(a4, &buf, 0) & 1) == 0)
  {
    int data = -1;
    goto LABEL_16;
  }
  int data = (int)buf.__r_.__value_.__l.__data_;
  if (LODWORD(buf.__r_.__value_.__l.__data_) >= 4)
  {
LABEL_16:
    uint64_t v12 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
    BOOL v15 = "Invalid input privacy level value: %d ";
    size_t v19 = v12;
    uint32_t v20 = 8;
LABEL_32:
    _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&buf, v20);
    return 0;
  }
  if ((prop::bbtrace::set(a3, v4) & 1) == 0)
  {
    xpc_object_t v14 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    BOOL v15 = "Failed to set privacy level!";
LABEL_30:
    size_t v19 = v14;
    uint32_t v20 = 2;
    goto LABEL_32;
  }
  memset(&__p, 0, sizeof(__p));
  char v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v9 = defaults::get((char *)v27, a3, &buf);
  if (v9)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_10:
      if (v9) {
        goto LABEL_11;
      }
LABEL_22:
      char v11 = 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_10;
  }
  operator delete(v27[0]);
  if (!v9) {
    goto LABEL_22;
  }
LABEL_11:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v10 = util::convert<int>(&__p, &buf, 0);
  char v11 = v10;
  if (v10) {
    int data = (int)buf.__r_.__value_.__l.__data_;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_23:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_24:
  if ((v11 & 1) == 0)
  {
    xpc_object_t v14 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    BOOL v15 = "Failed to get privacy level!";
    goto LABEL_30;
  }
  int v16 = *(_DWORD *)(a1 + 164);
  uint64_t v17 = *(NSObject **)(a1 + 40);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (data == v16)
  {
    if (v18)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
      _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I It is setting same privacy level: %d", (uint8_t *)&buf, 8u);
    }
    return 1;
  }
  if (v18)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
    _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Setting privacy level from %d to %d", (uint8_t *)&buf, 0xEu);
  }
  *(_DWORD *)(a1 + 164) = data;
  long long v21 = *a2;
  dispatch_object_t v25 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  if (*(char *)(a1 + 207) < 0) {
    std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(a1 + 184), *(void *)(a1 + 192));
  }
  else {
    std::string v24 = *(std::string *)(a1 + 184);
  }
  char v22 = INTTrace::sendConfig_sync(a1, &v25, (const std::string::value_type *)&v24, 0, 0, 0);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (v21) {
    dispatch_release(v21);
  }
  if (v22) {
    return 1;
  }
  char v23 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if (v4[23] < 0) {
      long long v4 = *(char **)v4;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    BOOL v15 = "Failed to send trace config %s";
    size_t v19 = v23;
    uint32_t v20 = 12;
    goto LABEL_32;
  }
  return result;
}

void sub_1A61514C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (v28)
  {
    dispatch_release(v28);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropHistory_sync(uint64_t a1, int a2, char *a3, const std::string *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v25 = 0;
  util::convert<int>(a4, &v25, 0);
  int v7 = v25;
  if (v25)
  {
    int v8 = *(_DWORD *)(a1 + 176) >> 20;
    if (v25 > 0x10000 || v25 < v8)
    {
      int v10 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v7;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
      char v11 = "Invalid input history size - %d MB (for trace file size - %d MB)";
      uint64_t v12 = v10;
      uint32_t v13 = 14;
LABEL_34:
      _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, v13);
      return 0;
    }
  }
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    char v11 = "Failed to set history property!";
    uint64_t v12 = v17;
    uint32_t v13 = 2;
    goto LABEL_34;
  }
  int v24 = 0;
  memset(&__p, 0, sizeof(__p));
  char v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v14 = defaults::get((char *)v27, a3, &buf);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    std::string __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_14:
      if (v14) {
        goto LABEL_15;
      }
      goto LABEL_24;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v27[0]);
  if (v14)
  {
LABEL_15:
    uint64_t v15 = util::convert<int>(&__p, &v24, 0);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_16;
    }
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v15 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_16:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v15 & 1) == 0) {
      goto LABEL_17;
    }
    goto LABEL_26;
  }
LABEL_25:
  if ((v15 & 1) == 0)
  {
LABEL_17:
    int v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v16, OS_LOG_TYPE_ERROR, "Failed to get history property!", (uint8_t *)&buf, 2u);
    }
    return v15;
  }
LABEL_26:
  int v19 = v24;
  int v20 = *(_DWORD *)(a1 + 168);
  long long v21 = *(NSObject **)(a1 + 40);
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (v19 == v20)
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v19;
      _os_log_impl(&dword_1A609F000, v21, OS_LOG_TYPE_DEFAULT, "#I It is setting same history size: %d", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v20;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v19;
      _os_log_impl(&dword_1A609F000, v21, OS_LOG_TYPE_DEFAULT, "#I Setting history from %d MB to %d MB", (uint8_t *)&buf, 0xEu);
      int v19 = v24;
    }
    *(_DWORD *)(a1 + 168) = v19;
    char v23 = *(abm::trace::TraceReader **)(a1 + 216);
    if (v23) {
      abm::trace::TraceReader::updateHistorySize(v23);
    }
  }
  return v15;
}

void sub_1A6151888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropTraceResetModeReboot_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((prop::bbtrace::set(a3, a4) & 1) == 0)
  {
    BOOL v9 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    char v11 = "Failed to set - Reset mode on AP boot - property!";
LABEL_28:
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, v11, buf, 2u);
    return 0;
  }
  memset(&__p, 0, sizeof(__p));
  char v20 = 7;
  strcpy((char *)v19, "BBTrace");
  memset(buf, 0, 24);
  BOOL v6 = defaults::get((char *)v19, a3, (std::string *)buf);
  if (v6)
  {
    prop::file::get<std::string>((const void **)v19, (uint64_t)a3, (uint64_t)buf, &v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24;
  }
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((v20 & 0x80000000) == 0)
    {
LABEL_8:
      if (v6) {
        goto LABEL_9;
      }
LABEL_18:
      int v8 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_25;
      }
      goto LABEL_19;
    }
  }
  else if ((v20 & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(v19[0]);
  if (!v6) {
    goto LABEL_18;
  }
LABEL_9:
  *(_DWORD *)std::string buf = -1431655766;
  int v7 = util::convert<int>(&__p, buf, 0);
  LOBYTE(v6) = v7;
  if (v7) {
    int v8 = *(_DWORD *)buf;
  }
  else {
    int v8 = 0;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_25:
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v6) {
      goto LABEL_26;
    }
    goto LABEL_20;
  }
LABEL_19:
  if (!v6)
  {
LABEL_26:
    BOOL v9 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    char v11 = "Failed to get - Reset mode on AP boot - property!";
    goto LABEL_28;
  }
LABEL_20:
  int v12 = *(_DWORD *)(a1 + 156);
  uint32_t v13 = *(NSObject **)(a1 + 40);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v8 == v12)
  {
    if (v14)
    {
      if (v8 == 1)
      {
        uint64_t v15 = 9;
        uint8_t buf[23] = 9;
        qmemcpy(buf, "Last_Used", 9);
      }
      else if (v8)
      {
        uint64_t v15 = 11;
        uint8_t buf[23] = 11;
        qmemcpy(buf, "UnSpecified", 11);
      }
      else
      {
        uint64_t v15 = 7;
        uint8_t buf[23] = 7;
        qmemcpy(buf, "Default", 7);
      }
      buf[v15] = 0;
      LODWORD(v24.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 4) = (std::string::size_type)buf;
      WORD2(v24.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&v24.__r_.__value_.__r.__words[1] + 6) = v8;
      _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I 'Reset mode on AP Boot' is already %s (%d)", (uint8_t *)&v24, 0x12u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  else
  {
    if (v14)
    {
      if (v12 == 1)
      {
        uint64_t v16 = 9;
        *((unsigned char *)&v24.__r_.__value_.__s + 23) = 9;
        qmemcpy(&v24, "Last_Used", 9);
      }
      else if (v12)
      {
        uint64_t v16 = 11;
        *((unsigned char *)&v24.__r_.__value_.__s + 23) = 11;
        qmemcpy(&v24, "UnSpecified", 11);
      }
      else
      {
        uint64_t v16 = 7;
        *((unsigned char *)&v24.__r_.__value_.__s + 23) = 7;
        qmemcpy(&v24, "Default", 7);
      }
      v24.__r_.__value_.__s.__data_[v16] = 0;
      if (v8 == 1)
      {
        uint64_t v17 = 9;
        char v20 = 9;
        qmemcpy(v19, "Last_Used", 9);
      }
      else if (v8)
      {
        uint64_t v17 = 11;
        char v20 = 11;
        qmemcpy(v19, "UnSpecified", 11);
      }
      else
      {
        uint64_t v17 = 7;
        char v20 = 7;
        qmemcpy(v19, "Default", 7);
      }
      *((unsigned char *)v19 + v17) = 0;
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = &v24;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = v19;
      __int16 v22 = 1024;
      int v23 = v8;
      _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Setting - Reset mode on AP boot - from %s (%d) to %s (%d)", buf, 0x22u);
      if (v20 < 0) {
        operator delete(v19[0]);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }
    *(_DWORD *)(a1 + 156) = v8;
  }
  return 1;
}

void sub_1A6151D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if ((a14 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropTraceOwnership_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 160))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v7 = "Setting trace ownership, enabled must be set to false";
LABEL_27:
    _os_log_error_impl(&dword_1A609F000, v5, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&buf, 2u);
    return 0;
  }
  if ((prop::bbtrace::set(a3, a4) & 1) == 0)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v7 = "Failed to set trace ownership property!";
    goto LABEL_27;
  }
  memset(&v16, 0, sizeof(v16));
  char v18 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v9 = defaults::get((char *)__p, a3, &buf);
  if (v9)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v19);
    std::string v16 = v19;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_9:
      int data = -1431655766;
      if (v9) {
        goto LABEL_10;
      }
LABEL_19:
      char v12 = 0;
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_24;
      }
      goto LABEL_20;
    }
  }
  else if ((v18 & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(__p[0]);
  int data = -1431655766;
  if (!v9) {
    goto LABEL_19;
  }
LABEL_10:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v11 = util::convert<int>(&v16, &buf, 0);
  char v12 = v11;
  if (v11) {
    int data = (int)buf.__r_.__value_.__l.__data_;
  }
  else {
    int data = -1431655766;
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_24:
    operator delete(v16.__r_.__value_.__l.__data_);
    if ((v12 & 1) == 0) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
LABEL_20:
  if ((v12 & 1) == 0)
  {
LABEL_25:
    uint64_t v5 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v7 = "Failed to get trace ownership";
    goto LABEL_27;
  }
LABEL_21:
  int v13 = *(_DWORD *)(a1 + 208);
  BOOL v14 = *(NSObject **)(a1 + 40);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (data == v13)
  {
    if (v15)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Trace ownership is already set to %d", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v15)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace ownership from %d to %d", (uint8_t *)&buf, 0xEu);
    }
    *(_DWORD *)(a1 + 208) = data;
  }
  return 1;
}

void sub_1A6152040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTraceMode_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const std::string *a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  unsigned int v8 = -1431655766;
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(a4, &buf, 0))
  {
    unsigned int data = buf.__r_.__value_.__l.__data_;
    int v10 = (unsigned int *)(a1 + 152);
    unsigned int v11 = *(_DWORD *)(a1 + 152);
    if (v11 == LODWORD(buf.__r_.__value_.__l.__data_))
    {
      unsigned int v8 = buf.__r_.__value_.__l.__data_;
      goto LABEL_7;
    }
    if (LODWORD(buf.__r_.__value_.__l.__data_) == 4)
    {
      if (*(unsigned char *)(a1 + 160))
      {
        BOOL v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          if (v11 > 7) {
            BOOL v15 = "Unknown";
          }
          else {
            BOOL v15 = off_1E5C47A78[v11];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Passive With Logging Configuration";
          goto LABEL_70;
        }
        goto LABEL_63;
      }
      if (*(_DWORD *)(a1 + 208)) {
        goto LABEL_30;
      }
      std::string v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_63;
      }
      if (v11 > 7) {
        std::string v29 = "Unknown";
      }
      else {
        std::string v29 = off_1E5C47A78[v11];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"Passive With Logging Configuration";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      int v35 = 0;
      char v28 = "Mode transitioning %s -> %s, trace channel owner (%d) not set properly";
LABEL_78:
      _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&buf, 0x1Cu);
      uint64_t v17 = 0;
      if (!v7) {
        return v17;
      }
      goto LABEL_64;
    }
  }
  else
  {
    int v10 = (unsigned int *)(a1 + 152);
    unsigned int v11 = *(_DWORD *)(a1 + 152);
    if (v11 == -1431655766)
    {
LABEL_7:
      char v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (v8 > 7) {
          int v13 = "Unknown";
        }
        else {
          int v13 = off_1E5C47A78[v8];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
        _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Mode is already set to %s", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_23;
    }
    unsigned int data = -1431655766;
  }
  if (v11 == 4)
  {
    if (*(unsigned char *)(a1 + 160))
    {
      BOOL v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        if (data > 7) {
          std::string v16 = "Unknown";
        }
        else {
          std::string v16 = off_1E5C47AB8[data];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"Passive With Logging Configuration";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v16;
LABEL_70:
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "Mode transitioning %s -> %s, enabled must be set to false", (uint8_t *)&buf, 0x16u);
        uint64_t v17 = 0;
        if (!v7) {
          return v17;
        }
        goto LABEL_64;
      }
      goto LABEL_63;
    }
    int v18 = *(_DWORD *)(a1 + 208);
    if (v18)
    {
      std::string v19 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_63;
      }
      if (data > 7) {
        char v20 = "Unknown";
      }
      else {
        char v20 = off_1E5C47AB8[data];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"Passive With Logging Configuration";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v20;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      int v35 = v18;
      char v28 = "Mode transitioning %s -> %s and trace transport owner can't be %d";
      goto LABEL_78;
    }
  }
LABEL_30:
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    std::string v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] < 0) {
        a3 = *(char **)a3;
      }
      if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
        a4 = (const std::string *)a4->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a4;
      _os_log_error_impl(&dword_1A609F000, v24, OS_LOG_TYPE_ERROR, "Failed to set %s property to %s", (uint8_t *)&buf, 0x16u);
      uint64_t v17 = 0;
      if (v7) {
        goto LABEL_64;
      }
      return v17;
    }
    goto LABEL_63;
  }
  memset(&v30, 0, sizeof(v30));
  char v32 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v21 = defaults::get((char *)__p, a3, &buf);
  if (v21)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v33);
    std::string v30 = v33;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v32 & 0x80000000) == 0)
    {
LABEL_35:
      if (v21) {
        goto LABEL_36;
      }
LABEL_50:
      char v23 = 0;
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_52;
      }
      goto LABEL_51;
    }
  }
  else if ((v32 & 0x80000000) == 0)
  {
    goto LABEL_35;
  }
  operator delete(__p[0]);
  if (!v21) {
    goto LABEL_50;
  }
LABEL_36:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v22 = util::convert<int>(&v30, &buf, 0);
  char v23 = v22;
  if (v22) {
    unsigned int v8 = buf.__r_.__value_.__l.__data_;
  }
  else {
    unsigned int v8 = -1431655766;
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
LABEL_51:
  }
    operator delete(v30.__r_.__value_.__l.__data_);
LABEL_52:
  uint64_t v25 = *(NSObject **)(a1 + 40);
  if (v23)
  {
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v26 = *v10;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v26;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v8;
      _os_log_impl(&dword_1A609F000, v25, OS_LOG_TYPE_DEFAULT, "#I Setting trace transport mode from %d to %d", (uint8_t *)&buf, 0xEu);
    }
    *int v10 = v8;
    if (v8 == 7) {
      INTTrace::startTraceWithUSBBridgeInterface((INTTrace *)a1);
    }
LABEL_23:
    uint64_t v17 = 1;
    if (!v7) {
      return v17;
    }
    goto LABEL_64;
  }
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    if (a3[23] < 0) {
      a3 = *(char **)a3;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
    _os_log_error_impl(&dword_1A609F000, v25, OS_LOG_TYPE_ERROR, "Failed to get %s property", (uint8_t *)&buf, 0xCu);
    uint64_t v17 = 0;
    if (v7) {
      goto LABEL_64;
    }
    return v17;
  }
LABEL_63:
  uint64_t v17 = 0;
  if (v7)
  {
LABEL_64:
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v17;
}

void sub_1A6152658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropConfig_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v8);
  }
  if (prop::bbtrace::set(a3, a4))
  {
    __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    __p.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
    __p.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
    char v35 = 7;
    strcpy((char *)v34, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v9 = defaults::get((char *)v34, a3, &buf);
    BOOL v10 = v9;
    if (v9)
    {
      prop::file::get<std::string>((const void **)v34, (uint64_t)a3, (uint64_t)&buf, &v36);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = v36;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v35 & 0x80000000) == 0)
      {
LABEL_10:
        if (v10) {
          goto LABEL_11;
        }
        goto LABEL_29;
      }
    }
    else if ((v35 & 0x80000000) == 0)
    {
      goto LABEL_10;
    }
    operator delete(v34[0]);
    if (v10)
    {
LABEL_11:
      unsigned int v11 = (std::string *)(a1 + 184);
      if (*(char *)(a1 + 207) >= 0) {
        char v12 = (const char *)(a1 + 184);
      }
      else {
        char v12 = *(const char **)(a1 + 184);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t p_p = &__p;
      }
      else {
        uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      int v14 = strcasecmp(v12, (const char *)p_p);
      BOOL v15 = *(NSObject **)(a1 + 40);
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if (!v14)
      {
        if (v16)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
          _os_log_impl(&dword_1A609F000, v15, OS_LOG_TYPE_DEFAULT, "#I The config (%s) is already set!", (uint8_t *)&buf, 0xCu);
        }
LABEL_59:
        uint64_t v19 = 1;
LABEL_60:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_62;
      }
      if (v16)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
        _os_log_impl(&dword_1A609F000, v15, OS_LOG_TYPE_DEFAULT, "#I Setting trace config from %s to %s", (uint8_t *)&buf, 0x16u);
      }
      uint64_t v17 = *a2;
      dispatch_object_t v32 = v17;
      if (v17) {
        dispatch_retain(v17);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v31, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v31 = __p;
      }
      char v21 = INTTrace::sendConfig_sync(a1, &v32, (const std::string::value_type *)&v31, 0, 0, 0);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      if (v17) {
        dispatch_release(v17);
      }
      if (v21)
      {
        if (v11 != &__p)
        {
          if (*(char *)(a1 + 207) < 0)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v27 = &__p;
            }
            else {
              int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            }
            else {
              size_t size = __p.__r_.__value_.__l.__size_;
            }
            std::string::__assign_no_alias<false>((void **)(a1 + 184), v27, size);
          }
          else
          {
            if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0)
            {
              *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *(void *)(a1 + 200) = *((void *)&__p.__r_.__value_.__l + 2);
              uint64_t v19 = 1;
              goto LABEL_62;
            }
            std::string::__assign_no_alias<true>((void *)(a1 + 184), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
        }
        goto LABEL_59;
      }
      int v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        std::string v30 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
        _os_log_error_impl(&dword_1A609F000, v22, OS_LOG_TYPE_ERROR, "Failed to send trace config %s", (uint8_t *)&buf, 0xCu);
      }
      if ((prop::bbtrace::set(a3, (const char *)(a1 + 184)) & 1) == 0)
      {
        char v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(a1 + 207) < 0) {
            unsigned int v11 = (std::string *)v11->__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
          std::string v24 = "Failed to reset trace config to %s";
          uint64_t v25 = v23;
          uint32_t v26 = 12;
          goto LABEL_57;
        }
      }
      goto LABEL_30;
    }
LABEL_29:
    char v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      std::string v24 = "Failed to get trace config";
      uint64_t v25 = v20;
      uint32_t v26 = 2;
LABEL_57:
      _os_log_error_impl(&dword_1A609F000, v25, OS_LOG_TYPE_ERROR, v24, (uint8_t *)&buf, v26);
      uint64_t v19 = 0;
      goto LABEL_60;
    }
LABEL_30:
    uint64_t v19 = 0;
    goto LABEL_60;
  }
  int v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v18, OS_LOG_TYPE_ERROR, "Failed to set trace config", (uint8_t *)&buf, 2u);
  }
  uint64_t v19 = 0;
LABEL_62:
  if (v8)
  {
    dispatch_group_leave(v8);
    dispatch_release(v8);
  }
  return v19;
}

void sub_1A6152B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (v38) {
    dispatch_release(v38);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (v37)
  {
    dispatch_group_leave(v37);
    dispatch_release(v37);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A6152BE0()
{
  if (!v0) {
    JUMPOUT(0x1A6152BD8);
  }
  JUMPOUT(0x1A6152BC8);
}

uint64_t INTTrace::setPropMaxMemoryFileCount_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (prop::bbtrace::set(a3, a4))
  {
    int v18 = 0;
    memset(&v19, 0, sizeof(v19));
    char v21 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v8 = defaults::get((char *)__p, a3, &buf);
    if (v8)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v22);
      std::string v19 = v22;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v21 & 0x80000000) == 0)
      {
LABEL_8:
        if (v8) {
          goto LABEL_9;
        }
        goto LABEL_16;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(__p[0]);
    if (v8)
    {
LABEL_9:
      uint64_t v9 = util::convert<unsigned int>(&v19, &v18, 0);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
      {
LABEL_21:
        operator delete(v19.__r_.__value_.__l.__data_);
        if ((v9 & 1) == 0)
        {
LABEL_22:
          BOOL v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "Failed to get max memory file count property!", (uint8_t *)&buf, 2u);
          }
          goto LABEL_28;
        }
        goto LABEL_18;
      }
LABEL_17:
      if ((v9 & 1) == 0) {
        goto LABEL_22;
      }
LABEL_18:
      int v11 = v18;
      int v12 = *(_DWORD *)(a1 + 180);
      int v13 = *(NSObject **)(a1 + 40);
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v11 == v12)
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11;
          _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Max memory file count is already set to %u", (uint8_t *)&buf, 8u);
        }
      }
      else
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v12;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v11;
          _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Setting max memory file count from %u to %u", (uint8_t *)&buf, 0xEu);
          int v11 = v18;
        }
        *(_DWORD *)(a1 + 180) = v11;
        BOOL v16 = *(abm::trace::TraceReader **)(a1 + 216);
        if (v16) {
          abm::trace::TraceReader::updateMaxMemoryFileCount(v16);
        }
      }
      goto LABEL_28;
    }
LABEL_16:
    uint64_t v9 = 0;
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_21;
    }
    goto LABEL_17;
  }
  BOOL v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to set max memory file count property!", (uint8_t *)&buf, 2u);
  }
  uint64_t v9 = 0;
LABEL_28:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v9;
}

void sub_1A6152EB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (v23)
  {
    dispatch_group_leave(v23);
    dispatch_release(v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropFileSize_sync(uint64_t a1, int a2, char *a3, const std::string *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v25 = 0;
  util::convert<int>(a4, &v25, 0);
  int v7 = *(_DWORD *)(a1 + 168);
  if (v7)
  {
    int v8 = v25 / 0x100000;
    if (!v25 || v7 < v8)
    {
      BOOL v10 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v8;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v7;
      int v11 = "Invalid input trace file size - %d MB (for history %d MB)";
      int v12 = v10;
      uint32_t v13 = 14;
LABEL_40:
      _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, v13);
      return 0;
    }
  }
  if ((prop::bbtrace::set(a3, (const char *)a4) & 1) == 0)
  {
    int v18 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v11 = "Failed to set file size property!";
    int v12 = v18;
    uint32_t v13 = 2;
    goto LABEL_40;
  }
  unsigned int v24 = 0;
  memset(&__p, 0, sizeof(__p));
  char v28 = 7;
  strcpy((char *)v27, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v14 = defaults::get((char *)v27, a3, &buf);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v27, (uint64_t)a3, (uint64_t)&buf, &v29);
    std::string __p = v29;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_14:
      if (v14) {
        goto LABEL_15;
      }
      goto LABEL_27;
    }
  }
  else if ((v28 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v27[0]);
  if (v14)
  {
LABEL_15:
    LODWORD(v15) = util::convert<unsigned int>(&__p, &v24, 0);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_16;
    }
LABEL_28:
    unsigned int v16 = v24;
    if (v24) {
      uint64_t v15 = v15;
    }
    else {
      uint64_t v15 = 0;
    }
    if ((v15 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_32;
  }
LABEL_27:
  LODWORD(v15) = 0;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_28;
  }
LABEL_16:
  operator delete(__p.__r_.__value_.__l.__data_);
  unsigned int v16 = v24;
  if (v24) {
    uint64_t v15 = v15;
  }
  else {
    uint64_t v15 = 0;
  }
  if ((v15 & 1) == 0)
  {
LABEL_20:
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, "Failed to get file size property!", (uint8_t *)&buf, 2u);
    }
    return v15;
  }
LABEL_32:
  unsigned int v20 = *(_DWORD *)(a1 + 176);
  char v21 = *(NSObject **)(a1 + 40);
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (v16 == v20)
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
      _os_log_impl(&dword_1A609F000, v21, OS_LOG_TYPE_DEFAULT, "#I It is setting file size: %u", (uint8_t *)&buf, 8u);
    }
  }
  else
  {
    if (v22)
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v20 >> 10;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v16 >> 10;
      _os_log_impl(&dword_1A609F000, v21, OS_LOG_TYPE_DEFAULT, "#I Changing file size from %d KB to %d KB", (uint8_t *)&buf, 0xEu);
      unsigned int v16 = v24;
    }
    *(_DWORD *)(a1 + 176) = v16;
    char v23 = *(abm::trace::TraceReader **)(a1 + 216);
    if (v23) {
      abm::trace::TraceReader::updateFileSize(v23);
    }
  }
  return v15;
}

void sub_1A6153268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTransportReadSize_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(v18, 0, 28);
    char v20 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v7 = defaults::get((char *)__p, a3, &buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v21);
      *(std::string *)&v18[1] = v21;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v20 & 0x80000000) == 0)
      {
LABEL_6:
        if (v7) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(__p[0]);
    if (v7)
    {
LABEL_7:
      uint64_t v8 = util::convert<unsigned int>((const std::string *)&v18[1], v18, 0);
      if (SHIBYTE(v18[6]) < 0)
      {
LABEL_17:
        operator delete(*(void **)&v18[1]);
        if (!v8) {
          return v8;
        }
        goto LABEL_18;
      }
LABEL_15:
      if (!v8) {
        return v8;
      }
LABEL_18:
      unsigned int v10 = v18[0];
      unsigned int v11 = *(_DWORD *)(a1 + 252);
      if (v18[0] != v11)
      {
        int v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11 >> 10;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v10 >> 10;
          _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Updating trace transport read-size from %u KB to %u KB", (uint8_t *)&buf, 0xEu);
          unsigned int v10 = v18[0];
        }
        *(_DWORD *)(a1 + 252) = v10;
        if (*(unsigned char *)(a1 + 160))
        {
          uint32_t v13 = *a2;
          uint64_t v17 = v13;
          if (v13) {
            dispatch_retain(v13);
          }
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v17);
          if (v13) {
            dispatch_release(v13);
          }
          BOOL v14 = *a2;
          unsigned int v16 = v14;
          if (v14) {
            dispatch_retain(v14);
          }
          INTTrace::start_sync((INTTrace *)a1, (group *)&v16);
          if (v14) {
            dispatch_release(v14);
          }
        }
      }
      return v8;
    }
LABEL_14:
    uint64_t v8 = 0;
    if (SHIBYTE(v18[6]) < 0) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Failed to set trace transport read-size", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A6153540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropTransportReadCount_sync(uint64_t a1, NSObject **a2, char *a3, const char *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (prop::bbtrace::set(a3, a4))
  {
    memset(v18, 0, 28);
    char v20 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v7 = defaults::get((char *)__p, a3, &buf);
    if (v7)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v21);
      *(std::string *)&v18[1] = v21;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v20 & 0x80000000) == 0)
      {
LABEL_6:
        if (v7) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(__p[0]);
    if (v7)
    {
LABEL_7:
      uint64_t v8 = util::convert<unsigned int>((const std::string *)&v18[1], v18, 0);
      if (SHIBYTE(v18[6]) < 0)
      {
LABEL_17:
        operator delete(*(void **)&v18[1]);
        if (!v8) {
          return v8;
        }
        goto LABEL_18;
      }
LABEL_15:
      if (!v8) {
        return v8;
      }
LABEL_18:
      int v10 = v18[0];
      int v11 = *(_DWORD *)(a1 + 256);
      if (v18[0] != v11)
      {
        int v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v10;
          _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Updating trace transport read-count from %d to %d", (uint8_t *)&buf, 0xEu);
          int v10 = v18[0];
        }
        *(_DWORD *)(a1 + 256) = v10;
        if (*(unsigned char *)(a1 + 160))
        {
          uint32_t v13 = *a2;
          uint64_t v17 = v13;
          if (v13) {
            dispatch_retain(v13);
          }
          INTTrace::stop_sync((INTTrace *)a1, (group *)&v17);
          if (v13) {
            dispatch_release(v13);
          }
          BOOL v14 = *a2;
          unsigned int v16 = v14;
          if (v14) {
            dispatch_retain(v14);
          }
          INTTrace::start_sync((INTTrace *)a1, (group *)&v16);
          if (v14) {
            dispatch_release(v14);
          }
        }
      }
      return v8;
    }
LABEL_14:
    uint64_t v8 = 0;
    if (SHIBYTE(v18[6]) < 0) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Failed to set trace transport read-count", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A6153818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (v25)
  {
    dispatch_release(v25);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropSleepTraceMode_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  BOOL v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (!prop::bbtrace::set(a3, a4))
  {
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "Failed to set sleep trace enabled", (uint8_t *)&buf, 2u);
      uint64_t v12 = 0;
      if (!v7) {
        return v12;
      }
      goto LABEL_26;
    }
LABEL_25:
    uint64_t v12 = 0;
    if (v7) {
      goto LABEL_26;
    }
    return v12;
  }
  memset(&v16, 0, sizeof(v16));
  char v18 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v8 = defaults::get((char *)__p, a3, &buf);
  if (v8)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v19);
    std::string v16 = v19;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_8:
      int data = -1431655766;
      if (v8) {
        goto LABEL_9;
      }
LABEL_19:
      int v10 = 0;
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_24;
      }
LABEL_20:
      if (!v10) {
        goto LABEL_25;
      }
      goto LABEL_21;
    }
  }
  else if ((v18 & 0x80000000) == 0)
  {
    goto LABEL_8;
  }
  operator delete(__p[0]);
  int data = -1431655766;
  if (!v8) {
    goto LABEL_19;
  }
LABEL_9:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v10 = util::convert<int>(&v16, &buf, 0);
  if (v10) {
    int data = (int)buf.__r_.__value_.__l.__data_;
  }
  else {
    int data = -1431655766;
  }
  if ((SHIBYTE(v16.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_20;
  }
LABEL_24:
  operator delete(v16.__r_.__value_.__l.__data_);
  if (!v10) {
    goto LABEL_25;
  }
LABEL_21:
  int v13 = *(_DWORD *)(a1 + 264);
  if (data == v13)
  {
    uint64_t v12 = 1;
    if (!v7) {
      return v12;
    }
    goto LABEL_26;
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = data;
    _os_log_impl(&dword_1A609F000, v15, OS_LOG_TYPE_DEFAULT, "#I Setting sleep trace mode from %d to %d", (uint8_t *)&buf, 0xEu);
  }
  *(_DWORD *)(a1 + 264) = data;
  uint64_t v12 = 1;
  if (v7)
  {
LABEL_26:
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v12;
}

void sub_1A6153AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropSleepConfig_sync(uint64_t a1, dispatch_object_t *a2, char *a3, const char *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  BOOL v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  if (prop::bbtrace::set(a3, a4))
  {
    v20.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    v20.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAALL;
    v20.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAA00;
    char v22 = 7;
    strcpy((char *)__p, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v8 = defaults::get((char *)__p, a3, &buf);
    if (v8)
    {
      prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v23);
      std::string v20 = v23;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v22 & 0x80000000) == 0)
      {
LABEL_8:
        if (v8) {
          goto LABEL_9;
        }
        goto LABEL_27;
      }
    }
    else if ((v22 & 0x80000000) == 0)
    {
      goto LABEL_8;
    }
    operator delete(__p[0]);
    if (v8)
    {
LABEL_9:
      uint64_t v9 = (std::string *)(a1 + 272);
      if (*(char *)(a1 + 295) >= 0) {
        int v10 = (const char *)(a1 + 272);
      }
      else {
        int v10 = *(const char **)(a1 + 272);
      }
      if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v11 = &v20;
      }
      else {
        int v11 = (std::string *)v20.__r_.__value_.__r.__words[0];
      }
      int v12 = strcasecmp(v10, (const char *)v11);
      int v13 = *(NSObject **)(a1 + 40);
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        if (v14)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
          _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Setting sleep trace config from %s to %s", (uint8_t *)&buf, 0x16u);
        }
        if (v9 != &v20)
        {
          if (*(char *)(a1 + 295) < 0)
          {
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v18 = &v20;
            }
            else {
              char v18 = (std::string *)v20.__r_.__value_.__r.__words[0];
            }
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = HIBYTE(v20.__r_.__value_.__r.__words[2]);
            }
            else {
              size_t size = v20.__r_.__value_.__l.__size_;
            }
            std::string::__assign_no_alias<false>((void **)(a1 + 272), v18, size);
          }
          else
          {
            if ((*((unsigned char *)&v20.__r_.__value_.__s + 23) & 0x80) == 0)
            {
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)&v20.__r_.__value_.__l.__data_;
              *(void *)(a1 + 288) = *((void *)&v20.__r_.__value_.__l + 2);
              goto LABEL_31;
            }
            std::string::__assign_no_alias<true>((void *)(a1 + 272), v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
          }
        }
      }
      else if (v14)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
        _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I The config (%s) is already set!", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_29;
    }
LABEL_27:
    std::string v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v16, OS_LOG_TYPE_ERROR, "Failed to get sleep trace config", (uint8_t *)&buf, 2u);
    }
LABEL_29:
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
    goto LABEL_31;
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "Failed to set sleep trace config", (uint8_t *)&buf, 2u);
  }
  BOOL v8 = 0;
LABEL_31:
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v8;
}

void sub_1A6153E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v30)
  {
    dispatch_group_leave(v30);
    dispatch_release(v30);
  }
  _Unwind_Resume(exception_object);
}

BOOL INTTrace::setPropErrorHandling_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((prop::bbtrace::set(a3, a4) & 1) == 0)
  {
    int v10 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v12 = "Failed to set trace error handling property!";
LABEL_25:
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&buf, 2u);
    return 0;
  }
  memset(&v19, 0, sizeof(v19));
  char v21 = 7;
  strcpy((char *)__p, "BBTrace");
  memset(&buf, 0, sizeof(buf));
  BOOL v6 = defaults::get((char *)__p, a3, &buf);
  if (v6)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)a3, (uint64_t)&buf, &v22);
    std::string v19 = v22;
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_6:
      if (v6) {
        goto LABEL_7;
      }
LABEL_16:
      char v8 = 0;
      unsigned int data = 1;
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_22;
      }
      goto LABEL_17;
    }
  }
  else if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(__p[0]);
  if (!v6) {
    goto LABEL_16;
  }
LABEL_7:
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  int v7 = util::convert<int>(&v19, &buf, 0);
  char v8 = v7;
  if (v7) {
    unsigned int data = buf.__r_.__value_.__l.__data_;
  }
  else {
    unsigned int data = 1;
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
  {
LABEL_22:
    operator delete(v19.__r_.__value_.__l.__data_);
    if ((v8 & 1) == 0) {
      goto LABEL_23;
    }
    goto LABEL_18;
  }
LABEL_17:
  if ((v8 & 1) == 0)
  {
LABEL_23:
    int v10 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    int v12 = "Failed to get trace error handling property!";
    goto LABEL_25;
  }
LABEL_18:
  uint64_t v13 = *(int *)(a1 + 356);
  BOOL v14 = *(NSObject **)(a1 + 40);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (data == v13)
  {
    if (v15)
    {
      if (data > 2) {
        std::string v16 = "Unknown";
      }
      else {
        std::string v16 = off_1E5C47AF8[data];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Trace error handling is already set to %s", (uint8_t *)&buf, 0xCu);
    }
    return 1;
  }
  if (v15)
  {
    if (v13 > 2)
    {
      uint64_t v17 = "Unknown";
      if (data > 2) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = off_1E5C47AF8[v13];
      if (data > 2)
      {
LABEL_29:
        char v18 = "Unknown";
LABEL_34:
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
        _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Setting trace error handling from %s to %s", (uint8_t *)&buf, 0x16u);
        goto LABEL_35;
      }
    }
    char v18 = off_1E5C47AF8[data];
    goto LABEL_34;
  }
LABEL_35:
  *(_DWORD *)(a1 + 356) = data;
  return 1;
}

void sub_1A61541B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t INTTrace::setPropRetainPreviousTrace_sync(uint64_t a1, uint64_t a2, char *a3, const char *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (prop::bbtrace::set(a3, a4))
  {
    char v18 = 1;
    memset(&__p, 0, sizeof(__p));
    char v21 = 7;
    strcpy((char *)v20, "BBTrace");
    memset(&buf, 0, sizeof(buf));
    BOOL v6 = defaults::get((char *)v20, a3, &buf);
    if (v6)
    {
      prop::file::get<std::string>((const void **)v20, (uint64_t)a3, (uint64_t)&buf, &v22);
      std::string __p = v22;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v21 & 0x80000000) == 0)
      {
LABEL_6:
        if (v6) {
          goto LABEL_7;
        }
        goto LABEL_16;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(v20[0]);
    if (v6)
    {
LABEL_7:
      uint64_t v7 = util::convert<BOOL>(&__p, (BOOL *)&v18, 0);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_8;
      }
      goto LABEL_17;
    }
LABEL_16:
    uint64_t v7 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_8:
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v7 & 1) == 0) {
        goto LABEL_9;
      }
LABEL_18:
      int v10 = v18;
      int v11 = *(unsigned __int8 *)(a1 + 360);
      int v12 = *(NSObject **)(a1 + 40);
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (v10 == v11)
      {
        if (v13)
        {
          BOOL v14 = "true";
          if (!v10) {
            BOOL v14 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
          _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Retain previous trace property is already set to %s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        if (v13)
        {
          BOOL v15 = "true";
          if (v11) {
            std::string v16 = "true";
          }
          else {
            std::string v16 = "false";
          }
          if (!v10) {
            BOOL v15 = "false";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v15;
          _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Setting retain previous trace property from %s to %s", (uint8_t *)&buf, 0x16u);
          LOBYTE(v10) = v18;
        }
        *(unsigned char *)(a1 + 360) = v10;
      }
      return v7;
    }
LABEL_17:
    if ((v7 & 1) == 0)
    {
LABEL_9:
      char v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to get retain previous trace property", (uint8_t *)&buf, 2u);
      }
      return v7;
    }
    goto LABEL_18;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Failed to set retain previous trace property", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_1A61544FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<INTTrace *,std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace *)#1},std::allocator<INTTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI8INTTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  }
  return 0;
}

uint64_t std::shared_ptr<INTTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<INTTrace>(INTTrace*)::{lambda(INTTrace*)#1}::operator() const(INTTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace4initENSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS5_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupEE3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSJ__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 8);
  if ((*(char *)(v1 + 39) & 0x80000000) == 0)
  {
    std::string v20 = *(std::string *)(v1 + 16);
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
    uint64_t v18 = *(void *)(v1 + 40);
    std::string v19 = v3;
    if (!v3) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)(v1 + 16), *(void *)(v1 + 24));
  unint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  uint64_t v18 = *(void *)(v1 + 40);
  std::string v19 = v3;
  if (v3) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  long long v4 = *(NSObject **)(v1 + 56);
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  **(unsigned char **)uint64_t v1 = Trace::init(v2, (void **)&v20.__r_.__value_.__l.__data_, &v18, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (**(unsigned char **)v1) {
      goto LABEL_12;
    }
LABEL_23:
    BOOL v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24[1].__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Failed to initialize Trace!", (uint8_t *)&v24[1], 2u);
    }
    return;
  }
  operator delete(v20.__r_.__value_.__l.__data_);
  if (!**(unsigned char **)v1) {
    goto LABEL_23;
  }
LABEL_12:
  HIBYTE(v16[2]) = 7;
  strcpy((char *)v16, "Enabled");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v5 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v5)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_18;
    }
LABEL_26:
    operator delete(v22[0]);
    if (!v5) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_26;
  }
LABEL_18:
  if (v5) {
LABEL_27:
  }
    util::convert<BOOL>(&__p, (BOOL *)(v2 + 160), 0);
LABEL_28:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_30;
  }
  operator delete(v16[0]);
LABEL_30:
  INTTrace::initBootSessionPrefs_sync((INTTrace *)v2);
  HIBYTE(v16[2]) = 12;
  strcpy((char *)v16, "PrivacyLevel");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v7 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v7)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_36:
      if (!v7) {
        goto LABEL_44;
      }
      goto LABEL_42;
    }
  }
  else if ((v23 & 0x80000000) == 0)
  {
    goto LABEL_36;
  }
  operator delete(v22[0]);
  if (!v7) {
    goto LABEL_44;
  }
LABEL_42:
  LODWORD(v24[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v24[1], 0)) {
    *(_DWORD *)(v2 + 164) = v24[1].__r_.__value_.__l.__data_;
  }
LABEL_44:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_46;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_46;
  }
  operator delete(v16[0]);
LABEL_46:
  HIBYTE(v16[2]) = 7;
  strcpy((char *)v16, "History");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v8 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v8)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_52;
    }
LABEL_57:
    operator delete(v22[0]);
    if (!v8) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_57;
  }
LABEL_52:
  if (v8) {
LABEL_58:
  }
    util::convert<int>(&__p, (_DWORD *)(v2 + 168), 0);
LABEL_59:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_61;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_61;
  }
  operator delete(v16[0]);
LABEL_61:
  *((unsigned char *)&v24[0].__r_.__value_.__s + 23) = 4;
  strcpy((char *)v24, "File");
  *((unsigned char *)&v24[1].__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v24[1], "BBTrace");
  prop::get_from_file((char *)&v24[1], (char *)v24, v2 + 184);
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v24[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_63;
    }
  }
  else if ((SHIBYTE(v24[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_63;
  }
  operator delete(v24[0].__r_.__value_.__l.__data_);
LABEL_63:
  HIBYTE(v16[2]) = 8;
  strcpy((char *)v16, "FileSize");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v9 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v9)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_69;
    }
LABEL_76:
    operator delete(v22[0]);
    if (!v9) {
      goto LABEL_78;
    }
    goto LABEL_77;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_76;
  }
LABEL_69:
  if (v9) {
LABEL_77:
  }
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 176), 0);
LABEL_78:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_80;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_80;
  }
  operator delete(v16[0]);
LABEL_80:
  HIBYTE(v16[2]) = 18;
  strcpy((char *)v16, "MaxMemoryFileCount");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v10 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v10)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_86;
    }
LABEL_91:
    operator delete(v22[0]);
    if (!v10) {
      goto LABEL_93;
    }
    goto LABEL_92;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_91;
  }
LABEL_86:
  if (v10) {
LABEL_92:
  }
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 180), 0);
LABEL_93:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_95;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_95;
  }
  operator delete(v16[0]);
LABEL_95:
  HIBYTE(v16[2]) = 6;
  strcpy((char *)v16, "SizeIO");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v11 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v11)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_101;
    }
LABEL_106:
    operator delete(v22[0]);
    if (!v11) {
      goto LABEL_108;
    }
    goto LABEL_107;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_106;
  }
LABEL_101:
  if (v11) {
LABEL_107:
  }
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 252), 0);
LABEL_108:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_110;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_110;
  }
  operator delete(v16[0]);
LABEL_110:
  HIBYTE(v16[2]) = 14;
  strcpy((char *)v16, "NumberOfReadIO");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v12 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v12)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if ((SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_116;
    }
LABEL_121:
    operator delete(v22[0]);
    if (!v12) {
      goto LABEL_123;
    }
    goto LABEL_122;
  }
  operator delete(v24[1].__r_.__value_.__l.__data_);
  if (v23 < 0) {
    goto LABEL_121;
  }
LABEL_116:
  if (v12) {
LABEL_122:
  }
    util::convert<unsigned int>(&__p, (_DWORD *)(v2 + 256), 0);
LABEL_123:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_125;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_125;
  }
  operator delete(v16[0]);
LABEL_125:
  HIBYTE(v16[2]) = 20;
  strcpy((char *)v16, "Enabled_During_Sleep");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v13 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v13)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_131:
      if (!v13) {
        goto LABEL_139;
      }
      goto LABEL_137;
    }
  }
  else if ((v23 & 0x80000000) == 0)
  {
    goto LABEL_131;
  }
  operator delete(v22[0]);
  if (!v13) {
    goto LABEL_139;
  }
LABEL_137:
  LODWORD(v24[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v24[1], 0)) {
    *(_DWORD *)(v2 + 264) = v24[1].__r_.__value_.__l.__data_;
  }
LABEL_139:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_141;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_141;
  }
  operator delete(v16[0]);
LABEL_141:
  strcpy((char *)&v24[0].__r_.__value_.__r.__words[2] + 7, "\nBBTrace");
  strcpy((char *)v24, "File_Sleep");
  *((unsigned char *)&v24[1].__r_.__value_.__s + 23) = 7;
  prop::get_from_file((char *)&v24[1], (char *)v24, v2 + 272);
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v24[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_143;
    }
  }
  else if ((SHIBYTE(v24[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_143;
  }
  operator delete(v24[0].__r_.__value_.__l.__data_);
LABEL_143:
  HIBYTE(v16[2]) = 14;
  strcpy((char *)v16, "Error_Handling");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v14 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v14)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v24[0];
  }
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_149:
      if (!v14) {
        goto LABEL_159;
      }
      goto LABEL_157;
    }
  }
  else if ((v23 & 0x80000000) == 0)
  {
    goto LABEL_149;
  }
  operator delete(v22[0]);
  if (!v14) {
    goto LABEL_159;
  }
LABEL_157:
  LODWORD(v24[1].__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&__p, &v24[1], 0)) {
    *(_DWORD *)(v2 + 356) = v24[1].__r_.__value_.__l.__data_;
  }
LABEL_159:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      goto LABEL_161;
    }
  }
  else if ((SHIBYTE(v16[2]) & 0x80000000) == 0)
  {
    goto LABEL_161;
  }
  operator delete(v16[0]);
LABEL_161:
  HIBYTE(v16[2]) = 21;
  strcpy((char *)v16, "Retain_Previous_Trace");
  memset(&__p, 0, sizeof(__p));
  char v23 = 7;
  strcpy((char *)v22, "BBTrace");
  memset(&v24[1], 0, sizeof(std::string));
  BOOL v15 = defaults::get((char *)v22, (char *)v16, &v24[1]);
  if (v15)
  {
    prop::file::get<std::string>((const void **)v22, (uint64_t)v16, (uint64_t)&v24[1], v24);
    std::string __p = v24[0];
  }
  if (SHIBYTE(v24[1].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24[1].__r_.__value_.__l.__data_);
    if ((v23 & 0x80000000) == 0)
    {
LABEL_165:
      if (!v15) {
        goto LABEL_172;
      }
      goto LABEL_171;
    }
  }
  else if ((v23 & 0x80000000) == 0)
  {
    goto LABEL_165;
  }
  operator delete(v22[0]);
  if (v15) {
LABEL_171:
  }
    util::convert<BOOL>(&__p, (BOOL *)(v2 + 360), 0);
LABEL_172:
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v16[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_176:
    operator delete(v16[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v16[2]) < 0) {
    goto LABEL_176;
  }
}

void sub_1A61552A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A61553CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (object)
  {
    dispatch_release(object);
    std::string v20 = a14;
    if (!a14)
    {
LABEL_3:
      if (a20 < 0) {
        goto LABEL_10;
      }
      goto LABEL_11;
    }
  }
  else
  {
    std::string v20 = a14;
    if (!a14) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v20);
  if (a20 < 0) {
LABEL_10:
  }
    JUMPOUT(0x1A61553C0);
LABEL_11:
  JUMPOUT(0x1A61553C4);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>(INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1,std::default_delete<INTTrace::init(std::string,std::weak_ptr<abm::BasebandTracingTask>,dispatch::group)::$_1>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  int v4 = *(_DWORD *)(v3 + 172);
  if ((v4 - 2) >= 2)
  {
    if (v4 != 1)
    {
      if (v4) {
        goto LABEL_54;
      }
      BOOL v5 = abm::trace::kScratchFolder[0];
      size_t v6 = strlen(abm::trace::kScratchFolder[0]);
      if (v6 <= 0x7FFFFFFFFFFFFFF7)
      {
        std::string::size_type v7 = v6;
        if (v6 >= 0x17)
        {
          uint64_t v34 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v6 | 7) != 0x17) {
            uint64_t v34 = v6 | 7;
          }
          uint64_t v35 = v34 + 1;
          p_dst = (std::string *)operator new(v34 + 1);
          __dst.__r_.__value_.__l.__size_ = v7;
          __dst.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
          p_dst = &__dst;
          if (!v6) {
            goto LABEL_41;
          }
        }
        memmove(p_dst, v5, v7);
LABEL_41:
        p_dst->__r_.__value_.__s.__data_[v7] = 0;
        std::string v36 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
        long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
        std::string::size_type v47 = v36->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = v37;
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        abm::trace::TraceInfo::create();
        goto LABEL_47;
      }
LABEL_65:
      std::string::__throw_length_error[abi:ne180100]();
    }
    BOOL v13 = abm::trace::kScratchFolder[0];
    size_t v14 = strlen(abm::trace::kScratchFolder[0]);
    if (v14 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_65;
    }
    std::string::size_type v15 = v14;
    if (v14 >= 0x17)
    {
      uint64_t v38 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v38 = v14 | 7;
      }
      uint64_t v39 = v38 + 1;
      std::string v16 = (std::string *)operator new(v38 + 1);
      __dst.__r_.__value_.__l.__size_ = v15;
      __dst.__r_.__value_.__r.__words[2] = v39 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14;
      std::string v16 = &__dst;
      if (!v14) {
        goto LABEL_46;
      }
    }
    memmove(v16, v13, v15);
LABEL_46:
    v16->__r_.__value_.__s.__data_[v15] = 0;
    size_t v40 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
    long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    std::string::size_type v47 = v40->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    abm::trace::TraceInfo::create();
LABEL_47:
    long long v42 = v48;
    long long v48 = 0uLL;
    std::string v33 = *(std::__shared_weak_count **)(v3 + 312);
    *(_OWORD *)(v3 + 304) = v42;
    if (!v33) {
      goto LABEL_50;
    }
    goto LABEL_48;
  }
  BOOL v9 = abm::trace::kScratchFolder[0];
  size_t v10 = strlen(abm::trace::kScratchFolder[0]);
  if (v10 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_65;
  }
  std::string::size_type v11 = v10;
  if (v10 >= 0x17)
  {
    uint64_t v17 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v17 = v10 | 7;
    }
    uint64_t v18 = v17 + 1;
    BOOL v12 = (std::string *)operator new(v17 + 1);
    __dst.__r_.__value_.__l.__size_ = v11;
    __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10;
    BOOL v12 = &__dst;
    if (!v10) {
      goto LABEL_20;
    }
  }
  memmove(v12, v9, v11);
LABEL_20:
  v12->__r_.__value_.__s.__data_[v11] = 0;
  std::string v19 = std::string::append(&__dst, "BBTrace.scratch/", 0x10uLL);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v47 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  abm::trace::TraceInfo::create();
  long long v21 = v48;
  long long v48 = 0uLL;
  std::string v22 = *(std::__shared_weak_count **)(v3 + 312);
  *(_OWORD *)(v3 + 304) = v21;
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  char v23 = (std::__shared_weak_count *)*((void *)&v48 + 1);
  if (*((void *)&v48 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v48 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
    if ((SHIBYTE(v47) & 0x80000000) == 0)
    {
LABEL_26:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_27;
      }
      goto LABEL_64;
    }
  }
  else if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    goto LABEL_26;
  }
  operator delete(__p[0]);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_27:
    uint64_t v24 = abm::trace::kScratchFolder[0];
    size_t v25 = strlen(abm::trace::kScratchFolder[0]);
    if (v25 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_65;
    }
    goto LABEL_28;
  }
LABEL_64:
  operator delete(__dst.__r_.__value_.__l.__data_);
  uint64_t v24 = abm::trace::kScratchFolder[0];
  size_t v25 = strlen(abm::trace::kScratchFolder[0]);
  if (v25 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_65;
  }
LABEL_28:
  std::string::size_type v26 = v25;
  if (v25 >= 0x17)
  {
    uint64_t v28 = (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v25 | 7) != 0x17) {
      uint64_t v28 = v25 | 7;
    }
    uint64_t v29 = v28 + 1;
    int v27 = (std::string *)operator new(v28 + 1);
    __dst.__r_.__value_.__l.__size_ = v26;
    __dst.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
    goto LABEL_34;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v25;
  int v27 = &__dst;
  if (v25) {
LABEL_34:
  }
    memmove(v27, v24, v26);
  v27->__r_.__value_.__s.__data_[v26] = 0;
  std::string v30 = std::string::append(&__dst, "BBTrace.scratch.filtered/", 0x19uLL);
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  std::string::size_type v47 = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  abm::trace::TraceInfo::create();
  long long v32 = v48;
  long long v48 = 0uLL;
  std::string v33 = *(std::__shared_weak_count **)(v3 + 328);
  *(_OWORD *)(v3 + 320) = v32;
  if (!v33) {
    goto LABEL_50;
  }
LABEL_48:
  if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
LABEL_50:
  uint64_t v43 = (std::__shared_weak_count *)*((void *)&v48 + 1);
  if (*((void *)&v48 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v48 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
    if ((SHIBYTE(v47) & 0x80000000) == 0)
    {
LABEL_53:
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_54;
      }
LABEL_58:
      operator delete(__dst.__r_.__value_.__l.__data_);
      operator delete(v2);
      uint64_t v44 = (std::__shared_weak_count *)a1[2];
      if (!v44) {
        goto LABEL_61;
      }
      goto LABEL_59;
    }
  }
  else if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    goto LABEL_53;
  }
  operator delete(__p[0]);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_58;
  }
LABEL_54:
  operator delete(v2);
  uint64_t v44 = (std::__shared_weak_count *)a1[2];
  if (!v44) {
    goto LABEL_61;
  }
LABEL_59:
  if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
LABEL_61:
  operator delete(a1);
}

void sub_1A6155998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0)
    {
LABEL_3:
      operator delete(v22);
      uint64_t v24 = (std::__shared_weak_count *)v21[2];
      if (!v24) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a10);
  operator delete(v22);
  uint64_t v24 = (std::__shared_weak_count *)v21[2];
  if (!v24) {
    goto LABEL_9;
  }
LABEL_7:
  if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
LABEL_9:
  operator delete(v21);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::prepare(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  uint64_t v2 = *a1;
  dispatch_group_t v3 = (*a1)[1];
  isa = v3[18].isa;
  if (isa)
  {
    dispatch_retain((dispatch_object_t)v3[18].isa);
    dispatch_group_enter(isa);
  }
  if (LOBYTE(v3[20].isa))
  {
    INTTrace::prepare_sync((INTTrace *)v3);
  }
  else
  {
    BOOL v5 = v3[5].isa;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 0;
      _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Trace is not enabled. Skip to prepare processing", (uint8_t *)v7, 2u);
    }
  }
  if (isa)
  {
    dispatch_group_leave(isa);
    dispatch_release(isa);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2) {
      dispatch_release(*v2);
    }
  }
  operator delete(v2);
  size_t v6 = (std::__shared_weak_count *)a1[2];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  operator delete(a1);
}

void sub_1A6155BC0(_Unwind_Exception *a1)
{
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2) {
      dispatch_release(*v2);
    }
  }
  operator delete(v2);
  BOOL v5 = (std::__shared_weak_count *)v1[2];
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::start(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  int v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(unsigned char *)(v3 + 160))
  {
    BOOL v5 = (char *)v2[1];
    buf.gr_name = v5;
    if (v5) {
      dispatch_retain((dispatch_object_t)v5);
    }
    INTTrace::start_sync((INTTrace *)v3, &buf);
LABEL_33:
    if (v5) {
      dispatch_release((dispatch_object_t)v5);
    }
    if (v4)
    {
      dispatch_group_leave(v4);
      dispatch_release(v4);
    }
    std::string v16 = v2[1];
    if (v16) {
      dispatch_release(v16);
    }
    operator delete(v2);
    uint64_t v17 = (std::__shared_weak_count *)a1[2];
    if (v17)
    {
      if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    operator delete(a1);
    return;
  }
  if (*(void *)(v3 + 232)) {
    goto LABEL_30;
  }
  size_t v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.gr_name) = 0;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Creating Trace CommandDriver", (uint8_t *)&buf, 2u);
  }
  std::string::size_type v7 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  uint64_t v8 = off_1EB5EE540;
  if (!off_1EB5EE540)
  {
    CommandDriverFactory::create_default_global((uint64_t *)&buf, v7);
    long long v9 = *(_OWORD *)&buf.gr_name;
    buf.gr_name = 0;
    buf.gr_passwd = 0;
    size_t v10 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
    off_1EB5EE540 = v9;
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    gr_passwd = buf.gr_passwd;
    if (buf.gr_passwd && !atomic_fetch_add((atomic_ullong *volatile)buf.gr_passwd + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(char *))(*(void *)gr_passwd + 16))(gr_passwd);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)gr_passwd);
    }
    uint64_t v8 = off_1EB5EE540;
  }
  BOOL v12 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
  if (*(&off_1EB5EE540 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE540 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v8 + 136))(&v20, v8);
  long long v13 = v20;
  long long v20 = 0uLL;
  size_t v14 = *(std::__shared_weak_count **)(v3 + 240);
  *(_OWORD *)(v3 + 232) = v13;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  std::string::size_type v15 = (std::__shared_weak_count *)*((void *)&v20 + 1);
  if (*((void *)&v20 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  if (*(void *)(v3 + 232))
  {
LABEL_30:
    BOOL v5 = (char *)v2[1];
    buf.gr_name = v5;
    if (v5) {
      dispatch_retain((dispatch_object_t)v5);
    }
    INTTrace::stop_sync((INTTrace *)v3, &buf);
    goto LABEL_33;
  }
  uint64_t v18 = GetOsLogContext()[1];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.gr_name) = 0;
    _os_log_fault_impl(&dword_1A609F000, v18, OS_LOG_TYPE_FAULT, "Trace command driver must be present!", (uint8_t *)&buf, 2u);
  }
  std::string v19 = GetOsLogContext()[1];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf.gr_name) = 136315906;
    *(char **)((char *)&buf.gr_name + 4) = "ABM ASSERT";
    WORD2(buf.gr_passwd) = 2080;
    *(char **)((char *)&buf.gr_passwd + 6) = "fTraceCommandDriver";
    *((_WORD *)&buf.gr_gid + 3) = 2080;
    buf.gr_mem = (char **)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices_Manager/AppleBasebandManager/ABMHe"
                          "lper/Server/Tasks/Wireless/Trace/INTTrace/INTTrace.cpp";
    __int16 v22 = 1024;
    int v23 = 196;
    _os_log_fault_impl(&dword_1A609F000, v19, OS_LOG_TYPE_FAULT, "%s (%s): File: %s Line: %d", (uint8_t *)&buf, 0x26u);
  }
  __break(1u);
}

void sub_1A61560A8(_Unwind_Exception *a1)
{
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  BOOL v5 = v2[1];
  if (v5) {
    dispatch_release(v5);
  }
  operator delete(v2);
  size_t v6 = (std::__shared_weak_count *)v1[2];
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::stop(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  int v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  if (*(unsigned char *)(v3 + 160))
  {
    BOOL v5 = (char *)v2[1];
    v9.gr_name = v5;
    if (v5) {
      dispatch_retain((dispatch_object_t)v5);
    }
    INTTrace::stop_sync((INTTrace *)v3, &v9);
    if (v5) {
      dispatch_release((dispatch_object_t)v5);
    }
  }
  else
  {
    size_t v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9.gr_passwd) = 0;
      _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Trace is not enabled. Skip processing trace stop", (uint8_t *)&v9.gr_passwd, 2u);
    }
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  std::string::size_type v7 = v2[1];
  if (v7) {
    dispatch_release(v7);
  }
  operator delete(v2);
  uint64_t v8 = (std::__shared_weak_count *)a1[2];
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  operator delete(a1);
}

void sub_1A6156310(_Unwind_Exception *a1)
{
  if (v4)
  {
    dispatch_release(v4);
    if (!v3)
    {
LABEL_3:
      size_t v6 = v2[1];
      if (!v6) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if (!v3)
  {
    goto LABEL_3;
  }
  dispatch_group_leave(v3);
  dispatch_release(v3);
  size_t v6 = v2[1];
  if (!v6)
  {
LABEL_4:
    operator delete(v2);
    std::string::size_type v7 = (std::__shared_weak_count *)v1[2];
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
LABEL_8:
  dispatch_release(v6);
  operator delete(v2);
  std::string::size_type v7 = (std::__shared_weak_count *)v1[2];
  if (!v7) {
    goto LABEL_11;
  }
LABEL_9:
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_11:
  operator delete(v1);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::abort(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  int v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  BOOL v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)group buf = 0;
    _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Abort received", buf, 2u);
  }
  if (!*(void *)(v3 + 304)) {
    goto LABEL_7;
  }
  char v26 = 0;
  buf[0] = 0;
  Timestamp::Timestamp((Timestamp *)v23);
  char v22 = 0;
  LOBYTE(v21) = 0;
  char v20 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v23, v24);
  if (v26 < 0)
  {
    operator delete(*(void **)buf);
    if (!*(void *)(v3 + 320)) {
      goto LABEL_11;
    }
  }
  else
  {
LABEL_7:
    if (!*(void *)(v3 + 320)) {
      goto LABEL_11;
    }
  }
  char v18 = 0;
  LOBYTE(v17) = 0;
  Timestamp::Timestamp((Timestamp *)v15);
  char v14 = 0;
  LOBYTE(v13) = 0;
  char v12 = 0;
  LOBYTE(v11) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v15, v16);
  if (v18 < 0) {
    operator delete(v17);
  }
LABEL_11:
  uint64_t v6 = *(void *)(v3 + 232);
  if (v6)
  {
    std::string::size_type v7 = v2[1];
    dispatch_object_t object = v7;
    if (v7) {
      dispatch_retain(v7);
    }
    (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v6 + 144))(v6, &object);
    if (object) {
      dispatch_release(object);
    }
  }
  INTTrace::stopReader_sync((INTTrace *)v3);
  *(unsigned char *)(v3 + 260) = 0;
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  uint64_t v8 = v2[1];
  if (v8) {
    dispatch_release(v8);
  }
  operator delete(v2);
  group v9 = (std::__shared_weak_count *)a1[2];
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  operator delete(a1);
}

void sub_1A6156670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (object)
  {
    dispatch_release(object);
    if (!v44)
    {
LABEL_6:
      long long v46 = v43[1];
      if (v46) {
        dispatch_release(v46);
      }
      operator delete(v43);
      std::string::size_type v47 = (std::__shared_weak_count *)v42[2];
      if (v47)
      {
        if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
      operator delete(v42);
      _Unwind_Resume(a1);
    }
  }
  else if (!v44)
  {
    goto LABEL_6;
  }
  dispatch_group_leave(v44);
  dispatch_release(v44);
  goto LABEL_6;
}

void sub_1A61567B8()
{
  if (!v0) {
    JUMPOUT(0x1A615674CLL);
  }
  JUMPOUT(0x1A615673CLL);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::shutdown(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  uint64_t v2 = *a1;
  dispatch_group_t v3 = (*a1)[1];
  isa = v3[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)group buf = 0;
    _os_log_impl(&dword_1A609F000, isa, OS_LOG_TYPE_DEFAULT, "#I Shutdown received", buf, 2u);
  }
  Class v5 = v3[29].isa;
  if (v5)
  {
    uint64_t v6 = v2[2];
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    (*(void (**)(Class, dispatch_object_t *))(*(void *)v5 + 144))(v5, &object);
    if (object) {
      dispatch_release(object);
    }
  }
  INTTrace::stopReader_sync((INTTrace *)v3);
  std::string::size_type v7 = (std::__shared_weak_count *)v3[30].isa;
  v3[29].isa = 0;
  v3[30].isa = 0;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)v3[28].isa;
  v3[27].isa = 0;
  v3[28].isa = 0;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  BYTE4(v3[32].isa) = 0;
  group v9 = v2[2];
  if (v9) {
    dispatch_release(v9);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2) {
      dispatch_release(*v2);
    }
  }
  operator delete(v2);
  size_t v10 = (std::__shared_weak_count *)a1[2];
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  operator delete(a1);
}

void sub_1A61569A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object)
  {
    dispatch_release(object);
    long long v13 = v11[2];
    if (!v13)
    {
LABEL_3:
      char v14 = *v11;
      if (!*v11) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  else
  {
    long long v13 = v11[2];
    if (!v13) {
      goto LABEL_3;
    }
  }
  dispatch_release(v13);
  char v14 = *v11;
  if (!*v11) {
    goto LABEL_9;
  }
LABEL_7:
  dispatch_group_leave(v14);
  if (*v11) {
    dispatch_release(*v11);
  }
LABEL_9:
  operator delete(v11);
  std::string::size_type v15 = (std::__shared_weak_count *)v10[2];
  if (v15)
  {
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::enterLowPower(dispatch::group)::$_0>(INTTrace::enterLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::enterLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::enterLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  uint64_t v2 = *a1;
  isa = (*a1)[1][5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)Class v5 = 0;
    _os_log_impl(&dword_1A609F000, isa, OS_LOG_TYPE_DEFAULT, "#I EnterLowPower received", v5, 2u);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2) {
      dispatch_release(*v2);
    }
  }
  operator delete(v2);
  int v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  operator delete(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::exitLowPower(dispatch::group)::$_0>(INTTrace::exitLowPower(dispatch::group)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::exitLowPower(dispatch::group)::$_0,dispatch_queue_s *::default_delete<INTTrace::exitLowPower(dispatch::group)::$_0>>)::{lambda(void *)#1}::__invoke(dispatch_group_t **a1)
{
  uint64_t v2 = *a1;
  isa = (*a1)[1][5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)Class v5 = 0;
    _os_log_impl(&dword_1A609F000, isa, OS_LOG_TYPE_DEFAULT, "#I ExitLowPower received", v5, 2u);
  }
  if (*v2)
  {
    dispatch_group_leave(*v2);
    if (*v2) {
      dispatch_release(*v2);
    }
  }
  operator delete(v2);
  int v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  operator delete(a1);
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>(INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,dispatch_queue_s *::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v2 = *a1;
  v12[0] = v2;
  uint64_t v3 = *(void *)(v2 + 8);
  if (!*(unsigned char *)(v3 + 160))
  {
    int v4 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Trace is disabled. Skip snapshot processing!", (uint8_t *)&__p, 2u);
    }
    goto LABEL_26;
  }
  if (*(void *)(v3 + 304)
    && (std::string __p = operator new(0x20uLL),
        long long v18 = xmmword_1A61F71E0,
        strcpy((char *)__p, "Trace State Configuration"),
        INTTrace::getStateAsDict_sync(v3, v2 + 16, &object),
        abm::trace::TraceInfo::push(),
        xpc_release(object),
        xpc_object_t object = 0,
        SHIBYTE(v18) < 0))
  {
    operator delete(__p);
    if (!*(void *)(v3 + 320)) {
      goto LABEL_10;
    }
  }
  else if (!*(void *)(v3 + 320))
  {
    goto LABEL_10;
  }
  std::string __p = operator new(0x20uLL);
  long long v18 = xmmword_1A61F71E0;
  strcpy((char *)__p, "Trace State Configuration");
  INTTrace::getStateAsDict_sync(v3, v2 + 16, &v15);
  abm::trace::TraceInfo::push();
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (SHIBYTE(v18) < 0) {
    operator delete(__p);
  }
LABEL_10:
  Class v5 = *(capabilities::debug **)(v3 + 232);
  if (v5)
  {
    Class v5 = (capabilities::debug *)(*(uint64_t (**)(capabilities::debug *))(*(void *)v5 + 152))(v5);
    if (v5) {
      Class v5 = (capabilities::debug *)(*(uint64_t (**)(void))(**(void **)(v3 + 232) + 168))(*(void *)(v3 + 232));
    }
  }
  if (!*(void *)(v3 + 216)) {
    goto LABEL_26;
  }
  capabilities::debug::environment(v5);
  capabilities::debug::operator&();
  uint64_t v6 = *(const void **)(v2 + 40);
  CFTypeRef cf = v6;
  if (v6) {
    CFRetain(v6);
  }
  uint64_t v7 = *(void *)(v3 + 312);
  std::string __p = *(void **)(v3 + 304);
  *(void *)&long long v18 = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v3 + 328);
  v12[1] = *(void *)(v3 + 320);
  long long v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  abm::trace::TraceReader::snapshot();
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    group v9 = (std::__shared_weak_count *)v18;
    if ((void)v18)
    {
LABEL_23:
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
        CFTypeRef v10 = cf;
        if (!cf) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
  }
  else
  {
    group v9 = (std::__shared_weak_count *)v18;
    if ((void)v18) {
      goto LABEL_23;
    }
  }
  CFTypeRef v10 = cf;
  if (cf) {
LABEL_25:
  }
    CFRelease(v10);
LABEL_26:
  std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](v12);
  std::string::size_type v11 = (std::__shared_weak_count *)a1[2];
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  operator delete(a1);
}

void sub_1A6156F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, CFTypeRef cf, xpc_object_t object, xpc_object_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20)
{
  char v22 = a11;
  if (a11 && !atomic_fetch_add(&a11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  int v23 = a16;
  if (a16 && !atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  if (cf) {
    CFRelease(cf);
  }
  std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](&a9);
  uint64_t v24 = (std::__shared_weak_count *)v20[2];
  if (v24)
  {
    if (!atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  operator delete(v20);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0,std::default_delete<INTTrace::snapshot(dispatch::group,ctu::cf::CFSharedRef<__CFDictionary const>)::$_0>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(const void **)(v2 + 40);
    if (v3) {
      CFRelease(v3);
    }
    if (*(char *)(v2 + 39) < 0) {
      operator delete(*(void **)(v2 + 16));
    }
    if (*(void *)v2)
    {
      dispatch_group_leave(*(dispatch_group_t *)v2);
      if (*(void *)v2) {
        dispatch_release(*(dispatch_object_t *)v2);
      }
    }
    operator delete((void *)v2);
  }
  return a1;
}

void dispatch::async<void ctu::SharedSynchronizable<Trace>::execute_wrapped<INTTrace::dumpState(dispatch::group,std::string)::$_0>(INTTrace::dumpState(dispatch::group,std::string)::$_0 &&)::{lambda(void)#1}>(dispatch_queue_s *,std::unique_ptr<INTTrace::dumpState(dispatch::group,std::string)::$_0,std::default_delete<INTTrace::dumpState(dispatch::group,std::string)::$_0>>)::{lambda(void *)#1}::__invoke(void *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)a1;
  uint64_t v3 = **(void **)a1;
  int v4 = *(NSObject **)(v3 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(v3 + 144));
    dispatch_group_enter(v4);
  }
  Class v5 = *(NSObject **)(v3 + 40);
  if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_12;
  }
  if (*((char *)v2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v9, (const std::string::value_type *)v2[1], v2[2]);
  }
  else
  {
    long long v6 = *(_OWORD *)(v2 + 1);
    v9.__r_.__value_.__r.__words[2] = v2[3];
    *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v6;
  }
  INTTrace::dumpState_sync(v3, (uint64_t)&v9, __p);
  if (v11 >= 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  *(_DWORD *)group buf = 136315138;
  long long v13 = v7;
  _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
  if (v11 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_21;
    }
LABEL_12:
    if (!v4) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if ((SHIBYTE(v9.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_12;
  }
LABEL_21:
  operator delete(v9.__r_.__value_.__l.__data_);
  if (v4)
  {
LABEL_13:
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
LABEL_14:
  if (*((char *)v2 + 31) < 0) {
    operator delete((void *)v2[1]);
  }
  operator delete(v2);
  uint64_t v8 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  operator delete(a1);
}

void sub_1A6157328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (v16)
  {
    dispatch_group_leave(v16);
    dispatch_release(v16);
    if ((v15[31] & 0x80000000) == 0)
    {
LABEL_3:
      operator delete(v15);
      std::string v19 = (std::__shared_weak_count *)v14[2];
      if (!v19) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  else if ((v15[31] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v17);
  operator delete(v15);
  std::string v19 = (std::__shared_weak_count *)v14[2];
  if (!v19) {
    goto LABEL_9;
  }
LABEL_7:
  if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_9:
  operator delete(v14);
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS7_11char_traitsIcEENS7_9allocatorIcEEEESF_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSH__block_invoke(uint64_t a1)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 40);
  uint64_t v3 = (const char **)(v1 + 16);
  int v4 = *(char *)(v1 + 39);
  if ((v4 & 0x80000000) == 0)
  {
    if (strcasecmp((const char *)(v1 + 16), "Enabled"))
    {
      if (strcasecmp((const char *)(v1 + 16), "Live_Filter_Setting"))
      {
        if (strcasecmp((const char *)(v1 + 16), "PrivacyLevel"))
        {
          if (strcasecmp((const char *)(v1 + 16), "History"))
          {
            if (strcasecmp((const char *)(v1 + 16), "Mode"))
            {
              if (strcasecmp((const char *)(v1 + 16), "Reset_Mode_Boot"))
              {
                if (strcasecmp((const char *)(v1 + 16), "TraceOwnership"))
                {
                  if (strcasecmp((const char *)(v1 + 16), "File"))
                  {
                    if (strcasecmp((const char *)(v1 + 16), "MaxMemoryFileCount"))
                    {
                      if (strcasecmp((const char *)(v1 + 16), "FileSize"))
                      {
                        if (strcasecmp((const char *)(v1 + 16), "SizeIO"))
                        {
                          if (strcasecmp((const char *)(v1 + 16), "NumberOfReadIO"))
                          {
                            if (strcasecmp((const char *)(v1 + 16), "Enabled_During_Sleep"))
                            {
                              std::string v9 = (const char *)(v1 + 16);
                              if (strcasecmp((const char *)(v1 + 16), "File_Sleep")) {
                                goto LABEL_16;
                              }
                              goto LABEL_35;
                            }
                            goto LABEL_107;
                          }
                          goto LABEL_101;
                        }
                        goto LABEL_95;
                      }
                      goto LABEL_89;
                    }
                    goto LABEL_83;
                  }
                  goto LABEL_77;
                }
                goto LABEL_71;
              }
              goto LABEL_65;
            }
            goto LABEL_59;
          }
          goto LABEL_53;
        }
        goto LABEL_47;
      }
      goto LABEL_43;
    }
LABEL_39:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&buf, "Enabled");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropEnabled_sync(v2, (NSObject **)&v60, (char *)&buf, (const char *)&v59);
LABEL_146:
    **(unsigned char **)uint64_t v1 = Size_sync;
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v59.__r_.__value_.__l.__data_);
      if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_148:
        if (!v14) {
          goto LABEL_150;
        }
        goto LABEL_149;
      }
    }
    else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_148;
    }
    operator delete(buf.__r_.__value_.__l.__data_);
    if (!v14) {
      goto LABEL_150;
    }
LABEL_149:
    dispatch_release((dispatch_object_t)v14);
    goto LABEL_150;
  }
  std::string v9 = *v3;
  if (!strcasecmp(*v3, "Enabled")) {
    goto LABEL_39;
  }
  if (!strcasecmp(v9, "Live_Filter_Setting"))
  {
LABEL_43:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 19;
    strcpy((char *)&buf, "Live_Filter_Setting");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropLiveFilterSetting_sync(v2, &v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "PrivacyLevel"))
  {
LABEL_47:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&buf, "PrivacyLevel");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropPrivacyLevel_sync(v2, (NSObject **)&v60, (char *)&buf, &v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "History"))
  {
LABEL_53:
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 7;
    strcpy((char *)&buf, "History");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropHistory_sync(v2, v5, (char *)&buf, &v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "Mode"))
  {
LABEL_59:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&buf, "Mode");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropTraceMode_sync(v2, (dispatch_object_t *)&v60, (char *)&buf, &v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "Reset_Mode_Boot"))
  {
LABEL_65:
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 15;
    strcpy((char *)&buf, "Reset_Mode_Boot");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropTraceResetModeReboot_sync(v2, v6, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "TraceOwnership"))
  {
LABEL_71:
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "TraceOwnership");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropTraceOwnership_sync(v2, v7, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "File"))
  {
LABEL_77:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 4;
    strcpy((char *)&buf, "File");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropConfig_sync(v2, (dispatch_object_t *)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "MaxMemoryFileCount"))
  {
LABEL_83:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 18;
    strcpy((char *)&buf, "MaxMemoryFileCount");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropMaxMemoryFileCount_sync(v2, (dispatch_object_t *)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "FileSize"))
  {
LABEL_89:
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&buf, "FileSize");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropFileSize_sync(v2, v8, (char *)&buf, &v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "SizeIO"))
  {
LABEL_95:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 6;
    strcpy((char *)&buf, "SizeIO");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropTransportReadSize_sync(v2, (NSObject **)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "NumberOfReadIO"))
  {
LABEL_101:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "NumberOfReadIO");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropTransportReadCount_sync(v2, (NSObject **)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "Enabled_During_Sleep"))
  {
LABEL_107:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 20;
    strcpy((char *)&buf, "Enabled_During_Sleep");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropSleepTraceMode_sync(v2, (dispatch_object_t *)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  if (!strcasecmp(v9, "File_Sleep"))
  {
LABEL_35:
    uint64_t v14 = *(char **)(v1 + 48);
    char v60 = v14;
    if (v14) {
      dispatch_retain((dispatch_object_t)v14);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 10;
    strcpy((char *)&buf, "File_Sleep");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropSleepConfig_sync(v2, (dispatch_object_t *)&v60, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
LABEL_16:
  if (!strcasecmp(v9, "Error_Handling"))
  {
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 14;
    strcpy((char *)&buf, "Error_Handling");
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropErrorHandling_sync(v2, v10, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  strcpy((char *)&buf, "CellularLoggingAllowed");
  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 22;
  if (util::equal_nocase((const char *)(v1 + 16), (const char *)&buf))
  {
    int v11 = prop::bbtrace::set((char *)(v1 + 16), (const char *)(v1 + 56));
    char v12 = *(unsigned char **)v1;
    **(unsigned char **)uint64_t v1 = v11;
    if (v11)
    {
      memset(&buf, 0, sizeof(buf));
      if (prop::bbtrace::get((char *)(v1 + 16), (uint64_t)&buf)) {
        char v13 = util::convert<BOOL>(&buf, (BOOL *)(v2 + 352), 0);
      }
      else {
        char v13 = 0;
      }
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      **(unsigned char **)uint64_t v1 = v13;
    }
    else
    {
      *char v12 = 0;
    }
    goto LABEL_150;
  }
  std::string v16 = (const char *)(v1 + 16);
  if (v4 < 0) {
    std::string v16 = *v3;
  }
  if (!strcasecmp(v16, "Retain_Previous_Trace"))
  {
    uint64_t v14 = *(char **)(v1 + 48);
    if (v14)
    {
      dispatch_retain(*(dispatch_object_t *)(v1 + 48));
      LOBYTE(v4) = *(unsigned char *)(v1 + 39);
    }
    if ((v4 & 0x80) != 0)
    {
      std::string::__init_copy_ctor_external(&buf, *(const std::string::value_type **)(v1 + 16), *(void *)(v1 + 24));
    }
    else
    {
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)v3;
      buf.__r_.__value_.__r.__words[2] = *(void *)(v1 + 32);
    }
    if (*(char *)(v1 + 79) < 0) {
      std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)(v1 + 56), *(void *)(v1 + 64));
    }
    else {
      std::string v59 = *(std::string *)(v1 + 56);
    }
    char Size_sync = INTTrace::setPropRetainPreviousTrace_sync(v2, v17, (char *)&buf, (const char *)&v59);
    goto LABEL_146;
  }
  long long v18 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    std::string v19 = (const char *)(v1 + 16);
    if (v4 < 0) {
      std::string v19 = *v3;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
    _os_log_error_impl(&dword_1A609F000, v18, OS_LOG_TYPE_ERROR, "Key not handled: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_150:
  if (!*(void *)(v2 + 304)) {
    goto LABEL_176;
  }
  int v20 = *(char *)(v1 + 39);
  if (v20 >= 0) {
    size_t v21 = *(unsigned __int8 *)(v1 + 39);
  }
  else {
    size_t v21 = *(void *)(v1 + 24);
  }
  unint64_t v22 = v21 + 3;
  memset(&__dst, 170, sizeof(__dst));
  if (v21 + 3 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v24 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v24 = v22 | 7;
    }
    uint64_t v25 = v24 + 1;
    p_dst = (std::string *)operator new(v24 + 1);
    __dst.__r_.__value_.__l.__size_ = v21 + 3;
    __dst.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v21 + 3;
    if (!v21) {
      goto LABEL_168;
    }
  }
  if (v20 >= 0) {
    char v26 = (const char *)(v1 + 16);
  }
  else {
    char v26 = *v3;
  }
  memmove(p_dst, v26, v21);
LABEL_168:
  *(_DWORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v21) = 2112800;
  int v27 = *(char *)(v1 + 79);
  if (v27 >= 0) {
    uint64_t v28 = (const std::string::value_type *)(v1 + 56);
  }
  else {
    uint64_t v28 = *(const std::string::value_type **)(v1 + 56);
  }
  if (v27 >= 0) {
    std::string::size_type v29 = *(unsigned __int8 *)(v1 + 79);
  }
  else {
    std::string::size_type v29 = *(void *)(v1 + 64);
  }
  std::string v30 = std::string::append(&__dst, v28, v29);
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  std::string::size_type v58 = v30->__r_.__value_.__r.__words[2];
  long long v57 = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  Timestamp::Timestamp((Timestamp *)v54);
  char v53 = 0;
  LOBYTE(v52) = 0;
  char v51 = 0;
  LOBYTE(__p) = 0;
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v54, v55);
  if ((SHIBYTE(v58) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_176;
    }
LABEL_201:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (!*(void *)(v2 + 320)) {
      return;
    }
    goto LABEL_177;
  }
  operator delete((void *)v57);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_201;
  }
LABEL_176:
  if (!*(void *)(v2 + 320)) {
    return;
  }
LABEL_177:
  int v32 = *(char *)(v1 + 39);
  if (v32 >= 0) {
    size_t v33 = *(unsigned __int8 *)(v1 + 39);
  }
  else {
    size_t v33 = *(void *)(v1 + 24);
  }
  unint64_t v34 = v33 + 3;
  memset(&v49, 170, sizeof(v49));
  if (v33 + 3 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v34 >= 0x17)
  {
    uint64_t v36 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v34 | 7) != 0x17) {
      uint64_t v36 = v34 | 7;
    }
    uint64_t v37 = v36 + 1;
    uint64_t v35 = (char *)operator new(v36 + 1);
    v49.__r_.__value_.__l.__size_ = v33 + 3;
    v49.__r_.__value_.__r.__words[2] = v37 | 0x8000000000000000;
    v49.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
  }
  else
  {
    memset(&v49, 0, sizeof(v49));
    uint64_t v35 = (char *)&v49;
    *((unsigned char *)&v49.__r_.__value_.__s + 23) = v33 + 3;
    if (!v33) {
      goto LABEL_191;
    }
  }
  if (v32 >= 0) {
    uint64_t v38 = (const char *)(v1 + 16);
  }
  else {
    uint64_t v38 = *v3;
  }
  memmove(v35, v38, v33);
LABEL_191:
  *(_DWORD *)&v35[v33] = 2112800;
  long long v41 = *(const std::string::value_type **)(v1 + 56);
  uint64_t v40 = v1 + 56;
  uint64_t v39 = v41;
  int v42 = *(char *)(v40 + 23);
  if (v42 >= 0) {
    uint64_t v43 = (const std::string::value_type *)v40;
  }
  else {
    uint64_t v43 = v39;
  }
  if (v42 >= 0) {
    std::string::size_type v44 = *(unsigned __int8 *)(v40 + 23);
  }
  else {
    std::string::size_type v44 = *(void *)(v40 + 8);
  }
  uint64_t v45 = std::string::append(&v49, v43, v44);
  long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v46;
  v45->__r_.__value_.__l.__size_ = 0;
  v45->__r_.__value_.__r.__words[2] = 0;
  v45->__r_.__value_.__r.__words[0] = 0;
  Timestamp::Timestamp((Timestamp *)v47);
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v47, v48);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
  }
  else if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    return;
  }
  operator delete(v49.__r_.__value_.__l.__data_);
}

void sub_1A61582DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (*(char *)(v52 - 105) < 0)
  {
    operator delete(*(void **)(v52 - 128));
    if (v51)
    {
LABEL_5:
      dispatch_release(v51);
      _Unwind_Resume(a1);
    }
  }
  else if (v51)
  {
    goto LABEL_5;
  }
  _Unwind_Resume(a1);
}

void ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIZN8INTTrace11getPropertyERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERSB_E3__0EEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOSG__block_invoke(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 40);
  uint64_t v3 = (const char **)(v1 + 16);
  if ((*(char *)(v1 + 39) & 0x80000000) == 0)
  {
    if (strcasecmp((const char *)(v1 + 16), "Enabled"))
    {
      if (strcasecmp((const char *)(v1 + 16), "Live_Filter_Setting"))
      {
        if (strcasecmp((const char *)(v1 + 16), "History"))
        {
          if (strcasecmp((const char *)(v1 + 16), "Mode"))
          {
            if (strcasecmp((const char *)(v1 + 16), "Reset_Mode_Boot"))
            {
              if (strcasecmp((const char *)(v1 + 16), "TraceOwnership"))
              {
                if (strcasecmp((const char *)(v1 + 16), "File"))
                {
                  if (strcasecmp((const char *)(v1 + 16), "State"))
                  {
                    if (strcasecmp((const char *)(v1 + 16), "MaxMemoryFileCount"))
                    {
                      if (strcasecmp((const char *)(v1 + 16), "FileSize"))
                      {
                        if (strcasecmp((const char *)(v1 + 16), "SizeIO"))
                        {
                          if (strcasecmp((const char *)(v1 + 16), "NumberOfReadIO"))
                          {
                            if (strcasecmp((const char *)(v1 + 16), "Enabled_During_Sleep"))
                            {
                              if (strcasecmp((const char *)(v1 + 16), "File_Sleep"))
                              {
                                if (strcasecmp((const char *)(v1 + 16), "Error_Handling"))
                                {
                                  int v4 = (const char *)(v1 + 16);
                                  if (strcasecmp((const char *)(v1 + 16), "CellularLoggingAllowed"))
                                  {
LABEL_18:
                                    if (strcasecmp(v4, "Retain_Previous_Trace"))
                                    {
                                      **(unsigned char **)uint64_t v1 = 0;
                                      int v5 = *(NSObject **)(v2 + 40);
                                      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
                                      {
                                        if (*(char *)(v1 + 39) < 0) {
                                          uint64_t v3 = (const char **)*v3;
                                        }
                                        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                                        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
                                        _os_log_error_impl(&dword_1A609F000, v5, OS_LOG_TYPE_ERROR, "Key not handled: %s", (uint8_t *)&buf, 0xCu);
                                      }
                                      return;
                                    }
                                    int v40 = *(unsigned __int8 *)(v2 + 360);
                                    __p[0] = 0;
                                    *(void **)((char *)__p + 7) = 0;
                                    std::to_string(&buf, v40);
                                    goto LABEL_46;
                                  }
                                  goto LABEL_39;
                                }
                                goto LABEL_96;
                              }
LABEL_92:
                              std::string v16 = (void *)(v2 + 272);
                              uint64_t v17 = *(void *)(v1 + 8);
                              if (v17 == v2 + 272) {
                                return;
                              }
                              size_t v18 = *(unsigned __int8 *)(v2 + 295);
                              if ((*(char *)(v17 + 23) & 0x80000000) == 0)
                              {
                                if ((v18 & 0x80) != 0)
                                {
                                  std::string v30 = *(void **)(v2 + 272);
                                  size_t v31 = *(void *)(v2 + 280);
                                  goto LABEL_72;
                                }
                                goto LABEL_53;
                              }
                              int v24 = (char)v18;
                              uint64_t v25 = *(void **)(v2 + 272);
                              size_t v26 = *(void *)(v2 + 280);
LABEL_61:
                              if (v24 >= 0) {
                                int v27 = v16;
                              }
                              else {
                                int v27 = v25;
                              }
                              if (v24 >= 0) {
                                size_t v28 = v18;
                              }
                              else {
                                size_t v28 = v26;
                              }
                              std::string::__assign_no_alias<false>((void **)v17, v27, v28);
                              return;
                            }
LABEL_88:
                            capabilities::trace::asString();
                            uint64_t v35 = *(void *)(v1 + 8);
                            if ((std::string *)v35 != &buf)
                            {
                              if (*(char *)(v35 + 23) < 0)
                              {
                                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  p_std::string buf = &buf;
                                }
                                else {
                                  p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                                }
                                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                                  size_t size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                                }
                                else {
                                  size_t size = buf.__r_.__value_.__l.__size_;
                                }
                                std::string::__assign_no_alias<false>((void **)v35, p_buf, size);
                              }
                              else if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
                              {
                                std::string::__assign_no_alias<true>((void *)v35, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                              }
                              else
                              {
                                long long v36 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
                                *(void *)(v35 + 16) = *((void *)&buf.__r_.__value_.__l + 2);
                                *(_OWORD *)uint64_t v35 = v36;
                              }
                            }
                            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                              operator delete(buf.__r_.__value_.__l.__data_);
                            }
                            return;
                          }
                          goto LABEL_82;
                        }
                        goto LABEL_70;
                      }
                      goto LABEL_59;
                    }
                    goto LABEL_58;
                  }
                  goto LABEL_54;
                }
LABEL_50:
                std::string v16 = (void *)(v2 + 184);
                uint64_t v17 = *(void *)(v1 + 8);
                if (v17 == v2 + 184) {
                  return;
                }
                size_t v18 = *(unsigned __int8 *)(v2 + 207);
                if ((*(char *)(v17 + 23) & 0x80000000) == 0)
                {
                  if ((v18 & 0x80) != 0)
                  {
                    std::string v30 = *(void **)(v2 + 184);
                    size_t v31 = *(void *)(v2 + 192);
LABEL_72:
                    std::string::__assign_no_alias<true>((void *)v17, v30, v31);
                    return;
                  }
LABEL_53:
                  long long v19 = *(_OWORD *)v16;
                  *(void *)(v17 + 16) = v16[2];
                  *(_OWORD *)uint64_t v17 = v19;
                  return;
                }
                int v24 = (char)v18;
                uint64_t v25 = *(void **)(v2 + 184);
                size_t v26 = *(void *)(v2 + 192);
                goto LABEL_61;
              }
LABEL_45:
              int v12 = *(_DWORD *)(v2 + 208);
              __p[0] = 0;
              *(void **)((char *)__p + 7) = 0;
              std::to_string(&buf, v12);
              goto LABEL_46;
            }
LABEL_44:
            int v11 = *(_DWORD *)(v2 + 156);
            __p[0] = 0;
            *(void **)((char *)__p + 7) = 0;
            std::to_string(&buf, v11);
            goto LABEL_46;
          }
LABEL_43:
          int v10 = *(_DWORD *)(v2 + 152);
          __p[0] = 0;
          *(void **)((char *)__p + 7) = 0;
          std::to_string(&buf, v10);
          goto LABEL_46;
        }
LABEL_42:
        int v9 = *(_DWORD *)(v2 + 168);
        __p[0] = 0;
        *(void **)((char *)__p + 7) = 0;
        std::to_string(&buf, v9);
        goto LABEL_46;
      }
LABEL_41:
      int v8 = *(_DWORD *)(v2 + 172);
      __p[0] = 0;
      *(void **)((char *)__p + 7) = 0;
      std::to_string(&buf, v8);
      goto LABEL_46;
    }
LABEL_40:
    int v7 = *(unsigned __int8 *)(v2 + 160);
    __p[0] = 0;
    *(void **)((char *)__p + 7) = 0;
    std::to_string(&buf, v7);
    goto LABEL_46;
  }
  int v4 = *v3;
  if (!strcasecmp(*v3, "Enabled")) {
    goto LABEL_40;
  }
  if (!strcasecmp(v4, "Live_Filter_Setting")) {
    goto LABEL_41;
  }
  if (!strcasecmp(v4, "History")) {
    goto LABEL_42;
  }
  if (!strcasecmp(v4, "Mode")) {
    goto LABEL_43;
  }
  if (!strcasecmp(v4, "Reset_Mode_Boot")) {
    goto LABEL_44;
  }
  if (!strcasecmp(v4, "TraceOwnership")) {
    goto LABEL_45;
  }
  if (!strcasecmp(v4, "File")) {
    goto LABEL_50;
  }
  if (strcasecmp(v4, "State"))
  {
    if (strcasecmp(v4, "MaxMemoryFileCount"))
    {
      if (strcasecmp(v4, "FileSize"))
      {
        if (strcasecmp(v4, "SizeIO"))
        {
          if (strcasecmp(v4, "NumberOfReadIO"))
          {
            if (strcasecmp(v4, "Enabled_During_Sleep"))
            {
              if (strcasecmp(v4, "File_Sleep"))
              {
                if (strcasecmp(v4, "Error_Handling"))
                {
                  if (strcasecmp(v4, "CellularLoggingAllowed")) {
                    goto LABEL_18;
                  }
LABEL_39:
                  int v6 = *(unsigned __int8 *)(v2 + 352);
                  __p[0] = 0;
                  *(void **)((char *)__p + 7) = 0;
                  std::to_string(&buf, v6);
LABEL_46:
                  __p[0] = (void *)buf.__r_.__value_.__l.__size_;
                  std::string::size_type v13 = buf.__r_.__value_.__r.__words[0];
                  *(void **)((char *)__p + 7) = *(void **)((char *)&buf.__r_.__value_.__r.__words[1] + 7);
                  char v14 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  uint64_t v15 = *(void *)(v1 + 8);
                  if (*(char *)(v15 + 23) < 0) {
                    operator delete(*(void **)v15);
                  }
                  *(void *)uint64_t v15 = v13;
                  *(void **)(v15 + 8) = __p[0];
                  *(void **)(v15 + 15) = *(void **)((char *)__p + 7);
                  *(unsigned char *)(v15 + 23) = v14;
                  return;
                }
LABEL_96:
                int v37 = *(_DWORD *)(v2 + 356);
                __p[0] = 0;
                *(void **)((char *)__p + 7) = 0;
                std::to_string(&buf, v37);
                goto LABEL_46;
              }
              goto LABEL_92;
            }
            goto LABEL_88;
          }
LABEL_82:
          unsigned int v34 = *(_DWORD *)(v2 + 256);
          __p[0] = 0;
          *(void **)((char *)__p + 7) = 0;
          std::to_string(&buf, v34);
          goto LABEL_46;
        }
LABEL_70:
        unsigned int v29 = *(_DWORD *)(v2 + 252);
        __p[0] = 0;
        *(void **)((char *)__p + 7) = 0;
        std::to_string(&buf, v29);
        goto LABEL_46;
      }
LABEL_59:
      unsigned int v23 = *(_DWORD *)(v2 + 176);
      __p[0] = 0;
      *(void **)((char *)__p + 7) = 0;
      std::to_string(&buf, v23);
      goto LABEL_46;
    }
LABEL_58:
    unsigned int v22 = *(_DWORD *)(v2 + 180);
    __p[0] = 0;
    *(void **)((char *)__p + 7) = 0;
    std::to_string(&buf, v22);
    goto LABEL_46;
  }
LABEL_54:
  char v42 = 14;
  strcpy((char *)__p, "Get dump state");
  INTTrace::dumpState_sync(v2, (uint64_t)__p, &buf);
  uint64_t v20 = *(void *)(v1 + 8);
  if ((std::string *)v20 != &buf)
  {
    if (*(char *)(v20 + 23) < 0)
    {
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v32 = &buf;
      }
      else {
        int v32 = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v33 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t v33 = buf.__r_.__value_.__l.__size_;
      }
      std::string::__assign_no_alias<false>((void **)v20, v32, v33);
    }
    else if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)v20, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v21 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)(v20 + 16) = *((void *)&buf.__r_.__value_.__l + 2);
      *(_OWORD *)uint64_t v20 = v21;
    }
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (v42 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A6158D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    if (*(char *)(*(void *)(v21 + 8) + 23) < 0) {
      JUMPOUT(0x1A6158A10);
    }
    JUMPOUT(0x1A6158A18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __cxx_global_var_init_53()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_54()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<SharedData>::~PthreadMutexGuardPolicy, &ctu::Singleton<SharedData,SharedData,ctu::PthreadMutexGuardPolicy<SharedData>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_55()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A609F000);
  }
  return result;
}

double BasebandIPCTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  uint64_t v3 = (BasebandIPCTrace *)operator new(0xB8uLL);
  BasebandIPCTrace::BasebandIPCTrace(v3);
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<BasebandIPCTrace>::shared_ptr[abi:ne180100]<BasebandIPCTrace,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  double result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A6158FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A6159004(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void BasebandIPCTrace::BasebandIPCTrace(BasebandIPCTrace *this)
{
  char v6 = 11;
  strcpy((char *)__p, "trace.bbipc");
  Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this = &unk_1EFB0C620;
  char v4 = 11;
  strcpy((char *)v3, "BasebandIPC");
  char isSupported = abm::trace::isSupported((uint64_t)v3);
  if (v4 < 0) {
    operator delete(v3[0]);
  }
  *((unsigned char *)this + 152) = isSupported;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 20) = 0;
}

void sub_1A61590F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Trace::~Trace(v14);
  _Unwind_Resume(a1);
}

void sub_1A6159114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandIPCTrace::init(uint64_t a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    std::string v18 = *(std::string *)a2;
    int v7 = (std::__shared_weak_count *)a3[1];
    uint64_t v16 = *a3;
    uint64_t v17 = v7;
    if (!v7) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  int v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v16 = *a3;
  uint64_t v17 = v7;
  if (v7) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  int v8 = *a4;
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  int v9 = Trace::init(a1, (void **)&v18.__r_.__value_.__l.__data_, &v16, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v9) {
      goto LABEL_12;
    }
    return 0;
  }
  operator delete(v18.__r_.__value_.__l.__data_);
  if (!v9) {
    return 0;
  }
LABEL_12:
  char v14 = 7;
  strcpy((char *)v13, "Enabled");
  memset(&v19, 0, sizeof(v19));
  char v21 = 11;
  strcpy((char *)__p, "BasebandIPC");
  memset(&v23, 0, sizeof(v23));
  BOOL v10 = defaults::get((char *)__p, (char *)v13, &v23);
  if (v10)
  {
    prop::file::get<std::string>((const void **)__p, (uint64_t)v13, (uint64_t)&v23, &v22);
    std::string v19 = v22;
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_16:
      if (v10) {
        goto LABEL_17;
      }
LABEL_26:
      uint64_t v11 = 0;
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
  }
  else if ((v21 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(__p[0]);
  if (!v10) {
    goto LABEL_26;
  }
LABEL_17:
  uint64_t v11 = util::convert<BOOL>(&v19, (BOOL *)(a1 + 152), 0);
  if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_28;
  }
LABEL_27:
  operator delete(v19.__r_.__value_.__l.__data_);
LABEL_28:
  if ((v14 & 0x80000000) == 0) {
    return v11;
  }
  operator delete(v13[0]);
  return v11;
}

void sub_1A6159334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void BasebandIPCTrace::~BasebandIPCTrace(BasebandIPCTrace *this)
{
  *(void *)this = &unk_1EFB0C620;
  uint64_t v2 = (const void *)*((void *)this + 22);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    char v4 = this;
  }
  else
  {
    char v4 = this;
  }
  Trace::~Trace(v4);
}

{
  const void *v2;
  std::__shared_weak_count *v3;
  Trace *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EFB0C620;
  uint64_t v2 = (const void *)*((void *)this + 22);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    char v4 = this;
  }
  else
  {
    char v4 = this;
  }
  Trace::~Trace(v4);
}

{
  const void *v2;
  std::__shared_weak_count *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EFB0C620;
  uint64_t v2 = (const void *)*((void *)this + 22);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    Trace::~Trace(this);
  }
  else
  {
    Trace::~Trace(this);
  }
  operator delete(v4);
}

void BasebandIPCTrace::start(uint64_t a1, dispatch_object_t *a2)
{
  char v4 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v4);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 1174405120;
  v6[2] = ___ZN16BasebandIPCTrace5startEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
  v6[3] = &__block_descriptor_tmp_22;
  void v6[4] = a1;
  dispatch_group_t group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(group);
  }
  long long v5 = *a2;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  ctu::SharedSynchronizable<Trace>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v6);
  if (object) {
    dispatch_release(object);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
}

void ___ZN16BasebandIPCTrace5startEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1)
{
  *(void *)&v6.gr_gid = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(v2 + 152);
    LODWORD(v6.gr_passwd) = 67109120;
    HIDWORD(v6.gr_passwd) = v4;
    _os_log_impl(&dword_1A609F000, v3, OS_LOG_TYPE_DEFAULT, "#I Starting with enable = %d", (uint8_t *)&v6.gr_passwd, 8u);
  }
  if (*(unsigned char *)(v2 + 152))
  {
    long long v5 = *(char **)(a1 + 48);
    v6.gr_name = v5;
    if (v5) {
      dispatch_retain((dispatch_object_t)v5);
    }
    BasebandIPCTrace::start_sync((BasebandIPCTrace *)v2, &v6);
    if (v5) {
      dispatch_release((dispatch_object_t)v5);
    }
  }
}

void sub_1A6159814(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void BasebandIPCTrace::start_sync(BasebandIPCTrace *this, group *a2)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  gr_name = a2->gr_name;
  if (a2->gr_name)
  {
    dispatch_retain((dispatch_object_t)a2->gr_name);
    dispatch_group_enter((dispatch_group_t)gr_name);
  }
  int v4 = *((void *)this + 18);
  if (v4)
  {
    dispatch_retain(*((dispatch_object_t *)this + 18));
    dispatch_group_enter(v4);
  }
  char v65 = v4;
  std::string::size_type v66 = gr_name;
  if (*((void *)this + 20)) {
    goto LABEL_71;
  }
  long long v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Create command driver", (uint8_t *)&buf, 2u);
  }
  group v6 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  int v7 = (const void *)off_1EB5EE540;
  if (!off_1EB5EE540)
  {
    CommandDriverFactory::create_default_global((uint64_t *)&buf, v6);
    long long v8 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
    int v9 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
    off_1EB5EE540 = v8;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    size_t size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
    if (buf.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(buf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
    int v7 = (const void *)off_1EB5EE540;
  }
  v88[0] = v7;
  v88[1] = *((const void **)&off_1EB5EE540 + 1);
  if (*(&off_1EB5EE540 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE540 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  GetABMLogServer(&v86);
  uint64_t v11 = (capabilities::radio *)(*(void *(**)(std::string *__return_ptr, const void *, uint64_t *))(*(void *)v7 + 120))(&v91, v7, &v86);
  long long v12 = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
  *(_OWORD *)&v91.__r_.__value_.__l.__data_ = 0uLL;
  std::string::size_type v13 = (std::__shared_weak_count *)*((void *)this + 21);
  *((_OWORD *)this + 10) = v12;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  char v14 = (std::__shared_weak_count *)v91.__r_.__value_.__l.__size_;
  if (v91.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v91.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v15 = v87;
  if (v87 && !atomic_fetch_add(&v87->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)v88[1];
  if (v88[1] && !atomic_fetch_add((atomic_ullong *volatile)v88[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (!capabilities::radio::mav20Plus(v11)) {
    goto LABEL_71;
  }
  *(_DWORD *)((char *)v85 + 3) = 0;
  v85[0] = 0;
  *(_DWORD *)((char *)v84 + 3) = 0;
  v84[0] = 0;
  char v83 = 8;
  strcpy((char *)__p, "LogLevel");
  char v89 = 11;
  strcpy((char *)v88, "BasebandIPC");
  memset(&buf, 0, sizeof(buf));
  BOOL v17 = defaults::get((char *)v88, (char *)__p, &buf);
  if (v17)
  {
    prop::file::get<std::string>(v88, (uint64_t)__p, (uint64_t)&buf, &v91);
    std::string::size_type v19 = v91.__r_.__value_.__l.__size_;
    std::string v18 = (std::string::value_type *)v91.__r_.__value_.__r.__words[0];
    v85[0] = v91.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v85 + 3) = *(_DWORD *)((char *)&v91.__r_.__value_.__r.__words[2] + 3);
    char v20 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_36;
    }
  }
  else
  {
    std::string v18 = 0;
    std::string::size_type v19 = 0;
    char v20 = 0;
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_36;
    }
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_36:
  if ((v89 & 0x80000000) == 0)
  {
    if ((v83 & 0x80000000) == 0) {
      goto LABEL_38;
    }
LABEL_42:
    operator delete(__p[0]);
    if (v17) {
      goto LABEL_39;
    }
    goto LABEL_43;
  }
  operator delete((void *)v88[0]);
  if (v83 < 0) {
    goto LABEL_42;
  }
LABEL_38:
  if (v17)
  {
LABEL_39:
    uint64_t v21 = *((void *)this + 20);
    char v81 = 8;
    strcpy((char *)v80, "LogLevel");
    if (v20 < 0)
    {
      std::string::__init_copy_ctor_external(&v79, v18, v19);
    }
    else
    {
      v79.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
      v79.__r_.__value_.__l.__size_ = v19;
      LODWORD(v79.__r_.__value_.__r.__words[2]) = v85[0];
      *(_DWORD *)((char *)&v79.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v85 + 3);
      *((unsigned char *)&v79.__r_.__value_.__s + 23) = v20;
    }
    (*(void (**)(uint64_t, void **, std::string *))(*(void *)v21 + 72))(v21, v80, &v79);
    if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v79.__r_.__value_.__l.__data_);
    }
    if (v81 < 0) {
      operator delete(v80[0]);
    }
    goto LABEL_50;
  }
LABEL_43:
  std::string v22 = *((void *)this + 5);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl(&dword_1A609F000, v22, OS_LOG_TYPE_ERROR, "Failed to get LogLevel", (uint8_t *)&buf, 2u);
  }
LABEL_50:
  char v83 = 11;
  strcpy((char *)__p, "PayloadSize");
  char v89 = 11;
  strcpy((char *)v88, "BasebandIPC");
  memset(&buf, 0, sizeof(buf));
  BOOL v23 = defaults::get((char *)v88, (char *)__p, &buf);
  if (v23)
  {
    prop::file::get<std::string>(v88, (uint64_t)__p, (uint64_t)&buf, &v91);
    std::string::size_type v25 = v91.__r_.__value_.__l.__size_;
    int v24 = (std::string::value_type *)v91.__r_.__value_.__r.__words[0];
    v84[0] = v91.__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v84 + 3) = *(_DWORD *)((char *)&v91.__r_.__value_.__r.__words[2] + 3);
    char v26 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_55;
    }
  }
  else
  {
    int v24 = 0;
    std::string::size_type v25 = 0;
    char v26 = 0;
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_55;
    }
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_55:
  if ((v89 & 0x80000000) == 0)
  {
    if ((v83 & 0x80000000) == 0) {
      goto LABEL_57;
    }
LABEL_61:
    operator delete(__p[0]);
    if (v23) {
      goto LABEL_58;
    }
LABEL_62:
    size_t v28 = *((void *)this + 5);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1A609F000, v28, OS_LOG_TYPE_ERROR, "Failed to get MHI PayloadSize", (uint8_t *)&buf, 2u);
    }
    goto LABEL_69;
  }
  operator delete((void *)v88[0]);
  if (v83 < 0) {
    goto LABEL_61;
  }
LABEL_57:
  if (!v23) {
    goto LABEL_62;
  }
LABEL_58:
  uint64_t v27 = *((void *)this + 20);
  char v78 = 11;
  strcpy((char *)v77, "PayloadSize");
  if (v26 < 0)
  {
    std::string::__init_copy_ctor_external(&v76, v24, v25);
  }
  else
  {
    v76.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
    v76.__r_.__value_.__l.__size_ = v25;
    LODWORD(v76.__r_.__value_.__r.__words[2]) = v84[0];
    *(_DWORD *)((char *)&v76.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v84 + 3);
    *((unsigned char *)&v76.__r_.__value_.__s + 23) = v26;
  }
  (*(void (**)(uint64_t, void **, std::string *))(*(void *)v27 + 72))(v27, v77, &v76);
  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v76.__r_.__value_.__l.__data_);
  }
  if (v78 < 0) {
    operator delete(v77[0]);
  }
LABEL_69:
  if (v26 < 0)
  {
    operator delete(v24);
    gr_name = (char *)v66;
    if ((v20 & 0x80) == 0) {
      goto LABEL_71;
    }
  }
  else
  {
    gr_name = (char *)v66;
    if ((v20 & 0x80) == 0) {
      goto LABEL_71;
    }
  }
  operator delete(v18);
LABEL_71:
  *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf.__r_.__value_.__l.__size_;
  unsigned int v29 = (char *)operator new(0x38uLL);
  *((_WORD *)v29 + 16) = 42;
  *(_OWORD *)(v29 + 34) = *(_OWORD *)&v91.__r_.__value_.__l.__data_;
  *(void *)(v29 + 47) = *(std::string::size_type *)((char *)&v91.__r_.__value_.__r.__words[1] + 5);
  v29[55] = 1;
  *(void *)unsigned int v29 = 0;
  *((void *)v29 + 1) = 0;
  *((void *)v29 + 2) = &buf.__r_.__value_.__l.__size_;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v29;
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v29, (uint64_t *)v29);
  ++buf.__r_.__value_.__r.__words[2];
  v91.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v91.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1174405120;
  aBlock[2] = ___ZN16BasebandIPCTrace10start_syncEN8dispatch5groupE_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_5_4;
  aBlock[4] = this;
  dispatch_group_t group = (dispatch_group_t)gr_name;
  if (gr_name)
  {
    dispatch_retain((dispatch_object_t)gr_name);
    dispatch_group_enter(group);
  }
  dispatch_group_t v75 = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v75);
  }
  int v67 = _Block_copy(aBlock);
  std::string::size_type v30 = *((void *)this + 11);
  if (v30) {
    dispatch_retain(*((dispatch_object_t *)this + 11));
  }
  v91.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
  v91.__r_.__value_.__l.__size_ = v30;
  uint64_t v64 = *((void *)this + 20);
  long long v71 = 0;
  uint64_t v72 = 0;
  long long v70 = &v71;
  std::string::size_type v31 = buf.__r_.__value_.__r.__words[0];
  if ((std::string::size_type *)buf.__r_.__value_.__l.__data_ != &buf.__r_.__value_.__r.__words[1])
  {
    int v32 = 0;
    p_size_t size = buf.__r_.__value_.__r.__words[0] + 32;
    unsigned int v34 = &v71;
LABEL_123:
    if (v32) {
      std::string::size_type v47 = v34;
    }
    else {
      std::string::size_type v47 = &v71;
    }
    dispatch_time_t v55 = &v70;
    if (v32)
    {
      dispatch_time_t v55 = (uint64_t ***)v34;
      long long v46 = v34 + 1;
    }
    else
    {
      long long v46 = &v71;
    }
    if (v55[1])
    {
LABEL_130:
      xpc_object_t v56 = *(std::string **)(v31 + 8);
      if (v56) {
        goto LABEL_138;
      }
      do
      {
LABEL_140:
        char v60 = *(std::string **)(v31 + 16);
        BOOL v37 = v60->__r_.__value_.__r.__words[0] == v31;
        std::string::size_type v31 = (std::string::size_type)v60;
      }
      while (!v37);
      goto LABEL_142;
    }
    while (1)
    {
LABEL_132:
      long long v57 = (uint64_t *)operator new(0x38uLL);
      std::string::size_type v58 = (std::string *)(v57 + 4);
      if (*(char *)(v31 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v58, *(const std::string::value_type **)(v31 + 32), *(void *)(v31 + 40));
      }
      else
      {
        long long v59 = *(_OWORD *)p_size;
        v57[6] = *(void *)(p_size + 16);
        *(_OWORD *)&v58->__r_.__value_.__l.__data_ = v59;
      }
      *long long v57 = 0;
      v57[1] = 0;
      v57[2] = (uint64_t)v47;
      NSObject *v46 = v57;
      if (*v70)
      {
        long long v70 = (uint64_t **)*v70;
        long long v57 = *v46;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v71, v57);
      ++v72;
      xpc_object_t v56 = *(std::string **)(v31 + 8);
      if (!v56) {
        goto LABEL_140;
      }
      do
      {
LABEL_138:
        char v60 = v56;
        xpc_object_t v56 = (std::string *)v56->__r_.__value_.__r.__words[0];
      }
      while (v56);
LABEL_142:
      if (v60 == (std::string *)&buf.__r_.__value_.__r.__words[1]) {
        break;
      }
      int v32 = v71;
      std::string::size_type v31 = (std::string::size_type)v60;
      p_size_t size = (std::string::size_type)&v60[1].__r_.__value_.__l.__size_;
      unsigned int v34 = &v71;
      if (v70 == &v71) {
        goto LABEL_123;
      }
      uint64_t v35 = v71;
      long long v36 = &v71;
      if (v71)
      {
        do
        {
          unsigned int v34 = (uint64_t **)v35;
          uint64_t v35 = (uint64_t *)v35[1];
        }
        while (v35);
      }
      else
      {
        do
        {
          unsigned int v34 = (uint64_t **)v36[2];
          BOOL v37 = *v34 == (uint64_t *)v36;
          long long v36 = v34;
        }
        while (v37);
      }
      int v38 = *((char *)v34 + 55);
      if (v38 >= 0) {
        uint64_t v39 = (uint64_t *)(v34 + 4);
      }
      else {
        uint64_t v39 = v34[4];
      }
      if (v38 >= 0) {
        size_t v40 = *((unsigned __int8 *)v34 + 55);
      }
      else {
        size_t v40 = (size_t)v34[5];
      }
      int v41 = *(char *)(v31 + 55);
      if (v41 >= 0) {
        char v42 = (const void *)p_size;
      }
      else {
        char v42 = *(const void **)(v31 + 32);
      }
      if (v41 >= 0) {
        size_t v43 = *(unsigned __int8 *)(v31 + 55);
      }
      else {
        size_t v43 = *(void *)(v31 + 40);
      }
      if (v43 >= v40) {
        size_t v44 = v40;
      }
      else {
        size_t v44 = v43;
      }
      int v45 = memcmp(v39, v42, v44);
      if (v45)
      {
        if (v45 < 0) {
          goto LABEL_123;
        }
      }
      else if (v40 < v43)
      {
        goto LABEL_123;
      }
      long long v46 = &v71;
      std::string::size_type v47 = &v71;
      if (v32)
      {
        while (1)
        {
          std::string::size_type v47 = (uint64_t **)v32;
          size_t v48 = *((unsigned __int8 *)v32 + 55);
          uint64_t v49 = v32[5];
          if ((v48 & 0x80u) == 0) {
            unsigned int v50 = v32 + 4;
          }
          else {
            unsigned int v50 = (const void *)v32[4];
          }
          if ((v48 & 0x80u) == 0) {
            size_t v51 = v48;
          }
          else {
            size_t v51 = v49;
          }
          if (v51 >= v43) {
            size_t v52 = v43;
          }
          else {
            size_t v52 = v51;
          }
          int v53 = memcmp(v42, v50, v52);
          if (v53)
          {
            if (v53 < 0) {
              goto LABEL_102;
            }
LABEL_116:
            int v54 = memcmp(v50, v42, v52);
            if (v54)
            {
              if ((v54 & 0x80000000) == 0) {
                goto LABEL_130;
              }
            }
            else if (v51 >= v43)
            {
              goto LABEL_130;
            }
            int v32 = v47[1];
            if (!v32)
            {
              long long v46 = v47 + 1;
              goto LABEL_132;
            }
          }
          else
          {
            if (v43 >= v51) {
              goto LABEL_116;
            }
LABEL_102:
            int v32 = *v47;
            long long v46 = v47;
            if (!*v47) {
              goto LABEL_132;
            }
          }
        }
      }
    }
  }
  dispatch_time_t v61 = dispatch_time(0, 8000000000);
  if (v67)
  {
    uint64_t v62 = _Block_copy(v67);
    std::string::size_type v63 = v91.__r_.__value_.__l.__size_;
    uint64_t v68 = v62;
    dispatch_object_t object = (dispatch_object_t)v91.__r_.__value_.__l.__size_;
    if (!v91.__r_.__value_.__l.__size_) {
      goto LABEL_148;
    }
    goto LABEL_147;
  }
  std::string::size_type v63 = v91.__r_.__value_.__l.__size_;
  uint64_t v68 = 0;
  dispatch_object_t object = (dispatch_object_t)v91.__r_.__value_.__l.__size_;
  if (v91.__r_.__value_.__l.__size_) {
LABEL_147:
  }
    dispatch_retain(v63);
LABEL_148:
  (*(void (**)(uint64_t, uint64_t ***, dispatch_time_t, void **))(*(void *)v64 + 48))(v64, &v70, v61, &v68);
  if (object) {
    dispatch_release(object);
  }
  if (v68) {
    _Block_release(v68);
  }
  std::__tree<std::string>::destroy((char *)v71);
  if (v63) {
    dispatch_release(v63);
  }
  if (v67) {
    _Block_release(v67);
  }
  if (v75)
  {
    dispatch_group_leave(v75);
    if (v75) {
      dispatch_release(v75);
    }
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  std::__tree<std::string>::destroy((char *)buf.__r_.__value_.__l.__size_);
  if (v65)
  {
    dispatch_group_leave(v65);
    dispatch_release(v65);
  }
  if (v66)
  {
    dispatch_group_leave(v66);
    dispatch_release(v66);
  }
}

void sub_1A615A37C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, dispatch_group_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,dispatch_group_t a23,dispatch_group_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a36 < 0)
  {
    operator delete(__p);
    if ((v54 & 0x80) == 0) {
      goto LABEL_6;
    }
  }
  else if ((v54 & 0x80) == 0)
  {
LABEL_6:
    if (v57 < 0) {
      operator delete(v55);
    }
    if (group)
    {
      dispatch_group_leave(group);
      dispatch_release(group);
    }
    if (a11)
    {
      dispatch_group_leave(a11);
      dispatch_release(a11);
    }
    _Unwind_Resume(exception_object);
  }
  operator delete(v56);
  goto LABEL_6;
}

void ___ZN16BasebandIPCTrace10start_syncEN8dispatch5groupE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  if (*a2) {
    uint64_t v3 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    int v4 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = v2;
      _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#E Enabling failed: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE(uint64_t a1, uint64_t a2)
{
  int v4 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    int v5 = *(NSObject **)(a1 + 40);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 48) = v6;
  if (v6)
  {
    dispatch_retain(v6);
    uint64_t v7 = *(NSObject **)(a1 + 48);
    if (v7)
    {
      dispatch_group_enter(v7);
    }
  }
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 48);
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = *(NSObject **)(a1 + 40);
  if (v4)
  {
    dispatch_group_leave(v4);
    int v5 = *(NSObject **)(a1 + 40);
    if (v5)
    {
      dispatch_release(v5);
    }
  }
}

void BasebandIPCTrace::abort(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  int v4 = *(NSObject **)(a1 + 144);
  if (v4)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 144));
    dispatch_group_enter(v4);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 1174405120;
  v5[2] = ___ZN16BasebandIPCTrace5abortEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
  v5[3] = &__block_descriptor_tmp_8_1;
  v5[4] = a1;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(group);
  }
  dispatch_group_t object = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(object);
  }
  ctu::SharedSynchronizable<Trace>::execute_wrapped((uint64_t *)(a1 + 72), (uint64_t)v5);
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
}

void ___ZN16BasebandIPCTrace5abortEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Aborting", v6, 2u);
  }
  uint64_t v3 = v1[20];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
  }
  int v4 = (std::__shared_weak_count *)v1[21];
  v1[20] = 0;
  v1[21] = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    int v5 = (const void *)v1[22];
    v1[22] = 0;
    if (!v5) {
      return;
    }
  }
  else
  {
    int v5 = (const void *)v1[22];
    v1[22] = 0;
    if (!v5) {
      return;
    }
  }
  CFRelease(v5);
}

uint64_t BasebandIPCTrace::snapshot(uint64_t a1, NSObject **a2, const __CFDictionary **a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  v38[0] = 0xAAAAAAAAAAAAAAAALL;
  v38[1] = 0xAAAAAAAAAAAAAAAALL;
  ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v38, *a3);
  memset(v37, 170, sizeof(v37));
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "kKeyTraceAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](buf);
  memset(__p, 170, sizeof(__p));
  strcpy((char *)buf, "kTraceFilterActionNone");
  char v41 = 22;
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v39, "kKeyTraceFilterAction");
  ctu::cf::map_adapter::getString();
  MEMORY[0x1A62748E0](&v39);
  if (v41 < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v6 = (void *)HIBYTE(__p[2]);
  int v7 = SHIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0) {
    uint64_t v6 = __p[1];
  }
  if (v6 != (void *)22) {
    goto LABEL_15;
  }
  long long v8 = (void **)__p[0];
  if (SHIBYTE(__p[2]) >= 0) {
    long long v8 = __p;
  }
  int v9 = *v8;
  BOOL v10 = v8[1];
  uint64_t v11 = *(uint64_t *)((char *)v8 + 14);
  BOOL v12 = v9 == *(void **)"kTraceFilterActionNone" && v10 == *(void **)"lterActionNone";
  if (!v12 || v11 != *(void *)"tionNone")
  {
LABEL_15:
    char v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    uint64_t v15 = (void **)__p[0];
    if (v7 >= 0) {
      uint64_t v15 = __p;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    uint64_t v16 = "#I Skipping snapshot as trace filter is '%s'";
    BOOL v17 = v14;
    uint32_t v18 = 12;
    goto LABEL_19;
  }
  char v20 = (void *)HIBYTE(v37[2]);
  if (SHIBYTE(v37[2]) < 0) {
    char v20 = v37[1];
  }
  if (v20 != (void *)21) {
    goto LABEL_37;
  }
  uint64_t v21 = v37;
  if (SHIBYTE(v37[2]) < 0) {
    uint64_t v21 = (void **)v37[0];
  }
  std::string v22 = *v21;
  BOOL v23 = v21[1];
  uint64_t v24 = *(uint64_t *)((char *)v21 + 13);
  BOOL v25 = v22 == *(void **)"kCollectTelephonyLogs" && v23 == *(void **)"TelephonyLogs";
  if (v25 && v24 == *(void *)"honyLogs")
  {
    size_t v28 = *a2;
    if (v28)
    {
      dispatch_retain(v28);
      dispatch_group_enter(v28);
    }
    unsigned int v29 = *(NSObject **)(a1 + 144);
    if (v29)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 144));
      dispatch_group_enter(v29);
    }
    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 1174405120;
    void v32[2] = ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    v32[3] = &__block_descriptor_tmp_11_2;
    v32[4] = a1;
    dispatch_group_t group = v28;
    if (v28)
    {
      dispatch_retain(v28);
      dispatch_group_enter(group);
    }
    CFDictionaryRef v30 = *a3;
    CFTypeRef cf = v30;
    if (v30) {
      CFRetain(v30);
    }
    std::string::size_type v31 = (uint64_t *)(a1 + 72);
    dispatch_group_t object = v29;
    if (v29)
    {
      dispatch_retain(v29);
      dispatch_group_enter(object);
    }
    ctu::SharedSynchronizable<Trace>::execute_wrapped(v31, (uint64_t)v32);
    if (object)
    {
      dispatch_group_leave(object);
      if (object) {
        dispatch_release(object);
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
    if (v29)
    {
      dispatch_group_leave(v29);
      dispatch_release(v29);
    }
    if (v28)
    {
      dispatch_group_leave(v28);
      dispatch_release(v28);
    }
  }
  else
  {
LABEL_37:
    uint64_t v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v16 = "#I Skipping";
      BOOL v17 = v27;
      uint32_t v18 = 2;
LABEL_19:
      _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    }
  }
LABEL_20:
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v37[2]) & 0x80000000) == 0) {
      return MEMORY[0x1A6274930](v38);
    }
LABEL_24:
    operator delete(v37[0]);
    return MEMORY[0x1A6274930](v38);
  }
  if (SHIBYTE(v37[2]) < 0) {
    goto LABEL_24;
  }
  return MEMORY[0x1A6274930](v38);
}

void sub_1A615AD8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  if (*(unsigned char *)(v1 + 152))
  {
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v3 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
    uint64_t v4 = xmmword_1EB5EE590;
    if (!(void)xmmword_1EB5EE590)
    {
      ctu::XpcJetsamAssertion::create_default_global((uint64_t *)&v31, v3);
      long long v5 = v31;
      long long v31 = 0uLL;
      uint64_t v6 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
      xmmword_1EB5EE590 = v5;
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      int v7 = (std::__shared_weak_count *)*((void *)&v31 + 1);
      if (*((void *)&v31 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v31 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      uint64_t v4 = xmmword_1EB5EE590;
    }
    long long v8 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
    uint64_t v27 = v4;
    uint64_t v28 = *((void *)&xmmword_1EB5EE590 + 1);
    if (*((void *)&xmmword_1EB5EE590 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
    std::string __p = operator new(0x20uLL);
    long long v26 = xmmword_1A61F7570;
    strcpy((char *)__p, "Baseband IPC Trace Snapshot");
    ctu::XpcJetsamAssertion::createActivity();
    operator delete(__p);
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    int v9 = dispatch_group_create();
    BOOL v10 = v9;
    uint64_t v24 = v9;
    if (v9) {
      dispatch_retain(v9);
    }
    uint64_t v11 = (const void *)a1[6];
    BOOL v23 = v11;
    if (v11) {
      CFRetain(v11);
    }
    BasebandIPCTrace::collect_sync(v1, &v24);
    if (v11) {
      CFRelease(v11);
    }
    if (v10) {
      dispatch_release(v10);
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 1174405120;
    block[2] = ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2;
    block[3] = &__block_descriptor_tmp_10_2;
    BOOL v12 = a1[5];
    void block[4] = v1;
    dispatch_group_t group = v12;
    if (v12)
    {
      dispatch_retain(v12);
      dispatch_group_enter(group);
    }
    std::string::size_type v13 = a1[7];
    dispatch_group_t object = v13;
    if (v13)
    {
      dispatch_retain(v13);
      dispatch_group_enter(object);
    }
    unint64_t v20 = v29;
    uint64_t v21 = (std::__shared_weak_count *)v30;
    if (v30) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
    }
    char v14 = (const void *)a1[6];
    CFTypeRef cf = v14;
    if (v14) {
      CFRetain(v14);
    }
    dispatch_group_notify(v10, *(dispatch_queue_t *)(v1 + 88), block);
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v15 = v21;
    if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    if (object)
    {
      dispatch_group_leave(object);
      if (object) {
        dispatch_release(object);
      }
    }
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
    if (v10) {
      dispatch_release(v10);
    }
    uint64_t v16 = (std::__shared_weak_count *)v30;
    if (v30)
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)(v30 + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
}

void sub_1A615B1D0(_Unwind_Exception *a1)
{
}

void sub_1A615B1FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  if (v12)
  {
    dispatch_release(v12);
    dispatch_release(v12);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v13 - 64);
  _Unwind_Resume(a1);
}

void sub_1A615B22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v27 - 80);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v27 - 80);
  _Unwind_Resume(a1);
}

void BasebandIPCTrace::collect_sync(uint64_t a1, NSObject **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Collecting", buf, 2u);
  }
  if (*(void *)(a1 + 160))
  {
    long long v5 = *a2;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    uint64_t v6 = *(NSObject **)(a1 + 144);
    if (v6)
    {
      dispatch_retain(*(dispatch_object_t *)(a1 + 144));
      dispatch_group_enter(v6);
    }
    memset(buf, 170, sizeof(buf));
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN16BasebandIPCTrace12collect_syncEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_17_0;
    aBlock[4] = a1;
    dispatch_group_t group = v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(group);
    }
    dispatch_group_t v17 = v6;
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v17);
    }
    int v7 = (config::hw *)_Block_copy(aBlock);
    long long v8 = v7;
    int v9 = *(NSObject **)(a1 + 88);
    if (v9) {
      dispatch_retain(*(dispatch_object_t *)(a1 + 88));
    }
    *(void *)std::string buf = v8;
    *(void *)&uint8_t buf[8] = v9;
    uint64_t v10 = *(void *)(a1 + 160);
    if (config::hw::watch(v7)) {
      int64_t v11 = 12000000000;
    }
    else {
      int64_t v11 = 10000000000;
    }
    dispatch_time_t v12 = dispatch_time(0, v11);
    if (v8)
    {
      uint64_t v13 = _Block_copy(v8);
      dispatch_object_t object = v9;
      if (!v9)
      {
LABEL_20:
        (*(void (**)(uint64_t, dispatch_time_t, void **))(*(void *)v10 + 56))(v10, v12, &v13);
        if (object) {
          dispatch_release(object);
        }
        if (v13) {
          _Block_release(v13);
        }
        if (v9) {
          dispatch_release(v9);
        }
        if (v8) {
          _Block_release(v8);
        }
        if (v17)
        {
          dispatch_group_leave(v17);
          if (v17) {
            dispatch_release(v17);
          }
        }
        if (group)
        {
          dispatch_group_leave(group);
          if (group) {
            dispatch_release(group);
          }
        }
        if (v6)
        {
          dispatch_group_leave(v6);
          dispatch_release(v6);
        }
        if (v5)
        {
          dispatch_group_leave(v5);
          dispatch_release(v5);
        }
        return;
      }
    }
    else
    {
      uint64_t v13 = 0;
      dispatch_object_t object = v9;
      if (!v9) {
        goto LABEL_20;
      }
    }
    dispatch_retain(v9);
    goto LABEL_20;
  }
}

void sub_1A615B4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t object, dispatch_group_t group)
{
  dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback((uint64_t)&a10);
  dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback(v20 - 64);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (object)
  {
    dispatch_group_leave(object);
    if (object) {
      dispatch_release(object);
    }
  }
  if (v19)
  {
    dispatch_group_leave(v19);
    dispatch_release(v19);
    if (!v18) {
LABEL_9:
    }
      _Unwind_Resume(a1);
  }
  else if (!v18)
  {
    goto LABEL_9;
  }
  dispatch_group_leave(v18);
  dispatch_release(v18);
  _Unwind_Resume(a1);
}

void ___ZN16BasebandIPCTrace8snapshotEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(BasebandIPCTrace **)(a1 + 32);
  uint64_t v2 = *(char **)(a1 + 72);
  v3.gr_passwd = v2;
  if (v2) {
    CFRetain(v2);
  }
  BasebandIPCTrace::write_sync((uint64_t)v1, (const __CFDictionary **)&v3.gr_passwd);
  if (v2) {
    CFRelease(v2);
  }
  v3.gr_name = 0;
  BasebandIPCTrace::start_sync(v1, &v3);
}

void sub_1A615B5D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t BasebandIPCTrace::write_sync(uint64_t result, const __CFDictionary **a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (*(void *)(result + 176)) {
    uint64_t v2 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    uint64_t v4 = result;
    long long v5 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Captured cached data", (uint8_t *)&buf, 2u);
    }
    v60[0] = 0xAAAAAAAAAAAAAAAALL;
    v60[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v60, *a2);
    memset(v59, 170, sizeof(v59));
    uint64_t v6 = (const void *)*MEMORY[0x1E4F4C3A0];
    size_t v7 = strlen((const char *)*MEMORY[0x1E4F4C3A0]);
    if (v7 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v8 = v7;
    if (v7 >= 0x17)
    {
      uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v10 = v7 | 7;
      }
      uint64_t v11 = v10 + 1;
      p_std::string buf = (std::string *)operator new(v10 + 1);
      buf.__r_.__value_.__l.__size_ = v8;
      buf.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    }
    else
    {
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = v7;
      p_std::string buf = &buf;
      if (!v7)
      {
LABEL_15:
        dispatch_time_t v12 = (const char *)*MEMORY[0x1E4F4C4C8];
        p_buf->__r_.__value_.__s.__data_[v8] = 0;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v58, v12);
        ctu::cf::map_adapter::getString();
        MEMORY[0x1A62748E0](v58);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        memset(v58, 170, sizeof(v58));
        uint64_t v13 = abm::trace::kSnapshotFolder[0];
        size_t v14 = strlen(abm::trace::kSnapshotFolder[0]);
        if (v14 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v15 = v14;
        if (v14 >= 0x17)
        {
          uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v14 | 7) != 0x17) {
            uint64_t v17 = v14 | 7;
          }
          uint64_t v18 = v17 + 1;
          uint64_t v16 = (std::string *)operator new(v17 + 1);
          buf.__r_.__value_.__l.__size_ = v15;
          buf.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
        }
        else
        {
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = v14;
          uint64_t v16 = &buf;
          if (!v14)
          {
LABEL_25:
            v16->__r_.__value_.__s.__data_[v15] = 0;
            ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)__p, "kKeyTraceDumpStatePath");
            ctu::cf::map_adapter::getString();
            MEMORY[0x1A62748E0](__p);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            std::string::size_type v19 = abm::trace::kLogDirPrefix[0];
            size_t v20 = strlen(abm::trace::kLogDirPrefix[0]);
            if (v20 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            std::string::size_type v21 = v20;
            if (v20 >= 0x17)
            {
              uint64_t v23 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v20 | 7) != 0x17) {
                uint64_t v23 = v20 | 7;
              }
              uint64_t v24 = v23 + 1;
              p_dst = (std::string *)operator new(v23 + 1);
              __dst.__r_.__value_.__l.__size_ = v21;
              __dst.__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }
            else
            {
              *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v20;
              p_dst = &__dst;
              if (!v20)
              {
LABEL_35:
                p_dst->__r_.__value_.__s.__data_[v21] = 0;
                if (SHIBYTE(v58[2]) >= 0) {
                  BOOL v25 = v58;
                }
                else {
                  BOOL v25 = (void **)v58[0];
                }
                if (SHIBYTE(v58[2]) >= 0) {
                  std::string::size_type v26 = HIBYTE(v58[2]);
                }
                else {
                  std::string::size_type v26 = (std::string::size_type)v58[1];
                }
                uint64_t v27 = std::string::insert(&__dst, 0, (const std::string::value_type *)v25, v26);
                long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
                v55.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v28;
                v27->__r_.__value_.__l.__size_ = 0;
                v27->__r_.__value_.__r.__words[2] = 0;
                v27->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(v59[2]) >= 0) {
                  unint64_t v29 = (const std::string::value_type *)v59;
                }
                else {
                  unint64_t v29 = (const std::string::value_type *)v59[0];
                }
                if (SHIBYTE(v59[2]) >= 0) {
                  std::string::size_type v30 = HIBYTE(v59[2]);
                }
                else {
                  std::string::size_type v30 = (std::string::size_type)v59[1];
                }
                long long v31 = std::string::append(&v55, v29, v30);
                long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
                buf.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
                *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v32;
                v31->__r_.__value_.__l.__size_ = 0;
                v31->__r_.__value_.__r.__words[2] = 0;
                v31->__r_.__value_.__r.__words[0] = 0;
                size_t v33 = std::string::append(&buf, "-bbipc", 6uLL);
                long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
                int64_t v57 = v33->__r_.__value_.__r.__words[2];
                *(_OWORD *)std::string __p = v34;
                v33->__r_.__value_.__l.__size_ = 0;
                v33->__r_.__value_.__r.__words[2] = 0;
                v33->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(buf.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_49:
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_50;
                    }
LABEL_65:
                    operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_50:
                    memset(&v55, 170, sizeof(v55));
                    uint64_t v35 = abm::trace::kScratchFolder[0];
                    size_t v36 = strlen(abm::trace::kScratchFolder[0]);
                    if (v36 > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    std::string::size_type v37 = v36;
                    if (v36 >= 0x17)
                    {
                      uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v36 | 7) != 0x17) {
                        uint64_t v39 = v36 | 7;
                      }
                      uint64_t v40 = v39 + 1;
                      int v38 = (std::string *)operator new(v39 + 1);
                      buf.__r_.__value_.__l.__size_ = v37;
                      buf.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
                      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
                    }
                    else
                    {
                      *((unsigned char *)&buf.__r_.__value_.__s + 23) = v36;
                      int v38 = &buf;
                      if (!v36)
                      {
LABEL_58:
                        v38->__r_.__value_.__s.__data_[v37] = 0;
                        char v41 = std::string::append(&buf, "BBIPCScratch", 0xCuLL);
                        long long v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
                        v55.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
                        *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v42;
                        v41->__r_.__value_.__l.__size_ = 0;
                        v41->__r_.__value_.__r.__words[2] = 0;
                        v41->__r_.__value_.__r.__words[0] = 0;
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(buf.__r_.__value_.__l.__data_);
                        }
                        if (support::fs::createDir((const char *)&v55, 0x1EDu, 1))
                        {
                          CFDictionaryRef v43 = *(const __CFDictionary **)(v4 + 176);
                          v52[0] = MEMORY[0x1E4F143A8];
                          v52[1] = 1174405120;
                          v52[2] = ___ZN16BasebandIPCTrace10write_syncEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke;
                          v52[3] = &__block_descriptor_tmp_20_4;
                          if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
                            std::string::__init_copy_ctor_external(&v53, v55.__r_.__value_.__l.__data_, v55.__r_.__value_.__l.__size_);
                          }
                          else {
                            std::string v53 = v55;
                          }
                          buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
                          buf.__r_.__value_.__l.__size_ = 0x40000000;
                          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN3ctu2cf8for_eachINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEPK8__CFDataEEvPK14__CFDictionaryU13block_pointerFvRKT_RKT0_E_block_invoke;
                          uint64_t v62 = &unk_1E5C47B60;
                          std::string::size_type v63 = v52;
                          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
                          CFDictionaryApplyFunction(v43, (CFDictionaryApplierFunction)ctu::cf::DictApplyFunction, &__dst);
                          if (support::fs::createDir((const char *)__p, 0x1EDu, 1)
                            && ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                              ? (int v45 = (const std::__fs::filesystem::path *)&v55)
                              : (int v45 = (const std::__fs::filesystem::path *)v55.__r_.__value_.__r.__words[0]),
                                v57 >= 0
                              ? (long long v46 = (const std::__fs::filesystem::path *)__p)
                              : (long long v46 = (const std::__fs::filesystem::path *)__p[0]),
                                rename(v45, v46, v44),
                                !v47)
                            || (size_t v48 = *(NSObject **)(v4 + 40), !os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)))
                          {
                            if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                              goto LABEL_77;
                            }
LABEL_94:
                            operator delete(v53.__r_.__value_.__l.__data_);
                            uint64_t v49 = *(const void **)(v4 + 176);
                            *(void *)(v4 + 176) = 0;
                            if (!v49)
                            {
LABEL_79:
                              if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
                              {
                                operator delete(v55.__r_.__value_.__l.__data_);
                                if ((SHIBYTE(v57) & 0x80000000) == 0)
                                {
LABEL_81:
                                  if ((SHIBYTE(v58[2]) & 0x80000000) == 0) {
                                    goto LABEL_82;
                                  }
                                  goto LABEL_87;
                                }
                              }
                              else if ((SHIBYTE(v57) & 0x80000000) == 0)
                              {
                                goto LABEL_81;
                              }
                              operator delete(__p[0]);
                              if ((SHIBYTE(v58[2]) & 0x80000000) == 0)
                              {
LABEL_82:
                                if ((SHIBYTE(v59[2]) & 0x80000000) == 0) {
                                  return MEMORY[0x1A6274930](v60);
                                }
LABEL_88:
                                operator delete(v59[0]);
                                return MEMORY[0x1A6274930](v60);
                              }
LABEL_87:
                              operator delete(v58[0]);
                              if ((SHIBYTE(v59[2]) & 0x80000000) == 0) {
                                return MEMORY[0x1A6274930](v60);
                              }
                              goto LABEL_88;
                            }
LABEL_78:
                            CFRelease(v49);
                            goto LABEL_79;
                          }
                          unsigned int v50 = &v55;
                          if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                            unsigned int v50 = (std::string *)v55.__r_.__value_.__r.__words[0];
                          }
                          size_t v51 = __p;
                          if (v57 < 0) {
                            size_t v51 = (void **)__p[0];
                          }
                          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
                          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v51;
                          _os_log_error_impl(&dword_1A609F000, v48, OS_LOG_TYPE_ERROR, "Failed to move %s to %s", (uint8_t *)&buf, 0x16u);
                          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
                            goto LABEL_94;
                          }
                        }
LABEL_77:
                        uint64_t v49 = *(const void **)(v4 + 176);
                        *(void *)(v4 + 176) = 0;
                        if (!v49) {
                          goto LABEL_79;
                        }
                        goto LABEL_78;
                      }
                    }
                    memmove(v38, v35, v37);
                    goto LABEL_58;
                  }
                }
                else if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_49;
                }
                operator delete(v55.__r_.__value_.__l.__data_);
                if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_50;
                }
                goto LABEL_65;
              }
            }
            memmove(p_dst, v19, v21);
            goto LABEL_35;
          }
        }
        memmove(v16, v13, v15);
        goto LABEL_25;
      }
    }
    memmove(p_buf, v6, v8);
    goto LABEL_15;
  }
  return result;
}

void sub_1A615BD0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (*(char *)(v44 - 129) < 0) {
    operator delete(*(void **)(v44 - 152));
  }
  MEMORY[0x1A6274930](v44 - 128);
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c27_ZTSNSt3__110shared_ptrIvEE72c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    long long v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = a2[6];
  a1[6] = v6;
  if (v6)
  {
    dispatch_retain(v6);
    size_t v7 = a1[6];
    if (v7) {
      dispatch_group_enter(v7);
    }
  }
  uint64_t v8 = a2[8];
  a1[7] = a2[7];
  a1[8] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  CFTypeRef result = (CFTypeRef)a2[9];
  a1[9] = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c30_ZTSN8dispatch13group_sessionE56c27_ZTSNSt3__110shared_ptrIvEE72c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE(void *a1)
{
  uint64_t v2 = (const void *)a1[9];
  if (v2) {
    CFRelease(v2);
  }
  group v3 = (std::__shared_weak_count *)a1[8];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = a1[6];
  if (v4)
  {
    dispatch_group_leave(v4);
    long long v5 = a1[6];
    if (v5) {
      dispatch_release(v5);
    }
  }
  uint64_t v6 = a1[5];
  if (v6)
  {
    dispatch_group_leave(v6);
    size_t v7 = a1[5];
    if (v7)
    {
      dispatch_release(v7);
    }
  }
}

void __copy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE56c30_ZTSN8dispatch13group_sessionE(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    long long v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = (const void *)a2[6];
  a1[6] = v6;
  if (v6) {
    CFRetain(v6);
  }
  size_t v7 = a2[7];
  a1[7] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    uint64_t v8 = a1[7];
    if (v8)
    {
      dispatch_group_enter(v8);
    }
  }
}

void __destroy_helper_block_e8_40c30_ZTSN8dispatch13group_sessionE48c45_ZTSN3ctu2cf11CFSharedRefIK14__CFDictionaryEE56c30_ZTSN8dispatch13group_sessionE(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2)
  {
    dispatch_group_leave(v2);
    group v3 = a1[7];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  long long v5 = a1[5];
  if (v5)
  {
    dispatch_group_leave(v5);
    uint64_t v6 = a1[5];
    if (v6)
    {
      dispatch_release(v6);
    }
  }
}

void BasebandIPCTrace::dumpState(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 152);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Enabled %d", (uint8_t *)v4, 8u);
  }
}

BOOL BasebandIPCTrace::setProperty(uint64_t a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  size_t v7 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v7);
  }
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 0;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 1174405120;
  uint64_t v12[2] = ___ZN16BasebandIPCTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke;
  v12[3] = &unk_1EFB0C7C0;
  v12[5] = a1;
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(group);
  }
  v12[4] = &v16;
  uint64_t v14 = a3;
  uint64_t v15 = a4;
  size_t v20 = v12;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_3;
  block[3] = &__block_descriptor_tmp_65_1;
  void block[4] = a1 + 72;
  void block[5] = &v20;
  uint64_t v8 = *(NSObject **)(a1 + 88);
  if (*(void *)(a1 + 96))
  {
    dispatch_async_and_wait(v8, block);
    int v9 = *((unsigned __int8 *)v17 + 24);
    uint64_t v10 = group;
    if (!group) {
      goto LABEL_11;
    }
  }
  else
  {
    dispatch_sync(v8, block);
    int v9 = *((unsigned __int8 *)v17 + 24);
    uint64_t v10 = group;
    if (!group) {
      goto LABEL_11;
    }
  }
  dispatch_group_leave(v10);
  if (group) {
    dispatch_release(group);
  }
LABEL_11:
  _Block_object_dispose(&v16, 8);
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  return v9 != 0;
}

void ___ZN16BasebandIPCTrace11setPropertyEN8dispatch5groupERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEESA__block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = prop::bbipc::set(*(char **)(a1 + 56), *(char **)(a1 + 64));
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    if (*(char *)(v3 + 23) < 0)
    {
      uint64_t v4 = (capabilities::radio *)strcasecmp(*(const char **)v3, "Enabled");
      if (v4) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v4 = (capabilities::radio *)strcasecmp((const char *)v3, "Enabled");
      if (v4)
      {
LABEL_4:
        if (capabilities::radio::mav20Plus(v4))
        {
          uint64_t v5 = *(void *)(v2 + 160);
          if (v5)
          {
            uint64_t v6 = *(long long **)(a1 + 56);
            if (*((char *)v6 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)v6, *((void *)v6 + 1));
            }
            else
            {
              long long v7 = *v6;
              v20.__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
              *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v7;
            }
            uint64_t v13 = *(long long **)(a1 + 64);
            if (*((char *)v13 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v19, *(const std::string::value_type **)v13, *((void *)v13 + 1));
            }
            else
            {
              long long v14 = *v13;
              v19.__r_.__value_.__r.__words[2] = *((void *)v13 + 2);
              *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v14;
            }
            (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v5 + 72))(v5, &v20, &v19);
            if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v19.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v20.__r_.__value_.__l.__data_);
            }
          }
        }
        return;
      }
    }
    char v22 = -86;
    memset(&v23, 0, sizeof(v23));
    char v25 = 11;
    strcpy((char *)__p, "BasebandIPC");
    memset(&buf, 0, sizeof(buf));
    BOOL v9 = defaults::get((char *)__p, (char *)v3, &buf);
    if (v9)
    {
      prop::file::get<std::string>((const void **)__p, v3, (uint64_t)&buf, &v26);
      std::string v23 = v26;
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(buf.__r_.__value_.__l.__data_);
      if ((v25 & 0x80000000) == 0)
      {
LABEL_15:
        if (v9) {
          goto LABEL_16;
        }
        goto LABEL_20;
      }
    }
    else if ((v25 & 0x80000000) == 0)
    {
      goto LABEL_15;
    }
    operator delete(__p[0]);
    if (v9)
    {
LABEL_16:
      char v10 = util::convert<BOOL>(&v23, (BOOL *)&v22, 0);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_21;
      }
      goto LABEL_22;
    }
LABEL_20:
    char v10 = 0;
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
LABEL_21:
    }
      operator delete(v23.__r_.__value_.__l.__data_);
LABEL_22:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      int v11 = v22;
      if (v22 != *(unsigned char *)(v2 + 152))
      {
        *(unsigned char *)(v2 + 152) = v22;
        if (v11)
        {
          dispatch_time_t v12 = dispatch_group_create();
          std::string::size_type v21 = v12;
          BasebandIPCTrace::start_sync((BasebandIPCTrace *)v2, (group *)&v21);
          if (v12) {
            dispatch_release(v12);
          }
        }
        else
        {
          uint64_t v15 = *(std::__shared_weak_count **)(v2 + 168);
          *(void *)(v2 + 160) = 0;
          *(void *)(v2 + 168) = 0;
          if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
          uint64_t v16 = *(const void **)(v2 + 176);
          *(void *)(v2 + 176) = 0;
          if (v16) {
            CFRelease(v16);
          }
        }
      }
    }
    return;
  }
  uint64_t v8 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    std::string::size_type v17 = *(void *)(a1 + 56);
    if (*(char *)(v17 + 23) < 0) {
      std::string::size_type v17 = *(void *)v17;
    }
    std::string::size_type v18 = *(void *)(a1 + 64);
    if (*(char *)(v18 + 23) < 0) {
      std::string::size_type v18 = *(void *)v18;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v17;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v18;
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Set property to file failed; key=%s value=%s",
      (uint8_t *)&buf,
      0x16u);
  }
}

void sub_1A615C6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandIPCTrace::getProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  BOOL v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  void v7[2] = ___ZN16BasebandIPCTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke;
  v7[3] = &unk_1E5C47B18;
  v7[4] = &v8;
  void v7[5] = a2;
  v7[6] = a3;
  dispatch_time_t v12 = v7;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_3;
  block[3] = &__block_descriptor_tmp_65_1;
  void block[4] = a1 + 72;
  void block[5] = &v12;
  uint64_t v4 = a1 + 88;
  uint64_t v3 = *(NSObject **)(a1 + 88);
  if (*(void *)(v4 + 8)) {
    dispatch_async_and_wait(v3, block);
  }
  else {
    dispatch_sync(v3, block);
  }
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void ___ZN16BasebandIPCTrace11getPropertyERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERS6__block_invoke(void *a1)
{
  uint64_t v2 = (char *)a1[5];
  uint64_t v3 = a1[6];
  char v6 = 11;
  strcpy((char *)__p, "BasebandIPC");
  BOOL v4 = prop::get_from_file((char *)__p, v2, v3);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v4;
}

void sub_1A615C8C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN16BasebandIPCTrace12collect_syncEN8dispatch5groupEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1, uint64_t *a2, CFTypeRef *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *a2;
  if (*a2) {
    uint64_t v5 = ctu::SharedRef<__CFError,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFError>::get;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    char v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v10 = 138412290;
      uint64_t v11 = v4;
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Query failed: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    long long v7 = (const void **)(v3 + 176);
    if ((CFTypeRef *)(v3 + 176) != a3)
    {
      CFTypeRef v8 = *a3;
      if (*a3) {
        CFRetain(*a3);
      }
      BOOL v9 = *v7;
      *long long v7 = v8;
      if (v9) {
        CFRelease(v9);
      }
    }
  }
}

void sub_1A615C9D4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t dispatch::callback<void({block_pointer})(ctu::cf::CFSharedRef<__CFError>,ctu::cf::CFSharedRef<__CFDictionary const>)>::~callback(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

void ___ZN16BasebandIPCTrace10write_syncEN3ctu2cf11CFSharedRefIK14__CFDictionaryEE_block_invoke(uint64_t a1, uint64_t a2, CFDataRef *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v3 = *(char *)(a1 + 55);
  if (v3 >= 0) {
    size_t v4 = *(unsigned __int8 *)(a1 + 55);
  }
  else {
    size_t v4 = *(void *)(a1 + 40);
  }
  unint64_t v5 = v4 + 1;
  memset(__dst, 170, 24);
  if (v4 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v5 >= 0x17)
  {
    uint64_t v10 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v10 = v5 | 7;
    }
    uint64_t v11 = v10 + 1;
    BOOL v9 = operator new(v10 + 1);
    *(void *)&__dst[8] = v4 + 1;
    *(void *)&uint8_t __dst[16] = v11 | 0x8000000000000000;
    *(void *)std::string __dst = v9;
  }
  else
  {
    memset(__dst, 0, 24);
    BOOL v9 = __dst;
    __dst[23] = v4 + 1;
    if (!v4) {
      goto LABEL_15;
    }
  }
  if (v3 >= 0) {
    uint64_t v12 = (const void *)(a1 + 32);
  }
  else {
    uint64_t v12 = *(const void **)(a1 + 32);
  }
  memmove(v9, v12, v4);
LABEL_15:
  *(_WORD *)&v9[v4] = 47;
  int v13 = *(char *)(a2 + 23);
  if (v13 >= 0) {
    long long v14 = (const std::string::value_type *)a2;
  }
  else {
    long long v14 = *(const std::string::value_type **)a2;
  }
  if (v13 >= 0) {
    std::string::size_type v15 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v15 = *(void *)(a2 + 8);
  }
  uint64_t v16 = std::string::append((std::string *)__dst, v14, v15);
  std::string __p = *v16;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if ((__dst[23] & 0x80000000) != 0) {
    operator delete(*(void **)__dst);
  }
  memset(&__dst[8], 170, 0x230uLL);
  uint64_t v17 = MEMORY[0x1E4FBA468] + 64;
  *(void *)&__dst[416] = MEMORY[0x1E4FBA468] + 64;
  std::string::size_type v18 = (void *)MEMORY[0x1E4FBA400];
  uint64_t v19 = *(void *)(MEMORY[0x1E4FBA400] + 16);
  *(void *)std::string __dst = *(void *)(MEMORY[0x1E4FBA400] + 8);
  *(void *)&__dst[*(void *)(*(void *)__dst - 24)] = v19;
  std::string v20 = (std::ios_base *)&__dst[*(void *)(*(void *)__dst - 24)];
  std::ios_base::init(v20, &__dst[8]);
  uint64_t v21 = MEMORY[0x1E4FBA468] + 24;
  v20[1].__vftable = 0;
  v20[1].__fmtflags_ = -1;
  *(void *)std::string __dst = v21;
  *(void *)&__dst[416] = v17;
  MEMORY[0x1A6274EA0](&__dst[8]);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)&__dst[*(void *)(*(void *)__dst - 24)], *(_DWORD *)&__dst[*(void *)(*(void *)__dst - 24) + 32] | 4);
  }
  if (!*(_DWORD *)&__dst[*(void *)(*(void *)__dst - 24) + 32] && *a3)
  {
    CFDataGetBytePtr(*a3);
    CFDataGetLength(*a3);
    std::ostream::write();
  }
  *(void *)std::string __dst = *v18;
  *(void *)&__dst[*(void *)(*(void *)__dst - 24)] = v18[3];
  MEMORY[0x1A6274EB0](&__dst[8]);
  std::ostream::~ostream();
  MEMORY[0x1A62751A0](&__dst[416]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1A615CE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::ofstream::~ofstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA400];
  uint64_t v3 = *MEMORY[0x1E4FBA400];
  *a1 = *MEMORY[0x1E4FBA400];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x1A6274EB0](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1A62751A0](a1 + 52);
  return a1;
}

void __copy_helper_block_e8_32c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(void *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_32c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void BasebandIPCTrace::getSettingPrefix(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "BasebandIPC::");
}

const char *BasebandIPCTrace::getName(BasebandIPCTrace *this)
{
  return "trace.bbipc";
}

void *std::shared_ptr<BasebandIPCTrace>::shared_ptr[abi:ne180100]<BasebandIPCTrace,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  size_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0C878;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2) {
    return a1;
  }
  char v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 72) = a2;
      *(void *)(a2 + 80) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(a2 + 72) = a2;
  *(void *)(a2 + 80) = v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A615D0D8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1}::operator() const(BasebandIPCTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A615D100(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<BasebandIPCTrace *,std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace *)#1},std::allocator<BasebandIPCTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110share"
                                "d_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16BasebandIPCTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<BasebandIPCTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<BasebandIPCTrace>(BasebandIPCTrace*)::{lambda(BasebandIPCTrace*)#1}::operator() const(BasebandIPCTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_3(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void ___ZN3ctu2cf8for_eachINSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEPK8__CFDataEEvPK14__CFDictionaryU13block_pointerFvRKT_RKT0_E_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v9 = 0uLL;
  uint64_t v10 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v8 = 0;
  if (a3)
  {
    CFTypeID v5 = CFGetTypeID(a3);
    if (v5 == CFDataGetTypeID()) {
      char v6 = a3;
    }
    else {
      char v6 = 0;
    }
  }
  else
  {
    char v6 = 0;
  }
  *(void *)&long long v9 = v6;
  (*(void (**)(uint64_t, void **, long long *))(v4 + 16))(v4, __p, &v9);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A615D2C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ctu::cf::DictApplyFunction(ctu::cf *this, const void *a2, const void *a3, void *a4)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

uint64_t __cxx_global_var_init_21()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<CommandDriverFactory>::~PthreadMutexGuardPolicy, &ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t __cxx_global_var_init_22()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A609F000);
  }
  return result;
}

void abm::CellularLoggingTask::~CellularLoggingTask(abm::CellularLoggingTask *this)
{
  *(void *)this = &unk_1EFB0C8C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 22);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 22);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = *((void *)this + 20);
  if (v4)
  {
    dispatch_group_leave(v4);
    CFTypeID v5 = *((void *)this + 20);
    if (v5) {
      dispatch_release(v5);
    }
  }
  if ((*((char *)this + 159) & 0x80000000) == 0)
  {
    *(void *)this = &unk_1EFB0FCB8;
    char v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  operator delete(*((void **)this + 17));
  *(void *)this = &unk_1EFB0FCB8;
  char v6 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v6) {
LABEL_12:
  }
    std::__shared_weak_count::__release_weak(v6);
LABEL_13:
  long long v7 = *((void *)this + 14);
  if (v7) {
    dispatch_release(v7);
  }
  *(void *)this = &unk_1EFB09350;
  MEMORY[0x1A6274710]((char *)this + 8);
  uint64_t v8 = *((void *)this + 12);
  if (v8) {
    dispatch_release(v8);
  }
  long long v9 = *((void *)this + 11);
  if (v9) {
    dispatch_release(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
}

{
  void *v1;
  uint64_t vars8;

  abm::CellularLoggingTask::~CellularLoggingTask(this);

  operator delete(v1);
}

uint64_t abm::CellularLoggingTask::getName(abm::CellularLoggingTask *this)
{
  return (uint64_t)this + 136;
}

uint64_t abm::CellularLoggingTask::CellularLoggingTask(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = (std::__shared_weak_count *)a3[1];
  uint64_t v36 = *a3;
  std::string::size_type v37 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v9 = (std::__shared_weak_count *)a4[1];
  uint64_t v34 = *a4;
  uint64_t v35 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  abm::HelperTask::HelperTask(a1, a2, &v36, &v34);
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v10 = v37;
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    *(void *)a1 = &unk_1EFB0C8C8;
    unsigned int v11 = *(_DWORD *)(a1 + 104) - 1;
    if (v11 <= 9) {
      goto LABEL_10;
    }
  }
  else
  {
    *(void *)a1 = &unk_1EFB0C8C8;
    unsigned int v11 = *(_DWORD *)(a1 + 104) - 1;
    if (v11 <= 9)
    {
LABEL_10:
      uint64_t v12 = off_1E5C47B80[v11];
      goto LABEL_13;
    }
  }
  uint64_t v12 = "invalid";
LABEL_13:
  size_t v13 = strlen(v12);
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v14 = v13;
  if (v13 >= 0x17)
  {
    uint64_t v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v16 = v13 | 7;
    }
    uint64_t v17 = v16 + 1;
    std::string::size_type v15 = operator new(v16 + 1);
    *(void *)(a1 + 144) = v14;
    *(void *)(a1 + 152) = v17 | 0x8000000000000000;
    *(void *)(a1 + 136) = v15;
    goto LABEL_20;
  }
  *(unsigned char *)(a1 + 159) = v13;
  std::string::size_type v15 = (void *)(a1 + 136);
  if (v13) {
LABEL_20:
  }
    memmove(v15, v12, v14);
  *((unsigned char *)v15 + v14) = 0;
  *(void *)(a1 + 160) = 0;
  abm::helper::getLoggingDomain(a2, __p);
  if ((a2 - 1) > 9) {
    std::string::size_type v18 = "invalid";
  }
  else {
    std::string::size_type v18 = off_1E5C47B80[a2 - 1];
  }
  if (v32 >= 0) {
    uint64_t v19 = __p;
  }
  else {
    uint64_t v19 = (void **)__p[0];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v33, (const char *)v19, v18);
  *(void *)(a1 + 168) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)(a1 + 176) = 0xAAAAAAAAAAAAAAAALL;
  std::string v20 = operator new(0x28uLL);
  std::__shared_ptr_emplace<abm::AppMonitor>::__shared_ptr_emplace[abi:ne180100]<ctu::OsLogContext &,std::allocator<abm::AppMonitor>,0>(v20, (const ctu::OsLogContext *)v33);
  *(void *)(a1 + 168) = v20 + 3;
  *(void *)(a1 + 176) = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v33);
  if (v32 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v21 = (std::__shared_weak_count *)a3[1];
  uint64_t v29 = *a3;
  std::string::size_type v30 = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v22 = (std::__shared_weak_count *)a4[1];
  uint64_t v27 = *a4;
  uint64_t v28 = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::string v23 = *(NSObject **)(a1 + 88);
  dispatch_object_t object = v23;
  if (v23) {
    dispatch_retain(v23);
  }
  abm::CellularLoggingCommon::create(&v29, &v27, &object, (void *)(a1 + 184));
  if (object) {
    dispatch_release(object);
  }
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  uint64_t v24 = v30;
  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  return a1;
}

void sub_1A615D89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, std::__shared_weak_count *a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  if (a11) {
    std::__shared_weak_count::__release_weak(a11);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v26);
  uint64_t v28 = *(NSObject **)(v24 + 160);
  if (v28)
  {
    dispatch_group_leave(v28);
    uint64_t v29 = *(NSObject **)(v24 + 160);
    if (v29) {
      dispatch_release(v29);
    }
  }
  if (*(char *)(v24 + 159) < 0)
  {
    operator delete(*v25);
    abm::HelperTask::~HelperTask((abm::HelperTask *)v24);
    _Unwind_Resume(a1);
  }
  abm::HelperTask::~HelperTask((abm::HelperTask *)v24);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingTask::init_sync(abm::CellularLoggingTask *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (v3 = *((void *)this + 9), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  CFTypeID v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    char v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v6) {
      goto LABEL_75;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
    char v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v6) {
      goto LABEL_75;
    }
  }
  long long v7 = std::__shared_weak_count::lock(v6);
  dispatch_group_t v75 = v7;
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *((void *)this + 15);
    uint64_t v74 = v9;
    if (v9)
    {
      uint64_t v10 = (char *)operator new(0x20uLL);
      uint64_t v72 = v10;
      long long v73 = xmmword_1A61F7580;
      strcpy(v10, "kCommandCellularLoggingStart");
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke;
      aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      aBlock[4] = this;
      void aBlock[5] = v3;
      long long v70 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      unsigned int v11 = _Block_copy(aBlock);
      uint64_t v12 = *((void *)this + 11);
      if (v12) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v71[0] = v11;
      v71[1] = v12;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v72, (uint64_t)v71);
      if (v12) {
        dispatch_release(v12);
      }
      if (v11) {
        _Block_release(v11);
      }
      operator delete(v10);
      size_t v13 = (char *)operator new(0x20uLL);
      int v67 = v13;
      long long v68 = xmmword_1A61F7570;
      strcpy(v13, "kCommandCellularLoggingStop");
      v64[0] = MEMORY[0x1E4F143A8];
      v64[1] = 3321888768;
      void v64[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_5;
      v64[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v64[4] = this;
      v64[5] = v3;
      char v65 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      size_t v14 = _Block_copy(v64);
      std::string::size_type v15 = *((void *)this + 11);
      if (v15) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v66[0] = v14;
      v66[1] = v15;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v67, (uint64_t)v66);
      if (v15) {
        dispatch_release(v15);
      }
      if (v14) {
        _Block_release(v14);
      }
      operator delete(v13);
      uint64_t v16 = (char *)operator new(0x28uLL);
      uint64_t v62 = v16;
      long long v63 = xmmword_1A61F9A00;
      strcpy(v16, "kCommandCellularLoggingGetCurrentIndex");
      v59[0] = MEMORY[0x1E4F143A8];
      v59[1] = 3321888768;
      v59[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_6;
      v59[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v59[4] = this;
      v59[5] = v3;
      char v60 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v17 = _Block_copy(v59);
      std::string::size_type v18 = *((void *)this + 11);
      if (v18) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v61[0] = v17;
      v61[1] = v18;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v62, (uint64_t)v61);
      if (v18) {
        dispatch_release(v18);
      }
      if (v17) {
        _Block_release(v17);
      }
      operator delete(v16);
      uint64_t v19 = (char *)operator new(0x28uLL);
      int64_t v57 = v19;
      long long v58 = xmmword_1A61F8010;
      strcpy(v19, "kCommandCellularLoggingGetConfigLists");
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 3321888768;
      v54[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_7;
      v54[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v54[4] = this;
      v54[5] = v3;
      std::string v55 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::string v20 = _Block_copy(v54);
      uint64_t v21 = *((void *)this + 11);
      if (v21) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v56[0] = v20;
      v56[1] = v21;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v57, (uint64_t)v56);
      if (v21) {
        dispatch_release(v21);
      }
      if (v20) {
        _Block_release(v20);
      }
      operator delete(v19);
      char v22 = (char *)operator new(0x20uLL);
      size_t v52 = v22;
      long long v53 = xmmword_1A61F7580;
      strcpy(v22, "kCommandCellularLoggingPause");
      v49[0] = MEMORY[0x1E4F143A8];
      v49[1] = 3321888768;
      v49[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_8;
      v49[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v49[4] = this;
      void v49[5] = v3;
      unsigned int v50 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::string v23 = _Block_copy(v49);
      uint64_t v24 = *((void *)this + 11);
      if (v24) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v51[0] = v23;
      v51[1] = v24;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v52, (uint64_t)v51);
      if (v24) {
        dispatch_release(v24);
      }
      if (v23) {
        _Block_release(v23);
      }
      operator delete(v22);
      char v25 = (char *)operator new(0x20uLL);
      int v47 = v25;
      long long v48 = xmmword_1A61F9520;
      strcpy(v25, "kCommandCellularLoggingResume");
      v44[0] = MEMORY[0x1E4F143A8];
      v44[1] = 3321888768;
      v44[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_9;
      v44[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v44[4] = this;
      v44[5] = v3;
      int v45 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v26 = _Block_copy(v44);
      uint64_t v27 = *((void *)this + 11);
      if (v27) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v46[0] = v26;
      v46[1] = v27;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v47, (uint64_t)v46);
      if (v27) {
        dispatch_release(v27);
      }
      if (v26) {
        _Block_release(v26);
      }
      operator delete(v25);
      uint64_t v28 = (char *)operator new(0x28uLL);
      long long v42 = v28;
      long long v43 = xmmword_1A61F8010;
      strcpy(v28, "kCommandCellularLoggingSetAppBundleID");
      v39[0] = MEMORY[0x1E4F143A8];
      v39[1] = 3321888768;
      v39[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_10;
      v39[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v39[4] = this;
      v39[5] = v3;
      uint64_t v40 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v29 = _Block_copy(v39);
      std::string::size_type v30 = *((void *)this + 11);
      if (v30) {
        dispatch_retain(*((dispatch_object_t *)this + 11));
      }
      v41[0] = v29;
      v41[1] = v30;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v42, (uint64_t)v41);
      if (v30) {
        dispatch_release(v30);
      }
      if (v29) {
        _Block_release(v29);
      }
      operator delete(v28);
      long long v31 = (char *)operator new(0x20uLL);
      std::string::size_type v37 = v31;
      long long v38 = xmmword_1A61F8040;
      strcpy(v31, "kCommandCellularLoggingSnapshot");
      v34[0] = MEMORY[0x1E4F143A8];
      v34[1] = 3321888768;
      void v34[2] = ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_12;
      v34[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
      v34[4] = this;
      v34[5] = v3;
      uint64_t v35 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      char v32 = _Block_copy(v34);
      size_t v33 = *((void *)this + 11);
      if (v33) {
        dispatch_retain(v33);
      }
      v36[0] = v32;
      v36[1] = v33;
      abm::HelperServerInternal::setCommandHandler(v9, (uint64_t)&v37, (uint64_t)v36);
      if (v33) {
        dispatch_release(v33);
      }
      if (v32) {
        _Block_release(v32);
      }
      operator delete(v31);
      if (v35) {
        std::__shared_weak_count::__release_weak(v35);
      }
      if (v40) {
        std::__shared_weak_count::__release_weak(v40);
      }
      if (v45) {
        std::__shared_weak_count::__release_weak(v45);
      }
      if (v50) {
        std::__shared_weak_count::__release_weak(v50);
      }
      if (v55) {
        std::__shared_weak_count::__release_weak(v55);
      }
      if (v60) {
        std::__shared_weak_count::__release_weak(v60);
      }
      if (v65) {
        std::__shared_weak_count::__release_weak(v65);
      }
      if (v70) {
        std::__shared_weak_count::__release_weak(v70);
      }
    }
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
LABEL_75:
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A615E1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,std::__shared_weak_count *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a21);
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  operator delete(v69);
  if (a32)
  {
    std::__shared_weak_count::__release_weak(a32);
    uint64_t v72 = a44;
    if (!a44)
    {
LABEL_5:
      long long v73 = a56;
      if (!a56) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v72 = a44;
    if (!a44) {
      goto LABEL_5;
    }
  }
  std::__shared_weak_count::__release_weak(v72);
  long long v73 = a56;
  if (!a56)
  {
LABEL_6:
    uint64_t v74 = a68;
    if (!a68) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  std::__shared_weak_count::__release_weak(v73);
  uint64_t v74 = a68;
  if (!a68)
  {
LABEL_7:
    dispatch_group_t v75 = (std::__shared_weak_count *)STACK[0x238];
    if (!STACK[0x238]) {
      goto LABEL_8;
    }
    goto LABEL_15;
  }
LABEL_14:
  std::__shared_weak_count::__release_weak(v74);
  dispatch_group_t v75 = (std::__shared_weak_count *)STACK[0x238];
  if (!STACK[0x238])
  {
LABEL_8:
    std::string v76 = (std::__shared_weak_count *)STACK[0x298];
    if (!STACK[0x298]) {
      goto LABEL_9;
    }
    goto LABEL_16;
  }
LABEL_15:
  std::__shared_weak_count::__release_weak(v75);
  std::string v76 = (std::__shared_weak_count *)STACK[0x298];
  if (!STACK[0x298])
  {
LABEL_9:
    uint64_t v77 = *(std::__shared_weak_count **)(v70 - 168);
    if (!v77) {
      goto LABEL_10;
    }
    goto LABEL_17;
  }
LABEL_16:
  std::__shared_weak_count::__release_weak(v76);
  uint64_t v77 = *(std::__shared_weak_count **)(v70 - 168);
  if (!v77)
  {
LABEL_10:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v70 - 120);
    std::__shared_weak_count::__release_weak(v68);
    _Unwind_Resume(a1);
  }
LABEL_17:
  std::__shared_weak_count::__release_weak(v77);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v70 - 120);
  std::__shared_weak_count::__release_weak(v68);
  _Unwind_Resume(a1);
}

void sub_1A615E3B4()
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&STACK[0x240]);
  if (STACK[0x238]) {
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)STACK[0x238]);
  }
  operator delete(v0);
  if (STACK[0x298]) {
    JUMPOUT(0x1A615E38CLL);
  }
  JUMPOUT(0x1A615E230);
}

void sub_1A615E3E4()
{
  if (STACK[0x298]) {
    JUMPOUT(0x1A615E38CLL);
  }
  JUMPOUT(0x1A615E230);
}

void sub_1A615E3F4()
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback(v1 - 256);
  if (STACK[0x298]) {
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)STACK[0x298]);
  }
  operator delete(v0);
  if (*(void *)(v1 - 168)) {
    JUMPOUT(0x1A615E398);
  }
  JUMPOUT(0x1A615E238);
}

void sub_1A615E424()
{
  if (*(void *)(v0 - 168)) {
    JUMPOUT(0x1A615E398);
  }
  JUMPOUT(0x1A615E238);
}

void sub_1A615E434(_Unwind_Exception *a1)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback(v3 - 160);
  CFTypeID v5 = *(std::__shared_weak_count **)(v3 - 168);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  operator delete(v2);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v3 - 120);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_1A615E470(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 120);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke(void *a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v5 = a1[4];
  uint64_t v80 = 0;
  char v81 = 0;
  char v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    char v81 = std::__shared_weak_count::lock(v6);
    if (!v81) {
      return;
    }
    uint64_t v80 = a1[5];
    if (v80)
    {
      uint64_t v9 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging Start", buf, 2u);
      }
      uint64_t v10 = *(void *)(v5 + 184);
      if (v10)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 176))(v10))
        {
          unsigned int v11 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has been already started!", buf, 2u);
          }
          xpc_object_t v12 = xpc_null_create();
          if (*(void *)a4) {
            size_t v13 = _Block_copy(*(const void **)a4);
          }
          else {
            size_t v13 = 0;
          }
          std::string v23 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          *(void *)&long long v83 = 3321888768;
          *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v13)
          {
            uint64_t v24 = _Block_copy(v13);
            int v87 = 0;
            aBlocuint64_t k = v24;
            xpc_object_t object = v12;
            if (v12)
            {
LABEL_43:
              xpc_retain(v12);
LABEL_46:
              dispatch_async(v23, buf);
              xpc_release(object);
              xpc_object_t object = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v13) {
                _Block_release(v13);
              }
LABEL_105:
              xpc_release(v12);
              goto LABEL_167;
            }
          }
          else
          {
            int v87 = 0;
            aBlocuint64_t k = 0;
            xpc_object_t object = v12;
            if (v12) {
              goto LABEL_43;
            }
          }
          xpc_object_t object = xpc_null_create();
          goto LABEL_46;
        }
        TelephonyXPC::ServerClientState::ServerClientState();
        *(void *)std::string buf = operator new(0x28uLL);
        long long v83 = xmmword_1A61F8A10;
        strcpy(*(char **)buf, "com.apple.cellular-logging.internal");
        int isClientEntitled = TelephonyXPC::ServerClientState::isClientEntitled();
        if (SHIBYTE(v83) < 0) {
          operator delete(*(void **)buf);
        }
        if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
          std::__shared_weak_count::__release_weak(v79);
        }
        *(unsigned char *)(*(void *)(v5 + 184) + 128) = isClientEntitled;
        if ((abm::CellularLoggingTask::isCarrierBundleKeyExist((abm::CellularLoggingTask *)v5) & 1) == 0)
        {
          uint64_t v17 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle Key doesn't exist, checking for internal entitlement", buf, 2u);
          }
          if ((isClientEntitled & 1) == 0)
          {
            char v25 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl(&dword_1A609F000, v25, OS_LOG_TYPE_ERROR, "Couldn't find internal app entitlement, cannot start cellular logging", buf, 2u);
            }
            xpc_object_t v12 = xpc_null_create();
            if (*(void *)a4) {
              uint64_t v26 = _Block_copy(*(const void **)a4);
            }
            else {
              uint64_t v26 = 0;
            }
            std::string::size_type v37 = *(NSObject **)(a4 + 8);
            *(void *)std::string buf = MEMORY[0x1E4F143A8];
            *(void *)&long long v83 = 3321888768;
            *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v26) {
              long long v38 = _Block_copy(v26);
            }
            else {
              long long v38 = 0;
            }
            int v87 = -534716416;
            aBlocuint64_t k = v38;
            xpc_object_t object = v12;
            if (v12) {
              xpc_retain(v12);
            }
            else {
              xpc_object_t object = xpc_null_create();
            }
            dispatch_async(v37, buf);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v26) {
              _Block_release(v26);
            }
            goto LABEL_105;
          }
        }
        if ((TelephonyUtilIsInternalBuild() & isClientEntitled & 1) == 0
          && !abm::CellularLoggingTask::isUserAgreeLegalInfo((abm::CellularLoggingTask *)v5))
        {
          size_t v33 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v33, OS_LOG_TYPE_ERROR, "The User disagree to proceed!", buf, 2u);
          }
          xpc_object_t v12 = xpc_null_create();
          if (*(void *)a4) {
            uint64_t v34 = _Block_copy(*(const void **)a4);
          }
          else {
            uint64_t v34 = 0;
          }
          uint64_t v39 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          *(void *)&long long v83 = 3321888768;
          *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v34) {
            uint64_t v40 = _Block_copy(v34);
          }
          else {
            uint64_t v40 = 0;
          }
          int v87 = -534716414;
          aBlocuint64_t k = v40;
          xpc_object_t object = v12;
          if (v12) {
            xpc_retain(v12);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          dispatch_async(v39, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v34) {
            _Block_release(v34);
          }
          goto LABEL_105;
        }
        std::string::size_type v18 = (char *)sandbox_extension_issue_file();
        uint64_t v19 = *(void *)(v5 + 184);
        std::string v20 = *a3;
        xpc_object_t v78 = v20;
        if (v20) {
          xpc_retain(v20);
        }
        else {
          xpc_object_t v78 = xpc_null_create();
        }
        char v27 = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(void *)v19 + 48))(v19, &v78);
        xpc_release(v78);
        xpc_object_t v78 = 0;
        if ((v27 & 1) == 0)
        {
          std::string::size_type v30 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v30, OS_LOG_TYPE_ERROR, "Failed to start CellularLoggingCommon object!", buf, 2u);
          }
          (*(void (**)(void))(**(void **)(v5 + 184) + 56))(*(void *)(v5 + 184));
          xpc_object_t v31 = xpc_null_create();
          if (*(void *)a4) {
            char v32 = _Block_copy(*(const void **)a4);
          }
          else {
            char v32 = 0;
          }
          uint64_t v35 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          *(void *)&long long v83 = 3321888768;
          *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v32) {
            uint64_t v36 = _Block_copy(v32);
          }
          else {
            uint64_t v36 = 0;
          }
          int v87 = -534716416;
          aBlocuint64_t k = v36;
          xpc_object_t object = v31;
          if (v31) {
            xpc_retain(v31);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          dispatch_async(v35, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v32) {
            _Block_release(v32);
          }
          xpc_release(v31);
          goto LABEL_167;
        }
        xpc_object_t v28 = xpc_dictionary_create(0, 0, 0);
        if (v28 || (xpc_object_t v28 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v28) == MEMORY[0x1E4F14590])
          {
            xpc_retain(v28);
            xpc_object_t v29 = v28;
          }
          else
          {
            xpc_object_t v29 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v29 = xpc_null_create();
          xpc_object_t v28 = 0;
        }
        xpc_release(v28);
        size_t v41 = strlen(v18);
        if (v41 >= 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        size_t v42 = v41;
        if (v41 >= 0x17)
        {
          uint64_t v44 = (v41 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v41 | 7) != 0x17) {
            uint64_t v44 = v41 | 7;
          }
          uint64_t v45 = v44 + 1;
          long long v43 = operator new(v44 + 1);
          *(void *)&long long v83 = v42;
          *((void *)&v83 + 1) = v45 | 0x8000000000000000;
          *(void *)std::string buf = v43;
        }
        else
        {
          HIBYTE(v83) = v41;
          long long v43 = buf;
          if (!v41) {
            goto LABEL_115;
          }
        }
        memmove(v43, v18, v42);
LABEL_115:
        *((unsigned char *)v43 + v42) = 0;
        if (v83 >= 0) {
          long long v46 = (const char *)buf;
        }
        else {
          long long v46 = *(const char **)buf;
        }
        xpc_object_t v47 = xpc_string_create(v46);
        if (!v47) {
          xpc_object_t v47 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeySE", v47);
        xpc_object_t v48 = xpc_null_create();
        xpc_release(v47);
        xpc_release(v48);
        if (SHIBYTE(v83) < 0) {
          operator delete(*(void **)buf);
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 184) + 104))(buf);
        if (v83 >= 0) {
          uint64_t v49 = (const char *)buf;
        }
        else {
          uint64_t v49 = *(const char **)buf;
        }
        xpc_object_t v50 = xpc_string_create(v49);
        if (!v50) {
          xpc_object_t v50 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeyConfigName", v50);
        xpc_object_t v51 = xpc_null_create();
        xpc_release(v50);
        xpc_release(v51);
        if (SHIBYTE(v83) < 0) {
          operator delete(*(void **)buf);
        }
        unsigned int v52 = (*(uint64_t (**)(void))(**(void **)(v5 + 184) + 112))(*(void *)(v5 + 184));
        xpc_object_t v53 = xpc_int64_create(v52);
        if (!v53) {
          xpc_object_t v53 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeyConfigHistory", v53);
        xpc_object_t v54 = xpc_null_create();
        xpc_release(v53);
        xpc_release(v54);
        std::string v55 = (char *)operator new(0x38uLL);
        strcpy(v55, "/private/var/mobile/Library/Logs/CellularLogging");
        xpc_object_t v56 = xpc_string_create(v55);
        if (!v56) {
          xpc_object_t v56 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "LogPath", v56);
        xpc_object_t v57 = xpc_null_create();
        xpc_release(v56);
        xpc_release(v57);
        operator delete(v55);
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v5 + 184) + 120))(buf);
        if (v83 >= 0) {
          long long v58 = (const char *)buf;
        }
        else {
          long long v58 = *(const char **)buf;
        }
        xpc_object_t v59 = xpc_string_create(v58);
        if (!v59) {
          xpc_object_t v59 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeyLogExt", v59);
        xpc_object_t v60 = xpc_null_create();
        xpc_release(v59);
        xpc_release(v60);
        if (SHIBYTE(v83) < 0) {
          operator delete(*(void **)buf);
        }
        unsigned int v61 = (*(uint64_t (**)(void))(**(void **)(v5 + 184) + 112))(*(void *)(v5 + 184));
        xpc_object_t v62 = xpc_int64_create(v61);
        if (!v62) {
          xpc_object_t v62 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeyMaxNumberOfFiles", v62);
        xpc_object_t v63 = xpc_null_create();
        xpc_release(v62);
        xpc_release(v63);
        unsigned int v64 = (*(uint64_t (**)(void))(**(void **)(v5 + 184) + 136))(*(void *)(v5 + 184));
        xpc_object_t v65 = xpc_int64_create(v64);
        if (!v65) {
          xpc_object_t v65 = xpc_null_create();
        }
        xpc_dictionary_set_value(v29, "kKeyFileSize", v65);
        xpc_object_t v66 = xpc_null_create();
        xpc_release(v65);
        xpc_release(v66);
        (*(void (**)(xpc_object_t *__return_ptr))(**(void **)(v5 + 184) + 144))(&value);
        xpc_dictionary_set_value(v29, "kKeyGUIDLists", value);
        xpc_object_t v67 = value;
        xpc_object_t value = xpc_null_create();
        xpc_release(v67);
        xpc_release(value);
        xpc_object_t value = 0;
        (*(void (**)(xpc_object_t *__return_ptr))(**(void **)(v5 + 184) + 152))(&v76);
        xpc_dictionary_set_value(v29, "kKeyDIAGIDLists", v76);
        xpc_object_t v68 = v76;
        xpc_object_t v76 = xpc_null_create();
        xpc_release(v68);
        xpc_release(v76);
        xpc_object_t v76 = 0;
        if (v18) {
          free(v18);
        }
        uint64_t v69 = *(NSObject **)(v5 + 112);
        if (v69)
        {
          dispatch_retain(*(dispatch_object_t *)(v5 + 112));
          dispatch_group_enter(v69);
        }
        uint64_t v70 = *(NSObject **)(v5 + 160);
        *(void *)(v5 + 160) = v69;
        if (v70)
        {
          dispatch_group_leave(v70);
          dispatch_release(v70);
        }
        if (v29)
        {
          xpc_retain(v29);
          xpc_object_t v71 = v29;
        }
        else
        {
          xpc_object_t v71 = xpc_null_create();
        }
        if (*(void *)a4) {
          uint64_t v72 = _Block_copy(*(const void **)a4);
        }
        else {
          uint64_t v72 = 0;
        }
        long long v73 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        *(void *)&long long v83 = 3321888768;
        *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v72) {
          uint64_t v74 = _Block_copy(v72);
        }
        else {
          uint64_t v74 = 0;
        }
        int v87 = 0;
        aBlocuint64_t k = v74;
        xpc_object_t object = v71;
        if (v71) {
          xpc_retain(v71);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        dispatch_async(v73, buf);
        xpc_release(object);
        xpc_object_t object = 0;
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v72) {
          _Block_release(v72);
        }
        xpc_release(v71);
        xpc_release(v29);
        goto LABEL_167;
      }
      size_t v14 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created!", buf, 2u);
      }
      xpc_object_t v12 = xpc_null_create();
      if (*(void *)a4) {
        std::string::size_type v15 = _Block_copy(*(const void **)a4);
      }
      else {
        std::string::size_type v15 = 0;
      }
      uint64_t v21 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      *(void *)&long long v83 = 3321888768;
      *((void *)&v83 + 1) = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      uint64_t v84 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v15)
      {
        char v22 = _Block_copy(v15);
        int v87 = -534716414;
        aBlocuint64_t k = v22;
        xpc_object_t object = v12;
        if (v12)
        {
LABEL_32:
          xpc_retain(v12);
LABEL_35:
          dispatch_async(v21, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v15) {
            _Block_release(v15);
          }
          goto LABEL_105;
        }
      }
      else
      {
        int v87 = -534716414;
        aBlocuint64_t k = 0;
        xpc_object_t object = v12;
        if (v12) {
          goto LABEL_32;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_35;
    }
  }
LABEL_167:
  dispatch_group_t v75 = v81;
  if (v81)
  {
    if (!atomic_fetch_add(&v81->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }
}

void sub_1A615F42C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  xpc_release(v22);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t abm::CellularLoggingTask::isAppEntitled()
{
  return TelephonyXPC::ServerClientState::isClientEntitled();
}

uint64_t abm::CellularLoggingTask::isCarrierBundleKeyExist(abm::CellularLoggingTask *this)
{
  BOOL v5 = 0;
  uint64_t result = *((void *)this + 23);
  if (result)
  {
    memset(&v4, 170, sizeof(v4));
    strcpy(__p, "CellularLoggingAllowed");
    char v3 = 22;
    abm::CellularLoggingCommon::getProperty(result, __p, &v4);
    if (v3 < 0) {
      operator delete(*(void **)__p);
    }
    util::convert<BOOL>(&v4, &v5, 0);
    if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v4.__r_.__value_.__l.__data_);
    }
    return v5;
  }
  return result;
}

void sub_1A615F628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingTask::isUserAgreeLegalInfo(abm::CellularLoggingTask *this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(&v40, 170, sizeof(v40));
  uint64_t v2 = *((void *)this + 23);
  char v39 = 12;
  strcpy((char *)__p, "CarrierName1");
  abm::CellularLoggingCommon::getProperty(v2, (const std::string::value_type *)__p, &v40);
  if (v39 < 0) {
    operator delete(__p[0]);
  }
  memset(&__sz, 170, sizeof(__sz));
  uint64_t v3 = *((void *)this + 23);
  char v36 = 12;
  strcpy((char *)v35, "CarrierName2");
  abm::CellularLoggingCommon::getProperty(v3, (const std::string::value_type *)v35, &__sz);
  if (v36 < 0)
  {
    operator delete(v35[0]);
    memset(&v34, 170, sizeof(v34));
    int v4 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      if (v4)
      {
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v40.__r_.__value_.__l.__data_;
        std::string::size_type v5 = v40.__r_.__value_.__r.__words[2];
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    memset(&v34, 170, sizeof(v34));
    int v4 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  std::string::size_type size = v40.__r_.__value_.__l.__size_;
  if (v40.__r_.__value_.__l.__size_)
  {
    p_sz = &v40;
    goto LABEL_20;
  }
LABEL_10:
  if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __sz.__r_.__value_.__l.__size_;
    if (!__sz.__r_.__value_.__l.__size_)
    {
LABEL_25:
      *((unsigned char *)&v34.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v34, "Carrier");
      int v8 = (char)v4;
      if ((v4 & 0x80u) == 0) {
        size_t v9 = v4;
      }
      else {
        size_t v9 = v40.__r_.__value_.__l.__size_;
      }
      if (!v9) {
        goto LABEL_48;
      }
      goto LABEL_29;
    }
    p_sz = &__sz;
LABEL_20:
    std::string::__init_copy_ctor_external(&v34, p_sz->__r_.__value_.__l.__data_, size);
    int v8 = SHIBYTE(v40.__r_.__value_.__r.__words[2]);
    if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v9 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t v9 = v40.__r_.__value_.__l.__size_;
    }
    if (!v9) {
      goto LABEL_48;
    }
    goto LABEL_29;
  }
  if (!*((unsigned char *)&__sz.__r_.__value_.__s + 23)) {
    goto LABEL_25;
  }
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&__sz.__r_.__value_.__l.__data_;
  std::string::size_type v5 = __sz.__r_.__value_.__r.__words[2];
LABEL_13:
  v34.__r_.__value_.__r.__words[2] = v5;
  int v8 = (char)v4;
  if ((v4 & 0x80u) == 0) {
    size_t v9 = v4;
  }
  else {
    size_t v9 = v40.__r_.__value_.__l.__size_;
  }
  if (!v9) {
    goto LABEL_48;
  }
LABEL_29:
  int v10 = SHIBYTE(__sz.__r_.__value_.__r.__words[2]);
  if ((__sz.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v11 = HIBYTE(__sz.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v11 = __sz.__r_.__value_.__l.__size_;
  }
  if (v11)
  {
    unint64_t v12 = v9 + 5;
    memset(&__dst, 170, sizeof(__dst));
    if (v9 + 5 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v12 > 0x16)
    {
      uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v14 = v12 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_dst = (std::string *)operator new(v14 + 1);
      __dst.__r_.__value_.__l.__size_ = v9 + 5;
      __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9 + 5;
    }
    if (v8 >= 0) {
      uint64_t v16 = &v40;
    }
    else {
      uint64_t v16 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    memmove(p_dst, v16, v9);
    strcpy((char *)p_dst + v9, " and ");
    if (v10 >= 0) {
      uint64_t v17 = &__sz;
    }
    else {
      uint64_t v17 = (std::string *)__sz.__r_.__value_.__r.__words[0];
    }
    std::string::size_type v18 = std::string::append(&__dst, (const std::string::value_type *)v17, v11);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v44.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    char v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
    v34.__r_.__value_.__r.__words[0] = v19;
    v34.__r_.__value_.__l.__size_ = v44.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&v34.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v44.__r_.__value_.__r.__words + 7);
    *((unsigned char *)&v34.__r_.__value_.__s + 23) = v20;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_49;
      }
      goto LABEL_51;
    }
  }
LABEL_48:
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_49:
    std::string v32 = v34;
    goto LABEL_52;
  }
LABEL_51:
  std::string::__init_copy_ctor_external(&v32, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
LABEL_52:
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v44, v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
  }
  else {
    std::string v44 = v32;
  }
  CFStringRef v41 = 0;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__dst, v44.__r_.__value_.__l.__data_, v44.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = v44;
  }
  long long v43 = 0;
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (ctu::cf::convert_copy()) {
    char v22 = v43;
  }
  else {
    char v22 = 0;
  }
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size_t v33 = v22;
    if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_63;
    }
LABEL_83:
    operator delete(v44.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_84;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  size_t v33 = v22;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_83;
  }
LABEL_63:
  if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_64;
  }
LABEL_84:
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_64:
  __dst.__r_.__value_.__r.__words[0] = 0;
  CFURLRef v23 = CFURLCreateWithFileSystemPath(v21, @"/System/Library/PrivateFrameworks/ABMHelper.framework", kCFURLPOSIXPathStyle, 0);
  v44.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
  uint64_t v24 = CFBundleCreate(v21, v23);
  long long v43 = v24;
  CFStringRef v25 = CFBundleCopyLocalizedString(v24, @"USERCONFIRM_MESSAGE", @"USERCONFIRM_MESSAGE", @"CellularLoggingTask");
  CFStringRef v26 = CFStringCreateWithFormat(v21, 0, v25, v22);
  CFStringRef v41 = v26;
  CFStringRef v27 = CFBundleCopyLocalizedString(v24, @"USERCONFIRM_TITLE", @"USERCONFIRM_TITLE", @"CellularLoggingTask");
  CFStringRef v28 = CFBundleCopyLocalizedString(v24, @"USERCONFIRM_ALLOW", @"USERCONFIRM_ALLOW", @"CellularLoggingTask");
  CFStringRef v29 = CFBundleCopyLocalizedString(v24, @"USERCONFIRM_DENY", @"USERCONFIRM_DENY", @"CellularLoggingTask");
  CFUserNotificationDisplayAlert(0.0, 3uLL, 0, 0, 0, v27, v26, v28, v29, 0, (CFOptionFlags *)&__dst);
  CFRelease(v25);
  std::string::size_type v30 = __dst.__r_.__value_.__r.__words[0];
  if (v29) {
    CFRelease(v29);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v22) {
    CFRelease(v22);
  }
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__sz.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_80;
    }
LABEL_86:
    operator delete(__sz.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v30 == 0;
    }
LABEL_87:
    operator delete(v40.__r_.__value_.__l.__data_);
    return v30 == 0;
  }
  operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_86;
  }
LABEL_80:
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_87;
  }
  return v30 == 0;
}

void sub_1A615FC64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_5(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v5);
    uint64_t v35 = v8;
    if (v8)
    {
      size_t v9 = v8;
      if (!a1[5])
      {
LABEL_79:
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      int v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging Stop", buf, 2u);
      }
      if (*(void *)(v7 + 184))
      {
        xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
        uint64_t v12 = MEMORY[0x1E4F14590];
        if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v11) == v12)
          {
            xpc_retain(v11);
            xpc_object_t v13 = v11;
          }
          else
          {
            xpc_object_t v13 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v13 = xpc_null_create();
          xpc_object_t v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A6275E60](v13) == v12)
        {
          if (abm::CellularLoggingCommon::isStarted(*(abm::CellularLoggingCommon **)(v7 + 184)))
          {
            uint64_t v22 = *(void *)(v7 + 184);
            if (*(void *)a4) {
              CFURLRef v23 = _Block_copy(*(const void **)a4);
            }
            else {
              CFURLRef v23 = 0;
            }
            CFStringRef v28 = *(NSObject **)(a4 + 8);
            if (v28) {
              dispatch_retain(v28);
            }
            uint64_t v30 = a1[5];
            CFStringRef v29 = (std::__shared_weak_count *)a1[6];
            if (v29) {
              atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            std::string v44 = 0;
            xpc_object_t v31 = operator new(0x30uLL);
            *xpc_object_t v31 = &unk_1EFB0C940;
            v31[1] = v23;
            void v31[2] = v28;
            v31[3] = v30;
            uint8_t v31[4] = v29;
            if (v29) {
              atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            v31[5] = v7;
            std::string v44 = v31;
            (*(void (**)(uint64_t, void *))(*(void *)v22 + 64))(v22, v43);
            if (v44 == v43)
            {
              (*(void (**)(void *))(v43[0] + 32))(v43);
            }
            else if (v44)
            {
              (*(void (**)(void *))(*v44 + 40))(v44);
            }
            if (v29) {
              std::__shared_weak_count::__release_weak(v29);
            }
            std::string v34 = *(NSObject **)(v7 + 160);
            *(void *)(v7 + 160) = 0;
            if (v34)
            {
              dispatch_group_leave(v34);
              dispatch_release(v34);
            }
LABEL_78:
            xpc_release(v13);
            size_t v9 = v35;
            if (!v35) {
              return;
            }
            goto LABEL_79;
          }
          CFStringRef v26 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1A609F000, v26, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
          }
          xpc_object_t v20 = xpc_null_create();
          if (*(void *)a4) {
            CFStringRef v27 = _Block_copy(*(const void **)a4);
          }
          else {
            CFStringRef v27 = 0;
          }
          std::string v32 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v37 = 3321888768;
          long long v38 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          char v39 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v27) {
            size_t v33 = _Block_copy(v27);
          }
          else {
            size_t v33 = 0;
          }
          int v42 = 0;
          aBlocuint64_t k = v33;
          xpc_object_t object = v20;
          if (v20) {
            xpc_retain(v20);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          dispatch_async(v32, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v27) {
            _Block_release(v27);
          }
LABEL_46:
          xpc_release(v20);
          goto LABEL_78;
        }
        std::string::size_type v19 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
        }
        xpc_object_t v20 = xpc_null_create();
        if (*(void *)a4) {
          CFAllocatorRef v21 = _Block_copy(*(const void **)a4);
        }
        else {
          CFAllocatorRef v21 = 0;
        }
        uint64_t v24 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v37 = 3321888768;
        long long v38 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        char v39 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v21)
        {
          CFStringRef v25 = _Block_copy(v21);
          int v42 = -534716416;
          aBlocuint64_t k = v25;
          xpc_object_t object = v20;
          if (v20)
          {
LABEL_39:
            xpc_retain(v20);
LABEL_42:
            dispatch_async(v24, buf);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v21) {
              _Block_release(v21);
            }
            goto LABEL_46;
          }
        }
        else
        {
          int v42 = -534716416;
          aBlocuint64_t k = 0;
          xpc_object_t object = v20;
          if (v20) {
            goto LABEL_39;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_42;
      }
      uint64_t v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created!", buf, 2u);
      }
      xpc_object_t v15 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v16 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t v17 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3321888768;
      long long v38 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      char v39 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        std::string::size_type v18 = _Block_copy(v16);
        int v42 = -534716414;
        aBlocuint64_t k = v18;
        xpc_object_t object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v16) {
            _Block_release(v16);
          }
          xpc_release(v15);
          goto LABEL_79;
        }
      }
      else
      {
        int v42 = -534716414;
        aBlocuint64_t k = 0;
        xpc_object_t object = v15;
        if (v15) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A61604A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void *std::function<void ()(BOOL,xpc::dict)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb_EN3__1D1Ev(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (v3) {
    dispatch_release(v3);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_6(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v5);
    std::string v32 = v8;
    if (v8)
    {
      size_t v9 = v8;
      if (!a1[5])
      {
LABEL_63:
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      int v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Getting Current Index", buf, 2u);
      }
      if (*(void *)(v7 + 184))
      {
        xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
        uint64_t v12 = MEMORY[0x1E4F14590];
        if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v11) == v12)
          {
            xpc_retain(v11);
            xpc_object_t v13 = v11;
          }
          else
          {
            xpc_object_t v13 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v13 = xpc_null_create();
          xpc_object_t v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A6275E60](v13) != v12)
        {
          std::string::size_type v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
          }
          xpc_object_t v20 = xpc_null_create();
          if (*(void *)a4) {
            CFAllocatorRef v21 = _Block_copy(*(const void **)a4);
          }
          else {
            CFAllocatorRef v21 = 0;
          }
          CFStringRef v28 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v34 = 3321888768;
          uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            CFStringRef v29 = _Block_copy(v21);
            int v39 = -534716416;
            aBlocuint64_t k = v29;
            xpc_object_t object = v20;
            if (v20)
            {
LABEL_43:
              xpc_retain(v20);
LABEL_46:
              dispatch_async(v28, buf);
              xpc_release(object);
              xpc_object_t object = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v21) {
                _Block_release(v21);
              }
              goto LABEL_62;
            }
          }
          else
          {
            int v39 = -534716416;
            aBlocuint64_t k = 0;
            xpc_object_t object = v20;
            if (v20) {
              goto LABEL_43;
            }
          }
          xpc_object_t object = xpc_null_create();
          goto LABEL_46;
        }
        unsigned int v22 = (*(uint64_t (**)(void))(**(void **)(v7 + 184) + 160))(*(void *)(v7 + 184));
        xpc_object_t v23 = xpc_int64_create(v22);
        if (!v23) {
          xpc_object_t v23 = xpc_null_create();
        }
        xpc_dictionary_set_value(v13, "kKeyCurrentIndex", v23);
        xpc_object_t v24 = xpc_null_create();
        xpc_release(v23);
        xpc_release(v24);
        CFStringRef v25 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v22;
          _os_log_impl(&dword_1A609F000, v25, OS_LOG_TYPE_DEFAULT, "#I Current Index is set to - 0x%x", buf, 8u);
        }
        if (v13)
        {
          xpc_retain(v13);
          xpc_object_t v20 = v13;
          CFStringRef v26 = *(const void **)a4;
          if (*(void *)a4)
          {
LABEL_39:
            CFStringRef v27 = _Block_copy(v26);
            goto LABEL_53;
          }
        }
        else
        {
          xpc_object_t v20 = xpc_null_create();
          CFStringRef v26 = *(const void **)a4;
          if (*(void *)a4) {
            goto LABEL_39;
          }
        }
        CFStringRef v27 = 0;
LABEL_53:
        uint64_t v30 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v34 = 3321888768;
        uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v27)
        {
          xpc_object_t v31 = _Block_copy(v27);
          int v39 = 0;
          aBlocuint64_t k = v31;
          xpc_object_t object = v20;
          if (v20)
          {
LABEL_55:
            xpc_retain(v20);
LABEL_58:
            dispatch_async(v30, buf);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v27) {
              _Block_release(v27);
            }
LABEL_62:
            xpc_release(v20);
            xpc_release(v13);
            size_t v9 = v32;
            if (!v32) {
              return;
            }
            goto LABEL_63;
          }
        }
        else
        {
          int v39 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t object = v20;
          if (v20) {
            goto LABEL_55;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_58;
      }
      uint64_t v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      xpc_object_t v15 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v16 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t v17 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v34 = 3321888768;
      uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        std::string::size_type v18 = _Block_copy(v16);
        int v39 = -534716416;
        aBlocuint64_t k = v18;
        xpc_object_t object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v16) {
            _Block_release(v16);
          }
          xpc_release(v15);
          goto LABEL_63;
        }
      }
      else
      {
        int v39 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t object = v15;
        if (v15) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A6160BF4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_7(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v5);
    char v36 = v8;
    if (v8)
    {
      size_t v9 = v8;
      if (!a1[5])
      {
LABEL_69:
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      int v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Getting Config Lists", buf, 2u);
      }
      if (*(void *)(v7 + 184))
      {
        xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
        uint64_t v12 = MEMORY[0x1E4F14590];
        if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v11) == v12)
          {
            xpc_retain(v11);
            xpc_object_t v13 = v11;
          }
          else
          {
            xpc_object_t v13 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v13 = xpc_null_create();
          xpc_object_t v11 = 0;
        }
        xpc_release(v11);
        if (MEMORY[0x1A6275E60](v13) != v12)
        {
          std::string::size_type v19 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Failed to create output dictionary!", buf, 2u);
          }
          xpc_object_t v20 = xpc_null_create();
          if (*(void *)a4) {
            CFAllocatorRef v21 = _Block_copy(*(const void **)a4);
          }
          else {
            CFAllocatorRef v21 = 0;
          }
          CFStringRef v27 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v38 = 3321888768;
          int v39 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          uint64_t v40 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            CFStringRef v28 = _Block_copy(v21);
            int v43 = -534716416;
            aBlocuint64_t k = v28;
            xpc_object_t object = v20;
            if (v20)
            {
LABEL_41:
              xpc_retain(v20);
LABEL_44:
              dispatch_async(v27, buf);
              xpc_release(object);
              xpc_object_t object = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v21) {
                _Block_release(v21);
              }
              xpc_release(v20);
              goto LABEL_68;
            }
          }
          else
          {
            int v43 = -534716416;
            aBlocuint64_t k = 0;
            xpc_object_t object = v20;
            if (v20) {
              goto LABEL_41;
            }
          }
          xpc_object_t object = xpc_null_create();
          goto LABEL_44;
        }
        memset(__p, 170, sizeof(__p));
        (*(void (**)(void **__return_ptr))(**(void **)(v7 + 184) + 168))(__p);
        xpc_object_t v22 = xpc_data_create(__p[0], (char *)__p[1] - (char *)__p[0]);
        if (!v22) {
          xpc_object_t v22 = xpc_null_create();
        }
        xpc_dictionary_set_value(v13, "kKeyConfigLists", v22);
        xpc_object_t v23 = xpc_null_create();
        xpc_release(v22);
        xpc_release(v23);
        if (v13)
        {
          xpc_retain(v13);
          xpc_object_t v24 = v13;
          CFStringRef v25 = *(const void **)a4;
          if (*(void *)a4)
          {
LABEL_37:
            CFStringRef v26 = _Block_copy(v25);
            goto LABEL_51;
          }
        }
        else
        {
          xpc_object_t v24 = xpc_null_create();
          CFStringRef v25 = *(const void **)a4;
          if (*(void *)a4) {
            goto LABEL_37;
          }
        }
        CFStringRef v26 = 0;
LABEL_51:
        CFStringRef v29 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v38 = 3321888768;
        int v39 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        uint64_t v40 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v26)
        {
          uint64_t v30 = _Block_copy(v26);
          int v43 = 0;
          aBlocuint64_t k = v30;
          xpc_object_t object = v24;
          if (v24)
          {
LABEL_53:
            xpc_retain(v24);
LABEL_56:
            dispatch_async(v29, buf);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v26) {
              _Block_release(v26);
            }
            xpc_release(v24);
            xpc_object_t v31 = (void **)__p[0];
            if (__p[0])
            {
              std::string v32 = (void **)__p[1];
              size_t v33 = __p[0];
              if (__p[1] != __p[0])
              {
                do
                {
                  if (*((char *)v32 - 1) < 0) {
                    operator delete(*(v32 - 3));
                  }
                  v32 -= 3;
                }
                while (v32 != v31);
                size_t v33 = __p[0];
              }
              __p[1] = v31;
              operator delete(v33);
            }
LABEL_68:
            xpc_release(v13);
            size_t v9 = v36;
            if (!v36) {
              return;
            }
            goto LABEL_69;
          }
        }
        else
        {
          int v43 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t object = v24;
          if (v24) {
            goto LABEL_53;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_56;
      }
      uint64_t v14 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      xpc_object_t v15 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v16 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t v17 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v38 = 3321888768;
      int v39 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      uint64_t v40 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        std::string::size_type v18 = _Block_copy(v16);
        int v43 = -534716416;
        aBlocuint64_t k = v18;
        xpc_object_t object = v15;
        if (v15)
        {
LABEL_19:
          xpc_retain(v15);
LABEL_22:
          dispatch_async(v17, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v16) {
            _Block_release(v16);
          }
          xpc_release(v15);
          goto LABEL_69;
        }
      }
      else
      {
        int v43 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t object = v15;
        if (v15) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A6161298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  xpc_release(v13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v5);
    std::string v32 = v8;
    if (v8)
    {
      size_t v9 = v8;
      if (!a1[5]) {
        goto LABEL_67;
      }
      int v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Pause Cellular Logging", buf, 2u);
      }
      xpc_object_t v11 = *(abm::CellularLoggingCommon **)(v7 + 184);
      if (v11)
      {
        if (abm::CellularLoggingCommon::isStarted(v11))
        {
          uint64_t v12 = *(void *)(v7 + 184);
          xpc_object_t object = xpc_null_create();
          LOBYTE(v12) = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(void *)v12 + 72))(v12, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          if (v12)
          {
            xpc_object_t v13 = xpc_null_create();
            if (*(void *)a4) {
              uint64_t v14 = _Block_copy(*(const void **)a4);
            }
            else {
              uint64_t v14 = 0;
            }
            CFStringRef v26 = *(NSObject **)(a4 + 8);
            *(void *)std::string buf = MEMORY[0x1E4F143A8];
            uint64_t v34 = 3321888768;
            uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v14)
            {
              CFStringRef v27 = _Block_copy(v14);
              int v39 = 0;
              aBlocuint64_t k = v27;
              xpc_object_t v38 = v13;
              if (v13)
              {
LABEL_48:
                xpc_retain(v13);
LABEL_55:
                dispatch_async(v26, buf);
                xpc_release(v38);
                xpc_object_t v38 = 0;
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v14) {
                  _Block_release(v14);
                }
LABEL_66:
                xpc_release(v13);
LABEL_67:
                if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
                  std::__shared_weak_count::__release_weak(v9);
                }
                return;
              }
            }
            else
            {
              int v39 = 0;
              aBlocuint64_t k = 0;
              xpc_object_t v38 = v13;
              if (v13) {
                goto LABEL_48;
              }
            }
            xpc_object_t v38 = xpc_null_create();
            goto LABEL_55;
          }
          xpc_object_t v20 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v20, OS_LOG_TYPE_ERROR, "Failed to pause cellular logging", buf, 2u);
          }
          xpc_object_t v13 = xpc_null_create();
          if (*(void *)a4) {
            CFAllocatorRef v21 = _Block_copy(*(const void **)a4);
          }
          else {
            CFAllocatorRef v21 = 0;
          }
          CFStringRef v28 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v34 = 3321888768;
          uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            CFStringRef v29 = _Block_copy(v21);
            int v39 = -534716416;
            aBlocuint64_t k = v29;
            xpc_object_t v38 = v13;
            if (v13)
            {
LABEL_52:
              xpc_retain(v13);
LABEL_62:
              dispatch_async(v28, buf);
              xpc_release(v38);
              xpc_object_t v38 = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v21) {
                _Block_release(v21);
              }
              goto LABEL_66;
            }
          }
          else
          {
            int v39 = -534716416;
            aBlocuint64_t k = 0;
            xpc_object_t v38 = v13;
            if (v13) {
              goto LABEL_52;
            }
          }
          xpc_object_t v38 = xpc_null_create();
          goto LABEL_62;
        }
        std::string::size_type v18 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl(&dword_1A609F000, v18, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
        }
        xpc_object_t v16 = xpc_null_create();
        if (*(void *)a4) {
          std::string::size_type v19 = _Block_copy(*(const void **)a4);
        }
        else {
          std::string::size_type v19 = 0;
        }
        xpc_object_t v24 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v34 = 3321888768;
        uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          CFStringRef v25 = _Block_copy(v19);
          int v39 = 0;
          aBlocuint64_t k = v25;
          xpc_object_t v38 = v16;
          if (v16)
          {
LABEL_37:
            xpc_retain(v16);
LABEL_40:
            dispatch_async(v24, buf);
            xpc_release(v38);
            xpc_object_t v38 = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v19) {
              _Block_release(v19);
            }
LABEL_33:
            xpc_release(v16);
            goto LABEL_67;
          }
        }
        else
        {
          int v39 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t v38 = v16;
          if (v16) {
            goto LABEL_37;
          }
        }
        xpc_object_t v38 = xpc_null_create();
        goto LABEL_40;
      }
      xpc_object_t v15 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      xpc_object_t v16 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v17 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v17 = 0;
      }
      xpc_object_t v22 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v34 = 3321888768;
      uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        xpc_object_t v23 = _Block_copy(v17);
        int v39 = -534716416;
        aBlocuint64_t k = v23;
        xpc_object_t v38 = v16;
        if (v16)
        {
LABEL_26:
          xpc_retain(v16);
LABEL_29:
          dispatch_async(v22, buf);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v17) {
            _Block_release(v17);
          }
          goto LABEL_33;
        }
      }
      else
      {
        int v39 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t v38 = v16;
        if (v16) {
          goto LABEL_26;
        }
      }
      xpc_object_t v38 = xpc_null_create();
      goto LABEL_29;
    }
  }
}

void sub_1A6161924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_1A616195C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_9(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v5);
    std::string v32 = v8;
    if (v8)
    {
      size_t v9 = v8;
      if (!a1[5]) {
        goto LABEL_67;
      }
      int v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I Resume Cellular Logging", buf, 2u);
      }
      xpc_object_t v11 = *(abm::CellularLoggingCommon **)(v7 + 184);
      if (v11)
      {
        if (abm::CellularLoggingCommon::isStarted(v11))
        {
          uint64_t v12 = *(void *)(v7 + 184);
          xpc_object_t object = xpc_null_create();
          LOBYTE(v12) = (*(uint64_t (**)(uint64_t, xpc_object_t *))(*(void *)v12 + 80))(v12, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          if (v12)
          {
            xpc_object_t v13 = xpc_null_create();
            if (*(void *)a4) {
              uint64_t v14 = _Block_copy(*(const void **)a4);
            }
            else {
              uint64_t v14 = 0;
            }
            CFStringRef v26 = *(NSObject **)(a4 + 8);
            *(void *)std::string buf = MEMORY[0x1E4F143A8];
            uint64_t v34 = 3321888768;
            uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v14)
            {
              CFStringRef v27 = _Block_copy(v14);
              int v39 = 0;
              aBlocuint64_t k = v27;
              xpc_object_t v38 = v13;
              if (v13)
              {
LABEL_48:
                xpc_retain(v13);
LABEL_55:
                dispatch_async(v26, buf);
                xpc_release(v38);
                xpc_object_t v38 = 0;
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v14) {
                  _Block_release(v14);
                }
LABEL_66:
                xpc_release(v13);
LABEL_67:
                if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
                  std::__shared_weak_count::__release_weak(v9);
                }
                return;
              }
            }
            else
            {
              int v39 = 0;
              aBlocuint64_t k = 0;
              xpc_object_t v38 = v13;
              if (v13) {
                goto LABEL_48;
              }
            }
            xpc_object_t v38 = xpc_null_create();
            goto LABEL_55;
          }
          xpc_object_t v20 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v20, OS_LOG_TYPE_ERROR, "Failed to resume cellular logging", buf, 2u);
          }
          xpc_object_t v13 = xpc_null_create();
          if (*(void *)a4) {
            CFAllocatorRef v21 = _Block_copy(*(const void **)a4);
          }
          else {
            CFAllocatorRef v21 = 0;
          }
          CFStringRef v28 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v34 = 3321888768;
          uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v21)
          {
            CFStringRef v29 = _Block_copy(v21);
            int v39 = -534716416;
            aBlocuint64_t k = v29;
            xpc_object_t v38 = v13;
            if (v13)
            {
LABEL_52:
              xpc_retain(v13);
LABEL_62:
              dispatch_async(v28, buf);
              xpc_release(v38);
              xpc_object_t v38 = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v21) {
                _Block_release(v21);
              }
              goto LABEL_66;
            }
          }
          else
          {
            int v39 = -534716416;
            aBlocuint64_t k = 0;
            xpc_object_t v38 = v13;
            if (v13) {
              goto LABEL_52;
            }
          }
          xpc_object_t v38 = xpc_null_create();
          goto LABEL_62;
        }
        std::string::size_type v18 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl(&dword_1A609F000, v18, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
        }
        xpc_object_t v16 = xpc_null_create();
        if (*(void *)a4) {
          std::string::size_type v19 = _Block_copy(*(const void **)a4);
        }
        else {
          std::string::size_type v19 = 0;
        }
        xpc_object_t v24 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v34 = 3321888768;
        uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v19)
        {
          CFStringRef v25 = _Block_copy(v19);
          int v39 = 0;
          aBlocuint64_t k = v25;
          xpc_object_t v38 = v16;
          if (v16)
          {
LABEL_37:
            xpc_retain(v16);
LABEL_40:
            dispatch_async(v24, buf);
            xpc_release(v38);
            xpc_object_t v38 = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v19) {
              _Block_release(v19);
            }
LABEL_33:
            xpc_release(v16);
            goto LABEL_67;
          }
        }
        else
        {
          int v39 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t v38 = v16;
          if (v16) {
            goto LABEL_37;
          }
        }
        xpc_object_t v38 = xpc_null_create();
        goto LABEL_40;
      }
      xpc_object_t v15 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
      }
      xpc_object_t v16 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v17 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v17 = 0;
      }
      xpc_object_t v22 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v34 = 3321888768;
      uint64_t v35 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      char v36 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        xpc_object_t v23 = _Block_copy(v17);
        int v39 = -534716416;
        aBlocuint64_t k = v23;
        xpc_object_t v38 = v16;
        if (v16)
        {
LABEL_26:
          xpc_retain(v16);
LABEL_29:
          dispatch_async(v22, buf);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v17) {
            _Block_release(v17);
          }
          goto LABEL_33;
        }
      }
      else
      {
        int v39 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t v38 = v16;
        if (v16) {
          goto LABEL_26;
        }
      }
      xpc_object_t v38 = xpc_null_create();
      goto LABEL_29;
    }
  }
}

void sub_1A6161F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_1A6161FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_10(void *a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    size_t v9 = std::__shared_weak_count::lock(v5);
    std::string v44 = v9;
    if (v9)
    {
      int v10 = v9;
      if (!a1[5]) {
        goto LABEL_94;
      }
      xpc_object_t v11 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Setting up bundle ID monitoring for Cellular Logging", (uint8_t *)&buf, 2u);
      }
      if (*(void *)(v8 + 168))
      {
        if (MEMORY[0x1A6275E60](*a3) != MEMORY[0x1E4F14590])
        {
          xpc_object_t v12 = xpc_null_create();
          if (*(void *)a4) {
            xpc_object_t v13 = _Block_copy(*(const void **)a4);
          }
          else {
            xpc_object_t v13 = 0;
          }
          xpc_object_t v16 = *(NSObject **)(a4 + 8);
          buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
          buf.__r_.__value_.__l.__size_ = 3321888768;
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          xpc_object_t v48 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v13)
          {
            uint64_t v17 = _Block_copy(v13);
            int v51 = -534716414;
            aBlocuint64_t k = v17;
            xpc_object_t object = v12;
            if (v12)
            {
LABEL_17:
              xpc_retain(v12);
LABEL_20:
              dispatch_async(v16, &buf);
              xpc_release(object);
              xpc_object_t object = 0;
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (v13) {
                _Block_release(v13);
              }
LABEL_24:
              xpc_release(v12);
LABEL_94:
              if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
                std::__shared_weak_count::__release_weak(v10);
              }
              return;
            }
          }
          else
          {
            int v51 = -534716414;
            aBlocuint64_t k = 0;
            xpc_object_t object = v12;
            if (v12) {
              goto LABEL_17;
            }
          }
          xpc_object_t object = xpc_null_create();
          goto LABEL_20;
        }
        memset(&v42, 170, sizeof(v42));
        xpc_object_t value = xpc_dictionary_get_value(*a3, "kKeyAppBundleID");
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)value;
        if (value) {
          xpc_retain(value);
        }
        else {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        }
        xpc::dyn_cast_or_default();
        xpc_release(buf.__r_.__value_.__l.__data_);
        xpc_object_t v20 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          CFAllocatorRef v21 = &v42;
          if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            CFAllocatorRef v21 = (std::string *)v42.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
          _os_log_impl(&dword_1A609F000, v20, OS_LOG_TYPE_DEFAULT, "#I Preparing to set up monitoring for bundle ID %s", (uint8_t *)&buf, 0xCu);
        }
        xpc_object_t v22 = *(NSObject ***)(v8 + 168);
        xpc_object_t v23 = *(NSObject **)(v8 + 88);
        CFStringRef v41 = v23;
        if (v23) {
          dispatch_retain(v23);
        }
        uint64_t v38 = v8;
        if (*(void *)a4)
        {
          xpc_object_t v24 = _Block_copy(*(const void **)a4);
          CFStringRef v25 = *(NSObject **)(a4 + 8);
          int v39 = v24;
          uint64_t v40 = v25;
          if (!v25) {
            goto LABEL_46;
          }
        }
        else
        {
          xpc_object_t v24 = 0;
          CFStringRef v25 = *(NSObject **)(a4 + 8);
          int v39 = 0;
          uint64_t v40 = v25;
          if (!v25)
          {
LABEL_46:
            long long v46 = 0;
            CFStringRef v26 = operator new(0x20uLL);
            *CFStringRef v26 = &unk_1EFB0C9D0;
            v26[1] = v8;
            v26[2] = v24;
            v26[3] = v25;
            int v39 = 0;
            uint64_t v40 = 0;
            long long v46 = v26;
            abm::AppMonitor::setAppStateHandler(v22, &v41, v45);
            if (v46 == v45)
            {
              (*(void (**)(void *))(v45[0] + 32))(v45);
            }
            else if (v46)
            {
              (*(void (**)(void))(*v46 + 40))();
            }
            if (v23) {
              dispatch_release(v23);
            }
            CFStringRef v27 = *(void ***)(v8 + 168);
            if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
              std::string::__init_copy_ctor_external(&__p, v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
            }
            else {
              std::string __p = v42;
            }
            CFStringRef v28 = *v27;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              std::string::__init_copy_ctor_external(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            }
            else {
              std::string buf = __p;
            }
            BOOL v29 = abm::AppMonitorInternal::addBundleID(v28, (uint64_t)&buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(buf.__r_.__value_.__l.__data_);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_62:
                if (v29)
                {
LABEL_63:
                  abm::AppMonitorInternal::start(**(abm::AppMonitorInternal ***)(v8 + 168));
                  xpc_object_t v30 = xpc_null_create();
                  if (*(void *)a4) {
                    xpc_object_t v31 = _Block_copy(*(const void **)a4);
                  }
                  else {
                    xpc_object_t v31 = 0;
                  }
                  uint64_t v35 = *(NSObject **)(a4 + 8);
                  buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
                  buf.__r_.__value_.__l.__size_ = 3321888768;
                  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
                  xpc_object_t v48 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
                  if (v31) {
                    char v36 = _Block_copy(v31);
                  }
                  else {
                    char v36 = 0;
                  }
                  int v51 = 0;
                  aBlocuint64_t k = v36;
                  xpc_object_t object = v30;
                  if (v30) {
                    xpc_retain(v30);
                  }
                  else {
                    xpc_object_t object = xpc_null_create();
                  }
                  dispatch_async(v35, &buf);
                  xpc_release(object);
                  xpc_object_t object = 0;
                  if (aBlock) {
                    _Block_release(aBlock);
                  }
                  if (v31) {
                    _Block_release(v31);
                  }
LABEL_92:
                  xpc_release(v30);
                  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v42.__r_.__value_.__l.__data_);
                  }
                  goto LABEL_94;
                }
LABEL_67:
                xpc_object_t v30 = xpc_null_create();
                if (*(void *)a4) {
                  std::string v32 = _Block_copy(*(const void **)a4);
                }
                else {
                  std::string v32 = 0;
                }
                size_t v33 = *(NSObject **)(a4 + 8);
                buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
                buf.__r_.__value_.__l.__size_ = 3321888768;
                buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
                xpc_object_t v48 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
                if (v32) {
                  uint64_t v34 = _Block_copy(v32);
                }
                else {
                  uint64_t v34 = 0;
                }
                int v51 = -534716416;
                aBlocuint64_t k = v34;
                xpc_object_t object = v30;
                if (v30) {
                  xpc_retain(v30);
                }
                else {
                  xpc_object_t object = xpc_null_create();
                }
                dispatch_async(v33, &buf);
                xpc_release(object);
                xpc_object_t object = 0;
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v32) {
                  _Block_release(v32);
                }
                goto LABEL_92;
              }
            }
            else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_62;
            }
            operator delete(__p.__r_.__value_.__l.__data_);
            if (v29) {
              goto LABEL_63;
            }
            goto LABEL_67;
          }
        }
        dispatch_retain(v25);
        goto LABEL_46;
      }
      xpc_object_t v12 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v14 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v14 = 0;
      }
      std::string::size_type v18 = *(NSObject **)(a4 + 8);
      buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
      buf.__r_.__value_.__l.__size_ = 3321888768;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      xpc_object_t v48 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v14)
      {
        std::string::size_type v19 = _Block_copy(v14);
        int v51 = -534716416;
        aBlocuint64_t k = v19;
        xpc_object_t object = v12;
        if (v12)
        {
LABEL_28:
          xpc_retain(v12);
LABEL_31:
          dispatch_async(v18, &buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v14) {
            _Block_release(v14);
          }
          goto LABEL_24;
        }
      }
      else
      {
        int v51 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t object = v12;
        if (v12) {
          goto LABEL_28;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_31;
    }
  }
}

void sub_1A6162710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t object,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb0_EN3__2D1Ev(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3) {
    _Block_release(v3);
  }
  return a1;
}

void ___ZN3abm19CellularLoggingTask9init_syncEv_block_invoke_12(void *a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  std::string::size_type v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    size_t v9 = std::__shared_weak_count::lock(v5);
    int v39 = v9;
    if (v9)
    {
      int v10 = v9;
      if (!a1[5])
      {
LABEL_84:
        if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      xpc_object_t v11 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging dump Telephony Logs", buf, 2u);
      }
      if (*(void *)(v8 + 184))
      {
        xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
        uint64_t v13 = MEMORY[0x1E4F14590];
        if (v12 || (xpc_object_t v12 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v12) == v13)
          {
            xpc_retain(v12);
            xpc_object_t v14 = v12;
          }
          else
          {
            xpc_object_t v14 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
          xpc_object_t v12 = 0;
        }
        xpc_release(v12);
        if (MEMORY[0x1A6275E60](v14) == v13)
        {
          if (abm::CellularLoggingCommon::isStarted(*(abm::CellularLoggingCommon **)(v8 + 184)))
          {
            memset(__p, 170, sizeof(__p));
            xpc_object_t value = xpc_dictionary_get_value(*a3, "DumpStateReason");
            xpc_object_t v36 = value;
            if (value) {
              xpc_retain(value);
            }
            else {
              xpc_object_t v36 = xpc_null_create();
            }
            *(void *)std::string buf = 0;
            uint64_t v41 = 0;
            std::string v42 = 0;
            xpc::dyn_cast_or_default();
            if (SHIBYTE(v42) < 0) {
              operator delete(*(void **)buf);
            }
            xpc_release(v36);
            uint64_t v28 = *(void *)(v8 + 184);
            if (*(void *)a4) {
              BOOL v29 = _Block_copy(*(const void **)a4);
            }
            else {
              BOOL v29 = 0;
            }
            std::string v32 = *(NSObject **)(a4 + 8);
            if (v32) {
              dispatch_retain(v32);
            }
            uint64_t v34 = a1[5];
            size_t v33 = (std::__shared_weak_count *)a1[6];
            if (v33) {
              atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            xpc_object_t v48 = 0;
            uint64_t v35 = operator new(0x30uLL);
            void *v35 = &unk_1EFB0CA50;
            v35[1] = v29;
            v35[2] = v32;
            v35[3] = v34;
            v35[4] = v33;
            if (v33) {
              atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            v35[5] = v8;
            xpc_object_t v48 = v35;
            (*(void (**)(uint64_t, void **, void *))(*(void *)v28 + 192))(v28, __p, v47);
            if (v48 == v47)
            {
              (*(void (**)(void *))(v47[0] + 32))(v47);
            }
            else if (v48)
            {
              (*(void (**)(void *))(*v48 + 40))(v48);
            }
            if (v33) {
              std::__shared_weak_count::__release_weak(v33);
            }
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
LABEL_83:
            xpc_release(v14);
            int v10 = v39;
            if (!v39) {
              return;
            }
            goto LABEL_84;
          }
          CFStringRef v26 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1A609F000, v26, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
          }
          xpc_object_t v21 = xpc_null_create();
          if (*(void *)a4) {
            CFStringRef v27 = _Block_copy(*(const void **)a4);
          }
          else {
            CFStringRef v27 = 0;
          }
          xpc_object_t v30 = *(NSObject **)(a4 + 8);
          *(void *)std::string buf = MEMORY[0x1E4F143A8];
          uint64_t v41 = 3321888768;
          std::string v42 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
          int v43 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
          if (v27) {
            xpc_object_t v31 = _Block_copy(v27);
          }
          else {
            xpc_object_t v31 = 0;
          }
          int v46 = 0;
          aBlocuint64_t k = v31;
          xpc_object_t object = v21;
          if (v21) {
            xpc_retain(v21);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          dispatch_async(v30, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v27) {
            _Block_release(v27);
          }
LABEL_46:
          xpc_release(v21);
          goto LABEL_83;
        }
        xpc_object_t v20 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl(&dword_1A609F000, v20, OS_LOG_TYPE_ERROR, "Failed to create output dictionary", buf, 2u);
        }
        xpc_object_t v21 = xpc_null_create();
        if (*(void *)a4) {
          xpc_object_t v22 = _Block_copy(*(const void **)a4);
        }
        else {
          xpc_object_t v22 = 0;
        }
        xpc_object_t v24 = *(NSObject **)(a4 + 8);
        *(void *)std::string buf = MEMORY[0x1E4F143A8];
        uint64_t v41 = 3321888768;
        std::string v42 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        int v43 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v22)
        {
          CFStringRef v25 = _Block_copy(v22);
          int v46 = -534716416;
          aBlocuint64_t k = v25;
          xpc_object_t object = v21;
          if (v21)
          {
LABEL_39:
            xpc_retain(v21);
LABEL_42:
            dispatch_async(v24, buf);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v22) {
              _Block_release(v22);
            }
            goto LABEL_46;
          }
        }
        else
        {
          int v46 = -534716416;
          aBlocuint64_t k = 0;
          xpc_object_t object = v21;
          if (v21) {
            goto LABEL_39;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_42;
      }
      xpc_object_t v15 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object has not been created", buf, 2u);
      }
      xpc_object_t v16 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v17 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v17 = 0;
      }
      std::string::size_type v18 = *(NSObject **)(a4 + 8);
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v41 = 3321888768;
      std::string v42 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      int v43 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        std::string::size_type v19 = _Block_copy(v17);
        int v46 = -534716414;
        aBlocuint64_t k = v19;
        xpc_object_t object = v16;
        if (v16)
        {
LABEL_19:
          xpc_retain(v16);
LABEL_22:
          dispatch_async(v18, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v17) {
            _Block_release(v17);
          }
          xpc_release(v16);
          goto LABEL_84;
        }
      }
      else
      {
        int v46 = -534716414;
        aBlocuint64_t k = 0;
        xpc_object_t object = v16;
        if (v16) {
          goto LABEL_19;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_22;
    }
  }
}

void sub_1A6162F74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t _ZZZN3abm19CellularLoggingTask9init_syncEvEUb1_EN3__3D1Ev(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (v3) {
    dispatch_release(v3);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFBundle>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFURL const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A616319C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEED1Ev(void *a1)
{
  *a1 = &unk_1EFB0C940;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)a1[1];
  if (v4) {
    _Block_release(v4);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEED0Ev(void *__p)
{
  *std::string __p = &unk_1EFB0C940;
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = __p[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)__p[1];
  if (v4) {
    _Block_release(v4);
  }

  operator delete(__p);
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEv(void *a1)
{
  uint64_t v2 = operator new(0x30uLL);
  *uint64_t v2 = &unk_1EFB0C940;
  uint64_t v3 = (void *)a1[1];
  if (v3) {
    uint64_t v3 = _Block_copy(v3);
  }
  int v4 = a1[2];
  v2[1] = v3;
  v2[2] = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  uint64_t v5 = a1[4];
  v2[3] = a1[3];
  v2[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  void v2[5] = a1[5];
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEPNS0_6__baseIS9_EE(void *a1, void *a2)
{
  *a2 = &unk_1EFB0C940;
  int v4 = (void *)a1[1];
  if (v4) {
    int v4 = _Block_copy(v4);
  }
  uint64_t v5 = a1[2];
  a2[1] = v4;
  a2[2] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  uint64_t v6 = a1[4];
  a2[3] = a1[3];
  a2[4] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  a2[5] = a1[5];
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE7destroyEv(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)a1[1];
  if (v4) {
    _Block_release(v4);
  }
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE18destroy_deallocateEv(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = __p[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)__p[1];
  if (v4) {
    _Block_release(v4);
  }

  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEEclEObOS8_(void *a1, unsigned __int8 *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  uint64_t v6 = (std::__shared_weak_count *)a1[4];
  if (!v6) {
    goto LABEL_39;
  }
  uint64_t v7 = a1[5];
  uint64_t v8 = std::__shared_weak_count::lock(v6);
  if (!v8) {
    goto LABEL_39;
  }
  size_t v9 = v8;
  if (a1[3])
  {
    if (v4) {
      goto LABEL_22;
    }
    int v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to stop log collection", (uint8_t *)&v21, 2u);
      if (v5)
      {
LABEL_7:
        xpc_retain(v5);
        xpc_object_t v11 = v5;
        xpc_object_t v12 = (const void *)a1[1];
        if (v12)
        {
LABEL_8:
          uint64_t v13 = _Block_copy(v12);
          goto LABEL_12;
        }
LABEL_11:
        uint64_t v13 = 0;
LABEL_12:
        xpc_object_t v14 = a1[2];
        uint64_t v21 = MEMORY[0x1E4F143A8];
        uint64_t v22 = 3321888768;
        xpc_object_t v23 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        xpc_object_t v24 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v13)
        {
          xpc_object_t v15 = _Block_copy(v13);
          int v27 = -534716416;
          aBlocuint64_t k = v15;
          xpc_object_t object = v11;
          if (v11)
          {
LABEL_14:
            xpc_retain(v11);
LABEL_17:
            dispatch_async(v14, &v21);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v13) {
              _Block_release(v13);
            }
            xpc_release(v11);
LABEL_22:
            if (v5)
            {
              xpc_retain(v5);
              xpc_object_t v16 = v5;
              uint64_t v17 = (const void *)a1[1];
              if (v17)
              {
LABEL_24:
                std::string::size_type v18 = _Block_copy(v17);
                goto LABEL_27;
              }
            }
            else
            {
              xpc_object_t v16 = xpc_null_create();
              uint64_t v17 = (const void *)a1[1];
              if (v17) {
                goto LABEL_24;
              }
            }
            std::string::size_type v18 = 0;
LABEL_27:
            std::string::size_type v19 = a1[2];
            uint64_t v21 = MEMORY[0x1E4F143A8];
            uint64_t v22 = 3321888768;
            xpc_object_t v23 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            xpc_object_t v24 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v18)
            {
              xpc_object_t v20 = _Block_copy(v18);
              int v27 = 0;
              aBlocuint64_t k = v20;
              xpc_object_t object = v16;
              if (v16)
              {
LABEL_29:
                xpc_retain(v16);
LABEL_32:
                dispatch_async(v19, &v21);
                xpc_release(object);
                xpc_object_t object = 0;
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v18) {
                  _Block_release(v18);
                }
                xpc_release(v16);
                goto LABEL_37;
              }
            }
            else
            {
              int v27 = 0;
              aBlocuint64_t k = 0;
              xpc_object_t object = v16;
              if (v16) {
                goto LABEL_29;
              }
            }
            xpc_object_t object = xpc_null_create();
            goto LABEL_32;
          }
        }
        else
        {
          int v27 = -534716416;
          aBlocuint64_t k = 0;
          xpc_object_t object = v11;
          if (v11) {
            goto LABEL_14;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_17;
      }
    }
    else if (v5)
    {
      goto LABEL_7;
    }
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v12 = (const void *)a1[1];
    if (v12) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }
LABEL_37:
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_39:
  xpc_release(v5);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb_E3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1NS_9allocatorIS4_EEFvbN3xpc4dictEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb_E3__1;
}

void *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEED1Ev(void *a1)
{
  *a1 = &unk_1EFB0C9D0;
  uint64_t v2 = a1[3];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = (const void *)a1[2];
  if (v3) {
    _Block_release(v3);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEED0Ev(void *__p)
{
  *std::string __p = &unk_1EFB0C9D0;
  uint64_t v2 = __p[3];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = (const void *)__p[2];
  if (v3) {
    _Block_release(v3);
  }

  operator delete(__p);
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7__cloneEv(void *a1)
{
  uint64_t v2 = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  unint64_t v3 = (void *)a1[2];
  *uint64_t v2 = &unk_1EFB0C9D0;
  v2[1] = v4;
  if (v3) {
    unint64_t v3 = _Block_copy(v3);
  }
  uint64_t v5 = a1[3];
  v2[2] = v3;
  v2[3] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7__cloneEPNS0_6__baseISD_EE(void *a1, void *a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = (void *)a1[2];
  *a2 = &unk_1EFB0C9D0;
  a2[1] = v5;
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  uint64_t v6 = a1[3];
  a2[2] = v4;
  a2[3] = v6;
  if (v6)
  {
    dispatch_retain(v6);
  }
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE7destroyEv(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    _Block_release(v3);
  }
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE18destroy_deallocateEv(void *__p)
{
  uint64_t v2 = __p[3];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = (const void *)__p[2];
  if (v3) {
    _Block_release(v3);
  }

  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEEclEOSB_OSC_(void *a1, uint64_t a2, int *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v22 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  int v4 = *a3;
  uint64_t v5 = (void *)a1[1];
  uint64_t v6 = v5[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I App state: %d", buf, 8u);
  }
  if (v4 == 1)
  {
    uint64_t v7 = v5[23];
    if (v7)
    {
      (*(void (**)(uint64_t, void **))(*(void *)v7 + 184))(v7, __p);
      uint64_t v8 = (void *)v5[21];
      if (v8)
      {
        *(void *)std::string buf = *v8;
        ctu::SharedSynchronizable<abm::AppMonitorInternal>::execute_wrapped<abm::AppMonitorInternal::stop(void)::{lambda(void)#1}>(*(uint64_t **)buf, buf);
        goto LABEL_37;
      }
      uint64_t v13 = v5[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1A609F000, v13, OS_LOG_TYPE_ERROR, "AppMonitor object doesn't exist!", buf, 2u);
      }
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v15 = (const void *)a1[2];
      if (v15) {
        xpc_object_t v16 = _Block_copy(v15);
      }
      else {
        xpc_object_t v16 = 0;
      }
      std::string::size_type v19 = a1[3];
      *(void *)std::string buf = MEMORY[0x1E4F143A8];
      uint64_t v24 = 3321888768;
      CFStringRef v25 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
      CFStringRef v26 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v16)
      {
        xpc_object_t v20 = _Block_copy(v16);
        int v29 = -534716416;
        aBlocuint64_t k = v20;
        xpc_object_t object = v14;
        if (v14)
        {
LABEL_29:
          xpc_retain(v14);
LABEL_32:
          dispatch_async(v19, buf);
          xpc_release(object);
          xpc_object_t object = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v16) {
            _Block_release(v16);
          }
          xpc_release(v14);
          goto LABEL_37;
        }
      }
      else
      {
        int v29 = -534716416;
        aBlocuint64_t k = 0;
        xpc_object_t object = v14;
        if (v14) {
          goto LABEL_29;
        }
      }
      xpc_object_t object = xpc_null_create();
      goto LABEL_32;
    }
    size_t v9 = v5[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "CellularLoggingCommon object doesn't exist!", buf, 2u);
    }
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v11 = (const void *)a1[2];
    if (v11) {
      xpc_object_t v12 = _Block_copy(v11);
    }
    else {
      xpc_object_t v12 = 0;
    }
    uint64_t v17 = a1[3];
    *(void *)std::string buf = MEMORY[0x1E4F143A8];
    uint64_t v24 = 3321888768;
    CFStringRef v25 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
    CFStringRef v26 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v12)
    {
      std::string::size_type v18 = _Block_copy(v12);
      int v29 = -534716416;
      aBlocuint64_t k = v18;
      xpc_object_t object = v10;
      if (v10)
      {
LABEL_18:
        xpc_retain(v10);
LABEL_21:
        dispatch_async(v17, buf);
        xpc_release(object);
        xpc_object_t object = 0;
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v12) {
          _Block_release(v12);
        }
        xpc_release(v10);
        goto LABEL_37;
      }
    }
    else
    {
      int v29 = -534716416;
      aBlocuint64_t k = 0;
      xpc_object_t object = v10;
      if (v10) {
        goto LABEL_18;
      }
    }
    xpc_object_t object = xpc_null_create();
    goto LABEL_21;
  }
LABEL_37:
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A6163DC4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void sub_1A6163E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A6163E08);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2NS_9allocatorIS4_EEFvNS_12basic_stringIcNS_11char_traitsIcEENS5_IcEEEENS2_8AppStateEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb0_E3__2;
}

void *_ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEED1Ev(void *a1)
{
  *a1 = &unk_1EFB0CA50;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)a1[1];
  if (v4) {
    _Block_release(v4);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEED0Ev(void *__p)
{
  *std::string __p = &unk_1EFB0CA50;
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = __p[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)__p[1];
  if (v4) {
    _Block_release(v4);
  }

  operator delete(__p);
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEv(void *a1)
{
  uint64_t v2 = operator new(0x30uLL);
  *uint64_t v2 = &unk_1EFB0CA50;
  unint64_t v3 = (void *)a1[1];
  if (v3) {
    unint64_t v3 = _Block_copy(v3);
  }
  int v4 = a1[2];
  v2[1] = v3;
  v2[2] = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  uint64_t v5 = a1[4];
  v2[3] = a1[3];
  v2[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  void v2[5] = a1[5];
  return v2;
}

void _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7__cloneEPNS0_6__baseIS9_EE(void *a1, void *a2)
{
  *a2 = &unk_1EFB0CA50;
  int v4 = (void *)a1[1];
  if (v4) {
    int v4 = _Block_copy(v4);
  }
  uint64_t v5 = a1[2];
  a2[1] = v4;
  a2[2] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  uint64_t v6 = a1[4];
  a2[3] = a1[3];
  a2[4] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  a2[5] = a1[5];
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE7destroyEv(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)a1[1];
  if (v4) {
    _Block_release(v4);
  }
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE18destroy_deallocateEv(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = __p[2];
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = (const void *)__p[1];
  if (v4) {
    _Block_release(v4);
  }

  operator delete(__p);
}

void _ZNSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEEclEObOS8_(void *a1, unsigned __int8 *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = *a3;
  *a3 = xpc_null_create();
  uint64_t v6 = (std::__shared_weak_count *)a1[4];
  if (!v6) {
    goto LABEL_39;
  }
  uint64_t v7 = a1[5];
  uint64_t v8 = std::__shared_weak_count::lock(v6);
  if (!v8) {
    goto LABEL_39;
  }
  size_t v9 = v8;
  if (a1[3])
  {
    if (v4) {
      goto LABEL_22;
    }
    xpc_object_t v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to snapshot", (uint8_t *)&v21, 2u);
      if (v5)
      {
LABEL_7:
        xpc_retain(v5);
        xpc_object_t v11 = v5;
        xpc_object_t v12 = (const void *)a1[1];
        if (v12)
        {
LABEL_8:
          uint64_t v13 = _Block_copy(v12);
          goto LABEL_12;
        }
LABEL_11:
        uint64_t v13 = 0;
LABEL_12:
        xpc_object_t v14 = a1[2];
        uint64_t v21 = MEMORY[0x1E4F143A8];
        uint64_t v22 = 3321888768;
        xpc_object_t v23 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
        uint64_t v24 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v13)
        {
          xpc_object_t v15 = _Block_copy(v13);
          int v27 = -534716416;
          aBlocuint64_t k = v15;
          xpc_object_t object = v11;
          if (v11)
          {
LABEL_14:
            xpc_retain(v11);
LABEL_17:
            dispatch_async(v14, &v21);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v13) {
              _Block_release(v13);
            }
            xpc_release(v11);
LABEL_22:
            if (v5)
            {
              xpc_retain(v5);
              xpc_object_t v16 = v5;
              uint64_t v17 = (const void *)a1[1];
              if (v17)
              {
LABEL_24:
                std::string::size_type v18 = _Block_copy(v17);
                goto LABEL_27;
              }
            }
            else
            {
              xpc_object_t v16 = xpc_null_create();
              uint64_t v17 = (const void *)a1[1];
              if (v17) {
                goto LABEL_24;
              }
            }
            std::string::size_type v18 = 0;
LABEL_27:
            std::string::size_type v19 = a1[2];
            uint64_t v21 = MEMORY[0x1E4F143A8];
            uint64_t v22 = 3321888768;
            xpc_object_t v23 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_0;
            uint64_t v24 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
            if (v18)
            {
              xpc_object_t v20 = _Block_copy(v18);
              int v27 = 0;
              aBlocuint64_t k = v20;
              xpc_object_t object = v16;
              if (v16)
              {
LABEL_29:
                xpc_retain(v16);
LABEL_32:
                dispatch_async(v19, &v21);
                xpc_release(object);
                xpc_object_t object = 0;
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v18) {
                  _Block_release(v18);
                }
                xpc_release(v16);
                goto LABEL_37;
              }
            }
            else
            {
              int v27 = 0;
              aBlocuint64_t k = 0;
              xpc_object_t object = v16;
              if (v16) {
                goto LABEL_29;
              }
            }
            xpc_object_t object = xpc_null_create();
            goto LABEL_32;
          }
        }
        else
        {
          int v27 = -534716416;
          aBlocuint64_t k = 0;
          xpc_object_t object = v11;
          if (v11) {
            goto LABEL_14;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_17;
      }
    }
    else if (v5)
    {
      goto LABEL_7;
    }
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v12 = (const void *)a1[1];
    if (v12) {
      goto LABEL_8;
    }
    goto LABEL_11;
  }
LABEL_37:
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_39:
  xpc_release(v5);
}

uint64_t _ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3$_3" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3NS_9allocatorIS4_EEFvbN3xpc4dictEEE11target_typeEv()
{
  return &_ZTIZZN3abm19CellularLoggingTask9init_syncEvEUb1_E3__3;
}

uint64_t _GLOBAL__sub_I_CellularLoggingTask_mm()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  dword_1EB5EEA84 = result;
  return result;
}

void abm::helper::getUserConfig(int a1@<W0>, xpc_object_t *a2@<X8>)
{
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v4 = xpc_null_create();
  *a2 = v4;
  uint64_t v5 = MEMORY[0x1E4F14590];
  if (a1 == 501)
  {
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    if (v8 || (xpc_object_t v8 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v8) == v5)
      {
        xpc_retain(v8);
        xpc_object_t v9 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
    }
    xpc_release(v8);
    xpc_object_t v19 = xpc_null_create();
    xpc_object_t v20 = *a2;
    *a2 = v9;
    xpc_release(v20);
    xpc_release(v19);
    xpc_object_t v21 = xpc_string_create("CommCenterMobileHelper");
    if (!v21) {
      xpc_object_t v21 = xpc_null_create();
    }
    xpc_dictionary_set_value(v9, (const char *)*MEMORY[0x1E4FAE028], v21);
    xpc_object_t v22 = xpc_null_create();
    xpc_release(v21);
    xpc_release(v22);
    xpc_object_t v23 = xpc_string_create("com.apple.abm.helper.mobile");
    if (!v23) {
      xpc_object_t v23 = xpc_null_create();
    }
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E4FAE030], v23);
    xpc_object_t v24 = xpc_null_create();
    xpc_release(v23);
    xpc_release(v24);
    xpc_object_t v25 = xpc_array_create(0, 0);
    if (v25 || (xpc_object_t v25 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v25) == MEMORY[0x1E4F14568])
      {
        xpc_retain(v25);
        xpc_object_t v26 = v25;
      }
      else
      {
        xpc_object_t v26 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v26 = xpc_null_create();
      xpc_object_t v25 = 0;
    }
    xpc_release(v25);
    xpc_object_t v34 = xpc_string_create("com.apple.abm.helper.mobile.allow");
    if (!v34) {
      xpc_object_t v34 = xpc_null_create();
    }
    xpc_array_append_value(v26, v34);
    xpc_release(v34);
    xpc_object_t v35 = xpc_string_create("com.apple.developer.cellular-logging.allow");
    if (!v35) {
      xpc_object_t v35 = xpc_null_create();
    }
    xpc_array_append_value(v26, v35);
    xpc_release(v35);
    xpc_object_t v36 = xpc_string_create("com.apple.cellular-logging.internal");
    if (!v36) {
      xpc_object_t v36 = xpc_null_create();
    }
    xpc_array_append_value(v26, v36);
    xpc_release(v36);
    if (v26)
    {
      xpc_retain(v26);
      xpc_object_t v37 = v26;
    }
    else
    {
      xpc_object_t v37 = xpc_null_create();
    }
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E4FAE038], v37);
    xpc_object_t v38 = xpc_null_create();
    xpc_release(v37);
    xpc_release(v38);
    char v53 = 20;
    strcpy(__p, "ABMMobileHelperReady");
    xpc_object_t v39 = xpc_string_create(__p);
    if (!v39) {
      xpc_object_t v39 = xpc_null_create();
    }
    xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E4FAE040], v39);
    xpc_object_t v40 = xpc_null_create();
    xpc_release(v39);
    xpc_release(v40);
    if (v53 < 0) {
      operator delete(*(void **)__p);
    }
    xpc_release(v26);
    xpc_object_t v4 = *a2;
  }
  else
  {
    if (a1 == 25)
    {
      xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
      if (v10 || (xpc_object_t v10 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A6275E60](v10) == v5)
        {
          xpc_retain(v10);
          xpc_object_t v11 = v10;
        }
        else
        {
          xpc_object_t v11 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v11 = xpc_null_create();
        xpc_object_t v10 = 0;
      }
      xpc_release(v10);
      xpc_object_t v27 = xpc_null_create();
      xpc_object_t v28 = *a2;
      *a2 = v11;
      xpc_release(v28);
      xpc_release(v27);
      xpc_object_t v29 = xpc_string_create("abm-helper");
      if (!v29) {
        xpc_object_t v29 = xpc_null_create();
      }
      xpc_dictionary_set_value(v11, (const char *)*MEMORY[0x1E4FAE028], v29);
      xpc_object_t v30 = xpc_null_create();
      xpc_release(v29);
      xpc_release(v30);
      xpc_object_t v31 = xpc_string_create("com.apple.abm.helper.wireless");
      if (!v31) {
        xpc_object_t v31 = xpc_null_create();
      }
      xpc_object_t v4 = *a2;
      xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E4FAE030], v31);
      xpc_object_t v32 = xpc_null_create();
      xpc_release(v31);
      xpc_release(v32);
      strcpy(__p, "ABMWirelessHelperReady");
      char v53 = 22;
      xpc_object_t v18 = xpc_string_create(__p);
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
    }
    else
    {
      if (a1) {
        goto LABEL_61;
      }
      xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
      if (v6 || (xpc_object_t v6 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A6275E60](v6) == v5)
        {
          xpc_retain(v6);
          xpc_object_t v7 = v6;
        }
        else
        {
          xpc_object_t v7 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v7 = xpc_null_create();
        xpc_object_t v6 = 0;
      }
      xpc_release(v6);
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v13 = *a2;
      *a2 = v7;
      xpc_release(v13);
      xpc_release(v12);
      xpc_object_t v14 = xpc_string_create("CommCenterRootHelper");
      if (!v14) {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_dictionary_set_value(v7, (const char *)*MEMORY[0x1E4FAE028], v14);
      xpc_object_t v15 = xpc_null_create();
      xpc_release(v14);
      xpc_release(v15);
      xpc_object_t v16 = xpc_string_create("com.apple.abm.helper.root");
      if (!v16) {
        xpc_object_t v16 = xpc_null_create();
      }
      xpc_object_t v4 = *a2;
      xpc_dictionary_set_value(*a2, (const char *)*MEMORY[0x1E4FAE030], v16);
      xpc_object_t v17 = xpc_null_create();
      xpc_release(v16);
      xpc_release(v17);
      char v53 = 18;
      strcpy(__p, "ABMRootHelperReady");
      xpc_object_t v18 = xpc_string_create(__p);
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
    }
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E4FAE040], v18);
    xpc_object_t v33 = xpc_null_create();
    xpc_release(v18);
    xpc_release(v33);
    if (v53 < 0) {
      operator delete(*(void **)__p);
    }
  }
LABEL_61:
  if (MEMORY[0x1A6275E60](v4) == v5)
  {
    xpc_object_t v41 = xpc_int64_create(a1);
    if (!v41) {
      xpc_object_t v41 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, "UserID", v41);
    xpc_object_t v42 = xpc_null_create();
    xpc_release(v41);
    xpc_release(v42);
    if (a1)
    {
      if (a1 == 501)
      {
        int v43 = "mobile";
      }
      else if (a1 == 25)
      {
        int v43 = "wireless";
      }
      else
      {
        int v43 = "";
      }
    }
    else
    {
      int v43 = "root";
    }
    xpc_object_t v44 = xpc_string_create(v43);
    if (!v44) {
      xpc_object_t v44 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, "UserName", v44);
    xpc_object_t v45 = xpc_null_create();
    xpc_release(v44);
    xpc_release(v45);
    xpc_object_t v46 = xpc_BOOL_create(0);
    if (!v46) {
      xpc_object_t v46 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E4FAE048], v46);
    xpc_object_t v47 = xpc_null_create();
    xpc_release(v46);
    xpc_release(v47);
    xpc_object_t v48 = xpc_BOOL_create(0);
    if (!v48) {
      xpc_object_t v48 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E4FAE050], v48);
    xpc_object_t v49 = xpc_null_create();
    xpc_release(v48);
    xpc_release(v49);
    xpc_object_t v50 = xpc_string_create("unknown");
    if (!v50) {
      xpc_object_t v50 = xpc_null_create();
    }
    xpc_dictionary_set_value(v4, (const char *)*MEMORY[0x1E4FAE020], v50);
    xpc_object_t v51 = xpc_null_create();
    xpc_release(v50);
    xpc_release(v51);
  }
}

void sub_1A6164DC4(_Unwind_Exception *a1)
{
  xpc_release(v3);
  xpc_release(v2);
  xpc::dict::~dict(v1);
  _Unwind_Resume(a1);
}

uint64_t abm::helper::getDaemonNotificationName@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  if (result == 501)
  {
    a2[23] = 20;
    strcpy(a2, "ABMMobileHelperReady");
  }
  else if (result == 25)
  {
    strcpy(a2, "ABMWirelessHelperReady");
    a2[23] = 22;
  }
  else if (result)
  {
    a2[23] = 0;
    *a2 = 0;
  }
  else
  {
    a2[23] = 18;
    strcpy(a2, "ABMRootHelperReady");
  }
  return result;
}

uint64_t abm::helper::getUserForTask(int a1)
{
  if ((a1 - 1) > 9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return dword_1A61F9C7C[a1 - 1];
  }
}

void abm::helper::getTasksForUser(int a1@<W0>, char **a2@<X8>)
{
  xpc_object_t v4 = 0;
  uint64_t v5 = 0;
  xpc_object_t v6 = 0;
  int v7 = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  do
  {
    uint64_t v9 = v7 - 1;
    if (v9 > 9)
    {
      if (a1 == -1)
      {
LABEL_9:
        if (v6 < v5)
        {
          *(_DWORD *)xpc_object_t v6 = v7;
          uint64_t v8 = (uint64_t)(v6 + 4);
        }
        else
        {
          uint64_t v10 = (v6 - v4) >> 2;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 62) {
            std::vector<abm::helper::TaskID>::__throw_length_error[abi:ne180100]();
          }
          if ((v5 - v4) >> 1 > v11) {
            unint64_t v11 = (v5 - v4) >> 1;
          }
          if ((unint64_t)(v5 - v4) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v11;
          }
          if (v12)
          {
            if (v12 >> 62) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            xpc_object_t v13 = operator new(4 * v12);
            xpc_object_t v14 = &v13[4 * v10];
            *(_DWORD *)xpc_object_t v14 = v7;
            uint64_t v8 = (uint64_t)(v14 + 4);
            int64_t v15 = v6 - v4;
            if (v6 == v4) {
              goto LABEL_24;
            }
          }
          else
          {
            xpc_object_t v13 = 0;
            xpc_object_t v14 = (char *)(4 * v10);
            *(_DWORD *)(4 * v10) = v7;
            uint64_t v8 = 4 * v10 + 4;
            int64_t v15 = v6 - v4;
            if (v6 == v4) {
              goto LABEL_24;
            }
          }
          unint64_t v16 = v15 - 4;
          if (v16 >= 0xBC)
          {
            unint64_t v19 = (v6 - 4 - v4) & 0xFFFFFFFFFFFFFFFCLL;
            if (&v13[v6 - v4 - 4 - v19] > &v13[v6 - v4 - 4])
            {
              xpc_object_t v17 = v6;
            }
            else if (&v6[-v19 - 4] > v6 - 4)
            {
              xpc_object_t v17 = v6;
            }
            else if ((unint64_t)(v4 - v13) >= 0x20)
            {
              uint64_t v20 = (v16 >> 2) + 1;
              uint64_t v21 = 4 * (v20 & 0x7FFFFFFFFFFFFFF8);
              xpc_object_t v17 = &v6[-v21];
              v14 -= v21;
              xpc_object_t v22 = &v13[4 * v10 - 16];
              xpc_object_t v23 = v6 - 16;
              uint64_t v24 = v20 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v25 = *(_OWORD *)v23;
                *(v22 - 1) = *((_OWORD *)v23 - 1);
                *xpc_object_t v22 = v25;
                v22 -= 2;
                v23 -= 32;
                v24 -= 8;
              }
              while (v24);
              if (v20 == (v20 & 0x7FFFFFFFFFFFFFF8)) {
                goto LABEL_24;
              }
            }
            else
            {
              xpc_object_t v17 = v6;
            }
          }
          else
          {
            xpc_object_t v17 = v6;
          }
          do
          {
            int v18 = *((_DWORD *)v17 - 1);
            v17 -= 4;
            *((_DWORD *)v14 - 1) = v18;
            v14 -= 4;
          }
          while (v17 != v4);
LABEL_24:
          uint64_t v5 = &v13[4 * v12];
          *a2 = v14;
          a2[1] = (char *)v8;
          a2[2] = v5;
          if (v4) {
            operator delete(v4);
          }
          xpc_object_t v4 = v14;
        }
        a2[1] = (char *)v8;
        xpc_object_t v6 = (char *)v8;
      }
    }
    else if (dword_1A61F9C7C[v9] == a1)
    {
      goto LABEL_9;
    }
    ++v7;
  }
  while (v7 != 11);
}

void sub_1A6165278(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::helper::getLoggingDomain@<X0>(int a1@<W0>, unsigned char *a2@<X8>)
{
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[7] = v4;
  v25[8] = v4;
  void v25[5] = v4;
  v25[6] = v4;
  v25[3] = v4;
  v25[4] = v4;
  v25[1] = v4;
  void v25[2] = v4;
  long long v24 = v4;
  v25[0] = v4;
  *(_OWORD *)std::string __p = v4;
  long long v23 = v4;
  long long v20 = v4;
  *(_OWORD *)stat __src = v4;
  long long v18 = v4;
  long long v19 = v4;
  long long v17 = v4;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v17);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"com.apple.abm.helper", 20);
  xpc_object_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)".", 1);
  if ((a1 - 1) > 9) {
    int v7 = "";
  }
  else {
    int v7 = (&off_1E5C47BE8)[a1 - 1];
  }
  size_t v8 = strlen(v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)v7, v8);
  if ((BYTE8(v24) & 0x10) != 0)
  {
    uint64_t v10 = (unsigned char *)v24;
    if ((void *)v24 < __src[1])
    {
      *(void **)&long long v24 = __src[1];
      uint64_t v10 = __src[1];
    }
    unint64_t v11 = __src[0];
    size_t v9 = v10 - (char *)__src[0];
    if ((unint64_t)(v10 - (char *)__src[0]) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_21;
    }
  }
  else
  {
    if ((BYTE8(v24) & 8) == 0)
    {
      size_t v9 = 0;
      a2[23] = 0;
      goto LABEL_17;
    }
    unint64_t v11 = (const void *)*((void *)&v19 + 1);
    size_t v9 = *((void *)&v20 + 1) - *((void *)&v19 + 1);
    if (*((void *)&v20 + 1) - *((void *)&v19 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_21:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    xpc_object_t v14 = operator new(v12 + 1);
    *((void *)a2 + 1) = v9;
    *((void *)a2 + 2) = v13 | 0x8000000000000000;
    *(void *)a2 = v14;
    a2 = v14;
    goto LABEL_16;
  }
  a2[23] = v9;
  if (v9) {
LABEL_16:
  }
    memmove(a2, v11, v9);
LABEL_17:
  a2[v9] = 0;
  *(void *)&long long v17 = *MEMORY[0x1E4FBA408];
  uint64_t v15 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v17 + *(void *)(v17 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v18 = v15;
  *((void *)&v18 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v25);
}

void sub_1A6165550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *abm::helper::DaemonObserver::DaemonObserver(void *a1, int a2, uint64_t a3)
{
  a1[2] = 0;
  xpc_object_t v6 = (const void **)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  int v7 = *(void **)a3;
  if (*(void *)a3) {
    int v7 = _Block_copy(v7);
  }
  a1[3] = v7;
  size_t v8 = *(NSObject **)(a3 + 8);
  a1[4] = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  a1[5] = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a2 == 501)
  {
    char v14 = 20;
    strcpy(__p, "ABMMobileHelperReady");
  }
  else if (a2 == 25)
  {
    strcpy(__p, "ABMWirelessHelperReady");
    char v14 = 22;
  }
  else if (a2)
  {
    char v14 = 0;
    __p[0] = 0;
  }
  else
  {
    char v14 = 18;
    strcpy(__p, "ABMRootHelperReady");
  }
  CFStringRef v10 = CFStringCreateWithCString(v9, __p, 0x600u);
  unint64_t v11 = *v6;
  void *v6 = v10;
  if (v11) {
    CFRelease(v11);
  }
  if (v14 < 0) {
    operator delete(*(void **)__p);
  }
  return a1;
}

void sub_1A61656C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(v16);
    ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(v15);
    long long v18 = *(std::__shared_weak_count **)(v14 + 8);
    if (!v18) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(v16);
    ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(v15);
    long long v18 = *(std::__shared_weak_count **)(v14 + 8);
    if (!v18) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v18);
  _Unwind_Resume(a1);
}

uint64_t dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

void abm::helper::DaemonObserver::~DaemonObserver(abm::helper::DaemonObserver *this)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, *((const void **)this + 5), *((CFNotificationName *)this + 2), 0);
  unint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    long long v4 = (std::__shared_weak_count *)v3[1];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
    *((void *)this + 5) = 0;
  }
  uint64_t v5 = *((void *)this + 4);
  if (v5) {
    dispatch_release(v5);
  }
  xpc_object_t v6 = (const void *)*((void *)this + 3);
  if (v6) {
    _Block_release(v6);
  }
  int v7 = (const void *)*((void *)this + 2);
  if (v7) {
    CFRelease(v7);
  }
  size_t v8 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void abm::helper::DaemonObserver::init(abm::helper::DaemonObserver *this)
{
  uint64_t v2 = operator new(0x10uLL);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
  if (!v3 || (uint64_t v4 = *(void *)this, (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  xpc_object_t v6 = v5;
  *uint64_t v2 = v4;
  v2[1] = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *((void *)this + 5) = v2;
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v6);
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  size_t v8 = (const void *)*((void *)this + 5);
  CFStringRef v9 = (const __CFString *)*((void *)this + 2);

  CFNotificationCenterAddObserver(DarwinNotifyCenter, v8, (CFNotificationCallback)abm::helper::DaemonObserver::handleDaemonReadyNotificationStatic, v9, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

void sub_1A61658D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void abm::helper::DaemonObserver::handleDaemonReadyNotificationStatic(abm::helper::DaemonObserver *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  if (a2)
  {
    int v7 = (std::__shared_weak_count *)*((void *)a2 + 1);
    if (v7)
    {
      size_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        CFStringRef v9 = v8;
        if (*(void *)a2) {
          abm::helper::DaemonObserver::handleDaemonReady(*(abm::helper::DaemonObserver **)a2);
        }
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
  }
}

void abm::helper::DaemonObserver::handleDaemonReady(abm::helper::DaemonObserver *this)
{
  if (!*((void *)this + 3) || !*((void *)this + 4)) {
    return;
  }
  xpc_object_t v2 = xpc_null_create();
  unint64_t v3 = (const void *)*((void *)this + 3);
  if (v3) {
    uint64_t v4 = _Block_copy(v3);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *((void *)this + 4);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 1174405120;
  _OWORD v8[2] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke;
  v8[3] = &__block_descriptor_tmp_23;
  if (v4) {
    xpc_object_t v6 = _Block_copy(v4);
  }
  else {
    xpc_object_t v6 = 0;
  }
  aBlocuint64_t k = v6;
  int v10 = -534716411;
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  dispatch_async(v5, v8);
  xpc_release(object);
  xpc_object_t object = 0;
  if ((SHIBYTE(v13) & 0x80000000) == 0)
  {
    int v7 = aBlock;
    if (!aBlock) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  operator delete(__p);
  int v7 = aBlock;
  if (aBlock) {
LABEL_16:
  }
    _Block_release(v7);
LABEL_17:
  if (v4) {
    _Block_release(v4);
  }
  xpc_release(v2);
}

void std::vector<abm::helper::TaskID>::__throw_length_error[abi:ne180100]()
{
}

void ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke(uint64_t a1)
{
}

void dispatch::block<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::operator()<TelephonyXPC::Result const&,xpc::dict const&>(uint64_t *a1, int *a2, void **a3)
{
  uint64_t v4 = *a1;
  int v7 = *a2;
  if (*((char *)a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)a2 + 1), *((void *)a2 + 2));
    uint64_t v5 = *a3;
    xpc_object_t object = v5;
    if (v5) {
      goto LABEL_3;
    }
  }
  else
  {
    std::string __p = *(std::string *)(a2 + 2);
    uint64_t v5 = *a3;
    xpc_object_t object = v5;
    if (v5)
    {
LABEL_3:
      xpc_retain(v5);
      goto LABEL_6;
    }
  }
  xpc_object_t object = xpc_null_create();
LABEL_6:
  (*(void (**)(uint64_t, int *, xpc_object_t *))(v4 + 16))(v4, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1A6165BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

xpc_object_t __copy_helper_block_e8_32c76_ZTSN8dispatch5blockIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE40c27_ZTSN12TelephonyXPC6ResultE72c15_ZTSN3xpc4dictE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 32);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  uint64_t v5 = (std::string *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  int v7 = *(void **)(a2 + 72);
  *(void *)(a1 + 72) = v7;
  if (v7) {
    return xpc_retain(v7);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 72) = result;
  return result;
}

void sub_1A6165CA0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(const void **)(v1 + 32);
  if (v3) {
    _Block_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c76_ZTSN8dispatch5blockIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE40c27_ZTSN12TelephonyXPC6ResultE72c15_ZTSN3xpc4dictE(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;
  if (*(char *)(a1 + 71) < 0)
  {
    operator delete(*(void **)(a1 + 48));
    xpc_object_t v2 = *(const void **)(a1 + 32);
    if (!v2) {
      return;
    }
    goto LABEL_5;
  }
  xpc_object_t v2 = *(const void **)(a1 + 32);
  if (v2) {
LABEL_5:
  }
    _Block_release(v2);
}

uint64_t Trace::Trace(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const char *)a2;
  if (*(char *)(a2 + 23) < 0) {
    uint64_t v4 = *(const char **)a2;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v9, "com.apple.telephony.abm", v4);
  GetABMLogServer(&v7);
  dispatch_object_t object = 0;
  ctu::SharedSynchronizable<Trace>::SharedSynchronizable((void *)(a1 + 72), a2, 0, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>>((void *)a1, (uint64_t)v9, &v7);
  *(void *)a1 = &unk_1EFB0CB00;
  uint64_t v5 = v8;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v9);
  *(void *)a1 = &unk_1EFB095E8;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  return a1;
}

void sub_1A6165E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, dispatch_object_t object)
{
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v14);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a12);
  _Unwind_Resume(a1);
}

void sub_1A6165E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void Trace::create(char *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, void *a4@<X8>)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  a4[1] = 0;
  int v8 = a1[23];
  if ((v8 & 0x80000000) == 0)
  {
    CFStringRef v9 = (capabilities::trace *)strcasecmp(a1, "IPC");
    int v10 = a1;
    if (v9) {
      goto LABEL_3;
    }
LABEL_12:
    if (!capabilities::trace::supportsKernelPCITrace(v9)) {
      goto LABEL_64;
    }
    uint64_t v15 = (KernelPCITrace *)operator new(0x110uLL);
    KernelPCITrace::KernelPCITrace(v15);
    memset(buf, 170, sizeof(buf));
    std::shared_ptr<KernelPCITrace>::shared_ptr[abi:ne180100]<KernelPCITrace,std::shared_ptr<KernelPCITrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCITrace>(KernelPCITrace*)::{lambda(KernelPCITrace*)#1},void>(buf, (uint64_t)v15);
    ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
    uint64_t v16 = *(void *)buf;
    long long v17 = (std::__shared_weak_count *)a4[1];
    *(_OWORD *)a4 = *(_OWORD *)buf;
    if (!v17) {
      goto LABEL_18;
    }
LABEL_14:
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    goto LABEL_64;
  }
  int v10 = *(const char **)a1;
  CFStringRef v9 = (capabilities::trace *)strcasecmp(*(const char **)a1, "IPC");
  if (!v9) {
    goto LABEL_12;
  }
LABEL_3:
  unint64_t v11 = (capabilities::trace *)strcasecmp(v10, "KernelPCI");
  if (v11)
  {
    if ((v8 & 0x80) == 0)
    {
LABEL_5:
      uint64_t v12 = (capabilities::radio *)strcasecmp(a1, "BasebandTrace");
      if (v12)
      {
        uint64_t v12 = (capabilities::radio *)strcasecmp(a1, abm::trace::kDIAG[0]);
        if (v12)
        {
          uint64_t v12 = (capabilities::radio *)strcasecmp(a1, "BBTrace");
          if (v12)
          {
            uint64_t v13 = (capabilities::radio *)strcasecmp(a1, "CoreDump");
            if (!v13) {
              goto LABEL_56;
            }
            uint64_t v13 = (capabilities::radio *)strcasecmp(a1, abm::trace::kEURCoreDump[0]);
            uint64_t v14 = a1;
            if (!v13) {
              goto LABEL_56;
            }
            goto LABEL_33;
          }
        }
      }
      goto LABEL_37;
    }
LABEL_28:
    uint64_t v14 = *(const char **)a1;
    uint64_t v12 = (capabilities::radio *)strcasecmp(*(const char **)a1, "BasebandTrace");
    if (v12)
    {
      uint64_t v12 = (capabilities::radio *)strcasecmp(v14, abm::trace::kDIAG[0]);
      if (v12)
      {
        uint64_t v12 = (capabilities::radio *)strcasecmp(v14, "BBTrace");
        if (v12)
        {
          uint64_t v13 = (capabilities::radio *)strcasecmp(v14, "CoreDump");
          if (!v13 || (uint64_t v13 = (capabilities::radio *)strcasecmp(v14, abm::trace::kEURCoreDump[0]), !v13))
          {
LABEL_56:
            int v34 = capabilities::radio::vendor(v13);
            switch(v34)
            {
              case 1:
                EURCoreDumpTrace::createInternal(buf);
                break;
              case 2:
                ICECoredumpTrace::createInternal(buf);
                break;
              case 3:
                CoredumpTrace::createInternal(buf);
                break;
              default:
                goto LABEL_64;
            }
            goto LABEL_63;
          }
LABEL_33:
          long long v23 = (capabilities::radio *)strcasecmp(v14, "BasebandIPC");
          if (v23) {
            goto LABEL_64;
          }
          int v24 = capabilities::radio::vendor(v23);
          if (v24 == 2)
          {
            BasebandIPCTraceICE::createInternal(buf);
          }
          else
          {
            if (v24 != 1) {
              goto LABEL_64;
            }
            BasebandIPCTrace::createInternal(buf);
          }
LABEL_63:
          std::shared_ptr<abm::trace::TraceReader>::operator=[abi:ne180100]((uint64_t)a4, (long long *)buf);
          std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)buf);
          goto LABEL_64;
        }
      }
    }
LABEL_37:
    int v25 = capabilities::radio::vendor(v12);
    if (v25 == 2)
    {
      xpc_object_t v31 = (ICETrace *)operator new(0x1F0uLL);
      ICETrace::ICETrace(v31);
      memset(buf, 170, sizeof(buf));
      std::shared_ptr<ICETrace>::shared_ptr[abi:ne180100]<ICETrace,std::shared_ptr<ICETrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICETrace>(ICETrace*)::{lambda(ICETrace*)#1},void>(buf, (uint64_t)v31);
      ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
      xpc_object_t v32 = (std::__shared_weak_count *)a4[1];
      *(_OWORD *)a4 = *(_OWORD *)buf;
      if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
      GetABMLogServer(&v43);
      xpc_object_t v28 = *((void *)GetGlobalLogger(&v43) + 4);
      xpc_object_t v33 = v44;
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        xpc_object_t v30 = "#I ICE Trace is created";
        goto LABEL_55;
      }
    }
    else if (v25 == 1)
    {
      unint64_t v26 = (DIAGTrace *)operator new(0x198uLL);
      DIAGTrace::DIAGTrace(v26);
      memset(buf, 170, sizeof(buf));
      std::shared_ptr<DIAGTrace>::shared_ptr[abi:ne180100]<DIAGTrace,std::shared_ptr<DIAGTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<DIAGTrace>(DIAGTrace*)::{lambda(DIAGTrace*)#1},void>(buf, (uint64_t)v26);
      ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
      xpc_object_t v27 = (std::__shared_weak_count *)a4[1];
      *(_OWORD *)a4 = *(_OWORD *)buf;
      if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
      GetABMLogServer(&v45);
      xpc_object_t v28 = *((void *)GetGlobalLogger(&v45) + 4);
      xpc_object_t v29 = v46;
      if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        xpc_object_t v30 = "#I DIAG is created";
LABEL_55:
        _os_log_impl(&dword_1A609F000, v28, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
      }
    }
LABEL_64:
    uint64_t v19 = *a4;
    if (*a4) {
      goto LABEL_65;
    }
    goto LABEL_19;
  }
  if ((capabilities::trace::supportsKernelPCIBinaryTrace(v11) & 1) == 0)
  {
    if ((a1[23] & 0x80) == 0) {
      goto LABEL_5;
    }
    goto LABEL_28;
  }
  long long v18 = (KernelPCIABPTrace *)operator new(0x110uLL);
  KernelPCIABPTrace::KernelPCIABPTrace(v18);
  memset(buf, 170, sizeof(buf));
  std::shared_ptr<KernelPCIABPTrace>::shared_ptr[abi:ne180100]<KernelPCIABPTrace,std::shared_ptr<KernelPCIABPTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<KernelPCIABPTrace>(KernelPCIABPTrace*)::{lambda(KernelPCIABPTrace*)#1},void>(buf, (uint64_t)v18);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(*(uint64_t *)buf);
  uint64_t v16 = *(void *)buf;
  long long v17 = (std::__shared_weak_count *)a4[1];
  *(_OWORD *)a4 = *(_OWORD *)buf;
  if (v17) {
    goto LABEL_14;
  }
LABEL_18:
  uint64_t v19 = v16;
  if (v16)
  {
LABEL_65:
    if (a1[23] < 0) {
      std::string::__init_copy_ctor_external(&v42, *(const std::string::value_type **)a1, *((void *)a1 + 1));
    }
    else {
      std::string v42 = *(std::string *)a1;
    }
    xpc_object_t v35 = (std::__shared_weak_count *)a2[1];
    uint64_t v40 = *a2;
    xpc_object_t v41 = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v36 = *a3;
    dispatch_object_t object = v36;
    if (v36) {
      dispatch_retain(v36);
    }
    (*(void (**)(uint64_t, std::string *, uint64_t *, dispatch_object_t *))(*(void *)v19 + 48))(v19, &v42, &v40, &object);
    if (object) {
      dispatch_release(object);
    }
    if (v41) {
      std::__shared_weak_count::__release_weak(v41);
    }
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    return;
  }
LABEL_19:
  GetABMLogServer(&v37);
  long long v20 = *((void *)GetGlobalLogger(&v37) + 4);
  uint64_t v21 = v38;
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (a1[23] >= 0) {
      xpc_object_t v22 = a1;
    }
    else {
      xpc_object_t v22 = *(char **)a1;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v22;
    _os_log_impl(&dword_1A609F000, v20, OS_LOG_TYPE_DEFAULT, "#I Failed to create the trace: %s", buf, 0xCu);
  }
}

void sub_1A6166540(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A6166554(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A6166568(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A616657C(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A6166590(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A61665A4(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 80);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A61665C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21)
{
  operator delete(v22);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v21);
  _Unwind_Resume(a1);
}

void sub_1A616669C(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A61666B0(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A61666C4(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A61666D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void sub_1A61666F4(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A6166708(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A616671C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (object)
  {
    dispatch_release(object);
    xpc_object_t v22 = a14;
    if (!a14)
    {
LABEL_3:
      if (a20 < 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    xpc_object_t v22 = a14;
    if (!a14) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v22);
  if (a20 < 0)
  {
LABEL_4:
    operator delete(__p);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v20);
    _Unwind_Resume(a1);
  }
LABEL_7:
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v20);
  _Unwind_Resume(a1);
}

void sub_1A6166778(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Trace::getCurrentBootSessionUUID(unsigned char *a1@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(void *)&v19[13] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__s = v3;
  *(_OWORD *)uint64_t v19 = v3;
  size_t v15 = 37;
  if (!sysctlbyname("kern.bootsessionuuid", __s, &v15, 0, 0) && v15 == 37)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v8 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v8 = v4 | 7;
      }
      uint64_t v9 = v8 + 1;
      int v10 = operator new(v8 + 1);
      *((void *)a1 + 1) = v5;
      *((void *)a1 + 2) = v9 | 0x8000000000000000;
      *(void *)a1 = v10;
      a1 = v10;
    }
    else
    {
      a1[23] = v4;
      if (!v4) {
        goto LABEL_17;
      }
    }
    memcpy(a1, __s, v5);
LABEL_17:
    a1[v5] = 0;
    return;
  }
  GetABMLogServer(&v13);
  long long v6 = *((void *)GetGlobalLogger(&v13) + 4);
  uint64_t v7 = v14;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    unint64_t v11 = __error();
    uint64_t v12 = strerror(*v11);
    *(_DWORD *)std::string buf = 136315138;
    long long v17 = v12;
    _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Failed to get boot session uuid, error: %s", buf, 0xCu);
  }
  a1[23] = 0;
  *a1 = 0;
}

void sub_1A6166964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *ctu::SharedSynchronizable<Trace>::SharedSynchronizable(void *a1, uint64_t a2, dispatch_queue_attr_t attr, dispatch_object_t *a4)
{
  if (*(char *)(a2 + 23) >= 0) {
    long long v6 = (const char *)a2;
  }
  else {
    long long v6 = *(const char **)a2;
  }
  uint64_t v7 = *a4;
  if (*a4)
  {
    dispatch_retain(*a4);
    dispatch_retain(v7);
    uint64_t v8 = dispatch_queue_create_with_target_V2(v6, attr, v7);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = v8;
    if (!v8) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  uint64_t v8 = dispatch_queue_create(v6, attr);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = v8;
  if (v8) {
LABEL_6:
  }
    dispatch_retain(v8);
LABEL_7:
  a1[3] = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  if (v8) {
    dispatch_release(v8);
  }
  if (v7)
  {
    dispatch_release(v7);
    dispatch_release(v7);
  }
  return a1;
}

void *ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<ctu::OsLogContext,std::shared_ptr<ctu::LogServer>>(void *a1, uint64_t a2, void *a3)
{
  *a1 = &unk_1EFB09728;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  a1[1] = &unk_1EFB08838;
  a1[7] = *a3;
  uint64_t v5 = a3[1];
  a1[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  return a1;
}

void sub_1A6166B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *ctu::SharedLoggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB09728;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  long long v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  size_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void ctu::SharedLoggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB09728;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  long long v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  size_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(a1);
}

uint64_t __cxx_global_var_init_4()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

void abm::CellularLoggingCommon::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, void *a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, "com.apple.telephony.abm", "carriercellularlogging.modem");
  uint64_t v9 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext(v8);
  *a4 = 0;
  a4[1] = 0;
  int v11 = capabilities::radio::vendor(v10);
  int v12 = v11;
  if (v11 != 1)
  {
    if (v11 != 3)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v12;
        long long v18 = "Not supported radio vendor: %d";
        int v24 = v9;
        uint32_t v25 = 8;
        goto LABEL_36;
      }
      return;
    }
    uint64_t v13 = a1[1];
    uint64_t v30 = *a1;
    xpc_object_t v31 = (std::__shared_weak_count *)v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = (std::__shared_weak_count *)a2[1];
    uint64_t v28 = *a2;
    xpc_object_t v29 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    size_t v15 = *a3;
    dispatch_object_t object = v15;
    if (v15) {
      dispatch_retain(v15);
    }
    std::allocate_shared[abi:ne180100]<abm::CellularLoggingINT,std::allocator<abm::CellularLoggingINT>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(&v30, &v28, &object, buf);
    long long v16 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    *(_OWORD *)a4 = v16;
    if (object) {
      dispatch_release(object);
    }
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    long long v17 = v31;
    if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
      if (*a4)
      {
LABEL_16:
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          long long v18 = "Succeeded creating CellularLoggingINT";
LABEL_33:
          int v24 = v9;
          uint32_t v25 = 2;
LABEL_36:
          _os_log_impl(&dword_1A609F000, v24, OS_LOG_TYPE_DEFAULT, v18, buf, v25);
          return;
        }
        return;
      }
    }
    else if (*a4)
    {
      goto LABEL_16;
    }
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    unint64_t v26 = "Failed creating CellularLoggingINT";
LABEL_44:
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, v26, buf, 2u);
    return;
  }
  uint64_t v19 = a1[1];
  uint64_t v35 = *a1;
  xpc_object_t v36 = (std::__shared_weak_count *)v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = (std::__shared_weak_count *)a2[1];
  uint64_t v33 = *a2;
  int v34 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = *a3;
  dispatch_object_t v32 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  std::allocate_shared[abi:ne180100]<abm::CellularLoggingEUR,std::allocator<abm::CellularLoggingEUR>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(&v35, &v33, &v32, buf);
  long long v22 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  *(_OWORD *)a4 = v22;
  if (v32) {
    dispatch_release(v32);
  }
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  long long v23 = v36;
  if (!v36 || atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (*a4) {
      goto LABEL_31;
    }
LABEL_41:
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    unint64_t v26 = "Failed creating CellularLoggingEUR";
    goto LABEL_44;
  }
  ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
  std::__shared_weak_count::__release_weak(v23);
  if (!*a4) {
    goto LABEL_41;
  }
LABEL_31:
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    long long v18 = "Succeeded creating CellularLoggingEUR";
    goto LABEL_33;
  }
}

void sub_1A6166FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, uint64_t a16, std::__shared_weak_count *a17, char a18)
{
  if (object) {
    dispatch_release(object);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v18);
  _Unwind_Resume(a1);
}

void sub_1A616700C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12, char a13)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v13);
  _Unwind_Resume(a1);
}

void sub_1A6167040(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t abm::CellularLoggingCommon::CellularLoggingCommon(uint64_t a1, void *a2, void *a3, NSObject **a4)
{
  *(void *)a1 = &unk_1EFB0CB40;
  uint64_t v13 = "carriercellularlogging.modem";
  uint64_t v8 = ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>((void *)a1, &v13, a2);
  v8[9] = 0;
  v8[10] = 0;
  void *v8 = &unk_1EFB0CB40;
  uint64_t v9 = a3[1];
  v8[11] = *a3;
  v8[12] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = a2[1];
  *(void *)(a1 + 104) = *a2;
  *(void *)(a1 + 112) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  int v11 = *a4;
  *(void *)(a1 + 120) = *a4;
  if (v11) {
    dispatch_retain(v11);
  }
  *(unsigned char *)(a1 + 128) = 0;
  return a1;
}

void *ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>(void *a1, const char **a2, void *a3)
{
  *a1 = &unk_1EFB0CCB0;
  uint64_t v5 = *a2;
  size_t v6 = strlen(*a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (void *)v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v8 = (void **)operator new(v9 + 1);
    __dst[1] = v7;
    unint64_t v14 = v10 | 0x8000000000000000;
    __dst[0] = v8;
    goto LABEL_8;
  }
  HIBYTE(v14) = v6;
  uint64_t v8 = __dst;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, (size_t)v7);
  *((unsigned char *)v7 + (void)v8) = 0;
  ctu::LoggerCommonBase::LoggerCommonBase();
  a1[1] = &unk_1EFB08838;
  a1[7] = *a3;
  uint64_t v11 = a3[1];
  a1[8] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
  return a1;
}

void sub_1A6167260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void abm::CellularLoggingCommon::~CellularLoggingCommon(abm::CellularLoggingCommon *this)
{
  *(void *)this = &unk_1EFB0CB40;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    dispatch_release(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 14);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    size_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v4) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  size_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
LABEL_6:
  }
    std::__shared_weak_count::__release_weak(v4);
LABEL_7:
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  *(void *)this = &unk_1EFB0CCB0;
  MEMORY[0x1A6274710]((char *)this + 8);
}

BOOL abm::CellularLoggingCommon::setProperty(void *a1, const std::string::value_type *a2, const std::string::value_type *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v41 = 0;
  std::string v42 = &v41;
  uint64_t v43 = 0x2020000000;
  char v44 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  size_t v4 = (std::__shared_weak_count *)a1[12];
  if (!v4)
  {
    uint64_t v7 = 0;
    goto LABEL_9;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  uint64_t v40 = v7;
  if (!v7 || (uint64_t v39 = a1[11]) == 0)
  {
LABEL_9:
    uint64_t v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Server is not available", buf, 2u);
      BOOL v11 = 0;
      if (!v7) {
        goto LABEL_68;
      }
    }
    else
    {
      BOOL v11 = 0;
      if (!v7) {
        goto LABEL_68;
      }
    }
    goto LABEL_66;
  }
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  if (v8 || (xpc_object_t v8 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v8) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v8);
      xpc_object_t v9 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v8 = 0;
  }
  xpc_release(v8);
  xpc_object_t v12 = xpc_string_create("BasebandTrace");
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_dictionary_set_value(v9, "kKeyTraceName", v12);
  xpc_object_t v13 = xpc_null_create();
  xpc_release(v12);
  xpc_release(v13);
  unint64_t v14 = a2;
  if (a2[23] < 0) {
    unint64_t v14 = *(const char **)a2;
  }
  xpc_object_t v15 = xpc_string_create(v14);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_dictionary_set_value(v9, "kKeyTracePropertyName", v15);
  xpc_object_t v16 = xpc_null_create();
  xpc_release(v15);
  xpc_release(v16);
  long long v17 = a3;
  if (a3[23] < 0) {
    long long v17 = *(const char **)a3;
  }
  xpc_object_t v18 = xpc_string_create(v17);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_dictionary_set_value(v9, "kKeyTracePropertyValue", v18);
  xpc_object_t v19 = xpc_null_create();
  xpc_release(v18);
  xpc_release(v19);
  xpc_object_t v20 = xpc_BOOL_create(1);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  xpc_dictionary_set_value(v9, "kKeyTracePropertyWaitForCompletion", v20);
  xpc_object_t v21 = xpc_null_create();
  xpc_release(v20);
  xpc_release(v21);
  long long v22 = dispatch_group_create();
  long long v23 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  int v24 = dispatch_queue_create("CellularLoggingCommon", v23);
  unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  char v47 = 12;
  strcpy(buf, "helperserver");
  abm::client::CreateManager();
  if (v47 < 0) {
    operator delete(*(void **)buf);
  }
  if (v22)
  {
    dispatch_retain(v22);
    dispatch_group_enter(v22);
  }
  unint64_t v33 = v37;
  int v34 = (std::__shared_weak_count *)v38;
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
  if (v22)
  {
    dispatch_retain(v22);
    dispatch_group_enter(v22);
  }
  if (a2[23] < 0) {
    std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else {
    std::string v31 = *(std::string *)a2;
  }
  if (a3[23] < 0) {
    std::string::__init_copy_ctor_external(&v32, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else {
    std::string v32 = *(std::string *)a3;
  }
  abm::client::SetTraceProperty();
  if (v36 < 0) {
    operator delete(__p);
  }
  uint32_t v25 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
LABEL_50:
    operator delete(v31.__r_.__value_.__l.__data_);
    unint64_t v26 = v22;
    if (!v22) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_50;
  }
LABEL_47:
  unint64_t v26 = v22;
  if (v22)
  {
LABEL_51:
    dispatch_group_leave(v26);
    dispatch_release(v22);
  }
LABEL_52:
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  dispatch_time_t v27 = dispatch_time(0, 25000000000);
  if (!dispatch_group_wait(v22, v27))
  {
    BOOL v11 = *((unsigned char *)v42 + 24) != 0;
    xpc_object_t v29 = (std::__shared_weak_count *)v38;
    if (!v38) {
      goto LABEL_61;
    }
    goto LABEL_59;
  }
  uint64_t v28 = a1[5];
  if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    BOOL v11 = 0;
    *((unsigned char *)v42 + 24) = 0;
    xpc_object_t v29 = (std::__shared_weak_count *)v38;
    if (!v38) {
      goto LABEL_61;
    }
    goto LABEL_59;
  }
  if (a2[23] < 0) {
    a2 = *(const std::string::value_type **)a2;
  }
  if (a3[23] < 0) {
    a3 = *(const std::string::value_type **)a3;
  }
  *(_DWORD *)std::string buf = 136315394;
  *(void *)&uint8_t buf[4] = a2;
  *(_WORD *)&buf[12] = 2080;
  xpc_object_t v46 = a3;
  _os_log_error_impl(&dword_1A609F000, v28, OS_LOG_TYPE_ERROR, "Timeout for setting property for %s with %s", buf, 0x16u);
  BOOL v11 = 0;
  *((unsigned char *)v42 + 24) = 0;
  xpc_object_t v29 = (std::__shared_weak_count *)v38;
  if (v38)
  {
LABEL_59:
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
LABEL_61:
  if (v24) {
    dispatch_release(v24);
  }
  if (v22) {
    dispatch_release(v22);
  }
  xpc_release(v9);
  uint64_t v7 = v40;
  if (v40)
  {
LABEL_66:
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
LABEL_68:
  _Block_object_dispose(&v41, 8);
  return v11;
}

void sub_1A61679C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_group_t group, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a22 < 0)
  {
    operator delete(__p);
    uint64_t v40 = group;
    if (!group) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v40 = group;
    if (!group)
    {
LABEL_6:
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
      if (v36)
      {
        dispatch_group_leave(v36);
        dispatch_release(v36);
      }
      std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a35);
      if (v37)
      {
        dispatch_release(v37);
        if (!v36)
        {
LABEL_11:
          xpc_release(v35);
          std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v38 - 144);
          _Block_object_dispose((const void *)(v38 - 128), 8);
          _Unwind_Resume(a1);
        }
      }
      else if (!v36)
      {
        goto LABEL_11;
      }
      dispatch_release(v36);
      goto LABEL_11;
    }
  }
  dispatch_group_leave(v40);
  dispatch_release(group);
  goto LABEL_6;
}

void sub_1A6167B34(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm21CellularLoggingCommon11setPropertyENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES7__block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    size_t v4 = *(NSObject **)(*(void *)(a1 + 40) + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      size_t v6 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        size_t v6 = (void *)*v6;
      }
      uint64_t v7 = (void *)(a1 + 80);
      if (*(char *)(a1 + 103) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      int v8 = 136315394;
      xpc_object_t v9 = v6;
      __int16 v10 = 2080;
      BOOL v11 = v7;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Failed to set property with the name(%s) with the value (%s)", (uint8_t *)&v8, 0x16u);
      BOOL v5 = *a2 == 0;
    }
    else
    {
      BOOL v5 = 0;
    }
  }
  else
  {
    BOOL v5 = 1;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
}

void __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE80c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    BOOL v5 = *(NSObject **)(a1 + 48);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 56), *(const std::string::value_type **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
  }
  uint64_t v7 = (std::string *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
}

void sub_1A6167D04(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  size_t v4 = *(NSObject **)(v1 + 48);
  if (v4)
  {
    dispatch_group_leave(v4);
    BOOL v5 = *(NSObject **)(v1 + 48);
    if (v5) {
      dispatch_release(v5);
    }
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE80c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0)
  {
    operator delete(*(void **)(a1 + 80));
    if ((*(char *)(a1 + 79) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = *(NSObject **)(a1 + 48);
      if (!v2) {
        return;
      }
      goto LABEL_7;
    }
  }
  else if ((*(char *)(a1 + 79) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 56));
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (!v2) {
    return;
  }
LABEL_7:
  dispatch_group_leave(v2);
  long long v3 = *(NSObject **)(a1 + 48);
  if (v3)
  {
    dispatch_release(v3);
  }
}

void abm::CellularLoggingCommon::getProperty(uint64_t a1@<X0>, const std::string::value_type *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  std::string v32 = &v31;
  uint64_t v33 = 0x4812000000;
  int v34 = __Block_byref_object_copy__0;
  uint64_t v35 = __Block_byref_object_dispose__0;
  long long v36 = 0u;
  long long v37 = 0u;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v6 || (xpc_object_t v6 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v6) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v6);
      xpc_object_t v7 = v6;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v6 = 0;
  }
  xpc_release(v6);
  xpc_object_t v8 = xpc_string_create("BasebandTrace");
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "kKeyTraceName", v8);
  xpc_object_t v9 = xpc_null_create();
  xpc_release(v8);
  xpc_release(v9);
  __int16 v10 = a2;
  if (a2[23] < 0) {
    __int16 v10 = *(const char **)a2;
  }
  xpc_object_t v11 = xpc_string_create(v10);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "kKeyTracePropertyName", v11);
  xpc_object_t v12 = xpc_null_create();
  xpc_release(v11);
  xpc_release(v12);
  xpc_object_t v13 = xpc_BOOL_create(1);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  xpc_dictionary_set_value(v7, "kKeyTracePropertyWaitForCompletion", v13);
  xpc_object_t v14 = xpc_null_create();
  xpc_release(v13);
  xpc_release(v14);
  xpc_object_t v15 = dispatch_group_create();
  xpc_object_t v16 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  long long v17 = dispatch_queue_create("CellularLoggingCommon", v16);
  unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  char v39 = 12;
  strcpy((char *)buf, "helperserver");
  abm::client::CreateManager();
  if (v39 < 0) {
    operator delete(*(void **)buf);
  }
  if (v15)
  {
    dispatch_retain(v15);
    dispatch_group_enter(v15);
  }
  unint64_t v25 = v29;
  unint64_t v26 = (std::__shared_weak_count *)v30;
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
  if (v15)
  {
    dispatch_retain(v15);
    dispatch_group_enter(v15);
  }
  if (a2[23] < 0) {
    std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else {
    std::string v24 = *(std::string *)a2;
  }
  abm::client::GetTraceProperty();
  if (v28 < 0) {
    operator delete(__p);
  }
  xpc_object_t v18 = v26;
  if (!v26 || atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
  std::__shared_weak_count::__release_weak(v18);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
LABEL_29:
  }
    operator delete(v24.__r_.__value_.__l.__data_);
LABEL_30:
  if (v15)
  {
    dispatch_group_leave(v15);
    dispatch_release(v15);
    dispatch_group_leave(v15);
    dispatch_release(v15);
  }
  dispatch_time_t v19 = dispatch_time(0, 25000000000);
  if (dispatch_group_wait(v15, v19))
  {
    xpc_object_t v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if (a2[23] < 0) {
        a2 = *(const std::string::value_type **)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_error_impl(&dword_1A609F000, v20, OS_LOG_TYPE_ERROR, "Timeout for getting property! for %s", buf, 0xCu);
      xpc_object_t v21 = v32;
      if ((*((char *)v32 + 71) & 0x80000000) == 0) {
        goto LABEL_35;
      }
LABEL_41:
      std::string::__init_copy_ctor_external(a3, (const std::string::value_type *)v21[6], v21[7]);
      goto LABEL_42;
    }
  }
  xpc_object_t v21 = v32;
  if (*((char *)v32 + 71) < 0) {
    goto LABEL_41;
  }
LABEL_35:
  long long v22 = *((_OWORD *)v21 + 3);
  a3->__r_.__value_.__r.__words[2] = v21[8];
  *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v22;
LABEL_42:
  long long v23 = (std::__shared_weak_count *)v30;
  if (v30 && !atomic_fetch_add((atomic_ullong *volatile)(v30 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v15) {
    dispatch_release(v15);
  }
  xpc_release(v7);
  _Block_object_dispose(&v31, 8);
  if (SHIBYTE(v37) < 0) {
    operator delete(*((void **)&v36 + 1));
  }
}

void sub_1A61682F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_group_t group, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a29);
  if (v44)
  {
    dispatch_release(v44);
    if (!v43)
    {
LABEL_4:
      xpc_release(v42);
      _Block_object_dispose(&a31, 8);
      if (a42 < 0)
      {
        operator delete(__p);
        _Unwind_Resume(a1);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v43)
  {
    goto LABEL_4;
  }
  dispatch_release(v43);
  goto LABEL_4;
}

__n128 __Block_byref_object_copy__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

void ___ZN3abm21CellularLoggingCommon11getPropertyENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE_block_invoke(uint64_t a1, _DWORD *a2, xpc_object_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 40);
  xpc_object_t v7 = xpc_null_create();
  if (*a2)
  {
    xpc_object_t v8 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      xpc_object_t v16 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        xpc_object_t v16 = (void *)*v16;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v16;
      _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to get property with the name(%s)", buf, 0xCu);
    }
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v10 = xpc_null_create();
    xpc_release(v7);
    xpc_release(v10);
    goto LABEL_19;
  }
  if (a3)
  {
    xpc_retain(a3);
    goto LABEL_7;
  }
  a3 = xpc_null_create();
  if (a3)
  {
LABEL_7:
    if (MEMORY[0x1A6275E60](a3) == MEMORY[0x1E4F14590])
    {
      xpc_retain(a3);
      xpc_object_t v9 = a3;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
    goto LABEL_11;
  }
  xpc_object_t v9 = xpc_null_create();
  a3 = 0;
LABEL_11:
  xpc_object_t v11 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v11);
  xpc_release(a3);
  xpc_object_t v12 = (const char *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    xpc_object_t v12 = *(const char **)v12;
  }
  xpc_object_t value = xpc_dictionary_get_value(v9, v12);
  xpc_object_t object = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v15 = v14 + 48;
  if (*(char *)(v14 + 71) < 0) {
    operator delete(*(void **)v15);
  }
  *(_OWORD *)uint64_t v15 = *(_OWORD *)buf;
  *(void *)(v15 + 16) = v19;
  HIBYTE(v19) = 0;
  buf[0] = 0;
  xpc_release(object);
LABEL_19:
  xpc_release(v9);
}

void sub_1A6168664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    BOOL v5 = *(NSObject **)(a1 + 48);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = (std::string *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
}

void sub_1A616874C(_Unwind_Exception *exception_object)
{
  long long v3 = *(NSObject **)(v1 + 48);
  if (v3)
  {
    dispatch_group_leave(v3);
    size_t v4 = *(NSObject **)(v1 + 48);
    if (v4) {
      dispatch_release(v4);
    }
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0)
  {
    operator delete(*(void **)(a1 + 56));
    uint64_t v2 = *(NSObject **)(a1 + 48);
    if (!v2) {
      return;
    }
  }
  else
  {
    uint64_t v2 = *(NSObject **)(a1 + 48);
    if (!v2) {
      return;
    }
  }
  dispatch_group_leave(v2);
  long long v3 = *(NSObject **)(a1 + 48);
  if (v3)
  {
    dispatch_release(v3);
  }
}

BOOL abm::CellularLoggingCommon::start()
{
  BOOL v5 = (char *)operator new(0x38uLL);
  *(_WORD *)&v4[50] = 0;
  *(_DWORD *)&v4[52] = 0;
  *(void *)&v4[56] = 0x8000000000000038;
  long long v6 = xmmword_1A61F8900;
  strcpy(v5, "/private/var/mobile/Library/Logs/CellularLogging");
  strcpy(v4, "/CellularLoggingile/Library/Logs/private/var/mob0");
  uint64_t v0 = support::fs::removeDir((const char *)&v5);
  BOOL Dir = v0;
  if (SHIBYTE(v6) < 0)
  {
    operator delete(v5);
    if (!Dir) {
      return Dir;
    }
  }
  else if (!v0)
  {
    return Dir;
  }
  long long v3 = (char *)operator new(0x38uLL);
  BOOL v5 = v3;
  long long v6 = *(_OWORD *)&v4[48];
  *(_OWORD *)long long v3 = *(_OWORD *)&v4[32];
  *((_OWORD *)v3 + 1) = *(_OWORD *)&v4[16];
  *((_OWORD *)v3 + 2) = *(_OWORD *)v4;
  v3[48] = 0;
  BOOL Dir = support::fs::createDir((const char *)&v5, 0x1EDu, 0);
  if ((SHIBYTE(v6) & 0x80000000) == 0) {
    return Dir;
  }
  operator delete(v5);
  return Dir;
}

void sub_1A61688C8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 17) < 0) {
    operator delete(*(void **)(v1 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingCommon::changeState(abm::CellularLoggingCommon *this, int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)&v24.__r_.__value_.__s + 23) = 1;
  LOWORD(v24.__r_.__value_.__l.__data_) = 47;
  size_t v4 = std::string::insert(&v24, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  long long v6 = std::string::append(&v27, "com.apple.cellularlogging.state", 0x1FuLL);
  long long v8 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  int64_t v26 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v8;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_14:
    operator delete(v24.__r_.__value_.__l.__data_);
    if (v26 >= 0) {
      xpc_object_t v9 = (const std::__fs::filesystem::path *)__p;
    }
    else {
      xpc_object_t v9 = (const std::__fs::filesystem::path *)__p[0];
    }
    if (a2) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
  operator delete(v27.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_14;
  }
LABEL_3:
  if (v26 >= 0) {
    xpc_object_t v9 = (const std::__fs::filesystem::path *)__p;
  }
  else {
    xpc_object_t v9 = (const std::__fs::filesystem::path *)__p[0];
  }
  if (a2)
  {
LABEL_7:
    int v10 = open((const char *)v9, 1537, 420);
    xpc_object_t v11 = *((void *)this + 5);
    if (v10 >= 1)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v27.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#N Successfully created Cellular Logging state file", (uint8_t *)&v27, 2u);
      }
      while (close(v10) && *__error() == 4)
        ;
      goto LABEL_30;
    }
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = 0;
      if ((SHIBYTE(v26) & 0x80000000) == 0) {
        return v19;
      }
      goto LABEL_35;
    }
    long long v23 = __p;
    if (v26 < 0) {
      long long v23 = (void **)__p[0];
    }
    LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    xpc_object_t v16 = "Failed to create the state file, %s";
    long long v17 = v11;
LABEL_43:
    uint32_t v22 = 12;
    goto LABEL_44;
  }
LABEL_18:
  if (remove(v9, v7))
  {
    if (v26 >= 0) {
      xpc_object_t v12 = __p;
    }
    else {
      xpc_object_t v12 = (void **)__p[0];
    }
    int v13 = unlink((const char *)v12);
    uint64_t v14 = *((void *)this + 5);
    if (v13)
    {
      if (!os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
      uint64_t v15 = __p;
      if (v26 < 0) {
        uint64_t v15 = (void **)__p[0];
      }
      LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      xpc_object_t v16 = "Failed to remove the state file, %s";
      long long v17 = v14;
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v14 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v27.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#N Successfully removed Cellular Logging state file", (uint8_t *)&v27, 2u);
  }
LABEL_30:
  sync();
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (!DarwinNotifyCenter)
  {
    xpc_object_t v21 = *((void *)this + 5);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
LABEL_34:
      uint64_t v19 = 0;
      if ((SHIBYTE(v26) & 0x80000000) == 0) {
        return v19;
      }
LABEL_35:
      operator delete(__p[0]);
      return v19;
    }
    LOWORD(v27.__r_.__value_.__l.__data_) = 0;
    xpc_object_t v16 = "Failed getting darwin notification center!!!";
    long long v17 = v21;
    uint32_t v22 = 2;
LABEL_44:
    _os_log_error_impl(&dword_1A609F000, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v27, v22);
    uint64_t v19 = 0;
    if ((SHIBYTE(v26) & 0x80000000) == 0) {
      return v19;
    }
    goto LABEL_35;
  }
  uint64_t v19 = 1;
  CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.CarrierCellularLogging.state", 0, 0, 1u);
  if (SHIBYTE(v26) < 0) {
    goto LABEL_35;
  }
  return v19;
}

void sub_1A6168C48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingCommon::isStarted(abm::CellularLoggingCommon *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)&v18.__r_.__value_.__s + 23) = 1;
  LOWORD(v18.__r_.__value_.__l.__data_) = 47;
  uint64_t v2 = std::string::insert(&v18, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  *(void *)&v17.st_uid = *((void *)&v2->__r_.__value_.__l + 2);
  *(_OWORD *)&v17.st_dev = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  size_t v4 = std::string::append((std::string *)&v17, "com.apple.cellularlogging.state", 0x1FuLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  int64_t v16 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v17.st_gid) < 0)
  {
    operator delete(*(void **)&v17.st_dev);
    if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      long long v6 = *((void *)this + 5);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
      goto LABEL_7;
    }
  }
  else if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v18.__r_.__value_.__l.__data_);
  long long v6 = *((void *)this + 5);
  if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_13;
  }
LABEL_7:
  v7.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v7.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blkstd::string::size_type size = v7;
  *(timespec *)v17.st_qspare = v7;
  v17.st_birthtimespec = v7;
  *(timespec *)&v17.st_std::string::size_type size = v7;
  v17.st_mtimespec = v7;
  v17.st_ctimespec = v7;
  *(timespec *)&v17.st_uid = v7;
  v17.st_atimespec = v7;
  *(timespec *)&v17.st_dev = v7;
  if (v16 >= 0) {
    long long v8 = __p;
  }
  else {
    long long v8 = (void **)__p[0];
  }
  int v9 = stat((const char *)v8, &v17);
  int v10 = "does not exist";
  if (!v9) {
    int v10 = "exists";
  }
  LODWORD(v18.__r_.__value_.__l.__data_) = 136315394;
  *(std::string::size_type *)((char *)v18.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
  WORD2(v18.__r_.__value_.__r.__words[1]) = 2080;
  *(std::string::size_type *)((char *)&v18.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
  _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I State file %s %s", (uint8_t *)&v18, 0x16u);
LABEL_13:
  v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v11.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blkstd::string::size_type size = v11;
  *(timespec *)v17.st_qspare = v11;
  v17.st_birthtimespec = v11;
  *(timespec *)&v17.st_std::string::size_type size = v11;
  v17.st_mtimespec = v11;
  v17.st_ctimespec = v11;
  *(timespec *)&v17.st_uid = v11;
  v17.st_atimespec = v11;
  *(timespec *)&v17.st_dev = v11;
  if (v16 >= 0) {
    xpc_object_t v12 = __p;
  }
  else {
    xpc_object_t v12 = (void **)__p[0];
  }
  int v13 = stat((const char *)v12, &v17);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  return v13 == 0;
}

void sub_1A6168E9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingCommon::getFileSize(uint64_t a1, xpc_object_t *a2, uint64_t *a3)
{
  if (MEMORY[0x1A6275E60](*a2) != MEMORY[0x1E4F14590])
  {
    long long v6 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    long long v8 = "Received null input";
LABEL_21:
    _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&buf, 2u);
    return 0;
  }
  if (!xpc_dictionary_get_value(*a2, "kKeyFileSize") || !xpc_dictionary_get_value(*a2, "kKeyFileSegmentMode"))
  {
    if (xpc_dictionary_get_value(*a2, "kKeyFileSize"))
    {
      memset(&buf, 170, sizeof(buf));
      char v18 = 8;
      strcpy((char *)__p, "FileSize");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)__p, &buf);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      int v16 = 0;
      util::convert<unsigned int>(&buf, &v16, 0);
      xpc_object_t value = xpc_dictionary_get_value(*a2, "kKeyFileSize");
      xpc_object_t object = value;
      if (value) {
        xpc_retain(value);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      *a3 = xpc::dyn_cast_or_default();
      xpc_release(object);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
        return 1;
      }
    }
    else if (xpc_dictionary_get_value(*a2, "kKeyFileSegmentMode"))
    {
      xpc_object_t v10 = xpc_dictionary_get_value(*a2, "kKeyFileSegmentMode");
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
      if (v10) {
        xpc_retain(v10);
      }
      else {
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      }
      int v11 = xpc::dyn_cast_or_default();
      xpc_release(buf.__r_.__value_.__l.__data_);
      if ((v11 - 1) < 2 || v11)
      {
        uint64_t v14 = capabilities::trace::defaultFileSizeBytes(v12);
      }
      else
      {
        int v13 = (capabilities::abs *)capabilities::radio::vendor(v12);
        if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v13)) {
          uint64_t v14 = 0x4000;
        }
        else {
          uint64_t v14 = 0x8000;
        }
      }
      *a3 = v14;
      return 1;
    }
    return 1;
  }
  long long v6 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (result)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    long long v8 = "Both file-size and chunk mode are passed";
    goto LABEL_21;
  }
  return result;
}

void sub_1A616917C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, char a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

uint64_t abm::CellularLoggingCommon::convertFileSegmentModeToSize(capabilities::trace *a1, int a2)
{
  if ((a2 - 1) < 2 || a2)
  {
    return capabilities::trace::defaultFileSizeBytes(a1);
  }
  else
  {
    long long v3 = (capabilities::abs *)capabilities::radio::vendor(a1);
    if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v3)) {
      return 0x4000;
    }
    else {
      return 0x8000;
    }
  }
}

uint64_t abm::CellularLoggingCommon::setIsAppEntitled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 128) = a2;
  return this;
}

void *ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0CCB0;
  MEMORY[0x1A6274710](a1 + 1);
  return a1;
}

void ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0CCB0;
  MEMORY[0x1A6274710](a1 + 1);

  operator delete(a1);
}

uint64_t __cxx_global_var_init_31_0()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

uint64_t _GLOBAL__sub_I_CellularLoggingCommon_mm()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  dword_1EB5EEA8C = result;
  return result;
}

void abm::ProfileManagementTask::~ProfileManagementTask(abm::ProfileManagementTask *this)
{
  *(void *)this = &unk_1EFB0CD28;
  uint64_t v2 = *((void *)this + 18);
  if (v2) {
    dispatch_release(v2);
  }
  *(void *)this = &unk_1EFB0FCB8;
  long long v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  size_t v4 = *((void *)this + 14);
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)this = &unk_1EFB09350;
  MEMORY[0x1A6274710]((char *)this + 8);
  long long v5 = *((void *)this + 12);
  if (v5) {
    dispatch_release(v5);
  }
  long long v6 = *((void *)this + 11);
  if (v6) {
    dispatch_release(v6);
  }
  timespec v7 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

{
  void *v1;
  uint64_t vars8;

  abm::ProfileManagementTask::~ProfileManagementTask(this);

  operator delete(v1);
}

void *abm::ProfileManagementTask::getName(abm::ProfileManagementTask *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_16, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&_MergedGlobals_16))
  {
    return qword_1EB5EEAA0;
  }
  unsigned int v3 = *((_DWORD *)this + 26) - 1;
  if (v3 > 9) {
    size_t v4 = "invalid";
  }
  else {
    size_t v4 = off_1E5C47C38[v3];
  }
  std::string::basic_string[abi:ne180100]<0>(qword_1EB5EEAA0, v4);
  __cxa_atexit(MEMORY[0x1E4FBA210], qword_1EB5EEAA0, &dword_1A609F000);
  __cxa_guard_release(&_MergedGlobals_16);
  return qword_1EB5EEAA0;
}

void sub_1A61694F0(_Unwind_Exception *a1)
{
}

void *abm::ProfileManagementTask::ProfileManagementTask(void *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  long long v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v12 = *a3;
  int v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v10 = *a4;
  int v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v12, &v10);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  timespec v7 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *a1 = &unk_1EFB0CD28;
  long long v8 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  a1[18] = dispatch_queue_create("profile.task.queue", v8);
  return a1;
}

void sub_1A6169608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::init_sync(abm::ProfileManagementTask *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (v3 = *((void *)this + 9), (size_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  long long v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v41 = 0;
    std::string v42 = 0;
    long long v6 = (std::__shared_weak_count *)*((void *)this + 16);
    if (v6) {
      goto LABEL_5;
    }
LABEL_8:
    timespec v7 = 0;
    goto LABEL_9;
  }
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v5);
  uint64_t v41 = 0;
  std::string v42 = 0;
  long long v6 = (std::__shared_weak_count *)*((void *)this + 16);
  if (!v6) {
    goto LABEL_8;
  }
LABEL_5:
  timespec v7 = std::__shared_weak_count::lock(v6);
  std::string v42 = v7;
  if (v7)
  {
    uint64_t v8 = *((void *)this + 15);
    uint64_t v41 = v8;
    goto LABEL_10;
  }
LABEL_9:
  uint64_t v8 = 0;
LABEL_10:
  *((void *)this + 17) = 0;
  abm::ProfileManagementTask::registerForNotifications_sync(this);
  v40[23] = 18;
  strcpy(v40, "CommandReadProfile");
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke;
  aBlock[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  aBlock[4] = this;
  void aBlock[5] = v3;
  uint64_t v38 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v9 = _Block_copy(aBlock);
  uint64_t v10 = *((void *)this + 11);
  if (v10) {
    dispatch_retain(*((dispatch_object_t *)this + 11));
  }
  v39[0] = v9;
  v39[1] = v10;
  abm::HelperServerInternal::setCommandHandler(v8, (uint64_t)v40, (uint64_t)v39);
  if (v10) {
    dispatch_release(v10);
  }
  if (v9) {
    _Block_release(v9);
  }
  v36[23] = 19;
  strcpy(v36, "CommandApplyProfile");
  v33[0] = MEMORY[0x1E4F143A8];
  v33[1] = 3321888768;
  v33[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_3;
  v33[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v33[4] = this;
  v33[5] = v3;
  int v34 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v11 = _Block_copy(v33);
  uint64_t v12 = *((void *)this + 11);
  if (v12) {
    dispatch_retain(*((dispatch_object_t *)this + 11));
  }
  v35[0] = v11;
  v35[1] = v12;
  abm::HelperServerInternal::setCommandHandler(v8, (uint64_t)v36, (uint64_t)v35);
  if (v12) {
    dispatch_release(v12);
  }
  if (v11) {
    _Block_release(v11);
  }
  int v13 = (char *)operator new(0x19uLL);
  uint64_t v31 = v13;
  long long v32 = xmmword_1A61F7590;
  strcpy(v13, "CheckIfProfileInstalled");
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3321888768;
  v28[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_2;
  v28[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v28[4] = this;
  v28[5] = v3;
  unint64_t v29 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v14 = _Block_copy(v28);
  uint64_t v15 = *((void *)this + 11);
  if (v15) {
    dispatch_retain(*((dispatch_object_t *)this + 11));
  }
  v30[0] = v14;
  v30[1] = v15;
  abm::HelperServerInternal::setCommandHandler(v8, (uint64_t)&v31, (uint64_t)v30);
  if (v15) {
    dispatch_release(v15);
  }
  if (v14) {
    _Block_release(v14);
  }
  operator delete(v13);
  v27[23] = 21;
  strcpy(v27, "CommandInstallProfile");
  v24[0] = MEMORY[0x1E4F143A8];
  v24[1] = 3321888768;
  std::string v24[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_5;
  _OWORD v24[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v24[4] = this;
  v24[5] = v3;
  unint64_t v25 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v16 = _Block_copy(v24);
  stat v17 = *((void *)this + 11);
  if (v17) {
    dispatch_retain(*((dispatch_object_t *)this + 11));
  }
  v26[0] = v16;
  v26[1] = v17;
  abm::HelperServerInternal::setCommandHandler(v8, (uint64_t)v27, (uint64_t)v26);
  if (v17) {
    dispatch_release(v17);
  }
  if (v16) {
    _Block_release(v16);
  }
  v23[23] = 16;
  strcpy(v23, "UninstallProfile");
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3321888768;
  void v20[2] = ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_6;
  void v20[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e242_v48__0_ServerClientState__shared_ptr_TelephonyXPC::ServerClientState::State____State_____shared_weak_count___8_dict__object__v__24_callback_void_____int__xpc::dict____block_void_____int__xpc::dict_______queue__object___dispatch_object_s____32l;
  v20[4] = this;
  v20[5] = v3;
  xpc_object_t v21 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  char v18 = _Block_copy(v20);
  uint64_t v19 = *((void *)this + 11);
  if (v19) {
    dispatch_retain(v19);
  }
  v22[0] = v18;
  v22[1] = v19;
  abm::HelperServerInternal::setCommandHandler(v8, (uint64_t)v23, (uint64_t)v22);
  if (v19) {
    dispatch_release(v19);
  }
  if (v18) {
    _Block_release(v18);
  }
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A6169B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,std::__shared_weak_count *a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a17);
  if (a16)
  {
    std::__shared_weak_count::__release_weak(a16);
    std::string v55 = a28;
    if (!a28)
    {
LABEL_3:
      xpc_object_t v56 = a40;
      if (!a40) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else
  {
    std::string v55 = a28;
    if (!a28) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v55);
  xpc_object_t v56 = a40;
  if (!a40)
  {
LABEL_4:
    xpc_object_t v57 = a52;
    if (!a52) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  std::__shared_weak_count::__release_weak(v56);
  xpc_object_t v57 = a52;
  if (!a52)
  {
LABEL_5:
    long long v58 = *(std::__shared_weak_count **)(v53 - 184);
    if (!v58) {
      goto LABEL_6;
    }
    goto LABEL_11;
  }
LABEL_10:
  std::__shared_weak_count::__release_weak(v57);
  long long v58 = *(std::__shared_weak_count **)(v53 - 184);
  if (!v58)
  {
LABEL_6:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v53 - 128);
    std::__shared_weak_count::__release_weak(v52);
    _Unwind_Resume(a1);
  }
LABEL_11:
  std::__shared_weak_count::__release_weak(v58);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v53 - 128);
  std::__shared_weak_count::__release_weak(v52);
  _Unwind_Resume(a1);
}

void sub_1A6169C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a52) {
    JUMPOUT(0x1A6169C44);
  }
  JUMPOUT(0x1A6169BA0);
}

void sub_1A6169C88()
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback(v0 - 176);
  if (*(void *)(v0 - 184)) {
    JUMPOUT(0x1A6169C50);
  }
  JUMPOUT(0x1A6169BA8);
}

void sub_1A6169CA4(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v2 - 128);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::registerForNotifications_sync(abm::ProfileManagementTask *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2 || (v3 = *((void *)this + 9), (size_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  long long v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0) {
    abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync((NSObject **)this);
  }
  long long v6 = *((void *)this + 11);
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3321888768;
  handler[2] = ___ZN3abm21ProfileManagementTask29registerForNotifications_syncEv_block_invoke;
  handler[3] = &__block_descriptor_56_e8_40c41_ZTSNSt3__18weak_ptrIN3abm10HelperTaskEEE_e9_v16__0_v8l;
  handler[4] = this;
  handler[5] = v3;
  uint64_t v8 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  xpc_set_event_stream_handler("com.apple.notifyd.matching", v6, handler);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A6169DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    std::__shared_weak_count::__release_weak(a16);
    std::__shared_weak_count::__release_weak(v16);
    _Unwind_Resume(a1);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    timespec v7 = (dispatch_object_t *)a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v5);
    stat v17 = v8;
    if (v8)
    {
      int v9 = v8;
      if (!a1[5])
      {
LABEL_20:
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      uint64_t v10 = v7[14];
      if (v10)
      {
        dispatch_retain(v7[14]);
        dispatch_group_enter(v10);
      }
      abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v7, &object);
      if (*(void *)a4) {
        int v11 = _Block_copy(*(const void **)a4);
      }
      else {
        int v11 = 0;
      }
      uint64_t v12 = *(NSObject **)(a4 + 8);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3321888768;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1;
      block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v11)
      {
        int v13 = _Block_copy(v11);
        int v21 = 0;
        xpc_object_t v14 = object;
        aBlocuint64_t k = v13;
        xpc_object_t v20 = object;
        if (object)
        {
LABEL_11:
          xpc_retain(v14);
LABEL_14:
          dispatch_async(v12, block);
          xpc_release(v20);
          xpc_object_t v20 = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v11) {
            _Block_release(v11);
          }
          xpc_release(object);
          xpc_object_t object = 0;
          if (v10)
          {
            dispatch_group_leave(v10);
            dispatch_release(v10);
          }
          goto LABEL_20;
        }
      }
      else
      {
        int v21 = 0;
        xpc_object_t v14 = object;
        aBlocuint64_t k = 0;
        xpc_object_t v20 = object;
        if (object) {
          goto LABEL_11;
        }
      }
      xpc_object_t v20 = xpc_null_create();
      goto LABEL_14;
    }
  }
}

void sub_1A616A008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10)
  {
    dispatch_group_leave(v10);
    dispatch_release(v10);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::ProfileManagementTask::readProfile_sync(abm::ProfileManagementTask *this@<X0>, xpc_object_t *a2@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *a2 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a2 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A6275E60](v5) == MEMORY[0x1E4F14590])
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *a2 = v6;
LABEL_9:
  xpc_release(v5);
  id v7 = objc_alloc_init(MEMORY[0x1E4F1CB18]);
  if (!v7) {
    return;
  }
  objc_msgSend(v7, "addSuiteNamed:", objc_msgSend(NSString, "stringWithUTF8String:", "com.apple.commcenter"));
  uint64_t v8 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", "EnableBasebandLogging"));
  int v9 = v8;
  if (v8)
  {
    __p[0] = v8;
    CFRetain(v8);
    ctu::cf_to_xpc((uint64_t *)&value, v9, v10);
    xpc_dictionary_set_value(*a2, "EnableBasebandLogging", value);
    xpc_object_t v11 = value;
    xpc_object_t value = xpc_null_create();
    xpc_release(v11);
    xpc_release(value);
    xpc_object_t value = 0;
    CFRelease(v9);
  }
  uint64_t v12 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", "TelephonyLoggingVersion", __p[0]));
  int v13 = v12;
  if (v12)
  {
    __p[0] = v12;
    CFRetain(v12);
    ctu::cf_to_xpc((uint64_t *)&object, v13, v14);
    xpc_dictionary_set_value(*a2, "TelephonyLoggingVersion", object);
    xpc_object_t v15 = object;
    xpc_object_t object = xpc_null_create();
    xpc_release(v15);
    xpc_release(object);
    xpc_object_t object = 0;
    CFRelease(v13);
  }
  int v16 = (ctu *)objc_msgSend(v7, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", "TelephonyLoggingPriority", __p[0]));
  stat v17 = v16;
  if (v16)
  {
    __p[0] = v16;
    CFRetain(v16);
    ctu::cf_to_xpc((uint64_t *)&v24, v17, v18);
    xpc_dictionary_set_value(*a2, "TelephonyLoggingPriority", v24);
    xpc_object_t v19 = v24;
    xpc_object_t v24 = xpc_null_create();
    xpc_release(v19);
    xpc_release(v24);
    xpc_object_t v24 = 0;
    CFRelease(v17);
    goto LABEL_17;
  }
  if ((unint64_t)v9 | (unint64_t)v13)
  {
LABEL_17:
    xpc_object_t v20 = *((void *)this + 5);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      xpc::object::to_string((uint64_t *)__p, (xpc::object *)a2);
      if (v23 >= 0) {
        int v21 = __p;
      }
      else {
        int v21 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v28 = v21;
      _os_log_impl(&dword_1A609F000, v20, OS_LOG_TYPE_DEFAULT, "#I Logging profile: %s ", buf, 0xCu);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1A616A33C(_Unwind_Exception *a1)
{
  xpc::dict::~dict(v1);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_3(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    id v7 = (dispatch_object_t *)a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v5);
    char v18 = v8;
    if (v8)
    {
      int v9 = v8;
      if (!a1[5])
      {
LABEL_20:
        if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        return;
      }
      uint64_t v10 = v7[14];
      if (v10)
      {
        dispatch_retain(v7[14]);
        dispatch_group_enter(v10);
      }
      abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v7, &v15);
      abm::ProfileManagementTask::convertToTraceProperties_sync((uint64_t)v7, &v15, 0, &object);
      abm::ProfileManagementTask::applyTraceProperties_sync((uint64_t)v7, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v15);
      xpc_object_t v15 = 0;
      xpc_object_t v11 = xpc_null_create();
      if (*(void *)a4) {
        uint64_t v12 = _Block_copy(*(const void **)a4);
      }
      else {
        uint64_t v12 = 0;
      }
      int v13 = *(NSObject **)(a4 + 8);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3321888768;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1;
      block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v12)
      {
        xpc_object_t v14 = _Block_copy(v12);
        int v22 = 0;
        aBlocuint64_t k = v14;
        xpc_object_t v21 = v11;
        if (v11)
        {
LABEL_11:
          xpc_retain(v11);
LABEL_14:
          dispatch_async(v13, block);
          xpc_release(v21);
          xpc_object_t v21 = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v12) {
            _Block_release(v12);
          }
          xpc_release(v11);
          if (v10)
          {
            dispatch_group_leave(v10);
            dispatch_release(v10);
          }
          goto LABEL_20;
        }
      }
      else
      {
        int v22 = 0;
        aBlocuint64_t k = 0;
        xpc_object_t v21 = v11;
        if (v11) {
          goto LABEL_11;
        }
      }
      xpc_object_t v21 = xpc_null_create();
      goto LABEL_14;
    }
  }
}

void sub_1A616A60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, char a12)
{
  xpc_release(object);
  xpc_release(a10);
  if (v12)
  {
    dispatch_group_leave(v12);
    dispatch_release(v12);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t abm::ProfileManagementTask::applyTraceProperties_sync(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = MEMORY[0x1A6275E60](*a2);
  uint64_t v5 = MEMORY[0x1E4F14568];
  if (v4 != MEMORY[0x1E4F14568] || MEMORY[0x1A6275E60](*a2) != v5 || !xpc_array_get_count(*a2))
  {
    char v6 = 0;
    return v6 & 1;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)a2);
    int v9 = SHIBYTE(__p[2]) >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Applying trace properties: %s", buf, 0xCu);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  HIBYTE(__p[2]) = 17;
  strcpy((char *)__p, "ProfileManagement");
  abm::client::CreateManager();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  uint64_t v31 = (char *)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v10 = *a2;
  if (*a2)
  {
    xpc_retain(*a2);
    xpc_object_t object = v10;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t object = v10;
    if (!v10)
    {
      xpc_object_t v10 = 0;
      xpc_object_t object = xpc_null_create();
      goto LABEL_18;
    }
  }
  xpc_retain(v10);
LABEL_18:
  uint64_t v31 = 0;
  xpc_release(v10);
  xpc_object_t v11 = (const char *)*MEMORY[0x1E4F4C0F8];
  char v6 = 1;
  while (1)
  {
    xpc_object_t v12 = *a2;
    if (*a2) {
      xpc_retain(*a2);
    }
    else {
      xpc_object_t v12 = xpc_null_create();
    }
    if (MEMORY[0x1A6275E60](*a2) == v5)
    {
      size_t count = xpc_array_get_count(*a2);
      if (!v12)
      {
LABEL_28:
        xpc_object_t v14 = xpc_null_create();
        goto LABEL_29;
      }
    }
    else
    {
      size_t count = 0;
      if (!v12) {
        goto LABEL_28;
      }
    }
    xpc_retain(v12);
    xpc_object_t v14 = v12;
LABEL_29:
    xpc_release(v12);
    xpc_object_t v16 = object;
    xpc_object_t v15 = v31;
    xpc_release(v14);
    if (v15 == (char *)count && v16 == v14) {
      break;
    }
    xpc_object_t xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    __p[0] = &object;
    __p[1] = v31;
    xpc::array::object_proxy::operator xpc::dict((uint64_t)__p, &xdict);
    xpc_object_t v17 = xpc_int64_create(3000);
    if (!v17) {
      xpc_object_t v17 = xpc_null_create();
    }
    xpc_dictionary_set_value(xdict, v11, v17);
    xpc_object_t v18 = xpc_null_create();
    xpc_release(v17);
    xpc_release(v18);
    xpc_object_t v19 = xpc_BOOL_create(0);
    if (!v19) {
      xpc_object_t v19 = xpc_null_create();
    }
    xpc_dictionary_set_value(xdict, "kKeyTracePropertyWaitForCompletion", v19);
    xpc_object_t v20 = xpc_null_create();
    xpc_release(v19);
    xpc_release(v20);
    memset(buf, 170, 24);
    xpc_object_t value = xpc_dictionary_get_value(xdict, "kKeyTraceName");
    __p[0] = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      __p[0] = xpc_null_create();
    }
    xpc::dyn_cast_or_default();
    xpc_release(__p[0]);
    *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)std::string __p = v22;
    *(_OWORD *)&std::vector<std::ssub_match> __p[2] = v22;
    std::string v27 = (std::__shared_weak_count *)v33;
    if (v33) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
    }
    int64_t v26 = (char *)operator new(0x20uLL);
    strcpy(v26, "kCommandSetTraceProperty");
    abm::client::PerformCommand();
    operator delete(v26);
    if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
      BOOL v23 = LODWORD(__p[0]) == 0;
      if (SHIBYTE(__p[3]) < 0)
      {
LABEL_47:
        operator delete(__p[1]);
        if (((char)buf[23] & 0x80000000) == 0) {
          goto LABEL_44;
        }
        goto LABEL_48;
      }
    }
    else
    {
      BOOL v23 = LODWORD(__p[0]) == 0;
      if (SHIBYTE(__p[3]) < 0) {
        goto LABEL_47;
      }
    }
    if (((char)buf[23] & 0x80000000) == 0) {
      goto LABEL_44;
    }
LABEL_48:
    operator delete(*(void **)buf);
LABEL_44:
    xpc_release(xdict);
    xpc_object_t v24 = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t v24 = xpc_null_create();
    }
    v6 &= v23;
    ++v31;
    xpc_release(v24);
  }
  xpc_release(object);
  unint64_t v25 = (std::__shared_weak_count *)v33;
  if (v33 && !atomic_fetch_add((atomic_ullong *volatile)(v33 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  return v6 & 1;
}

void sub_1A616AB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,xpc_object_t object,xpc_object_t a29,uint64_t a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void abm::ProfileManagementTask::convertToTraceProperties_sync(uint64_t a1@<X0>, void **a2@<X1>, int a3@<W2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v8 = xpc_null_create();
  *a4 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v9 = xpc_array_create(0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    *a4 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    *a4 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A6275E60](v10) == MEMORY[0x1E4F14568])
  {
    xpc_retain(v10);
    goto LABEL_9;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_8:
  *a4 = v11;
LABEL_9:
  xpc_release(v10);
  xpc_object_t v43 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)a2;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)"EnableBasebandLogging";
  xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &v43);
  uint64_t v12 = MEMORY[0x1A6275E60](v43);
  uint64_t v13 = MEMORY[0x1E4F14590];
  xpc_object_t v14 = *(NSObject **)(a1 + 40);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v12 == v13)
  {
    if (v15)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I Logging profile found", (uint8_t *)&buf, 2u);
    }
    xpc_object_t v21 = *a2;
    xpc_object_t object = v21;
    if (v21) {
      xpc_retain(v21);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    logs::convertToTraceProperties((std::string::size_type)&object, (xpc_object_t *)&buf.__r_.__value_.__l.__data_);
    std::string::size_type v22 = buf.__r_.__value_.__r.__words[0];
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    xpc_object_t v23 = *a4;
    *a4 = (xpc_object_t)v22;
    xpc_release(v23);
    xpc_release(buf.__r_.__value_.__l.__data_);
    buf.__r_.__value_.__r.__words[0] = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_object_t v24 = xpc_dictionary_create(0, 0, 0);
    if (v24 || (xpc_object_t v24 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v24) == v13)
      {
        xpc_retain(v24);
        xpc_object_t v20 = v24;
      }
      else
      {
        xpc_object_t v20 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v24 = 0;
    }
    xpc_release(v24);
    xpc_object_t v25 = xpc_null_create();
    xpc_release(v8);
    xpc_release(v25);
    xpc_object_t v26 = xpc_string_create("Profile");
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    xpc_dictionary_set_value(v20, "kKeyTraceName", v26);
    xpc_object_t v27 = xpc_null_create();
    xpc_release(v26);
    xpc_release(v27);
    xpc_object_t v28 = xpc_string_create((const char *)*MEMORY[0x1E4F4C0E0]);
    if (!v28) {
      xpc_object_t v28 = xpc_null_create();
    }
    xpc_dictionary_set_value(v20, "kKeyTracePropertyName", v28);
    xpc_object_t v29 = xpc_null_create();
    xpc_release(v28);
    xpc_release(v29);
    memset(&__p, 0, sizeof(__p));
    std::to_string(&buf, 1);
    std::string __p = buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v31 = xpc_string_create((const char *)p_p);
    if (!v31) {
      xpc_object_t v31 = xpc_null_create();
    }
    xpc_dictionary_set_value(v20, "kKeyTracePropertyValue", v31);
    xpc_object_t v32 = xpc_null_create();
    xpc_release(v31);
    xpc_release(v32);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    xpc_array_append_value(*a4, v20);
  }
  else
  {
    if (v15)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_1A609F000, v14, OS_LOG_TYPE_DEFAULT, "#I No Logging profile found", (uint8_t *)&buf, 2u);
    }
    if (a3)
    {
      xpc_object_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Load the default trace properties", (uint8_t *)&buf, 2u);
      }
      logs::getDefaultTraceProperties((xpc_object_t *)&buf.__r_.__value_.__l.__data_);
      std::string::size_type v17 = buf.__r_.__value_.__r.__words[0];
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
      xpc_object_t v18 = *a4;
      *a4 = (xpc_object_t)v17;
      xpc_release(v18);
      xpc_release(buf.__r_.__value_.__l.__data_);
      xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
      if (v19 || (xpc_object_t v19 = xpc_null_create()) != 0)
      {
        if (MEMORY[0x1A6275E60](v19) == v13)
        {
          xpc_retain(v19);
          xpc_object_t v20 = v19;
        }
        else
        {
          xpc_object_t v20 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v20 = xpc_null_create();
        xpc_object_t v19 = 0;
      }
      xpc_release(v19);
      xpc_object_t v33 = xpc_null_create();
      xpc_release(v8);
      xpc_release(v33);
      xpc_object_t v34 = xpc_string_create("Profile");
      if (!v34) {
        xpc_object_t v34 = xpc_null_create();
      }
      xpc_dictionary_set_value(v20, "kKeyTraceName", v34);
      xpc_object_t v35 = xpc_null_create();
      xpc_release(v34);
      xpc_release(v35);
      xpc_object_t v36 = xpc_string_create((const char *)*MEMORY[0x1E4F4C0E0]);
      if (!v36) {
        xpc_object_t v36 = xpc_null_create();
      }
      xpc_dictionary_set_value(v20, "kKeyTracePropertyName", v36);
      xpc_object_t v37 = xpc_null_create();
      xpc_release(v36);
      xpc_release(v37);
      std::to_string(&buf, 0);
      std::string __p = buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v38 = &__p;
      }
      else {
        uint64_t v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      xpc_object_t v39 = xpc_string_create((const char *)v38);
      if (!v39) {
        xpc_object_t v39 = xpc_null_create();
      }
      xpc_dictionary_set_value(v20, "kKeyTracePropertyValue", v39);
      xpc_object_t v40 = xpc_null_create();
      xpc_release(v39);
      xpc_release(v40);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      xpc_array_append_value(*a4, v20);
    }
    else
    {
      xpc_object_t v20 = v8;
    }
  }
  xpc_release(v43);
  xpc_release(v20);
}

void sub_1A616B25C(void *a1)
{
}

void sub_1A616B268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t object)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  xpc::array::~array(v17);
  xpc_release(v18);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_2(void *a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (NSObject **)a1[4];
  uint64_t v34 = 0;
  xpc_object_t v35 = 0;
  char v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    xpc_object_t v35 = std::__shared_weak_count::lock(v6);
    if (!v35) {
      return;
    }
    uint64_t v34 = a1[5];
    if (v34)
    {
      xpc_object_t v9 = v5[14];
      if (v9)
      {
        dispatch_retain(v5[14]);
        dispatch_group_enter(v9);
      }
      memset(__p, 170, sizeof(__p));
      xpc_object_t value = xpc_dictionary_get_value(*a3, "ProfileName");
      *(void *)&long long object = value;
      if (value) {
        xpc_retain(value);
      }
      else {
        *(void *)&long long object = xpc_null_create();
      }
      xpc::dyn_cast_or_default();
      xpc_release((xpc_object_t)object);
      xpc_object_t v11 = (void *)HIBYTE(__p[2]);
      char v12 = HIBYTE(__p[2]);
      if (SHIBYTE(__p[2]) < 0) {
        xpc_object_t v11 = __p[1];
      }
      if (v11)
      {
        int v32 = -1431655766;
        uint64_t v13 = v5[5];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v14 = (void **)__p[0];
          if (SHIBYTE(__p[2]) >= 0) {
            xpc_object_t v14 = __p;
          }
          LODWORD(object) = 136315138;
          *(void *)((char *)&object + 4) = v14;
          _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Checking if profile installed: name [%s]", (uint8_t *)&object, 0xCu);
          char v12 = HIBYTE(__p[2]);
        }
        if (v12 >= 0) {
          BOOL v15 = __p;
        }
        else {
          BOOL v15 = (void **)__p[0];
        }
        char v16 = abm::ProfileManagementTask::checkifProfileInstalled_sync(v5, (const char *)v15, &v32);
        xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
        if (v17 || (xpc_object_t v17 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v17) == MEMORY[0x1E4F14590])
          {
            xpc_retain(v17);
            xpc_object_t v18 = v17;
          }
          else
          {
            xpc_object_t v18 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v17 = 0;
        }
        xpc_release(v17);
        xpc_object_t v24 = xpc_BOOL_create(v16);
        if (!v24) {
          xpc_object_t v24 = xpc_null_create();
        }
        xpc_dictionary_set_value(v18, "ProfileIsInstalled", v24);
        xpc_object_t v25 = xpc_null_create();
        xpc_release(v24);
        xpc_release(v25);
        if (v18)
        {
          xpc_retain(v18);
          xpc_object_t v26 = v18;
          xpc_object_t v27 = *(const void **)a4;
          if (*(void *)a4)
          {
LABEL_44:
            xpc_object_t v28 = _Block_copy(v27);
            goto LABEL_47;
          }
        }
        else
        {
          xpc_object_t v26 = xpc_null_create();
          xpc_object_t v27 = *(const void **)a4;
          if (*(void *)a4) {
            goto LABEL_44;
          }
        }
        xpc_object_t v28 = 0;
LABEL_47:
        xpc_object_t v29 = *(NSObject **)(a4 + 8);
        *(void *)&long long object = MEMORY[0x1E4F143A8];
        *((void *)&object + 1) = 3321888768;
        xpc_object_t v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
        uint64_t v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
        if (v28)
        {
          unint64_t v30 = _Block_copy(v28);
          int v41 = 0;
          aBlocuint64_t k = v30;
          xpc_object_t v40 = v26;
          if (v26)
          {
LABEL_49:
            xpc_retain(v26);
LABEL_52:
            dispatch_async(v29, &object);
            xpc_release(v40);
            xpc_object_t v40 = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v28) {
              _Block_release(v28);
            }
            xpc_release(v26);
            xpc_release(v18);
LABEL_57:
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
            if (v9)
            {
              dispatch_group_leave(v9);
              dispatch_release(v9);
            }
            goto LABEL_61;
          }
        }
        else
        {
          int v41 = 0;
          aBlocuint64_t k = 0;
          xpc_object_t v40 = v26;
          if (v26) {
            goto LABEL_49;
          }
        }
        xpc_object_t v40 = xpc_null_create();
        goto LABEL_52;
      }
      xpc_object_t v19 = v5[5];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(object) = 0;
        _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Requested profile info is empty", (uint8_t *)&object, 2u);
      }
      xpc_object_t v20 = xpc_null_create();
      if (*(void *)a4) {
        xpc_object_t v21 = _Block_copy(*(const void **)a4);
      }
      else {
        xpc_object_t v21 = 0;
      }
      std::string::size_type v22 = *(NSObject **)(a4 + 8);
      *(void *)&long long object = MEMORY[0x1E4F143A8];
      *((void *)&object + 1) = 3321888768;
      xpc_object_t v37 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
      uint64_t v38 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v21)
      {
        xpc_object_t v23 = _Block_copy(v21);
        int v41 = -534716414;
        aBlocuint64_t k = v23;
        xpc_object_t v40 = v20;
        if (v20)
        {
LABEL_31:
          xpc_retain(v20);
LABEL_34:
          dispatch_async(v22, &object);
          xpc_release(v40);
          xpc_object_t v40 = 0;
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v21) {
            _Block_release(v21);
          }
          xpc_release(v20);
          goto LABEL_57;
        }
      }
      else
      {
        int v41 = -534716414;
        aBlocuint64_t k = 0;
        xpc_object_t v40 = v20;
        if (v20) {
          goto LABEL_31;
        }
      }
      xpc_object_t v40 = xpc_null_create();
      goto LABEL_34;
    }
  }
LABEL_61:
  xpc_object_t v31 = v35;
  if (v35)
  {
    if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
}

void sub_1A616B8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t abm::ProfileManagementTask::checkifProfileInstalled_sync(NSObject **this, const char *a2, int *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  abm::sProfileInfoList((abm *)this);
  size_t v6 = strlen(a2);
  id v7 = (abm *)strncasecmp(a2, *(const char **)qword_1EB5EEAB8, v6);
  if (!v7)
  {
    unsigned int v11 = 0;
    goto LABEL_7;
  }
  abm::sProfileInfoList(v7);
  size_t v8 = strlen(a2);
  id v7 = (abm *)strncasecmp(a2, *(const char **)(qword_1EB5EEAB8 + 24), v8);
  if (!v7)
  {
    unsigned int v11 = 1;
LABEL_7:
    abm::sProfileInfoList(v7);
    int v12 = *(_DWORD *)(qword_1EB5EEAB8 + 24 * v11 + 16);
    xpc_object_t object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)this, &object);
    if (MEMORY[0x1A6275E60](object) == MEMORY[0x1E4F14590])
    {
      xpc_object_t value = xpc_dictionary_get_value(object, "TelephonyLoggingPriority");
      *(void *)std::string buf = value;
      if (value) {
        xpc_retain(value);
      }
      else {
        *(void *)std::string buf = xpc_null_create();
      }
      int v15 = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      xpc_object_t v16 = xpc_dictionary_get_value(object, "TelephonyLoggingVersion");
      *(void *)std::string buf = v16;
      if (v16) {
        xpc_retain(v16);
      }
      else {
        *(void *)std::string buf = xpc_null_create();
      }
      *a3 = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      xpc_object_t v17 = this[5];
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v12 == v15)
      {
        if (v18)
        {
          int v19 = *a3;
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = a2;
          __int16 v22 = 1024;
          int v23 = v19;
          _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Installed profile name [%s] : version [%d] ", buf, 0x12u);
        }
        uint64_t v10 = 1;
        goto LABEL_9;
      }
      if (v18)
      {
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        __int16 v22 = 1024;
        int v23 = v12;
        __int16 v24 = 1024;
        int v25 = v15;
        _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Checking profile [%s: index %d] but installed profile index is [%d] ", buf, 0x18u);
      }
    }
    uint64_t v10 = 0;
LABEL_9:
    xpc_release(object);
    return v10;
  }
  xpc_object_t v9 = this[5];
  uint64_t v10 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#E Could not find info for profile: %s", buf, 0xCu);
    return 0;
  }
  return v10;
}

void sub_1A616BC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_5(void *a1, uint64_t a2, xpc_object_t *a3, NSObject **a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    size_t v8 = (NSObject **)a1[4];
    xpc_object_t v9 = std::__shared_weak_count::lock(v5);
    int v25 = v9;
    if (v9)
    {
      uint64_t v10 = v9;
      if (a1[5])
      {
        unsigned int v11 = v8[14];
        if (v11)
        {
          dispatch_retain(v8[14]);
          dispatch_group_enter(v11);
        }
        memset(&v23, 170, sizeof(v23));
        xpc_object_t value = xpc_dictionary_get_value(*a3, "ProfileName");
        *(void *)xpc_object_t object = value;
        if (value) {
          xpc_retain(value);
        }
        else {
          *(void *)xpc_object_t object = xpc_null_create();
        }
        xpc::dyn_cast_or_default();
        xpc_release(*(xpc_object_t *)object);
        xpc_object_t v13 = xpc_dictionary_get_value(*a3, "RequireUserConfirmation");
        *(void *)xpc_object_t object = v13;
        if (v13) {
          xpc_retain(v13);
        }
        else {
          *(void *)xpc_object_t object = xpc_null_create();
        }
        int v14 = xpc::dyn_cast_or_default();
        xpc_release(*(xpc_object_t *)object);
        int v15 = v8[5];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v16 = &v23;
          if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            xpc_object_t v16 = (std::string *)v23.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)xpc_object_t object = 136315394;
          *(void *)&object[4] = v16;
          *(_WORD *)&object[12] = 1024;
          *(_DWORD *)&object[14] = v14;
          _os_log_impl(&dword_1A609F000, v15, OS_LOG_TYPE_DEFAULT, "#I Install profile: %s, with confirmation %d", object, 0x12u);
        }
        uint64_t v17 = a1[6];
        *(void *)xpc_object_t object = a1[5];
        *(void *)&object[8] = v17;
        if (v17) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 16), 1uLL, memory_order_relaxed);
        }
        *(void *)&object[16] = v11;
        if (v11)
        {
          dispatch_retain(v11);
          if (*(void *)&object[16]) {
            dispatch_group_enter(*(dispatch_group_t *)&object[16]);
          }
        }
        LOBYTE(v29) = v14;
        *((void *)&v29 + 1) = v8;
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&__p, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v23;
        }
        BOOL v18 = *a4;
        if (*a4) {
          BOOL v18 = _Block_copy(v18);
        }
        int v19 = a4[1];
        v31[0] = v18;
        v31[1] = v19;
        if (v19) {
          dispatch_retain(v19);
        }
        xpc_object_t v20 = v8[18];
        xpc_object_t v21 = (char *)operator new(0x50uLL);
        uint64_t v22 = *(void *)&object[8];
        *(void *)xpc_object_t v21 = *(void *)object;
        *((void *)v21 + 1) = v22;
        if (v22) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 16), 1uLL, memory_order_relaxed);
        }
        *((void *)v21 + 2) = *(void *)&object[16];
        *(_OWORD *)(v21 + 24) = v29;
        *(std::string *)(v21 + 40) = __p;
        memset(&__p, 0, sizeof(__p));
        *((_OWORD *)v21 + 4) = *(_OWORD *)v31;
        *(void *)&object[16] = 0;
        v31[0] = 0;
        v31[1] = 0;
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        dispatch_async_f(v20, v21, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v26);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v27);
        if (v31[1]) {
          dispatch_release(v31[1]);
        }
        if (v31[0]) {
          _Block_release(v31[0]);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (*(void *)&object[16])
        {
          dispatch_group_leave(*(dispatch_group_t *)&object[16]);
          if (*(void *)&object[16]) {
            dispatch_release(*(dispatch_object_t *)&object[16]);
          }
        }
        if (*(void *)&object[8]) {
          std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&object[8]);
        }
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v23.__r_.__value_.__l.__data_);
        }
        if (v11)
        {
          dispatch_group_leave(v11);
          dispatch_release(v11);
        }
      }
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

void sub_1A616C018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object,std::__shared_weak_count *a21,dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v22)
  {
    dispatch_group_leave(v22);
    dispatch_release(v22);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask9init_syncEv_block_invoke_6(uint64_t a1, uint64_t a2, xpc_object_t *a3, NSObject **a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    xpc_object_t v9 = std::__shared_weak_count::lock(v5);
    xpc_object_t v33 = v9;
    if (v9)
    {
      uint64_t v10 = v9;
      if (!*(void *)(a1 + 40))
      {
LABEL_52:
        if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        return;
      }
      unsigned int v11 = *(NSObject **)(v8 + 112);
      if (v11)
      {
        dispatch_retain(*(dispatch_object_t *)(v8 + 112));
        dispatch_group_enter(v11);
      }
      memset(&v31, 170, sizeof(v31));
      xpc_object_t value = xpc_dictionary_get_value(*a3, "ProfileName");
      xpc_object_t object = value;
      if (value) {
        xpc_retain(value);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      xpc::dyn_cast_or_default();
      xpc_release(object);
      std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v31.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        int v14 = *(std::__shared_weak_count **)(a1 + 48);
        xpc_object_t object = *(xpc_object_t *)(a1 + 40);
        uint64_t v27 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        group[0] = v11;
        if (v11)
        {
          dispatch_retain(v11);
          dispatch_group_enter(group[0]);
        }
        group[1] = (dispatch_group_t)v8;
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&__p, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v31;
        }
        BOOL v18 = *a4;
        if (*a4) {
          BOOL v18 = _Block_copy(v18);
        }
        int v19 = a4[1];
        v30[0] = v18;
        v30[1] = v19;
        if (v19) {
          dispatch_retain(v19);
        }
        xpc_object_t v20 = *(NSObject **)(v8 + 144);
        xpc_object_t v21 = (char *)operator new(0x48uLL);
        uint64_t v22 = v27;
        *(void *)xpc_object_t v21 = object;
        *((void *)v21 + 1) = v22;
        if (v22) {
          atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        long long v23 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_OWORD *)v21 + 1) = *(_OWORD *)group;
        *((_OWORD *)v21 + 2) = v23;
        *((void *)v21 + 6) = *((void *)&__p.__r_.__value_.__l + 2);
        memset(&__p, 0, sizeof(__p));
        *(_OWORD *)(v21 + 56) = *(_OWORD *)v30;
        group[0] = 0;
        v30[0] = 0;
        v30[1] = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        dispatch_async_f(v20, v21, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v34);
        _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v35);
        if (v30[1]) {
          dispatch_release(v30[1]);
        }
        if (v30[0]) {
          _Block_release(v30[0]);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v27) {
          std::__shared_weak_count::__release_weak(v27);
        }
LABEL_48:
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        if (v11)
        {
          dispatch_group_leave(v11);
          dispatch_release(v11);
        }
        goto LABEL_52;
      }
      int v15 = *(NSObject **)(v8 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        LOWORD(object) = 0;
        _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "Requested profile info is empty", (uint8_t *)&object, 2u);
      }
      xpc_object_t v16 = xpc_null_create();
      if (*a4) {
        uint64_t v17 = _Block_copy(*a4);
      }
      else {
        uint64_t v17 = 0;
      }
      __int16 v24 = a4[1];
      xpc_object_t object = (xpc_object_t)MEMORY[0x1E4F143A8];
      uint64_t v27 = (std::__shared_weak_count *)3321888768;
      group[0] = (dispatch_group_t)___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
      group[1] = (dispatch_group_t)&__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
      if (v17)
      {
        int v25 = _Block_copy(v17);
        LODWORD(__p.__r_.__value_.__r.__words[2]) = -534716414;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v16;
        if (v16)
        {
LABEL_40:
          xpc_retain(v16);
LABEL_43:
          dispatch_async(v24, &object);
          xpc_release((xpc_object_t)__p.__r_.__value_.__l.__size_);
          __p.__r_.__value_.__l.__size_ = 0;
          if (__p.__r_.__value_.__r.__words[0]) {
            _Block_release(__p.__r_.__value_.__l.__data_);
          }
          if (v17) {
            _Block_release(v17);
          }
          xpc_release(v16);
          goto LABEL_48;
        }
      }
      else
      {
        LODWORD(__p.__r_.__value_.__r.__words[2]) = -534716414;
        __p.__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v16;
        if (v16) {
          goto LABEL_40;
        }
      }
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)xpc_null_create();
      goto LABEL_43;
    }
  }
}

void sub_1A616C4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, std::__shared_weak_count *a10, dispatch_group_t group, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (a10)
  {
    std::__shared_weak_count::__release_weak(a10);
    if ((a23 & 0x80000000) == 0) {
      goto LABEL_9;
    }
  }
  else if ((a23 & 0x80000000) == 0)
  {
LABEL_9:
    if (!v23) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  operator delete(__p);
  if (!v23)
  {
LABEL_11:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v24 - 80);
    _Unwind_Resume(a1);
  }
LABEL_10:
  dispatch_group_leave(v23);
  dispatch_release(v23);
  goto LABEL_11;
}

uint64_t abm::ProfileManagementTask::showMCProfileInstallNotification_sync(abm::ProfileManagementTask *this, const char *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!TelephonyUtilIsCarrierBuild() || (TelephonyUtilIsInternalBuild() & 1) != 0) {
    return 1;
  }
  uint64_t v5 = *((void *)this + 5);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1A609F000, v5, OS_LOG_TYPE_DEFAULT, "#I Checking [%s] logging profile notification", (uint8_t *)&buf, 0xCu);
  }
  abm::sProfileInfoList((abm *)v6);
  size_t v7 = strlen(a2);
  uint64_t v8 = (abm *)strncasecmp(a2, *(const char **)qword_1EB5EEAB8, v7);
  if (v8)
  {
    abm::sProfileInfoList(v8);
    size_t v9 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1EB5EEAB8 + 24), v9))
    {
      uint64_t v10 = *((void *)this + 5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        unsigned int v11 = "Profile notification skipped as we failed to get profile info";
LABEL_67:
        _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&buf, 2u);
        return 0;
      }
      return 0;
    }
    unsigned int v12 = 1;
  }
  else
  {
    unsigned int v12 = 0;
  }
  if ((abm::ProfileManagementTask::isProfileValid((NSObject **)this, v12) & 1) == 0)
  {
    uint64_t v10 = *((void *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unsigned int v11 = "Profile notification skipped as profile is not valid";
      goto LABEL_67;
    }
    return 0;
  }
  if ((abm::ProfileManagementTask::isAllowedToOverrideProfile((NSObject **)this, v12) & 1) == 0)
  {
    uint64_t v10 = *((void *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      unsigned int v11 = "Profile notification skipped as we want to keep pre-installed one";
      goto LABEL_67;
    }
    return 0;
  }
  if (*((void *)this + 17) && (unint64_t)(TelephonyUtilGetSystemTime() - *((void *)this + 17)) >> 6 < 0x753) {
    return 0;
  }
  xpc_object_t v13 = *((void *)this + 5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A609F000, v13, OS_LOG_TYPE_DEFAULT, "#I Asking for user confirmation to install profile", (uint8_t *)&buf, 2u);
  }
  int v14 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  [v14 setObject:@"Dismiss" forKeyedSubscript:*MEMORY[0x1E4F1D9E0]];
  uint64_t v15 = [NSString stringWithFormat:@"Update %s %@", a2, @"Logging Profile"];
  [v14 setObject:v15 forKeyedSubscript:*MEMORY[0x1E4F1D990]];
  [v14 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4F1D9B8]];
  [v14 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4FA7340]];
  [v14 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:*MEMORY[0x1E4FA7328]];
  [v14 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4FA73C8]];
  if (config::hw::watch((config::hw *)[v14 setObject:@"Install" forKeyedSubscript:*MEMORY[0x1E4F1D9D0]]))
  {
    uint64_t v16 = objc_msgSend(NSString, "stringWithUTF8String:", "The Telephony Logging Profile generates files that allow Apple to troubleshoot issues with your device and help Apple to improve its products and services. The generated files may contain some of your personal information, including contents of SMS's, device identifiers and names, the IP addresses and recent location history of your device, phone numbers of the registering device, Apple Accounts into which you are signed, and logs of incoming and outgoing calls and audio routes during the time the logging is enabled. If you install this profile, it will automatically turn the logging on and this data will be captured when you take a Sysdiagnose on this device. The data will not leave the device unless you initiate a Sysdiagnose and send the results. The profile will expire after 21 days. You will be able to turn on and off logging at any time while the Profile is installed. To turn off logging on your device, go to your iphone and watch app. By enabling this diagnostic tool and sending a copy of the generated files to Apple, you are consenting to Apple's use of the content of such files in accordance with its privacy policy (http://www.apple.com/legal/privacy).");
    [v14 setObject:v16 forKeyedSubscript:*MEMORY[0x1E4F1D9A8]];
    char v17 = 1;
  }
  else
  {
    int v19 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F74230], "sharedConnection"), "isProfileUIInstallationAllowed");
    char v17 = v19;
    if (v19) {
      xpc_object_t v20 = "Do you want to ";
    }
    else {
      xpc_object_t v20 = "Do you want to enable profile installation and ";
    }
    buf.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    buf.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAAAALL;
    if (v19) {
      size_t v21 = 15;
    }
    else {
      size_t v21 = 47;
    }
    buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    if (v19)
    {
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = 15;
      p_std::string buf = &buf;
    }
    else
    {
      p_std::string buf = (std::string *)operator new(0x30uLL);
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = xmmword_1A61F9D90;
    }
    memcpy(p_buf, v20, v21);
    p_buf->__r_.__value_.__s.__data_[v21] = 0;
    std::string::append(&buf, "install profile to avoid missing important logging information?", 0x3FuLL);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v23 = &buf;
    }
    else {
      long long v23 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v24 = [NSString stringWithUTF8String:v23];
    [v14 setObject:v24 forKeyedSubscript:*MEMORY[0x1E4F1D9A8]];
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  SInt32 error = 0;
  CFOptionFlags responseFlags = 3;
  int v25 = CFUserNotificationCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 600.0, 3uLL, &error, (CFDictionaryRef)v14);
  uint64_t v26 = v25;
  if (v25) {
    uint64_t v27 = ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get;
  }
  else {
    uint64_t v27 = 0;
  }
  SInt32 v28 = error;
  if (!v27 || error)
  {
    std::string v31 = *((void *)this + 5);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v28;
      _os_log_error_impl(&dword_1A609F000, v31, OS_LOG_TYPE_ERROR, "Creating profile installation notification resulted in error: %d", (uint8_t *)&buf, 8u);
    }
    uint64_t v4 = 0;
  }
  else
  {
    SInt32 v29 = CFUserNotificationReceiveResponse(v25, 0.0, &responseFlags);
    SInt32 error = v29;
    unint64_t v30 = *((void *)this + 5);
    if (v29)
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v29;
        _os_log_error_impl(&dword_1A609F000, v30, OS_LOG_TYPE_ERROR, "Receiving profile installation notification resulted in error: %d", (uint8_t *)&buf, 8u);
      }
    }
    else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = responseFlags;
      _os_log_impl(&dword_1A609F000, v30, OS_LOG_TYPE_DEFAULT, "#I responseFlags=0x%lx", (uint8_t *)&buf, 0xCu);
    }
    BOOL v32 = responseFlags == 1 && error == 0;
    int v33 = !v32;
    if (v32) {
      char v34 = v17;
    }
    else {
      char v34 = 1;
    }
    if (v34)
    {
      uint64_t v4 = v33 ^ 1u;
    }
    else
    {
      uint64_t v35 = (void *)[MEMORY[0x1E4F74230] sharedConnection];
      uint64_t v4 = 1;
      [v35 setBoolValue:1 forSetting:*MEMORY[0x1E4F74190]];
    }
  }
  *((void *)this + 17) = TelephonyUtilGetSystemTime();
  if (v26) {
    CFRelease(v26);
  }
  return v4;
}

void sub_1A616CB94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::ProfileManagementTask::getProfileInfoIndex_sync(abm::ProfileManagementTask *this, const char *a2)
{
  abm::sProfileInfoList(this);
  size_t v3 = strlen(a2);
  uint64_t result = strncasecmp(a2, *(const char **)qword_1EB5EEAB8, v3);
  if (result)
  {
    abm::sProfileInfoList((abm *)result);
    size_t v5 = strlen(a2);
    if (!strncasecmp(a2, *(const char **)(qword_1EB5EEAB8 + 24), v5)) {
      return 1;
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t abm::ProfileManagementTask::isProfileValid(NSObject **this, unsigned int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  abm::sProfileInfoList((abm *)this);
  uint64_t v4 = *(void *)(qword_1EB5EEAB8 + 24 * a2 + 8);
  size_t v5 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithIdentifier:", @"com.apple.ABMHelper"), "bundleURL");
  uint64_t v6 = objc_msgSend((id)objc_msgSend(v5, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(NSString, "stringWithUTF8String:", v4), 0), "path");
  uint64_t v7 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithContentsOfFile:v6];
  if (v7)
  {
    uint64_t v8 = (void *)v7;
    uint64_t v18 = 0;
    size_t v9 = (void *)[MEMORY[0x1E4F74220] profileWithData:v7 outError:&v18];
    uint64_t v10 = [MEMORY[0x1E4F1C9C8] date];
    unsigned int v11 = (void *)[v9 removalDate];
    if (v11 && (void *)[v11 earlierDate:v10] == v11)
    {
      int v14 = this[5];
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      if (v15)
      {
        abm::sProfileInfoList((abm *)v15);
        uint64_t v17 = *(void *)(qword_1EB5EEAB8 + 24 * a2);
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v20 = v17;
        _os_log_error_impl(&dword_1A609F000, v14, OS_LOG_TYPE_ERROR, "Profile [%s] is expired", buf, 0xCu);
      }
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = 1;
    }
  }
  else
  {
    xpc_object_t v13 = this[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      LODWORD(v20) = a2;
      _os_log_error_impl(&dword_1A609F000, v13, OS_LOG_TYPE_ERROR, "Failed to get profile data [index:%d]", buf, 8u);
    }
    return 0;
  }
  return v12;
}

uint64_t abm::ProfileManagementTask::isAllowedToOverrideProfile(NSObject **this, unsigned int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  memset(__dst, 170, sizeof(__dst));
  abm::sProfileInfoList((abm *)this);
  uint64_t v4 = *(const char **)(qword_1EB5EEAB8 + 24 * a2);
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v6 = (void *)v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t v7 = (void **)operator new(v8 + 1);
    __dst[1] = v6;
    _OWORD __dst[2] = (void *)(v9 | 0x8000000000000000);
    __dst[0] = v7;
    goto LABEL_8;
  }
  HIBYTE(__dst[2]) = v5;
  uint64_t v7 = __dst;
  if (v5) {
LABEL_8:
  }
    size_t v5 = (size_t)memmove(v7, v4, (size_t)v6);
  *((unsigned char *)v6 + (void)v7) = 0;
  abm::sProfileInfoList((abm *)v5);
  int v10 = *(_DWORD *)(qword_1EB5EEAB8 + 24 * a2 + 20);
  abm::sProfileInfoList(v11);
  int v12 = *(_DWORD *)(qword_1EB5EEAB8 + 24 * a2 + 16);
  xpc_object_t object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)this, &object);
  if (MEMORY[0x1A6275E60](object) != MEMORY[0x1E4F14590])
  {
LABEL_10:
    uint64_t v13 = 1;
    goto LABEL_11;
  }
  xpc_object_t value = xpc_dictionary_get_value(object, "TelephonyLoggingPriority");
  *(void *)SInt32 v29 = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    *(void *)SInt32 v29 = xpc_null_create();
  }
  int v16 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v29);
  xpc_object_t v17 = xpc_dictionary_get_value(object, "TelephonyLoggingVersion");
  *(void *)SInt32 v29 = v17;
  if (v17) {
    xpc_retain(v17);
  }
  else {
    *(void *)SInt32 v29 = xpc_null_create();
  }
  int v18 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v29);
  if (v16 == v12 && v18 >= v10)
  {
    int v19 = this[5];
    uint64_t v13 = 0;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    uint64_t v20 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      uint64_t v20 = (void **)__dst[0];
    }
    *(_DWORD *)SInt32 v29 = 136315394;
    *(void *)&v29[4] = v20;
    __int16 v30 = 1024;
    int v31 = v10;
    uint64_t v21 = "#I Skip install [%s, version: %d] as installed profile version is same or higher";
    uint64_t v22 = v19;
    goto LABEL_31;
  }
  long long v23 = this[5];
  BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v16 <= v12)
  {
    if (v24)
    {
      uint64_t v26 = __dst;
      if (SHIBYTE(__dst[2]) < 0) {
        uint64_t v26 = (void **)__dst[0];
      }
      *(_DWORD *)SInt32 v29 = 136315394;
      *(void *)&v29[4] = v26;
      __int16 v30 = 1024;
      int v31 = v10;
      _os_log_impl(&dword_1A609F000, v23, OS_LOG_TYPE_DEFAULT, "#I Allow to override [%s, version: %d] ", v29, 0x12u);
    }
    goto LABEL_10;
  }
  if (v24)
  {
    int v25 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      int v25 = (void **)__dst[0];
    }
    *(_DWORD *)SInt32 v29 = 136315394;
    *(void *)&v29[4] = v25;
    __int16 v30 = 1024;
    int v31 = v10;
    uint64_t v21 = "#I Skip install [%s, version: %d] as installed profile has higher priority ";
    uint64_t v22 = v23;
LABEL_31:
    _os_log_impl(&dword_1A609F000, v22, OS_LOG_TYPE_DEFAULT, v21, v29, 0x12u);
    uint64_t v13 = 0;
    goto LABEL_11;
  }
  uint64_t v13 = 0;
LABEL_11:
  xpc_release(object);
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  return v13;
}

void sub_1A616D1CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

uint64_t ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get(uint64_t a1)
{
  return *(void *)a1;
}

const void **ctu::cf::CFSharedRef<__CFUserNotification>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync(NSObject **this)
{
  xpc_object_t v2 = xpc_array_create(0, 0);
  if (v2 || (xpc_object_t v2 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v2) == MEMORY[0x1E4F14568])
    {
      xpc_retain(v2);
      xpc_object_t v3 = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v2 = 0;
  }
  int v16 = -1431655766;
  xpc_release(v2);
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v4) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v6 = xpc_string_create("Profile");
  if (!v6) {
    xpc_object_t v6 = xpc_null_create();
  }
  xpc_dictionary_set_value(v5, "kKeyTraceName", v6);
  xpc_object_t v7 = xpc_null_create();
  xpc_release(v6);
  xpc_release(v7);
  xpc_object_t v8 = xpc_string_create("InstalledCarrierProfileVersion");
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  xpc_dictionary_set_value(v5, "kKeyTracePropertyName", v8);
  xpc_object_t v9 = xpc_null_create();
  xpc_release(v8);
  xpc_release(v9);
  if (abm::ProfileManagementTask::checkifProfileInstalled_sync(this, "Baseband", &v16)) {
    int v10 = v16;
  }
  else {
    int v10 = 0;
  }
  std::to_string(&v17, v10);
  std::string __p = v17;
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v12 = xpc_string_create((const char *)p_p);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_dictionary_set_value(v5, "kKeyTracePropertyValue", v12);
  xpc_object_t v13 = xpc_null_create();
  xpc_release(v12);
  xpc_release(v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  xpc_array_append_value(v3, v5);
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  abm::ProfileManagementTask::applyTraceProperties_sync((uint64_t)this, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
  xpc_release(v3);
}

void sub_1A616D554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void ___ZN3abm21ProfileManagementTask29registerForNotifications_syncEv_block_invoke(void *a1, void *a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    xpc_object_t v6 = std::__shared_weak_count::lock(v3);
    int v25 = v6;
    if (v6)
    {
      xpc_object_t v7 = v6;
      if (a1[5])
      {
        xpc_object_t v8 = *(NSObject **)(v5 + 112);
        if (v8)
        {
          dispatch_retain(*(dispatch_object_t *)(v5 + 112));
          dispatch_group_enter(v8);
        }
        if (a2)
        {
          string = xpc_dictionary_get_string(a2, (const char *)*MEMORY[0x1E4F14560]);
          if (string)
          {
            if (!strcasecmp("com.apple.ManagedConfiguration.profileListChanged", string))
            {
              xpc_object_t v12 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v19[0]) = 0;
                _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I streamed event received: Profile Changed", (uint8_t *)v19, 2u);
              }
              if (abm::ProfileManagementTask::wasProfileInstalled_sync((abm::ProfileManagementTask *)v5))
              {
                int v13 = 1;
              }
              else
              {
                if (TelephonyUtilIsInternalBuild()) {
                  int IsCarrierBuild = 1;
                }
                else {
                  int IsCarrierBuild = TelephonyUtilIsCarrierBuild();
                }
                int v13 = IsCarrierBuild ^ 1;
              }
              abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v5, &v22);
              abm::ProfileManagementTask::convertToTraceProperties_sync(v5, &v22, v13, &v23);
              abm::ProfileManagementTask::applyTraceProperties_sync(v5, &v23);
              xpc_release(v23);
              xpc_object_t v23 = 0;
              xpc_release(v22);
              xpc_object_t v22 = 0;
              if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
              {
                abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync((NSObject **)v5);
                uint64_t v16 = a1[5];
                BOOL v15 = (std::__shared_weak_count *)a1[6];
                if (v15) {
                  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                }
                if (v8)
                {
                  dispatch_retain(v8);
                  dispatch_group_enter(v8);
                }
                std::string v17 = *(NSObject **)(v5 + 144);
                int v18 = operator new(0x20uLL);
                *int v18 = v16;
                v18[1] = v15;
                if (v15)
                {
                  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  v18[2] = v8;
                  void v18[3] = v5;
                  dispatch_async_f(v17, v18, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
                  std::__shared_weak_count::__release_weak(v15);
                }
                else
                {
                  v18[2] = v8;
                  void v18[3] = v5;
                  dispatch_async_f(v17, v18, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
                }
              }
            }
            else if (!strcasecmp("com.apple.purplebuddy.setupdone", string))
            {
              int v10 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v19[0]) = 0;
                _os_log_impl(&dword_1A609F000, v10, OS_LOG_TYPE_DEFAULT, "#I streamed event received: Buddy Setup Done", (uint8_t *)v19, 2u);
              }
              if ((TelephonyUtilIsInternalBuild() & 1) == 0 && (TelephonyUtilIsCarrierBuild() & 1) == 0)
              {
                abm::ProfileManagementTask::readProfile_sync((abm::ProfileManagementTask *)v5, &v20);
                abm::ProfileManagementTask::convertToTraceProperties_sync(v5, &v20, 1, &object);
                abm::ProfileManagementTask::applyTraceProperties_sync(v5, &object);
                xpc_release(object);
                xpc_object_t object = 0;
                xpc_release(v20);
                xpc_object_t v20 = 0;
              }
              if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
              {
                uint64_t v11 = a1[6];
                v19[0] = a1[5];
                v19[1] = v11;
                if (v11) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
                }
                v19[2] = v8;
                if (v8)
                {
                  dispatch_retain(v8);
                  dispatch_group_enter(v8);
                }
                void v19[3] = v5;
                _ZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvRKNS_5queueEOT_(*(NSObject **)(v5 + 144), (uint64_t)v19);
                _ZZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_EN3__4D1Ev((uint64_t)v19);
              }
            }
          }
        }
        if (v8)
        {
          dispatch_group_leave(v8);
          dispatch_release(v8);
        }
      }
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A616D988(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t object, xpc_object_t a15, xpc_object_t a16, char a17)
{
  xpc_release(object);
  xpc_release(a13);
  if (v17)
  {
    dispatch_group_leave(v17);
    dispatch_release(v17);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t abm::ProfileManagementTask::wasProfileInstalled_sync(abm::ProfileManagementTask *this)
{
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  int v41 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  HIBYTE(__p[2]) = 17;
  strcpy((char *)__p, "ProfileManagement");
  abm::client::CreateManager();
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  uint64_t v3 = MEMORY[0x1E4F14590];
  if (v2 || (xpc_object_t v2 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v2) == v3)
    {
      xpc_retain(v2);
      xpc_object_t v4 = v2;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v2 = 0;
  }
  xpc_release(v2);
  xpc_object_t v5 = xpc_string_create("Profile");
  if (!v5) {
    xpc_object_t v5 = xpc_null_create();
  }
  xpc_dictionary_set_value(v4, "kKeyTraceName", v5);
  xpc_object_t v6 = xpc_null_create();
  xpc_release(v5);
  xpc_release(v6);
  xpc_object_t v7 = xpc_string_create((const char *)*MEMORY[0x1E4F4C0E0]);
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_dictionary_set_value(v4, "kKeyTracePropertyName", v7);
  xpc_object_t v8 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v8);
  xpc_object_t v39 = xpc_null_create();
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string __p = v9;
  *(_OWORD *)&std::vector<std::ssub_match> __p[2] = v9;
  unint64_t v36 = v40;
  xpc_object_t v37 = v41;
  atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
  v42.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v42.__r_.__value_.__r.__words[1] = xmmword_1A61F6FD0;
  strcpy(v42.__r_.__value_.__l.__data_, "kCommandGetTraceProperty");
  abm::client::PerformCommand();
  operator delete(v42.__r_.__value_.__l.__data_);
  if (atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    xpc_object_t v10 = v39;
    if (v39) {
      goto LABEL_16;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
    xpc_object_t v10 = v39;
    if (v39) {
      goto LABEL_16;
    }
  }
  xpc_object_t v10 = xpc_null_create();
  if (!v10)
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v10 = 0;
    goto LABEL_19;
  }
LABEL_16:
  if (MEMORY[0x1A6275E60](v10) == v3)
  {
    xpc_retain(v10);
    xpc_object_t v11 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
  }
LABEL_19:
  xpc_release(v10);
  if (LODWORD(__p[0]) || MEMORY[0x1A6275E60](v11) != v3)
  {
LABEL_52:
    uint64_t v28 = 0;
    goto LABEL_53;
  }
  xpc_object_t value = xpc_dictionary_get_value(v11, "kKeyTracePropertyValue");
  xpc_object_t object = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::dyn_cast_or_default();
  std::to_string(&v42, 1);
  std::string v31 = v42;
  unsigned __int8 v13 = v35;
  if ((v35 & 0x80u) == 0) {
    size_t v14 = v35;
  }
  else {
    size_t v14 = __n;
  }
  std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
  int v16 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v31.__r_.__value_.__l.__size_;
  }
  if (v14 != size)
  {
    BOOL v26 = 0;
    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_43;
  }
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v17 = &v31;
  }
  else {
    std::string v17 = (std::string *)v31.__r_.__value_.__r.__words[0];
  }
  if ((char)v35 < 0)
  {
    BOOL v26 = memcmp(__s1, v17, __n) == 0;
    goto LABEL_45;
  }
  if (v35)
  {
    uint64_t v18 = v35 - 1;
    p_s1 = &__s1;
    do
    {
      int v21 = *(unsigned __int8 *)p_s1;
      p_s1 = (void **)((char *)p_s1 + 1);
      int v20 = v21;
      int v23 = v17->__r_.__value_.__s.__data_[0];
      std::string v17 = (std::string *)((char *)v17 + 1);
      int v22 = v23;
      BOOL v25 = v18-- != 0;
      BOOL v26 = v20 == v22;
    }
    while (v20 == v22 && v25);
LABEL_45:
    if ((v16 & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_43:
    operator delete(v31.__r_.__value_.__l.__data_);
    unsigned __int8 v13 = v35;
    goto LABEL_46;
  }
  BOOL v26 = 1;
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_43;
  }
LABEL_46:
  if ((v13 & 0x80) != 0) {
    operator delete(__s1);
  }
  xpc_release(object);
  if (!v26) {
    goto LABEL_52;
  }
  uint64_t v27 = *((void *)this + 5);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v42.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A609F000, v27, OS_LOG_TYPE_DEFAULT, "#I Logging profile was installed", (uint8_t *)&v42, 2u);
  }
  uint64_t v28 = 1;
LABEL_53:
  xpc_release(v11);
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  xpc_release(v4);
  SInt32 v29 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  return v28;
}

void sub_1A616DEDC(void *a1)
{
}

void sub_1A616DEE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  xpc_release(object);
  xpc_release(v32);
  if (a31 < 0) {
    operator delete(a26);
  }
  xpc_release(v31);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v33 - 96);
  _Unwind_Resume(a1);
}

void sub_1A616DFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void _ZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvRKNS_5queueEOT_(NSObject *a1, uint64_t a2)
{
  xpc_object_t v4 = operator new(0x20uLL);
  uint64_t v5 = *(void *)(a2 + 8);
  *xpc_object_t v4 = *(void *)a2;
  v4[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  long long v6 = *(_OWORD *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *((_OWORD *)v4 + 1) = v6;

  dispatch_async_f(a1, v4, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
}

uint64_t _ZZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_EN3__4D1Ev(uint64_t a1)
{
  xpc_object_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void abm::sProfileInfoList(abm *this)
{
  v1[6] = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EEA98, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1EB5EEA98))
    {
      v1[0] = "Baseband";
      v1[1] = "Baseband.mobileconfig";
      v1[2] = 0x1000000003;
      v1[3] = "CellularDE";
      v1[4] = "CellularDE.mobileconfig";
      void v1[5] = 0x1000000002;
      std::vector<abm::ProfileManagementTask::ProfileDetail>::vector[abi:ne180100](v1, 2uLL);
      __cxa_atexit((void (*)(void *))std::vector<abm::ProfileManagementTask::ProfileDetail>::~vector[abi:ne180100], &qword_1EB5EEAB8, &dword_1A609F000);
      __cxa_guard_release(&qword_1EB5EEA98);
    }
  }
}

void sub_1A616E1B8(_Unwind_Exception *a1)
{
}

void abm::ProfileManagementTask::getProfileIdentifier_sync(NSObject **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  abm::sProfileInfoList((abm *)this);
  uint64_t v6 = *(void *)(qword_1EB5EEAB8 + 24 * a2 + 8);
  xpc_object_t v7 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithIdentifier:", @"com.apple.ABMHelper"), "bundleURL");
  uint64_t v8 = objc_msgSend((id)objc_msgSend(v7, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(NSString, "stringWithUTF8String:", v6), 0), "path");
  uint64_t v9 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithContentsOfFile:v8];
  if (v9)
  {
    xpc_object_t v10 = (void *)v9;
    int v22 = 0;
    xpc_object_t v11 = (void *)[MEMORY[0x1E4F74220] profileWithData:v9 outError:&v22];
    xpc_object_t v12 = v22;
    if (v22)
    {
      unsigned __int8 v13 = this[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = objc_msgSend((id)objc_msgSend(v12, "localizedDescription"), "UTF8String");
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_error_impl(&dword_1A609F000, v13, OS_LOG_TYPE_ERROR, "Reading profile Error: %s", buf, 0xCu);
      }
      goto LABEL_12;
    }
    int v16 = (const char *)objc_msgSend((id)objc_msgSend(v11, "identifier"), "UTF8String");
    size_t v17 = strlen(v16);
    if (v17 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v18 = v17;
    if (v17 >= 0x17)
    {
      uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17) {
        uint64_t v20 = v17 | 7;
      }
      uint64_t v21 = v20 + 1;
      int v19 = operator new(v20 + 1);
      *(void *)&uint8_t buf[8] = v18;
      unint64_t v24 = v21 | 0x8000000000000000;
      *(void *)std::string buf = v19;
    }
    else
    {
      HIBYTE(v24) = v17;
      int v19 = buf;
      if (!v17)
      {
        buf[0] = 0;
        if ((*(char *)(a3 + 23) & 0x80000000) == 0)
        {
LABEL_11:
          *(_OWORD *)a3 = *(_OWORD *)buf;
          *(void *)(a3 + 16) = v24;
LABEL_12:

          return;
        }
LABEL_18:
        operator delete(*(void **)a3);
        goto LABEL_11;
      }
    }
    memmove(v19, v16, v18);
    *((unsigned char *)v19 + v18) = 0;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_18;
  }
  BOOL v15 = this[5];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_error_impl(&dword_1A609F000, v15, OS_LOG_TYPE_ERROR, "Failed to get profile data [index:%d]", buf, 8u);
  }
}

void sub_1A616E440(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::ProfileManagementTask::installMCProfile_sync(NSObject **this, const char *a2, int a3)
{
  *(void *)&void v32[5] = *MEMORY[0x1E4F143B8];
  abm::sProfileInfoList((abm *)this);
  size_t v6 = strlen(a2);
  xpc_object_t v7 = (abm *)strncasecmp(a2, *(const char **)qword_1EB5EEAB8, v6);
  if (v7)
  {
    abm::sProfileInfoList(v7);
    size_t v8 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1EB5EEAB8 + 24), v8))
    {
      uint64_t v9 = this[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        xpc_object_t v10 = "Install profile failed as we failed to get profile info";
LABEL_13:
        _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
        return 0;
      }
      return 0;
    }
    unsigned int v11 = 1;
    uint64_t isAllowedToOverrideProfile = abm::ProfileManagementTask::isAllowedToOverrideProfile(this, 1u);
    if ((isAllowedToOverrideProfile & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = this[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        xpc_object_t v10 = "Install profile failed as we want to keep pre-installed one";
        goto LABEL_13;
      }
      return 0;
    }
  }
  else
  {
    unsigned int v11 = 0;
    uint64_t isAllowedToOverrideProfile = abm::ProfileManagementTask::isAllowedToOverrideProfile(this, 0);
    if ((isAllowedToOverrideProfile & 1) == 0) {
      goto LABEL_11;
    }
  }
  id v30 = 0;
  abm::sProfileInfoList((abm *)isAllowedToOverrideProfile);
  uint64_t v13 = *(void *)(qword_1EB5EEAB8 + 24 * v11 + 8);
  uint64_t v14 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithIdentifier:", @"com.apple.ABMHelper"), "bundleURL");
  uint64_t v15 = objc_msgSend((id)objc_msgSend(v14, "URLByAppendingPathComponent:isDirectory:", objc_msgSend(NSString, "stringWithUTF8String:", v13), 0), "path");
  int v16 = (config::hw *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithContentsOfFile:v15];
  if (!v16)
  {
    int v19 = this[5];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)uint64_t v32 = a2;
      _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Profile [%s] not found", buf, 0xCu);
    }
    return 0;
  }
  size_t v17 = v16;
  if (a3 && (config::hw::watch(v16) & 1) == 0) {
    uint64_t v18 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F74230], "sharedConnection"), "queueFileDataForAcceptance:originalFileName:outError:", v17, 0, &v30);
  }
  else {
    uint64_t v18 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F74230], "sharedConnection"), "installProfileData:options:outError:", v17, 0, &v30);
  }
  int v22 = (void *)v18;
  if (v18) {
    BOOL v23 = v30 == 0;
  }
  else {
    BOOL v23 = 0;
  }
  uint64_t v20 = v23;
  unint64_t v24 = this[5];
  if (v23)
  {
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = [v22 UTF8String];
      *(_DWORD *)std::string buf = 136315138;
      *(void *)uint64_t v32 = v25;
      _os_log_impl(&dword_1A609F000, v24, OS_LOG_TYPE_DEFAULT, "#I Install profile data success, id: %s", buf, 0xCu);
    }
    if (TelephonyUtilIsCarrierBuild())
    {
      uint64_t IsInternalBuild = TelephonyUtilIsInternalBuild();
      if ((IsInternalBuild & 1) == 0)
      {
        if (config::hw::watch((config::hw *)IsInternalBuild)) {
          abm::ProfileManagementTask::rebootWithConfirmation_sync((abm::ProfileManagementTask *)this);
        }
      }
    }
  }
  else if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int isProfileValid = abm::ProfileManagementTask::isProfileValid(this, v11);
    uint64_t v29 = objc_msgSend((id)objc_msgSend(v30, "localizedDescription"), "UTF8String");
    *(_DWORD *)std::string buf = 67109378;
    v32[0] = isProfileValid;
    LOWORD(v32[1]) = 2080;
    *(void *)((char *)&v32[1] + 2) = v29;
    _os_log_error_impl(&dword_1A609F000, v24, OS_LOG_TYPE_ERROR, "Install profile data [valid=%d] failed: %s", buf, 0x12u);
  }

  return v20;
}

void abm::ProfileManagementTask::rebootWithConfirmation_sync(abm::ProfileManagementTask *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  xpc_object_t v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I Asking for user confirmation to reboot after installing profile", buf, 2u);
  }
  uint64_t v3 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  [v3 setObject:@"Dismiss" forKeyedSubscript:*MEMORY[0x1E4F1D9E0]];
  [v3 setObject:@"Reboot Required" forKeyedSubscript:*MEMORY[0x1E4F1D990]];
  [v3 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4F1D9B8]];
  [v3 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4FA7340]];
  [v3 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:*MEMORY[0x1E4FA7328]];
  [v3 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4FA73C8]];
  [v3 setObject:@"Reboot" forKeyedSubscript:*MEMORY[0x1E4F1D9D0]];
  [v3 setObject:@"A reboot is required for the logging profile change to take effect. Would you like to reboot now?" forKeyedSubscript:*MEMORY[0x1E4F1D9A8]];
  SInt32 error = 0;
  CFOptionFlags responseFlags = 3;
  xpc_object_t v4 = CFUserNotificationCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 600.0, 3uLL, &error, (CFDictionaryRef)v3);
  uint64_t v5 = v4;
  if (v4) {
    size_t v6 = ctu::SharedRef<__CFUserNotification,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFUserNotification>::get;
  }
  else {
    size_t v6 = 0;
  }
  SInt32 v7 = error;
  if (!v6 || error)
  {
    xpc_object_t v10 = *((void *)this + 5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      LODWORD(v14) = v7;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Creating reboot notification resulted in error: %d", buf, 8u);
    }
  }
  else
  {
    SInt32 v8 = CFUserNotificationReceiveResponse(v4, 0.0, &responseFlags);
    SInt32 error = v8;
    uint64_t v9 = *((void *)this + 5);
    if (v8)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v14) = v8;
        _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Receiving reboot notification resulted in error: %d", buf, 8u);
      }
    }
    else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      CFOptionFlags v14 = responseFlags;
      _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I responseFlags=0x%lx", buf, 0xCu);
    }
    if (responseFlags == 1 && !error) {
      abm::ProfileManagementTask::reboot_sync(this);
    }
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1A616EADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void abm::ProfileManagementTask::uninstallMCProfile_sync(NSObject **a1, const char *a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  size_t v6 = a1[5];
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Uninstall profile: %s", buf, 0xCu);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v28 = 0;
  abm::sProfileInfoList((abm *)v7);
  size_t v8 = strlen(a2);
  uint64_t v9 = (abm *)strncasecmp(a2, *(const char **)qword_1EB5EEAB8, v8);
  if (v9)
  {
    abm::sProfileInfoList(v9);
    size_t v10 = strlen(a2);
    if (strncasecmp(a2, *(const char **)(qword_1EB5EEAB8 + 24), v10))
    {
      unsigned int v11 = a1[5];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = a2;
        _os_log_error_impl(&dword_1A609F000, v11, OS_LOG_TYPE_ERROR, "Failed to get profile [%s] info", buf, 0xCu);
      }
      goto LABEL_38;
    }
    unsigned int v12 = 1;
  }
  else
  {
    unsigned int v12 = 0;
  }
  abm::ProfileManagementTask::getProfileIdentifier_sync(a1, v12, (uint64_t)buf);
  uint64_t v28 = v30;
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  unint64_t v13 = (unint64_t)v30 >> 56;
  int v14 = SHIBYTE(v30);
  if (SHIBYTE(v30) < 0) {
    unint64_t v13 = *(void *)&buf[8];
  }
  if (v13)
  {
    uint64_t v15 = (void *)[MEMORY[0x1E4F74230] sharedConnection];
    if (v14 >= 0) {
      int v16 = __p;
    }
    else {
      int v16 = (void **)__p[0];
    }
    uint64_t v17 = [NSString stringWithUTF8String:v16];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3321888768;
    std::string v24[2] = ___ZN3abm21ProfileManagementTask23uninstallMCProfile_syncEPKcN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_block_invoke;
    _OWORD v24[3] = &__block_descriptor_56_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_e5_v8__0l;
    v24[4] = a1;
    uint64_t v18 = *(void **)a3;
    if (*(void *)a3) {
      uint64_t v18 = _Block_copy(v18);
    }
    int v19 = *(NSObject **)(a3 + 8);
    aBlocuint64_t k = v18;
    dispatch_object_t object = v19;
    if (v19) {
      dispatch_retain(v19);
    }
    [v15 removeProfileWithIdentifier:v17 completion:v24];
    if (object) {
      dispatch_release(object);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    goto LABEL_38;
  }
  if (!*(void *)a3 || !*(void *)(a3 + 8)) {
    goto LABEL_38;
  }
  xpc_object_t v20 = xpc_null_create();
  if (*(void *)a3) {
    uint64_t v21 = _Block_copy(*(const void **)a3);
  }
  else {
    uint64_t v21 = 0;
  }
  int v22 = *(NSObject **)(a3 + 8);
  *(void *)std::string buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3321888768;
  id v30 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
  std::string v31 = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v21)
  {
    int v34 = -534716416;
    uint64_t v32 = 0;
    xpc_object_t v33 = v20;
    if (v20) {
      goto LABEL_30;
    }
LABEL_32:
    xpc_object_t v33 = xpc_null_create();
    goto LABEL_33;
  }
  BOOL v23 = _Block_copy(v21);
  int v34 = -534716416;
  uint64_t v32 = v23;
  xpc_object_t v33 = v20;
  if (!v20) {
    goto LABEL_32;
  }
LABEL_30:
  xpc_retain(v20);
LABEL_33:
  dispatch_async(v22, buf);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  if (v32) {
    _Block_release(v32);
  }
  if (v21) {
    _Block_release(v21);
  }
  xpc_release(v20);
LABEL_38:
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A616EE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN3abm21ProfileManagementTask23uninstallMCProfile_syncEPKcN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE_block_invoke(void *a1)
{
  uint64_t v1 = (NSObject **)a1[4];
  if (!a1[5] || !a1[6]) {
    goto LABEL_16;
  }
  xpc_object_t v3 = xpc_null_create();
  xpc_object_t v4 = (const void *)a1[5];
  if (v4) {
    uint64_t v5 = _Block_copy(v4);
  }
  else {
    uint64_t v5 = 0;
  }
  size_t v6 = a1[6];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
  block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
  if (!v5)
  {
    int v11 = 0;
    aBlocuint64_t k = 0;
    xpc_object_t object = v3;
    if (v3) {
      goto LABEL_8;
    }
LABEL_10:
    xpc_object_t object = xpc_null_create();
    goto LABEL_11;
  }
  int v11 = 0;
  aBlocuint64_t k = _Block_copy(v5);
  xpc_object_t object = v3;
  if (!v3) {
    goto LABEL_10;
  }
LABEL_8:
  xpc_retain(v3);
LABEL_11:
  dispatch_async(v6, block);
  xpc_release(object);
  xpc_object_t object = 0;
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v5) {
    _Block_release(v5);
  }
  xpc_release(v3);
LABEL_16:
  if (TelephonyUtilIsCarrierBuild() && (TelephonyUtilIsInternalBuild() & 1) == 0)
  {
    abm::ProfileManagementTask::updateDefaultCarrierProfileInstalledProperty_sync(v1);
    if (config::hw::watch(v7)) {
      abm::ProfileManagementTask::rebootWithConfirmation_sync((abm::ProfileManagementTask *)v1);
    }
  }
}

void __copy_helper_block_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(void **)(a2 + 40);
  if (v4) {
    xpc_object_t v4 = _Block_copy(v4);
  }
  uint64_t v5 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v5;
  if (v5)
  {
    dispatch_retain(v5);
  }
}

void __destroy_helper_block_e8_40c57_ZTSN8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEE(uint64_t a1)
{
  xpc_object_t v2 = *(NSObject **)(a1 + 48);
  if (v2) {
    dispatch_release(v2);
  }
  xpc_object_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    _Block_release(v3);
  }
}

void abm::ProfileManagementTask::reboot_sync(abm::ProfileManagementTask *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v3 = 0;
    _os_log_impl(&dword_1A609F000, v1, OS_LOG_TYPE_DEFAULT, "#I Rebooting", v3, 2u);
  }
  xpc_object_t v2 = (void *)[objc_alloc(MEMORY[0x1E4F62AF0]) initWithReason:@"For logging profile change to take effect"];
  [v2 setRebootType:1];
  [v2 setSource:1];
  objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F62AF8], "sharedService"), "shutdownWithOptions:", v2);
}

void *std::vector<abm::ProfileManagementTask::ProfileDetail>::vector[abi:ne180100](void *result, unint64_t a2)
{
  qword_1EB5EEAB8 = 0;
  qword_1EB5EEAC0 = 0;
  qword_1EB5EEAC8 = 0;
  if (a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    }
    xpc_object_t v2 = result;
    size_t v3 = 24 * a2;
    qword_1EB5EEAB8 = (uint64_t)operator new(24 * a2);
    qword_1EB5EEAC0 = qword_1EB5EEAB8;
    uint64_t v4 = qword_1EB5EEAB8 + v3;
    qword_1EB5EEAC8 = qword_1EB5EEAB8 + v3;
    uint64_t result = memmove((void *)qword_1EB5EEAB8, v2, v3);
    qword_1EB5EEAC0 = v4;
  }
  return result;
}

void sub_1A616F20C(_Unwind_Exception *exception_object)
{
  if (qword_1EB5EEAB8)
  {
    qword_1EB5EEAC0 = qword_1EB5EEAB8;
    operator delete((void *)qword_1EB5EEAB8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<abm::ProfileManagementTask::ProfileDetail>::~vector[abi:ne180100](uint64_t a1)
{
  xpc_object_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__0ES2_EEEvDpT__block_invoke_1(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  xpc_object_t v2 = *(void **)(a1 + 40);
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A616F2CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  xpc_object_t v2 = *(void **)(a1 + 40);
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A616F350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t *_ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v2 + 72);
    if (v3) {
      dispatch_release(v3);
    }
    uint64_t v4 = *(const void **)(v2 + 64);
    if (v4) {
      _Block_release(v4);
    }
    if (*(char *)(v2 + 63) < 0) {
      operator delete(*(void **)(v2 + 40));
    }
    uint64_t v5 = *(NSObject **)(v2 + 16);
    if (v5)
    {
      dispatch_group_leave(v5);
      size_t v6 = *(NSObject **)(v2 + 16);
      if (v6) {
        dispatch_release(v6);
      }
    }
    BOOL v7 = *(std::__shared_weak_count **)(v2 + 8);
    if (v7) {
      std::__shared_weak_count::__release_weak(v7);
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t *_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v2) {
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v14);
  }
  uint64_t v3 = *(NSObject ***)(a1 + 32);
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v14);
  }
  uint64_t v5 = v4;
  if (*(void *)a1)
  {
    int v6 = -534716416;
    if (!*(unsigned char *)(a1 + 24)) {
      goto LABEL_8;
    }
    BOOL v7 = (const char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      BOOL v7 = *(const char **)v7;
    }
    if (abm::ProfileManagementTask::showMCProfileInstallNotification_sync((abm::ProfileManagementTask *)v3, v7))
    {
LABEL_8:
      size_t v8 = (const char *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        size_t v8 = *(const char **)v8;
      }
      if (abm::ProfileManagementTask::installMCProfile_sync(v3, v8, *(unsigned __int8 *)(a1 + 24))) {
        int v6 = 0;
      }
      else {
        int v6 = -534716416;
      }
    }
    xpc_object_t v9 = xpc_null_create();
    size_t v10 = *(const void **)(a1 + 64);
    if (v10) {
      int v11 = _Block_copy(v10);
    }
    else {
      int v11 = 0;
    }
    unsigned int v12 = *(NSObject **)(a1 + 72);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJiS2_EEEvDpT__block_invoke;
    block[3] = &__block_descriptor_52_e8_32c54_ZTSN8dispatch5blockIU13block_pointerFviN3xpc4dictEEEE40c15_ZTSN3xpc4dictE_e5_v8__0l;
    if (v11)
    {
      int v18 = v6;
      aBlocuint64_t k = _Block_copy(v11);
      xpc_object_t object = v9;
      if (v9)
      {
LABEL_18:
        xpc_retain(v9);
LABEL_21:
        dispatch_async(v12, block);
        xpc_release(object);
        xpc_object_t object = 0;
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v11) {
          _Block_release(v11);
        }
        xpc_release(v9);
        goto LABEL_26;
      }
    }
    else
    {
      int v18 = v6;
      aBlocuint64_t k = 0;
      xpc_object_t object = v9;
      if (v9) {
        goto LABEL_18;
      }
    }
    xpc_object_t object = xpc_null_create();
    goto LABEL_21;
  }
LABEL_26:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&v14);
}

void sub_1A616F5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb_E3__1NS_14default_deleteIS3_EEED1B8ne180100Ev(&a9);
  _Unwind_Resume(a1);
}

uint64_t *_ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v2 + 64);
    if (v3) {
      dispatch_release(v3);
    }
    uint64_t v4 = *(const void **)(v2 + 56);
    if (v4) {
      _Block_release(v4);
    }
    if (*(char *)(v2 + 55) < 0) {
      operator delete(*(void **)(v2 + 32));
    }
    uint64_t v5 = *(NSObject **)(v2 + 16);
    if (v5)
    {
      dispatch_group_leave(v5);
      int v6 = *(NSObject **)(v2 + 16);
      if (v6) {
        dispatch_release(v6);
      }
    }
    BOOL v7 = *(std::__shared_weak_count **)(v2 + 8);
    if (v7) {
      std::__shared_weak_count::__release_weak(v7);
    }
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t *_ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(uint64_t a1)
{
  uint64_t v11 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v2) {
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v11);
  }
  uint64_t v3 = *(NSObject ***)(a1 + 24);
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v11);
  }
  uint64_t v5 = v4;
  if (*(void *)a1)
  {
    int v6 = (const char *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0)
    {
      int v6 = *(const char **)v6;
      BOOL v7 = *(const void **)(a1 + 56);
      if (v7)
      {
LABEL_6:
        size_t v8 = _Block_copy(v7);
        xpc_object_t v9 = *(NSObject **)(a1 + 64);
        unsigned int v12 = v8;
        unint64_t v13 = v9;
        if (!v9)
        {
LABEL_8:
          abm::ProfileManagementTask::uninstallMCProfile_sync(v3, v6, (uint64_t)&v12);
          if (v9) {
            dispatch_release(v9);
          }
          if (v8) {
            _Block_release(v8);
          }
          goto LABEL_12;
        }
LABEL_7:
        dispatch_retain(v9);
        goto LABEL_8;
      }
    }
    else
    {
      BOOL v7 = *(const void **)(a1 + 56);
      if (v7) {
        goto LABEL_6;
      }
    }
    size_t v8 = 0;
    xpc_object_t v9 = *(NSObject **)(a1 + 64);
    unsigned int v12 = 0;
    unint64_t v13 = v9;
    if (!v9) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_12:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&v11);
}

void sub_1A616F7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v12) {
    dispatch_release(v12);
  }
  if (v11) {
    _Block_release(v11);
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _ZNSt3__110unique_ptrIZZN3abm21ProfileManagementTask9init_syncEvEUb0_E3__2NS_14default_deleteIS3_EEED1B8ne180100Ev(&a10);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__3EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[1];
  if (v2)
  {
    uint64_t v3 = (abm::ProfileManagementTask *)__p[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*__p)
      {
        int v6 = (config::hw *)abm::ProfileManagementTask::showMCProfileInstallNotification_sync(v3, "Baseband");
        if (v6)
        {
          int v7 = config::hw::watch(v6);
          abm::ProfileManagementTask::installMCProfile_sync((NSObject **)v3, "Baseband", v7 ^ 1);
        }
      }
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  size_t v8 = __p[2];
  if (v8)
  {
    dispatch_group_leave(v8);
    xpc_object_t v9 = __p[2];
    if (v9) {
      dispatch_release(v9);
    }
  }
  size_t v10 = (std::__shared_weak_count *)__p[1];
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }

  operator delete(__p);
}

void sub_1A616F940(_Unwind_Exception *a1)
{
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v4 = v1[2];
  if (v4)
  {
    dispatch_group_leave(v4);
    uint64_t v5 = v1[2];
    if (v5) {
      dispatch_release(v5);
    }
  }
  int v6 = (std::__shared_weak_count *)v1[1];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void _ZZN8dispatch5asyncIZZN3abm21ProfileManagementTask29registerForNotifications_syncEvEUb1_E3__4EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[1];
  if (v2)
  {
    uint64_t v3 = (abm::ProfileManagementTask *)__p[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*__p)
      {
        int v6 = (config::hw *)abm::ProfileManagementTask::showMCProfileInstallNotification_sync(v3, "Baseband");
        if (v6)
        {
          int v7 = config::hw::watch(v6);
          abm::ProfileManagementTask::installMCProfile_sync((NSObject **)v3, "Baseband", v7 ^ 1);
        }
      }
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }
  size_t v8 = __p[2];
  if (v8)
  {
    dispatch_group_leave(v8);
    xpc_object_t v9 = __p[2];
    if (v9) {
      dispatch_release(v9);
    }
  }
  size_t v10 = (std::__shared_weak_count *)__p[1];
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }

  operator delete(__p);
}

void sub_1A616FAA4(_Unwind_Exception *a1)
{
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v4 = v1[2];
  if (v4)
  {
    dispatch_group_leave(v4);
    uint64_t v5 = v1[2];
    if (v5) {
      dispatch_release(v5);
    }
  }
  int v6 = (std::__shared_weak_count *)v1[1];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t diag::FileInfo::shouldFilter(diag::FileInfo *this)
{
  int IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  int IsInternalBuild = TelephonyUtilIsInternalBuild();
  uint64_t result = (IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild()) ^ 1;
  if (*((unsigned char *)this + 28))
  {
    int v5 = *((_DWORD *)this + 6);
    if (v5) {
      BOOL v6 = v5 == 7;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      return 1;
    }
    else {
      return result;
    }
  }
  return result;
}

void diag::getFileInfo(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v23[2] = *MEMORY[0x1E4F143B8];
  int v21 = -1431655766;
  uint64_t v4 = (const std::string::value_type *)ETLDMCGetMatchingFileNameAndType();
  *(void *)(a2 + 24) = 0xAAAAAAAAAAAAAAAALL;
  *(void *)(a2 + 32) = 0xAAAAAAAAAAAAAAAALL;
  *(unsigned char *)(a2 + 28) = 0;
  *(unsigned char *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(unsigned char *)(a2 + 24) = 0;
  memset(&__p, 0, sizeof(__p));
  if (v4)
  {
    std::string::__assign_external(&__p, v4);
    *(_DWORD *)(a2 + 24) = v21;
    *(unsigned char *)(a2 + 28) = 1;
  }
  else if (&__p != (std::string *)a1)
  {
    if (*(char *)(a1 + 23) < 0) {
      std::string::__assign_no_alias<true>(&__p, *(void **)a1, *(void *)(a1 + 8));
    }
    else {
      std::string __p = *(std::string *)a1;
    }
  }
  int v5 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v7 = size + 17;
  memset(&v22, 170, 24);
  if (size + 17 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 >= 0x17)
  {
    uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = (char *)operator new(v9 + 1);
    v22.__darwin_ino64_t st_ino = size + 17;
    *(void *)&v22.st_uid = v10 | 0x8000000000000000;
    *(void *)&v22.st_dev = v11;
    v11[16] = 47;
    *(_OWORD *)uint64_t v11 = *(_OWORD *)"/usr/lib/bbmasks/";
    size_t v8 = v11 + 17;
  }
  else
  {
    *(void *)&v22.st_uid = 47;
    *(_OWORD *)&v22.st_dev = *(_OWORD *)"/usr/lib/bbmasks/";
    size_t v8 = (char *)&v22.st_uid + 1;
    if (!size) {
      goto LABEL_17;
    }
  }
  if (v5 >= 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  memmove(v8, p_p, size);
LABEL_17:
  v8[size] = 0;
  unint64_t v13 = std::string::append((std::string *)&v22, ".dmc", 4uLL);
  uint64_t v14 = (const char *)v13->__r_.__value_.__r.__words[0];
  v23[0] = v13->__r_.__value_.__l.__size_;
  *(void *)((char *)v23 + 7) = *(std::string::size_type *)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
  int v15 = SHIBYTE(v13->__r_.__value_.__r.__words[2]);
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int st_gid_high = SHIBYTE(v22.st_gid);
  *(void *)(a2 + 15) = *(void *)((char *)v23 + 7);
  uint64_t v17 = v23[0];
  *(void *)a2 = v14;
  *(void *)(a2 + 8) = v17;
  *(unsigned char *)(a2 + 23) = v15;
  if (st_gid_high < 0) {
    operator delete(*(void **)&v22.st_dev);
  }
  v18.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v22.st_blksize_t size = v18;
  *(timespec *)v22.st_qspare = v18;
  v22.st_birthtimespec = v18;
  *(timespec *)&v22.st_size_t size = v18;
  v22.st_mtimespec = v18;
  v22.st_ctimespec = v18;
  *(timespec *)&v22.st_uid = v18;
  v22.st_atimespec = v18;
  if (v15 >= 0) {
    int v19 = (const char *)a2;
  }
  else {
    int v19 = v14;
  }
  *(timespec *)&v22.st_dev = v18;
  *(unsigned char *)(a2 + 32) = stat(v19, &v22) == 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1A616FDF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if (a14 < 0)
    {
LABEL_5:
      operator delete(a9);
      if ((*(char *)(v21 + 23) & 0x80000000) == 0) {
        goto LABEL_9;
      }
LABEL_8:
      operator delete(*(void **)v21);
LABEL_9:
      _Unwind_Resume(a1);
    }
  }
  else if (a14 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v21 + 23) & 0x80000000) == 0) {
    goto LABEL_9;
  }
  goto LABEL_8;
}

uint64_t diag::loadDMC(uint64_t a1)
{
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string __p = v1;
  long long v14 = v1;
  diag::getFileInfo(a1, (uint64_t)__p);
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v16.st_blksize_t size = v2;
  *(timespec *)v16.st_qspare = v2;
  v16.st_birthtimespec = v2;
  *(timespec *)&v16.st_size_t size = v2;
  v16.st_mtimespec = v2;
  v16.st_ctimespec = v2;
  *(timespec *)&v16.st_uid = v2;
  v16.st_atimespec = v2;
  *(timespec *)&v16.st_dev = v2;
  if ((SBYTE7(v14) & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if (stat((const char *)v3, &v16))
  {
    uint64_t v4 = 0;
    goto LABEL_6;
  }
  if ((SBYTE7(v14) & 0x80u) == 0) {
    BOOL v6 = __p;
  }
  else {
    BOOL v6 = (void **)__p[0];
  }
  uint64_t v4 = MEMORY[0x1A6273D70](v6, *MEMORY[0x1E4F1CF80], kETLDIAGLoggingDefaultView, 0);
  if (!v4) {
    goto LABEL_6;
  }
  char IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  char IsInternalBuild = TelephonyUtilIsInternalBuild();
  char v9 = IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild();
  if (BYTE12(v14))
  {
    if ((v9 & 1) != 0 && DWORD2(v14) && DWORD2(v14) != 7) {
      goto LABEL_6;
    }
  }
  else if (v9)
  {
    goto LABEL_6;
  }
  *(void *)&v16.st_dev = 0;
  unsigned int DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (DefaultFilters)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 24 * DefaultFilters;
    do
    {
      ETLDMCLogFilter();
      v11 += 24;
    }
    while (v12 != v11);
  }
LABEL_6:
  if (SBYTE7(v14) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1A616FFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t diag::filterDMC()
{
  unsigned int DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (!DefaultFilters) {
    return 0;
  }
  uint64_t v1 = 0;
  int v2 = 0;
  uint64_t v3 = 24 * DefaultFilters;
  do
  {
    v2 |= ETLDMCLogFilter();
    v1 += 24;
  }
  while (v3 != v1);
  return v2 & 1;
}

uint64_t diag::mergeDMC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)xpc_object_t v51 = v7;
  long long v52 = v7;
  diag::getFileInfo(a1, (uint64_t)v51);
  unint64_t v50 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v48 = v8;
  long long v49 = v8;
  diag::getFileInfo(a2, (uint64_t)v48);
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string __p = v9;
  long long v46 = v9;
  diag::getFileInfo(a3, (uint64_t)__p);
  v10.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v10.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize_t size = v10;
  *(timespec *)v54.st_qspare = v10;
  v54.st_birthtimespec = v10;
  *(timespec *)&v54.st_size_t size = v10;
  v54.st_mtimespec = v10;
  v54.st_ctimespec = v10;
  *(timespec *)&v54.st_uid = v10;
  v54.st_atimespec = v10;
  *(timespec *)&v54.st_dev = v10;
  if ((SBYTE7(v52) & 0x80u) == 0) {
    uint64_t v11 = v51;
  }
  else {
    uint64_t v11 = (void **)v51[0];
  }
  if (stat((const char *)v11, &v54))
  {
    uint64_t v12 = 0;
  }
  else
  {
    if ((SBYTE7(v52) & 0x80u) == 0) {
      unint64_t v13 = v51;
    }
    else {
      unint64_t v13 = (void **)v51[0];
    }
    uint64_t v12 = (const void *)MEMORY[0x1A6273D70](v13, *MEMORY[0x1E4F1CF80], kETLDIAGLoggingDefaultView, a4);
  }
  if (v12) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = a4;
  }
  v15.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v15.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize_t size = v15;
  *(timespec *)v54.st_qspare = v15;
  v54.st_birthtimespec = v15;
  *(timespec *)&v54.st_size_t size = v15;
  v54.st_mtimespec = v15;
  v54.st_ctimespec = v15;
  *(timespec *)&v54.st_uid = v15;
  v54.st_atimespec = v15;
  *(timespec *)&v54.st_dev = v15;
  if ((SBYTE7(v49) & 0x80u) == 0) {
    stat v16 = v48;
  }
  else {
    stat v16 = (void **)v48[0];
  }
  if (stat((const char *)v16, &v54))
  {
    uint64_t v17 = 0;
  }
  else
  {
    if ((SBYTE7(v49) & 0x80u) == 0) {
      timespec v18 = v48;
    }
    else {
      timespec v18 = (void **)v48[0];
    }
    uint64_t v17 = (const void *)MEMORY[0x1A6273D70](v18, *MEMORY[0x1E4F1CF80], kETLDIAGLoggingDefaultView, v14);
  }
  if (v17) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = v14;
  }
  v19.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v19.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v54.st_blksize_t size = v19;
  *(timespec *)v54.st_qspare = v19;
  v54.st_birthtimespec = v19;
  *(timespec *)&v54.st_size_t size = v19;
  v54.st_mtimespec = v19;
  v54.st_ctimespec = v19;
  *(timespec *)&v54.st_uid = v19;
  v54.st_atimespec = v19;
  *(timespec *)&v54.st_dev = v19;
  if ((SBYTE7(v46) & 0x80u) == 0) {
    xpc_object_t v20 = __p;
  }
  else {
    xpc_object_t v20 = (void **)__p[0];
  }
  if (stat((const char *)v20, &v54))
  {
    uint64_t v21 = 0;
    if (!v12) {
      goto LABEL_44;
    }
  }
  else
  {
    if ((SBYTE7(v46) & 0x80u) == 0) {
      stat v22 = __p;
    }
    else {
      stat v22 = (void **)__p[0];
    }
    uint64_t v21 = (const void *)MEMORY[0x1A6273D70](v22, *MEMORY[0x1E4F1CF80], kETLDIAGLoggingDefaultView, v14);
    if (!v12) {
      goto LABEL_44;
    }
  }
  char IsCarrierBuild = TelephonyUtilIsCarrierBuild();
  char IsInternalBuild = TelephonyUtilIsInternalBuild();
  char v25 = IsCarrierBuild | IsInternalBuild | TelephonyUtilIsVendorBuild();
  if (BYTE12(v52))
  {
    if ((v25 & 1) != 0 && DWORD2(v52) && DWORD2(v52) != 7) {
      goto LABEL_44;
    }
  }
  else if (v25)
  {
    goto LABEL_44;
  }
  *(void *)&v54.st_dev = 0;
  unsigned int DefaultFilters = ETLDMCLogGetDefaultFilters();
  if (DefaultFilters)
  {
    uint64_t v27 = 0;
    uint64_t v28 = 24 * DefaultFilters;
    do
    {
      ETLDMCLogFilter();
      v27 += 24;
    }
    while (v28 != v27);
  }
LABEL_44:
  if (!v17) {
    goto LABEL_54;
  }
  char v29 = TelephonyUtilIsCarrierBuild();
  char v30 = TelephonyUtilIsInternalBuild();
  char v31 = v29 | v30 | TelephonyUtilIsVendorBuild();
  if (BYTE12(v49))
  {
    if ((v31 & 1) != 0 && DWORD2(v49) && DWORD2(v49) != 7) {
      goto LABEL_54;
    }
  }
  else if (v31)
  {
    goto LABEL_54;
  }
  *(void *)&v54.st_dev = 0;
  unsigned int v32 = ETLDMCLogGetDefaultFilters();
  if (v32)
  {
    uint64_t v33 = 0;
    uint64_t v34 = 24 * v32;
    do
    {
      ETLDMCLogFilter();
      v33 += 24;
    }
    while (v34 != v33);
  }
LABEL_54:
  if (!v21)
  {
    if (v12 && v17)
    {
      uint64_t v38 = ETLDMCMerge();
      CFRelease(v12);
      CFRelease(v17);
      goto LABEL_72;
    }
    goto LABEL_78;
  }
  char v35 = TelephonyUtilIsCarrierBuild();
  char v36 = TelephonyUtilIsInternalBuild();
  char v37 = v35 | v36 | TelephonyUtilIsVendorBuild();
  if (BYTE12(v46))
  {
    if ((v37 & 1) != 0 && DWORD2(v46) && DWORD2(v46) != 7) {
      goto LABEL_67;
    }
LABEL_64:
    *(void *)&v54.st_dev = 0;
    unsigned int v39 = ETLDMCLogGetDefaultFilters();
    if (v39)
    {
      uint64_t v40 = 0;
      uint64_t v41 = 24 * v39;
      do
      {
        ETLDMCLogFilter();
        v40 += 24;
      }
      while (v41 != v40);
    }
    goto LABEL_67;
  }
  if ((v37 & 1) == 0) {
    goto LABEL_64;
  }
LABEL_67:
  if (v12 && v17)
  {
    std::string v42 = (const void *)ETLDMCMerge();
    uint64_t v38 = ETLDMCMerge();
    CFRelease(v12);
    CFRelease(v17);
    CFRelease(v21);
    CFRelease(v42);
    goto LABEL_72;
  }
  if (v17)
  {
    uint64_t v38 = ETLDMCMerge();
    CFRelease(v17);
    CFRelease(v21);
    goto LABEL_72;
  }
  if (v12)
  {
    uint64_t v38 = ETLDMCMerge();
    CFRelease(v12);
    CFRelease(v21);
LABEL_72:
    if ((SBYTE7(v46) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_85;
  }
LABEL_78:
  if (v17) {
    uint64_t v44 = (uint64_t)v17;
  }
  else {
    uint64_t v44 = (uint64_t)v21;
  }
  if (v12) {
    uint64_t v38 = (uint64_t)v12;
  }
  else {
    uint64_t v38 = v44;
  }
  if ((SBYTE7(v46) & 0x80000000) == 0)
  {
LABEL_73:
    if ((SBYTE7(v49) & 0x80000000) == 0) {
      goto LABEL_74;
    }
LABEL_86:
    operator delete(v48[0]);
    if ((SBYTE7(v52) & 0x80000000) == 0) {
      return v38;
    }
LABEL_87:
    operator delete(v51[0]);
    return v38;
  }
LABEL_85:
  operator delete(__p[0]);
  if (SBYTE7(v49) < 0) {
    goto LABEL_86;
  }
LABEL_74:
  if (SBYTE7(v52) < 0) {
    goto LABEL_87;
  }
  return v38;
}

void sub_1A6170594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a23 < 0)
  {
    operator delete(__p);
    if ((a32 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a32 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a27);
  _Unwind_Resume(exception_object);
}

BOOL diag::copyDMC(uint64_t a1, const void **a2)
{
  diag::getFileInfo(a1, (uint64_t)&v27);
  *(_OWORD *)char v25 = *(_OWORD *)&v27.st_dev;
  uint64_t v26 = *(void *)&v27.st_uid;
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  unint64_t v6 = v5 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v5 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v6 >= 0x17)
  {
    uint64_t v8 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v8 = v6 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v5 + 1;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v5 + 1;
    if (!v5) {
      goto LABEL_15;
    }
  }
  if (v4 >= 0) {
    timespec v10 = a2;
  }
  else {
    timespec v10 = *a2;
  }
  memmove(p_dst, v10, v5);
LABEL_15:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v5) = 47;
  int v11 = *(char *)(a1 + 23);
  if (v11 >= 0) {
    uint64_t v12 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v12 = *(const std::string::value_type **)a1;
  }
  if (v11 >= 0) {
    std::string::size_type v13 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v13 = *(void *)(a1 + 8);
  }
  uint64_t v14 = std::string::append(&__dst, v12, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  *(void *)&v27.st_uid = *((void *)&v14->__r_.__value_.__l + 2);
  *(_OWORD *)&v27.st_dev = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  stat v16 = std::string::append((std::string *)&v27, ".dmc", 4uLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  std::string::size_type v24 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v27.st_gid) < 0)
  {
    operator delete(*(void **)&v27.st_dev);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_23;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_23:
  v18.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v27.st_blksize_t size = v18;
  *(timespec *)v27.st_qspare = v18;
  v27.st_birthtimespec = v18;
  *(timespec *)&v27.st_size_t size = v18;
  v27.st_mtimespec = v18;
  v27.st_ctimespec = v18;
  *(timespec *)&v27.st_uid = v18;
  v27.st_atimespec = v18;
  *(timespec *)&v27.st_dev = v18;
  if (v26 >= 0) {
    timespec v19 = v25;
  }
  else {
    timespec v19 = (void **)v25[0];
  }
  if (stat((const char *)v19, &v27))
  {
    BOOL v20 = 0;
    if ((SHIBYTE(v24) & 0x80000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  BOOL v20 = support::fs::copyFile((const char *)v25, (const char *)__p, 0);
  if (SHIBYTE(v24) < 0) {
LABEL_28:
  }
    operator delete(__p[0]);
LABEL_29:
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
  return v20;
}

void sub_1A6170844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _GLOBAL__sub_I_DIAGUtil_cpp()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  kETLDIAGLoggingDefaultView = result;
  return result;
}

void *abm::LogCompressionTask::LogCompressionTask(void *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  size_t v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v12 = *a3;
  std::string::size_type v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v10 = *a4;
  int v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  abm::HelperTask::HelperTask((uint64_t)a1, a2, &v12, &v10);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  long long v7 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  *a1 = &unk_1EFB0CE00;
  a1[17] = 0;
  uint64_t v8 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  a1[18] = dispatch_queue_create("log.compression.task.queue", v8);
  return a1;
}

void sub_1A61709C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void abm::LogCompressionTask::~LogCompressionTask(abm::LogCompressionTask *this)
{
  *(void *)this = &unk_1EFB0CE00;
  int v2 = (void *)*((void *)this + 17);
  if (v2)
  {
    operator delete[](v2);
    *((void *)this + 17) = 0;
  }
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    dispatch_release(v3);
  }
  *(void *)this = &unk_1EFB0FCB8;
  int v4 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  size_t v5 = *((void *)this + 14);
  if (v5) {
    dispatch_release(v5);
  }
  *(void *)this = &unk_1EFB09350;
  MEMORY[0x1A6274710]((char *)this + 8);
  unint64_t v6 = *((void *)this + 12);
  if (v6) {
    dispatch_release(v6);
  }
  long long v7 = *((void *)this + 11);
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

{
  void *v1;
  uint64_t vars8;

  abm::LogCompressionTask::~LogCompressionTask(this);

  operator delete(v1);
}

void *abm::LogCompressionTask::getName(abm::LogCompressionTask *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_17, memory_order_acquire) & 1) != 0
    || !__cxa_guard_acquire(&_MergedGlobals_17))
  {
    return qword_1EB5EEAF0;
  }
  unsigned int v3 = *((_DWORD *)this + 26) - 1;
  if (v3 > 9) {
    int v4 = "invalid";
  }
  else {
    int v4 = off_1E5C47C88[v3];
  }
  std::string::basic_string[abi:ne180100]<0>(qword_1EB5EEAF0, v4);
  __cxa_atexit(MEMORY[0x1E4FBA210], qword_1EB5EEAF0, &dword_1A609F000);
  __cxa_guard_release(&_MergedGlobals_17);
  return qword_1EB5EEAF0;
}

void sub_1A6170BAC(_Unwind_Exception *a1)
{
}

void abm::LogCompressionTask::init_sync(abm::LogCompressionTask *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v2) {
    goto LABEL_26;
  }
  uint64_t v3 = *((void *)this + 9);
  int v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    goto LABEL_26;
  }
  size_t v5 = v4;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EEAD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB5EEAD8))
  {
    __cxa_atexit((void (*)(void *))std::weak_ptr<abm::HelperTask>::~weak_ptr, &qword_1EB5EEAE0, &dword_1A609F000);
    __cxa_guard_release(&qword_1EB5EEAD8);
  }
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  unint64_t v6 = (std::__shared_weak_count *)qword_1EB5EEAE8;
  qword_1EB5EEAE0 = v3;
  qword_1EB5EEAE8 = (uint64_t)v5;
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  long long v7 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v7 || (v8 = *((void *)this + 9), (uint64_t v9 = std::__shared_weak_count::lock(v7)) == 0)) {
LABEL_26:
  }
    std::__throw_bad_weak_ptr[abi:ne180100]();
  uint64_t v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v10);
  }
  int v11 = *((void *)this + 18);
  uint64_t v12 = operator new(8uLL);
  *uint64_t v12 = this;
  dispatch_async_f(v11, v12, (dispatch_function_t)dispatch::async<abm::LogCompressionTask::init_sync(void)::$_0>(dispatch_queue_s *,std::unique_ptr<abm::LogCompressionTask::init_sync(void)::$_0,std::default_delete<abm::LogCompressionTask::init_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke);
  std::string::size_type v13 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v13)
  {
    uint64_t v14 = std::__shared_weak_count::lock(v13);
    std::string::size_type v24 = v14;
    if (v14)
    {
      long long v15 = v14;
      uint64_t v16 = *((void *)this + 15);
      uint64_t v23 = v16;
      if (v16)
      {
        v22[23] = 20;
        strcpy(v22, "CommandCreateArchive");
        aBlock[0] = MEMORY[0x1E4F143A8];
        aBlock[1] = 1174405120;
        aBlock[2] = ___ZN3abm18LogCompressionTask9init_syncEv_block_invoke;
        aBlock[3] = &__block_descriptor_tmp_24;
        aBlock[4] = this;
        void aBlock[5] = v8;
        BOOL v20 = v10;
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        long long v17 = _Block_copy(aBlock);
        timespec v18 = *((void *)this + 11);
        if (v18) {
          dispatch_retain(v18);
        }
        v21[0] = v17;
        v21[1] = v18;
        abm::HelperServerInternal::setCommandHandler(v16, (uint64_t)v22, (uint64_t)v21);
        if (v18) {
          dispatch_release(v18);
        }
        if (v17) {
          _Block_release(v17);
        }
        if (v20) {
          std::__shared_weak_count::__release_weak(v20);
        }
      }
      if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }
  std::__shared_weak_count::__release_weak(v10);
}

void sub_1A6170E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::ServerClientState,xpc::dict,dispatch::callback<void({block_pointer})(int,xpc::dict)>)>::~callback((uint64_t)&a17);
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v18 - 64);
  std::__shared_weak_count::__release_weak(v17);
  _Unwind_Resume(a1);
}

void ___ZN3abm18LogCompressionTask9init_syncEv_block_invoke(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  size_t v5 = (NSObject **)a1[4];
  uint64_t v46 = 0;
  unint64_t v47 = 0;
  unint64_t v6 = (std::__shared_weak_count *)a1[6];
  if (v6)
  {
    unint64_t v47 = std::__shared_weak_count::lock(v6);
    if (!v47) {
      return;
    }
    uint64_t v46 = a1[5];
    if (v46)
    {
      if (*(void *)a4 && *(void *)(a4 + 8))
      {
        uint64_t v9 = v5[14];
        if (v9)
        {
          dispatch_retain(v5[14]);
          dispatch_group_enter(v9);
        }
        if (MEMORY[0x1A6275E60](*a3) == MEMORY[0x1E4F14590])
        {
          unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v45 = (atomic_ullong *)0xAAAAAAAAAAAAAAAALL;
          uint64_t v12 = (ctu::XpcJetsamAssertion *)pthread_mutex_lock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
          uint64_t v13 = xmmword_1EB5EE590;
          if (!(void)xmmword_1EB5EE590)
          {
            ctu::XpcJetsamAssertion::create_default_global((uint64_t *)&block, v12);
            long long v14 = block;
            blocuint64_t k = 0uLL;
            long long v15 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
            xmmword_1EB5EE590 = v14;
            if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
              std::__shared_weak_count::__release_weak(v15);
            }
            uint64_t v16 = (std::__shared_weak_count *)*((void *)&block + 1);
            if (*((void *)&block + 1)
              && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&block + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
            uint64_t v13 = xmmword_1EB5EE590;
          }
          long long v17 = (std::__shared_weak_count *)*((void *)&xmmword_1EB5EE590 + 1);
          uint64_t v42 = v13;
          uint64_t v43 = *((void *)&xmmword_1EB5EE590 + 1);
          if (*((void *)&xmmword_1EB5EE590 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_1EB5EE590 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
          char v41 = 14;
          strcpy((char *)__p, "Archiving Logs");
          ctu::XpcJetsamAssertion::createActivity();
          if (v41 < 0) {
            operator delete(__p[0]);
          }
          if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
          uint64_t v18 = a1[5];
          uint64_t v19 = a1[6];
          *(void *)&blocuint64_t k = v18;
          *((void *)&block + 1) = v19;
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 16), 1uLL, memory_order_relaxed);
          }
          uint64_t v33 = (void (*)(uint64_t))v9;
          if (v9)
          {
            dispatch_retain(v9);
            dispatch_group_enter(v9);
          }
          unint64_t v20 = v44;
          uint64_t v21 = v45;
          uint64_t v34 = (void *)v44;
          aBlocuint64_t k = v45;
          if (v45) {
            atomic_fetch_add_explicit(v45 + 1, 1uLL, memory_order_relaxed);
          }
          xpc_object_t v22 = (xpc_object_t)*a3;
          xpc_object_t object = v5;
          xpc_object_t v37 = v22;
          if (v22)
          {
            xpc_retain(v22);
          }
          else
          {
            xpc_object_t v22 = xpc_null_create();
            xpc_object_t v37 = v22;
          }
          if (*(void *)a4) {
            char v25 = _Block_copy(*(const void **)a4);
          }
          else {
            char v25 = 0;
          }
          uint64_t v26 = *(NSObject **)(a4 + 8);
          uint64_t v38 = v25;
          unsigned int v39 = v26;
          if (v26) {
            dispatch_retain(v26);
          }
          queue = v5[18];
          stat v27 = operator new(0x48uLL);
          uint64_t v28 = v27;
          *stat v27 = v18;
          v27[1] = v19;
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 16), 1uLL, memory_order_relaxed);
          }
          uint64_t v33 = 0;
          void v27[2] = v9;
          v27[3] = v20;
          uint64_t v34 = 0;
          aBlocuint64_t k = 0;
          _OWORD v27[4] = v21;
          v27[5] = v5;
          v27[6] = v22;
          xpc_object_t v29 = xpc_null_create();
          v28[7] = v25;
          v28[8] = v26;
          uint64_t v38 = 0;
          unsigned int v39 = 0;
          xpc_object_t v37 = v29;
          dispatch_async_f(queue, v28, (dispatch_function_t)_ZZN8dispatch5asyncIZZN3abm18LogCompressionTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_);
          _ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev((uint64_t)&block);
          char v30 = (std::__shared_weak_count *)v45;
          if (v45 && !atomic_fetch_add(v45 + 1, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
            std::__shared_weak_count::__release_weak(v30);
          }
          goto LABEL_45;
        }
        xpc_object_t v10 = xpc_null_create();
        if (*(void *)a4) {
          int v11 = _Block_copy(*(const void **)a4);
        }
        else {
          int v11 = 0;
        }
        uint64_t v23 = *(NSObject **)(a4 + 8);
        *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
        *((void *)&block + 1) = 1174405120;
        uint64_t v33 = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0;
        uint64_t v34 = &__block_descriptor_tmp_34;
        if (v11)
        {
          LODWORD(v37) = -534716414;
          aBlocuint64_t k = _Block_copy(v11);
          xpc_object_t object = v10;
          if (v10)
          {
LABEL_37:
            xpc_retain(v10);
LABEL_40:
            dispatch_async(v23, &block);
            xpc_release(object);
            xpc_object_t object = 0;
            if (aBlock) {
              _Block_release(aBlock);
            }
            if (v11) {
              _Block_release(v11);
            }
            xpc_release(v10);
LABEL_45:
            if (v9)
            {
              dispatch_group_leave(v9);
              dispatch_release(v9);
            }
            goto LABEL_47;
          }
        }
        else
        {
          LODWORD(v37) = -534716414;
          aBlocuint64_t k = 0;
          xpc_object_t object = v10;
          if (v10) {
            goto LABEL_37;
          }
        }
        xpc_object_t object = xpc_null_create();
        goto LABEL_40;
      }
    }
  }
LABEL_47:
  std::string::size_type v24 = v47;
  if (v47)
  {
    if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

void sub_1A61713A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  pthread_mutex_unlock(&ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance);
  if (v27)
  {
    dispatch_group_leave(v27);
    dispatch_release(v27);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v28 - 104);
  _Unwind_Resume(a1);
}

uint64_t _ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 64);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 56);
  if (v3) {
    _Block_release(v3);
  }
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  int v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  size_t v5 = *(NSObject **)(a1 + 16);
  if (v5)
  {
    dispatch_group_leave(v5);
    unint64_t v6 = *(NSObject **)(a1 + 16);
    if (v6) {
      dispatch_release(v6);
    }
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t std::weak_ptr<abm::HelperTask>::~weak_ptr(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void abm::LogCompressionTask::initWorkspace_sync(abm::LogCompressionTask *this)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_debug_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEBUG, "#D Initialization of Workspace", buf, 2u);
  }
  strlen(abm::trace::kSnapshotFolder[0]);
  ctu::fs::create_directory();
  uint64_t v3 = abm::trace::kPendingCompressionFolder;
  size_t v4 = strlen(abm::trace::kPendingCompressionFolder);
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v22 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_10;
  }
  HIBYTE(v22) = v4;
  unint64_t v6 = __dst;
  if (v4) {
LABEL_10:
  }
    memmove(v6, v3, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  uint64_t v9 = abm::trace::kSnapshotFolder[0];
  size_t v10 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v10 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  int v11 = (void *)v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    uint64_t v12 = operator new(v13 + 1);
    __p[1] = v11;
    unint64_t v20 = v14 | 0x8000000000000000;
    __p[0] = v12;
  }
  else
  {
    HIBYTE(v20) = v10;
    uint64_t v12 = __p;
    if (!v10) {
      goto LABEL_19;
    }
  }
  memmove(v12, v9, (size_t)v11);
LABEL_19:
  *((unsigned char *)v11 + (void)v12) = 0;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)v17, "[^\\.].*", 0);
  util::moveDirContent((std::string::size_type)__dst, (uint64_t)__p, 1u, 1, (uint64_t)v17);
  long long v15 = v18;
  if (!v18 || atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    std::locale::~locale(v17);
    if ((SHIBYTE(v20) & 0x80000000) == 0) {
      goto LABEL_22;
    }
LABEL_27:
    operator delete(__p[0]);
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_28;
  }
  ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
  std::__shared_weak_count::__release_weak(v15);
  std::locale::~locale(v17);
  if (SHIBYTE(v20) < 0) {
    goto LABEL_27;
  }
LABEL_22:
  if ((SHIBYTE(v22) & 0x80000000) == 0) {
    goto LABEL_23;
  }
LABEL_28:
  operator delete(__dst[0]);
LABEL_23:
  strlen(abm::trace::kPendingCompressionFolder);
  ctu::fs::create_directory();
  uint64_t v16 = *((void *)this + 5);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 136315394;
    std::string::size_type v24 = abm::trace::kPendingCompressionFolder;
    __int16 v25 = 2080;
    uint64_t v26 = abm::trace::kSnapshotFolder[0];
    _os_log_debug_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEBUG, "#D Moved %s/*/* -> %s/", buf, 0x16u);
  }
}

void sub_1A617185C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a28 < 0)
  {
    operator delete(a23);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t abm::LogCompressionTask::archive_sync(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  xpc_object_t value = xpc_dictionary_get_value(*a2, "Mode");
  *(void *)CFStringRef v121 = value;
  if (value) {
    xpc_retain(value);
  }
  else {
    *(void *)CFStringRef v121 = xpc_null_create();
  }
  uint64_t IsInternalBuild = TelephonyUtilIsInternalBuild();
  if ((IsInternalBuild & 1) != 0 || (uint64_t IsInternalBuild = TelephonyUtilIsCarrierBuild(), IsInternalBuild)) {
    capabilities::trace::getCompressionMode((capabilities::trace *)IsInternalBuild);
  }
  unsigned int v6 = xpc::dyn_cast_or_default();
  xpc_release(*(xpc_object_t *)v121);
  if (v6)
  {
    xpc_object_t v7 = xpc_dictionary_get_value(*a2, "SplitArchive");
    *(void *)CFStringRef v121 = v7;
    if (v7) {
      xpc_retain(v7);
    }
    else {
      *(void *)CFStringRef v121 = xpc_null_create();
    }
    int v10 = xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)v121);
    memset(v120, 170, sizeof(v120));
    xpc_object_t v11 = xpc_dictionary_get_value(*a2, "TimestampString");
    object.__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
    if (v11) {
      xpc_retain(v11);
    }
    else {
      object.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
    }
    Timestamp::Timestamp((Timestamp *)&buf);
    Timestamp::asString(v12, 0, 9, v121);
    xpc::dyn_cast_or_default();
    if ((v121[23] & 0x80000000) != 0) {
      operator delete(*(void **)v121);
    }
    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&buf, (void *)buf.__r_.__value_.__l.__size_);
    xpc_release(object.__r_.__value_.__l.__data_);
    memset(&object, 170, sizeof(object));
    uint64_t v13 = abm::trace::kPendingCompressionFolder;
    size_t v14 = strlen(abm::trace::kPendingCompressionFolder);
    if (v14 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v15 = v14;
    if (v14 >= 0x17)
    {
      uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v17 = v14 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_dst = (std::string *)operator new(v17 + 1);
      __dst.__r_.__value_.__l.__size_ = v15;
      __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14;
      p_dst = &__dst;
      if (!v14)
      {
LABEL_27:
        p_dst->__r_.__value_.__s.__data_[v15] = 0;
        if (SHIBYTE(v120[2]) >= 0) {
          uint64_t v19 = (const std::string::value_type *)v120;
        }
        else {
          uint64_t v19 = (const std::string::value_type *)v120[0];
        }
        if (SHIBYTE(v120[2]) >= 0) {
          std::string::size_type v20 = HIBYTE(v120[2]);
        }
        else {
          std::string::size_type v20 = (std::string::size_type)v120[1];
        }
        uint64_t v21 = std::string::append(&__dst, v19, v20);
        long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
        buf.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v22;
        v21->__r_.__value_.__l.__size_ = 0;
        v21->__r_.__value_.__r.__words[2] = 0;
        v21->__r_.__value_.__r.__words[0] = 0;
        ctu::fs::get_unique_pathname();
        uint64_t v23 = std::string::append((std::string *)v121, "/", 1uLL);
        long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
        object.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
        *(_OWORD *)&object.__r_.__value_.__l.__data_ = v24;
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        if ((v121[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)v121);
          if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_35:
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_36;
            }
LABEL_40:
            operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_36:
            memset(&__dst, 170, sizeof(__dst));
            xpc_object_t v25 = xpc_dictionary_get_value(*a2, "ArchiveSource");
            *(void *)CFStringRef v121 = v25;
            if (v25) {
              xpc_retain(v25);
            }
            else {
              *(void *)CFStringRef v121 = xpc_null_create();
            }
            xpc::dyn_cast_or_default();
            xpc_release(*(xpc_object_t *)v121);
            memset(&v117, 170, sizeof(v117));
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              std::string::__init_copy_ctor_external(&v117, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string v117 = __dst;
            }
            memset(v116, 170, sizeof(v116));
            xpc_object_t v26 = xpc_dictionary_get_value(*a2, "ArchiveDestFileName");
            *(void *)CFStringRef v121 = v26;
            if (v26) {
              xpc_retain(v26);
            }
            else {
              *(void *)CFStringRef v121 = xpc_null_create();
            }
            xpc::dyn_cast_or_default();
            xpc_release(*(xpc_object_t *)v121);
            v121[23] = 1;
            strcpy(v121, ".");
            uint64_t v27 = abm::trace::kLogTarExtension;
            if (v6 == 1) {
              uint64_t v27 = &abm::trace::kLogTarGzExtension;
            }
            uint64_t v28 = *v27;
            size_t v29 = strlen(*v27);
            char v30 = std::string::append((std::string *)v121, v28, v29);
            std::string v115 = *v30;
            v30->__r_.__value_.__l.__size_ = 0;
            v30->__r_.__value_.__r.__words[2] = 0;
            v30->__r_.__value_.__r.__words[0] = 0;
            if ((v121[23] & 0x80000000) != 0) {
              operator delete(*(void **)v121);
            }
            uint64_t v123 = 47;
            size_t v124 = 1;
            v121[0] = -86;
            std::__sort<std::__less<char,char> &,char *>();
            int v31 = v10;
            uint64_t v99 = a1;
            char v32 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
            std::string::size_type size = v117.__r_.__value_.__l.__size_;
            std::string::size_type v33 = v117.__r_.__value_.__r.__words[0];
            if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v35 = &v117;
            }
            else {
              char v35 = (std::string *)v117.__r_.__value_.__r.__words[0];
            }
            std::string::size_type v36 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
            if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v37 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v37 = v117.__r_.__value_.__l.__size_;
            }
            size_t v38 = v124;
            buf.__r_.__value_.__r.__words[2] = v124;
            buf.__r_.__value_.__r.__words[0] = 0;
            if (v124 >= 0x11)
            {
              p_std::string buf = (std::string *)operator new[](v124);
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
              uint64_t v40 = (uint64_t *)v123;
            }
            else
            {
              p_std::string buf = &buf;
              uint64_t v40 = &v123;
            }
            memcpy(p_buf, v40, v38);
            size_t v41 = buf.__r_.__value_.__r.__words[2];
            *(void *)&v121[16] = *((void *)&buf.__r_.__value_.__l + 2);
            *(void *)CFStringRef v121 = 0;
            unsigned int v98 = v6;
            if (buf.__r_.__value_.__r.__words[2] >= 0x11)
            {
              uint64_t v43 = operator new[](buf.__r_.__value_.__r.__words[2]);
              *(void *)CFStringRef v121 = v43;
              uint64_t v42 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            else
            {
              uint64_t v42 = &buf;
              uint64_t v43 = v121;
            }
            unint64_t v44 = (std::string *)((char *)v35 + v37);
            memcpy(v43, v42, v41);
            if (*(void *)&v121[16] >= 0x11uLL)
            {
              stat v54 = (std::string *)((char *)v35 + v37);
              while (v54 != v35)
              {
                unint64_t v44 = v54;
                int v56 = SHIBYTE(v54[-1].__r_.__value_.__r.__words[2]);
                stat v54 = (std::string *)((char *)v54 - 1);
                int v55 = v56;
                unint64_t v57 = *(void *)&v121[16];
                long long v58 = *(char **)v121;
                do
                {
                  unint64_t v59 = v57 >> 1;
                  xpc_object_t v60 = &v58[v57 >> 1];
                  int v62 = *v60;
                  unsigned int v61 = v60 + 1;
                  v57 += ~(v57 >> 1);
                  if (v62 >= v55) {
                    unint64_t v57 = v59;
                  }
                  else {
                    long long v58 = v61;
                  }
                }
                while (v57);
                if (v58 == (char *)(*(void *)v121 + *(void *)&v121[16]) || *v58 > v55) {
                  goto LABEL_89;
                }
              }
              unint64_t v44 = v35;
            }
            else
            {
              if (*(void *)&v121[16])
              {
                uint64_t v45 = (std::string *)((char *)v35 + v37);
                while (v45 != v35)
                {
                  unint64_t v44 = v45;
                  int v47 = SHIBYTE(v45[-1].__r_.__value_.__r.__words[2]);
                  uint64_t v45 = (std::string *)((char *)v45 - 1);
                  int v46 = v47;
                  uint64_t v48 = v121;
                  unint64_t v49 = *(void *)&v121[16];
                  do
                  {
                    unint64_t v50 = v49 >> 1;
                    xpc_object_t v51 = &v48[v49 >> 1];
                    int v53 = *v51;
                    long long v52 = v51 + 1;
                    v49 += ~(v49 >> 1);
                    if (v53 >= v46) {
                      unint64_t v49 = v50;
                    }
                    else {
                      uint64_t v48 = v52;
                    }
                  }
                  while (v49);
                  if (v48 == &v121[*(void *)&v121[16]] || *v48 > v46) {
                    goto LABEL_89;
                  }
                }
                unint64_t v44 = v35;
LABEL_92:
                xpc_object_t v63 = &v117;
                if (v32 >= 0)
                {
                  std::string::size_type v64 = v36;
                }
                else
                {
                  xpc_object_t v63 = (std::string *)v33;
                  std::string::size_type v64 = size;
                }
                std::string::size_type v65 = (char *)v44 - (char *)v63;
                if (v64 < (char *)v44 - (char *)v63) {
                  std::string::__throw_out_of_range[abi:ne180100]();
                }
                std::string::size_type v66 = (char *)v63 + v64 - (char *)v44;
                if (v66 == -1)
                {
                  unsigned int v67 = v98;
                  if (v32 < 0)
                  {
                    v117.__r_.__value_.__l.__size_ = v65;
                    *(unsigned char *)(v33 + v65) = 0;
                    if (v41 < 0x11) {
                      goto LABEL_103;
                    }
LABEL_101:
                    if (buf.__r_.__value_.__r.__words[0]) {
                      operator delete[](buf.__r_.__value_.__l.__data_);
                    }
LABEL_103:
                    if (v124 >= 0x11 && v123) {
                      operator delete[]((void *)v123);
                    }
                    std::string::append(&v117, "-lite", 5uLL);
                    *(void *)&long long v68 = 0xAAAAAAAAAAAAAAAALL;
                    *((void *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
                    *(_OWORD *)&v121[16] = v68;
                    long long v122 = v68;
                    *(_OWORD *)CFStringRef v121 = v68;
                    uint64_t v69 = *(NSObject **)(v99 + 40);
                    os_signpost_id_t v70 = os_signpost_id_generate(v69);
                    if (v70 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
                    {
                      xpc_object_t v71 = *(NSObject **)(v99 + 40);
                      if (os_signpost_enabled(v71))
                      {
                        uint64_t v72 = v120;
                        if (SHIBYTE(v120[2]) < 0) {
                          uint64_t v72 = (void **)v120[0];
                        }
                        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v72;
                        _os_signpost_emit_with_name_impl(&dword_1A609F000, v71, OS_SIGNPOST_INTERVAL_BEGIN, v70, "ArchivingLogs", "RequestTime=%{signpost.description:attribute}s", (uint8_t *)&buf, 0xCu);
                      }
                    }
                    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1EFB0CED8;
                    uint64_t v126 = &buf;
                    *(void *)CFStringRef v121 = v70;
                    *(void *)&v121[8] = os_retain(v69);
                    if (v126)
                    {
                      if (v126 == &buf)
                      {
                        *((void *)&v122 + 1) = &v121[16];
                        (*(void (**)(std::string *))(buf.__r_.__value_.__r.__words[0] + 24))(&buf);
                      }
                      else
                      {
                        *((void *)&v122 + 1) = v126;
                        uint64_t v126 = 0;
                      }
                    }
                    else
                    {
                      *((void *)&v122 + 1) = 0;
                    }
                    if (v126 == &buf)
                    {
                      (*(void (**)(std::string *))(buf.__r_.__value_.__r.__words[0] + 32))(&buf);
                      if (!v31) {
                        goto LABEL_165;
                      }
                    }
                    else
                    {
                      if (v126) {
                        (*(void (**)(void))(v126->__r_.__value_.__r.__words[0] + 40))();
                      }
                      if (!v31)
                      {
LABEL_165:
                        memset(&buf, 0, sizeof(buf));
                        char v108 = 0;
                        size_t v109 = 0;
                        uint64_t v110 = 0;
                        abm::resolveProcessingDirAndArchiveFileName(0, (const void **)&object.__r_.__value_.__l.__data_, (long long *)v116, (uint64_t)v120, (uint64_t)&buf, (uint64_t)&v108);
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v103, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v103 = __dst;
                        }
                        if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v102, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v102 = object;
                        }
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v101, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v101 = buf;
                        }
                        int v84 = SHIBYTE(v110);
                        if (v110 >= 0) {
                          size_t v85 = HIBYTE(v110);
                        }
                        else {
                          size_t v85 = v109;
                        }
                        int v86 = SHIBYTE(v115.__r_.__value_.__r.__words[2]);
                        if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          size_t v87 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          size_t v87 = v115.__r_.__value_.__l.__size_;
                        }
                        unint64_t v88 = v87 + v85;
                        memset(__p, 170, sizeof(__p));
                        if (v87 + v85 > 0x7FFFFFFFFFFFFFF7) {
                          std::string::__throw_length_error[abi:ne180100]();
                        }
                        if (v88 > 0x16)
                        {
                          uint64_t v94 = (v88 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v88 | 7) != 0x17) {
                            uint64_t v94 = v88 | 7;
                          }
                          uint64_t v95 = v94 + 1;
                          char v89 = (char *)operator new(v94 + 1);
                          __p[1] = (void *)(v87 + v85);
                          std::vector<std::ssub_match> __p[2] = (void *)(v95 | 0x8000000000000000);
                          __p[0] = v89;
                          if (!v85)
                          {
LABEL_187:
                            std::string v91 = &v89[v85];
                            if (v87)
                            {
                              if (v86 >= 0) {
                                uint64_t v92 = &v115;
                              }
                              else {
                                uint64_t v92 = (std::string *)v115.__r_.__value_.__r.__words[0];
                              }
                              memmove(v91, v92, v87);
                            }
                            v91[v87] = 0;
                            uint64_t v9 = abm::LogCompressionTask::archiveHelper_sync(v99, 0, (uint64_t)&v103, (const void **)&v102.__r_.__value_.__l.__data_, (uint64_t)&v101, (const void **)__p, v67);
                            if (SHIBYTE(__p[2]) < 0)
                            {
                              operator delete(__p[0]);
                              if ((SHIBYTE(v101.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              {
LABEL_194:
                                if ((SHIBYTE(v102.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                  goto LABEL_195;
                                }
                                goto LABEL_211;
                              }
                            }
                            else if ((SHIBYTE(v101.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
                              goto LABEL_194;
                            }
                            operator delete(v101.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v102.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_195:
                              if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_196;
                              }
                              goto LABEL_212;
                            }
LABEL_211:
                            operator delete(v102.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_196:
                              if ((SHIBYTE(v110) & 0x80000000) == 0) {
                                goto LABEL_197;
                              }
                              goto LABEL_213;
                            }
LABEL_212:
                            operator delete(v103.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v110) & 0x80000000) == 0)
                            {
LABEL_197:
                              if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_198;
                              }
                              goto LABEL_214;
                            }
LABEL_213:
                            operator delete(v108);
                            if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_198:
                              ctu::os::signpost_interval::~signpost_interval((ctu::os::signpost_interval *)v121);
                              if ((v86 & 0x80000000) == 0) {
                                goto LABEL_199;
                              }
                              goto LABEL_215;
                            }
LABEL_214:
                            operator delete(buf.__r_.__value_.__l.__data_);
                            ctu::os::signpost_interval::~signpost_interval((ctu::os::signpost_interval *)v121);
                            if ((v86 & 0x80000000) == 0)
                            {
LABEL_199:
                              if ((SHIBYTE(v116[2]) & 0x80000000) == 0) {
                                goto LABEL_200;
                              }
                              goto LABEL_216;
                            }
LABEL_215:
                            operator delete(v115.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v116[2]) & 0x80000000) == 0)
                            {
LABEL_200:
                              if ((SHIBYTE(v117.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_201;
                              }
                              goto LABEL_217;
                            }
LABEL_216:
                            operator delete(v116[0]);
                            if ((SHIBYTE(v117.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_201:
                              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_202;
                              }
                              goto LABEL_218;
                            }
LABEL_217:
                            operator delete(v117.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_202:
                              if ((SHIBYTE(object.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_203;
                              }
                              goto LABEL_219;
                            }
LABEL_218:
                            operator delete(__dst.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(object.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_203:
                              if ((SHIBYTE(v120[2]) & 0x80000000) == 0) {
                                return v9;
                              }
LABEL_220:
                              operator delete(v120[0]);
                              return v9;
                            }
LABEL_219:
                            operator delete(object.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v120[2]) & 0x80000000) == 0) {
                              return v9;
                            }
                            goto LABEL_220;
                          }
                        }
                        else
                        {
                          memset(__p, 0, sizeof(__p));
                          char v89 = (char *)__p;
                          HIBYTE(__p[2]) = v87 + v85;
                          if (!v85) {
                            goto LABEL_187;
                          }
                        }
                        if (v84 >= 0) {
                          __int16 v90 = &v108;
                        }
                        else {
                          __int16 v90 = v108;
                        }
                        memmove(v89, v90, v85);
                        goto LABEL_187;
                      }
                    }
                    ctu::fs::create_directory();
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      std::string::__init_copy_ctor_external(&v114, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                    }
                    else {
                      std::string v114 = __dst;
                    }
                    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
                      std::string::__init_copy_ctor_external(&v113, v117.__r_.__value_.__l.__data_, v117.__r_.__value_.__l.__size_);
                    }
                    else {
                      std::string v113 = v117;
                    }
                    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v111, ".*-live$", 0);
                    util::moveDirContent((std::string::size_type)&v114, (uint64_t)&v113, 0, 0, (uint64_t)&v111);
                    long long v73 = v112;
                    if (v112 && !atomic_fetch_add(&v112->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
                      std::__shared_weak_count::__release_weak(v73);
                      std::locale::~locale(&v111);
                      if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
LABEL_131:
                        if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                          goto LABEL_132;
                        }
LABEL_235:
                        operator delete(v114.__r_.__value_.__l.__data_);
LABEL_132:
                        memset(&buf, 0, sizeof(buf));
                        char v108 = 0;
                        size_t v109 = 0;
                        uint64_t v110 = 0;
                        abm::resolveProcessingDirAndArchiveFileName(1, (const void **)&object.__r_.__value_.__l.__data_, (long long *)v116, (uint64_t)v120, (uint64_t)&buf, (uint64_t)&v108);
                        if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v107, v117.__r_.__value_.__l.__data_, v117.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v107 = v117;
                        }
                        if (SHIBYTE(object.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v106, object.__r_.__value_.__l.__data_, object.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v106 = object;
                        }
                        unsigned int v74 = v67;
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                          std::string::__init_copy_ctor_external(&v105, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                        }
                        else {
                          std::string v105 = buf;
                        }
                        int v75 = SHIBYTE(v110);
                        if (v110 >= 0) {
                          size_t v76 = HIBYTE(v110);
                        }
                        else {
                          size_t v76 = v109;
                        }
                        int v77 = SHIBYTE(v115.__r_.__value_.__r.__words[2]);
                        if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                          size_t v78 = HIBYTE(v115.__r_.__value_.__r.__words[2]);
                        }
                        else {
                          size_t v78 = v115.__r_.__value_.__l.__size_;
                        }
                        unint64_t v79 = v78 + v76;
                        memset(v104, 170, sizeof(v104));
                        if (v78 + v76 > 0x7FFFFFFFFFFFFFF7) {
                          std::string::__throw_length_error[abi:ne180100]();
                        }
                        if (v79 > 0x16)
                        {
                          uint64_t v96 = (v79 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v79 | 7) != 0x17) {
                            uint64_t v96 = v79 | 7;
                          }
                          uint64_t v97 = v96 + 1;
                          uint64_t v80 = (char *)operator new(v96 + 1);
                          v104[1] = (void *)(v78 + v76);
                          v104[2] = (void *)(v97 | 0x8000000000000000);
                          v104[0] = v80;
                          if (!v76)
                          {
LABEL_154:
                            int v82 = &v80[v76];
                            if (v78)
                            {
                              if (v77 >= 0) {
                                long long v83 = &v115;
                              }
                              else {
                                long long v83 = (std::string *)v115.__r_.__value_.__r.__words[0];
                              }
                              memmove(v82, v83, v78);
                            }
                            v82[v78] = 0;
                            unsigned int v67 = v74;
                            abm::LogCompressionTask::archiveHelper_sync(v99, 1, (uint64_t)&v107, (const void **)&v106.__r_.__value_.__l.__data_, (uint64_t)&v105, (const void **)v104, v74);
                            if (SHIBYTE(v104[2]) < 0)
                            {
                              operator delete(v104[0]);
                              if ((SHIBYTE(v105.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                              {
LABEL_161:
                                if ((SHIBYTE(v106.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                  goto LABEL_162;
                                }
                                goto LABEL_227;
                              }
                            }
                            else if ((SHIBYTE(v105.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
                              goto LABEL_161;
                            }
                            operator delete(v105.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v106.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_162:
                              if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_163;
                              }
                              goto LABEL_228;
                            }
LABEL_227:
                            operator delete(v106.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v107.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                            {
LABEL_163:
                              if ((SHIBYTE(v110) & 0x80000000) == 0) {
                                goto LABEL_164;
                              }
                              goto LABEL_229;
                            }
LABEL_228:
                            operator delete(v107.__r_.__value_.__l.__data_);
                            if ((SHIBYTE(v110) & 0x80000000) == 0)
                            {
LABEL_164:
                              if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                                goto LABEL_165;
                              }
LABEL_230:
                              operator delete(buf.__r_.__value_.__l.__data_);
                              goto LABEL_165;
                            }
LABEL_229:
                            operator delete(v108);
                            if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                              goto LABEL_165;
                            }
                            goto LABEL_230;
                          }
                        }
                        else
                        {
                          memset(v104, 0, sizeof(v104));
                          uint64_t v80 = (char *)v104;
                          HIBYTE(v104[2]) = v78 + v76;
                          if (!v76) {
                            goto LABEL_154;
                          }
                        }
                        if (v75 >= 0) {
                          char v81 = &v108;
                        }
                        else {
                          char v81 = v108;
                        }
                        memmove(v80, v81, v76);
                        goto LABEL_154;
                      }
                    }
                    else
                    {
                      std::locale::~locale(&v111);
                      if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_131;
                      }
                    }
                    operator delete(v113.__r_.__value_.__l.__data_);
                    if ((SHIBYTE(v114.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_132;
                    }
                    goto LABEL_235;
                  }
                  *((unsigned char *)&v117.__r_.__value_.__s + 23) = v65 & 0x7F;
                  v117.__r_.__value_.__s.__data_[v65] = 0;
                }
                else
                {
                  std::string::__erase_external_with_move(&v117, v65, v66);
                  unsigned int v67 = v98;
                }
                if (v41 < 0x11) {
                  goto LABEL_103;
                }
                goto LABEL_101;
              }
              if (!v37)
              {
                unint64_t v44 = v35;
                goto LABEL_92;
              }
            }
LABEL_89:
            if (*(void *)&v121[16] >= 0x11uLL && *(void *)v121)
            {
              operator delete[](*(void **)v121);
              std::string::size_type v36 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
              std::string::size_type size = v117.__r_.__value_.__l.__size_;
              std::string::size_type v33 = v117.__r_.__value_.__r.__words[0];
              char v32 = HIBYTE(v117.__r_.__value_.__r.__words[2]);
            }
            goto LABEL_92;
          }
        }
        else if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_35;
        }
        operator delete(buf.__r_.__value_.__l.__data_);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_36;
        }
        goto LABEL_40;
      }
    }
    memmove(p_dst, v13, v15);
    goto LABEL_27;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFStringRef v121 = 0;
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Skipping archive creation because compression is disabled!", v121, 2u);
  }
  return 0;
}

void sub_1A6172800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,std::locale a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a38 < 0)
  {
    operator delete(__p);
    if ((a45 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a45 & 0x80000000) == 0)
  {
LABEL_6:
    if (a51 < 0) {
      operator delete(a46);
    }
    if (*(char *)(v79 - 121) < 0) {
      operator delete(*(void **)(v79 - 144));
    }
    ctu::os::signpost_interval::~signpost_interval((ctu::os::signpost_interval *)(v79 - 224));
    if (a72 < 0) {
      operator delete(a68);
    }
    if (a74 < 0) {
      operator delete(a73);
    }
    if (a76 < 0) {
      operator delete(a75);
    }
    if (a78 < 0) {
      operator delete(a77);
    }
    if (SLOBYTE(STACK[0x207]) < 0) {
      operator delete(object);
    }
    if (*(char *)(v79 - 225) < 0)
    {
      operator delete(*(void **)(v79 - 248));
      _Unwind_Resume(a1);
    }
    _Unwind_Resume(a1);
  }
  operator delete(a40);
  goto LABEL_6;
}

void abm::resolveProcessingDirAndArchiveFileName(int a1, const void **a2, long long *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v47[2] = *MEMORY[0x1E4F143B8];
  size_t v10 = *((unsigned __int8 *)a3 + 23);
  int v11 = (char)v10;
  if ((v10 & 0x80u) != 0) {
    size_t v10 = *((void *)a3 + 1);
  }
  if (v10)
  {
    if ((long long *)a6 != a3)
    {
      if ((*(char *)(a6 + 23) & 0x80000000) == 0)
      {
        if (v11 < 0)
        {
          std::string::__assign_no_alias<true>((void *)a6, *(void **)a3, *((void *)a3 + 1));
          if (a1 != 1)
          {
LABEL_34:
            int v28 = *((char *)a2 + 23);
            if (v28 >= 0) {
              size_t v29 = *((unsigned __int8 *)a2 + 23);
            }
            else {
              size_t v29 = (size_t)a2[1];
            }
            int v30 = *(char *)(a6 + 23);
            if (v30 >= 0) {
              size_t v31 = *(unsigned __int8 *)(a6 + 23);
            }
            else {
              size_t v31 = *(void *)(a6 + 8);
            }
            unint64_t v32 = v31 + v29;
            memset(&__p, 170, sizeof(__p));
            if (v31 + v29 > 0x7FFFFFFFFFFFFFF7) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            if (v32 > 0x16)
            {
              uint64_t v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v32 | 7) != 0x17) {
                uint64_t v34 = v32 | 7;
              }
              uint64_t v35 = v34 + 1;
              uint64_t p_p = (std::string *)operator new(v34 + 1);
              __p.__r_.__value_.__l.__size_ = v31 + v29;
              __p.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
              if (!v29) {
                goto LABEL_51;
              }
            }
            else
            {
              memset(&__p, 0, sizeof(__p));
              uint64_t p_p = &__p;
              *((unsigned char *)&__p.__r_.__value_.__s + 23) = v31 + v29;
              if (!v29)
              {
LABEL_51:
                if (v31)
                {
                  if (v30 >= 0) {
                    std::string::size_type v37 = (const void *)a6;
                  }
                  else {
                    std::string::size_type v37 = *(const void **)a6;
                  }
                  memmove((char *)p_p + v29, v37, v31);
                }
                p_p->__r_.__value_.__s.__data_[v29 + v31] = 0;
                size_t v38 = std::string::append(&__p, "/", 1uLL);
                std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
                v47[0] = v38->__r_.__value_.__l.__size_;
                *(void *)((char *)v47 + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
                char v40 = HIBYTE(v38->__r_.__value_.__r.__words[2]);
                v38->__r_.__value_.__l.__size_ = 0;
                v38->__r_.__value_.__r.__words[2] = 0;
                v38->__r_.__value_.__r.__words[0] = 0;
                if (*(char *)(a5 + 23) < 0) {
                  operator delete(*(void **)a5);
                }
                uint64_t v41 = v47[0];
                *(void *)a5 = v39;
                *(void *)(a5 + 8) = v41;
                *(void *)(a5 + 15) = *(void *)((char *)v47 + 7);
                *(unsigned char *)(a5 + 23) = v40;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                return;
              }
            }
            if (v28 >= 0) {
              std::string::size_type v36 = a2;
            }
            else {
              std::string::size_type v36 = *a2;
            }
            memmove(p_p, v36, v29);
            goto LABEL_51;
          }
        }
        else
        {
          long long v12 = *a3;
          *(void *)(a6 + 16) = *((void *)a3 + 2);
          *(_OWORD *)a6 = v12;
          if (a1 != 1) {
            goto LABEL_34;
          }
        }
LABEL_33:
        std::string::append((std::string *)a6, "-lite", 5uLL);
        goto LABEL_34;
      }
      if (v11 >= 0) {
        uint64_t v27 = a3;
      }
      else {
        uint64_t v27 = *(long long **)a3;
      }
      std::string::__assign_no_alias<false>((void **)a6, v27, v10);
    }
    if (a1 != 1) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  size_t v14 = abm::trace::kLogDirPrefix[0];
  size_t v15 = strlen(abm::trace::kLogDirPrefix[0]);
  if (v15 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v16 = v15;
  if (v15 >= 0x17)
  {
    uint64_t v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v18 = v15 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v17 = (std::string *)operator new(v18 + 1);
    __p.__r_.__value_.__l.__size_ = v16;
    __p.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    goto LABEL_16;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v15;
  uint64_t v17 = &__p;
  if (v15) {
LABEL_16:
  }
    memmove(v17, v14, v16);
  v17->__r_.__value_.__s.__data_[v16] = 0;
  int v20 = *(char *)(a4 + 23);
  if (v20 >= 0) {
    uint64_t v21 = (const std::string::value_type *)a4;
  }
  else {
    uint64_t v21 = *(const std::string::value_type **)a4;
  }
  if (v20 >= 0) {
    std::string::size_type v22 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    std::string::size_type v22 = *(void *)(a4 + 8);
  }
  uint64_t v23 = std::string::append(&__p, v21, v22);
  std::string::size_type v24 = v23->__r_.__value_.__r.__words[0];
  v47[0] = v23->__r_.__value_.__l.__size_;
  *(void *)((char *)v47 + 7) = *(std::string::size_type *)((char *)&v23->__r_.__value_.__r.__words[1] + 7);
  char v25 = HIBYTE(v23->__r_.__value_.__r.__words[2]);
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a6 + 23) < 0) {
    operator delete(*(void **)a6);
  }
  uint64_t v26 = v47[0];
  *(void *)a6 = v24;
  *(void *)(a6 + 8) = v26;
  *(void *)(a6 + 15) = *(void *)((char *)v47 + 7);
  *(unsigned char *)(a6 + 23) = v25;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (a1 != 1) {
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  if (a1 == 1) {
LABEL_61:
  }
    std::string::append((std::string *)a6, "-lite", 5uLL);
LABEL_62:
  if ((const void **)a5 != a2)
  {
    char v42 = *((unsigned char *)a2 + 23);
    if (*(char *)(a5 + 23) < 0)
    {
      if (v42 >= 0) {
        unint64_t v44 = a2;
      }
      else {
        unint64_t v44 = (void *)*a2;
      }
      if (v42 >= 0) {
        size_t v45 = *((unsigned __int8 *)a2 + 23);
      }
      else {
        size_t v45 = (size_t)a2[1];
      }
      std::string::__assign_no_alias<false>((void **)a5, v44, v45);
    }
    else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)a5, (void *)*a2, (size_t)a2[1]);
    }
    else
    {
      long long v43 = *(_OWORD *)a2;
      *(void *)(a5 + 16) = a2[2];
      *(_OWORD *)a5 = v43;
    }
  }
}

void sub_1A6172FC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::LogCompressionTask::archiveHelper_sync(uint64_t a1, int a2, uint64_t a3, const void **a4, uint64_t a5, const void **a6, unsigned int a7)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  int v7 = *((char *)a4 + 23);
  if (v7 >= 0) {
    size_t v8 = *((unsigned __int8 *)a4 + 23);
  }
  else {
    size_t v8 = (size_t)a4[1];
  }
  int v9 = *((char *)a6 + 23);
  if (v9 >= 0) {
    size_t v10 = *((unsigned __int8 *)a6 + 23);
  }
  else {
    size_t v10 = (size_t)a6[1];
  }
  unint64_t v11 = v10 + v8;
  memset(&__dst, 170, sizeof(__dst));
  if (v10 + v8 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v11 <= 0x16)
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10 + v8;
    if (!v8) {
      goto LABEL_18;
    }
    goto LABEL_14;
  }
  uint64_t v16 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v11 | 7) != 0x17) {
    uint64_t v16 = v11 | 7;
  }
  uint64_t v17 = v16 + 1;
  p_dst = (std::string *)operator new(v16 + 1);
  __dst.__r_.__value_.__l.__size_ = v10 + v8;
  __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  if (v8)
  {
LABEL_14:
    if (v7 >= 0) {
      uint64_t v18 = a4;
    }
    else {
      uint64_t v18 = *a4;
    }
    memmove(p_dst, v18, v8);
  }
LABEL_18:
  uint64_t v19 = (char *)p_dst + v8;
  if (v10)
  {
    if (v9 >= 0) {
      int v20 = a6;
    }
    else {
      int v20 = *a6;
    }
    memmove(v19, v20, v10);
  }
  v19[v10] = 0;
  uint64_t v21 = a1;
  std::string::size_type v22 = *(NSObject **)(a1 + 40);
  uint64_t v23 = a4;
  if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_40;
  }
  if (a2 == 1)
  {
    HIBYTE(v117) = 4;
    strcpy((char *)&v115, "lite");
    std::string::size_type v24 = (const std::string::value_type *)a3;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if (!a2)
  {
    HIBYTE(v117) = 4;
    strcpy((char *)&v115, "main");
    std::string::size_type v24 = (const std::string::value_type *)a3;
    if ((*(char *)(a3 + 23) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  HIBYTE(v117) = 3;
  LODWORD(v115) = 4144959;
  std::string::size_type v24 = (const std::string::value_type *)a3;
  if (*(char *)(a3 + 23) < 0) {
LABEL_29:
  }
    std::string::size_type v24 = *(const std::string::value_type **)a3;
LABEL_30:
  char v25 = a4;
  if ((v7 & 0x80000000) == 0)
  {
    uint64_t v26 = (const std::string::value_type *)a5;
    if ((*(char *)(a5 + 23) & 0x80000000) == 0) {
      goto LABEL_32;
    }
LABEL_64:
    uint64_t v26 = *(const std::string::value_type **)a5;
    uint64_t v27 = a6;
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_33;
    }
LABEL_65:
    uint64_t v27 = (void *)*a6;
    goto LABEL_33;
  }
  char v25 = (void *)*a4;
  uint64_t v26 = (const std::string::value_type *)a5;
  if (*(char *)(a5 + 23) < 0) {
    goto LABEL_64;
  }
LABEL_32:
  uint64_t v27 = a6;
  if (v9 < 0) {
    goto LABEL_65;
  }
LABEL_33:
  int v28 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  std::string::size_type v29 = __dst.__r_.__value_.__r.__words[0];
  abm::helper::asString(a7, &__p);
  int v30 = &__dst;
  if (v28 < 0) {
    int v30 = (std::string *)v29;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  *(_DWORD *)std::string buf = 136316674;
  *(void *)&uint8_t buf[4] = &v115;
  *(_WORD *)&unsigned char buf[12] = 2080;
  *(void *)&unsigned char buf[14] = v24;
  *(_WORD *)&unsigned char buf[22] = 2080;
  size_t v124 = v25;
  __int16 v125 = 2080;
  uint64_t v126 = v26;
  __int16 v127 = 2080;
  int v128 = v27;
  __int16 v129 = 2080;
  long long v130 = v30;
  __int16 v131 = 2080;
  xpc_object_t v132 = p_p;
  _os_log_impl(&dword_1A609F000, v22, OS_LOG_TYPE_DEFAULT, "#I Beginning to create %s archive:\n\tsource directory     = %s\n\tpending directory    = %s\n\tprocessing int directory = %s\n\tarchive file name    = %s\n\tarchive file path    = %s\n\tcompression mode     = %s", buf, 0x48u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    uint64_t v23 = a4;
    uint64_t v21 = a1;
    if ((SHIBYTE(v117) & 0x80000000) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v23 = a4;
    uint64_t v21 = a1;
    if ((SHIBYTE(v117) & 0x80000000) == 0) {
      goto LABEL_40;
    }
  }
  operator delete(v115);
LABEL_40:
  ctu::fs::create_directory();
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v113, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string v113 = *(std::string *)a3;
  }
  if (*(char *)(a5 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v112, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
  }
  else {
    std::string v112 = *(std::string *)a5;
  }
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v110, "[^\\.].*", 0);
  util::moveDirContent((std::string::size_type)&v113, (uint64_t)&v112, 1u, 0, (uint64_t)&v110);
  unint64_t v32 = v111;
  if (!v111 || atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    std::locale::~locale(&v110);
    if ((SHIBYTE(v112.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_49;
    }
LABEL_56:
    operator delete(v112.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v113.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_50;
    }
LABEL_57:
    operator delete(v113.__r_.__value_.__l.__data_);
    goto LABEL_50;
  }
  ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
  std::__shared_weak_count::__release_weak(v32);
  std::locale::~locale(&v110);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_56;
  }
LABEL_49:
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_57;
  }
LABEL_50:
  sync();
  std::string v115 = 0;
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t SystemTime = TelephonyUtilGetSystemTime();
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v108, "^(?!.*(\\.tar\\.gz|\\.$)).*", 0);
  char filtered_files = ctu::fs::get_filtered_files();
  uint64_t v35 = v109;
  if (!v109 || atomic_fetch_add(&v109->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    std::locale::~locale(&v108);
    if (filtered_files) {
      goto LABEL_53;
    }
LABEL_59:
    std::string::size_type v36 = *(NSObject **)(v21 + 40);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
LABEL_75:
      uint64_t v44 = 0;
      goto LABEL_95;
    }
    std::string::size_type v37 = (const std::string::value_type *)v23;
    if (*((char *)v23 + 23) < 0) {
      std::string::size_type v37 = (const std::string::value_type *)*v23;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v37;
    size_t v38 = "Failed to find matching files for archiving in %s";
    std::string::size_type v39 = v36;
    uint32_t v40 = 12;
LABEL_187:
    _os_log_error_impl(&dword_1A609F000, v39, OS_LOG_TYPE_ERROR, v38, buf, v40);
    goto LABEL_75;
  }
  ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
  std::__shared_weak_count::__release_weak(v35);
  std::locale::~locale(&v108);
  if ((filtered_files & 1) == 0) {
    goto LABEL_59;
  }
LABEL_53:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v107, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v107 = __dst;
  }
  uint64_t Archive_sync = abm::LogCompressionTask::createArchive_sync(v21, (uint64_t *)&v107, a7);
  uint64_t v42 = Archive_sync;
  if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v107.__r_.__value_.__l.__data_);
    if (v42) {
      goto LABEL_71;
    }
    goto LABEL_74;
  }
  if (!Archive_sync)
  {
LABEL_74:
    long long v43 = *(NSObject **)(v21 + 40);
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_75;
    }
    *(_WORD *)std::string buf = 0;
    size_t v38 = "Failed to create archive object";
    std::string::size_type v39 = v43;
    uint32_t v40 = 2;
    goto LABEL_187;
  }
LABEL_71:
  if (*((char *)v23 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v106, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
  }
  else {
    std::string v106 = *(std::string *)v23;
  }
  std::string v103 = 0;
  long long v104 = 0;
  uint64_t v105 = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v103, (uint64_t)v115, (uint64_t)v116, 0xAAAAAAAAAAAAAAABLL * (v116 - v115));
  if (*((char *)v23 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v102, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
  }
  else {
    std::string v102 = *(std::string *)v23;
  }
  uint64_t v44 = abm::LogCompressionTask::archiveEntries_sync(v21, v42, (std::string::size_type)&v106, (long long **)&v103, (uint64_t)&v102);
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v102.__r_.__value_.__l.__data_);
  }
  size_t v45 = (void **)v103;
  if (v103)
  {
    int v46 = v104;
    int v47 = v103;
    if (v104 != v103)
    {
      do
      {
        if (*((char *)v46 - 1) < 0) {
          operator delete(*(v46 - 3));
        }
        v46 -= 3;
      }
      while (v46 != v45);
      int v47 = v103;
    }
    long long v104 = v45;
    operator delete(v47);
  }
  if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v106.__r_.__value_.__l.__data_);
  }
  archive_write_free();
LABEL_95:
  uint64_t v48 = TelephonyUtilGetSystemTime();
  unint64_t v49 = *(NSObject **)(v21 + 40);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v50 = "Failed";
    if (v44) {
      unint64_t v50 = "Succeeded";
    }
    xpc_object_t v51 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      xpc_object_t v51 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    long long v52 = v23;
    if (*((char *)v23 + 23) < 0) {
      long long v52 = *v23;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v50;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v51;
    *(_WORD *)&unsigned char buf[22] = 2080;
    size_t v124 = v52;
    __int16 v125 = 2048;
    uint64_t v126 = (const std::string::value_type *)(v48 - SystemTime);
    _os_log_impl(&dword_1A609F000, v49, OS_LOG_TYPE_DEFAULT, "#I %s to create archive %s from contents of pending directory %s (elapsed archiving time = %llu ms)", buf, 0x2Au);
    unint64_t v49 = *(NSObject **)(v21 + 40);
  }
  BOOL v53 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
  if (!v44)
  {
    if (v53)
    {
      unint64_t v59 = v23;
      if (*((char *)v23 + 23) < 0) {
        unint64_t v59 = (void *)*v23;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v59;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(char **)&unsigned char buf[14] = abm::trace::kSnapshotFolder[0];
      _os_log_impl(&dword_1A609F000, v49, OS_LOG_TYPE_DEFAULT, "#I Fall-back move %s -> %s", buf, 0x16u);
    }
    if (*((char *)v23 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v101, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
    }
    else {
      std::string v101 = *(std::string *)v23;
    }
    xpc_object_t v60 = abm::trace::kSnapshotFolder[0];
    size_t v61 = strlen(abm::trace::kSnapshotFolder[0]);
    if (v61 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    int v62 = (void *)v61;
    if (v61 >= 0x17)
    {
      uint64_t v64 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v61 | 7) != 0x17) {
        uint64_t v64 = v61 | 7;
      }
      uint64_t v65 = v64 + 1;
      xpc_object_t v63 = operator new(v64 + 1);
      v99[1] = v62;
      unint64_t v100 = v65 | 0x8000000000000000;
      v99[0] = v63;
    }
    else
    {
      HIBYTE(v100) = v61;
      xpc_object_t v63 = v99;
      if (!v61) {
        goto LABEL_127;
      }
    }
    memmove(v63, v60, (size_t)v62);
LABEL_127:
    *((unsigned char *)v62 + (void)v63) = 0;
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v97, "[^\\.].*", 0);
    util::moveDirContent((std::string::size_type)&v101, (uint64_t)v99, 1u, 0, (uint64_t)&v97);
    std::string::size_type v66 = v98;
    if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
      std::__shared_weak_count::__release_weak(v66);
      std::locale::~locale(&v97);
      if ((SHIBYTE(v100) & 0x80000000) == 0)
      {
LABEL_130:
        if ((SHIBYTE(v101.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_173;
        }
LABEL_172:
        operator delete(v101.__r_.__value_.__l.__data_);
        goto LABEL_173;
      }
    }
    else
    {
      std::locale::~locale(&v97);
      if ((SHIBYTE(v100) & 0x80000000) == 0) {
        goto LABEL_130;
      }
    }
    operator delete(v99[0]);
    if ((SHIBYTE(v101.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_173;
    }
    goto LABEL_172;
  }
  if (!v53) {
    goto LABEL_146;
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    stat v54 = &__dst;
  }
  else {
    stat v54 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  int v55 = abm::trace::kSnapshotFolder[0];
  size_t v56 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v56 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v57 = v56;
  if (v56 >= 0x17)
  {
    uint64_t v67 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v56 | 7) != 0x17) {
      uint64_t v67 = v56 | 7;
    }
    uint64_t v68 = v67 + 1;
    long long v58 = (std::string *)operator new(v67 + 1);
    __p.__r_.__value_.__l.__size_ = v57;
    __p.__r_.__value_.__r.__words[2] = v68 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
    goto LABEL_135;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v56;
  long long v58 = &__p;
  if (v56) {
LABEL_135:
  }
    memmove(v58, v55, v57);
  v58->__r_.__value_.__s.__data_[v57] = 0;
  int v69 = *((char *)a6 + 23);
  if (v69 >= 0) {
    os_signpost_id_t v70 = (const std::string::value_type *)a6;
  }
  else {
    os_signpost_id_t v70 = (const std::string::value_type *)*a6;
  }
  if (v69 >= 0) {
    std::string::size_type v71 = *((unsigned __int8 *)a6 + 23);
  }
  else {
    std::string::size_type v71 = (std::string::size_type)a6[1];
  }
  uint64_t v72 = std::string::append(&__p, v70, v71);
  long long v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
  *(void *)&uint8_t buf[16] = *((void *)&v72->__r_.__value_.__l + 2);
  *(_OWORD *)std::string buf = v73;
  v72->__r_.__value_.__l.__size_ = 0;
  v72->__r_.__value_.__r.__words[2] = 0;
  v72->__r_.__value_.__r.__words[0] = 0;
  unsigned int v74 = buf;
  if (buf[23] < 0) {
    unsigned int v74 = *(unsigned char **)buf;
  }
  *(_DWORD *)uint64_t v119 = 136315394;
  uint64_t v120 = v54;
  __int16 v121 = 2080;
  long long v122 = v74;
  _os_log_impl(&dword_1A609F000, v49, OS_LOG_TYPE_DEFAULT, "#I Moving archive %s -> %s", v119, 0x16u);
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_146;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_146;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_146:
  int v75 = abm::trace::kSnapshotFolder[0];
  size_t v76 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v76 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v77 = v76;
  if (v76 >= 0x17)
  {
    uint64_t v79 = (v76 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v76 | 7) != 0x17) {
      uint64_t v79 = v76 | 7;
    }
    uint64_t v80 = v79 + 1;
    size_t v78 = (std::string *)operator new(v79 + 1);
    __p.__r_.__value_.__l.__size_ = v77;
    __p.__r_.__value_.__r.__words[2] = v80 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
    uint64_t v23 = a4;
    goto LABEL_153;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v76;
  size_t v78 = &__p;
  if (v76) {
LABEL_153:
  }
    memmove(v78, v75, v77);
  v78->__r_.__value_.__s.__data_[v77] = 0;
  int v81 = *((char *)a6 + 23);
  if (v81 >= 0) {
    int v82 = (const std::string::value_type *)a6;
  }
  else {
    int v82 = (const std::string::value_type *)*a6;
  }
  if (v81 >= 0) {
    std::string::size_type v83 = *((unsigned __int8 *)a6 + 23);
  }
  else {
    std::string::size_type v83 = (std::string::size_type)a6[1];
  }
  int v84 = std::string::append(&__p, v82, v83);
  long long v85 = *(_OWORD *)&v84->__r_.__value_.__l.__data_;
  *(void *)&uint8_t buf[16] = *((void *)&v84->__r_.__value_.__l + 2);
  *(_OWORD *)std::string buf = v85;
  v84->__r_.__value_.__l.__size_ = 0;
  v84->__r_.__value_.__r.__words[2] = 0;
  v84->__r_.__value_.__r.__words[0] = 0;
  ctu::fs::rename();
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_162;
    }
  }
  else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_162;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_162:
  int v86 = ctu::fs::remove_dir();
  size_t v87 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v88 = "Failed";
    if (v86) {
      unint64_t v88 = "Succeeded";
    }
    if (*((char *)v23 + 23) < 0) {
      uint64_t v23 = (const void **)*v23;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v88;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v23;
    _os_log_impl(&dword_1A609F000, v87, OS_LOG_TYPE_DEFAULT, "#I %s to remove pending directory %s", buf, 0x16u);
  }
LABEL_173:
  char v89 = v115;
  if (v115)
  {
    __int16 v90 = v116;
    std::string v91 = v115;
    if (v116 != v115)
    {
      do
      {
        if (*((char *)v90 - 1) < 0) {
          operator delete(*(v90 - 3));
        }
        v90 -= 3;
      }
      while (v90 != v89);
      std::string v91 = v115;
    }
    uint64_t v116 = v89;
    operator delete(v91);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v44;
}

void sub_1A6173D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  std::vector<std::string>::~vector[abi:ne180100](&a32);
  if (a40 < 0) {
    operator delete(__p);
  }
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v40 - 256));
  if (*(char *)(v40 - 209) < 0)
  {
    operator delete(*(void **)(v40 - 232));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t abm::LogCompressionTask::createArchive_sync(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = archive_write_new();
  if (!v6) {
    return v6;
  }
  if (a3 != 1)
  {
    archive_write_set_format_ustar();
    if ((*((char *)a2 + 23) & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_7:
    int v7 = archive_write_open_filename();
    if (!v7) {
      return v6;
    }
    goto LABEL_8;
  }
  archive_write_add_filter_gzip();
  archive_write_set_format_ustar();
  if (*((char *)a2 + 23) < 0) {
    goto LABEL_7;
  }
LABEL_4:
  int v7 = archive_write_open_filename();
  if (!v7) {
    return v6;
  }
LABEL_8:
  int v8 = v7;
  int v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    int v11 = 136315394;
    long long v12 = a2;
    __int16 v13 = 1024;
    int v14 = v8;
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Error creating archive at path %s, error code: %d", (uint8_t *)&v11, 0x12u);
  }
  archive_write_free();
  return 0;
}

uint64_t abm::LogCompressionTask::archiveEntries_sync(uint64_t a1, uint64_t a2, std::string::size_type a3, long long **a4, uint64_t a5)
{
  std::string::size_type v6 = a3;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      if (!*(void *)(a3 + 8)) {
        goto LABEL_106;
      }
    }
    else if (!*(unsigned char *)(a3 + 23))
    {
      goto LABEL_106;
    }
    int v8 = *a4;
    size_t v45 = a4[1];
    if (v45 == *a4) {
      goto LABEL_106;
    }
    char v9 = 1;
    uint64_t v10 = a1;
    while (1)
    {
      memset(&v57, 170, sizeof(v57));
      if (*((char *)v8 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v57, *(const std::string::value_type **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v11 = *v8;
        v57.__r_.__value_.__r.__words[2] = *((void *)v8 + 2);
        *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v11;
      }
      int v12 = SHIBYTE(v57.__r_.__value_.__r.__words[2]);
      if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v57.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v57.__r_.__value_.__l.__size_;
      }
      if (size == 2)
      {
        uint64_t v16 = (std::string *)v57.__r_.__value_.__r.__words[0];
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v16 = &v57;
        }
        if (LOWORD(v16->__r_.__value_.__l.__data_) == 11822)
        {
LABEL_20:
          int v15 = 5;
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            goto LABEL_98;
          }
          goto LABEL_99;
        }
      }
      else if (size == 1)
      {
        int v14 = (std::string *)v57.__r_.__value_.__r.__words[0];
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v14 = &v57;
        }
        if (v14->__r_.__value_.__s.__data_[0] == 46) {
          goto LABEL_20;
        }
      }
      memset(&__dst[32], 170, 24);
      int v17 = *(char *)(v6 + 23);
      if (v17 >= 0) {
        size_t v18 = *(unsigned __int8 *)(v6 + 23);
      }
      else {
        size_t v18 = *(void *)(v6 + 8);
      }
      unint64_t v19 = v18 + 1;
      memset(__dst, 170, 24);
      if (v18 + 1 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v19 >= 0x17)
      {
        std::string::size_type v21 = v6;
        uint64_t v22 = a5;
        uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v19 | 7) != 0x17) {
          uint64_t v23 = v19 | 7;
        }
        uint64_t v24 = v23 + 1;
        int v20 = operator new(v23 + 1);
        *(void *)&__dst[8] = v18 + 1;
        *(void *)&uint8_t __dst[16] = v24 | 0x8000000000000000;
        *(void *)std::string __dst = v20;
        a5 = v22;
        std::string::size_type v6 = v21;
        uint64_t v10 = a1;
      }
      else
      {
        memset(__dst, 0, 24);
        int v20 = __dst;
        __dst[23] = v18 + 1;
        if (!v18) {
          goto LABEL_39;
        }
      }
      if (v17 >= 0) {
        char v25 = (const void *)v6;
      }
      else {
        char v25 = *(const void **)v6;
      }
      memmove(v20, v25, v18);
LABEL_39:
      *(_WORD *)&v20[v18] = 47;
      if (v12 >= 0) {
        uint64_t v26 = &v57;
      }
      else {
        uint64_t v26 = (std::string *)v57.__r_.__value_.__r.__words[0];
      }
      uint64_t v27 = std::string::append((std::string *)__dst, (const std::string::value_type *)v26, size);
      long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      *(void *)&__dst[48] = *((void *)&v27->__r_.__value_.__l + 2);
      *(_OWORD *)&unsigned char __dst[32] = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      if ((__dst[23] & 0x80000000) != 0) {
        operator delete(*(void **)__dst);
      }
      if (!ctu::fs::is_directory())
      {
        if (!ctu::fs::file_exists()) {
          goto LABEL_70;
        }
        if ((__dst[55] & 0x80000000) != 0) {
          std::string::__init_copy_ctor_external(&v47, *(const std::string::value_type **)&__dst[32], *(std::string::size_type *)&__dst[40]);
        }
        else {
          std::string v47 = *(std::string *)&__dst[32];
        }
        if (*(char *)(a5 + 23) < 0) {
          std::string::__init_copy_ctor_external(&v46, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
        }
        else {
          std::string v46 = *(std::string *)a5;
        }
        char v33 = abm::LogCompressionTask::archiveEntry_sync(v10, a2, (__darwin_ino64_t)&v47, (const void **)&v46.__r_.__value_.__l.__data_);
        if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v46.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_63;
          }
        }
        else if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_63:
          if ((v33 & 1) == 0) {
            goto LABEL_70;
          }
LABEL_64:
          char v9 = 1;
LABEL_95:
          int v15 = 0;
          goto LABEL_96;
        }
        operator delete(v47.__r_.__value_.__l.__data_);
        if ((v33 & 1) == 0)
        {
LABEL_70:
          uint64_t v34 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string __dst = 0;
            _os_log_error_impl(&dword_1A609F000, v34, OS_LOG_TYPE_ERROR, "Failed to add archive.", __dst, 2u);
          }
          char v9 = 0;
          int v15 = 4;
          goto LABEL_96;
        }
        goto LABEL_64;
      }
      memset(__dst, 0, 24);
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v54, ".*", 0);
      char filtered_files = ctu::fs::get_filtered_files();
      int v30 = v55;
      if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
        std::locale::~locale(&v54);
        if ((filtered_files & 1) == 0)
        {
LABEL_54:
          size_t v31 = *(NSObject **)(v10 + 40);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl(&dword_1A609F000, v31, OS_LOG_TYPE_ERROR, "Failed to get files for archiving.", buf, 2u);
            char v9 = 0;
            int v15 = 4;
            unint64_t v32 = *(void ***)__dst;
            if (!*(void *)__dst) {
              goto LABEL_94;
            }
          }
          else
          {
            char v9 = 0;
            int v15 = 4;
            unint64_t v32 = *(void ***)__dst;
            if (!*(void *)__dst) {
              goto LABEL_94;
            }
          }
LABEL_87:
          size_t v38 = *(void ***)&__dst[8];
          std::string::size_type v39 = v32;
          if (*(void ***)&__dst[8] != v32)
          {
            do
            {
              if (*((char *)v38 - 1) < 0) {
                operator delete(*(v38 - 3));
              }
              v38 -= 3;
            }
            while (v38 != v32);
            std::string::size_type v39 = *(void ***)__dst;
          }
          *(void *)&__dst[8] = v32;
          operator delete(v39);
          goto LABEL_94;
        }
      }
      else
      {
        std::locale::~locale(&v54);
        if ((filtered_files & 1) == 0) {
          goto LABEL_54;
        }
      }
      if ((__dst[55] & 0x80000000) != 0) {
        std::string::__init_copy_ctor_external(&v52, *(const std::string::value_type **)&__dst[32], *(std::string::size_type *)&__dst[40]);
      }
      else {
        std::string v52 = *(std::string *)&__dst[32];
      }
      std::string __p = 0;
      unint64_t v50 = 0;
      uint64_t v51 = 0;
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&__p, *(uint64_t *)__dst, *(uint64_t *)&__dst[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__dst[8] - *(void *)__dst) >> 3));
      if (*(char *)(a5 + 23) < 0) {
        std::string::__init_copy_ctor_external(&v48, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
      }
      else {
        std::string v48 = *(std::string *)a5;
      }
      char v9 = abm::LogCompressionTask::archiveEntries_sync(v10, a2, &v52, &__p, &v48);
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v48.__r_.__value_.__l.__data_);
      }
      uint64_t v35 = (void **)__p;
      if (__p)
      {
        std::string::size_type v36 = v50;
        std::string::size_type v37 = __p;
        if (v50 != __p)
        {
          do
          {
            if (*((char *)v36 - 1) < 0) {
              operator delete(*(v36 - 3));
            }
            v36 -= 3;
          }
          while (v36 != v35);
          std::string::size_type v37 = __p;
        }
        unint64_t v50 = v35;
        operator delete(v37);
      }
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v52.__r_.__value_.__l.__data_);
      }
      int v15 = 0;
      unint64_t v32 = *(void ***)__dst;
      if (*(void *)__dst) {
        goto LABEL_87;
      }
LABEL_94:
      if (filtered_files) {
        goto LABEL_95;
      }
LABEL_96:
      if ((__dst[55] & 0x80000000) != 0)
      {
        operator delete(*(void **)&__dst[32]);
        if ((*((unsigned char *)&v57.__r_.__value_.__s + 23) & 0x80) == 0) {
          goto LABEL_99;
        }
LABEL_98:
        operator delete(v57.__r_.__value_.__l.__data_);
        goto LABEL_99;
      }
      if ((*((unsigned char *)&v57.__r_.__value_.__s + 23) & 0x80) != 0) {
        goto LABEL_98;
      }
LABEL_99:
      if (v15 == 5 || !v15)
      {
        int v8 = (long long *)((char *)v8 + 24);
        if (v8 != v45) {
          continue;
        }
      }
      return v9 & 1;
    }
  }
LABEL_106:
  uint64_t v40 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(v6 + 23) < 0) {
      std::string::size_type v6 = *(void *)v6;
    }
    unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3);
    LODWORD(v57.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)v57.__r_.__value_.__r.__words + 4) = a2;
    WORD2(v57.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v57.__r_.__value_.__r.__words[1] + 6) = v6;
    HIWORD(v57.__r_.__value_.__r.__words[2]) = 2048;
    unint64_t v58 = v42;
    _os_log_error_impl(&dword_1A609F000, v40, OS_LOG_TYPE_ERROR, "Error on the given parameter. arch: %p, baseDir: %s, fileLists.size(): %lu", (uint8_t *)&v57, 0x20u);
    char v9 = 0;
  }
  else
  {
    char v9 = 0;
  }
  return v9 & 1;
}

void sub_1A617475C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,std::locale a45)
{
  std::vector<std::string>::~vector[abi:ne180100](&a33);
  if (a41 < 0) {
    operator delete(__p);
  }
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v45 - 208));
  if (*(char *)(v45 - 153) < 0) {
    operator delete(*(void **)(v45 - 176));
  }
  if (*(char *)(v45 - 121) < 0) {
    operator delete(*(void **)(v45 - 144));
  }
  _Unwind_Resume(a1);
}

BOOL abm::LogCompressionTask::closeArchive_sync(uint64_t a1, uint64_t a2)
{
  return a2 && archive_write_free() == 0;
}

uint64_t abm::LogCompressionTask::archiveEntry_sync(uint64_t a1, uint64_t a2, __darwin_ino64_t a3, const void **a4)
{
  __darwin_ino64_t v4 = a3;
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_16;
  }
  if (*(char *)(a3 + 23) < 0)
  {
    if (*(void *)(a3 + 8)) {
      goto LABEL_4;
    }
LABEL_16:
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(v4 + 23) < 0) {
        __darwin_ino64_t v4 = *(void *)v4;
      }
      v52.st_dev = 134218242;
      *(void *)&v52.st_mode = a2;
      WORD2(v52.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&v52.st_ino + 6) = v4;
      _os_log_error_impl(&dword_1A609F000, v16, OS_LOG_TYPE_ERROR, "Error on the given parameter. arch: %p, filePath: %s", (uint8_t *)&v52, 0x16u);
    }
    return 0;
  }
  if (!*(unsigned char *)(a3 + 23)) {
    goto LABEL_16;
  }
LABEL_4:
  v8.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v8.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v52.st_blkstd::string::size_type size = v8;
  *(timespec *)v52.st_qspare = v8;
  v52.st_birthtimespec = v8;
  *(timespec *)&v52.st_std::string::size_type size = v8;
  v52.st_mtimespec = v8;
  v52.st_ctimespec = v8;
  *(timespec *)&v52.st_uid = v8;
  v52.st_atimespec = v8;
  *(timespec *)&v52.st_dev = v8;
  uint64_t v9 = archive_entry_new();
  if (v9)
  {
    uint64_t v47 = v9;
    uint64_t v10 = (const char *)v4;
    if (*(char *)(v4 + 23) < 0) {
      uint64_t v10 = *(const char **)v4;
    }
    lstat(v10, &v52);
    if ((v52.st_mode & 0xF000) != 0x8000)
    {
      BOOL v17 = 1;
LABEL_64:
      archive_entry_free();
      return v17;
    }
    archive_entry_copy_stat();
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v50.__loop_count_ = v11;
    *(_OWORD *)&v50.__start_.__cntrl_ = v11;
    *(_OWORD *)&v50.__traits_.__loc_.__locale_ = v11;
    *(_OWORD *)&v50.__traits_.__col_ = v11;
    int v12 = *((char *)a4 + 23);
    if (v12 >= 0) {
      size_t v13 = *((unsigned __int8 *)a4 + 23);
    }
    else {
      size_t v13 = (size_t)a4[1];
    }
    unint64_t v14 = v13 + 1;
    memset(&v48, 170, sizeof(v48));
    if (v13 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v14 >= 0x17)
    {
      uint64_t v19 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v14 | 7) != 0x17) {
        uint64_t v19 = v14 | 7;
      }
      uint64_t v20 = v19 + 1;
      std::string::size_type v21 = operator new(v19 + 1);
      v48.__r_.__value_.__l.__size_ = v13 + 1;
      v48.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
      v48.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
      unsigned char *v21 = 40;
      int v15 = v21 + 1;
    }
    else
    {
      v48.__r_.__value_.__r.__words[2] = 0;
      *((unsigned char *)&v48.__r_.__value_.__s + 23) = v13 + 1;
      int v15 = &v48.__r_.__value_.__s.__data_[1];
      *(_OWORD *)&v48.__r_.__value_.__l.__data_ = 0x28uLL;
      if (!v13) {
        goto LABEL_29;
      }
    }
    if (v12 >= 0) {
      uint64_t v22 = a4;
    }
    else {
      uint64_t v22 = *a4;
    }
    memmove(v15, v22, v13);
LABEL_29:
    v15[v13] = 0;
    uint64_t v23 = std::string::append(&v48, ")", 1uLL);
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    char v25 = std::string::append(&v49, "([/]*)(.*)", 0xAuLL);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = *((void *)&v25->__r_.__value_.__l + 2);
    *(_OWORD *)std::string __p = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]<std::char_traits<char>,std::allocator<char>>((uint64_t)&v50, (uint64_t)__p, 0);
    if ((__p[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__p);
      if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_31:
        if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_32;
        }
LABEL_44:
        operator delete(v48.__r_.__value_.__l.__data_);
LABEL_32:
        memset(&v49, 0, sizeof(v49));
        uint64_t v27 = *(unsigned __int8 *)(v4 + 23);
        if ((v27 & 0x80u) == 0) {
          v28.__i_ = (std::__wrap_iter<const char *>::iterator_type)v4;
        }
        else {
          v28.__i_ = *(std::__wrap_iter<const char *>::iterator_type *)v4;
        }
        if ((v27 & 0x80u) != 0) {
          uint64_t v27 = *(void *)(v4 + 8);
        }
        v29.__i_ = &v28.__i_[v27];
        std::regex_replace[abi:ne180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(&v49, v28, v29, &v50, "$3", 0);
        int v30 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v45 = &v49;
          if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v45 = (std::string *)v49.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string __p = 136315138;
          *(void *)&__p[4] = v45;
          _os_log_debug_impl(&dword_1A609F000, v30, OS_LOG_TYPE_DEBUG, "#D archivePathName: %s", __p, 0xCu);
        }
        archive_entry_set_pathname();
        if (archive_write_header())
        {
          int v31 = archive_errno();
          unint64_t v32 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            goto LABEL_40;
          }
          if (*(char *)(v4 + 23) < 0) {
            __darwin_ino64_t v4 = *(void *)v4;
          }
          std::string v46 = strerror(v31);
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = v4;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v31;
          *(_WORD *)&__p[18] = 2080;
          *(void *)&char __p[20] = v46;
          unint64_t v42 = "Failed to write header for file for file: %s error: %d(%s)";
        }
        else
        {
          char v33 = (const char *)v4;
          if (*(char *)(v4 + 23) < 0) {
            char v33 = *(const char **)v4;
          }
          int v34 = open(v33, 0, v47);
          int v35 = v34;
          if (v34 != -1)
          {
            ssize_t v36 = read(v34, *(void **)(a1 + 136), 0x300000uLL);
            if (v36 < 1)
            {
              BOOL v17 = 1;
            }
            else
            {
              do
              {
                ssize_t v37 = v36;
                uint64_t v38 = archive_write_data();
                ssize_t v36 = read(v35, *(void **)(a1 + 136), 0x300000uLL);
              }
              while (v36 > 0);
              BOOL v17 = v38 == v37;
            }
            close(v35);
            if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_60;
            }
            goto LABEL_41;
          }
          unint64_t v32 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
LABEL_40:
            BOOL v17 = 1;
            if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_60;
            }
            goto LABEL_41;
          }
          if (*(char *)(v4 + 23) < 0) {
            __darwin_ino64_t v4 = *(void *)v4;
          }
          int v39 = *__error();
          uint64_t v40 = __error();
          uint64_t v41 = strerror(*v40);
          *(_DWORD *)std::string __p = 136315650;
          *(void *)&__p[4] = v4;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v39;
          *(_WORD *)&__p[18] = 2080;
          *(void *)&char __p[20] = v41;
          unint64_t v42 = "Failed to open file: %s  error: %d(%s)";
        }
        _os_log_error_impl(&dword_1A609F000, v32, OS_LOG_TYPE_ERROR, v42, __p, 0x1Cu);
        BOOL v17 = 1;
        if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_60:
          cntrl = v50.__start_.__cntrl_;
          if (v50.__start_.__cntrl_
            && !atomic_fetch_add(&v50.__start_.__cntrl_->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))cntrl->__on_zero_shared)(cntrl);
            std::__shared_weak_count::__release_weak(cntrl);
          }
          std::locale::~locale(&v50.__traits_.__loc_);
          goto LABEL_64;
        }
LABEL_41:
        operator delete(v49.__r_.__value_.__l.__data_);
        goto LABEL_60;
      }
    }
    else if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_31;
    }
    operator delete(v49.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_44;
  }
  size_t v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v50.__traits_.__loc_.__locale_) = 0;
    _os_log_error_impl(&dword_1A609F000, v18, OS_LOG_TYPE_ERROR, "Failed to get archive_entry_new()", (uint8_t *)&v50, 2u);
  }
  return 1;
}

void sub_1A6174E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::locale a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&a23);
  _Unwind_Resume(a1);
}

void dispatch::async<abm::LogCompressionTask::init_sync(void)::$_0>(dispatch_queue_s *,std::unique_ptr<abm::LogCompressionTask::init_sync(void)::$_0,std::default_delete<abm::LogCompressionTask::init_sync(void)::$_0>>)::{lambda(void *)#1}::__invoke(abm::LogCompressionTask **a1)
{
  abm::LogCompressionTask::initWorkspace_sync(*a1);

  operator delete(a1);
}

void sub_1A6174F8C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  int v2 = *(void **)(a1 + 40);
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *))(v3 + 16))(v3, v1, &object);
  xpc_release(object);
}

void sub_1A6175008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void _ZZN8dispatch5asyncIZZN3abm18LogCompressionTask9init_syncEvEUb_E3__1EEvP16dispatch_queue_sNSt3__110unique_ptrIT_NS6_14default_deleteIS8_EEEEENUlPvE_8__invokeESC_(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[1];
  if (!v2) {
    goto LABEL_27;
  }
  uint64_t v3 = a1[5];
  __darwin_ino64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    goto LABEL_27;
  }
  size_t v5 = v4;
  if (*a1)
  {
    *(void *)(v3 + 136) = operator new[](0x300000uLL);
    xpc_object_t v6 = (xpc_object_t)a1[6];
    xpc_object_t v16 = v6;
    if (v6)
    {
      xpc_retain(v6);
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v16 = v6;
    }
    int v7 = abm::LogCompressionTask::archive_sync(v3, &v16);
    xpc_release(v6);
    xpc_object_t v16 = 0;
    timespec v8 = *(void **)(v3 + 136);
    if (v8) {
      operator delete[](v8);
    }
    *(void *)(v3 + 136) = 0;
    if (v7) {
      int v9 = 0;
    }
    else {
      int v9 = -534716416;
    }
    xpc_object_t v10 = xpc_null_create();
    long long v11 = (const void *)a1[7];
    if (v11) {
      int v12 = _Block_copy(v11);
    }
    else {
      int v12 = 0;
    }
    size_t v13 = a1[8];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 1174405120;
    block[2] = ___ZNK8dispatch8callbackIU13block_pointerFviN3xpc4dictEEEclIJN12TelephonyXPC3__2ES2_EEEvDpT__block_invoke_0;
    block[3] = &__block_descriptor_tmp_34;
    if (v12)
    {
      unint64_t v14 = _Block_copy(v12);
      int v20 = v9;
      aBlocuint64_t k = v14;
      xpc_object_t object = v10;
      if (v10)
      {
LABEL_17:
        xpc_retain(v10);
LABEL_20:
        dispatch_async(v13, block);
        xpc_release(object);
        xpc_object_t object = 0;
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v12) {
          _Block_release(v12);
        }
        xpc_release(v10);
        goto LABEL_25;
      }
    }
    else
    {
      int v20 = v9;
      aBlocuint64_t k = 0;
      xpc_object_t object = v10;
      if (v10) {
        goto LABEL_17;
      }
    }
    xpc_object_t object = xpc_null_create();
    goto LABEL_20;
  }
LABEL_25:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_27:
  int v15 = (void *)_ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev((uint64_t)a1);
  operator delete(v15);
}

void sub_1A6175234(_Unwind_Exception *a1)
{
  xpc_release(v3);
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  size_t v5 = (void *)_ZZZN3abm18LogCompressionTask9init_syncEvEUb_EN3__1D1Ev(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void *std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EFB0CED8;
  return result;
}

void std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EFB0CED8;
}

void std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::operator()(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    __darwin_ino64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)size_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A609F000, v4, OS_SIGNPOST_INTERVAL_END, v3, "ArchivingLogs", (const char *)&unk_1A6202E22, v5, 2u);
    }
  }
}

uint64_t std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3abm18LogCompressionTask12archive_syncEN3xpc4dictEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0,std::allocator<abm::LogCompressionTask::archive_sync(xpc::dict)::$_0>,void ()(os_log_s *,unsigned long long)>::target_type()
{
}

uint64_t __cxx_global_var_init_22_0()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::XpcJetsamAssertion,ctu::XpcJetsamAssertion,ctu::PthreadMutexGuardPolicy<ctu::XpcJetsamAssertion>>::sInstance, &dword_1A609F000);
  }
  return result;
}

double ICECoredumpTrace::createInternal@<D0>(_OWORD *a1@<X8>)
{
  unint64_t v3 = (CoredumpTrace *)operator new(0xF0uLL);
  *(_OWORD *)unint64_t v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  CoredumpTrace::CoredumpTrace(v3);
  *(void *)unint64_t v3 = &unk_1EFB0CF58;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<ICECoredumpTrace>::shared_ptr[abi:ne180100]<ICECoredumpTrace,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  double result = *(double *)&v5;
  *a1 = v5;
  return result;
}

void sub_1A61754DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A61754F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ICECoredumpTrace::parseCrashReason_sync(ICECoredumpTrace *this@<X0>, xpc_object_t *a2@<X8>)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  xpc_object_t object = xpc_null_create();
  *a2 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  *a2 = xpc_null_create();
  __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  __p.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)&__p, "unknown");
  std::string v113 = 0;
  __darwin_ino64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    long long v5 = (void *)((char *)this + 200);
    if (*((char *)this + 223) < 0) {
      long long v5 = (void *)*v5;
    }
    buf.st_dev = 136315138;
    *(void *)&buf.st_mode = v5;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Looking for crash report file: %s", (uint8_t *)&buf, 0xCu);
  }
  int v7 = (void *)((char *)this + 200);
  xpc_object_t v6 = (const char *)*((void *)this + 25);
  v8.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v8.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blkstd::string::size_type size = v8;
  *(timespec *)buf.st_qspare = v8;
  buf.st_birthtimespec = v8;
  *(timespec *)&buf.st_std::string::size_type size = v8;
  buf.st_mtimespec = v8;
  buf.st_ctimespec = v8;
  *(timespec *)&buf.st_uid = v8;
  buf.st_atimespec = v8;
  *(timespec *)&buf.st_dev = v8;
  if (*((char *)this + 223) >= 0) {
    int v9 = (char *)this + 200;
  }
  else {
    int v9 = v6;
  }
  if (!stat(v9, &buf))
  {
    if (*((char *)this + 223) < 0) {
      int v7 = (void *)*v7;
    }
    size_t v13 = objc_msgSend(MEMORY[0x1E4F1CA10], "inputStreamWithFileAtPath:", objc_msgSend(NSString, "stringWithUTF8String:", v7));
    unint64_t v14 = v13;
    if (v13)
    {
      [v13 open];
      int v15 = (ctu *)[MEMORY[0x1E4F28D90] JSONObjectWithStream:v14 options:0 error:&v113];
      if (v15)
      {
        ctu::cf_to_xpc((uint64_t *)&buf.st_dev, v15, v16);
        xpc_object_t v17 = *(xpc_object_t *)&buf.st_dev;
        if (*(void *)&buf.st_dev && MEMORY[0x1A6275E60](*(void *)&buf.st_dev) == MEMORY[0x1E4F14590]) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t v17 = xpc_null_create();
        }
        xpc_object_t v32 = xpc_null_create();
        xpc_object_t v33 = object;
        xpc_object_t object = v17;
        xpc_release(v33);
        xpc_release(v32);
        xpc_release(*(xpc_object_t *)&buf.st_dev);
        uint64_t v34 = MEMORY[0x1A6275E60](object);
        uint64_t v35 = MEMORY[0x1E4F14590];
        if (v34 != MEMORY[0x1E4F14590]) {
          goto LABEL_44;
        }
        uint64_t v41 = *((void *)this + 5);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          xpc::object::to_string((uint64_t *)&buf.st_dev, (xpc::object *)&object);
          uint64_t v95 = (buf.st_gid & 0x80000000) == 0 ? &buf : *(stat **)&buf.st_dev;
          LODWORD(v126.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v126.__r_.__value_.__r.__words + 4) = (std::string::size_type)v95;
          _os_log_debug_impl(&dword_1A609F000, v41, OS_LOG_TYPE_DEBUG, "#D %s", (uint8_t *)&v126, 0xCu);
          if (SHIBYTE(buf.st_gid) < 0) {
            operator delete(*(void **)&buf.st_dev);
          }
        }
        xpc_object_t value = xpc_dictionary_get_value(object, "crash");
        xpc_object_t xdict = value;
        if (value) {
          xpc_retain(value);
        }
        else {
          xpc_object_t xdict = xpc_null_create();
        }
        memset(&buf, 0, 24);
        xpc::dyn_cast_or_default();
        if (SHIBYTE(buf.st_gid) < 0) {
          operator delete(*(void **)&buf.st_dev);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        std::string __p = v126;
        *((unsigned char *)&v126.__r_.__value_.__s + 23) = 0;
        v126.__r_.__value_.__s.__data_[0] = 0;
        xpc_release(xdict);
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        int v48 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        if (size == 23)
        {
          uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t p_p = &__p;
          }
          std::string::size_type v63 = p_p->__r_.__value_.__r.__words[0];
          std::string::size_type v64 = p_p->__r_.__value_.__l.__size_;
          uint64_t v65 = *(std::string::size_type *)((char *)&p_p->__r_.__value_.__r.__words[1] + 7);
          if (v63 != 0x695F6D6574737973 || v64 != 0x635F64696C61766ELL || v65 != 0x656C626174646463) {
            goto LABEL_84;
          }
        }
        else
        {
          if (size != 18) {
            goto LABEL_84;
          }
          std::string v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string v49 = &__p;
          }
          std::string::size_type v50 = v49->__r_.__value_.__r.__words[0];
          std::string::size_type v51 = v49->__r_.__value_.__l.__size_;
          int v52 = LOWORD(v49->__r_.__value_.__r.__words[2]);
          BOOL v53 = v50 == 0x6E5F6D6574737973 && v51 == 0x6261746464635F6FLL;
          if (!v53 || v52 != 25964)
          {
LABEL_84:
            int v55 = *((void *)this + 5);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              size_t v56 = (std::string *)__p.__r_.__value_.__r.__words[0];
              if (v48 >= 0) {
                size_t v56 = &__p;
              }
              buf.st_dev = 136315138;
              *(void *)&buf.st_mode = v56;
              _os_log_impl(&dword_1A609F000, v55, OS_LOG_TYPE_DEFAULT, "#I Found crash type '%s'", (uint8_t *)&buf, 0xCu);
            }
            *(void *)&buf.st_dev = &object;
            buf.__darwin_ino64_t st_ino = (__darwin_ino64_t)"system_details";
            xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &v126);
            std::string::size_type v57 = v126.__r_.__value_.__r.__words[0];
            v126.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
            xpc_object_t v58 = *a2;
            *a2 = (xpc_object_t)v57;
            xpc_release(v58);
            xpc_release(v126.__r_.__value_.__l.__data_);
            if (MEMORY[0x1A6275E60](*a2) != v35)
            {
              uint64_t v59 = *((void *)this + 5);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.st_dev) = 0;
                _os_log_impl(&dword_1A609F000, v59, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to unrecognized or missing system_details", (uint8_t *)&buf, 2u);
              }
              xpc_object_t v60 = xpc_dictionary_create(0, 0, 0);
              if (v60 || (xpc_object_t v60 = xpc_null_create()) != 0)
              {
                if (MEMORY[0x1A6275E60](v60) == v35)
                {
                  xpc_retain(v60);
                  xpc_object_t v61 = v60;
                }
                else
                {
                  xpc_object_t v61 = xpc_null_create();
                }
              }
              else
              {
                xpc_object_t v61 = xpc_null_create();
                xpc_object_t v60 = 0;
              }
              xpc_release(v60);
              xpc_object_t v91 = xpc_null_create();
              xpc_object_t v92 = *a2;
              *a2 = v61;
              xpc_release(v92);
              xpc_release(v91);
              v126.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x40uLL);
              *(_OWORD *)&v126.__r_.__value_.__r.__words[1] = xmmword_1A61F7FD0;
              strcpy(v126.__r_.__value_.__l.__data_, "Coredump invalid, unrecognized or missing system_details: ");
              unsigned int v93 = std::string::append(&v126, "report.json", 0xBuLL);
              long long v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
              *(void *)&buf.st_uid = *((void *)&v93->__r_.__value_.__l + 2);
              *(_OWORD *)&buf.st_dev = v94;
              v93->__r_.__value_.__l.__size_ = 0;
              v93->__r_.__value_.__r.__words[2] = 0;
              v93->__r_.__value_.__r.__words[0] = 0;
              CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
              if (SHIBYTE(buf.st_gid) < 0) {
                operator delete(*(void **)&buf.st_dev);
              }
              if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v126.__r_.__value_.__l.__data_);
              }
              [v14 close];
              goto LABEL_60;
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v69 = &__p;
            }
            else {
              int v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v70 = xpc_string_create((const char *)v69);
            if (!v70) {
              xpc_object_t v70 = xpc_null_create();
            }
            xpc_dictionary_set_value(*a2, "crash", v70);
            xpc_object_t v71 = xpc_null_create();
            xpc_release(v70);
            xpc_release(v71);
            if (!xpc_dictionary_get_value(*a2, "log_data")) {
              goto LABEL_119;
            }
            xpc::dict::object_proxy::operator xpc::object(&v126, *a2, "log_data");
            xpc::dyn_cast_or_default();
            if ((buf.st_gid & 0x80000000) == 0) {
              __darwin_ino64_t st_gid_high = HIBYTE(buf.st_gid);
            }
            else {
              __darwin_ino64_t st_gid_high = buf.st_ino;
            }
            if (SHIBYTE(buf.st_gid) < 0) {
              operator delete(*(void **)&buf.st_dev);
            }
            xpc_release(v126.__r_.__value_.__l.__data_);
            if (!st_gid_high)
            {
LABEL_119:
              unint64_t v125 = 0xAAAAAAAAAAAAAAAALL;
              v73.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
              v73.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
              timespec v123 = v73;
              timespec v124 = v73;
              timespec v121 = v73;
              timespec v122 = v73;
              timespec v119 = v73;
              timespec v120 = v73;
              timespec v117 = v73;
              timespec v118 = v73;
              *(timespec *)&buf.st_blkstd::string::size_type size = v73;
              *(timespec *)buf.st_qspare = v73;
              buf.st_birthtimespec = v73;
              *(timespec *)&buf.st_std::string::size_type size = v73;
              buf.st_mtimespec = v73;
              buf.st_ctimespec = v73;
              *(timespec *)&buf.st_uid = v73;
              buf.st_atimespec = v73;
              *(timespec *)&buf.st_dev = v73;
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&buf);
              if (xpc_dictionary_get_value(*a2, "ucs_context_id"))
              {
                xpc::dict::object_proxy::operator xpc::object(&xdict, *a2, "ucs_context_id");
                xpc::dyn_cast_or_default();
                if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v74 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v74 = v126.__r_.__value_.__l.__size_;
                }
                if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v126.__r_.__value_.__l.__data_);
                }
                xpc_release(xdict);
                if (v74)
                {
                  std::string::basic_string[abi:ne180100]<0>(&v126, "c:");
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v75 = &v126;
                  }
                  else {
                    int v75 = (std::string *)v126.__r_.__value_.__r.__words[0];
                  }
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v76 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v76 = v126.__r_.__value_.__l.__size_;
                  }
                  std::string::size_type v77 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v75, v76);
                  xpc::dict::object_proxy::operator xpc::object(&v112, *a2, "ucs_context_id");
                  xpc::dyn_cast_or_default();
                  if ((v111 & 0x80u) == 0) {
                    p_xpc_object_t xdict = &xdict;
                  }
                  else {
                    p_xpc_object_t xdict = xdict;
                  }
                  if ((v111 & 0x80u) == 0) {
                    uint64_t v79 = v111;
                  }
                  else {
                    uint64_t v79 = v110;
                  }
                  uint64_t v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)p_xdict, v79);
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v80, (uint64_t)" ", 1);
                  if ((char)v111 < 0) {
                    operator delete(xdict);
                  }
                  xpc_release(v112);
                  if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v126.__r_.__value_.__l.__data_);
                  }
                }
              }
              if (xpc_dictionary_get_value(*a2, "ucs_static_id"))
              {
                xpc::dict::object_proxy::operator xpc::object(&xdict, *a2, "ucs_static_id");
                xpc::dyn_cast_or_default();
                if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v81 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v81 = v126.__r_.__value_.__l.__size_;
                }
                if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v126.__r_.__value_.__l.__data_);
                }
                xpc_release(xdict);
                if (v81)
                {
                  std::string::basic_string[abi:ne180100]<0>(&v126, "s:");
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v82 = &v126;
                  }
                  else {
                    int v82 = (std::string *)v126.__r_.__value_.__r.__words[0];
                  }
                  if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v83 = HIBYTE(v126.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v83 = v126.__r_.__value_.__l.__size_;
                  }
                  int v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf.st_uid, (uint64_t)v82, v83);
                  xpc::dict::object_proxy::operator xpc::object(&v112, *a2, "ucs_static_id");
                  xpc::dyn_cast_or_default();
                  if ((v111 & 0x80u) == 0) {
                    long long v85 = &xdict;
                  }
                  else {
                    long long v85 = xdict;
                  }
                  if ((v111 & 0x80u) == 0) {
                    uint64_t v86 = v111;
                  }
                  else {
                    uint64_t v86 = v110;
                  }
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v84, (uint64_t)v85, v86);
                  if ((char)v111 < 0) {
                    operator delete(xdict);
                  }
                  xpc_release(v112);
                  if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v126.__r_.__value_.__l.__data_);
                  }
                }
              }
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str[abi:ne180100](&buf, &v126);
              if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                size_t v87 = &v126;
              }
              else {
                size_t v87 = (std::string *)v126.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v107 = xpc_string_create((const char *)v87);
              if (!v107) {
                xpc_object_t v107 = xpc_null_create();
              }
              xpc::dict::object_proxy::operator=(&v108, *a2, "log_data", &v107);
              xpc_release(v108);
              xpc_object_t v108 = 0;
              xpc_release(v107);
              xpc_object_t v107 = 0;
              if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v126.__r_.__value_.__l.__data_);
              }
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&buf);
            }
LABEL_44:
            uint64_t v36 = MEMORY[0x1A6275E60](*a2);
            uint64_t v37 = MEMORY[0x1E4F14590];
            if (v36 == MEMORY[0x1E4F14590]) {
              goto LABEL_58;
            }
            uint64_t v38 = *((void *)this + 5);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.st_dev) = 0;
              _os_log_impl(&dword_1A609F000, v38, OS_LOG_TYPE_DEFAULT, "#I Loading raw crash report file due to processing errors", (uint8_t *)&buf, 2u);
            }
            xpc_object_t v39 = xpc_dictionary_create(0, 0, 0);
            if (v39 || (xpc_object_t v39 = xpc_null_create()) != 0)
            {
              if (MEMORY[0x1A6275E60](v39) == v37)
              {
                xpc_retain(v39);
                xpc_object_t v40 = v39;
              }
              else
              {
                xpc_object_t v40 = xpc_null_create();
              }
            }
            else
            {
              xpc_object_t v40 = xpc_null_create();
              xpc_object_t v39 = 0;
            }
            xpc_release(v39);
            xpc_object_t v43 = xpc_null_create();
            xpc_object_t v44 = *a2;
            *a2 = v40;
            xpc_release(v44);
            xpc_release(v43);
            v126.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x30uLL);
            *(_OWORD *)&v126.__r_.__value_.__r.__words[1] = xmmword_1A61F9EB0;
            strcpy(v126.__r_.__value_.__l.__data_, "Coredump invalid: IO error or zero size file: ");
            uint64_t v45 = std::string::append(&v126, "report.json", 0xBuLL);
            long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            *(void *)&buf.st_uid = *((void *)&v45->__r_.__value_.__l + 2);
            *(_OWORD *)&buf.st_dev = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            CoredumpTrace::loadRawCrashReport_sync((uint64_t)this, a2, (uint64_t)&buf);
            if (SHIBYTE(buf.st_gid) < 0)
            {
              operator delete(*(void **)&buf.st_dev);
              if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_58:
                if (!v14) {
                  goto LABEL_60;
                }
                goto LABEL_59;
              }
            }
            else if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_58;
            }
            operator delete(v126.__r_.__value_.__l.__data_);
            if (!v14) {
              goto LABEL_60;
            }
LABEL_59:
            [v14 close];
            goto LABEL_60;
          }
        }
        xpc_object_t xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
        *(void *)&buf.st_dev = &object;
        buf.__darwin_ino64_t st_ino = (__darwin_ino64_t)"agent";
        xpc::dict::object_proxy::operator xpc::dict((uint64_t)&buf, &xdict);
        memset(&buf, 170, 24);
        xpc_object_t v68 = xpc_dictionary_get_value(xdict, "name");
        v126.__r_.__value_.__r.__words[0] = (std::string::size_type)v68;
        if (v68) {
          xpc_retain(v68);
        }
        else {
          v126.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
        }
        xpc::dyn_cast_or_default();
        xpc_release(v126.__r_.__value_.__l.__data_);
        memset(&v126, 170, sizeof(v126));
        xpc_object_t v88 = xpc_dictionary_get_value(object, "scu_rstsr");
        xpc_object_t v112 = v88;
        if (v88) {
          xpc_retain(v88);
        }
        else {
          xpc_object_t v112 = xpc_null_create();
        }
        xpc::dyn_cast_or_default();
        xpc_release(v112);
        xpc_object_t v89 = xpc_dictionary_create(0, 0, 0);
        if (v89 || (xpc_object_t v89 = xpc_null_create()) != 0)
        {
          if (MEMORY[0x1A6275E60](v89) == v35)
          {
            xpc_retain(v89);
            xpc_object_t v90 = v89;
          }
          else
          {
            xpc_object_t v90 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v90 = xpc_null_create();
          xpc_object_t v89 = 0;
        }
        xpc_release(v89);
        xpc_object_t v96 = xpc_null_create();
        xpc_object_t v97 = *a2;
        *a2 = v90;
        xpc_release(v97);
        xpc_release(v96);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned int v98 = &__p;
        }
        else {
          unsigned int v98 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v99 = xpc_string_create((const char *)v98);
        if (!v99) {
          xpc_object_t v99 = xpc_null_create();
        }
        xpc_dictionary_set_value(*a2, "crash", v99);
        xpc_object_t v100 = xpc_null_create();
        xpc_release(v99);
        xpc_release(v100);
        if ((buf.st_gid & 0x80000000) == 0) {
          p_stat buf = (const char *)&buf;
        }
        else {
          p_stat buf = *(const char **)&buf.st_dev;
        }
        xpc_object_t v102 = xpc_string_create(p_buf);
        if (!v102) {
          xpc_object_t v102 = xpc_null_create();
        }
        xpc_dictionary_set_value(*a2, "agent", v102);
        xpc_object_t v103 = xpc_null_create();
        xpc_release(v102);
        xpc_release(v103);
        if ((v126.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v104 = &v126;
        }
        else {
          long long v104 = (std::string *)v126.__r_.__value_.__r.__words[0];
        }
        xpc_object_t v105 = xpc_string_create((const char *)v104);
        if (!v105) {
          xpc_object_t v105 = xpc_null_create();
        }
        xpc_dictionary_set_value(*a2, "scu_rstsr", v105);
        xpc_object_t v106 = xpc_null_create();
        xpc_release(v105);
        xpc_release(v106);
        if (SHIBYTE(v126.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v126.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.st_gid) < 0) {
          operator delete(*(void **)&buf.st_dev);
        }
        xpc_release(xdict);
        goto LABEL_44;
      }
      std::__wrap_iter<const char *> v29 = v113;
      if (!v113) {
        goto LABEL_44;
      }
      int v30 = *((void *)this + 5);
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
      uint64_t v31 = objc_msgSend((id)objc_msgSend(v29, "localizedDescription"), "UTF8String");
      buf.st_dev = 136315138;
      *(void *)&buf.st_mode = v31;
      uint64_t v19 = "Error parsing file via return code: %s";
      int v20 = v30;
      uint32_t v21 = 12;
    }
    else
    {
      size_t v18 = *((void *)this + 5);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
      LOWORD(buf.st_dev) = 0;
      uint64_t v19 = "Error reading file";
      int v20 = v18;
      uint32_t v21 = 2;
    }
    _os_log_error_impl(&dword_1A609F000, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&buf, v21);
    goto LABEL_44;
  }
  xpc_object_t v10 = *((void *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)this + 223) < 0) {
      int v7 = (void *)*v7;
    }
    buf.st_dev = 136315138;
    *(void *)&buf.st_mode = v7;
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "File not found: %s", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  if (v11 || (xpc_object_t v11 = xpc_null_create()) != 0)
  {
    if (MEMORY[0x1A6275E60](v11) == MEMORY[0x1E4F14590])
    {
      xpc_retain(v11);
      xpc_object_t v12 = v11;
    }
    else
    {
      xpc_object_t v12 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v11 = 0;
  }
  xpc_release(v11);
  xpc_object_t v22 = xpc_null_create();
  xpc_object_t v23 = *a2;
  *a2 = v12;
  xpc_release(v23);
  xpc_release(v22);
  *((unsigned char *)&v126.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v126, "report.json");
  long long v24 = std::string::append(&v126, " missing", 8uLL);
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  *(void *)&buf.st_uid = *((void *)&v24->__r_.__value_.__l + 2);
  *(_OWORD *)&buf.st_dev = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  if ((buf.st_gid & 0x80000000) == 0) {
    long long v26 = (const char *)&buf;
  }
  else {
    long long v26 = *(const char **)&buf.st_dev;
  }
  xpc_object_t v27 = xpc_string_create(v26);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_dictionary_set_value(*a2, "ioerror", v27);
  xpc_object_t v28 = xpc_null_create();
  xpc_release(v27);
  xpc_release(v28);
  if (SHIBYTE(buf.st_gid) < 0)
  {
    operator delete(*(void **)&buf.st_dev);
    if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_60;
    }
  }
  else if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_60;
  }
  operator delete(v126.__r_.__value_.__l.__data_);
LABEL_60:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  xpc_release(object);
}

void sub_1A61764FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, xpc_object_t object, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,xpc_object_t a26,uint64_t buf,int a28,__int16 a29,uint64_t a30,char a31,char a32)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

xpc_object_t xpc::dict::object_proxy::operator xpc::object(void *a1, xpc_object_t xdict, char *key)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, key);
  *a1 = value;
  if (value) {
    return xpc_retain(value);
  }
  xpc_object_t result = xpc_null_create();
  *a1 = result;
  return result;
}

xpc_object_t xpc::dict::object_proxy::operator=(xpc_object_t *a1, xpc_object_t xdict, char *key, xpc_object_t *a4)
{
  xpc_dictionary_set_value(xdict, key, *a4);
  *a1 = *a4;
  xpc_object_t result = xpc_null_create();
  *a4 = result;
  return result;
}

uint64_t ICECoredumpTrace::crashBaseband_sync(uint64_t a1)
{
  char v11 = 0;
  uint64_t Controller = (const void *)TelephonyBasebandCreateController();
  xpc_object_t v10 = Controller;
  uint64_t Reset = TelephonyBasebandGetReset();
  if ((Reset & 1) == 0)
  {
    __darwin_ino64_t v4 = *(NSObject **)(a1 + 40);
    uint64_t Reset = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if (Reset)
    {
      *(_WORD *)int v9 = 0;
      _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Failed to get baseband reset state", v9, 2u);
    }
    char v11 = 0;
  }
  int v5 = capabilities::coredump::supportsGPIOSignalling((capabilities::coredump *)Reset);
  xpc_object_t v6 = *(NSObject **)(a1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Crashing baseband (GPIO)", v9, 2u);
    }
    TelephonyBasebandSetModemCoredumpGPIO();
    usleep(0xF4240u);
    TelephonyBasebandSetModemCoredumpGPIO();
  }
  else if (v7)
  {
    *(_WORD *)int v9 = 0;
    _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Modem does not support coredump GPIO signalling", v9, 2u);
  }
  if (Controller) {
    CFRelease(Controller);
  }
  return 0;
}

void sub_1A6176BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t ICECoredumpTrace::makeCrashString@<X0>(xpc_object_t *a1@<X1>, unsigned char *a2@<X8>)
{
  unint64_t v87 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v86[7] = v5;
  v86[8] = v5;
  v86[5] = v5;
  v86[6] = v5;
  v86[3] = v5;
  v86[4] = v5;
  v86[1] = v5;
  v86[2] = v5;
  long long v85 = v5;
  v86[0] = v5;
  *(_OWORD *)std::string::size_type v83 = v5;
  long long v84 = v5;
  long long v81 = v5;
  long long v82 = v5;
  long long v79 = v5;
  long long v80 = v5;
  long long v78 = v5;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v78);
  if (xpc_dictionary_get_value(*a1, "ioerror"))
  {
    memset(&__p, 170, sizeof(__p));
    xpc_object_t value = xpc_dictionary_get_value(*a1, "ioerror");
    xpc_object_t object = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    xpc_release(object);
    timespec v8 = &v79;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
LABEL_27:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_29;
  }
  if (xpc_dictionary_get_value(*a1, "fullreport"))
  {
    memset(&__p, 170, sizeof(__p));
    xpc_object_t v7 = xpc_dictionary_get_value(*a1, "fullreport");
    xpc_object_t object = v7;
    if (v7) {
      xpc_retain(v7);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    xpc_release(object);
    util::strip_non_printable(&__p);
    timespec v8 = (long long *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"RAW=", 4);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    goto LABEL_27;
  }
  xpc_object_t v11 = xpc_dictionary_get_value(*a1, "crash");
  xpc_object_t v12 = v11;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_object_t v21 = xpc_string_create("system_no_cddtable");
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  BOOL v22 = xpc_equal(v12, v21);
  xpc_release(v21);
  xpc_release(v12);
  if (v22)
  {
    xpc_object_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"Missing or corrupt coredump table (", 35);
    xpc_object_t v24 = xpc_dictionary_get_value(*a1, "crash");
    v66[0] = v24;
    if (v24) {
      xpc_retain(v24);
    }
    else {
      v66[0] = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      xpc_object_t v27 = &__p;
    }
    else {
      xpc_object_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v28 = __p.__r_.__value_.__l.__size_;
    }
    std::__wrap_iter<const char *> v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)v27, v28);
    int v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)")", 1);
    uint64_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)" agent=", 7);
    xpc_object_t v32 = xpc_dictionary_get_value(*a1, "agent");
    v63[0] = v32;
    if (v32) {
      xpc_retain(v32);
    }
    else {
      v63[0] = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v76 & 0x80u) == 0) {
      p_xpc_object_t object = &object;
    }
    else {
      p_xpc_object_t object = object;
    }
    if ((v76 & 0x80u) == 0) {
      uint64_t v44 = v76;
    }
    else {
      uint64_t v44 = v75;
    }
    uint64_t v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)p_object, v44);
    long long v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)" scu=", 5);
    xpc_object_t v47 = xpc_dictionary_get_value(*a1, "scu_rstsr");
    xpc_object_t v70 = v47;
    if (v47) {
      xpc_retain(v47);
    }
    else {
      xpc_object_t v70 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v73 & 0x80u) == 0) {
      BOOL v53 = &v71;
    }
    else {
      BOOL v53 = v71;
    }
    if ((v73 & 0x80u) == 0) {
      uint64_t v54 = v73;
    }
    else {
      uint64_t v54 = v72;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)v53, v54);
    if ((char)v73 < 0) {
      operator delete(v71);
    }
    xpc_release(v70);
    if ((char)v76 < 0) {
      operator delete(object);
    }
    xpc_release(v63[0]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    xpc_release(v66[0]);
  }
  else
  {
    long long v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v79, (uint64_t)"TASK=", 5);
    xpc_object_t v26 = xpc_dictionary_get_value(*a1, "host_taskname");
    xpc_object_t v70 = v26;
    if (v26) {
      xpc_retain(v26);
    }
    else {
      xpc_object_t v70 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      xpc_object_t v33 = &__p;
    }
    else {
      xpc_object_t v33 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v34 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)v33, v34);
    uint64_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" @ ", 3);
    xpc_object_t v37 = xpc_dictionary_get_value(*a1, "host_filename");
    xpc_object_t v69 = v37;
    if (v37) {
      xpc_retain(v37);
    }
    else {
      xpc_object_t v69 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v76 & 0x80u) == 0) {
      uint64_t v38 = &object;
    }
    else {
      uint64_t v38 = object;
    }
    if ((v76 & 0x80u) == 0) {
      uint64_t v39 = v76;
    }
    else {
      uint64_t v39 = v75;
    }
    xpc_object_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v38, v39);
    uint64_t v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)":", 1);
    xpc_object_t v42 = xpc_dictionary_get_value(*a1, "host_line");
    xpc_object_t v68 = v42;
    if (v42) {
      xpc_retain(v42);
    }
    else {
      xpc_object_t v68 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v73 & 0x80u) == 0) {
      int v48 = &v71;
    }
    else {
      int v48 = v71;
    }
    if ((v73 & 0x80u) == 0) {
      uint64_t v49 = v73;
    }
    else {
      uint64_t v49 = v72;
    }
    std::string::size_type v50 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)v48, v49);
    std::string::size_type v51 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)",CPU=", 5);
    xpc_object_t v52 = xpc_dictionary_get_value(*a1, "host_cpu_id");
    xpc_object_t v65 = v52;
    if (v52) {
      xpc_retain(v52);
    }
    else {
      xpc_object_t v65 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v67 & 0x80u) == 0) {
      int v55 = v66;
    }
    else {
      int v55 = (xpc_object_t *)v66[0];
    }
    if ((v67 & 0x80u) == 0) {
      uint64_t v56 = v67;
    }
    else {
      uint64_t v56 = (uint64_t)v66[1];
    }
    std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)v55, v56);
    xpc_object_t v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)",LOG=", 5);
    xpc_object_t v59 = xpc_dictionary_get_value(*a1, "log_data");
    xpc_object_t v62 = v59;
    if (v59) {
      xpc_retain(v59);
    }
    else {
      xpc_object_t v62 = xpc_null_create();
    }
    xpc_object_t v88 = 0;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    if ((v64 & 0x80u) == 0) {
      xpc_object_t v60 = v63;
    }
    else {
      xpc_object_t v60 = (xpc_object_t *)v63[0];
    }
    if ((v64 & 0x80u) == 0) {
      uint64_t v61 = v64;
    }
    else {
      uint64_t v61 = (uint64_t)v63[1];
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)v60, v61);
    if ((char)v64 < 0) {
      operator delete(v63[0]);
    }
    xpc_release(v62);
    if ((char)v67 < 0) {
      operator delete(v66[0]);
    }
    xpc_release(v65);
    if ((char)v73 < 0) {
      operator delete(v71);
    }
    xpc_release(v68);
    if ((char)v76 < 0) {
      operator delete(object);
    }
    xpc_release(v69);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    xpc_release(v70);
  }
LABEL_29:
  if ((BYTE8(v85) & 0x10) != 0)
  {
    uint64_t v14 = v85;
    if ((unint64_t)v85 < *((void *)&v82 + 1))
    {
      *(void *)&long long v85 = *((void *)&v82 + 1);
      uint64_t v14 = *((void *)&v82 + 1);
    }
    int v15 = (const void *)v82;
    size_t v13 = v14 - v82;
    if ((unint64_t)(v14 - v82) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_46;
    }
  }
  else
  {
    if ((BYTE8(v85) & 8) == 0)
    {
      size_t v13 = 0;
      a2[23] = 0;
      goto LABEL_42;
    }
    int v15 = (const void *)*((void *)&v80 + 1);
    size_t v13 = *((void *)&v81 + 1) - *((void *)&v80 + 1);
    if (*((void *)&v81 + 1) - *((void *)&v80 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_46:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v13 >= 0x17)
  {
    uint64_t v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v16 = v13 | 7;
    }
    uint64_t v17 = v16 + 1;
    size_t v18 = operator new(v16 + 1);
    *((void *)a2 + 1) = v13;
    *((void *)a2 + 2) = v17 | 0x8000000000000000;
    *(void *)a2 = v18;
    a2 = v18;
    goto LABEL_41;
  }
  a2[23] = v13;
  if (v13) {
LABEL_41:
  }
    memmove(a2, v15, v13);
LABEL_42:
  a2[v13] = 0;
  *(void *)&long long v78 = *MEMORY[0x1E4FBA408];
  uint64_t v19 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)&v78 + *(void *)(v78 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  *(void *)&long long v79 = v19;
  *((void *)&v79 + 1) = MEMORY[0x1E4FBA470] + 16;
  if (SHIBYTE(v84) < 0) {
    operator delete(v83[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1A62751A0](v86);
}

void sub_1A6177524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t a16, xpc_object_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t a23,xpc_object_t a24,xpc_object_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,xpc_object_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  if (a22 < 0) {
    operator delete(a17);
  }
  xpc_release(a16);
  if (a31 < 0) {
    operator delete(a26);
  }
  xpc_release(a23);
  if (a37 < 0) {
    operator delete(a32);
  }
  xpc_release(a24);
  if (a43 < 0) {
    operator delete(a38);
  }
  xpc_release(a25);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void ICECoredumpTrace::~ICECoredumpTrace(ICECoredumpTrace *this)
{
  CoredumpTrace::~CoredumpTrace(this);

  operator delete(v1);
}

void *std::shared_ptr<ICECoredumpTrace>::shared_ptr[abi:ne180100]<ICECoredumpTrace,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  __darwin_ino64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D050;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (!a2) {
    return a1;
  }
  xpc_object_t v6 = *(std::__shared_weak_count **)(a2 + 80);
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *(void *)(a2 + 72) = a2;
      *(void *)(a2 + 80) = v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(void *)(a2 + 72) = a2;
  *(void *)(a2 + 80) = v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_1A617794C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1}::operator() const(ICECoredumpTrace*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A6177974(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<ICECoredumpTrace *,std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace *)#1},std::allocator<ICECoredumpTrace>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110share"
                                "d_ptrIT_EEPS7_EUlPS4_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI5TraceE15make_shared_ptrI16ICECoredumpTraceEENSt3__110shared_ptrIT_EEPS7_EUlPS4_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<ICECoredumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<ICECoredumpTrace>(ICECoredumpTrace*)::{lambda(ICECoredumpTrace*)#1}::operator() const(ICECoredumpTrace*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

BOOL trace::isModeActive(int a1)
{
  return !a1 || a1 == 6;
}

const char *trace::toString(unsigned int a1)
{
  if (a1 > 7) {
    return "Unknown";
  }
  else {
    return off_1E5C47D38[a1];
  }
}

{
  if (a1 > 3) {
    return "unknown";
  }
  else {
    return off_1E5C47D78[a1];
  }
}

{
  if (a1 > 2) {
    return "Unknown";
  }
  else {
    return off_1E5C47D98[a1];
  }
}

{
  if (a1 > 3) {
    return "Unknown";
  }
  else {
    return off_1E5C47DB0[a1];
  }
}

const char *trace::dal::toString(unsigned int a1)
{
  if (a1 > 6) {
    return "TraceLevelUnknown";
  }
  else {
    return off_1E5C47DD0[a1];
  }
}

{
  if (a1 > 2) {
    return "TraceModeUnknown";
  }
  else {
    return off_1E5C47E08[a1];
  }
}

std::string *abm::trace::getBasebandTraceDirSuffix@<X0>(abm::trace *this@<X0>, std::string *a2@<X8>)
{
  int v2 = (int)this;
  memset(a2, 170, sizeof(std::string));
  *((unsigned char *)&a2->__r_.__value_.__s + 23) = 0;
  a2->__r_.__value_.__s.__data_[0] = 0;
  xpc_object_t result = (std::string *)capabilities::radio::vendor(this);
  if ((result - 2) >= 2)
  {
    if (result != 1) {
      return result;
    }
    long long v5 = abm::trace::kEURTraceSnapshotDirectorySuffix;
    if (v2) {
      long long v5 = abm::trace::kEURQDSSTraceSnapshotDirectorySuffix;
    }
  }
  else
  {
    long long v5 = abm::trace::kICETraceSnapshotDirectorySuffix;
  }
  return std::string::__assign_external(a2, *v5);
}

void sub_1A6177BD8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void abm::trace::getCoreDumpDirSuffix(std::string *a1@<X8>)
{
  {
    if (v4)
    {
      int v5 = capabilities::radio::maverick(v4);
      xpc_object_t v6 = abm::trace::kEURCoreDumpSnapshotDirectorySuffix;
      if (!v5) {
        xpc_object_t v6 = abm::trace::kCoreDumpSnapshotDirectorySuffix;
      }
      std::string::basic_string[abi:ne180100]<0>(&abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix, *v6);
    }
  }
  if (byte_1E96B8ACF < 0)
  {
    long long v3 = abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix;
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)v3, *((std::string::size_type *)&v3 + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = abm::trace::getCoreDumpDirSuffix(void)::coredumpDirSuffix;
    a1->__r_.__value_.__r.__words[2] = unk_1E96B8AC8;
  }
}

void sub_1A6177CC0(_Unwind_Exception *a1)
{
}

uint64_t abm::trace::isSupported(uint64_t a1)
{
  uint64_t v1 = (const char *)a1;
  int v2 = *(char *)(a1 + 23);
  if (v2 < 0)
  {
    long long v3 = (capabilities::radio *)strcasecmp(*(const char **)a1, abm::trace::kDIAG[0]);
    if (v3)
    {
LABEL_3:
      __darwin_ino64_t v4 = v1;
      if ((v2 & 0x80) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else
  {
    long long v3 = (capabilities::radio *)strcasecmp((const char *)a1, abm::trace::kDIAG[0]);
    if (v3) {
      goto LABEL_3;
    }
  }
  if (capabilities::radio::maverick(v3)) {
    return 1;
  }
  LOBYTE(v2) = v1[23];
  __darwin_ino64_t v4 = v1;
  if ((v2 & 0x80) == 0)
  {
LABEL_4:
    int v5 = (capabilities::radio *)strcasecmp(v4, abm::trace::kICETrace[0]);
    if (v5) {
      goto LABEL_5;
    }
LABEL_12:
    if (capabilities::radio::ice(v5)) {
      return 1;
    }
    LOBYTE(v2) = v1[23];
    if ((v2 & 0x80) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_11:
  int v5 = (capabilities::radio *)strcasecmp(*(const char **)v1, abm::trace::kICETrace[0]);
  if (!v5) {
    goto LABEL_12;
  }
LABEL_5:
  if ((v2 & 0x80) == 0)
  {
LABEL_6:
    xpc_object_t v6 = v1;
    if (!strcasecmp(v1, (const char *)abm::trace::kBasebandTrace)) {
      return 1;
    }
    goto LABEL_15;
  }
LABEL_14:
  xpc_object_t v6 = *(const char **)v1;
  if (!strcasecmp(*(const char **)v1, (const char *)abm::trace::kBasebandTrace)) {
    return 1;
  }
LABEL_15:
  xpc_object_t v7 = (capabilities::radio *)strcasecmp(v6, abm::trace::kEURCoreDump[0]);
  if (v7)
  {
    if ((v2 & 0x80) == 0) {
      goto LABEL_17;
    }
  }
  else
  {
    if (capabilities::radio::maverick(v7)) {
      return 1;
    }
    if ((v1[23] & 0x80) == 0)
    {
LABEL_17:
      if (!strcasecmp(v1, (const char *)abm::trace::kCoreDump)
        || !strcasecmp(v1, (const char *)abm::trace::kSystemLogs))
      {
        return 1;
      }
      timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kCompression);
      if (!v8) {
        goto LABEL_40;
      }
      if (strcasecmp(v1, (const char *)abm::trace::kBasebandIPC))
      {
        timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kIPC);
        if (!v8) {
          goto LABEL_40;
        }
        timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kKernelPCI);
        if (!v8) {
          goto LABEL_40;
        }
        timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTapToRadar);
        if (!v8) {
          goto LABEL_40;
        }
LABEL_34:
        if (strcasecmp(v1, (const char *)abm::trace::kProfile))
        {
          timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceTailspin);
          if (v8)
          {
            timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceSettings);
            if (v8)
            {
              timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTraceFilter);
              if (v8) {
                return 0;
              }
            }
          }
          goto LABEL_40;
        }
        return 1;
      }
      goto LABEL_43;
    }
  }
  uint64_t v1 = *(const char **)v1;
  if (!strcasecmp(v1, (const char *)abm::trace::kCoreDump) || !strcasecmp(v1, (const char *)abm::trace::kSystemLogs)) {
    return 1;
  }
  timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kCompression);
  if (!v8) {
    goto LABEL_40;
  }
  if (strcasecmp(v1, (const char *)abm::trace::kBasebandIPC))
  {
    timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kIPC);
    if (!v8
      || (timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kKernelPCI), !v8)
      || (timespec v8 = (capabilities::trace *)strcasecmp(v1, (const char *)abm::trace::kTapToRadar), !v8))
    {
LABEL_40:
      return capabilities::trace::allowed(v8);
    }
    goto LABEL_34;
  }
LABEL_43:

  return MEMORY[0x1F417D648]();
}

BasebandTransportICE *BasebandTransportICE::BasebandTransportICE(BasebandTransportICE *a1, uint64_t *a2, NSObject **a3)
{
  __darwin_ino64_t v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  xpc_object_t v10 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v5 = *a3;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  BasebandTransport::BasebandTransport((uint64_t)a1, &v9, &object);
  if (object) {
    dispatch_release(object);
  }
  xpc_object_t v6 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(void *)a1 = &unk_1EFB0D0A0;
  *((void *)a1 + 54) = 0;
  *((void *)a1 + 58) = 0;
  *((void *)a1 + 62) = 0;
  *((void *)a1 + 63) = 0;
  *((void *)a1 + 64) = dispatch_queue_create("BasebandTransportARI", 0);
  BasebandTransportICE::configurePhysical(a1);
  return a1;
}

void sub_1A61780BC(_Unwind_Exception *a1)
{
  xpc_object_t v6 = *((void *)v1 + 64);
  if (v6) {
    dispatch_release(v6);
  }
  std::function<BOOL ()(void)>::~function(v4);
  std::function<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::~function(v3);
  std::function<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::~function(v2);
  BasebandTransport::~BasebandTransport(v1);
  _Unwind_Resume(a1);
}

void sub_1A61780F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object) {
    dispatch_release(object);
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void **BasebandTransportICE::configurePhysical(BasebandTransportICE *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I using physical pipe...", (uint8_t *)&v4, 2u);
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D360;
  int v5 = this;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](&v4, (void *)this + 59);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D3E0;
  int v5 = this;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v4, (void *)this + 55);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D460;
  int v5 = this;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v4, (void *)this + 51);
  xpc_object_t result = v6;
  if (v6 == (void **)&v4) {
    return (void **)((uint64_t (*)(void **))v4[4])((void **)&v4);
  }
  if (v6) {
    return (void **)(*((uint64_t (**)(void))*v6 + 5))();
  }
  return result;
}

void *std::function<BOOL ()(void)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void *std::function<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void *std::function<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void **BasebandTransportICE::configureARIPipe(BasebandTransportICE *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I using ARI client pipe...", (uint8_t *)&v4, 2u);
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D1B0;
  int v5 = this;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](&v4, (void *)this + 59);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D240;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v4, (void *)this + 55);
  if (v6 == (void **)&v4)
  {
    v4[4]((void **)&v4);
  }
  else if (v6)
  {
    (*((void (**)(void))*v6 + 5))();
  }
  __darwin_ino64_t v4 = (void (**)(void **))&unk_1EFB0D2D0;
  int v5 = this;
  xpc_object_t v6 = (void **)&v4;
  std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](&v4, (void *)this + 51);
  xpc_object_t result = v6;
  if (v6 == (void **)&v4) {
    return (void **)((uint64_t (*)(void **))v4[4])((void **)&v4);
  }
  if (v6) {
    return (void **)(*((uint64_t (**)(void))*v6 + 5))();
  }
  return result;
}

uint64_t BasebandTransportICE::open(BasebandTransport *a1, uint64_t *a2, const void **a3)
{
  if (*(_DWORD *)a2 == 8)
  {
    uint64_t v6 = *a2;
    v25[1] = *((_OWORD *)a2 + 1);
    uint64_t v26 = a2[4];
    *(void *)&v25[0] = v6;
    *((void *)&v25[0] + 1) = 1;
    uint64_t v7 = (void *)*a3;
    if (*a3) {
      uint64_t v7 = _Block_copy(v7);
    }
    xpc_object_t v24 = v7;
    BOOL v8 = BasebandTransport::open(a1, v25, &v24);
    if (v24) {
      _Block_release(v24);
    }
    if (v8)
    {
      BOOL v9 = 1;
    }
    else
    {
      xpc_object_t v12 = *((void *)a1 + 5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)stat buf = 0;
        _os_log_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEFAULT, "#I Physical transport not available.  Trying ARI pipe...", buf, 2u);
      }
      long long v13 = *((_OWORD *)a2 + 1);
      v21[0] = *(_OWORD *)a2;
      v21[1] = v13;
      uint64_t v22 = a2[4];
      if (*a3) {
        uint64_t v14 = _Block_copy(*a3);
      }
      else {
        uint64_t v14 = 0;
      }
      int v20 = v14;
      BOOL v15 = BasebandTransportICE::openARIClientPipe((uint64_t)a1, v21, &v20);
      if (v14) {
        _Block_release(v14);
      }
      if (v15)
      {
        BasebandTransportICE::configureARIPipe(a1);
        return 1;
      }
      BOOL v9 = 0;
    }
  }
  else
  {
    long long v10 = *((_OWORD *)a2 + 1);
    v18[0] = *(_OWORD *)a2;
    v18[1] = v10;
    uint64_t v19 = a2[4];
    xpc_object_t v11 = (void *)*a3;
    if (*a3) {
      xpc_object_t v11 = _Block_copy(v11);
    }
    aBlocuint64_t k = v11;
    BOOL v9 = BasebandTransport::open(a1, v18, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
  }
  BasebandTransportICE::configurePhysical(a1);
  return v9;
}

void sub_1A61788F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (v10) {
    _Block_release(v10);
  }
  _Unwind_Resume(exception_object);
}

BOOL BasebandTransportICE::openARIClientPipe(uint64_t a1, long long *a2, void **a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v6 = *a2;
  long long v7 = a2[1];
  *(unsigned char *)(a1 + 136) = *((unsigned char *)a2 + 32);
  *(_OWORD *)(a1 + 120) = v7;
  *(_OWORD *)(a1 + 104) = v6;
  BOOL v8 = *a3;
  if (*a3) {
    BOOL v8 = _Block_copy(v8);
  }
  BOOL v9 = *(const void **)(a1 + 144);
  *(void *)(a1 + 144) = v8;
  if (v9) {
    _Block_release(v9);
  }
  *(_DWORD *)(a1 + 504) = 0;
  long long v10 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v10 || (uint64_t v11 = *(void *)(a1 + 72), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  long long v13 = v12;
  uint64_t v14 = (int *)(a1 + 504);
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v13);
  }
  int v15 = AriHost::RegisterClient((AriHost *)"ipc.bb", (const char *)(a1 + 504), *(int **)(a1 + 512), (dispatch_queue_s *)(1000 * *((_DWORD *)a2 + 2)));
  if (v15)
  {
    BOOL v16 = 0;
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
  }
  else
  {
    v22[0] = v11;
    v22[1] = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    long long v3 = v22;
    BOOL v16 = AriHost::SetRTEventHandler() == 0;
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
  }
  size_t v18 = "fail";
  int v19 = *v14;
  if (v16) {
    size_t v18 = "success";
  }
  *(_DWORD *)stat buf = 136315394;
  xpc_object_t v24 = v18;
  __int16 v25 = 1024;
  int v26 = v19;
  _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I ARI pipe open %s ctx 0x%x", buf, 0x12u);
LABEL_14:
  if (!v15)
  {
    int v20 = (std::__shared_weak_count *)v3[1];
    if (v20) {
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  std::__shared_weak_count::__release_weak(v13);
  return v16;
}

void sub_1A6178BA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

uint64_t BasebandTransportICE::write(BasebandTransportICE *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4, char a5, int a6)
{
  xpc_object_t v12 = a2;
  long long v10 = a4;
  uint64_t v11 = a3;
  char v9 = a5;
  int v8 = a6;
  uint64_t v6 = *((void *)this + 54);
  if (!v6) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, const unsigned __int8 **, uint64_t *, unsigned int **, char *, int *))(*(void *)v6 + 48))(v6, &v12, &v11, &v10, &v9, &v8);
}

uint64_t BasebandTransportICE::read(BasebandTransportICE *this, unsigned __int8 *a2, uint64_t a3, unsigned int *a4, char a5, int a6)
{
  xpc_object_t v12 = a2;
  long long v10 = a4;
  uint64_t v11 = a3;
  char v9 = a5;
  int v8 = a6;
  uint64_t v6 = *((void *)this + 58);
  if (!v6) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, unsigned __int8 **, uint64_t *, unsigned int **, char *, int *))(*(void *)v6 + 48))(v6, &v12, &v11, &v10, &v9, &v8);
}

uint64_t BasebandTransportICE::close_sync(BasebandTransportICE *this)
{
  uint64_t v1 = *((void *)this + 62);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  int v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t ___ZN20BasebandTransportICE17openARIClientPipeEN17BasebandTransport10ParametersEN8dispatch5blockIU13block_pointerFvPhjEEE_block_invoke(void *a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = (std::__shared_weak_count *)a1[6];
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = a1[4];
  __darwin_ino64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = v4;
  if (a1[5])
  {
    uint64_t v6 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = "ipc.bb";
      _os_log_error_impl(&dword_1A609F000, v6, OS_LOG_TYPE_ERROR, "Got AriHost::ARI_RT_REINIT callback for %s", __p, 0xCu);
    }
    char v10 = 6;
    strcpy(__p, "ipc.bb");
    AriHost::ReRegisterClient();
    if (v10 < 0)
    {
      operator delete(*(void **)__p);
      uint64_t v7 = 0;
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_14:
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
    else
    {
      uint64_t v7 = 0;
      if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_14;
    }
  }
  return v7;
}

void sub_1A6178EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL BasebandTransportICE::writeARIClientPipe(BasebandTransportICE *this, const unsigned __int8 *a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v5 = (std::__shared_weak_count *)*((void *)this + 10);
  if (!v5 || (int v8 = std::__shared_weak_count::lock(v5)) == 0) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  char v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (*((_DWORD *)this + 127))
    {
LABEL_5:
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      int started = AriHost::Send();
      uint64_t v11 = v9;
      goto LABEL_6;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v9);
    if (*((_DWORD *)this + 127)) {
      goto LABEL_5;
    }
  }
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int started = AriHost::StartStream();
  uint64_t v11 = v9;
LABEL_6:
  std::__shared_weak_count::__release_weak(v11);
  if (started)
  {
    xpc_object_t v12 = *((void *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)stat buf = 134217984;
      uint64_t v15 = a3;
      _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Failed to send %zu bytes on ARI pipe", buf, 0xCu);
    }
  }
  else if (a4)
  {
    *a4 = a3;
  }
  std::__shared_weak_count::__release_weak(v9);
  return started == 0;
}

void sub_1A6179124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v22);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke(void *a1, uint64_t a2, int a3)
{
  __darwin_ino64_t v4 = (std::__shared_weak_count *)a1[6];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = a1[4];
  int v8 = std::__shared_weak_count::lock(v4);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  char v9 = v8;
  if (a1[5])
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2;
    block[3] = &__block_descriptor_tmp_5_0;
    void block[4] = v7;
    void block[5] = a2;
    int v13 = a3;
    dispatch_async(*(dispatch_queue_t *)(v7 + 152), block);
    uint64_t v10 = 0;
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v10 = 0xFFFFFFFFLL;
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
LABEL_8:
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v10;
}

void ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 128);
  if (v3)
  {
    std::string __p = 0;
    xpc_object_t v12 = 0;
    uint64_t v13 = 0;
    (*(void (**)(uint64_t, void, void, void **))(*(void *)v3 + 8))(v3, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), &__p);
    __darwin_ino64_t v4 = __p;
    size_t v5 = v12 - (unsigned char *)__p;
    if (*(unsigned char *)(v2 + 136))
    {
      uint64_t v6 = malloc_type_malloc(v12 - (unsigned char *)__p, 0x6FF6341AuLL);
      memcpy(v6, v4, v5);
    }
    (*(void (**)(void))(*(void *)(v2 + 144) + 16))();
    if (__p)
    {
      xpc_object_t v12 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v7 = *(const void **)(a1 + 40);
    size_t v8 = *(unsigned int *)(a1 + 48);
    if (*(unsigned char *)(v2 + 136))
    {
      char v9 = malloc_type_malloc(v8, 0x6FF6341AuLL);
      memcpy(v9, v7, v8);
    }
    uint64_t v10 = *(void (**)(void))(*(void *)(v2 + 144) + 16);
    v10();
  }
}

void sub_1A61793C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandTransportICE::sendToDataHandler(BasebandTransportICE *this, unsigned __int8 *a2, size_t size)
{
  if (*((unsigned char *)this + 136))
  {
    uint64_t v6 = malloc_type_malloc(size, 0x6FF6341AuLL);
    memcpy(v6, a2, size);
    uint64_t v7 = *(uint64_t (**)(void))(*((void *)this + 18) + 16);
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(void))(*((void *)this + 18) + 16);
  }
  return v7();
}

uint64_t ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_10(void *a1, AriMsg *a2, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  __darwin_ino64_t v4 = (std::__shared_weak_count *)a1[6];
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = a1[4];
  size_t v8 = std::__shared_weak_count::lock(v4);
  uint64_t v17 = v8;
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  char v9 = v8;
  if (!a1[5])
  {
    uint64_t v12 = 0xFFFFFFFFLL;
    if (atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v12;
    }
    goto LABEL_11;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2_11;
  block[3] = &__block_descriptor_tmp_12;
  void block[4] = v7;
  void block[5] = a2;
  unsigned int v15 = a3;
  dispatch_async(*(dispatch_queue_t *)(v7 + 152), block);
  int BufCtx = AriMsg::GetBufCtx(a2, (const unsigned __int8 *)a3);
  *(_DWORD *)(v7 + 508) = BufCtx;
  uint64_t v11 = *(NSObject **)(v7 + 40);
  uint64_t v12 = 0;
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v12;
    }
LABEL_11:
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    return v12;
  }
  *(_DWORD *)stat buf = 67109120;
  int v19 = BufCtx;
  _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I bypass will use ctx id 0x%x", buf, 8u);
  uint64_t v12 = 0;
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_11;
  }
  return v12;
}

void sub_1A6179680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN20BasebandTransportICE18writeARIClientPipeEPKhmPjbj_block_invoke_2_11(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 128);
  if (v3)
  {
    std::string __p = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    (*(void (**)(uint64_t, void, void, void **))(*(void *)v3 + 8))(v3, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), &__p);
    __darwin_ino64_t v4 = __p;
    size_t v5 = v12 - (unsigned char *)__p;
    if (*(unsigned char *)(v2 + 136))
    {
      uint64_t v6 = malloc_type_malloc(v12 - (unsigned char *)__p, 0x6FF6341AuLL);
      memcpy(v6, v4, v5);
    }
    (*(void (**)(void))(*(void *)(v2 + 144) + 16))();
    if (__p)
    {
      uint64_t v12 = __p;
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v7 = *(const void **)(a1 + 40);
    size_t v8 = *(unsigned int *)(a1 + 48);
    if (*(unsigned char *)(v2 + 136))
    {
      char v9 = malloc_type_malloc(v8, 0x6FF6341AuLL);
      memcpy(v9, v7, v8);
    }
    uint64_t v10 = *(void (**)(void))(*(void *)(v2 + 144) + 16);
    v10();
  }
}

void sub_1A61797E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandTransportICE::closeARIClientPipe_sync(BasebandTransportICE *this)
{
  *((_DWORD *)this + 127) = 0;
  AriHost::DeregisterClient((AriHost *)*((unsigned int *)this + 126));
  *((_DWORD *)this + 126) = 0;
  return 1;
}

void BasebandTransportICE::~BasebandTransportICE(BasebandTransportICE *this)
{
  BasebandTransportICE::~BasebandTransportICE(this);

  operator delete(v1);
}

{
  NSObject *v2;
  BasebandTransportICE *v3;
  char *v4;
  BasebandTransportICE *v5;
  char *v6;
  BasebandTransportICE *v7;
  BasebandTransport *v8;
  uint64_t vars8;

  *(void *)this = &unk_1EFB0D0A0;
  uint64_t v2 = *((void *)this + 64);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = (BasebandTransportICE *)*((void *)this + 62);
  if (v3 == (BasebandTransportICE *)((char *)this + 472))
  {
    (*(void (**)(char *))(*((void *)this + 59) + 32))((char *)this + 472);
    __darwin_ino64_t v4 = (char *)this + 440;
    size_t v5 = (BasebandTransportICE *)*((void *)this + 58);
    if (v5 != (BasebandTransportICE *)((char *)this + 440)) {
      goto LABEL_7;
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(BasebandTransportICE *))(*(void *)v3 + 40))(v3);
    }
    __darwin_ino64_t v4 = (char *)this + 440;
    size_t v5 = (BasebandTransportICE *)*((void *)this + 58);
    if (v5 != (BasebandTransportICE *)((char *)this + 440))
    {
LABEL_7:
      if (v5) {
        (*(void (**)(BasebandTransportICE *))(*(void *)v5 + 40))(v5);
      }
      uint64_t v6 = (char *)this + 408;
      uint64_t v7 = (BasebandTransportICE *)*((void *)this + 54);
      if (v7 != (BasebandTransportICE *)((char *)this + 408)) {
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  (*(void (**)(char *))(*(void *)v4 + 32))(v4);
  uint64_t v6 = (char *)this + 408;
  uint64_t v7 = (BasebandTransportICE *)*((void *)this + 54);
  if (v7 != (BasebandTransportICE *)((char *)this + 408))
  {
LABEL_10:
    if (v7) {
      (*(void (**)(BasebandTransportICE *))(*(void *)v7 + 40))(v7);
    }
    size_t v8 = this;
    goto LABEL_14;
  }
LABEL_17:
  (*(void (**)(char *))(*(void *)v6 + 32))(v6);
  size_t v8 = this;

LABEL_14:
  BasebandTransport::~BasebandTransport(v8);
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  xpc_object_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *xpc_object_t result = &unk_1EFB0D1B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EFB0D1B0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  AriHost::EndStream((AriHost *)*(unsigned int *)(v1 + 508));
  *(_DWORD *)(v1 + 508) = 0;
  AriHost::DeregisterClient((AriHost *)*(unsigned int *)(v1 + 504));
  *(_DWORD *)(v1 + 504) = 0;
  return 1;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_0") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_0")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_0,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_0>,BOOL ()(void)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(void)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    unint64_t v3 = result;
    __darwin_ino64_t v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        xpc_object_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        xpc_object_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      xpc_object_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A6179DEC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone()
{
  xpc_object_t result = operator new(0x10uLL);
  *xpc_object_t result = &unk_1EFB0D240;
  return result;
}

void std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EFB0D240;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  **a4 = 0;
  return 0;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_1") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_1")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_1,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    unint64_t v3 = result;
    __darwin_ino64_t v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        xpc_object_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        xpc_object_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      xpc_object_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A617A184(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  xpc_object_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *xpc_object_t result = &unk_1EFB0D2D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EFB0D2D0;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned int **a4)
{
  __darwin_ino64_t v4 = *(BasebandTransportICE **)(a1 + 8);
  uint64_t v5 = *a2;
  uint64_t v6 = *a3;
  uint64_t v7 = *a4;
  v21[0] = 0;
  v21[1] = v21;
  long long v21[2] = 0x4002000000;
  v21[3] = __Block_byref_object_copy__1;
  v21[4] = __Block_byref_object_dispose__1;
  std::string __p = 0;
  xpc_object_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v17 = 0;
  size_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  uint64_t v20 = v5;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = v6;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  uint64_t v12[2] = ___ZZN20BasebandTransportICE16configureARIPipeEvENK3__2clEPKhmPjbj_block_invoke;
  v12[3] = &unk_1E5C47E68;
  v12[8] = v5;
  v12[9] = v6;
  v12[4] = v21;
  v12[5] = &v17;
  void v12[6] = &v13;
  v12[7] = v4;
  __int16 v25 = v12;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_0;
  block[3] = &__block_descriptor_tmp_39;
  void block[4] = (char *)v4 + 72;
  void block[5] = &v25;
  size_t v8 = *((void *)v4 + 11);
  if (*((void *)v4 + 12))
  {
    dispatch_async_and_wait(v8, block);
    uint64_t v9 = v14[3];
    if (v9)
    {
LABEL_3:
      BOOL v10 = BasebandTransportICE::writeARIClientPipe(v4, (const unsigned __int8 *)v18[3], v9, v7);
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_sync(v8, block);
    uint64_t v9 = v14[3];
    if (v9) {
      goto LABEL_3;
    }
  }
  BOOL v10 = 1;
LABEL_6:
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  if (__p)
  {
    xpc_object_t v23 = __p;
    operator delete(__p);
  }
  return v10;
}

void sub_1A617A3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE16configureARIPipeEvE3$_2") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE16configureARIPipeEvE3$_2")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE16configureARIPipeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configureARIPipe(void)::$_2,std::allocator<BasebandTransportICE::configureARIPipe(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

__n128 __Block_byref_object_copy__1(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

uint64_t (***___ZZN20BasebandTransportICE16configureARIPipeEvENK3__2clEPKhmPjbj_block_invoke(void *a1))(void, void, void, uint64_t)
{
  __n128 result = *(uint64_t (****)(void, void, void, uint64_t))(a1[7] + 128);
  if (result)
  {
    __n128 result = (uint64_t (***)(void, void, void, uint64_t))(**result)(result, a1[8], a1[9], *(void *)(a1[4] + 8) + 40);
    *(void *)(*(void *)(a1[5] + 8) + 24) = *(void *)(*(void *)(a1[4] + 8) + 40);
    *(void *)(*(void *)(a1[6] + 8) + 24) = *(void *)(*(void *)(a1[4] + 8) + 48)
                                                 - *(void *)(*(void *)(a1[4] + 8) + 40);
  }
  return result;
}

void *___ZNK3ctu20SharedSynchronizableI17BasebandTransportE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_0(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void *std::__function::__value_func<BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    unint64_t v3 = result;
    __darwin_ino64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1A617A804(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EFB0D360;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EFB0D360;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::operator()(uint64_t a1)
{
  return BasebandTransport::close_sync(*(BasebandTransport **)(a1 + 8));
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_0") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_0" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_0")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_0,std::allocator<BasebandTransportICE::configurePhysical(void)::$_0>,BOOL ()(void)>::target_type()
{
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EFB0D3E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EFB0D3E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, unsigned __int8 **a2, unint64_t *a3, unsigned int **a4)
{
  return BasebandTransport::read(*(BasebandTransport **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_1") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_1")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_1,std::allocator<BasebandTransportICE::configurePhysical(void)::$_1>,BOOL ()(unsigned char *,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EFB0D460;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EFB0D460;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::operator()(uint64_t a1, const unsigned __int8 **a2, uint64_t *a3, unsigned int **a4)
{
  return BasebandTransport::write(*(BasebandTransport **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN20BasebandTransportICE17configurePhysicalEvE3$_2") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_2" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN20BasebandTransportICE17configurePhysicalEvE3$_2")) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN20BasebandTransportICE17configurePhysicalEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<BasebandTransportICE::configurePhysical(void)::$_2,std::allocator<BasebandTransportICE::configurePhysical(void)::$_2>,BOOL ()(unsigned char const*,unsigned long,unsigned int *,BOOL,unsigned int)>::target_type()
{
}

void abm::CellularLoggingINT::create(uint64_t *a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, void *a4@<X8>)
{
}

uint64_t abm::CellularLoggingINT::CellularLoggingINT(uint64_t a1, uint64_t *a2, uint64_t *a3, dispatch_object_t *a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v12 = *a2;
  uint64_t v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *a3;
  uint64_t v6 = (std::__shared_weak_count *)a3[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  size_t v8 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  *(void *)a1 = &unk_1EFB0CB40;
  uint64_t v14 = "carriercellularlogging.modem";
  ctu::Loggable<abm::CellularLoggingCommon,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::Loggable<char const*,std::shared_ptr<ctu::LogServer>&>((void *)a1, &v14, &v12);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)a1 = &unk_1EFB0CB40;
  *(void *)(a1 + 88) = v7;
  *(void *)(a1 + 96) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = v13;
  *(void *)(a1 + 104) = v12;
  *(void *)(a1 + 112) = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = v8;
  if (!v8)
  {
    *(unsigned char *)(a1 + 128) = 0;
    if (!v6) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  dispatch_retain(v8);
  *(unsigned char *)(a1 + 128) = 0;
  dispatch_release(v8);
  if (v6) {
LABEL_13:
  }
    std::__shared_weak_count::__release_weak(v6);
LABEL_14:
  BOOL v10 = v13;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *(void *)a1 = &unk_1EFB0D4E0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 232) = 3;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 256) = 0;
  return a1;
}

void sub_1A617AD14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v11)
  {
    dispatch_release(v11);
    if (!v10)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
      _Unwind_Resume(a1);
    }
  }
  else if (!v10)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v10);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void abm::CellularLoggingINT::~CellularLoggingINT(void **this)
{
  *this = &unk_1EFB0D4E0;
  if ((*((char *)this + 279) & 0x80000000) == 0)
  {
    if ((*((char *)this + 223) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    operator delete(this[25]);
    uint64_t v2 = (std::__shared_weak_count *)this[23];
    if (!v2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  operator delete(this[32]);
  if (*((char *)this + 223) < 0) {
    goto LABEL_6;
  }
LABEL_3:
  uint64_t v2 = (std::__shared_weak_count *)this[23];
  if (!v2)
  {
LABEL_8:
    if ((*((char *)this + 175) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_14;
  }
LABEL_7:
  if (atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if ((*((char *)this + 175) & 0x80000000) == 0)
  {
LABEL_9:
    unint64_t v3 = (std::__shared_weak_count *)this[18];
    if (!v3) {
      goto LABEL_10;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(this[19]);
  unint64_t v3 = (std::__shared_weak_count *)this[18];
  if (!v3) {
    goto LABEL_10;
  }
LABEL_15:
  if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_10:
    __darwin_ino64_t v4 = (abm::CellularLoggingCommon *)this;
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  __darwin_ino64_t v4 = (abm::CellularLoggingCommon *)this;

LABEL_12:
  abm::CellularLoggingCommon::~CellularLoggingCommon(v4);
}

{
  void *v1;
  uint64_t vars8;

  abm::CellularLoggingINT::~CellularLoggingINT(this);

  operator delete(v1);
}

uint64_t abm::CellularLoggingINT::start(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  xpc_object_t v4 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  BOOL v5 = abm::CellularLoggingCommon::start();
  xpc_release(v4);
  uint64_t v118 = 0;
  if (v5)
  {
    memset(&v117, 170, sizeof(v117));
    HIBYTE(v116[2]) = 19;
    strcpy((char *)v116, "Live_Filter_Setting");
    abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v116, &v117);
    if (SHIBYTE(v116[2]) < 0) {
      operator delete(v116[0]);
    }
    *(_DWORD *)stat buf = -1431655766;
    int v6 = util::convert<int>(&v117, buf, 0);
    int v7 = *(_DWORD *)buf;
    if (!v6) {
      int v7 = 0;
    }
    *(_DWORD *)(a1 + 240) = v7;
    xpc_object_t value = xpc_dictionary_get_value(*a2, "kKeyLiveFilterSetting");
    *(void *)stat buf = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      *(void *)stat buf = xpc_null_create();
    }
    *(_DWORD *)(a1 + 232) = xpc::dyn_cast_or_default();
    xpc_release(*(xpc_object_t *)buf);
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_22:
      char v115 = 4;
      strcpy((char *)v114, "Mode");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v114, (std::string *)buf);
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v117.__r_.__value_.__l.__data_);
      }
      std::string v117 = *(std::string *)buf;
      uint8_t buf[23] = 0;
      buf[0] = 0;
      if (v115 < 0) {
        operator delete(v114[0]);
      }
      *(_DWORD *)stat buf = -1431655766;
      if (util::convert<int>(&v117, buf, 0)) {
        *(_DWORD *)(a1 + 244) = *(_DWORD *)buf;
      }
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(int *)(a1 + 244);
        if (v17 > 7) {
          size_t v18 = "Unknown";
        }
        else {
          size_t v18 = off_1E5C47EC8[v17];
        }
        *(_DWORD *)stat buf = 136315138;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#I Previous trace mode: %s", buf, 0xCu);
      }
      char v113 = 7;
      strcpy((char *)v112, "Enabled");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v112, (std::string *)buf);
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v117.__r_.__value_.__l.__data_);
      }
      std::string v117 = *(std::string *)buf;
      uint8_t buf[23] = 0;
      buf[0] = 0;
      if (v113 < 0) {
        operator delete(v112[0]);
      }
      BOOL v111 = 0;
      util::convert<BOOL>(&v117, &v111, 0);
      BOOL v19 = v111;
      *(unsigned char *)(a1 + 248) = v111;
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v21 = "true";
        if (!v19) {
          xpc_object_t v21 = "false";
        }
        *(_DWORD *)stat buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl(&dword_1A609F000, v20, OS_LOG_TYPE_DEFAULT, "#I Previous trace enabled: %s", buf, 0xCu);
      }
      char v110 = 4;
      strcpy((char *)__p, "File");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)__p, (std::string *)buf);
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v117.__r_.__value_.__l.__data_);
      }
      std::string v117 = *(std::string *)buf;
      uint8_t buf[23] = 0;
      buf[0] = 0;
      if (v110 < 0) {
        operator delete(__p[0]);
      }
      xpc_object_t v22 = xpc_dictionary_get_value(*a2, "kKeyConfigName");
      xpc_object_t object = v22;
      if (v22) {
        xpc_retain(v22);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      xpc::dyn_cast_or_default();
      xpc_object_t v23 = (void **)(a1 + 200);
      if (*(char *)(a1 + 223) < 0) {
        operator delete(*v23);
      }
      *(_OWORD *)xpc_object_t v23 = *(_OWORD *)buf;
      *(void *)(a1 + 216) = *(void *)&buf[16];
      uint8_t buf[23] = 0;
      buf[0] = 0;
      xpc_release(object);
      uint64_t v24 = (void **)(a1 + 256);
      if ((std::string *)(a1 + 256) != &v117)
      {
        if (*(char *)(a1 + 279) < 0)
        {
          if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            __int16 v25 = &v117;
          }
          else {
            __int16 v25 = (std::string *)v117.__r_.__value_.__r.__words[0];
          }
          if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t size = HIBYTE(v117.__r_.__value_.__r.__words[2]);
          }
          else {
            size_t size = v117.__r_.__value_.__l.__size_;
          }
          std::string::__assign_no_alias<false>(v24, v25, size);
        }
        else if ((*((unsigned char *)&v117.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v24, v117.__r_.__value_.__l.__data_, v117.__r_.__value_.__l.__size_);
        }
        else
        {
          *(_OWORD *)uint64_t v24 = *(_OWORD *)&v117.__r_.__value_.__l.__data_;
          *(void *)(a1 + 272) = *((void *)&v117.__r_.__value_.__l + 2);
        }
      }
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v28 = &v117;
        if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v28 = (std::string *)v117.__r_.__value_.__r.__words[0];
        }
        std::__wrap_iter<const char *> v29 = (void *)(a1 + 200);
        if (*(char *)(a1 + 223) < 0) {
          std::__wrap_iter<const char *> v29 = *v23;
        }
        *(_DWORD *)stat buf = 136315394;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = v29;
        _os_log_impl(&dword_1A609F000, v27, OS_LOG_TYPE_DEFAULT, "#I Previous trace primary config: %s, Current trace config: %s", buf, 0x16u);
      }
      char v107 = 7;
      strcpy((char *)v106, "History");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v106, (std::string *)buf);
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v117.__r_.__value_.__l.__data_);
      }
      std::string v117 = *(std::string *)buf;
      uint8_t buf[23] = 0;
      buf[0] = 0;
      if (v107 < 0) {
        operator delete(v106[0]);
      }
      util::convert<int>(&v117, (_DWORD *)(a1 + 288), 0);
      xpc_object_t v30 = xpc_dictionary_get_value(*a2, "kKeyConfigHistory");
      *(void *)stat buf = v30;
      if (v30) {
        xpc_retain(v30);
      }
      else {
        *(void *)stat buf = xpc_null_create();
      }
      *(_DWORD *)(a1 + 192) = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      uint64_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v32 = &v117;
        if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          xpc_object_t v32 = (std::string *)v117.__r_.__value_.__r.__words[0];
        }
        int v33 = *(_DWORD *)(a1 + 192);
        *(_DWORD *)stat buf = 136315394;
        *(void *)&uint8_t buf[4] = v32;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&unsigned char buf[14] = v33;
        _os_log_impl(&dword_1A609F000, v31, OS_LOG_TYPE_DEFAULT, "#I Previous trace history size: %s, Current trace history size: %d", buf, 0x12u);
      }
      xpc_object_t v34 = *a2;
      xpc_object_t v105 = v34;
      if (v34) {
        xpc_retain(v34);
      }
      else {
        xpc_object_t v105 = xpc_null_create();
      }
      uint64_t v35 = (unint64_t *)(a1 + 224);
      BOOL FileSize = abm::CellularLoggingCommon::getFileSize(a1, &v105, (uint64_t *)(a1 + 224));
      xpc_release(v105);
      xpc_object_t v105 = 0;
      if (!FileSize)
      {
        uint64_t v49 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)stat buf = 0;
          _os_log_error_impl(&dword_1A609F000, v49, OS_LOG_TYPE_ERROR, "Failed to get file size", buf, 2u);
        }
        goto LABEL_95;
      }
      unint64_t v38 = *v35;
      uint64_t v39 = (capabilities::abs *)capabilities::radio::vendor(v37);
      int shouldUseMinBasebandTransportIOReadSize = (capabilities::radio *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v39);
      unint64_t v41 = 0x8000;
      if (shouldUseMinBasebandTransportIOReadSize) {
        unint64_t v41 = 0x4000;
      }
      if (v38 >= v41)
      {
        unint64_t v47 = *v35;
        if ((*v35 & (*v35 - 1)) != 0)
        {
LABEL_91:
          int v48 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)stat buf = 134217984;
            *(void *)&uint8_t buf[4] = v47 >> 10;
            _os_log_error_impl(&dword_1A609F000, v48, OS_LOG_TYPE_ERROR, "File size (%zu) KB must be the power of 2", buf, 0xCu);
          }
          goto LABEL_95;
        }
      }
      else
      {
        xpc_object_t v42 = (capabilities::abs *)capabilities::radio::vendor(shouldUseMinBasebandTransportIOReadSize);
        int v43 = capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v42);
        uint64_t v44 = *(NSObject **)(a1 + 40);
        BOOL v45 = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
        if (v45)
        {
          unint64_t v65 = *v35;
          if (v43) {
            int v66 = 16;
          }
          else {
            int v66 = 32;
          }
          *(_DWORD *)stat buf = 134218496;
          *(void *)&uint8_t buf[4] = v65 >> 10;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&unsigned char buf[14] = v66;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v66;
          _os_log_error_impl(&dword_1A609F000, v44, OS_LOG_TYPE_ERROR, "The Given file size %zu KB is less than minimum %u KB, adjusting to %u KB", buf, 0x18u);
        }
        long long v46 = (capabilities::abs *)capabilities::radio::vendor((capabilities::radio *)v45);
        if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v46)) {
          unint64_t v47 = 0x4000;
        }
        else {
          unint64_t v47 = 0x8000;
        }
        unint64_t *v35 = v47;
        if ((v47 & (v47 - 1)) != 0) {
          goto LABEL_91;
        }
      }
      char v104 = 8;
      strcpy((char *)v103, "FileSize");
      abm::CellularLoggingCommon::getProperty(a1, (const std::string::value_type *)v103, (std::string *)buf);
      if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v117.__r_.__value_.__l.__data_);
      }
      std::string v117 = *(std::string *)buf;
      uint8_t buf[23] = 0;
      buf[0] = 0;
      if (v104 < 0) {
        operator delete(v103[0]);
      }
      util::convert<unsigned long>(&v117, (uint64_t *)(a1 + 280), 0);
      std::string::size_type v51 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v52 = *(void *)(a1 + 280) >> 10;
        unint64_t v53 = *v35 >> 10;
        *(_DWORD *)stat buf = 134218240;
        *(void *)&uint8_t buf[4] = v52;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&unsigned char buf[14] = v53;
        _os_log_impl(&dword_1A609F000, v51, OS_LOG_TYPE_DEFAULT, "#I Previous trace file size: %zu KB, Current trace file size: %zu KB", buf, 0x16u);
      }
      if (*(_DWORD *)(a1 + 232) == 3)
      {
LABEL_107:
        if (!*(unsigned char *)(a1 + 128))
        {
          uint64_t v10 = 1;
          goto LABEL_96;
        }
        HIBYTE(v79[2]) = 19;
        strcpy((char *)v79, "Live_Filter_Setting");
        std::to_string((std::string *)buf, 3);
        *(_OWORD *)std::string::size_type v77 = *(_OWORD *)buf;
        uint64_t v78 = *(void *)&buf[16];
        uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v79, (const std::string::value_type *)v77);
        if (SHIBYTE(v78) < 0)
        {
          operator delete(v77[0]);
          if ((SHIBYTE(v79[2]) & 0x80000000) == 0)
          {
LABEL_110:
            if (!v10) {
              goto LABEL_96;
            }
            goto LABEL_125;
          }
        }
        else if ((SHIBYTE(v79[2]) & 0x80000000) == 0)
        {
          goto LABEL_110;
        }
        operator delete(v79[0]);
        if (!v10) {
          goto LABEL_96;
        }
LABEL_125:
        xpc_object_t v58 = (const void *)*MEMORY[0x1E4F4C0E0];
        size_t v59 = strlen((const char *)*MEMORY[0x1E4F4C0E0]);
        if (v59 <= 0x7FFFFFFFFFFFFFF7)
        {
          xpc_object_t v60 = (void *)v59;
          if (v59 >= 0x17)
          {
            uint64_t v63 = (v59 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v59 | 7) != 0x17) {
              uint64_t v63 = v59 | 7;
            }
            uint64_t v64 = v63 + 1;
            uint64_t v61 = (void **)operator new(v63 + 1);
            __dst[1] = v60;
            unint64_t v76 = v64 | 0x8000000000000000;
            __dst[0] = v61;
          }
          else
          {
            HIBYTE(v76) = v59;
            uint64_t v61 = __dst;
            if (!v59) {
              goto LABEL_135;
            }
          }
          memmove(v61, v58, (size_t)v60);
LABEL_135:
          *((unsigned char *)v60 + (void)v61) = 0;
          std::to_string((std::string *)buf, 1);
          *(_OWORD *)unsigned __int8 v73 = *(_OWORD *)buf;
          uint64_t v74 = *(void *)&buf[16];
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)__dst, (const std::string::value_type *)v73);
          if (SHIBYTE(v74) < 0) {
            operator delete(v73[0]);
          }
          if ((SHIBYTE(v76) & 0x80000000) == 0)
          {
            if (!v10) {
              goto LABEL_96;
            }
            goto LABEL_141;
          }
          operator delete(__dst[0]);
          if (v10)
          {
LABEL_141:
            uint64_t v10 = abm::CellularLoggingCommon::changeState((abm::CellularLoggingCommon *)a1, 1);
            goto LABEL_96;
          }
LABEL_95:
          uint64_t v10 = 0;
          goto LABEL_96;
        }
LABEL_201:
        std::string::__throw_length_error[abi:ne180100]();
      }
      xpc_object_t v54 = xpc_dictionary_get_value(*a2, "kKeyLiveFilterFileSize");
      *(void *)stat buf = v54;
      if (v54) {
        xpc_retain(v54);
      }
      else {
        *(void *)stat buf = xpc_null_create();
      }
      *(_DWORD *)(a1 + 236) = xpc::dyn_cast_or_default();
      xpc_release(*(xpc_object_t *)buf);
      unsigned int v55 = *(_DWORD *)(a1 + 236);
      if ((v55 & (v55 - 1)) != 0)
      {
        uint64_t v56 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          goto LABEL_95;
        }
        *(_DWORD *)stat buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v55 >> 10;
        std::string::size_type v57 = "Live-Filter File size (%u) KB must be the power of 2";
        goto LABEL_122;
      }
      if (v55 - 4194305 <= 0xFFC003FE)
      {
        uint64_t v56 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR)) {
          goto LABEL_95;
        }
        *(_DWORD *)stat buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v55 >> 10;
        std::string::size_type v57 = "The Given Live-Filtered file size (%u) KB is beyond allowed limit";
LABEL_122:
        _os_log_error_impl(&dword_1A609F000, v56, OS_LOG_TYPE_ERROR, v57, buf, 8u);
        goto LABEL_95;
      }
      if (*(char *)(a1 + 175) < 0)
      {
        *(void *)(a1 + 160) = 4;
        xpc_object_t v62 = *(char **)(a1 + 152);
      }
      else
      {
        xpc_object_t v62 = (char *)(a1 + 152);
        *(unsigned char *)(a1 + 175) = 4;
      }
      strcpy(v62, ".acp");
      if (*(_DWORD *)(a1 + 232) == 3) {
        goto LABEL_107;
      }
      unsigned __int8 v67 = (char *)*MEMORY[0x1E4F4C0E0];
      size_t v68 = strlen((const char *)*MEMORY[0x1E4F4C0E0]);
      if (v68 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_201;
      }
      xpc_object_t v69 = (void *)v68;
      if (v68 >= 0x17)
      {
        uint64_t v71 = (v68 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v68 | 7) != 0x17) {
          uint64_t v71 = v68 | 7;
        }
        uint64_t v72 = v71 + 1;
        xpc_object_t v70 = operator new(v71 + 1);
        v101[1] = v69;
        unint64_t v102 = v72 | 0x8000000000000000;
        v101[0] = v70;
      }
      else
      {
        HIBYTE(v102) = v68;
        xpc_object_t v70 = v101;
        if (!v68)
        {
LABEL_156:
          *((unsigned char *)v69 + (void)v70) = 0;
          std::to_string((std::string *)buf, 0);
          *(_OWORD *)xpc_object_t v99 = *(_OWORD *)buf;
          uint64_t v100 = *(void *)&buf[16];
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v101, (const std::string::value_type *)v99);
          if (SHIBYTE(v100) < 0)
          {
            operator delete(v99[0]);
            if ((SHIBYTE(v102) & 0x80000000) == 0)
            {
LABEL_158:
              if (!v10) {
                goto LABEL_199;
              }
              goto LABEL_162;
            }
          }
          else if ((SHIBYTE(v102) & 0x80000000) == 0)
          {
            goto LABEL_158;
          }
          operator delete(v101[0]);
          if (!v10)
          {
LABEL_199:
            if (abm::CellularLoggingINT::startReader((abm::CellularLoggingINT *)a1, 1))
            {
LABEL_96:
              if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v117.__r_.__value_.__l.__data_);
              }
              return v10;
            }
            abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)a1, 1);
            goto LABEL_95;
          }
LABEL_162:
          std::string::basic_string[abi:ne180100]<0>(v97, "History");
          util::to_str<BOOL>(*(_DWORD *)(a1 + 192), &v96);
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v97, (const std::string::value_type *)&v96);
          if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v96.__r_.__value_.__l.__data_);
          }
          if (v98 < 0)
          {
            operator delete(v97[0]);
            if ((v10 & 1) == 0) {
              goto LABEL_198;
            }
          }
          else if (!v10)
          {
            goto LABEL_199;
          }
          std::string::basic_string[abi:ne180100]<0>(v94, "FileSize");
          util::to_str<unsigned long>(&v93, *v35);
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v94, (const std::string::value_type *)&v93);
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v93.__r_.__value_.__l.__data_);
          }
          if (v95 < 0)
          {
            operator delete(v94[0]);
            if ((v10 & 1) == 0) {
              goto LABEL_198;
            }
          }
          else if (!v10)
          {
            goto LABEL_199;
          }
          std::string::basic_string[abi:ne180100]<0>(v91, "TraceOwnership");
          util::to_str<abm::traceOwnership>(&v90);
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v91, (const std::string::value_type *)&v90);
          if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v90.__r_.__value_.__l.__data_);
          }
          if (v92 < 0)
          {
            operator delete(v91[0]);
            if ((v10 & 1) == 0) {
              goto LABEL_198;
            }
          }
          else if (!v10)
          {
            goto LABEL_199;
          }
          std::string::basic_string[abi:ne180100]<0>(v88, "Mode");
          util::to_str<trace::Mode>(&v87);
          uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v88, (const std::string::value_type *)&v87);
          if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v87.__r_.__value_.__l.__data_);
          }
          if ((v89 & 0x80000000) == 0)
          {
            if (!v10) {
              goto LABEL_199;
            }
            goto LABEL_186;
          }
          operator delete(v88[0]);
          if (v10)
          {
LABEL_186:
            std::string::basic_string[abi:ne180100]<0>(v85, v67);
            util::to_str<BOOL>(1, &v84);
            uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v85, (const std::string::value_type *)&v84);
            if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v84.__r_.__value_.__l.__data_);
            }
            if ((v86 & 0x80000000) == 0)
            {
              if (!v10) {
                goto LABEL_199;
              }
LABEL_192:
              std::string::basic_string[abi:ne180100]<0>(v82, "File");
              if (*(char *)(a1 + 223) < 0) {
                xpc_object_t v23 = (void **)*v23;
              }
              std::string::basic_string[abi:ne180100]<0>(v80, (char *)v23);
              uint64_t v10 = abm::CellularLoggingCommon::setProperty((void *)a1, (const std::string::value_type *)v82, (const std::string::value_type *)v80);
              if (v81 < 0) {
                operator delete(v80[0]);
              }
              if (v83 < 0) {
                operator delete(v82[0]);
              }
              goto LABEL_199;
            }
            operator delete(v85[0]);
            if (v10) {
              goto LABEL_192;
            }
          }
LABEL_198:
          uint64_t v10 = 0;
          goto LABEL_199;
        }
      }
      memmove(v70, v67, (size_t)v69);
      goto LABEL_156;
    }
    unsigned int v12 = *(_DWORD *)(a1 + 240);
    if (v12 > 3)
    {
      uint64_t v13 = "unknown";
      unsigned int v14 = *(_DWORD *)(a1 + 232);
      if (v14 > 3) {
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v13 = off_1E5C47EA8[v12];
      unsigned int v14 = *(_DWORD *)(a1 + 232);
      if (v14 > 3)
      {
LABEL_18:
        uint64_t v15 = "unknown";
LABEL_21:
        *(_DWORD *)stat buf = 136315906;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&unsigned char buf[14] = v12;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v15;
        __int16 v120 = 1024;
        unsigned int v121 = v14;
        _os_log_impl(&dword_1A609F000, v11, OS_LOG_TYPE_DEFAULT, "#I Live Filter Setting was %s (%d) and is now being set to %s (%d)", buf, 0x22u);
        goto LABEL_22;
      }
    }
    uint64_t v15 = off_1E5C47EA8[v14];
    goto LABEL_21;
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)stat buf = 0;
    _os_log_error_impl(&dword_1A609F000, v9, OS_LOG_TYPE_ERROR, "Failed creating path", buf, 2u);
  }
  return 0;
}

void sub_1A617BEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (*(char *)(v36 - 137) < 0) {
    operator delete(*(void **)(v36 - 160));
  }
  _Unwind_Resume(a1);
}

double util::to_str<unsigned long>(std::string *a1, unint64_t __val)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v4, __val);
  double result = *(double *)&v4.__r_.__value_.__l.__data_;
  *a1 = v4;
  return result;
}

void sub_1A617C2A0(void *a1)
{
}

void sub_1A617C2AC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

double util::to_str<abm::traceOwnership>(std::string *a1)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v3, 1);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_1A617C314(void *a1)
{
}

void sub_1A617C320(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

double util::to_str<trace::Mode>(std::string *a1)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  std::to_string(&v3, 4);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_1A617C388(void *a1)
{
}

void sub_1A617C394(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t abm::CellularLoggingINT::startReader(abm::CellularLoggingINT *this, int a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  std::string v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Starting Readers", (uint8_t *)&buf, 2u);
  }
  memset(&v63, 170, sizeof(v63));
  char v62 = 14;
  strcpy((char *)__p, "TraceOwnership");
  abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)__p, &v63);
  if (v62 < 0) {
    operator delete(__p[0]);
  }
  int data = -1431655766;
  LODWORD(buf.__r_.__value_.__l.__data_) = -1431655766;
  if (util::convert<int>(&v63, &buf, 0))
  {
    int data = (int)buf.__r_.__value_.__l.__data_;
    if (LODWORD(buf.__r_.__value_.__l.__data_) == 1)
    {
      HIBYTE(v60[2]) = 18;
      strcpy((char *)v60, "MaxMemoryFileCount");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v60, &buf);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      std::string v63 = buf;
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(v60[2]) < 0) {
        operator delete(v60[0]);
      }
      int v59 = 0;
      util::convert<unsigned int>(&v63, &v59, 0);
      int v6 = *((void *)this + 5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v59;
        _os_log_impl(&dword_1A609F000, v6, OS_LOG_TYPE_DEFAULT, "#I Maximum memory file count: %u", (uint8_t *)&buf, 8u);
      }
      char v58 = 6;
      strcpy((char *)v57, "SizeIO");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v57, &buf);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      std::string v63 = buf;
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (v58 < 0) {
        operator delete(v57[0]);
      }
      unsigned int v56 = 0;
      util::convert<unsigned int>(&v63, &v56, 0);
      int v7 = *((void *)this + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v56;
        _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Transport IO Read Size: %u", (uint8_t *)&buf, 8u);
      }
      char v55 = 14;
      strcpy((char *)v54, "NumberOfReadIO");
      abm::CellularLoggingCommon::getProperty((uint64_t)this, (const std::string::value_type *)v54, &buf);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      std::string v63 = buf;
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (v55 < 0) {
        operator delete(v54[0]);
      }
      unsigned int v53 = 0;
      util::convert<unsigned int>(&v63, &v53, 0);
      size_t v8 = *((void *)this + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v53;
        _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Transport IO Read Count: %u", (uint8_t *)&buf, 8u);
      }
      buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAA0000;
      *(_OWORD *)&v72[8] = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v73 = 0xAAAAAAAA00100000;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      *(_OWORD *)uint64_t v72 = 0u;
      std::string::__assign_external((std::string *)((char *)&v71 + 8), "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
      if (SBYTE7(v71) < 0)
      {
        *((void *)&v70 + 1) = 4;
        uint64_t v9 = (char *)v70;
      }
      else
      {
        uint64_t v9 = (char *)&v70;
        BYTE7(v71) = 4;
      }
      strcpy(v9, ".acp");
      *(_DWORD *)&v72[16] = *((_DWORD *)this + 48);
      *(_DWORD *)&v72[20] = v59;
      int v13 = *((_DWORD *)this + 58);
      if (v13 != 2)
      {
        if (v13 == 1)
        {
          int v14 = *((_DWORD *)this + 59);
          goto LABEL_39;
        }
        if (v13) {
          goto LABEL_40;
        }
      }
      int v14 = *((_DWORD *)this + 56);
LABEL_39:
      LODWORD(v73) = v14;
LABEL_40:
      unint64_t v45 = 0xAAAAAAAAAAAA0000;
      *(_OWORD *)&v51[8] = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long v46 = 0u;
      long long v47 = 0u;
      *(_OWORD *)int v48 = 0u;
      *(_OWORD *)uint64_t v49 = 0u;
      long long v50 = 0u;
      *(_OWORD *)std::string::size_type v51 = 0u;
      unint64_t v52 = 0xAAAAAAAA00100000;
      BYTE7(v41) = 5;
      strcpy((char *)&v40, "-live");
      uint64_t v15 = std::string::insert((std::string *)&v40, 0, "/private/var/mobile/Library/Logs/CellularLogging", 0x30uLL);
      std::string::size_type v16 = v15->__r_.__value_.__r.__words[0];
      *(void *)&long long v66 = v15->__r_.__value_.__l.__size_;
      *(void *)((char *)&v66 + 7) = *(std::string::size_type *)((char *)&v15->__r_.__value_.__r.__words[1] + 7);
      char v17 = HIBYTE(v15->__r_.__value_.__r.__words[2]);
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      if ((v51[15] & 0x80000000) != 0) {
        operator delete(*((void **)&v50 + 1));
      }
      *((void *)&v50 + 1) = v16;
      *(void *)std::string::size_type v51 = v66;
      *(void *)&v51[7] = *(void *)((char *)&v66 + 7);
      v51[15] = v17;
      if (SBYTE7(v41) < 0)
      {
        operator delete((void *)v40);
        if ((SBYTE7(v50) & 0x80000000) == 0) {
          goto LABEL_44;
        }
      }
      else if ((SBYTE7(v50) & 0x80000000) == 0)
      {
LABEL_44:
        size_t v18 = (char *)v49;
        BYTE7(v50) = 4;
        goto LABEL_47;
      }
      v49[1] = (void *)4;
      size_t v18 = (char *)v49[0];
LABEL_47:
      strcpy(v18, ".acp");
      *(_DWORD *)&v51[16] = *((_DWORD *)this + 48);
      *(_DWORD *)&v51[20] = v59;
      LODWORD(v52) = *((_DWORD *)this + 59);
      BOOL v19 = (std::__shared_weak_count *)*((void *)this + 14);
      uint64_t v43 = *((void *)this + 13);
      uint64_t v44 = v19;
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      abm::trace::TraceReader::create();
      long long v20 = v40;
      long long v40 = 0uLL;
      xpc_object_t v21 = (std::__shared_weak_count *)*((void *)this + 18);
      *(_OWORD *)((char *)this + 136) = v20;
      if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
      xpc_object_t v22 = (std::__shared_weak_count *)*((void *)&v40 + 1);
      if (*((void *)&v40 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      xpc_object_t v23 = v44;
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
        if (*((void *)this + 17))
        {
LABEL_58:
          uint64_t v25 = *((void *)this + 9);
          uint64_t v24 = (std::__shared_weak_count *)*((void *)this + 10);
          *(void *)&long long v66 = v25;
          if (!v24 || (int v26 = std::__shared_weak_count::lock(v24), (*((void *)&v66 + 1) = v26) == 0)) {
            std::__throw_bad_weak_ptr[abi:ne180100]();
          }
          uint64_t v27 = v26;
          *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v41 = v28;
          *(void *)&long long v40 = 0xAAAAAA0000000011;
          unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v40 + 1) = 10;
          int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v26);
          if (shouldUseMinBasebandTransportIOReadSize) {
            int v30 = 0x4000;
          }
          else {
            int v30 = 0x8000;
          }
          LODWORD(v41) = v30;
          capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize);
          LOBYTE(v42) = 0;
          long long v41 = __PAIR64__(v53, v56);
          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 3321888768;
          aBlock[2] = ___ZN3abm18CellularLoggingINT11startReaderEb_block_invoke;
          aBlock[3] = &__block_descriptor_56_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE_e22_v48__0_Status_iBQQQQ_8l;
          aBlock[4] = this;
          void aBlock[5] = v25;
          uint64_t v39 = v27;
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          xpc_object_t v37 = _Block_copy(aBlock);
          uint64_t v11 = abm::trace::TraceReader::start();
          if (v37) {
            _Block_release(v37);
          }
          if ((v11 & a2) == 1)
          {
            if (abm::CellularLoggingCommon::changeState(this, 1))
            {
              uint64_t v11 = 1;
            }
            else
            {
              xpc_object_t v32 = *((void *)this + 5);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)uint64_t v64 = 136315138;
                unint64_t v65 = "true";
                _os_log_error_impl(&dword_1A609F000, v32, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", v64, 0xCu);
              }
              uint64_t v11 = 0;
            }
          }
          int v33 = v39;
          if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
          xpc_object_t v34 = (std::__shared_weak_count *)*((void *)&v66 + 1);
          if (*((void *)&v66 + 1)
            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v66 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }
          goto LABEL_81;
        }
      }
      else if (*((void *)this + 17))
      {
        goto LABEL_58;
      }
      uint64_t v31 = *((void *)this + 5);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v40) = 0;
        _os_log_error_impl(&dword_1A609F000, v31, OS_LOG_TYPE_ERROR, "Failed to create trace reader!", (uint8_t *)&v40, 2u);
      }
      uint64_t v11 = 0;
LABEL_81:
      if ((v51[15] & 0x80000000) != 0)
      {
        operator delete(*((void **)&v50 + 1));
        if ((SBYTE7(v50) & 0x80000000) == 0)
        {
LABEL_83:
          uint64_t v35 = (void *)*((void *)&v47 + 1);
          if (!*((void *)&v47 + 1)) {
            goto LABEL_85;
          }
          goto LABEL_84;
        }
      }
      else if ((SBYTE7(v50) & 0x80000000) == 0)
      {
        goto LABEL_83;
      }
      operator delete(v49[0]);
      uint64_t v35 = (void *)*((void *)&v47 + 1);
      if (!*((void *)&v47 + 1))
      {
LABEL_85:
        if (SBYTE7(v47) < 0)
        {
          operator delete(v46[0]);
          if ((v72[15] & 0x80000000) == 0)
          {
LABEL_87:
            if ((SBYTE7(v71) & 0x80000000) == 0) {
              goto LABEL_88;
            }
            goto LABEL_97;
          }
        }
        else if ((v72[15] & 0x80000000) == 0)
        {
          goto LABEL_87;
        }
        operator delete(*((void **)&v71 + 1));
        if ((SBYTE7(v71) & 0x80000000) == 0)
        {
LABEL_88:
          uint64_t v36 = (void *)*((void *)&v68 + 1);
          if (!*((void *)&v68 + 1)) {
            goto LABEL_90;
          }
          goto LABEL_89;
        }
LABEL_97:
        operator delete((void *)v70);
        uint64_t v36 = (void *)*((void *)&v68 + 1);
        if (!*((void *)&v68 + 1))
        {
LABEL_90:
          if (SBYTE7(v68) < 0) {
            operator delete((void *)buf.__r_.__value_.__l.__size_);
          }
          goto LABEL_30;
        }
LABEL_89:
        *(void *)&long long v69 = v36;
        operator delete(v36);
        goto LABEL_90;
      }
LABEL_84:
      v48[0] = v35;
      operator delete(v35);
      goto LABEL_85;
    }
  }
  uint64_t v10 = *((void *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = data;
    _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Trace Owner: %d, CellularLogging does not own trace transport. Skip creating trace reader", (uint8_t *)&buf, 8u);
  }
  uint64_t v11 = 0;
LABEL_30:
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v63.__r_.__value_.__l.__data_);
  }
  return v11;
}

void sub_1A617CDD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v63 + 40);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v64 - 208);
  TraceFileCollection::Parameters::~Parameters(&a28);
  TraceFileCollection::Parameters::~Parameters((void **)(v64 - 192));
  if (*(char *)(v64 - 233) < 0) {
    operator delete(*(void **)(v64 - 256));
  }
  _Unwind_Resume(a1);
}

void sub_1A617CED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a57 < 0) {
    JUMPOUT(0x1A617CEC8);
  }
  JUMPOUT(0x1A617CED0);
}

uint64_t abm::CellularLoggingINT::stopReader(abm::CellularLoggingINT *this, int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  std::string v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14) = 0;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Stopping Readers", (uint8_t *)&v14, 2u);
  }
  int v6 = (void *)((char *)this + 136);
  BOOL v5 = (abm::trace::TraceReader *)*((void *)this + 17);
  if (!v5) {
    goto LABEL_18;
  }
  char v7 = abm::trace::TraceReader::stop(v5);
  size_t v8 = *((void *)this + 5);
  if (v7)
  {
    if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14) = 0;
      _os_log_impl(&dword_1A609F000, v8, OS_LOG_TYPE_DEFAULT, "#I Succeeded stopping reader.", (uint8_t *)&v14, 2u);
    }
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 18);
    *((void *)this + 17) = 0;
    *((void *)this + 18) = 0;
    if (v9)
    {
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 18);
      void *v6 = 0;
      *((void *)this + 18) = 0;
      if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
        uint64_t v11 = 1;
        if (!a2) {
          return v11;
        }
        goto LABEL_19;
      }
    }
    else
    {
      void *v6 = 0;
      *((void *)this + 18) = 0;
    }
LABEL_18:
    uint64_t v11 = 1;
    if (!a2) {
      return v11;
    }
    goto LABEL_19;
  }
  if (os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v14) = 0;
    _os_log_error_impl(&dword_1A609F000, v8, OS_LOG_TYPE_ERROR, "Failed to stop reader", (uint8_t *)&v14, 2u);
    uint64_t v11 = 0;
    if (!a2) {
      return v11;
    }
  }
  else
  {
    uint64_t v11 = 0;
    if (!a2) {
      return v11;
    }
  }
LABEL_19:
  if ((abm::CellularLoggingCommon::changeState(this, 0) & 1) == 0)
  {
    unsigned int v12 = *((void *)this + 5);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v14 = 136315138;
      uint64_t v15 = "false";
      _os_log_error_impl(&dword_1A609F000, v12, OS_LOG_TYPE_ERROR, "Failed to change state (%s) for cellularlogging!", (uint8_t *)&v14, 0xCu);
    }
    return 0;
  }
  return v11;
}

uint64_t abm::CellularLoggingINT::pause(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string v4 = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I CellularLogging Pause", v4, 2u);
    if (*(_DWORD *)(a1 + 232) == 3) {
      return 1;
    }
  }
  else if (*(_DWORD *)(a1 + 232) == 3)
  {
    return 1;
  }
  if (*(void *)(a1 + 136)) {
    return abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)a1, 0);
  }
  return 1;
}

uint64_t abm::CellularLoggingINT::resume(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string v4 = 0;
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#I CellularLogging Resume", v4, 2u);
    if (*(_DWORD *)(a1 + 232) == 3) {
      return 1;
    }
  }
  else if (*(_DWORD *)(a1 + 232) == 3)
  {
    return 1;
  }
  if (*(void *)(a1 + 136)) {
    return abm::CellularLoggingINT::startReader((abm::CellularLoggingINT *)a1, 0);
  }
  return 1;
}

void ___ZN3abm18CellularLoggingINT11startReaderEb_block_invoke(uint64_t a1, _DWORD *a2)
{
  if (*a2 == 3)
  {
    uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string v3 = 0;
      _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, "#E No Logging Traffic detected (Stalled?)", v3, 2u);
    }
  }
}

uint64_t __copy_helper_block_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c55_ZTSNSt3__110shared_ptrIN3abm21CellularLoggingCommonEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void abm::CellularLoggingINT::restoreToPreviousState(abm::CellularLoggingINT *this)
{
  uint64_t v2 = (const void *)*MEMORY[0x1E4F4C0E0];
  size_t v3 = strlen((const char *)*MEMORY[0x1E4F4C0E0]);
  if (v3 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string v4 = (void *)v3;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    BOOL v5 = (void **)operator new(v6 + 1);
    __dst[1] = v4;
    unint64_t v39 = v7 | 0x8000000000000000;
    __dst[0] = v5;
    goto LABEL_8;
  }
  HIBYTE(v39) = v3;
  BOOL v5 = __dst;
  if (v3) {
LABEL_8:
  }
    memmove(v5, v2, (size_t)v4);
  *((unsigned char *)v4 + (void)v5) = 0;
  std::to_string(&v40, 0);
  std::string v37 = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)__dst, (const std::string::value_type *)&v37);
  if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v39) & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_14:
    operator delete(__dst[0]);
    if (*((_DWORD *)this + 58) == 3) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  operator delete(v37.__r_.__value_.__l.__data_);
  if (SHIBYTE(v39) < 0) {
    goto LABEL_14;
  }
LABEL_11:
  if (*((_DWORD *)this + 58) == 3) {
    goto LABEL_19;
  }
LABEL_15:
  char v36 = 14;
  strcpy((char *)v35, "TraceOwnership");
  std::to_string(&v40, 0);
  std::string v34 = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v35, (const std::string::value_type *)&v34);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v34.__r_.__value_.__l.__data_);
    if ((v36 & 0x80000000) == 0) {
      goto LABEL_17;
    }
LABEL_35:
    operator delete(v35[0]);
    goto LABEL_17;
  }
  if (v36 < 0) {
    goto LABEL_35;
  }
LABEL_17:
  char v33 = 4;
  strcpy((char *)v32, "Mode");
  std::to_string(&v40, *((_DWORD *)this + 61));
  std::string v31 = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v32, (const std::string::value_type *)&v31);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v31.__r_.__value_.__l.__data_);
    if ((v33 & 0x80000000) == 0) {
      goto LABEL_19;
    }
  }
  else if ((v33 & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(v32[0]);
LABEL_19:
  char v30 = 7;
  strcpy((char *)v29, "History");
  std::to_string(&v40, *((_DWORD *)this + 72));
  std::string __p = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v29, (const std::string::value_type *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v30 & 0x80000000) == 0) {
      goto LABEL_21;
    }
  }
  else if ((v30 & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(v29[0]);
LABEL_21:
  char v27 = 8;
  v25.__r_.__value_.__r.__words[2] = 0;
  strcpy((char *)v26, "FileSize");
  std::to_string(&v40, *((void *)this + 35));
  std::string v25 = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v26, (const std::string::value_type *)&v25);
  if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v27 & 0x80000000) == 0) {
      goto LABEL_23;
    }
LABEL_30:
    operator delete(v26[0]);
    int v8 = *((_DWORD *)this + 60);
    if (v8 == 3) {
      goto LABEL_24;
    }
    goto LABEL_31;
  }
  operator delete(v25.__r_.__value_.__l.__data_);
  if (v27 < 0) {
    goto LABEL_30;
  }
LABEL_23:
  int v8 = *((_DWORD *)this + 60);
  if (v8 == 3)
  {
LABEL_24:
    v24[23] = 19;
    strcpy(v24, "Live_Filter_Setting");
    std::to_string(&v40, 0);
    std::string v23 = v40;
    abm::CellularLoggingCommon::setProperty(this, v24, (const std::string::value_type *)&v23);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v23.__r_.__value_.__l.__data_);
      if ((v24[23] & 0x80000000) == 0) {
        goto LABEL_43;
      }
    }
    else if ((v24[23] & 0x80000000) == 0)
    {
      goto LABEL_43;
    }
    uint64_t v9 = v24;
    goto LABEL_42;
  }
LABEL_31:
  v22[23] = 19;
  strcpy(v22, "Live_Filter_Setting");
  std::to_string(&v40, v8);
  std::string v21 = v40;
  abm::CellularLoggingCommon::setProperty(this, v22, (const std::string::value_type *)&v21);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v21.__r_.__value_.__l.__data_);
    if ((v22[23] & 0x80000000) == 0) {
      goto LABEL_43;
    }
  }
  else if ((v22[23] & 0x80000000) == 0)
  {
    goto LABEL_43;
  }
  uint64_t v9 = v22;
LABEL_42:
  operator delete(*(void **)v9);
LABEL_43:
  if (!*((unsigned char *)this + 248)) {
    goto LABEL_54;
  }
  size_t v10 = strlen((const char *)v2);
  if (v10 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = (void *)v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    unsigned int v12 = operator new(v13 + 1);
    v19[1] = v11;
    unint64_t v20 = v14 | 0x8000000000000000;
    v19[0] = v12;
    goto LABEL_51;
  }
  HIBYTE(v20) = v10;
  unsigned int v12 = v19;
  if (v10) {
LABEL_51:
  }
    memmove(v12, v2, (size_t)v11);
  *((unsigned char *)v11 + (void)v12) = 0;
  std::to_string(&v40, *((unsigned __int8 *)this + 248));
  std::string v18 = v40;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v19, (const std::string::value_type *)&v18);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v20) & 0x80000000) == 0) {
      goto LABEL_54;
    }
  }
  else if ((SHIBYTE(v20) & 0x80000000) == 0)
  {
    goto LABEL_54;
  }
  operator delete(v19[0]);
LABEL_54:
  char v17 = 4;
  strcpy((char *)v16, "File");
  if (*((char *)this + 279) < 0) {
    std::string::__init_copy_ctor_external(&v15, *((const std::string::value_type **)this + 32), *((void *)this + 33));
  }
  else {
    std::string v15 = *(std::string *)((char *)this + 256);
  }
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v16, (const std::string::value_type *)&v15);
  if ((SHIBYTE(v15.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v17 & 0x80000000) == 0) {
      return;
    }
LABEL_61:
    operator delete(v16[0]);
    return;
  }
  operator delete(v15.__r_.__value_.__l.__data_);
  if (v17 < 0) {
    goto LABEL_61;
  }
}

void sub_1A617D95C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1A617DB78(void *a1)
{
}

void sub_1A617DB84()
{
  if ((*(char *)(v0 - 121) & 0x80000000) == 0) {
    JUMPOUT(0x1A617DB5CLL);
  }
  JUMPOUT(0x1A617DB54);
}

void abm::CellularLoggingINT::stop(abm::CellularLoggingINT *this)
{
  if (!abm::CellularLoggingCommon::isStarted(this))
  {
    uint64_t v2 = *((void *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    size_t v3 = "#I Cellular Logging has not been started yet";
    std::string v4 = buf;
    goto LABEL_7;
  }
  if (*((_DWORD *)this + 58) == 3)
  {
    uint64_t v2 = *((void *)this + 5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v5 = 0;
    size_t v3 = "#I In streaming mode, skipping";
    std::string v4 = (uint8_t *)&v5;
LABEL_7:
    _os_log_impl(&dword_1A609F000, v2, OS_LOG_TYPE_DEFAULT, v3, v4, 2u);
    return;
  }
  abm::CellularLoggingINT::stopReader(this, 1);

  abm::CellularLoggingINT::restoreToPreviousState(this);
}

void abm::CellularLoggingINT::stopWithConfig(uint64_t a1, uint64_t a2)
{
  if (abm::CellularLoggingCommon::isStarted((abm::CellularLoggingCommon *)a1))
  {
    if (*(_DWORD *)(a1 + 232) == 3)
    {
      abm::CellularLoggingINT::restoreToPreviousState((abm::CellularLoggingINT *)a1);
      uint8_t v4 = abm::CellularLoggingCommon::changeState((abm::CellularLoggingCommon *)a1, 0);
      if (*(void *)(a2 + 24))
      {
        uint8_t v5 = v4;
        xpc_object_t object = xpc_null_create();
        buf[0] = v5;
        uint64_t v6 = *(void *)(a2 + 24);
        if (!v6) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(void *)v6 + 48))(v6, buf, &object);
        xpc_release(object);
      }
    }
    else
    {
      abm::CellularLoggingINT::stop((abm::CellularLoggingINT *)a1);
      if (*(void *)(a2 + 24))
      {
        xpc_object_t v10 = xpc_null_create();
        buf[0] = 1;
        uint64_t v9 = *(void *)(a2 + 24);
        if (!v9) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(void *)v9 + 48))(v9, buf, &v10);
        xpc_release(v10);
      }
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_1A609F000, v7, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
    }
    xpc_object_t v12 = xpc_null_create();
    buf[0] = 1;
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(void *)v8 + 48))(v8, buf, &v12);
    xpc_release(v12);
  }
}

void sub_1A617DE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, xpc_object_t a12)
{
}

void abm::CellularLoggingINT::getConfigName(abm::CellularLoggingINT *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 223) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 25), *((void *)this + 26));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 200);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 27);
  }
}

uint64_t abm::CellularLoggingINT::getConfigHistoryMB(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 48);
}

void abm::CellularLoggingINT::getFileExtension(abm::CellularLoggingINT *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 175) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 19), *((void *)this + 20));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 152);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 21);
  }
}

uint64_t abm::CellularLoggingINT::getMaxNumberOfFiles(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 48);
}

uint64_t abm::CellularLoggingINT::getFileSize(abm::CellularLoggingINT *this)
{
  return *((unsigned int *)this + 56);
}

xpc_object_t abm::CellularLoggingINT::getModemInformation1@<X0>(void *a1@<X8>)
{
  xpc_object_t result = xpc_null_create();
  *a1 = result;
  return result;
}

xpc_object_t abm::CellularLoggingINT::getModemInformation2@<X0>(void *a1@<X8>)
{
  xpc_object_t result = xpc_null_create();
  *a1 = result;
  return result;
}

uint64_t abm::CellularLoggingINT::getCurrentIndex(abm::CellularLoggingINT *this)
{
  if (*((void *)this + 17))
  {
    uint64_t v1 = *((void *)this + 17);
    return MEMORY[0x1F410C770](v1);
  }
  else
  {
    uint64_t v2 = *((void *)this + 5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint8_t v4 = 0;
      _os_log_error_impl(&dword_1A609F000, v2, OS_LOG_TYPE_ERROR, "Reader does not exist!", v4, 2u);
    }
    return 0;
  }
}

void abm::CellularLoggingINT::getCandidateConfigNames(void *a1@<X8>)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  memset(a1, 170, 24);
  char v3 = 7;
  strcpy((char *)__p, "Default");
  std::vector<std::string>::vector[abi:ne180100](a1, (uint64_t)__p, 1uLL);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1A617E07C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL abm::CellularLoggingINT::checkPrecondition(abm::CellularLoggingINT *this)
{
  BOOL isStarted = abm::CellularLoggingCommon::isStarted(this);
  if (!isStarted || *((_DWORD *)this + 58) != 3) {
    return isStarted;
  }
  HIBYTE(v5[2]) = 19;
  strcpy((char *)v5, "Live_Filter_Setting");
  std::to_string(&v6, 3);
  std::string __p = v6;
  abm::CellularLoggingCommon::setProperty(this, (const std::string::value_type *)v5, (const std::string::value_type *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v5[2]) & 0x80000000) == 0) {
      return isStarted;
    }
  }
  else if ((SHIBYTE(v5[2]) & 0x80000000) == 0)
  {
    return isStarted;
  }
  operator delete(v5[0]);
  return isStarted;
}

void sub_1A617E170(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((a21 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

void sub_1A617E1A4(void *a1)
{
}

void sub_1A617E1B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((a14 & 0x80000000) == 0) {
    JUMPOUT(0x1A617E184);
  }
  JUMPOUT(0x1A617E17CLL);
}

BOOL abm::CellularLoggingINT::handleAppCrash(NSObject **this, std::string::size_type a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 58) != 3)
  {
    abm::CellularLoggingINT::stopReader((abm::CellularLoggingINT *)this, 1);
    memset(buf, 170, sizeof(buf));
    Timestamp::Timestamp((Timestamp *)buf);
    *((unsigned char *)&v23.__r_.__value_.__s + 23) = 1;
    LOWORD(v23.__r_.__value_.__l.__data_) = 47;
    uint64_t v7 = std::string::insert(&v23, 0, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging", 0x47uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    size_t v9 = strlen(abm::trace::kLogDirPrefix[0]);
    xpc_object_t v10 = std::string::append(&v25, abm::trace::kLogDirPrefix[0], v9);
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    Timestamp::asString((uint64_t)buf, 0, 9, __p);
    if ((v22 & 0x80u) == 0) {
      xpc_object_t v12 = __p;
    }
    else {
      xpc_object_t v12 = (void **)__p[0];
    }
    if ((v22 & 0x80u) == 0) {
      std::string::size_type v13 = v22;
    }
    else {
      std::string::size_type v13 = (std::string::size_type)__p[1];
    }
    uint64_t v14 = std::string::append(&v26, (const std::string::value_type *)v12, v13);
    std::string v24 = *v14;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if ((char)v22 < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_16:
        if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_17;
        }
        goto LABEL_31;
      }
    }
    else if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_16;
    }
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_17:
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_18;
      }
LABEL_32:
      operator delete(v23.__r_.__value_.__l.__data_);
LABEL_18:
      v26.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x48uLL);
      *(_OWORD *)&v26.__r_.__value_.__r.__words[1] = xmmword_1A61F74B0;
      strcpy(v26.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging");
      BOOL Dir = support::fs::createDir((const char *)&v26, 0x1EDu, 1);
      BOOL v6 = Dir;
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v26.__r_.__value_.__l.__data_);
        if (v6)
        {
LABEL_20:
          memset(&v26, 170, sizeof(v26));
          v25.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x38uLL);
          *(_OWORD *)&v25.__r_.__value_.__r.__words[1] = xmmword_1A61F8900;
          strcpy(v25.__r_.__value_.__l.__data_, "/private/var/mobile/Library/Logs/CellularLogging");
          support::fs::moveDirUnique((const char *)&v25, (uint64_t)&v24, (uint64_t)&v26);
          if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v25.__r_.__value_.__l.__data_);
            uint64_t v16 = this[5];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
LABEL_22:
              if (*(char *)(a2 + 23) >= 0) {
                std::string::size_type v17 = a2;
              }
              else {
                std::string::size_type v17 = *(void *)a2;
              }
              std::string v18 = &v26;
              if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string v18 = (std::string *)v26.__r_.__value_.__r.__words[0];
              }
              LODWORD(v25.__r_.__value_.__l.__data_) = 136315394;
              *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = v17;
              WORD2(v25.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v25.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
              _os_log_impl(&dword_1A609F000, v16, OS_LOG_TYPE_DEFAULT, "#N Detected %s crash, moving logs to %s", (uint8_t *)&v25, 0x16u);
              if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
              {
LABEL_43:
                operator delete(v26.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_41;
                }
                goto LABEL_40;
              }
              goto LABEL_39;
            }
          }
          else
          {
            uint64_t v16 = this[5];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_22;
            }
          }
          if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_43;
          }
          goto LABEL_39;
        }
      }
      else if (Dir)
      {
        goto LABEL_20;
      }
      BOOL v19 = this[5];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v26.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v26.__r_.__value_.__r.__words + 4) = (std::string::size_type)"/private/var/mobile/Library/Logs/CrashReporter/Baseband/CellularLogging";
        _os_log_error_impl(&dword_1A609F000, v19, OS_LOG_TYPE_ERROR, "Failed to create directory %s", (uint8_t *)&v26, 0xCu);
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_40;
        }
        goto LABEL_41;
      }
LABEL_39:
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
LABEL_40:
      }
        operator delete(v24.__r_.__value_.__l.__data_);
LABEL_41:
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)buf, *(void **)&buf[8]);
      return v6;
    }
LABEL_31:
    operator delete(v25.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_32;
  }
  uint64_t v4 = this[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v5 = a2;
    }
    else {
      std::string::size_type v5 = *(void *)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl(&dword_1A609F000, v4, OS_LOG_TYPE_DEFAULT, "#I Detected %s crashed", buf, 0xCu);
  }
  return 1;
}

void sub_1A617E5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy(v33 - 64, *(void **)(v33 - 56));
  _Unwind_Resume(a1);
}

void abm::CellularLoggingINT::snapshot(abm::CellularLoggingCommon *a1, uint64_t a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!abm::CellularLoggingCommon::isStarted(a1))
  {
    size_t v9 = *((void *)a1 + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEFAULT, "#I Cellular Logging has not been started yet", buf, 2u);
    }
    if (a3[3])
    {
      xpc_object_t object = xpc_null_create();
      buf[0] = 0;
      uint64_t v10 = a3[3];
      if (!v10) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      (*(void (**)(uint64_t, uint8_t *, xpc_object_t *))(*(void *)v10 + 48))(v10, buf, &object);
      xpc_release(object);
    }
    return;
  }
  BOOL v6 = dispatch_group_create();
  uint64_t v7 = v6;
  dispatch_object_t v11 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v7);
  }
  uint64_t v8 = a3[3];
  if (!v8) {
    goto LABEL_7;
  }
  if ((void *)v8 != a3)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
LABEL_7:
    std::string v15 = (void *)v8;
    goto LABEL_14;
  }
  std::string v15 = v14;
  (*(void (**)(void *, void *))(*a3 + 24))(a3, v14);
LABEL_14:
  abm::CellularLoggingINT::snapshotInternal((uint64_t)a1, &v11, a2, v14);
  if (v15 == v14)
  {
    (*(void (**)(void *))(v14[0] + 32))(v14);
    if (v7)
    {
LABEL_18:
      dispatch_group_leave(v7);
      dispatch_release(v7);
      dispatch_release(v7);
    }
  }
  else
  {
    if (v15) {
      (*(void (**)(void *))(*v15 + 40))(v15);
    }
    if (v7) {
      goto LABEL_18;
    }
  }
}

void sub_1A617E8DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, char a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void abm::CellularLoggingINT::snapshotInternal(uint64_t a1, dispatch_object_t *a2, uint64_t a3, void *a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = dispatch_group_create();
  uint64_t v8 = dispatch_queue_create("CellularLoggingCommon", 0);
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2020000000;
  char v30 = 0;
  v27[0] = 0;
  v27[1] = v27;
  void v27[2] = 0x3812000000;
  v27[3] = __Block_byref_object_copy__2;
  _OWORD v27[4] = __Block_byref_object_dispose__2;
  v27[5] = "";
  xpc_object_t object = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t object = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t object = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_8;
    }
  }
  if (MEMORY[0x1A6275E60](v10) == MEMORY[0x1E4F14590])
  {
    xpc_retain(v10);
    goto LABEL_9;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_8:
  xpc_object_t object = v11;
LABEL_9:
  xpc_release(v10);
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  std::string v26 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
  char v24 = 12;
  strcpy((char *)__p, "helperserver");
  abm::client::CreateManager();
  xpc_object_t v12 = *(std::__shared_weak_count **)(a1 + 80);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  abm::client::CollectTelephonyLogs();
  if (v22 < 0) {
    operator delete(v21);
  }
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  if (v7)
  {
    dispatch_group_leave(v7);
    dispatch_release(v7);
    dispatch_group_leave(v7);
    dispatch_release(v7);
  }
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN3abm18CellularLoggingINT16snapshotInternalEN8dispatch13group_sessionERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS3_8functionIFvbN3xpc4dictEEEE_block_invoke_16;
  block[3] = &unk_1EFB0D618;
  dispatch_object_t v32 = *a2;
  if (v32)
  {
    dispatch_retain(v32);
    if (v32) {
      dispatch_group_enter(v32);
    }
  }
  uint64_t v13 = a4[3];
  if (!v13) {
    goto LABEL_35;
  }
  if ((void *)v13 != a4)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
LABEL_35:
    std::string v34 = (void *)v13;
    goto LABEL_37;
  }
  std::string v34 = v33;
  (*(void (**)(void *, void *))(*a4 + 24))(a4, v33);
LABEL_37:
  void block[4] = v29;
  void block[5] = v27;
  dispatch_group_notify(v7, *(dispatch_queue_t *)(a1 + 120), block);
  if (v34 == v33)
  {
    (*(void (**)(void *))(v33[0] + 32))(v33);
    unint64_t v20 = v32;
    if (!v32) {
      goto LABEL_45;
    }
    goto LABEL_43;
  }
  if (v34) {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v34 + 40))(v34, v14, v15, v16, v17, v18, v19);
  }
  unint64_t v20 = v32;
  if (v32)
  {
LABEL_43:
    dispatch_group_leave(v20);
    if (v32) {
      dispatch_release(v32);
    }
  }
LABEL_45:
  if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  _Block_object_dispose(v27, 8);
  xpc_release(object);
  _Block_object_dispose(v29, 8);
  if (v8) {
    dispatch_release(v8);
  }
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_1A617EEC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_group_t group, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void abm::CellularLoggingINT::getLogPath(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X3>, std::string *a4@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  memset(&v41, 170, sizeof(v41));
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v41, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string v41 = *(std::string *)a3;
  }
  if (a2 == 2)
  {
    *((unsigned char *)&v40.__r_.__value_.__s + 23) = 1;
    LOWORD(v40.__r_.__value_.__l.__data_) = 46;
    size_t v9 = strlen(abm::trace::kLogTarExtension[0]);
    uint64_t v8 = std::string::append(&v40, abm::trace::kLogTarExtension[0], v9);
  }
  else
  {
    if (a2 != 1) {
      goto LABEL_12;
    }
    *((unsigned char *)&v40.__r_.__value_.__s + 23) = 1;
    LOWORD(v40.__r_.__value_.__l.__data_) = 46;
    size_t v7 = strlen(abm::trace::kLogTarGzExtension);
    uint64_t v8 = std::string::append(&v40, abm::trace::kLogTarGzExtension, v7);
  }
  std::string::size_type v10 = v8->__r_.__value_.__r.__words[0];
  v42.__r_.__value_.__r.__words[0] = v8->__r_.__value_.__l.__size_;
  *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v8->__r_.__value_.__r.__words[1] + 7);
  char v11 = HIBYTE(v8->__r_.__value_.__r.__words[2]);
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  v41.__r_.__value_.__r.__words[0] = v10;
  v41.__r_.__value_.__l.__size_ = v42.__r_.__value_.__r.__words[0];
  *(std::string::size_type *)((char *)&v41.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v42.__r_.__value_.__r.__words + 7);
  *((unsigned char *)&v41.__r_.__value_.__s + 23) = v11;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
LABEL_12:
  xpc_object_t v12 = abm::trace::kSnapshotFolder[0];
  size_t v13 = strlen(abm::trace::kSnapshotFolder[0]);
  if (v13 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v14 = v13;
  if (v13 >= 0x17)
  {
    uint64_t v16 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v16 = v13 | 7;
    }
    uint64_t v17 = v16 + 1;
    p_dst = (std::string *)operator new(v16 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_19;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13;
  p_dst = &__dst;
  if (v13) {
LABEL_19:
  }
    memmove(p_dst, v12, v14);
  p_dst->__r_.__value_.__s.__data_[v14] = 0;
  uint64_t v18 = abm::trace::kLogDirPrefix[0];
  size_t v19 = strlen(abm::trace::kLogDirPrefix[0]);
  if (v19 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v20 = v19;
  if (v19 >= 0x17)
  {
    uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v22 = v19 | 7;
    }
    uint64_t v23 = v22 + 1;
    uint64_t p_p = operator new(v22 + 1);
    size_t v37 = v20;
    int64_t v38 = v23 | 0x8000000000000000;
    std::string __p = p_p;
    goto LABEL_27;
  }
  HIBYTE(v38) = v19;
  uint64_t p_p = &__p;
  if (v19) {
LABEL_27:
  }
    memmove(p_p, v18, v20);
  *((unsigned char *)p_p + v20) = 0;
  if (v38 >= 0) {
    char v24 = (const std::string::value_type *)&__p;
  }
  else {
    char v24 = (const std::string::value_type *)__p;
  }
  if (v38 >= 0) {
    std::string::size_type v25 = HIBYTE(v38);
  }
  else {
    std::string::size_type v25 = v37;
  }
  std::string v26 = std::string::append(&__dst, v24, v25);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  int v28 = *(char *)(a1 + 23);
  if (v28 >= 0) {
    std::__wrap_iter<const char *> v29 = (const std::string::value_type *)a1;
  }
  else {
    std::__wrap_iter<const char *> v29 = *(const std::string::value_type **)a1;
  }
  if (v28 >= 0) {
    std::string::size_type v30 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v30 = *(void *)(a1 + 8);
  }
  std::string v31 = std::string::append(&v42, v29, v30);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v33 = &v41;
  }
  else {
    uint64_t v33 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v41.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v40, (const std::string::value_type *)v33, size);
  *a4 = *v35;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v40.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_48:
      if ((SHIBYTE(v38) & 0x80000000) == 0) {
        goto LABEL_49;
      }
      goto LABEL_54;
    }
  }
  else if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_48;
  }
  operator delete(v42.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
LABEL_49:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_55;
  }
LABEL_54:
  operator delete(__p);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_50:
    if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_56:
    operator delete(v41.__r_.__value_.__l.__data_);
    return;
  }
LABEL_55:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_56;
  }
}

void sub_1A617F39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  xpc_object_t result = xpc_null_create();
  *(void *)(a2 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
}

void ___ZN3abm18CellularLoggingINT16snapshotInternalEN8dispatch13group_sessionERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS3_8functionIFvbN3xpc4dictEEEE_block_invoke(void *a1, _DWORD *a2, xpc_object_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[11];
  if (!v4) {
    return;
  }
  uint64_t v7 = a1[6];
  uint64_t v8 = std::__shared_weak_count::lock(v4);
  uint64_t v23 = v8;
  if (!v8) {
    return;
  }
  size_t v9 = v8;
  if (!a1[10])
  {
LABEL_31:
    if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    return;
  }
  if (*a2)
  {
    std::string::size_type v10 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v10, OS_LOG_TYPE_ERROR, "Failed to collect telephony logs", buf, 2u);
    }
    goto LABEL_31;
  }
  uint64_t v11 = MEMORY[0x1E4F14590];
  if (a3)
  {
    xpc_retain(a3);
  }
  else
  {
    a3 = xpc_null_create();
    if (!a3)
    {
      xpc_object_t v12 = xpc_null_create();
      a3 = 0;
      goto LABEL_14;
    }
  }
  if (MEMORY[0x1A6275E60](a3) == v11)
  {
    xpc_retain(a3);
    xpc_object_t v12 = a3;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
  }
LABEL_14:
  xpc_release(a3);
  if (MEMORY[0x1A6275E60](v12) == v11)
  {
    xpc_object_t value = xpc_dictionary_get_value(v12, (const char *)*MEMORY[0x1E4F4C4C8]);
    xpc_object_t object = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    *(void *)std::string buf = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0x200000000000000;
    xpc::dyn_cast_or_default();
    strcpy((char *)buf, "-*");
    abm::CellularLoggingINT::getLogPath((uint64_t)&v19, 2, (uint64_t)buf, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v15 = xpc_string_create((const char *)p_p);
    if (!v15) {
      xpc_object_t v15 = xpc_null_create();
    }
    xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1[4] + 8) + 48), "kKeyLogDumpMainPath", v15);
    xpc_object_t v16 = xpc_null_create();
    xpc_release(v15);
    xpc_release(v16);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    xpc_release(object);
  }
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  uint64_t v17 = *(NSObject **)(v7 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_1A609F000, v17, OS_LOG_TYPE_DEFAULT, "#I Telephony logs dumped successfully", buf, 2u);
  }
  xpc_release(v12);
  size_t v9 = v23;
  if (v23) {
    goto LABEL_31;
  }
}

void sub_1A617F7C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  xpc_release(v27);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_56c30_ZTSN8dispatch13group_sessionE64c47_ZTSNSt3__110shared_ptrIN3abm6client7ManagerEEE80c52_ZTSNSt3__18weak_ptrIN3abm21CellularLoggingCommonEEE(void *a1, void *a2)
{
  uint64_t v4 = a2[7];
  a1[7] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    std::string::size_type v5 = a1[7];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = a2[9];
  a1[8] = a2[8];
  a1[9] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a2[11];
  a1[10] = a2[10];
  a1[11] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
}

void __destroy_helper_block_e8_56c30_ZTSN8dispatch13group_sessionE64c47_ZTSNSt3__110shared_ptrIN3abm6client7ManagerEEE80c52_ZTSNSt3__18weak_ptrIN3abm21CellularLoggingCommonEEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  char v3 = (std::__shared_weak_count *)a1[9];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = a1[7];
    if (!v4) {
      return;
    }
  }
  else
  {
    uint64_t v4 = a1[7];
    if (!v4) {
      return;
    }
  }
  dispatch_group_leave(v4);
  std::string::size_type v5 = a1[7];
  if (v5)
  {
    dispatch_release(v5);
  }
}

void ___ZN3abm18CellularLoggingINT16snapshotInternalEN8dispatch13group_sessionERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS3_8functionIFvbN3xpc4dictEEEE_block_invoke_16(void *a1)
{
  if (a1[10])
  {
    char v2 = *(unsigned char *)(*(void *)(a1[4] + 8) + 24);
    char v3 = *(void **)(*(void *)(a1[5] + 8) + 48);
    xpc_object_t object = v3;
    if (v3)
    {
      xpc_retain(v3);
      char v6 = v2;
      uint64_t v4 = a1[10];
      if (v4)
      {
LABEL_4:
        (*(void (**)(uint64_t, char *, xpc_object_t *))(*(void *)v4 + 48))(v4, &v6, &object);
        xpc_release(object);
        return;
      }
    }
    else
    {
      xpc_object_t object = xpc_null_create();
      char v6 = v2;
      uint64_t v4 = a1[10];
      if (v4) {
        goto LABEL_4;
      }
    }
    std::__throw_bad_function_call[abi:ne180100]();
  }
}

void sub_1A617FA00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

uint64_t __copy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c38_ZTSNSt3__18functionIFvbN3xpc4dictEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    std::string::size_type v5 = *(NSObject **)(a1 + 48);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t result = *(void *)(a2 + 80);
  if (!result) {
    goto LABEL_7;
  }
  if (result != a2 + 56)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
LABEL_7:
    *(void *)(a1 + 80) = result;
    return result;
  }
  *(void *)(a1 + 80) = a1 + 56;
  return (*(uint64_t (**)(void))(**(void **)(a2 + 80) + 24))(*(void *)(a2 + 80));
}

void sub_1A617FAD0(_Unwind_Exception *exception_object)
{
  char v3 = *(NSObject **)(v1 + 48);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(v1 + 48);
    if (v4) {
      dispatch_release(v4);
    }
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c30_ZTSN8dispatch13group_sessionE56c38_ZTSNSt3__18functionIFvbN3xpc4dictEEEE(uint64_t a1)
{
  uint64_t v2 = a1 + 56;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (!v4) {
      return;
    }
    goto LABEL_7;
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 48);
  if (v4)
  {
LABEL_7:
    dispatch_group_leave(v4);
    std::string::size_type v5 = *(NSObject **)(a1 + 48);
    if (v5)
    {
      dispatch_release(v5);
    }
  }
}

void std::allocate_shared[abi:ne180100]<abm::CellularLoggingINT,std::allocator<abm::CellularLoggingINT>,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,void>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x140uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = &v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D670;
  std::string::size_type v10 = (std::__shared_weak_count_vtbl *)&v8[1];
  std::construct_at[abi:ne180100]<abm::CellularLoggingINT,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingINT*>((uint64_t)&v8[1], a1, a2, a3);
  *a4 = v8 + 1;
  a4[1] = v8;
  shared_owners = (std::__shared_weak_count *)v8[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_owners);
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  else
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[4].__vftable = v10;
    v8[4].__shared_owners_ = (uint64_t)v8;
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);

  std::__shared_weak_count::__release_weak(v8);
}

void sub_1A617FCF8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<abm::CellularLoggingINT>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D670;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::CellularLoggingINT>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D670;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<abm::CellularLoggingINT>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::construct_at[abi:ne180100]<abm::CellularLoggingINT,std::shared_ptr<ctu::LogServer> &,std::weak_ptr<abm::HelperServerInternal> &,dispatch::queue &,abm::CellularLoggingINT*>(uint64_t a1, uint64_t *a2, uint64_t *a3, NSObject **a4)
{
  std::string::size_type v5 = (std::__shared_weak_count *)a2[1];
  v11[0] = *a2;
  v11[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v6 = (std::__shared_weak_count *)a3[1];
  v10[0] = *a3;
  v10[1] = (uint64_t)v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *a4;
  dispatch_object_t v9 = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  abm::CellularLoggingINT::CellularLoggingINT(a1, v11, v10, &v9);
  if (v7) {
    dispatch_release(v7);
  }
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (!v5 || atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
  std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void sub_1A617FE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v14)
  {
    dispatch_release(v14);
    if (!v13)
    {
LABEL_3:
      std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
      _Unwind_Resume(a1);
    }
  }
  else if (!v13)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v13);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_18_0()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_1A609F000);
  }
  return result;
}

void abm::HelperClient::create(char *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  char v6 = operator new(0x28uLL);
  uint64_t v7 = v6;
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = &unk_1EFB0D960;
  uint64_t v8 = v6 + 3;
  uint64_t v9 = *a2;
  std::string::size_type v10 = (std::__shared_weak_count *)a2[1];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v11[0] = v9;
  v11[1] = (uint64_t)v10;
  abm::HelperClient::HelperClient(v6 + 3, a1, v11);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *a3 = v8;
  a3[1] = v7;
}

void sub_1A618004C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v10)
  {
    if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::__shared_weak_count::~__shared_weak_count(v9);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void *abm::HelperClient::HelperClient(void *a1, char *__s, uint64_t *a3)
{
  size_t v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v12 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v12 = v6 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v7;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
    p_dst = &__dst;
    if (!v6)
    {
      __dst.__r_.__value_.__s.__data_[0] = 0;
      uint64_t v10 = *a3;
      uint64_t v9 = (std::__shared_weak_count *)a3[1];
      uint64_t v43 = v9;
      if (!v9) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }
  memcpy(p_dst, __s, v7);
  p_dst->__r_.__value_.__s.__data_[v7] = 0;
  uint64_t v10 = *a3;
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v43 = v9;
  if (v9) {
LABEL_5:
  }
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_6:
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = operator new(0x90uLL);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v47, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v47 = __dst;
  }
  uint64_t v45 = v10;
  long long v46 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)&v57.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v57, "com.apple.abm.helper");
  std::string::size_type v14 = std::string::append(&v57, ".", 1uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v16 = &v47;
  }
  else {
    xpc_object_t v16 = (std::string *)v47.__r_.__value_.__r.__words[0];
  }
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v47.__r_.__value_.__l.__size_;
  }
  uint64_t v18 = std::string::append(&v48, (const std::string::value_type *)v16, size);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  unint64_t v52 = (void *(*)(uint64_t))v18->__r_.__value_.__r.__words[2];
  long long __p = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v20 = &v47;
  }
  else {
    char v20 = (std::string *)v47.__r_.__value_.__r.__words[0];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v56, "com.apple.abm.helper", (const char *)v20);
  if (SHIBYTE(v52) >= 0) {
    uint64_t p_p = (const char *)&__p;
  }
  else {
    uint64_t p_p = (const char *)__p;
  }
  uint64_t v22 = dispatch_queue_create(p_p, 0);
  v11[9] = 0;
  v11[10] = 0;
  v11[11] = v22;
  if (v22)
  {
    uint64_t v23 = v22;
    dispatch_retain(v22);
    v11[12] = 0;
    dispatch_release(v23);
  }
  else
  {
    v11[12] = 0;
  }
  *uint64_t v11 = &unk_1EFB0D820;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v59);
  v11[1] = &unk_1EFB08838;
  char v24 = v46;
  v11[7] = v45;
  v11[8] = v24;
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v58);
  *uint64_t v11 = &unk_1EFB0D7E0;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v56);
  if (SHIBYTE(v52) < 0)
  {
    operator delete((void *)__p);
    if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_35:
      if ((SHIBYTE(v57.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_40:
      operator delete(v57.__r_.__value_.__l.__data_);
      *uint64_t v11 = &unk_1EFB0D710;
      uint64_t v25 = (std::string *)(v11 + 13);
      if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_41;
    }
  }
  else if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_35;
  }
  operator delete(v48.__r_.__value_.__l.__data_);
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_40;
  }
LABEL_36:
  *uint64_t v11 = &unk_1EFB0D710;
  uint64_t v25 = (std::string *)(v11 + 13);
  if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_37:
    std::string *v25 = v47;
    goto LABEL_42;
  }
LABEL_41:
  std::string::__init_copy_ctor_external(v25, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
LABEL_42:
  uint64_t v26 = v46;
  v11[16] = v45;
  v11[17] = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *a1 = v11;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  long long v27 = (std::__shared_weak_count *)operator new(0x20uLL);
  v27->__shared_owners_ = 0;
  p_shared_owners = &v27->__shared_owners_;
  v27->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D6C0;
  v27->__shared_weak_owners_ = 0;
  v27[1].__vftable = (std::__shared_weak_count_vtbl *)v11;
  a1[1] = v27;
  std::__wrap_iter<const char *> v29 = (std::__shared_weak_count *)v11[10];
  if (!v29)
  {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v11[9] = v11;
    v11[10] = v27;
    if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_58;
    }
LABEL_49:
    std::string::size_type v30 = (void *)*a1;
    if (!*(void *)(*a1 + 56)) {
      goto LABEL_59;
    }
    goto LABEL_50;
  }
  if (v29->__shared_owners_ != -1) {
    goto LABEL_49;
  }
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v11[9] = v11;
  v11[10] = v27;
  std::__shared_weak_count::__release_weak(v29);
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_49;
  }
LABEL_58:
  ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
  std::__shared_weak_count::__release_weak(v27);
  std::string::size_type v30 = (void *)*a1;
  if (!*(void *)(*a1 + 56)) {
    goto LABEL_59;
  }
LABEL_50:
  std::string v31 = (std::__shared_weak_count *)v30[10];
  if (!v31 || (std::string::size_type v32 = v30[9], (v33 = std::__shared_weak_count::lock(v31)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  std::string::size_type v34 = (std::string::size_type)v33;
  *(void *)&long long __p = v32;
  *((void *)&__p + 1) = v33;
  ctu::LoggerCommonBase::getLogDomain((ctu::LoggerCommonBase *)(v30 + 1));
  v48.__r_.__value_.__r.__words[0] = v32;
  v48.__r_.__value_.__l.__size_ = v34;
  long long __p = 0uLL;
  ctu::TrackedLogger::registerLoggerToServer();
  uint64_t v35 = (std::__shared_weak_count *)v48.__r_.__value_.__l.__size_;
  if (v48.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v48.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  char v36 = (std::__shared_weak_count *)*((void *)&__p + 1);
  if (*((void *)&__p + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__p + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
LABEL_59:
  size_t v37 = v46;
  if (!v46 || atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
  std::__shared_weak_count::__release_weak(v37);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
LABEL_62:
  }
    operator delete(v47.__r_.__value_.__l.__data_);
LABEL_63:
  uint64_t v38 = *a1;
  uint64_t v39 = *a1 + 72;
  v48.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
  v48.__r_.__value_.__l.__size_ = 0x40000000;
  v48.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN3abm20HelperClientInternal4initEv_block_invoke;
  uint64_t v49 = &__block_descriptor_tmp_9;
  uint64_t v50 = v38;
  v57.__r_.__value_.__r.__words[0] = (std::string::size_type)&v48;
  *(void *)&long long __p = MEMORY[0x1E4F143A8];
  *((void *)&__p + 1) = 0x40000000;
  unint64_t v52 = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  unsigned int v53 = &__block_descriptor_tmp_16;
  uint64_t v54 = v39;
  char v55 = &v57;
  std::string v40 = *(NSObject **)(v38 + 88);
  if (*(void *)(v38 + 96))
  {
    dispatch_async_and_wait(v40, &__p);
    std::string v41 = v43;
    if (!v43) {
      goto LABEL_68;
    }
  }
  else
  {
    dispatch_sync(v40, &__p);
    std::string v41 = v43;
    if (!v43) {
      goto LABEL_68;
    }
  }
  if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return a1;
    }
    goto LABEL_69;
  }
LABEL_68:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
LABEL_69:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1A61807A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(v25);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  if (a25 < 0) {
    operator delete(__p);
  }
  operator delete(v25);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if ((a17 & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(a12);
  _Unwind_Resume(a1);
}

void sub_1A61807C8()
{
}

void sub_1A61807D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a27);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a33);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v33);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a18);
  if (a25 < 0)
  {
    operator delete(__p);
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if ((a17 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if ((a17 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  operator delete(a12);
  _Unwind_Resume(a1);
}

void sub_1A61807F0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[11], v1, (dispatch_function_t)std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal*)#1}::operator() const(abm::HelperClientInternal*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_1A6180818()
{
}

void sub_1A6180828(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 80));
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 96));
  ctu::SharedSynchronizable<diag::DIAGConfigurer>::~SharedSynchronizable(v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v40 - 144));
  if (a38 < 0)
  {
    operator delete(__p);
    if ((a29 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v40 - 105) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((a29 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a24);
  if ((*(char *)(v40 - 105) & 0x80000000) == 0)
  {
LABEL_4:
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
    if ((a22 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_10:
  operator delete(*(void **)(v40 - 128));
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  if ((a22 & 0x80000000) == 0)
  {
LABEL_6:
    operator delete(v38);
    std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
    if (SHIBYTE(a14) < 0) {
      JUMPOUT(0x1A6180964);
    }
    JUMPOUT(0x1A6180944);
  }
LABEL_5:
  operator delete(a17);
  goto LABEL_6;
}

void sub_1A61808B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    JUMPOUT(0x1A61808C4);
  }
  JUMPOUT(0x1A6180868);
}

void sub_1A61808D8()
{
  if (*(char *)(v0 - 105) < 0) {
    JUMPOUT(0x1A61808E4);
  }
  JUMPOUT(0x1A6180870);
}

void sub_1A6180900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if ((a17 & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(a12);
  _Unwind_Resume(a1);
}

void abm::HelperClient::~HelperClient(abm::HelperClient *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

{
  std::__shared_weak_count *v1;

  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void abm::HelperClient::perform(uint64_t *a1, int a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  uint64_t v8 = *a1;
  xpc_object_t v9 = *a4;
  if (!*a4)
  {
    xpc_object_t v9 = xpc_null_create();
    uint64_t v10 = *(void **)a5;
    if (!*(void *)a5) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  xpc_retain(*a4);
  uint64_t v10 = *(void **)a5;
  if (*(void *)a5) {
LABEL_5:
  }
    uint64_t v10 = _Block_copy(v10);
LABEL_6:
  uint64_t v11 = *(NSObject **)(a5 + 8);
  aBlocuint64_t k = v10;
  xpc_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = MEMORY[0x1A6275E60](v9);
  uint64_t v13 = MEMORY[0x1E4F14590];
  if (v12 == MEMORY[0x1E4F14590])
  {
    xpc_object_t v15 = v9;
  }
  else
  {
    xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
    if (v14 || (xpc_object_t v14 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v14) == v13)
      {
        xpc_retain(v14);
        xpc_object_t v15 = v14;
      }
      else
      {
        xpc_object_t v15 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
    }
    xpc_release(v14);
    xpc_object_t v16 = xpc_null_create();
    xpc_release(v9);
    xpc_release(v16);
  }
  xpc_object_t v17 = xpc_int64_create(a2);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  xpc_dictionary_set_value(v15, "TaskID", v17);
  xpc_object_t v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 1174405120;
  v23[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke;
  void v23[3] = &__block_descriptor_tmp_20_5;
  v23[4] = v8;
  int v28 = a2;
  long long v19 = aBlock;
  if (aBlock) {
    long long v19 = _Block_copy(aBlock);
  }
  char v24 = v19;
  dispatch_object_t v25 = object;
  if (object) {
    dispatch_retain(object);
  }
  uint64_t v26 = a3;
  xpc_object_t v27 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  std::__wrap_iter<const char *> v29 = v23;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_16;
  void block[4] = v8 + 72;
  void block[5] = &v29;
  char v20 = *(NSObject **)(v8 + 88);
  if (*(void *)(v8 + 96)) {
    dispatch_async_and_wait(v20, block);
  }
  else {
    dispatch_sync(v20, block);
  }
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v25) {
    dispatch_release(v25);
  }
  if (v24) {
    _Block_release(v24);
  }
  if (object) {
    dispatch_release(object);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  xpc_release(v15);
}

void sub_1A6180D60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback((uint64_t)va);
  xpc_release(v2);
  _Unwind_Resume(a1);
}

void abm::HelperClient::perform(uint64_t *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, xpc_object_t *a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v10 = *a1;
  xpc_object_t v11 = *a4;
  if (*a4) {
    xpc_retain(*a4);
  }
  else {
    xpc_object_t v11 = xpc_null_create();
  }
  uint64_t v12 = MEMORY[0x1A6275E60](v11);
  uint64_t v13 = MEMORY[0x1E4F14590];
  if (v12 == MEMORY[0x1E4F14590])
  {
    xpc_object_t v15 = v11;
  }
  else
  {
    xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
    if (v14 || (xpc_object_t v14 = xpc_null_create()) != 0)
    {
      if (MEMORY[0x1A6275E60](v14) == v13)
      {
        xpc_retain(v14);
        xpc_object_t v15 = v14;
      }
      else
      {
        xpc_object_t v15 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
    }
    xpc_release(v14);
    xpc_object_t v16 = xpc_null_create();
    xpc_release(v11);
    xpc_release(v16);
  }
  xpc_object_t v17 = xpc_int64_create(a2);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  xpc_dictionary_set_value(v15, "TaskID", v17);
  xpc_object_t v18 = xpc_null_create();
  xpc_release(v17);
  xpc_release(v18);
  uint64_t v27 = 0;
  int v28 = &v27;
  uint64_t v29 = 0x4802000000;
  std::string::size_type v30 = __Block_byref_object_copy__3;
  std::string v31 = __Block_byref_object_dispose__3;
  unint64_t v32 = 0xAAAAAAAAE020E001;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  long long __p = 0;
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 1174405120;
  v23[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke;
  void v23[3] = &unk_1EFB0D920;
  int v26 = a2;
  v23[4] = &v27;
  void v23[5] = v10;
  v23[6] = a3;
  xpc_object_t object = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v25 = a5;
  char v36 = v23;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke;
  block[3] = &__block_descriptor_tmp_16;
  void block[4] = v10 + 72;
  void block[5] = &v36;
  long long v19 = *(NSObject **)(v10 + 88);
  if (*(void *)(v10 + 96))
  {
    dispatch_async_and_wait(v19, block);
    char v20 = v28;
    *a6 = *((_DWORD *)v28 + 10);
    std::string v21 = (std::string *)(a6 + 2);
    if ((*((char *)v20 + 71) & 0x80000000) == 0)
    {
LABEL_20:
      long long v22 = *((_OWORD *)v20 + 3);
      v21->__r_.__value_.__r.__words[2] = v20[8];
      *(_OWORD *)&v21->__r_.__value_.__l.__data_ = v22;
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_sync(v19, block);
    char v20 = v28;
    *a6 = *((_DWORD *)v28 + 10);
    std::string v21 = (std::string *)(a6 + 2);
    if ((*((char *)v20 + 71) & 0x80000000) == 0) {
      goto LABEL_20;
    }
  }
  std::string::__init_copy_ctor_external(v21, (const std::string::value_type *)v20[6], v20[7]);
LABEL_23:
  xpc_release(object);
  xpc_object_t object = 0;
  _Block_object_dispose(&v27, 8);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_1A6181080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  xpc_release(object);
  _Block_object_dispose(&a19, 8);
  if (a30 < 0) {
    operator delete(__p);
  }
  xpc_release(v30);
  _Unwind_Resume(a1);
}

void abm::HelperClient::registerForHelperReady(int a1@<W0>, uint64_t a2@<X1>, abm::helper::DaemonObserver **a3@<X8>)
{
  if (a1 != -1)
  {
    size_t v6 = (std::__shared_weak_count *)operator new(0x48uLL);
    v6->__shared_owners_ = 0;
    p_shared_owners = &v6->__shared_owners_;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D9B0;
    if (*(void *)a2)
    {
      uint64_t v8 = _Block_copy(*(const void **)a2);
      xpc_object_t v9 = (abm::helper::DaemonObserver *)&v6[1];
      uint64_t v10 = *(NSObject **)(a2 + 8);
      uint64_t v12 = v8;
      uint64_t v13 = v10;
      if (!v10) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v8 = 0;
      xpc_object_t v9 = (abm::helper::DaemonObserver *)&v6[1];
      uint64_t v10 = *(NSObject **)(a2 + 8);
      uint64_t v12 = 0;
      uint64_t v13 = v10;
      if (!v10)
      {
LABEL_5:
        abm::helper::DaemonObserver::DaemonObserver(v9, a1, (uint64_t)&v12);
        if (v10) {
          dispatch_release(v10);
        }
        if (v8) {
          _Block_release(v8);
        }
        shared_owners = (std::__shared_weak_count *)v6[1].__shared_owners_;
        if (shared_owners)
        {
          if (shared_owners->__shared_owners_ != -1) {
            goto LABEL_18;
          }
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1];
          v6[1].__shared_owners_ = (uint64_t)v6;
          std::__shared_weak_count::__release_weak(shared_owners);
          if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_18;
          }
        }
        else
        {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          v6[1].__vftable = (std::__shared_weak_count_vtbl *)&v6[1];
          v6[1].__shared_owners_ = (uint64_t)v6;
          if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
          {
LABEL_18:
            abm::helper::DaemonObserver::init(v9);
            goto LABEL_19;
          }
        }
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
        goto LABEL_18;
      }
    }
    dispatch_retain(v10);
    goto LABEL_5;
  }
  size_t v6 = 0;
  xpc_object_t v9 = 0;
LABEL_19:
  *a3 = v9;
  a3[1] = (abm::helper::DaemonObserver *)v6;
}

void sub_1A61812C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A61812D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  dispatch::callback<void({block_pointer})(TelephonyXPC::Result,xpc::dict)>::~callback((uint64_t)&a11);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v13);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A61812FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<abm::HelperClientInternal *,std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal *)#1},std::allocator<abm::HelperClientInternal>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_pt"
                     "rIT_EEPS7_EUlPS2_E_")
    return a1 + 24;
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__1"
                                "10shared_ptrIT_EEPS7_EUlPS2_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE15make_shared_ptrIS2_EENSt3__110shared_ptrIT_EEPS7_EUlPS2_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24; {
  return 0;
  }
}

uint64_t std::shared_ptr<abm::HelperClientInternal> ctu::SharedSynchronizable<abm::HelperClientInternal>::make_shared_ptr<abm::HelperClientInternal>(abm::HelperClientInternal*)::{lambda(abm::HelperClientInternal*)#1}::operator() const(abm::HelperClientInternal*)::{lambda(void *)#1}::__invoke(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0D820;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

{
  NSObject *v2;
  NSObject *v3;
  std::__shared_weak_count *v4;

  *a1 = &unk_1EFB0D820;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void abm::HelperClientInternal::~HelperClientInternal(abm::HelperClientInternal *this)
{
  abm::HelperClientInternal::~HelperClientInternal(this);

  operator delete(v1);
}

{
  std::__shared_weak_count *v2;
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;

  *(void *)this = &unk_1EFB0D710;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((*((char *)this + 127) & 0x80000000) == 0)
    {
LABEL_4:
      *(void *)this = &unk_1EFB0D820;
      MEMORY[0x1A6274710]((char *)this + 8);
      unint64_t v3 = *((void *)this + 12);
      if (!v3) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }
  else if ((*((char *)this + 127) & 0x80000000) == 0)
  {
    goto LABEL_4;
  }
  operator delete(*((void **)this + 13));
  *(void *)this = &unk_1EFB0D820;
  MEMORY[0x1A6274710]((char *)this + 8);
  unint64_t v3 = *((void *)this + 12);
  if (v3) {
LABEL_5:
  }
    dispatch_release(v3);
LABEL_6:
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    dispatch_release(v4);
  }
  std::string::size_type v5 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::updateTrackedConfig(uint64_t a1)
{
  return MEMORY[0x1F417DA50](a1 + 8);
}

void ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLoggerName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 127) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 104), *(void *)(a1 + 112));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 104);
    a2->__r_.__value_.__r.__words[2] = *(void *)(a1 + 120);
  }
}

uint64_t ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::getTrackedLogLevel(uint64_t a1)
{
  return MEMORY[0x1F417DD10](a1 + 8);
}

void ctu::SharedLoggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~SharedLoggable(void *a1)
{
  *a1 = &unk_1EFB0D820;
  MEMORY[0x1A6274710](a1 + 1);
  uint64_t v2 = a1[12];
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = a1[11];
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[10];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete(a1);
}

void *ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0D820;
  MEMORY[0x1A6274710](a1 + 1);
  return a1;
}

void ctu::Loggable<abm::HelperClientInternal,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::~Loggable(void *a1)
{
  *a1 = &unk_1EFB0D820;
  MEMORY[0x1A6274710](a1 + 1);

  operator delete(a1);
}

void ___ZN3abm20HelperClientInternal4initEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_debug_impl(&dword_1A609F000, v1, OS_LOG_TYPE_DEBUG, "#D Init", v2, 2u);
  }
}

void *___ZNK3ctu20SharedSynchronizableIN3abm20HelperClientInternalEE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS8__block_invoke(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a1 + 72) - 1;
  if v3 < 0xA && ((0x3FDu >> v3))
  {
    int v8 = dword_1A61FA7D8[v3];
    xpc_object_t xdict = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    abm::helper::getUserConfig(v8, &xdict);
    xpc_object_t v9 = (const char *)(v2 + 104);
    if (*(char *)(v2 + 127) < 0) {
      xpc_object_t v9 = *(const char **)v9;
    }
    xpc_object_t v10 = xpc_string_create(v9);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    xpc_dictionary_set_value(xdict, (const char *)*MEMORY[0x1E4FAE020], v10);
    xpc_object_t v11 = xpc_null_create();
    xpc_release(v10);
    xpc_release(v11);
    uint64_t v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      xpc::object::to_string((uint64_t *)block, (xpc::object *)&xdict);
      std::string v42 = block[23] >= 0 ? block : *(unsigned char **)block;
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v42;
      _os_log_debug_impl(&dword_1A609F000, v12, OS_LOG_TYPE_DEBUG, "#D %s", buf, 0xCu);
      if ((block[23] & 0x80000000) != 0) {
        operator delete(*(void **)block);
      }
    }
    memset(buf, 170, sizeof(buf));
    xpc_object_t object = xdict;
    if (xdict)
    {
      xpc_retain(xdict);
      uint64_t v13 = *(std::__shared_weak_count **)(v2 + 136);
      uint64_t v62 = *(void *)(v2 + 128);
      uint64_t v63 = v13;
      if (!v13)
      {
LABEL_16:
        TelephonyXPC::Client::create();
        if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
          std::__shared_weak_count::__release_weak(v63);
        }
        xpc_release(object);
        xpc_object_t object = 0;
        if (*(void *)buf)
        {
          uint64_t v15 = *(void *)(v2 + 72);
          xpc_object_t v14 = *(std::__shared_weak_count **)(v2 + 80);
          uint64_t v60 = v15;
          if (!v14 || (xpc_object_t v16 = std::__shared_weak_count::lock(v14), (v61 = v16) == 0)) {
            std::__throw_bad_weak_ptr[abi:ne180100]();
          }
          char v58 = (void *)0xAAAAAAAAAAAAAAAALL;
          dispatch_object_t v59 = (dispatch_object_t)0xAAAAAAAAAAAAAAAALL;
          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 1174405120;
          aBlock[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke_17;
          aBlock[3] = &__block_descriptor_tmp_19_1;
          aBlock[4] = v15;
          unsigned int v53 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v54 = *(void *)buf;
          char v55 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
          }
          xpc_object_t v17 = *(void **)(a1 + 40);
          if (v17) {
            xpc_object_t v17 = _Block_copy(v17);
          }
          xpc_object_t v18 = *(NSObject **)(a1 + 48);
          unsigned int v56 = v17;
          dispatch_object_t v57 = v18;
          if (v18) {
            dispatch_retain(v18);
          }
          long long v19 = _Block_copy(aBlock);
          global_queue = dispatch_get_global_queue(0, 0);
          std::string v21 = global_queue;
          if (global_queue) {
            dispatch_retain(global_queue);
          }
          char v58 = v19;
          dispatch_object_t v59 = v21;
          long long v22 = *(const char **)(a1 + 56);
          size_t v23 = strlen(v22);
          if (v23 >= 0x7FFFFFFFFFFFFFF8) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          size_t v24 = v23;
          if (v23 >= 0x17)
          {
            uint64_t v37 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v23 | 7) != 0x17) {
              uint64_t v37 = v23 | 7;
            }
            uint64_t v38 = v37 + 1;
            uint64_t v25 = operator new(v37 + 1);
            *(void *)&block[8] = v24;
            *(void *)&block[16] = v38 | 0x8000000000000000;
            *(void *)blocuint64_t k = v25;
          }
          else
          {
            block[23] = v23;
            uint64_t v25 = block;
            if (!v23)
            {
              block[0] = 0;
              int v26 = v58;
              if (v58) {
                goto LABEL_34;
              }
              goto LABEL_64;
            }
          }
          memmove(v25, v22, v24);
          v25[v24] = 0;
          int v26 = v58;
          if (v58)
          {
LABEL_34:
            uint64_t v27 = _Block_copy(v26);
            int v28 = v59;
            uint64_t v50 = v27;
            std::string::size_type v51 = v59;
            if (!v59)
            {
LABEL_36:
              uint64_t v29 = *(void **)(a1 + 64);
              xpc_object_t v49 = v29;
              if (v29) {
                xpc_retain(v29);
              }
              else {
                xpc_object_t v49 = xpc_null_create();
              }
              TelephonyXPC::Client::perform();
              xpc_release(v49);
              if (v51) {
                dispatch_release(v51);
              }
              if (v50) {
                _Block_release(v50);
              }
              if ((block[23] & 0x80000000) != 0) {
                operator delete(*(void **)block);
              }
              if (v28) {
                dispatch_release(v28);
              }
              if (v26) {
                _Block_release(v26);
              }
              if (v57) {
                dispatch_release(v57);
              }
              if (v56) {
                _Block_release(v56);
              }
              uint64_t v39 = v55;
              if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                std::__shared_weak_count::__release_weak(v39);
              }
              uint64_t v40 = v53;
              if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
                std::__shared_weak_count::__release_weak(v40);
              }
              std::string v41 = v61;
              if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                std::__shared_weak_count::__release_weak(v41);
              }
              goto LABEL_111;
            }
LABEL_35:
            dispatch_retain(v28);
            goto LABEL_36;
          }
LABEL_64:
          int v28 = v59;
          uint64_t v50 = 0;
          std::string::size_type v51 = v59;
          if (!v59) {
            goto LABEL_36;
          }
          goto LABEL_35;
        }
        uint64_t v33 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          unsigned int v46 = *(_DWORD *)(a1 + 72) - 1;
          if (v46 > 9) {
            std::string v47 = "invalid";
          }
          else {
            std::string v47 = off_1E5C47F48[v46];
          }
          uint64_t v48 = *(void *)(a1 + 56);
          *(_DWORD *)blocuint64_t k = 136315394;
          *(void *)&void block[4] = v47;
          *(_WORD *)&block[12] = 2080;
          *(void *)&block[14] = v48;
          _os_log_error_impl(&dword_1A609F000, v33, OS_LOG_TYPE_ERROR, "Unable to perform command: %s, %s", block, 0x16u);
          if (*(void *)(a1 + 40))
          {
LABEL_57:
            if (*(void *)(a1 + 48))
            {
              xpc_object_t v34 = xpc_null_create();
              uint64_t v35 = *(const void **)(a1 + 40);
              if (v35) {
                char v36 = _Block_copy(v35);
              }
              else {
                char v36 = 0;
              }
              uint64_t v43 = *(NSObject **)(a1 + 48);
              *(void *)blocuint64_t k = MEMORY[0x1E4F143A8];
              *(void *)&block[8] = 1174405120;
              *(void *)&block[16] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
              long long v68 = &__block_descriptor_tmp_21_2;
              if (v36) {
                uint64_t v44 = _Block_copy(v36);
              }
              else {
                uint64_t v44 = 0;
              }
              long long v69 = v44;
              int v70 = -534716415;
              long long v71 = 0;
              uint64_t v72 = 0;
              uint64_t v73 = 0;
              xpc_object_t v74 = v34;
              if (v34) {
                xpc_retain(v34);
              }
              else {
                xpc_object_t v74 = xpc_null_create();
              }
              dispatch_async(v43, block);
              xpc_release(v74);
              xpc_object_t v74 = 0;
              if (SHIBYTE(v73) < 0) {
                operator delete(v71);
              }
              if (v69) {
                _Block_release(v69);
              }
              if (v36) {
                _Block_release(v36);
              }
              xpc_release(v34);
            }
          }
        }
        else if (*(void *)(a1 + 40))
        {
          goto LABEL_57;
        }
LABEL_111:
        uint64_t v45 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
        xpc_release(xdict);
        return;
      }
    }
    else
    {
      xpc_object_t object = xpc_null_create();
      uint64_t v13 = *(std::__shared_weak_count **)(v2 + 136);
      uint64_t v62 = *(void *)(v2 + 128);
      uint64_t v63 = v13;
      if (!v13) {
        goto LABEL_16;
      }
    }
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_16;
  }
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)blocuint64_t k = 0;
    _os_log_error_impl(&dword_1A609F000, v4, OS_LOG_TYPE_ERROR, "Task not available!", block, 2u);
    if (!*(void *)(a1 + 40)) {
      return;
    }
  }
  else if (!*(void *)(a1 + 40))
  {
    return;
  }
  if (*(void *)(a1 + 48))
  {
    xpc_object_t v5 = xpc_null_create();
    size_t v6 = *(const void **)(a1 + 40);
    if (v6) {
      std::string::size_type v7 = _Block_copy(v6);
    }
    else {
      std::string::size_type v7 = 0;
    }
    std::string::size_type v30 = *(NSObject **)(a1 + 48);
    *(void *)blocuint64_t k = MEMORY[0x1E4F143A8];
    *(void *)&block[8] = 1174405120;
    *(void *)&block[16] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
    long long v68 = &__block_descriptor_tmp_21_2;
    if (v7) {
      std::string v31 = _Block_copy(v7);
    }
    else {
      std::string v31 = 0;
    }
    long long v69 = v31;
    int v70 = -534716415;
    long long v71 = 0;
    uint64_t v72 = 0;
    uint64_t v73 = 0;
    xpc_object_t v74 = v5;
    if (v5) {
      xpc_retain(v5);
    }
    else {
      xpc_object_t v74 = xpc_null_create();
    }
    dispatch_async(v30, block);
    xpc_release(v74);
    xpc_object_t v74 = 0;
    if (SHIBYTE(v73) < 0)
    {
      operator delete(v71);
      unint64_t v32 = v69;
      if (!v69)
      {
LABEL_50:
        if (v7) {
          _Block_release(v7);
        }
        xpc_release(v5);
        return;
      }
    }
    else
    {
      unint64_t v32 = v69;
      if (!v69) {
        goto LABEL_50;
      }
    }
    _Block_release(v32);
    goto LABEL_50;
  }
}

void sub_1A6182068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,char a27,uint64_t a28,xpc_object_t a29,xpc_object_t a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictEN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultES6_EEE_block_invoke_17(uint64_t a1, int *a2, xpc_object_t *a3)
{
  if (!*(void *)(a1 + 64) || !*(void *)(a1 + 72)) {
    return;
  }
  int v10 = *a2;
  if ((*((char *)a2 + 31) & 0x80000000) == 0)
  {
    std::string v11 = *(std::string *)(a2 + 2);
    xpc_object_t v5 = *a3;
    if (*a3) {
      goto LABEL_5;
    }
LABEL_8:
    xpc_object_t v5 = xpc_null_create();
    size_t v6 = *(const void **)(a1 + 64);
    if (v6) {
      goto LABEL_6;
    }
    goto LABEL_9;
  }
  std::string::__init_copy_ctor_external(&v11, *((const std::string::value_type **)a2 + 1), *((void *)a2 + 2));
  xpc_object_t v5 = *a3;
  if (!v5) {
    goto LABEL_8;
  }
LABEL_5:
  xpc_retain(v5);
  size_t v6 = *(const void **)(a1 + 64);
  if (v6)
  {
LABEL_6:
    std::string::size_type v7 = _Block_copy(v6);
    goto LABEL_10;
  }
LABEL_9:
  std::string::size_type v7 = 0;
LABEL_10:
  int v8 = *(NSObject **)(a1 + 72);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 1174405120;
  block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0;
  block[3] = &__block_descriptor_tmp_21_2;
  if (v7)
  {
    aBlocuint64_t k = _Block_copy(v7);
    int v14 = v10;
    if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_12:
      std::string __p = v11;
      goto LABEL_15;
    }
  }
  else
  {
    aBlocuint64_t k = 0;
    int v14 = v10;
    if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_12;
    }
  }
  std::string::__init_copy_ctor_external(&__p, v11.__r_.__value_.__l.__data_, v11.__r_.__value_.__l.__size_);
LABEL_15:
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  dispatch_async(v8, block);
  xpc_release(object);
  xpc_object_t object = 0;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    xpc_object_t v9 = aBlock;
    if (!aBlock) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  xpc_object_t v9 = aBlock;
  if (aBlock) {
LABEL_22:
  }
    _Block_release(v9);
LABEL_23:
  if (v7) {
    _Block_release(v7);
  }
  xpc_release(v5);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1A61823B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v21) {
    _Block_release(v21);
  }
  xpc_release(v20);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_32c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE48c49_ZTSNSt3__110shared_ptrIN12TelephonyXPC6ClientEEE64c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[7];
  a1[6] = a2[6];
  a1[7] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  size_t v6 = (void *)a2[8];
  if (v6) {
    size_t v6 = _Block_copy(v6);
  }
  std::string::size_type v7 = a2[9];
  a1[8] = v6;
  a1[9] = v7;
  if (v7)
  {
    dispatch_retain(v7);
  }
}

void __destroy_helper_block_e8_32c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE48c49_ZTSNSt3__110shared_ptrIN12TelephonyXPC6ClientEEE64c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE(void *a1)
{
  uint64_t v2 = a1[9];
  if (v2) {
    dispatch_release(v2);
  }
  int v3 = (const void *)a1[8];
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (std::__shared_weak_count *)a1[5];
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)a1[5];
    if (!v5) {
      return;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

xpc_object_t __copy_helper_block_e8_40c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE64c15_ZTSN3xpc4dictE(void *a1, void *a2)
{
  uint64_t v4 = (void *)a2[5];
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  uint64_t v5 = a2[6];
  a1[5] = v4;
  a1[6] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  size_t v6 = (void *)a2[8];
  a1[8] = v6;
  if (v6) {
    return xpc_retain(v6);
  }
  xpc_object_t result = xpc_null_create();
  a1[8] = result;
  return result;
}

void __destroy_helper_block_e8_40c79_ZTSN8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEE64c15_ZTSN3xpc4dictE(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 64));
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (v2) {
    dispatch_release(v2);
  }
  int v3 = *(const void **)(a1 + 40);
  if (v3) {
    _Block_release(v3);
  }
}

void ___ZNK8dispatch8callbackIU13block_pointerFvN12TelephonyXPC6ResultEN3xpc4dictEEEclIJS2_S4_EEEvDpT__block_invoke_0(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__3(__n128 *a1, __n128 *a2)
{
  a1[2].n128_u32[2] = a2[2].n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  unsigned int v2 = *(_DWORD *)(a1 + 72) - 1;
  if (v2 >= 0xA || ((0x3FDu >> v2) & 1) == 0)
  {
    int v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl(&dword_1A609F000, v3, OS_LOG_TYPE_ERROR, "Task not available!", buf, 2u);
    }
    return;
  }
  int v5 = dword_1A61FA7D8[v2];
  *(void *)std::string buf = 0;
  uint64_t v64 = buf;
  uint64_t v65 = 0x3002000000;
  long long v66 = __Block_byref_object_copy__22;
  unsigned __int8 v67 = __Block_byref_object_dispose__23;
  xpc_object_t v68 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  xpc_object_t v68 = xpc_null_create();
  xpc_object_t v62 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
  abm::helper::getUserConfig(v5, &v62);
  size_t v6 = (const char *)(v1 + 104);
  if (*(char *)(v1 + 127) < 0) {
    size_t v6 = *(const char **)v6;
  }
  xpc_object_t v7 = xpc_string_create(v6);
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_dictionary_set_value(v62, (const char *)*MEMORY[0x1E4FAE020], v7);
  xpc_object_t v8 = xpc_null_create();
  xpc_release(v7);
  xpc_release(v8);
  xpc_object_t v9 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v35 = (char *)MEMORY[0x1A6275DF0](v62);
    memset(__dst, 170, sizeof(__dst));
    size_t v36 = strlen(v35);
    if (v36 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    uint64_t v37 = (void *)v36;
    if (v36 >= 0x17)
    {
      uint64_t v45 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v36 | 7) != 0x17) {
        uint64_t v45 = v36 | 7;
      }
      uint64_t v46 = v45 + 1;
      uint64_t v38 = (xpc_object_t *)operator new(v45 + 1);
      __dst[1] = v37;
      _OWORD __dst[2] = (xpc_object_t)(v46 | 0x8000000000000000);
      __dst[0] = v38;
    }
    else
    {
      HIBYTE(__dst[2]) = v36;
      uint64_t v38 = __dst;
      if (!v36) {
        goto LABEL_94;
      }
    }
    memcpy(v38, v35, (size_t)v37);
LABEL_94:
    *((unsigned char *)v37 + (void)v38) = 0;
    free(v35);
    std::string v47 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      std::string v47 = (xpc_object_t *)__dst[0];
    }
    *(_DWORD *)long long v69 = 136315138;
    *(void *)&v69[4] = v47;
    _os_log_debug_impl(&dword_1A609F000, v9, OS_LOG_TYPE_DEBUG, "#D %s", v69, 0xCu);
    if (SHIBYTE(__dst[2]) < 0) {
      operator delete(__dst[0]);
    }
  }
  memset(v69, 170, 16);
  xpc_object_t object = v62;
  if (!v62)
  {
    xpc_object_t object = xpc_null_create();
    int v10 = *(std::__shared_weak_count **)(v1 + 136);
    uint64_t v58 = *(void *)(v1 + 128);
    dispatch_object_t v59 = v10;
    if (!v10) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  xpc_retain(v62);
  int v10 = *(std::__shared_weak_count **)(v1 + 136);
  uint64_t v58 = *(void *)(v1 + 128);
  dispatch_object_t v59 = v10;
  if (v10) {
LABEL_12:
  }
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_13:
  TelephonyXPC::Client::create();
  if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
    std::__shared_weak_count::__release_weak(v59);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  if (!*(void *)v69)
  {
    uint64_t v27 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__dst[0]) = 0;
      _os_log_error_impl(&dword_1A609F000, v27, OS_LOG_TYPE_ERROR, "Task not available!", (uint8_t *)__dst, 2u);
    }
    uint64_t v12 = 0;
    goto LABEL_83;
  }
  std::string v11 = dispatch_group_create();
  uint64_t v12 = v11;
  if (v11)
  {
    dispatch_retain(v11);
    dispatch_group_enter(v12);
  }
  uint64_t v14 = *(void *)(v1 + 72);
  uint64_t v13 = *(std::__shared_weak_count **)(v1 + 80);
  uint64_t v56 = v14;
  if (!v13 || (uint64_t v15 = std::__shared_weak_count::lock(v13), (v57 = v15) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v54 = (void *)0xAAAAAAAAAAAAAAAALL;
  dispatch_object_t v55 = (dispatch_object_t)0xAAAAAAAAAAAAAAAALL;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1174405120;
  aBlock[2] = ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke_24;
  aBlock[3] = &unk_1EFB0D8E8;
  void aBlock[6] = v14;
  unint64_t v52 = v15;
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_group_t group = v12;
  if (v12)
  {
    dispatch_retain(v12);
    dispatch_group_enter(group);
  }
  aBlock[4] = *(void *)(a1 + 32);
  void aBlock[5] = buf;
  xpc_object_t v16 = _Block_copy(aBlock);
  global_queue = dispatch_get_global_queue(0, 0);
  xpc_object_t v18 = global_queue;
  if (global_queue) {
    dispatch_retain(global_queue);
  }
  uint64_t v54 = v16;
  dispatch_object_t v55 = v18;
  long long v19 = *(const char **)(a1 + 48);
  size_t v20 = strlen(v19);
  if (v20 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string v21 = (void *)v20;
  if (v20 >= 0x17)
  {
    uint64_t v28 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v20 | 7) != 0x17) {
      uint64_t v28 = v20 | 7;
    }
    uint64_t v29 = v28 + 1;
    long long v22 = (xpc_object_t *)operator new(v28 + 1);
    __dst[1] = v21;
    _OWORD __dst[2] = (xpc_object_t)(v29 | 0x8000000000000000);
    __dst[0] = v22;
  }
  else
  {
    HIBYTE(__dst[2]) = v20;
    long long v22 = __dst;
    if (!v20)
    {
      LOBYTE(__dst[0]) = 0;
      size_t v23 = v54;
      if (v54) {
        goto LABEL_29;
      }
      goto LABEL_42;
    }
  }
  memmove(v22, v19, (size_t)v21);
  *((unsigned char *)v21 + (void)v22) = 0;
  size_t v23 = v54;
  if (v54)
  {
LABEL_29:
    size_t v24 = _Block_copy(v23);
    uint64_t v25 = v55;
    xpc_object_t v49 = v24;
    uint64_t v50 = v55;
    if (!v55) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
LABEL_42:
  uint64_t v25 = v55;
  xpc_object_t v49 = 0;
  uint64_t v50 = v55;
  if (v55) {
LABEL_30:
  }
    dispatch_retain(v25);
LABEL_31:
  int v26 = *(void **)(a1 + 56);
  xpc_object_t v48 = v26;
  if (v26) {
    xpc_retain(v26);
  }
  else {
    xpc_object_t v48 = xpc_null_create();
  }
  TelephonyXPC::Client::perform();
  xpc_release(v48);
  if (v50) {
    dispatch_release(v50);
  }
  if (v49) {
    _Block_release(v49);
  }
  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  if (v25) {
    dispatch_release(v25);
  }
  if (v23) {
    _Block_release(v23);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  std::string::size_type v30 = v52;
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  std::string v31 = v57;
  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  if (!v12) {
    goto LABEL_83;
  }
  dispatch_group_leave(v12);
  dispatch_release(v12);
  if (MEMORY[0x1A6275E60](*(void *)(a1 + 56)) == MEMORY[0x1E4F14590])
  {
    xpc_object_t value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 56), "Timeout");
    __dst[0] = value;
    if (value) {
      xpc_retain(value);
    }
    else {
      __dst[0] = xpc_null_create();
    }
    unsigned int v39 = xpc::dyn_cast_or_default();
    xpc_release(__dst[0]);
    if (v39)
    {
      dispatch_time_t v40 = dispatch_time(0, 1000000 * v39);
      if (!dispatch_group_wait(v12, v40)) {
        goto LABEL_79;
      }
LABEL_67:
      unint64_t v32 = (char *)operator new(0x30uLL);
      strcpy(v32, "Timeout waiting for response from helper server");
      uint64_t v33 = *(void *)(*(void *)(a1 + 32) + 8);
      *(_DWORD *)(v33 + 40) = -534716413;
      if (*(char *)(v33 + 71) < 0) {
        operator delete(*(void **)(v33 + 48));
      }
      *(void *)(v33 + 48) = v32;
      *(void *)(v33 + 56) = 47;
      *(void *)(v33 + 64) = 0x8000000000000030;
      goto LABEL_83;
    }
  }
  if (dispatch_group_wait(v12, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_67;
  }
LABEL_79:
  std::string v41 = *(void ***)(a1 + 64);
  xpc_object_t v42 = (xpc_object_t)*((void *)v64 + 5);
  if (v42) {
    xpc_retain(*((xpc_object_t *)v64 + 5));
  }
  else {
    xpc_object_t v42 = xpc_null_create();
  }
  uint64_t v43 = *v41;
  *std::string v41 = v42;
  xpc_release(v43);
LABEL_83:
  uint64_t v44 = *(std::__shared_weak_count **)&v69[8];
  if (*(void *)&v69[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v69[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  xpc_release(v62);
  if (v12) {
    dispatch_release(v12);
  }
  _Block_object_dispose(buf, 8);
  xpc_release(v68);
}

void sub_1A6182EC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,dispatch_group_t group,char a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,xpc_object_t a28,xpc_object_t object,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

xpc_object_t __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  xpc_object_t result = xpc_null_create();
  *(void *)(a2 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
  *(void *)(a1 + 40) = 0;
}

void ___ZN3abm20HelperClientInternal7performENS_6helper6TaskIDEPKcN3xpc4dictERS6__block_invoke_24(void *a1, uint64_t a2, xpc_object_t *a3)
{
  if (a1[6])
  {
    uint64_t v5 = *(void *)(a1[4] + 8);
    *(_DWORD *)(v5 + 40) = *(_DWORD *)a2;
    if (v5 + 40 != a2)
    {
      size_t v6 = (void **)(v5 + 48);
      int v7 = *(char *)(v5 + 71);
      size_t v8 = *(unsigned __int8 *)(a2 + 31);
      if ((v7 & 0x80000000) == 0)
      {
        if ((v8 & 0x80) == 0)
        {
          long long v9 = *(_OWORD *)(a2 + 8);
          v6[2] = *(void **)(a2 + 24);
          *(_OWORD *)size_t v6 = v9;
          uint64_t v10 = *(void *)(a1[5] + 8);
          xpc_object_t v11 = *a3;
          if (!*a3) {
            goto LABEL_17;
          }
LABEL_15:
          xpc_retain(v11);
LABEL_18:
          uint64_t v15 = *(void **)(v10 + 40);
          *(void *)(v10 + 40) = v11;
          xpc_release(v15);
          return;
        }
        std::string::__assign_no_alias<true>(v6, *(void **)(a2 + 8), *(void *)(a2 + 16));
        uint64_t v10 = *(void *)(a1[5] + 8);
        xpc_object_t v11 = *a3;
        if (v11) {
          goto LABEL_15;
        }
LABEL_17:
        xpc_object_t v11 = xpc_null_create();
        goto LABEL_18;
      }
      size_t v12 = *(void *)(a2 + 16);
      if ((v8 & 0x80u) == 0) {
        uint64_t v13 = (void *)(a2 + 8);
      }
      else {
        uint64_t v13 = *(void **)(a2 + 8);
      }
      if ((v8 & 0x80u) == 0) {
        size_t v14 = v8;
      }
      else {
        size_t v14 = v12;
      }
      std::string::__assign_no_alias<false>(v6, v13, v14);
    }
    uint64_t v10 = *(void *)(a1[5] + 8);
    xpc_object_t v11 = *a3;
    if (v11) {
      goto LABEL_15;
    }
    goto LABEL_17;
  }
}

void __copy_helper_block_e8_48c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE64c30_ZTSN8dispatch13group_sessionE(void *a1, void *a2)
{
  uint64_t v3 = a2[7];
  a1[6] = a2[6];
  a1[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[8];
  a1[8] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[8];
    if (v5)
    {
      dispatch_group_enter(v5);
    }
  }
}

void __destroy_helper_block_e8_48c54_ZTSNSt3__110shared_ptrIN3abm20HelperClientInternalEEE64c30_ZTSN8dispatch13group_sessionE(uint64_t a1)
{
  unsigned int v2 = *(NSObject **)(a1 + 64);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 64);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

xpc_object_t __copy_helper_block_e8_56c15_ZTSN3xpc4dictE(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 56);
  *(void *)(a1 + 56) = v3;
  if (v3) {
    return xpc_retain(v3);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 56) = result;
  return result;
}

void __destroy_helper_block_e8_56c15_ZTSN3xpc4dictE(uint64_t a1)
{
  *(void *)(a1 + 56) = 0;
}

void std::__shared_ptr_emplace<abm::HelperClientWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D960;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::HelperClientWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D960;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<abm::HelperClientWrapper>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::__shared_ptr_emplace<abm::helper::DaemonObserver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D9B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<abm::helper::DaemonObserver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0D9B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<abm::helper::DaemonObserver>::__on_zero_shared(uint64_t a1)
{
}

uint64_t diag::DIAGReader::Parameters::Parameters(uint64_t a1, int a2, void *a3, void *a4, void *a5, int a6, char *__s, int a8, int a9)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = *a3;
  *(_DWORD *)(a1 + 16) = a2;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 32) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 40) = *a4;
  uint64_t v14 = a4[1];
  *(void *)(a1 + 48) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = *a5;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 64) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  xpc_object_t v16 = (char *)(a1 + 96);
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 200) = 0x100000;
  uint64_t v17 = *(void *)(a1 + 40);
  xpc_object_t v18 = (capabilities::trace *)(a1 + 120);
  if (a1 + 120 == v17 + 56)
  {
LABEL_11:
    if (a6) {
      goto LABEL_12;
    }
    goto LABEL_37;
  }
  size_t v20 = *(unsigned char **)(v17 + 56);
  long long v19 = *(unsigned char **)(v17 + 64);
  size_t v21 = v19 - v20;
  if (v19 != v20)
  {
    if ((v21 & 0x8000000000000000) != 0) {
      std::vector<std::sub_match<char const*>>::__throw_length_error[abi:ne180100]();
    }
    long long v22 = (char *)operator new(v19 - v20);
    *(void *)(a1 + 120) = v22;
    *(void *)(a1 + 128) = v22;
    size_t v23 = &v22[v21];
    *(void *)(a1 + 136) = &v22[v21];
    xpc_object_t v18 = (capabilities::trace *)memcpy(v22, v20, v21);
    *(void *)(a1 + 128) = v23;
    goto LABEL_11;
  }
  *(void *)(a1 + 128) = v21;
  if (a6)
  {
LABEL_12:
    *(_DWORD *)(a1 + 192) = a6;
    if (a8) {
      goto LABEL_13;
    }
    goto LABEL_38;
  }
LABEL_37:
  xpc_object_t v18 = (capabilities::trace *)capabilities::trace::defaultHistorySizeMB(v18);
  *(_DWORD *)(a1 + 192) = v18;
  if (a8)
  {
LABEL_13:
    int v24 = a9;
    *(_DWORD *)(a1 + 196) = a8;
    int v25 = *(_DWORD *)(a1 + 16);
    if (v25 != 15) {
      goto LABEL_14;
    }
LABEL_39:
    *(_WORD *)(a1 + 88) = 1;
    if (*(char *)(a1 + 119) < 0)
    {
      *(void *)(a1 + 104) = 12;
      xpc_object_t v16 = *(char **)(a1 + 96);
    }
    else
    {
      *(unsigned char *)(a1 + 119) = 12;
    }
    strcpy(v16, "header.qmdl2");
    if (__s)
    {
      size_t v48 = strlen(__s);
      if (v48 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      xpc_object_t v49 = (void *)v48;
      if (v48 >= 0x17)
      {
        uint64_t v83 = (v48 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v48 | 7) != 0x17) {
          uint64_t v83 = v48 | 7;
        }
        uint64_t v84 = v83 + 1;
        uint64_t v50 = operator new(v83 + 1);
        v103[1] = v49;
        unint64_t v104 = v84 | 0x8000000000000000;
        v103[0] = v50;
      }
      else
      {
        HIBYTE(v104) = v48;
        uint64_t v50 = v103;
        if (!v48)
        {
          LOBYTE(v103[0]) = 0;
          uint64_t v51 = a1 + 168;
          if ((*(char *)(a1 + 191) & 0x80000000) == 0) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }
      }
      memcpy(v50, __s, (size_t)v49);
      *((unsigned char *)v49 + (void)v50) = 0;
      uint64_t v51 = a1 + 168;
      if (*(char *)(a1 + 191) < 0) {
LABEL_70:
      }
        operator delete(*(void **)v51);
LABEL_71:
      *(_OWORD *)uint64_t v51 = *(_OWORD *)v103;
      *(void *)(v51 + 16) = v104;
      if (!__s)
      {
        if (v101 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v102.__r_.__value_.__l.__data_);
        }
      }
      if (*(char *)(a1 + 167) < 0)
      {
        *(void *)(a1 + 152) = 4;
        unint64_t v52 = *(char **)(a1 + 144);
      }
      else
      {
        unint64_t v52 = (char *)(a1 + 144);
        *(unsigned char *)(a1 + 167) = 4;
      }
      strcpy(v52, ".bin");
      *(_DWORD *)(a1 + 200) = v24;
      long long v69 = abm::trace::kScratchFolder[0];
      size_t v70 = strlen(abm::trace::kScratchFolder[0]);
      if (v70 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v71 = v70;
      if (v70 >= 0x17)
      {
        uint64_t v73 = (v70 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v70 | 7) != 0x17) {
          uint64_t v73 = v70 | 7;
        }
        uint64_t v74 = v73 + 1;
        p_dst = (std::string *)operator new(v73 + 1);
        __dst.__r_.__value_.__l.__size_ = v71;
        __dst.__r_.__value_.__r.__words[2] = v74 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v70;
        p_dst = &__dst;
        if (!v70) {
          goto LABEL_106;
        }
      }
      memmove(p_dst, v69, v71);
LABEL_106:
      p_dst->__r_.__value_.__s.__data_[v71] = 0;
      uint64_t v75 = std::string::append(&__dst, "QDSS.scratch", 0xCuLL);
      long long v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
      unint64_t v104 = v75->__r_.__value_.__r.__words[2];
      *(_OWORD *)xpc_object_t v103 = v76;
      v75->__r_.__value_.__l.__size_ = 0;
      v75->__r_.__value_.__r.__words[2] = 0;
      v75->__r_.__value_.__r.__words[0] = 0;
      abm::trace::TraceInfo::create();
      goto LABEL_107;
    }
    unsigned int v53 = abm::trace::kScratchFolder[0];
    size_t v54 = strlen(abm::trace::kScratchFolder[0]);
    if (v54 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v55 = v54;
    if (v54 >= 0x17)
    {
      uint64_t v91 = (v54 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v54 | 7) != 0x17) {
        uint64_t v91 = v54 | 7;
      }
      uint64_t v92 = v91 + 1;
      uint64_t v56 = operator new(v91 + 1);
      v102.__r_.__value_.__l.__size_ = v55;
      v102.__r_.__value_.__r.__words[2] = v92 | 0x8000000000000000;
      v102.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
    }
    else
    {
      *((unsigned char *)&v102.__r_.__value_.__s + 23) = v54;
      uint64_t v56 = &v102;
      if (!v54)
      {
LABEL_144:
        v56[v55] = 0;
        char v101 = 12;
        strcpy((char *)__p, "QDSS.scratch");
        std::string v93 = std::string::append(&v102, (const std::string::value_type *)__p, 0xCuLL);
        long long v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
        unint64_t v104 = v93->__r_.__value_.__r.__words[2];
        *(_OWORD *)xpc_object_t v103 = v94;
        v93->__r_.__value_.__l.__size_ = 0;
        v93->__r_.__value_.__r.__words[2] = 0;
        v93->__r_.__value_.__r.__words[0] = 0;
        uint64_t v51 = a1 + 168;
        if (*(char *)(a1 + 191) < 0) {
          goto LABEL_70;
        }
        goto LABEL_71;
      }
    }
    memmove(v56, v53, v55);
    goto LABEL_144;
  }
LABEL_38:
  int v24 = a9;
  *(_DWORD *)(a1 + 196) = capabilities::trace::defaultMemoryFileMaxCount(v18);
  int v25 = *(_DWORD *)(a1 + 16);
  if (v25 == 15) {
    goto LABEL_39;
  }
LABEL_14:
  if (v25 == 11)
  {
    *(_WORD *)(a1 + 88) = 1;
    if (*(char *)(a1 + 119) < 0)
    {
      *(void *)(a1 + 104) = 12;
      xpc_object_t v16 = *(char **)(a1 + 96);
    }
    else
    {
      *(unsigned char *)(a1 + 119) = 12;
    }
    strcpy(v16, "header.qmdl2");
    if (__s)
    {
      size_t v39 = strlen(__s);
      if (v39 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      dispatch_time_t v40 = (void *)v39;
      if (v39 >= 0x17)
      {
        uint64_t v81 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v39 | 7) != 0x17) {
          uint64_t v81 = v39 | 7;
        }
        uint64_t v82 = v81 + 1;
        std::string v41 = operator new(v81 + 1);
        v103[1] = v40;
        unint64_t v104 = v82 | 0x8000000000000000;
        v103[0] = v41;
      }
      else
      {
        HIBYTE(v104) = v39;
        std::string v41 = v103;
        if (!v39)
        {
          LOBYTE(v103[0]) = 0;
          uint64_t v42 = a1 + 168;
          if ((*(char *)(a1 + 191) & 0x80000000) == 0) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
      }
      memcpy(v41, __s, (size_t)v40);
      *((unsigned char *)v40 + (void)v41) = 0;
      uint64_t v42 = a1 + 168;
      if (*(char *)(a1 + 191) < 0) {
LABEL_52:
      }
        operator delete(*(void **)v42);
LABEL_53:
      *(_OWORD *)uint64_t v42 = *(_OWORD *)v103;
      *(void *)(v42 + 16) = v104;
      if (!__s)
      {
        if (v101 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v102.__r_.__value_.__l.__data_);
        }
      }
      if (*(char *)(a1 + 167) < 0)
      {
        *(void *)(a1 + 152) = 7;
        uint64_t v43 = *(char **)(a1 + 144);
      }
      else
      {
        uint64_t v43 = (char *)(a1 + 144);
        *(unsigned char *)(a1 + 167) = 7;
      }
      strcpy(v43, ".adplv4");
      *(_DWORD *)(a1 + 200) = 0x40000;
      uint64_t v61 = abm::trace::kScratchFolder[0];
      size_t v62 = strlen(abm::trace::kScratchFolder[0]);
      if (v62 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v63 = v62;
      if (v62 >= 0x17)
      {
        uint64_t v65 = (v62 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v62 | 7) != 0x17) {
          uint64_t v65 = v62 | 7;
        }
        uint64_t v66 = v65 + 1;
        uint64_t v64 = (std::string *)operator new(v65 + 1);
        __dst.__r_.__value_.__l.__size_ = v63;
        __dst.__r_.__value_.__r.__words[2] = v66 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v64;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v62;
        uint64_t v64 = &__dst;
        if (!v62) {
          goto LABEL_96;
        }
      }
      memmove(v64, v61, v63);
LABEL_96:
      v64->__r_.__value_.__s.__data_[v63] = 0;
      unsigned __int8 v67 = std::string::append(&__dst, "ADPL.scratch", 0xCuLL);
      long long v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
      unint64_t v104 = v67->__r_.__value_.__r.__words[2];
      *(_OWORD *)xpc_object_t v103 = v68;
      v67->__r_.__value_.__l.__size_ = 0;
      v67->__r_.__value_.__r.__words[2] = 0;
      v67->__r_.__value_.__r.__words[0] = 0;
      abm::trace::TraceInfo::create();
      goto LABEL_107;
    }
    uint64_t v44 = abm::trace::kScratchFolder[0];
    size_t v45 = strlen(abm::trace::kScratchFolder[0]);
    if (v45 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v46 = v45;
    if (v45 >= 0x17)
    {
      uint64_t v87 = (v45 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v45 | 7) != 0x17) {
        uint64_t v87 = v45 | 7;
      }
      uint64_t v88 = v87 + 1;
      std::string v47 = operator new(v87 + 1);
      v102.__r_.__value_.__l.__size_ = v46;
      v102.__r_.__value_.__r.__words[2] = v88 | 0x8000000000000000;
      v102.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    }
    else
    {
      *((unsigned char *)&v102.__r_.__value_.__s + 23) = v45;
      std::string v47 = &v102;
      if (!v45)
      {
LABEL_138:
        v47[v46] = 0;
        char v101 = 12;
        strcpy((char *)__p, "ADPL.scratch");
        char v89 = std::string::append(&v102, (const std::string::value_type *)__p, 0xCuLL);
        long long v90 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
        unint64_t v104 = v89->__r_.__value_.__r.__words[2];
        *(_OWORD *)xpc_object_t v103 = v90;
        v89->__r_.__value_.__l.__size_ = 0;
        v89->__r_.__value_.__r.__words[2] = 0;
        v89->__r_.__value_.__r.__words[0] = 0;
        uint64_t v42 = a1 + 168;
        if (*(char *)(a1 + 191) < 0) {
          goto LABEL_52;
        }
        goto LABEL_53;
      }
    }
    memmove(v47, v44, v46);
    goto LABEL_138;
  }
  *(_WORD *)(a1 + 88) = 256;
  if ((*(char *)(a1 + 119) & 0x80000000) == 0)
  {
    *(unsigned char *)(a1 + 119) = 0;
    char *v16 = 0;
    if (__s) {
      goto LABEL_19;
    }
LABEL_83:
    dispatch_object_t v57 = abm::trace::kScratchFolder[0];
    size_t v58 = strlen(abm::trace::kScratchFolder[0]);
    if (v58 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v59 = v58;
    if (v58 >= 0x17)
    {
      uint64_t v95 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v58 | 7) != 0x17) {
        uint64_t v95 = v58 | 7;
      }
      uint64_t v96 = v95 + 1;
      uint64_t v60 = operator new(v95 + 1);
      v102.__r_.__value_.__l.__size_ = v59;
      v102.__r_.__value_.__r.__words[2] = v96 | 0x8000000000000000;
      v102.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
    }
    else
    {
      *((unsigned char *)&v102.__r_.__value_.__s + 23) = v58;
      uint64_t v60 = &v102;
      if (!v58)
      {
LABEL_150:
        v60[v59] = 0;
        char v101 = 12;
        strcpy((char *)__p, "DIAG.scratch");
        size_t v26 = (size_t)std::string::append(&v102, (const std::string::value_type *)__p, 0xCuLL);
        long long v97 = *(_OWORD *)v26;
        unint64_t v104 = *(void *)(v26 + 16);
        *(_OWORD *)xpc_object_t v103 = v97;
        *(void *)(v26 + 8) = 0;
        *(void *)(v26 + 16) = 0;
        *(void *)size_t v26 = 0;
        uint64_t v29 = a1 + 168;
        if (*(char *)(a1 + 191) < 0) {
          goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    memmove(v60, v57, v59);
    goto LABEL_150;
  }
  *(void *)(a1 + 104) = 0;
  **(unsigned char **)(a1 + 96) = 0;
  if (!__s) {
    goto LABEL_83;
  }
LABEL_19:
  size_t v26 = strlen(__s);
  if (v26 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v27 = (void *)v26;
  if (v26 >= 0x17)
  {
    uint64_t v85 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v26 | 7) != 0x17) {
      uint64_t v85 = v26 | 7;
    }
    uint64_t v86 = v85 + 1;
    uint64_t v28 = operator new(v85 + 1);
    v103[1] = v27;
    unint64_t v104 = v86 | 0x8000000000000000;
    v103[0] = v28;
  }
  else
  {
    HIBYTE(v104) = v26;
    uint64_t v28 = v103;
    if (!v26)
    {
      LOBYTE(v103[0]) = 0;
      uint64_t v29 = a1 + 168;
      if ((*(char *)(a1 + 191) & 0x80000000) == 0) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }
  size_t v26 = (size_t)memcpy(v28, __s, (size_t)v27);
  *((unsigned char *)v27 + (void)v28) = 0;
  uint64_t v29 = a1 + 168;
  if (*(char *)(a1 + 191) < 0) {
LABEL_23:
  }
    operator delete(*(void **)v29);
LABEL_24:
  *(_OWORD *)uint64_t v29 = *(_OWORD *)v103;
  *(void *)(v29 + 16) = v104;
  if (!__s)
  {
    if (v101 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v102.__r_.__value_.__l.__data_);
    }
  }
  if (capabilities::diag::diagVersion((capabilities::diag *)v26) == 3) {
    std::string::size_type v30 = ".diag.qmdl2";
  }
  else {
    std::string::size_type v30 = ".diag.qmdl";
  }
  std::string::__assign_external((std::string *)(a1 + 144), v30);
  *(_DWORD *)(a1 + 200) = v24;
  std::string v31 = abm::trace::kScratchFolder[0];
  size_t v32 = strlen(abm::trace::kScratchFolder[0]);
  if (v32 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v33 = v32;
  if (v32 >= 0x17)
  {
    uint64_t v35 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17) {
      uint64_t v35 = v32 | 7;
    }
    uint64_t v36 = v35 + 1;
    xpc_object_t v34 = (std::string *)operator new(v35 + 1);
    __dst.__r_.__value_.__l.__size_ = v33;
    __dst.__r_.__value_.__r.__words[2] = v36 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v32;
    xpc_object_t v34 = &__dst;
    if (!v32) {
      goto LABEL_45;
    }
  }
  memmove(v34, v31, v33);
LABEL_45:
  v34->__r_.__value_.__s.__data_[v33] = 0;
  uint64_t v37 = std::string::append(&__dst, "DIAG.scratch", 0xCuLL);
  long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  unint64_t v104 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)xpc_object_t v103 = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  abm::trace::TraceInfo::create();
LABEL_107:
  long long v77 = v99;
  long long v99 = 0uLL;
  uint64_t v78 = *(std::__shared_weak_count **)(a1 + 80);
  *(_OWORD *)(a1 + 72) = v77;
  if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
    std::__shared_weak_count::__release_weak(v78);
    long long v79 = (std::__shared_weak_count *)*((void *)&v99 + 1);
    if (!*((void *)&v99 + 1))
    {
LABEL_111:
      if ((SHIBYTE(v104) & 0x80000000) == 0) {
        goto LABEL_112;
      }
LABEL_117:
      operator delete(v103[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return a1;
      }
LABEL_118:
      operator delete(__dst.__r_.__value_.__l.__data_);
      return a1;
    }
  }
  else
  {
    long long v79 = (std::__shared_weak_count *)*((void *)&v99 + 1);
    if (!*((void *)&v99 + 1)) {
      goto LABEL_111;
    }
  }
  if (atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_111;
  }
  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
  std::__shared_weak_count::__release_weak(v79);
  if (SHIBYTE(v104) < 0) {
    goto LABEL_117;
  }
LABEL_112:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_118;
  }
  return a1;
}

{
  return diag::DIAGReader::Parameters::Parameters(a1, a2, a3, a4, a5, a6, __s, a8, a9);
}

void sub_1A618402C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  TraceFileCollection::Parameters::~Parameters(a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v39);
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100](a10);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](a11);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v38);
  std::string v41 = *(std::__shared_weak_count **)(v37 + 8);
  if (v41) {
    std::__shared_weak_count::__release_weak(v41);
  }
  _Unwind_Resume(a1);
}

void diag::DIAGReader::Parameters::create(int a1@<W0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, int a5@<W4>, char *a6@<X5>, int a7@<W6>, int a8@<W7>, void *a9@<X8>)
{
  uint64_t v17 = *a2;
  xpc_object_t v16 = (std::__shared_weak_count *)a2[1];
  xpc_object_t v18 = (std::__shared_weak_count *)operator new(0xE8uLL);
  long long v19 = v18;
  v18->__shared_owners_ = 0;
  p_shared_owners = &v18->__shared_owners_;
  v18->__shared_weak_owners_ = 0;
  v18->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DAE0;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = *a3;
  size_t v21 = (std::__shared_weak_count *)a3[1];
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *a4;
  size_t v23 = (std::__shared_weak_count *)a4[1];
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v33 = v17;
  xpc_object_t v34 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v24 = &v18[1].__vftable;
  uint64_t v31 = v20;
  size_t v32 = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v30[0] = v22;
  v30[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  diag::DIAGReader::Parameters::Parameters((uint64_t)&v18[1], a1, &v33, &v31, v30, a5, a6, a7, a8);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  int v25 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  size_t v26 = v34;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    shared_owners = (std::__shared_weak_count *)v19[1].__shared_owners_;
    if (shared_owners) {
      goto LABEL_31;
    }
  }
  else
  {
    shared_owners = (std::__shared_weak_count *)v19[1].__shared_owners_;
    if (shared_owners)
    {
LABEL_31:
      if (shared_owners->__shared_owners_ == -1)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
        v19[1].__shared_owners_ = (uint64_t)v19;
        std::__shared_weak_count::__release_weak(shared_owners);
        if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_36;
        }
      }
      goto LABEL_37;
    }
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
  v19[1].__shared_owners_ = (uint64_t)v19;
  if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_36:
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_37:
  *a9 = v24;
  a9[1] = v19;
}

void sub_1A61844A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (a16 && !atomic_fetch_add(&a16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
    std::__shared_weak_count::__release_weak(a16);
  }
  if (a18 && !atomic_fetch_add(&a18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a18->__on_zero_shared)(a18);
    std::__shared_weak_count::__release_weak(a18);
  }
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v19)
  {
    if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v23);
  _Unwind_Resume(a1);
}

uint64_t diag::DIAGReader::DIAGReader(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = *a2;
  uint64_t v6 = a1 + 16;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  size_t v8 = (uint64_t *)(a1 + 32);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  long long v9 = *(void **)a3;
  if (*(void *)a3) {
    long long v9 = _Block_copy(v9);
  }
  *(void *)(a1 + 72) = v9;
  uint64_t v10 = *(NSObject **)(a3 + 8);
  *(void *)(a1 + 80) = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  xpc_object_t v11 = *(std::__shared_weak_count **)(*a2 + 64);
  xpc_object_t v18 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  TraceFileCollection::create();
  size_t v12 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v19;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v13 = *v8;
  if (!*v8 || *(_DWORD *)(*(void *)v6 + 16) != 2) {
    return a1;
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 40);
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    *(_DWORD *)(a1 + 48) = 0;
    *(unsigned char *)(a1 + 52) = 0;
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)(a1 + 56) = v13;
    *(void *)(a1 + 64) = v14;
    if (!v15) {
      goto LABEL_23;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 48) = 0;
    *(unsigned char *)(a1 + 52) = 0;
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 64);
    *(void *)(a1 + 56) = v13;
    *(void *)(a1 + 64) = 0;
    if (!v15) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_23:
  if (v14)
  {
    p_shared_owners = &v14->__shared_owners_;
    if (atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        return a1;
      }
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        return a1;
      }
    }
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  return a1;
}

void sub_1A6184938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<ctu::LogServer>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  dispatch::callback<void({block_pointer})(std::string)>::~callback(v13);
  diag::DIAGProtocolHDLC::~DIAGProtocolHDLC(v12);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v11);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v10);
  uint64_t v15 = *(std::__shared_weak_count **)(v9 + 8);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  _Unwind_Resume(a1);
}

void diag::DIAGProtocolHDLC::~DIAGProtocolHDLC(diag::DIAGProtocolHDLC *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void diag::DIAGReader::~DIAGReader(diag::DIAGReader *this)
{
  unsigned int v2 = *((void *)this + 10);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 9);
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void diag::DIAGReader::start(diag::DIAGReader *this)
{
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (!v2 || (v3 = *(void *)this, (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v5);
  }
  __int16 v61 = -21846;
  char v62 = -86;
  v60[0] = -1431655766;
  *(_DWORD *)((char *)v60 + 3) = -1431655766;
  int v6 = *(_DWORD *)(*((void *)this + 2) + 16);
  int shouldUseMinBasebandTransportIOReadSize = (capabilities::abs *)capabilities::abs::shouldUseMinBasebandTransportIOReadSize((capabilities::abs *)v4);
  if (shouldUseMinBasebandTransportIOReadSize) {
    int v8 = 0x4000;
  }
  else {
    int v8 = 0x8000;
  }
  if (capabilities::abs::shouldUseMinBasebandTransportIOReadCount(shouldUseMinBasebandTransportIOReadSize))
  {
LABEL_9:
    int v9 = 4;
    if (*(_DWORD *)(*((void *)this + 2) + 16) != 2) {
      goto LABEL_41;
    }
LABEL_15:
    *((_DWORD *)this + 12) = 0;
    *((unsigned char *)this + 52) = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN4diag10DIAGReader5startEv_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_26;
    aBlock[4] = this;
    void aBlock[5] = v3;
    std::string::size_type v59 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v10 = _Block_copy(aBlock);
    uint64_t v11 = v59;
    if (!v59) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if (v6 == 2)
  {
    int v9 = 16;
    if (*(_DWORD *)(*((void *)this + 2) + 16) == 2) {
      goto LABEL_15;
    }
  }
  else
  {
    if (v6 != 16 && v6 != 15) {
      goto LABEL_9;
    }
    int v9 = 36;
    if (*(_DWORD *)(*((void *)this + 2) + 16) == 2) {
      goto LABEL_15;
    }
  }
LABEL_41:
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB5EEB10, memory_order_acquire) & 1) == 0)
  {
    uint64_t v36 = (capabilities::abs *)__cxa_guard_acquire(&qword_1EB5EEB10);
    if (v36)
    {
      if (capabilities::abs::shouldUseMinBasebandTransportIOReadSize(v36)) {
        int v37 = 0x4000;
      }
      else {
        int v37 = 0x8000;
      }
      _MergedGlobals_18 = v37;
      __cxa_guard_release(&qword_1EB5EEB10);
    }
  }
  v56[0] = MEMORY[0x1E4F143A8];
  v56[1] = 1174405120;
  void v56[2] = ___ZN4diag10DIAGReader5startEv_block_invoke_7;
  v56[3] = &__block_descriptor_tmp_10_3;
  v56[4] = this;
  v56[5] = v3;
  dispatch_object_t v57 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v10 = _Block_copy(v56);
  uint64_t v11 = v57;
  if (v57) {
LABEL_16:
  }
    std::__shared_weak_count::__release_weak(v11);
LABEL_17:
  uint64_t v12 = *(void *)(*((void *)this + 2) + 24);
  int v46 = v6;
  char v47 = 1;
  __int16 v48 = v61;
  char v49 = v62;
  uint64_t v50 = 10;
  int v51 = v8;
  int v52 = v9;
  uint64_t v53 = 0;
  char v54 = 0;
  *(_DWORD *)std::string::size_type v55 = v60[0];
  *(_DWORD *)&v55[3] = *(_DWORD *)((char *)v60 + 3);
  if (v10) {
    uint64_t v13 = _Block_copy(v10);
  }
  else {
    uint64_t v13 = 0;
  }
  size_t v45 = v13;
  int v14 = (*(uint64_t (**)(uint64_t, int *, void **))(*(void *)v12 + 48))(v12, &v46, &v45);
  if (v45) {
    _Block_release(v45);
  }
  if (!v14)
  {
    if (!*((void *)this + 9) || !*((void *)this + 10)) {
      goto LABEL_69;
    }
    BasebandTransport::asString(*(unsigned int *)(*((void *)this + 2) + 16), (char *)__p);
    int v20 = (char)v39;
    if ((v39 & 0x80u) == 0) {
      size_t v21 = v39;
    }
    else {
      size_t v21 = (size_t)__p[1];
    }
    unint64_t v22 = v21 + 15;
    memset(&v40, 170, sizeof(v40));
    if (v21 + 15 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v22 >= 0x17)
    {
      uint64_t v24 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v22 | 7) != 0x17) {
        uint64_t v24 = v22 | 7;
      }
      uint64_t v25 = v24 + 1;
      size_t v26 = (char *)operator new(v24 + 1);
      v40.__r_.__value_.__l.__size_ = v21 + 15;
      v40.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
      v40.__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
      qmemcpy(v26, "Failed to open ", 15);
      size_t v23 = v26 + 15;
    }
    else
    {
      v40.__r_.__value_.__r.__words[2] = 0;
      *((unsigned char *)&v40.__r_.__value_.__s + 23) = v21 + 15;
      strcpy((char *)&v40, "Failed to open ");
      size_t v23 = &v40.__r_.__value_.__s.__data_[15];
      if (!v21) {
        goto LABEL_51;
      }
    }
    if (v20 >= 0) {
      uint64_t v27 = __p;
    }
    else {
      uint64_t v27 = (void **)__p[0];
    }
    memmove(v23, v27, v21);
LABEL_51:
    v23[v21] = 0;
    uint64_t v28 = std::string::append(&v40, " transport", 0xAuLL);
    uint64_t v29 = (std::string::value_type *)v28->__r_.__value_.__r.__words[0];
    std::string::size_type size = v28->__r_.__value_.__l.__size_;
    v41[0] = v28->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v41 + 3) = *(_DWORD *)((char *)&v28->__r_.__value_.__r.__words[2] + 3);
    int v31 = SHIBYTE(v28->__r_.__value_.__r.__words[2]);
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    size_t v32 = (const void *)*((void *)this + 9);
    if (v32) {
      uint64_t v33 = _Block_copy(v32);
    }
    else {
      uint64_t v33 = 0;
    }
    xpc_object_t v34 = *((void *)this + 10);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 1174405120;
    block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEclIJS7_EEEvDpT__block_invoke;
    block[3] = &__block_descriptor_tmp_36;
    if (v33)
    {
      uint64_t v64 = _Block_copy(v33);
      if ((v31 & 0x80000000) == 0)
      {
LABEL_56:
        v65.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
        v65.__r_.__value_.__l.__size_ = size;
        LODWORD(v65.__r_.__value_.__r.__words[2]) = v41[0];
        *(_DWORD *)((char *)&v65.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v41 + 3);
        *((unsigned char *)&v65.__r_.__value_.__s + 23) = v31;
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v64 = 0;
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_56;
      }
    }
    std::string::__init_copy_ctor_external(&v65, v29, size);
LABEL_59:
    dispatch_async(v34, block);
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v65.__r_.__value_.__l.__data_);
      uint64_t v35 = v64;
      if (!v64) {
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v35 = v64;
      if (!v64)
      {
LABEL_64:
        if (v33) {
          _Block_release(v33);
        }
        if (v31 < 0)
        {
          operator delete(v29);
          if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_68:
            if (((char)v39 & 0x80000000) == 0) {
              goto LABEL_69;
            }
            goto LABEL_74;
          }
        }
        else if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_68;
        }
        operator delete(v40.__r_.__value_.__l.__data_);
        if (((char)v39 & 0x80000000) == 0) {
          goto LABEL_69;
        }
LABEL_74:
        operator delete(__p[0]);
        if (!v10) {
          goto LABEL_71;
        }
        goto LABEL_70;
      }
    }
    _Block_release(v35);
    goto LABEL_64;
  }
  v43[0] = MEMORY[0x1E4F143A8];
  v43[1] = 1174405120;
  v43[2] = ___ZN4diag10DIAGReader5startEv_block_invoke_11;
  void v43[3] = &__block_descriptor_tmp_17_1;
  v43[4] = this;
  v43[5] = v3;
  uint64_t v44 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v15 = _Block_copy(v43);
  xpc_object_t v16 = v15;
  uint64_t v17 = *(void *)(*((void *)this + 2) + 24);
  if (!v15)
  {
    uint64_t v42 = 0;
    BasebandTransport::reportStatus(v17, 60, &v42);
    long long v19 = v44;
    if (!v44) {
      goto LABEL_69;
    }
LABEL_38:
    std::__shared_weak_count::__release_weak(v19);
    if (!v10) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
  xpc_object_t v18 = _Block_copy(v15);
  uint64_t v42 = v18;
  BasebandTransport::reportStatus(v17, 60, &v42);
  if (v18) {
    _Block_release(v18);
  }
  _Block_release(v16);
  long long v19 = v44;
  if (v44) {
    goto LABEL_38;
  }
LABEL_69:
  if (v10) {
LABEL_70:
  }
    _Block_release(v10);
LABEL_71:
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1A618518C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EB5EEB10);
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_1A61851AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *aBlock)
{
  int v37 = *(const void **)(v35 - 112);
  if (v37) {
    _Block_release(v37);
  }
  if (v34) {
    _Block_release(v34);
  }
  operator delete(v33);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (v32) {
    _Block_release(v32);
  }
  std::__shared_weak_count::__release_weak(v31);
  _Unwind_Resume(a1);
}

void ___ZN4diag10DIAGReader5startEv_block_invoke(void *a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int v9 = v8;
      if (a1[5]) {
        diag::DIAGProtocolHDLC::handleReadData((diag::DIAGProtocolHDLC *)(v7 + 48), a2, a3);
      }
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_1A6185360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrIN4diag10DIAGReaderEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__18weak_ptrIN4diag10DIAGReaderEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN4diag10DIAGReader5startEv_block_invoke_7(void *a1, const unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    int v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int v9 = v8;
      if (a1[5])
      {
        unsigned int Data = TraceFileCollection::handleReadData(*(TraceFileCollection **)(v7 + 32), a2);
        if (TraceFileCollection::getInMemoryRemaining(*(TraceFileCollection **)(v7 + 32)) < _MergedGlobals_18) {
          TraceFileCollection::archive(*(TraceFileCollection **)(v7 + 32));
        }
        if (Data) {
          BOOL v11 = a3 > Data;
        }
        else {
          BOOL v11 = 0;
        }
        if (v11) {
          TraceFileCollection::handleReadData(*(TraceFileCollection **)(v7 + 32), &a2[Data]);
        }
      }
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
}

void sub_1A61854C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A61854D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN4diag10DIAGReader5startEv_block_invoke_11(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = (void *)a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    size_t v32 = v6;
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5]) {
        goto LABEL_46;
      }
      if (!v5[9] || !v5[10] || *(_DWORD *)a2 != 2)
      {
        if (!*(void *)(v5[2] + 72)) {
          goto LABEL_46;
        }
        std::to_string(&v26, *(void *)(a2 + 24));
        Timestamp::Timestamp((Timestamp *)v24);
        abm::trace::TraceInfo::push();
        std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v24, v25);
        if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_46;
        }
        uint64_t v12 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_45;
      }
      BasebandTransport::asString(*(unsigned int *)(v5[2] + 16), (char *)v27);
      int v8 = (char)v28;
      if ((v28 & 0x80u) == 0) {
        size_t v9 = v28;
      }
      else {
        size_t v9 = (size_t)v27[1];
      }
      unint64_t v10 = v9 + 20;
      memset(&v29, 170, sizeof(v29));
      if (v9 + 20 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v10 >= 0x17)
      {
        uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v10 | 7) != 0x17) {
          uint64_t v13 = v10 | 7;
        }
        uint64_t v14 = v13 + 1;
        uint64_t v15 = (char *)operator new(v13 + 1);
        v29.__r_.__value_.__l.__size_ = v9 + 20;
        v29.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
        v29.__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
        *((_DWORD *)v15 + 4) = 544042866;
        *(_OWORD *)uint64_t v15 = *(_OWORD *)"Failed to read from ";
        BOOL v11 = v15 + 20;
      }
      else
      {
        HIDWORD(v29.__r_.__value_.__r.__words[2]) = 0;
        *((unsigned char *)&v29.__r_.__value_.__s + 23) = v9 + 20;
        LODWORD(v29.__r_.__value_.__r.__words[2]) = 544042866;
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)"Failed to read from ";
        BOOL v11 = &v29.__r_.__value_.__s.__data_[20];
        if (!v9) {
          goto LABEL_24;
        }
      }
      if (v8 >= 0) {
        xpc_object_t v16 = v27;
      }
      else {
        xpc_object_t v16 = (void **)v27[0];
      }
      memmove(v11, v16, v9);
LABEL_24:
      v11[v9] = 0;
      uint64_t v17 = std::string::append(&v29, " transport", 0xAuLL);
      xpc_object_t v18 = (std::string::value_type *)v17->__r_.__value_.__r.__words[0];
      std::string::size_type size = v17->__r_.__value_.__l.__size_;
      v30[0] = v17->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v30 + 3) = *(_DWORD *)((char *)&v17->__r_.__value_.__r.__words[2] + 3);
      int v20 = SHIBYTE(v17->__r_.__value_.__r.__words[2]);
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      size_t v21 = (const void *)v5[9];
      if (v21) {
        unint64_t v22 = _Block_copy(v21);
      }
      else {
        unint64_t v22 = 0;
      }
      size_t v23 = v5[10];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 1174405120;
      block[2] = ___ZNK8dispatch8callbackIU13block_pointerFvNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEclIJS7_EEEvDpT__block_invoke;
      block[3] = &__block_descriptor_tmp_36;
      if (v22)
      {
        xpc_object_t v34 = _Block_copy(v22);
        if ((v20 & 0x80000000) == 0)
        {
LABEL_29:
          v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
          v35.__r_.__value_.__l.__size_ = size;
          LODWORD(v35.__r_.__value_.__r.__words[2]) = v30[0];
          *(_DWORD *)((char *)&v35.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v30 + 3);
          *((unsigned char *)&v35.__r_.__value_.__s + 23) = v20;
          goto LABEL_32;
        }
      }
      else
      {
        xpc_object_t v34 = 0;
        if ((v20 & 0x80000000) == 0) {
          goto LABEL_29;
        }
      }
      std::string::__init_copy_ctor_external(&v35, v18, size);
LABEL_32:
      dispatch_async(v23, block);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      if (v34) {
        _Block_release(v34);
      }
      if (v22) {
        _Block_release(v22);
      }
      if (v20 < 0)
      {
        operator delete(v18);
        if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_40:
          if (((char)v28 & 0x80000000) == 0) {
            goto LABEL_46;
          }
LABEL_44:
          uint64_t v12 = v27[0];
LABEL_45:
          operator delete(v12);
LABEL_46:
          if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
          return;
        }
      }
      else if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_40;
      }
      operator delete(v29.__r_.__value_.__l.__data_);
      if (((char)v28 & 0x80000000) == 0) {
        goto LABEL_46;
      }
      goto LABEL_44;
    }
  }
}

void sub_1A61858AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,char a44)
{
  __int16 v48 = *(const void **)(v46 - 112);
  if (v48) {
    _Block_release(v48);
  }
  if (v45) {
    _Block_release(v45);
  }
  operator delete(v44);
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a36 < 0)
  {
    operator delete(a31);
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a44);
  _Unwind_Resume(a1);
}

void diag::DIAGReader::stop(diag::DIAGReader *this)
{
  BasebandTransport::close(*(BasebandTransport **)(*((void *)this + 2) + 24));
  uint64_t v2 = *((void *)this + 2);
  if (*(void *)(v2 + 72))
  {
    std::to_string(&v5, *(void *)(*(void *)(v2 + 24) + 336));
    Timestamp::Timestamp((Timestamp *)v3);
    abm::trace::TraceInfo::push();
    std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v3, v4);
    if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v5.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1A6185A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a21, a22);
  if (*(char *)(v22 - 17) < 0) {
    operator delete(*(void **)(v22 - 40));
  }
  _Unwind_Resume(a1);
}

void diag::DIAGReader::snapshot(uint64_t a1, uint64_t a2)
{
  v58[2] = *MEMORY[0x1E4F143B8];
  *(void *)&v57[24] = 0xAAAAAAAAAAAAAALL;
  memset(v57, 170, 24);
  std::string::size_type v55 = (std::string::value_type *)0xAAAAAAAAAAAAAA00;
  unint64_t v56 = 0xAAAAAAAAAAAAAAAALL;
  *(_WORD *)&v57[7] = 0;
  uint64_t v4 = *(void **)(*(void *)(a1 + 16) + 40);
  uint64_t v5 = v4[1];
  uint64_t v6 = v4[2];
  if (v5 != v6)
  {
    while (1)
    {
      ETLDIAGLoggingGetGUIDString();
      uint64_t v7 = std::string::insert(&v52, 0, "GUID: ", 6uLL);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v53.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      size_t v9 = std::string::append(&v53, "\n", 1uLL);
      long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v11 = &v54;
      }
      else {
        BOOL v11 = (std::string *)v54.__r_.__value_.__r.__words[0];
      }
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v54.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)&v55, (const std::string::value_type *)v11, size);
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v54.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_12:
          if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_16;
          }
          goto LABEL_3;
        }
      }
      else if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_12;
      }
      operator delete(v53.__r_.__value_.__l.__data_);
      if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
LABEL_16:
      }
        operator delete(v52.__r_.__value_.__l.__data_);
LABEL_3:
      v5 += 16;
      if (v5 == v6)
      {
        uint64_t v4 = *(void **)(*(void *)(a1 + 16) + 40);
        break;
      }
    }
  }
  uint64_t v13 = (unsigned __int8 *)v4[4];
  uint64_t v14 = (unsigned __int8 *)v4[5];
  while (v13 != v14)
  {
    std::to_string(&v52, *v13);
    uint64_t v15 = std::string::insert(&v52, 0, "DiagID: ", 8uLL);
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    uint64_t v17 = std::string::append(&v53, "\n", 1uLL);
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v19 = &v54;
    }
    else {
      long long v19 = (std::string *)v54.__r_.__value_.__r.__words[0];
    }
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v20 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v20 = v54.__r_.__value_.__l.__size_;
    }
    std::string::append((std::string *)&v55, (const std::string::value_type *)v19, v20);
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v54.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_29:
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_33;
        }
        goto LABEL_20;
      }
    }
    else if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_29;
    }
    operator delete(v53.__r_.__value_.__l.__data_);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
LABEL_33:
    }
      operator delete(v52.__r_.__value_.__l.__data_);
LABEL_20:
    ++v13;
  }
  *((unsigned char *)&v50.__r_.__value_.__s + 23) = 5;
  strcpy((char *)&v50, "Ext: ");
  if (v57[7] >= 0) {
    size_t v21 = (const std::string::value_type *)&v55;
  }
  else {
    size_t v21 = v55;
  }
  if (v57[7] >= 0) {
    std::string::size_type v22 = v57[7];
  }
  else {
    std::string::size_type v22 = v56;
  }
  size_t v23 = std::string::insert(&v50, 0, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  uint64_t v25 = *(void *)(a1 + 16);
  unsigned __int8 v28 = *(const std::string::value_type **)(v25 + 144);
  uint64_t v26 = v25 + 144;
  uint64_t v27 = v28;
  int v29 = *(char *)(v26 + 23);
  if (v29 >= 0) {
    std::string::size_type v30 = (const std::string::value_type *)v26;
  }
  else {
    std::string::size_type v30 = v27;
  }
  if (v29 >= 0) {
    std::string::size_type v31 = *(unsigned __int8 *)(v26 + 23);
  }
  else {
    std::string::size_type v31 = *(void *)(v26 + 8);
  }
  size_t v32 = std::string::append(&v51, v30, v31);
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  xpc_object_t v34 = std::string::append(&v52, "\nQSR: ", 6uLL);
  long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  capabilities::radio::firmwarePrefix((uint64_t *)__p, (capabilities::radio *)v34);
  if ((v49 & 0x80u) == 0) {
    uint64_t v36 = __p;
  }
  else {
    uint64_t v36 = (void **)__p[0];
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v37 = v49;
  }
  else {
    std::string::size_type v37 = (std::string::size_type)__p[1];
  }
  uint64_t v38 = std::string::append(&v53, (const std::string::value_type *)v36, v37);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  std::string v40 = std::string::append(&v54, "hash\n", 5uLL);
  std::string::size_type v41 = v40->__r_.__value_.__r.__words[0];
  v58[0] = v40->__r_.__value_.__l.__size_;
  *(void *)((char *)v58 + 7) = *(std::string::size_type *)((char *)&v40->__r_.__value_.__r.__words[1] + 7);
  char v42 = HIBYTE(v40->__r_.__value_.__r.__words[2]);
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  *(void *)&unsigned char v57[8] = v41;
  *(void *)&v57[23] = *(void *)((char *)v58 + 7);
  *(void *)&v57[16] = v58[0];
  v57[31] = v42;
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v54.__r_.__value_.__l.__data_);
    if (((char)v49 & 0x80000000) == 0)
    {
LABEL_54:
      if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_55;
      }
      goto LABEL_62;
    }
  }
  else if (((char)v49 & 0x80000000) == 0)
  {
    goto LABEL_54;
  }
  operator delete(__p[0]);
  if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_55:
    if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_56;
    }
    goto LABEL_63;
  }
LABEL_62:
  operator delete(v53.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_56:
    if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_64;
  }
LABEL_63:
  operator delete(v52.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_57:
    if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_58;
    }
    goto LABEL_65;
  }
LABEL_64:
  operator delete(v51.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_58:
    if (!*(void *)(*(void *)(a1 + 16) + 72)) {
      goto LABEL_70;
    }
    goto LABEL_66;
  }
LABEL_65:
  operator delete(v50.__r_.__value_.__l.__data_);
  if (!*(void *)(*(void *)(a1 + 16) + 72)) {
    goto LABEL_70;
  }
LABEL_66:
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v47, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v47 = *(std::string *)a2;
  }
  Timestamp::Timestamp((Timestamp *)v45);
  abm::trace::TraceInfo::push();
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v45, v46);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v47.__r_.__value_.__l.__data_);
    if (!*(void *)(a1 + 32)) {
      goto LABEL_77;
    }
    goto LABEL_71;
  }
LABEL_70:
  if (!*(void *)(a1 + 32)) {
    goto LABEL_77;
  }
LABEL_71:
  uint64_t v43 = *(std::__shared_weak_count **)(*(void *)(a1 + 16) + 80);
  uint64_t v44 = v43;
  if (v43) {
    atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  TraceFileCollection::snapshot();
  if (v44)
  {
    if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
LABEL_77:
  if ((v57[7] & 0x80000000) == 0)
  {
    if ((v57[31] & 0x80000000) == 0) {
      return;
    }
LABEL_81:
    operator delete(*(void **)&v57[8]);
    return;
  }
  operator delete(v55);
  if ((v57[31] & 0x80000000) != 0) {
    goto LABEL_81;
  }
}

void sub_1A61860F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (*(char *)(v58 - 145) < 0)
  {
    operator delete(*(void **)(v58 - 168));
    if ((*(char *)(v58 - 121) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v58 - 121) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v58 - 144));
  _Unwind_Resume(exception_object);
}

BOOL diag::DIAGReader::isStarted(diag::DIAGReader *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 2) + 24);
  return *(unsigned char *)(v1 + 332) && *(_DWORD *)(v1 + 328) == 1;
}

uint64_t diag::DIAGReader::getReadCount(diag::DIAGReader *this)
{
  return *(void *)(*(void *)(*((void *)this + 2) + 24) + 336);
}

TraceFileCollection *diag::DIAGReader::setHistory(diag::DIAGReader *this)
{
  xpc_object_t result = (TraceFileCollection *)*((void *)this + 4);
  if (result) {
    return (TraceFileCollection *)TraceFileCollection::setHistory(result);
  }
  return result;
}

TraceFileCollection *diag::DIAGReader::setMaxMemoryFile(diag::DIAGReader *this)
{
  xpc_object_t result = (TraceFileCollection *)*((void *)this + 4);
  if (result) {
    return (TraceFileCollection *)TraceFileCollection::setMaxMemoryFileCount(result);
  }
  return result;
}

TraceFileCollection *diag::DIAGReader::setFileSize(diag::DIAGReader *this)
{
  xpc_object_t result = (TraceFileCollection *)*((void *)this + 4);
  if (result) {
    return (TraceFileCollection *)TraceFileCollection::setFileSize(result);
  }
  return result;
}

void diag::DIAGReader::shutdown(diag::DIAGReader *this)
{
  if (*((void *)this + 4))
  {
    uint64_t v1 = abm::trace::kTrashFolder[0];
    size_t v2 = strlen(abm::trace::kTrashFolder[0]);
    if (v2 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    uint64_t v3 = (void *)v2;
    if (v2 >= 0x17)
    {
      uint64_t v5 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v2 | 7) != 0x17) {
        uint64_t v5 = v2 | 7;
      }
      uint64_t v6 = v5 + 1;
      uint64_t v4 = (void **)operator new(v5 + 1);
      __dst[1] = v3;
      unint64_t v8 = v6 | 0x8000000000000000;
      __dst[0] = v4;
    }
    else
    {
      HIBYTE(v8) = v2;
      uint64_t v4 = __dst;
      if (!v2)
      {
LABEL_10:
        *((unsigned char *)v3 + (void)v4) = 0;
        TraceFileCollection::clear();
        if (SHIBYTE(v8) < 0) {
          operator delete(__dst[0]);
        }
        return;
      }
    }
    memmove(v4, v1, (size_t)v3);
    goto LABEL_10;
  }
}

void sub_1A6186470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t diag::DIAGReader::getTraceInfo@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 16);
  uint64_t v4 = *(void *)(v2 + 72);
  uint64_t v3 = *(void *)(v2 + 80);
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

TraceFileCollection *diag::DIAGReader::archive(diag::DIAGReader *this)
{
  xpc_object_t result = (TraceFileCollection *)*((void *)this + 4);
  if (result) {
    return (TraceFileCollection *)TraceFileCollection::archive(result);
  }
  return result;
}

uint64_t diag::DIAGReader::getCurrentIndex(diag::DIAGReader *this)
{
  uint64_t result = *((void *)this + 4);
  if (result) {
    return MEMORY[0x1F410C7E8]();
  }
  return result;
}

void diag::DIAGReaderManager::create(void *a1@<X8>)
{
  uint64_t v3 = (atomic_ullong *)operator new(0x40uLL);
  void v3[2] = 0;
  v3[1] = 0;
  atomic_ullong *v3 = (atomic_ullong)&unk_1EFB0DB60;
  v3[7] = 0;
  void v3[6] = 0;
  v3[4] = (atomic_ullong)v3;
  void v3[5] = (atomic_ullong)(v3 + 6);
  *a1 = v3 + 3;
  a1[1] = v3;
  atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(v3 + 2, 1uLL, memory_order_relaxed);
  v3[3] = (atomic_ullong)(v3 + 3);
  if (!atomic_fetch_add(v3 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v4 = (std::__shared_weak_count *)v3;
    (*(void (**)(atomic_ullong *))(*v3 + 16))(v3);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void *diag::DIAGReaderManager::DIAGReaderManager(void *this)
{
  *this = 0;
  this[1] = 0;
  this[4] = 0;
  this[3] = 0;
  this[2] = this + 3;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[4] = 0;
  this[3] = 0;
  this[2] = this + 3;
  return this;
}

void diag::DIAGReaderManager::~DIAGReaderManager(diag::DIAGReaderManager *this)
{
  std::__tree<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::__map_value_compare<abm::helper::TaskID,std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::less<abm::helper::TaskID>,true>,std::allocator<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>>>::destroy(*((void **)this + 3));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  std::__shared_weak_count *v2;

  std::__tree<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::__map_value_compare<abm::helper::TaskID,std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::less<abm::helper::TaskID>,true>,std::allocator<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>>>::destroy(*((void **)this + 3));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void diag::DIAGReaderManager::addReader(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = (void *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v9 = a1 + 24;
  do
  {
    unsigned int v10 = *(_DWORD *)(v7 + 32);
    BOOL v11 = v10 >= a2;
    if (v10 >= a2) {
      uint64_t v12 = (uint64_t *)v7;
    }
    else {
      uint64_t v12 = (uint64_t *)(v7 + 8);
    }
    if (v11) {
      uint64_t v9 = v7;
    }
    uint64_t v7 = *v12;
  }
  while (*v12);
  if ((void *)v9 == v8 || *(_DWORD *)(v9 + 32) > a2)
  {
LABEL_12:
    uint64_t v14 = *a3;
    uint64_t v13 = (std::__shared_weak_count *)a3[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(void *)a4)
    {
      uint64_t v15 = _Block_copy(*(const void **)a4);
      long long v16 = *(NSObject **)(a4 + 8);
      aBlocuint64_t k = v15;
      xpc_object_t object = v16;
      if (!v16) {
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v15 = 0;
      long long v16 = *(NSObject **)(a4 + 8);
      aBlocuint64_t k = 0;
      xpc_object_t object = v16;
      if (!v16)
      {
LABEL_17:
        uint64_t v17 = (std::__shared_weak_count *)operator new(0x70uLL);
        long long v18 = v17;
        v17->__shared_owners_ = 0;
        p_shared_owners = &v17->__shared_owners_;
        v17->__shared_weak_owners_ = 0;
        v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DA90;
        v38[0] = v14;
        v38[1] = v13;
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v15)
        {
          std::string::size_type v20 = _Block_copy(v15);
          uint64_t v21 = (uint64_t)&v18[1];
          uint64_t v36 = v20;
          std::string::size_type v37 = v16;
          if (!v16) {
            goto LABEL_22;
          }
        }
        else
        {
          std::string::size_type v20 = 0;
          uint64_t v21 = (uint64_t)&v17[1];
          uint64_t v36 = 0;
          std::string::size_type v37 = v16;
          if (!v16)
          {
LABEL_22:
            diag::DIAGReader::DIAGReader(v21, v38, (uint64_t)&v36);
            if (v16) {
              dispatch_release(v16);
            }
            if (v20) {
              _Block_release(v20);
            }
            if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
              uint64_t v34 = v21;
              long long v35 = v18;
              shared_owners = (std::__shared_weak_count *)v18[1].__shared_owners_;
              if (shared_owners) {
                goto LABEL_29;
              }
            }
            else
            {
              uint64_t v34 = v21;
              long long v35 = v18;
              shared_owners = (std::__shared_weak_count *)v18[1].__shared_owners_;
              if (shared_owners)
              {
LABEL_29:
                if (shared_owners->__shared_owners_ != -1
                  || (atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed),
                      atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed),
                      v18[1].__vftable = (std::__shared_weak_count_vtbl *)&v18[1],
                      v18[1].__shared_owners_ = (uint64_t)v18,
                      std::__shared_weak_count::__release_weak(shared_owners),
                      atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)))
                {
LABEL_39:
                  if (object) {
                    dispatch_release(object);
                  }
                  if (aBlock) {
                    _Block_release(aBlock);
                  }
                  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
                    std::__shared_weak_count::__release_weak(v13);
                    uint64_t v23 = *v8;
                    long long v24 = v8;
                    if (*v8)
                    {
                      while (1)
                      {
LABEL_50:
                        while (1)
                        {
                          long long v24 = (void *)v23;
                          unsigned int v25 = *(_DWORD *)(v23 + 32);
                          if (v25 <= a2) {
                            break;
                          }
                          uint64_t v23 = *v24;
                          unint64_t v8 = v24;
                          if (!*v24) {
                            goto LABEL_54;
                          }
                        }
                        if (v25 >= a2) {
                          break;
                        }
                        uint64_t v23 = v24[1];
                        if (!v23)
                        {
                          unint64_t v8 = v24 + 1;
                          goto LABEL_54;
                        }
                      }
                      uint64_t v26 = v24;
                      uint64_t v30 = v34;
                      int v29 = v35;
                      if (!v35) {
                        goto LABEL_58;
                      }
LABEL_57:
                      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_58:
                      std::string::size_type v31 = (std::__shared_weak_count *)*((void *)v26 + 6);
                      *((void *)v26 + 5) = v30;
                      *((void *)v26 + 6) = v29;
                      if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                        std::__shared_weak_count::__release_weak(v31);
                      }
                      if (v35)
                      {
                        if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
                          std::__shared_weak_count::__release_weak(v35);
                        }
                      }
                      return;
                    }
                  }
                  else
                  {
                    uint64_t v23 = *v8;
                    long long v24 = v8;
                    if (*v8) {
                      goto LABEL_50;
                    }
                  }
LABEL_54:
                  uint64_t v26 = operator new(0x38uLL);
                  *((_DWORD *)v26 + 8) = a2;
                  *((void *)v26 + 5) = 0;
                  *((void *)v26 + 6) = 0;
                  *(void *)uint64_t v26 = 0;
                  *((void *)v26 + 1) = 0;
                  *((void *)v26 + 2) = v24;
                  void *v8 = v26;
                  uint64_t v27 = **(void **)(a1 + 16);
                  unsigned __int8 v28 = (uint64_t *)v26;
                  if (v27)
                  {
                    *(void *)(a1 + 16) = v27;
                    unsigned __int8 v28 = (uint64_t *)*v8;
                  }
                  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 24), v28);
                  ++*(void *)(a1 + 32);
                  uint64_t v30 = v34;
                  int v29 = v35;
                  if (!v35) {
                    goto LABEL_58;
                  }
                  goto LABEL_57;
                }
LABEL_38:
                ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                std::__shared_weak_count::__release_weak(v18);
                goto LABEL_39;
              }
            }
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            v18[1].__vftable = (std::__shared_weak_count_vtbl *)&v18[1];
            v18[1].__shared_owners_ = (uint64_t)v18;
            if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_39;
            }
            goto LABEL_38;
          }
        }
        dispatch_retain(v16);
        goto LABEL_22;
      }
    }
    dispatch_retain(v16);
    goto LABEL_17;
  }
}

void sub_1A6186A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A6186A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  dispatch::callback<void({block_pointer})(std::string)>::~callback((uint64_t)&a15);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a17);
  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v19);
  dispatch::callback<void({block_pointer})(std::string)>::~callback((uint64_t)&a9);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1A6186AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void diag::DIAGReaderManager::start(diag::DIAGReaderManager *this)
{
  uint64_t v1 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)this + 24;
  if (v1 != (char *)this + 24)
  {
    do
    {
      diag::DIAGReader::start(*((diag::DIAGReader **)v1 + 5));
      uint64_t v3 = (char *)*((void *)v1 + 1);
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = *(char **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (char *)*((void *)v1 + 2);
          BOOL v5 = *(void *)v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != v2);
  }
}

void diag::DIAGReaderManager::stop(diag::DIAGReaderManager *this)
{
  uint64_t v1 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)this + 24;
  if (v1 != (char *)this + 24)
  {
    do
    {
      diag::DIAGReader::stop(*((diag::DIAGReader **)v1 + 5));
      uint64_t v3 = (char *)*((void *)v1 + 1);
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = *(char **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (char *)*((void *)v1 + 2);
          BOOL v5 = *(void *)v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != v2);
  }
}

void diag::DIAGReaderManager::startIfNotStarted(diag::DIAGReaderManager *this)
{
  uint64_t v1 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)this + 24;
  if (v1 != (char *)this + 24)
  {
    do
    {
      uint64_t v3 = (diag::DIAGReader *)*((void *)v1 + 5);
      uint64_t v4 = *(void *)(*((void *)v3 + 2) + 24);
      if (!*(unsigned char *)(v4 + 332) || *(_DWORD *)(v4 + 328) != 1) {
        diag::DIAGReader::start(v3);
      }
      BOOL v5 = (char *)*((void *)v1 + 1);
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          BOOL v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (char *)*((void *)v1 + 2);
          BOOL v7 = *(void *)v6 == (void)v1;
          uint64_t v1 = v6;
        }
        while (!v7);
      }
      uint64_t v1 = v6;
    }
    while (v6 != v2);
  }
}

void diag::DIAGReaderManager::snapshot(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v3 = a1 + 24;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v3 && *(_DWORD *)(v6 + 32) <= a2) {
      diag::DIAGReader::snapshot(*(void *)(v6 + 40), a3);
    }
  }
}

uint64_t diag::DIAGReaderManager::wait(uint64_t this, unsigned int a2)
{
  uint64_t v2 = *(void **)(this + 16);
  uint64_t v3 = (void *)(this + 24);
  if (v2 != (void *)(this + 24))
  {
    if (a2 <= 1)
    {
      do
      {
        BOOL v11 = (void *)v2[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            BOOL v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v2[2];
            BOOL v10 = *v12 == (void)v2;
            uint64_t v2 = v12;
          }
          while (!v10);
        }
        uint64_t v2 = v12;
      }
      while (v12 != v3);
    }
    else
    {
      do
      {
        uint64_t v5 = *(void *)(*(void *)(*(void *)(v2[5] + 16) + 24) + 336);
        unsigned int v6 = 2;
        do
        {
          this = usleep(0x7A120u);
          BOOL v7 = v5 == *(void *)(*(void *)(*(void *)(v2[5] + 16) + 24) + 336) || v6++ >= a2;
          uint64_t v5 = *(void *)(*(void *)(*(void *)(v2[5] + 16) + 24) + 336);
        }
        while (!v7);
        BOOL v8 = (void *)v2[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            BOOL v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v2[2];
            BOOL v10 = *v9 == (void)v2;
            uint64_t v2 = v9;
          }
          while (!v10);
        }
        uint64_t v2 = v9;
      }
      while (v9 != v3);
    }
  }
  return this;
}

void diag::DIAGReaderManager::pushInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  uint64_t v4 = (void *)(a1 + 24);
  if (v3 != (void *)(a1 + 24))
  {
    do
    {
      uint64_t v6 = *(void *)(v3[5] + 16);
      uint64_t v8 = *(void *)(v6 + 72);
      BOOL v7 = *(std::__shared_weak_count **)(v6 + 80);
      uint64_t v15 = v8;
      long long v16 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v8) {
        goto LABEL_11;
      }
      if (*(char *)(a3 + 23) < 0) {
        std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
      }
      else {
        std::string v14 = *(std::string *)a3;
      }
      Timestamp::Timestamp((Timestamp *)v12);
      abm::trace::TraceInfo::push();
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)v12, v13);
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v14.__r_.__value_.__l.__data_);
        if (v7)
        {
LABEL_12:
          if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
      }
      else
      {
LABEL_11:
        if (v7) {
          goto LABEL_12;
        }
      }
      uint64_t v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v3[2];
          BOOL v11 = *v10 == (void)v3;
          uint64_t v3 = v10;
        }
        while (!v11);
      }
      uint64_t v3 = v10;
    }
    while (v10 != v4);
  }
}

void sub_1A6186F64(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 80);
  _Unwind_Resume(a1);
}

void sub_1A6186F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a22, a23);
  if (a30 < 0) {
    operator delete(a25);
  }
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v30 - 80);
  _Unwind_Resume(a1);
}

void diag::DIAGReaderManager::pushInfo(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  uint64_t v4 = (void *)(a1 + 24);
  if (v3 != (void *)(a1 + 24))
  {
    do
    {
      uint64_t v6 = *(void *)(v3[5] + 16);
      uint64_t v8 = *(void *)(v6 + 72);
      BOOL v7 = *(std::__shared_weak_count **)(v6 + 80);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v8)
      {
        xpc_object_t object = *a3;
        if (*a3) {
          xpc_retain(*a3);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        abm::trace::TraceInfo::push();
        xpc_release(object);
      }
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        uint64_t v9 = (void *)v3[1];
        if (!v9)
        {
          do
          {
LABEL_17:
            BOOL v10 = (void *)v3[2];
            BOOL v11 = *v10 == (void)v3;
            uint64_t v3 = v10;
          }
          while (!v11);
          goto LABEL_3;
        }
      }
      else
      {
        uint64_t v9 = (void *)v3[1];
        if (!v9) {
          goto LABEL_17;
        }
      }
      do
      {
        BOOL v10 = v9;
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
LABEL_3:
      uint64_t v3 = v10;
    }
    while (v10 != v4);
  }
}

void sub_1A6187114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void diag::DIAGReaderManager::pushInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 16);
  uint64_t v3 = (void *)(a1 + 24);
  if (v2 != (void *)(a1 + 24))
  {
    uint64_t v5 = (std::string *)(a2 + 32);
    uint64_t v6 = (int *)(a2 + 16);
    do
    {
      uint64_t v7 = *(void *)(v2[5] + 16);
      uint64_t v9 = *(void *)(v7 + 72);
      uint64_t v8 = *(std::__shared_weak_count **)(v7 + 80);
      uint64_t v16 = v9;
      uint64_t v17 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v9) {
        goto LABEL_11;
      }
      if (*(char *)(a2 + 55) < 0) {
        std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
      }
      else {
        std::string v15 = *v5;
      }
      v14[0] = 0;
      v14[1] = 0;
      uint64_t v13 = v14;
      std::map<Timestamp::TimeDomain,timeval>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<Timestamp::TimeDomain,timeval>,std::__tree_node<std::__value_type<Timestamp::TimeDomain,timeval>,void *> *,long>>>((uint64_t *)&v13, *(int **)(a2 + 8), v6);
      abm::trace::TraceInfo::push();
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&v13, v14[0]);
      if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v15.__r_.__value_.__l.__data_);
        if (v8)
        {
LABEL_12:
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      else
      {
LABEL_11:
        if (v8) {
          goto LABEL_12;
        }
      }
      BOOL v10 = (void *)v2[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v2[2];
          BOOL v12 = *v11 == (void)v2;
          uint64_t v2 = v11;
        }
        while (!v12);
      }
      uint64_t v2 = v11;
    }
    while (v11 != v3);
  }
}

void sub_1A6187318(_Unwind_Exception *a1)
{
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v1 - 96);
  _Unwind_Resume(a1);
}

void sub_1A618732C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0)
    {
LABEL_3:
      std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a22, a23);
      if ((a30 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  std::__tree<std::__value_type<Timestamp::TimeDomain,timeval>,std::__map_value_compare<Timestamp::TimeDomain,std::__value_type<Timestamp::TimeDomain,timeval>,std::less<Timestamp::TimeDomain>,true>,std::allocator<std::__value_type<Timestamp::TimeDomain,timeval>>>::destroy((uint64_t)&a22, a23);
  if ((a30 & 0x80000000) == 0)
  {
LABEL_4:
    std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v30 - 96);
    _Unwind_Resume(a1);
  }
LABEL_7:
  operator delete(a25);
  std::shared_ptr<ctu::LogMessage>::~shared_ptr[abi:ne180100](v30 - 96);
  _Unwind_Resume(a1);
}

TraceFileCollection *diag::DIAGReaderManager::setHistory(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = (TraceFileCollection *)(a1 + 24);
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t v5 = (TraceFileCollection *)v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != result && *((_DWORD *)v5 + 8) <= a2)
    {
      uint64_t result = *(TraceFileCollection **)(*((void *)v5 + 5) + 32);
      if (result) {
        return (TraceFileCollection *)TraceFileCollection::setHistory(result);
      }
    }
  }
  return result;
}

TraceFileCollection *diag::DIAGReaderManager::setMaxMemoryFile(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = (TraceFileCollection *)(a1 + 24);
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t v5 = (TraceFileCollection *)v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != result && *((_DWORD *)v5 + 8) <= a2)
    {
      uint64_t result = *(TraceFileCollection **)(*((void *)v5 + 5) + 32);
      if (result) {
        return (TraceFileCollection *)TraceFileCollection::setMaxMemoryFileCount(result);
      }
    }
  }
  return result;
}

void diag::DIAGReaderManager::setStallHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  uint64_t v4 = (void *)(a1 + 24);
  if (v3 != (void *)(a1 + 24))
  {
    do
    {
      if (*((_DWORD *)v3 + 8) == 1) {
        goto LABEL_18;
      }
      uint64_t v6 = *(void *)(v3[5] + 16);
      uint64_t v8 = *(void *)(v6 + 72);
      BOOL v7 = *(std::__shared_weak_count **)(v6 + 80);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v8)
      {
        uint64_t v9 = *(void **)a3;
        if (*(void *)a3) {
          uint64_t v9 = _Block_copy(v9);
        }
        BOOL v10 = *(NSObject **)(a3 + 8);
        aBlocuint64_t k = v9;
        xpc_object_t object = v10;
        if (v10) {
          dispatch_retain(v10);
        }
        abm::trace::TraceInfo::setHandler();
        if (object) {
          dispatch_release(object);
        }
        if (aBlock) {
          _Block_release(aBlock);
        }
      }
      if (!v7 || atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
LABEL_18:
        BOOL v11 = (void *)v3[1];
        if (!v11) {
          goto LABEL_22;
        }
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
        BOOL v11 = (void *)v3[1];
        if (!v11)
        {
          do
          {
LABEL_22:
            BOOL v12 = (void *)v3[2];
            BOOL v13 = *v12 == (void)v3;
            uint64_t v3 = v12;
          }
          while (!v13);
          goto LABEL_3;
        }
      }
      do
      {
        BOOL v12 = v11;
        BOOL v11 = (void *)*v11;
      }
      while (v11);
LABEL_3:
      uint64_t v3 = v12;
    }
    while (v12 != v4);
  }
}

void sub_1A61875CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

TraceFileCollection *diag::DIAGReaderManager::setFileSize(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = (TraceFileCollection *)(a1 + 24);
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t v5 = (TraceFileCollection *)v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != result && *((_DWORD *)v5 + 8) <= a2)
    {
      uint64_t result = *(TraceFileCollection **)(*((void *)v5 + 5) + 32);
      if (result) {
        return (TraceFileCollection *)TraceFileCollection::setFileSize(result);
      }
    }
  }
  return result;
}

void diag::DIAGReaderManager::shutdown(diag::DIAGReaderManager *this)
{
  uint64_t v1 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)this + 24;
  if (v1 != (char *)this + 24)
  {
    do
    {
      diag::DIAGReader::shutdown(*((diag::DIAGReader **)v1 + 5));
      uint64_t v3 = (char *)*((void *)v1 + 1);
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = *(char **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (char *)*((void *)v1 + 2);
          BOOL v5 = *(void *)v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != v2);
  }
}

TraceFileCollection *diag::DIAGReaderManager::archive(TraceFileCollection *this)
{
  uint64_t v1 = (void *)*((void *)this + 2);
  uint64_t v2 = (void *)((char *)this + 24);
  if (v1 != (void *)((char *)this + 24))
  {
    do
    {
      this = *(TraceFileCollection **)(v1[5] + 32);
      if (this) {
        this = (TraceFileCollection *)TraceFileCollection::archive(this);
      }
      uint64_t v3 = (void *)v1[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v1[2];
          BOOL v5 = *v4 == (void)v1;
          uint64_t v1 = v4;
        }
        while (!v5);
      }
      uint64_t v1 = v4;
    }
    while (v4 != v2);
  }
  return this;
}

uint64_t diag::DIAGReaderManager::getCurrentIndex(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v2 = a1 + 24;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    unsigned int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 != v2 && *(_DWORD *)(v5 + 32) <= a2 && *(void *)(*(void *)(v5 + 40) + 32)) {
    return MEMORY[0x1F410C7E8]();
  }
  else {
    return 0;
  }
}

void std::__shared_ptr_emplace<diag::DIAGReader>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DA90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<diag::DIAGReader>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DA90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<diag::DIAGReader>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler,std::allocator<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DAE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler,std::allocator<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DAE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler,std::allocator<diag::DIAGReader::Parameters::create(BasebandTransport::Protocol,std::shared_ptr<BasebandTransport>,std::shared_ptr<ETLDIAGGUIDParameter>,std::shared_ptr<ctu::LogServer>,int,char const*,unsigned int,unsigned int)::make_shared_enabler>>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 215) < 0)
  {
    operator delete(*(void **)(a1 + 192));
    if ((*(char *)(a1 + 191) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = *(void **)(a1 + 144);
      if (!v2) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((*(char *)(a1 + 191) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(a1 + 168));
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
LABEL_4:
    *(void *)(a1 + 152) = v2;
    operator delete(v2);
  }
LABEL_5:
  if (*(char *)(a1 + 143) < 0)
  {
    operator delete(*(void **)(a1 + 120));
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
    if (!v3) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
    if (!v3)
    {
LABEL_13:
      uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
      if (!v4) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
  }
  if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_13;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v4) {
    goto LABEL_17;
  }
LABEL_14:
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_17:
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    unsigned int v6 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v6) {
      goto LABEL_23;
    }
  }
  else
  {
    unsigned int v6 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v6) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_23:
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7)
  {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void ___ZNK8dispatch8callbackIU13block_pointerFvNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEclIJS7_EEEvDpT__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 63) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 40), *(void *)(a1 + 48));
  }
  else {
    std::string __p = *(std::string *)(a1 + 40);
  }
  (*(void (**)(uint64_t, std::string *))(v1 + 16))(v1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1A6187AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_32c106_ZTSN8dispatch5blockIU13block_pointerFvNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEE40c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 32);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 32) = v4;
  uint64_t v5 = (std::string *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
}

void sub_1A6187B4C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(const void **)(v1 + 32);
  if (v3) {
    _Block_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c106_ZTSN8dispatch5blockIU13block_pointerFvNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEE40c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
  {
    operator delete(*(void **)(a1 + 40));
    uint64_t v2 = *(const void **)(a1 + 32);
    if (!v2) {
      return;
    }
    goto LABEL_5;
  }
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
LABEL_5:
  }
    _Block_release(v2);
}

void std::__shared_ptr_emplace<diag::DIAGReaderManager>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DB60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<diag::DIAGReaderManager>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EFB0DB60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_emplace<diag::DIAGReaderManager>::__on_zero_shared(uint64_t a1)
{
  std::__tree<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::__map_value_compare<abm::helper::TaskID,std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>,std::less<abm::helper::TaskID>,true>,std::allocator<std::__value_type<abm::helper::TaskID,std::shared_ptr<abm::HelperTask>>>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t _GLOBAL__sub_I_DIAGReader_cpp()
{
  uint64_t result = ETLDIAGLoggingGetDefaultView();
  kETLDIAGLoggingDefaultView = result;
  return result;
}

const char *abm::helper::asString(int a1)
{
  uint64_t v1 = "mobile";
  uint64_t v2 = "";
  if (a1 == 25) {
    uint64_t v2 = "wireless";
  }
  if (a1 != 501) {
    uint64_t v1 = v2;
  }
  if (a1) {
    return v1;
  }
  else {
    return "root";
  }
}

{
  if ((a1 - 1) > 9) {
    return "invalid";
  }
  else {
    return off_1E5C48298[a1 - 1];
  }
}

{
  if ((a1 - 1) > 4) {
    return "Unknown";
  }
  else {
    return off_1E5C48340[a1 - 1];
  }
}

const char *abm::helper::asString(unsigned int a1)
{
  if (a1 > 2) {
    return "invalid";
  }
  else {
    return off_1E5C482E8[a1];
  }
}

{
  if (a1 > 7) {
    return "Invalid";
  }
  else {
    return off_1E5C48300[a1];
  }
}

uint64_t abm::helper::asEnum(abm::helper *this, const char *a2)
{
  uint64_t v3 = (const char **)off_1E5C48338;
  unsigned int v4 = -1;
  while (1)
  {
    uint64_t v5 = "Unknown";
    if (v4 <= 4) {
      uint64_t v5 = *v3;
    }
    size_t v6 = strlen(v5);
    if (v6 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v7 = v6;
    if (v6 >= 0x17)
    {
      uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17) {
        uint64_t v9 = v6 | 7;
      }
      uint64_t v10 = v9 + 1;
      uint64_t v8 = operator new(v9 + 1);
      __dst[1] = v7;
      int64_t v27 = v10 | 0x8000000000000000;
      __dst[0] = v8;
LABEL_11:
      memcpy(v8, v5, v7);
      goto LABEL_12;
    }
    HIBYTE(v27) = v6;
    uint64_t v8 = __dst;
    if (v6) {
      goto LABEL_11;
    }
LABEL_12:
    *((unsigned char *)v8 + v7) = 0;
    size_t v11 = strlen((const char *)this);
    if (v11 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v12 = v11;
    if (v11 >= 0x17)
    {
      uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v14 = v11 | 7;
      }
      uint64_t v15 = v14 + 1;
      BOOL v13 = operator new(v14 + 1);
      v24[1] = v12;
      int64_t v25 = v15 | 0x8000000000000000;
      v24[0] = v13;
LABEL_19:
      memcpy(v13, this, v12);
      goto LABEL_20;
    }
    HIBYTE(v25) = v11;
    BOOL v13 = v24;
    if (v11) {
      goto LABEL_19;
    }
LABEL_20:
    *((unsigned char *)v13 + v12) = 0;
    int v16 = SHIBYTE(v27);
    uint64_t v17 = (void *)__dst[0];
    long long v18 = v27 >= 0 ? (const char *)__dst : (const char *)__dst[0];
    int v19 = SHIBYTE(v25);
    std::string::size_type v20 = (void *)v24[0];
    uint64_t v21 = v25 >= 0 ? (const char *)v24 : (const char *)v24[0];
    int v22 = strcasecmp(v18, v21);
    if (v19 < 0) {
      break;
    }
    if (v16 < 0) {
      goto LABEL_31;
    }
LABEL_28:
    if (!v22) {
      return v4 + 1;
    }
LABEL_32:
    ++v3;
    if (++v4 == 5) {
      return 0;
    }
  }
  operator delete(v20);
  if ((v16 & 0x80000000) == 0) {
    goto LABEL_28;
  }
LABEL_31:
  operator delete(v17);
  if (v22) {
    goto LABEL_32;
  }
  return v4 + 1;
}

void sub_1A6187F40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

size_t abm::helper::asString@<X0>(size_t result@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v2 = a2;
  if (!result)
  {
    a2[23] = 3;
    *(_WORD *)a2 = 26223;
    a2[2] = 102;
    a2[3] = 0;
    return result;
  }
  if (result == 2)
  {
    uint64_t v3 = abm::trace::kLogTarExtension[0];
    uint64_t result = strlen(abm::trace::kLogTarExtension[0]);
    if (result <= 0x7FFFFFFFFFFFFFF7)
    {
      size_t v4 = result;
      if (result >= 0x17)
      {
        uint64_t v7 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((result | 7) != 0x17) {
          uint64_t v7 = result | 7;
        }
        uint64_t v8 = v7 + 1;
        uint64_t v9 = operator new(v7 + 1);
        v2[1] = v4;
        v2[2] = v8 | 0x8000000000000000;
        *uint64_t v2 = v9;
        uint64_t v2 = v9;
      }
      else
      {
        *((unsigned char *)v2 + 23) = result;
        if (!result) {
          goto LABEL_16;
        }
      }
      uint64_t result = (size_t)memmove(v2, v3, v4);
LABEL_16:
      *((unsigned char *)v2 + v4) = 0;
      return result;
    }
LABEL_21:
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = abm::trace::kLogTarGzExtension;
  uint64_t result = strlen(abm::trace::kLogTarGzExtension);
  if (result > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_21;
  }
  size_t v6 = result;
  if (result >= 0x17)
  {
    uint64_t v10 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v10 = result | 7;
    }
    uint64_t v11 = v10 + 1;
    size_t v12 = operator new(v10 + 1);
    v2[1] = v6;
    v2[2] = v11 | 0x8000000000000000;
    *uint64_t v2 = v12;
    uint64_t v2 = v12;
  }
  else
  {
    *((unsigned char *)v2 + 23) = result;
    if (!result)
    {
      *(unsigned char *)uint64_t v2 = 0;
      return result;
    }
  }
  uint64_t result = (size_t)memmove(v2, v5, v6);
  *((unsigned char *)v2 + v6) = 0;
  return result;
}

double EURCoreDumpTrace::createInternal@<D0>(void *a1@<X8>)
{
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  a1[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = (EURCoreDumpTrace *)operator new(0xD8uLL);
  EURCoreDumpTrace::EURCoreDumpTrace(v3);
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  std::shared_ptr<EURCoreDumpTrace>::shared_ptr[abi:ne180100]<EURCoreDumpTrace,std::shared_ptr<EURCoreDumpTrace> ctu::SharedSynchronizable<Trace>::make_shared_ptr<EURCoreDumpTrace>(EURCoreDumpTrace*)::{lambda(EURCoreDumpTrace*)#1},void>(&v5, (uint64_t)v3);
  ctu::Loggable<Trace,ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>>::connectToLogServer_sync(v5);
  double result = *(double *)&v5;
  *(_OWORD *)a1 = v5;
  return result;
}

void sub_1A6188160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A6188174(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void EURCoreDumpTrace::EURCoreDumpTrace(EURCoreDumpTrace *this)
{
  char v11 = 14;
  strcpy((char *)__p, "trace.coredump");
  Trace::Trace((uint64_t)this, (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  *(void *)this = &unk_1EFB0DBB0;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 161) = 0;
  uint64_t v2 = (CommandDriverFactory *)pthread_mutex_lock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  uint64_t v3 = off_1EB5EE540;
  if (!off_1EB5EE540)
  {
    CommandDriverFactory::create_default_global((uint64_t *)&v12, v2);
    long long v4 = v12;
    long long v12 = 0uLL;
    long long v5 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
    off_1EB5EE540 = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    size_t v6 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    if (*((void *)&v12 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v12 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v3 = off_1EB5EE540;
  }
  uint64_t v7 = (std::__shared_weak_count *)*(&off_1EB5EE540 + 1);
  if (*(&off_1EB5EE540 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_1EB5EE540 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  uint64_t v8 = (capabilities::coredump *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 112))(v3);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v9 = (capabilities::trace *)capabilities::coredump::coredumpAttemptCount(v8);
  *((_DWORD *)this + 46) = v9;
  *((void *)this + 24) = (char *)this + 192;
  *((void *)this + 25) = (char *)this + 192;
  *((void *)this + 26) = 0;
  *((unsigned char *)this + 160) = capabilities::trace::allowed(v9);
}

void sub_1A6188394(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<CommandDriverFactory,CommandDriverFactory,ctu::PthreadMutexGuardPolicy<CommandDriverFactory>>::sInstance);
  Trace::~Trace(v1);
  _Unwind_Resume(a1);
}

void sub_1A61883F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1A61883ECLL);
}

uint64_t *std::list<boost::signals2::connection>::~list(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        long long v5 = (uint64_t *)v3[1];
        size_t v6 = (atomic_uint *)v3[3];
        if (v6 && atomic_fetch_add(v6 + 3, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 24))(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
  return a1;
}

void EURCoreDumpTrace::~EURCoreDumpTrace(EURCoreDumpTrace *this)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EFB0DBB0;
  uint64_t v2 = (char *)this + 192;
  uint64_t v3 = (char *)*((void *)this + 25);
  if (v3 != (char *)this + 192)
  {
    do
    {
      uint64_t v4 = (atomic_uint *)*((void *)v3 + 3);
      if (v4)
      {
        uint64_t v5 = v4[2];
        while (v5)
        {
          uint64_t v6 = v5;
          atomic_compare_exchange_strong_explicit(v4 + 2, (unsigned int *)&v6, v5 + 1, memory_order_relaxed, memory_order_relaxed);
          BOOL v7 = v6 == v5;
          uint64_t v5 = v6;
          if (v7)
          {
            uint64_t v8 = *((void *)v3 + 2);
            if (v8)
            {
              *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v31[8] = v9;
              v31[9] = v9;
              v31[6] = v9;
              v31[7] = v9;
              uint8_t v31[4] = v9;
              v31[5] = v9;
              void v31[2] = v9;
              dispatch_object_t v31[3] = v9;
              v31[0] = v9;
              v31[1] = v9;
              unint64_t v32 = 10;
              std::string __p = v31;
              uint64_t v34 = 0;
              uint64_t v35 = v8;
              (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
              if (*(unsigned char *)(v8 + 24))
              {
                *(unsigned char *)(v8 + 24) = 0;
                int v10 = *(_DWORD *)(v8 + 28) - 1;
                *(_DWORD *)(v8 + 28) = v10;
                if (!v10)
                {
                  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v8 + 40))(&v30, v8);
                  uint64_t v14 = v34;
                  if (v34 == v32 && v34 != -1)
                  {
                    if (4 * v34 <= (unint64_t)(v34 + 1)) {
                      unint64_t v15 = v34 + 1;
                    }
                    else {
                      unint64_t v15 = 4 * v34;
                    }
                    boost::signals2::detail::auto_buffer<boost::shared_ptr<void>,boost::signals2::detail::store_n_objects<10u>,boost::signals2::detail::default_grow_policy,std::allocator<boost::shared_ptr<void>>>::reserve_impl((uint64_t)v31, v15);
                    uint64_t v14 = v34;
                  }
                  uint64_t v16 = *((void *)&v30 + 1);
                  *((_OWORD *)__p + v14) = v30;
                  if (v16)
                  {
                    atomic_fetch_add_explicit((atomic_uint *volatile)(v16 + 8), 1u, memory_order_relaxed);
                    uint64_t v14 = v34;
                  }
                  uint64_t v34 = v14 + 1;
                  uint64_t v17 = (atomic_uint *)*((void *)&v30 + 1);
                  if (*((void *)&v30 + 1))
                  {
                    if (atomic_fetch_add((atomic_uint *volatile)(*((void *)&v30 + 1) + 8), 0xFFFFFFFF) == 1)
                    {
                      (*(void (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
                      if (atomic_fetch_add(v17 + 3, 0xFFFFFFFF) == 1) {
                        (*(void (**)(atomic_uint *))(*(void *)v17 + 24))(v17);
                      }
                    }
                  }
                }
              }
              (*(void (**)(uint64_t))(*(void *)v35 + 32))(v35);
              char v11 = (char *)__p;
              if (__p)
              {
                if (v34 - 1 >= 0)
                {
                  long long v12 = (char *)__p + 16 * v34;
                  do
                  {
                    BOOL v13 = (atomic_uint *)*((void *)v12 - 1);
                    if (v13)
                    {
                      if (atomic_fetch_add(v13 + 2, 0xFFFFFFFF) == 1)
                      {
                        (*(void (**)(atomic_uint *))(*(void *)v13 + 16))(v13);
                        if (atomic_fetch_add(v13 + 3, 0xFFFFFFFF) == 1) {
                          (*(void (**)(atomic_uint *))(*(void *)v13 + 24))(v13);
                        }
                      }
                    }
                    v12 -= 16;
                  }
                  while (v12 > v11);
                }
                if (v32 >= 0xB) {
                  operator delete(__p);
                }
              }
            }
            if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1)
            {
              (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
              if (atomic_fetch_add(v4 + 3, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v4 + 24))(v4);
              }
            }
            break;
          }
        }
      }
      uint64_t v3 = (char *)*((void *)v3 + 1);
    }
    while (v3 != v2);
  }
  if (*((void *)this + 26))
  {
    uint64_t v18 = *((void *)this + 24);
    int v19 = (char *)*((void *)this + 25);
    uint64_t v20 = *(void *)v19;
    *(void *)(v20 + 8) = *(void *)(v18 + 8);
    **(void **)(v18 + 8) = v20;
    *((void *)this + 26) = 0;
    if (v19 != v2)
    {
      do
      {
        uint64_t v21 = (char *)*((void *)v19 + 1);
        int v22 = (atomic_uint *)*((void *)v19 + 3);
        if (v22 && atomic_fetch_add(v22 + 3, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v22 + 24))(v22);
        }
        operator delete(v19);
        int v19 = v21;
      }
      while (v21 != v2);
    }
  }
  uint64_t v23 = *((void *)this + 19);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  if (*((void *)this + 26))
  {
    uint64_t v24 = *((void *)this + 24);
    int64_t v25 = (char *)*((void *)this + 25);
    uint64_t v26 = *(void *)v25;
    *(void *)(v26 + 8) = *(void *)(v24 + 8);
    **(void **)(v24 + 8) = v26;
    *((void *)this + 26) = 0;
    if (v25 != v2)
    {
      do
      {
        int64_t v27 = (char *)*((void *)v25 + 1);
        unsigned __int8 v28 = (atomic_uint *)*((void *)v25 + 3);
        if (v28 && atomic_fetch_add(v28 + 3, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v28 + 24))(v28);
        }
        operator delete(v25);
        int64_t v25 = v27;
      }
      while (v27 != v2);
    }
  }
  int v29 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }

  Trace::~Trace(this);
}

{
  void *v1;
  uint64_t vars8;

  EURCoreDumpTrace::~EURCoreDumpTrace(this);

  operator delete(v1);
}

void sub_1A6188A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35)
{
  if (a2)
  {
    boost::shared_ptr<void>::~shared_ptr((uint64_t)&a11);
    boost::signals2::detail::garbage_collecting_lock<boost::signals2::detail::connection_body_base>::~garbage_collecting_lock((uint64_t)&a13);
    boost::shared_ptr<boost::signals2::detail::connection_body_base>::~shared_ptr((uint64_t)&a9);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EURCoreDumpTrace::init(void *a1, uint64_t a2, uint64_t *a3, NSObject **a4)
{
  uint64_t v579 = *MEMORY[0x1E4F143B8];
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    uint64_t v6 = (uint64_t)a1;
    std::string v544 = *(std::string *)a2;
    BOOL v7 = (std::__shared_weak_count *)a3[1];
    uint64_t v542 = *a3;
    v543 = v7;
    if (!v7) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  std::string::__init_copy_ctor_external(&v544, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  uint64_t v6 = (uint64_t)a1;
  BOOL v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v542 = *a3;
  v543 = v7;
  if (v7) {
LABEL_3:
  }
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
LABEL_4:
  uint64_t v8 = *a4;
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  uint64_t v9 = Trace::init(v6, (void **)&v544.__r_.__value_.__l.__data_, &v542, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v543) {
    std::__shared_weak_count::__release_weak(v543);
  }
  if ((SHIBYTE(v544.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v9) {
      return v9;
    }
LABEL_16:
    unsigned int v523 = v9;
    int v10 = abm::trace::kScratchFolder[0];
    size_t v11 = strlen(abm::trace::kScratchFolder[0]);
    if (v11 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v12 = v11;
    if (v11 >= 0x17)
    {
      uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v14 = v11 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_dst = (long long *)operator new(v14 + 1);
      *((void *)&__dst + 1) = v12;
      *(void *)&long long v555 = v15 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      BYTE7(v555) = v11;
      p_dst = &__dst;
      if (!v11)
      {
LABEL_24:
        *((unsigned char *)p_dst + v12) = 0;
        uint64_t v16 = EURCoreDumpTrace::kCoreDumpScratchFolder[0];
        size_t v17 = strlen(EURCoreDumpTrace::kCoreDumpScratchFolder[0]);
        if (v17 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        size_t v18 = v17;
        if (v17 >= 0x17)
        {
          uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v17 | 7) != 0x17) {
            uint64_t v20 = v17 | 7;
          }
          uint64_t v21 = v20 + 1;
          uint64_t p_p = operator new(v20 + 1);
          uint64_t v546 = v18;
          int64_t v547 = v21 | 0x8000000000000000;
          std::string __p = p_p;
        }
        else
        {
          HIBYTE(v547) = v17;
          uint64_t p_p = &__p;
          if (!v17)
          {
LABEL_32:
            *((unsigned char *)p_p + v18) = 0;
            if (v547 >= 0) {
              int v22 = (const std::string::value_type *)&__p;
            }
            else {
              int v22 = (const std::string::value_type *)__p;
            }
            if (v547 >= 0) {
              std::string::size_type v23 = HIBYTE(v547);
            }
            else {
              std::string::size_type v23 = v546;
            }
            uint64_t v24 = std::string::append((std::string *)&__dst, v22, v23);
            long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
            *(void *)&long long v566 = *((void *)&v24->__r_.__value_.__l + 2);
            blocuint64_t k = v25;
            v24->__r_.__value_.__l.__size_ = 0;
            v24->__r_.__value_.__r.__words[2] = 0;
            v24->__r_.__value_.__r.__words[0] = 0;
            support::fs::createDir((const char *)&block, 0x1EDu, 1);
            if (SBYTE7(v566) < 0)
            {
              operator delete((void *)block);
              if ((SHIBYTE(v547) & 0x80000000) == 0)
              {
LABEL_40:
                if ((SBYTE7(v555) & 0x80000000) == 0) {
                  goto LABEL_41;
                }
LABEL_45:
                operator delete((void *)__dst);
LABEL_41:
                v540[0] = MEMORY[0x1E4F143A8];
                v540[1] = 0x40000000;
                v540[2] = ___ZN16EURCoreDumpTrace4initENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_8weak_ptrIN3abm19BasebandTracingTaskEEEN8dispatch5groupE_block_invoke;
                v540[3] = &__block_descriptor_tmp_10;
                v540[4] = a1;
                *(void *)&long long __dst = v540;
                *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
                *((void *)&block + 1) = 0x40000000;
                *(void *)&long long v566 = ___ZNK3ctu20SharedSynchronizableI5TraceE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke_4;
                *((void *)&v566 + 1) = &__block_descriptor_tmp_76;
                *(void *)&long long v567 = a1 + 9;
                *((void *)&v567 + 1) = &__dst;
                uint64_t v26 = a1[11];
                if (a1[12]) {
                  dispatch_async_and_wait(v26, &block);
                }
                else {
                  dispatch_sync(v26, &block);
                }
                uint64_t v27 = a1[21];
                std::string __p = (void *)MEMORY[0x1E4F143A8];
                uint64_t v546 = 0x40000000;
                int64_t v547 = (int64_t)___ZN3ctu20SharedSynchronizableI5TraceE13connect_eventIN5boost8signals26signalIFvNSt3__14listIN8coredump13CommandDriver29EURCoreDumpTraceProtocolCrashENS7_9allocatorISB_EEEEENS5_19optional_last_valueIvEEiNS7_4lessIiEENS4_8functionISF_EENSK_IFvRKNS5_10connectionESE_EEENS5_5mutexEEE16EURCoreDumpTracevJSE_EEEDTcl7connectfp_cvNS7_10shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSY_S10_E_block_invoke;
                v548 = &__block_descriptor_tmp_78;
                v549 = a1 + 9;
                v550 = EURCoreDumpTrace::postBootCrashReasonUpdate_sync;
                uint64_t v551 = 0;
                unsigned __int8 v28 = _Block_copy(&__p);
                uint64_t v531 = v27;
                int v29 = (std::__shared_weak_count *)a1[10];
                if (!v29 || (uint64_t v30 = a1[9], (v31 = std::__shared_weak_count::lock(v29)) == 0)) {
                  std::__throw_bad_weak_ptr[abi:ne180100]();
                }
                unint64_t v32 = v31;
                long long v33 = a1[11];
                dispatch_object_t v552 = v33;
                if (v28) {
                  uint64_t v34 = _Block_copy(v28);
                }
                else {
                  uint64_t v34 = 0;
                }
                v553 = v34;
                dispatch_retain(v33);
                long long __dst = 0u;
                long long v555 = 0u;
                dispatch_object_t v558 = v33;
                if (v34) {
                  uint64_t v34 = _Block_copy(v34);
                }
                v559 = v34;
                dispatch_retain(v33);
                dispatch_object_t v560 = v33;
                v524 = v28;
                v526 = v32;
                if (v34)
                {
                  uint64_t v35 = _Block_copy(v34);
                  v561 = v35;
                  dispatch_retain(v33);
                  if (v35)
                  {
                    uint64_t v36 = _Block_copy(v35);
                    dispatch_retain(v33);
                    v562 = 0;
                    if (v36)
                    {
                      std::string::size_type v37 = _Block_copy(v36);
                      dispatch_retain(v33);
                      v512 = v36;
                      if (v37)
                      {
                        uint64_t v38 = _Block_copy(v37);
                        dispatch_retain(v33);
                        aBlocuint64_t k = v37;
                        if (v38)
                        {
                          long long v39 = _Block_copy(v38);
                          dispatch_retain(v33);
                          if (v39)
                          {
                            std::string v40 = _Block_copy(v39);
                            dispatch_retain(v33);
                            unint64_t v563 = (unint64_t)v33;
                            if (v40)
                            {
                              std::string::size_type v41 = _Block_copy(v40);
                              char v42 = 0;
                              char v43 = 0;
                              char v44 = 0;
                              char v45 = 0;
                              char v46 = 0;
LABEL_69:
                              v564 = v41;
                              dispatch_retain(v33);
                              dispatch_release(v33);
                              if ((v46 & 1) == 0) {
                                _Block_release(v40);
                              }
                              dispatch_release(v33);
                              if ((v45 & 1) == 0) {
                                _Block_release(v39);
                              }
                              dispatch_release(v33);
                              if ((v44 & 1) == 0) {
                                _Block_release(v38);
                              }
                              v562 = boost::function1<void,std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>>::assign_to<ctu::DispatchSlot<dispatch::block<void({block_pointer})(std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>)>>>(ctu::DispatchSlot<dispatch::block<void({block_pointer})(std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>)>>)::stored_vtable;
                              dispatch_release(v33);
                              if ((v43 & 1) == 0) {
                                _Block_release(aBlock);
                              }
                              dispatch_release(v33);
                              if ((v42 & 1) == 0) {
                                _Block_release(v512);
                              }
                              *(void *)&long long v566 = 0xAAAAAAAAAAAAAAAALL;
                              *((void *)&v566 + 1) = 0xAAAAAAAAAAAAAAAALL;
                              *(void *)&blocuint64_t k = 0;
                              *((void *)&block + 1) = 0xAAAAAAAAAAAAAAAALL;
                              boost::function1<void,std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>>::move_assign((uint64_t)&block, (uint64_t *)&v562);
                              boost::function1<void,std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>>::move_assign((uint64_t)&v562, (uint64_t *)&v555 + 1);
                              boost::function1<void,std::list<coredump::CommandDriver::EURCoreDumpTraceProtocolCrash>>::move_assign((uint64_t)&v555 + 8, (uint64_t *)&block);
                              if ((void)block)
                              {
                                if ((block & 1) == 0)
                                {
                                  std::string v47 = *(void (**)(char *, char *, uint64_t))(block & 0xFFFFFFFFFFFFFFFELL);
                                  if (v47) {
                                    v47((char *)&block + 8, (char *)&block + 8, 2);
                                  }
                                }
                              }
                              if (v562)
                              {
                                if ((v562 & 1) == 0)
                                {
                                  __int16 v48 = *(void (**)(uint64_t, _WORD *, unsigned int))((unint64_t)v562 & 0xFFFFFFFFFFFFFFFELL);
                                  if (v48) {
                                    v48((uint64_t)&v563, &v563, 2u);
                                  }
                                }
                                v562 = 0;
                              }
                              dispatch_release(v560);
                              if (v561) {
                                _Block_release(v561);
                              }
                              dispatch_release(v558);
                              if (v559) {
                                _Block_release(v559);
                              }
                              atomic_fetch_add_explicit(&v526->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                              unsigned __int8 v49 = operator new(0x18uLL);
                              void *v49 = &unk_1EFB0E178;
                              v49[1] = v30;
                              v49[2] = v526;
                              atomic_fetch_add_explicit(&v526->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                              std::string v50 = operator new(0x18uLL);
                              *std::string v50 = &unk_1EFB0E178;
                              v50[1] = v30;
                              v50[2] = v526;
                              atomic_fetch_add_explicit(&v526->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                              *((void *)&block + 1) = v50;
                              LODWORD(block) = 2;
                              uint64_t v51 = *((void *)&__dst + 1);
                              if (*((void *)&__dst + 1) >= (unint64_t)v555)
                              {
                                std::string v53 = std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__push_back_slow_path<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>((void **)&__dst, (uint64_t)&block);
                              }
                              else
                              {
                                std::string v52 = operator new(0x18uLL);
                                *std::string v52 = &unk_1EFB0E178;
                                v52[1] = v30;
                                v52[2] = v526;
                                atomic_fetch_add_explicit(&v526->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                *(void *)(v51 + 8) = v52;
                                *(_DWORD *)uint64_t v51 = 2;
                                std::string v53 = (_DWORD *)(v51 + 24);
                              }
                              *((void *)&__dst + 1) = v53;
                              boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&block);
                              (*(void (**)(void *))(*v49 + 8))(v49);
                              std::__shared_weak_count::__release_weak(v526);
                              std::string v54 = *(uint64_t ***)(v531 + 136);
                              *(void *)&long long v55 = 0xAAAAAAAAAAAAAAAALL;
                              *((void *)&v55 + 1) = 0xAAAAAAAAAAAAAAAALL;
                              long long v573 = v55;
                              long long v574 = v55;
                              long long v571 = v55;
                              long long v572 = v55;
                              long long v569 = v55;
                              long long v570 = v55;
                              long long v567 = v55;
                              long long v568 = v55;
                              blocuint64_t k = v55;
                              long long v566 = v55;
                              unint64_t v56 = (pthread_mutex_t *)v54[3];
                              unint64_t v575 = 10;
                              p_blocuint64_t k = &block;
                              uint64_t v577 = 0;
                              v578 = v56;
                              pthread_mutex_lock(v56);
                              v562 = (uint64_t (**)())0xAAAAAAAAAAAAAAAALL;
                              unint64_t v563 = 0xAAAAAAAAAAAAAAAALL;
                              dispatch_object_t v57 = (atomic_uint *)v54[1];
                              v532 = (uint64_t ***)v54;
                              if (v57 && atomic_load_explicit(v57 + 2, memory_order_acquire) == 1)
                              {
                                uint64_t v58 = (uint64_t *)**v54;
                                std::string::size_type v59 = v54[2];
                                int v60 = 2;
                                if (v59 != v58)
                                {
LABEL_185:
                                  int v110 = 0;
                                  unsigned int v111 = v60 - 1;
                                  while (1)
                                  {
                                    uint64_t v114 = v59[2];
                                    char v115 = *(uint64_t **)(v114 + 32);
                                    if (!v115) {
                                      goto LABEL_186;
                                    }
                                    for (uint64_t i = *v115; ; i += 24)
                                    {
                                      if (i == v115[1]) {
                                        goto LABEL_186;
                                      }
                                      if ((*(_DWORD *)i ^ (*(int *)i >> 31)) <= 1) {
                                        break;
                                      }
                                      if ((*(uint64_t (**)(void))(**(void **)(i + 8) + 24))(*(void *)(i + 8))) {
                                        goto LABEL_202;
                                      }
LABEL_195:
                                      ;
                                    }
                                    uint64_t v117 = *(void *)(i + 16);
                                    if (v117
                                      && atomic_load_explicit((atomic_uint *volatile)(v117 + 8), memory_order_acquire))
                                    {
                                      goto LABEL_195;
                                    }
LABEL_202:
                                    if (*(unsigned char *)(v114 + 24))
                                    {
                                      *(unsigned char *)(v114 + 24) = 0;
                                      boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)v114, &block);
                                    }
LABEL_186:
                                    uint64_t v112 = v59[2];
                                    if (*(unsigned char *)(v112 + 24))
                                    {
                                      uint64_t v58 = (uint64_t *)v59[1];
                                      goto LABEL_188;
                                    }
                                    uint64_t v118 = **v54;
                                    __int16 v120 = (uint64_t **)(v118 + 32);
                                    timespec v119 = *(char **)(v118 + 32);
                                    if (!v119)
                                    {
                                      if (*(uint64_t **)(v118 + 80) != v59) {
                                        goto LABEL_279;
                                      }
                                      timespec v142 = (uint64_t *)v59[1];
                                      timespec v144 = (uint64_t **)(v118 + 32);
                                      timespec v123 = (uint64_t *)(v118 + 32);
                                      if (v142 != (uint64_t *)v118) {
                                        goto LABEL_275;
                                      }
                                      goto LABEL_257;
                                    }
                                    int v121 = *(_DWORD *)(v112 + 64);
                                    int v122 = *(_DWORD *)(v112 + 72);
                                    timespec v123 = (uint64_t *)(v118 + 32);
                                    uint64_t v124 = *(void *)(v118 + 32);
                                    if (v121 == 1)
                                    {
                                      timespec v123 = (uint64_t *)(v118 + 32);
                                      uint64_t v125 = *(void *)(v118 + 32);
                                      do
                                      {
                                        while (1)
                                        {
                                          int v131 = *(_DWORD *)(v125 + 32);
                                          BOOL v132 = v131 < 1;
                                          if (v131 == 1) {
                                            BOOL v132 = *(_DWORD *)(v125 + 40) < v122;
                                          }
                                          if (!v132) {
                                            break;
                                          }
                                          uint64_t v125 = *(void *)(v125 + 8);
                                          if (!v125) {
                                            goto LABEL_223;
                                          }
                                        }
                                        timespec v123 = (uint64_t *)v125;
                                        uint64_t v125 = *(void *)v125;
                                      }
                                      while (v125);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        int v126 = *(_DWORD *)(v124 + 32);
                                        BOOL v127 = v126 == v121;
                                        BOOL v128 = v126 < v121;
                                        if (v126 >= v121) {
                                          __int16 v129 = (uint64_t *)v124;
                                        }
                                        else {
                                          __int16 v129 = (uint64_t *)(v124 + 8);
                                        }
                                        if (v128) {
                                          long long v130 = v123;
                                        }
                                        else {
                                          long long v130 = (uint64_t *)v124;
                                        }
                                        if (v127)
                                        {
                                          __int16 v129 = (uint64_t *)v124;
                                          timespec v123 = (uint64_t *)v124;
                                        }
                                        else
                                        {
                                          timespec v123 = v130;
                                        }
                                        uint64_t v124 = *v129;
                                      }
                                      while (*v129);
                                    }
LABEL_223:
                                    if ((uint64_t *)v123[6] == v59)
                                    {
                                      uint64_t v133 = (uint64_t **)(v118 + 32);
                                      v134 = *(uint64_t ***)(v118 + 32);
                                      if (v121 != 1)
                                      {
                                        do
                                        {
                                          int v135 = *((_DWORD *)v134 + 8);
                                          v136 = (uint64_t ***)(v134 + 1);
                                          BOOL v137 = v121 == v135;
                                          BOOL v138 = v121 < v135;
                                          if (v121 >= v135) {
                                            timespec v139 = (uint64_t ***)(v134 + 1);
                                          }
                                          else {
                                            timespec v139 = (uint64_t ***)v134;
                                          }
                                          if (!v138) {
                                            v134 = v133;
                                          }
                                          if (v137) {
                                            timespec v139 = v136;
                                          }
                                          else {
                                            uint64_t v133 = v134;
                                          }
                                          v134 = *v139;
                                        }
                                        while (*v139);
LABEL_241:
                                        timespec v141 = (uint64_t *)v118;
                                        if (v133 != v120) {
                                          timespec v141 = v133[6];
                                        }
                                        timespec v142 = (uint64_t *)v59[1];
                                        if (v142 != v141)
                                        {
                                          if (v121 != 1)
                                          {
                                            int v143 = *((_DWORD *)v119 + 8);
                                            if (v121 == v143) {
                                              goto LABEL_278;
                                            }
                                            while (1)
                                            {
                                              if (v121 < v143)
                                              {
                                                uint64_t v150 = *(void *)v119;
                                                if (!*(void *)v119)
                                                {
                                                  __int16 v120 = (uint64_t **)v119;
LABEL_274:
                                                  timespec v144 = (uint64_t **)v119;
LABEL_275:
                                                  timespec v119 = (char *)operator new(0x38uLL);
                                                  uint64_t v151 = *(void *)(v112 + 64);
                                                  *((_DWORD *)v119 + 10) = *(_DWORD *)(v112 + 72);
                                                  *((void *)v119 + 4) = v151;
                                                  *((void *)v119 + 6) = 0;
                                                  *(void *)timespec v119 = 0;
                                                  *((void *)v119 + 1) = 0;
                                                  *((void *)v119 + 2) = v144;
                                                  *__int16 v120 = (uint64_t *)v119;
                                                  uint64_t v152 = **(void **)(v118 + 24);
                                                  long long v153 = (uint64_t *)v119;
                                                  if (v152)
                                                  {
                                                    *(void *)(v118 + 24) = v152;
                                                    long long v153 = *v120;
                                                  }
                                                  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v118 + 32), v153);
                                                  ++*(void *)(v118 + 40);
LABEL_278:
                                                  *((void *)v119 + 6) = v142;
                                                  goto LABEL_279;
                                                }
                                              }
                                              else
                                              {
                                                if (v143 >= v121) {
                                                  goto LABEL_278;
                                                }
                                                uint64_t v150 = *((void *)v119 + 1);
                                                if (!v150)
                                                {
                                                  __int16 v120 = (uint64_t **)(v119 + 8);
                                                  goto LABEL_274;
                                                }
                                              }
                                              int v143 = *(_DWORD *)(v150 + 32);
                                              timespec v119 = (char *)v150;
                                              if (v121 == v143)
                                              {
                                                *(void *)(v150 + 48) = v142;
                                                goto LABEL_279;
                                              }
                                            }
                                          }
                                          while (1)
                                          {
                                            timespec v144 = (uint64_t **)v119;
                                            int v145 = *((_DWORD *)v119 + 8);
                                            if (v145 == 1)
                                            {
                                              int v146 = *((_DWORD *)v119 + 10);
                                              if (v146 <= v122)
                                              {
                                                if (v146 >= v122)
                                                {
                                                  *((void *)v119 + 6) = v142;
                                                  goto LABEL_279;
                                                }
LABEL_253:
                                                timespec v119 = (char *)*((void *)v119 + 1);
                                                if (!v119)
                                                {
                                                  __int16 v120 = v144 + 1;
                                                  goto LABEL_275;
                                                }
                                                continue;
                                              }
                                            }
                                            else if (v145 <= 1)
                                            {
                                              goto LABEL_253;
                                            }
                                            timespec v119 = *(char **)v119;
                                            if (!*v144)
                                            {
                                              __int16 v120 = v144;
                                              goto LABEL_275;
                                            }
                                          }
                                        }
LABEL_257:
                                        std::string v147 = (uint64_t *)v123[1];
                                        uint64_t v148 = v123;
                                        if (v147)
                                        {
                                          do
                                          {
                                            long long v149 = v147;
                                            std::string v147 = (uint64_t *)*v147;
                                          }
                                          while (v147);
                                        }
                                        else
                                        {
                                          do
                                          {
                                            long long v149 = (uint64_t *)v148[2];
                                            BOOL v127 = *v149 == (void)v148;
                                            uint64_t v148 = v149;
                                          }
                                          while (!v127);
                                        }
                                        if (*(uint64_t **)(v118 + 24) == v123) {
                                          *(void *)(v118 + 24) = v149;
                                        }
                                        --*(void *)(v118 + 40);
                                        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v119, v123);
                                        operator delete(v123);
                                        goto LABEL_279;
                                      }
                                      while (1)
                                      {
                                        int v140 = *((_DWORD *)v134 + 8);
                                        if (v140 == 1)
                                        {
                                          if (v122 >= *((_DWORD *)v134 + 10)) {
                                            goto LABEL_235;
                                          }
                                        }
                                        else if (v140 <= 1)
                                        {
LABEL_235:
                                          v134 = (uint64_t **)v134[1];
                                          if (!v134) {
                                            goto LABEL_241;
                                          }
                                          continue;
                                        }
                                        uint64_t v133 = v134;
                                        v134 = (uint64_t **)*v134;
                                        if (!v134) {
                                          goto LABEL_241;
                                        }
                                      }
                                    }
LABEL_279:
                                    uint64_t v154 = *v59;
                                    uint64_t v58 = (uint64_t *)v59[1];
                                    *(void *)(v154 + 8) = v58;
                                    *(void *)v59[1] = v154;
                                    --*(void *)(v118 + 16);
                                    long long v155 = (atomic_uint *)v59[3];
                                    if (v155)
                                    {
                                      if (atomic_fetch_add(v155 + 2, 0xFFFFFFFF) == 1)
                                      {
                                        (*(void (**)(atomic_uint *))(*(void *)v155 + 16))(v155);
                                        if (atomic_fetch_add(v155 + 3, 0xFFFFFFFF) == 1) {
                                          (*(void (**)(atomic_uint *))(*(void *)v155 + 24))(v155);
                                        }
                                      }
                                    }
                                    operator delete(v59);
                                    std::string v54 = (uint64_t **)v532;
LABEL_188:
                                    BOOL v113 = v58 != (uint64_t *)**v54 && v111 >= ++v110;
                                    std::string::size_type v59 = v58;
                                    if (!v113)
                                    {
LABEL_284:
                                      v54[2] = v58;
                                      uint64_t v156 = operator new(0x50uLL);
                                      v156[1] = 0;
                                      v156[2] = 0;
                                      *((unsigned char *)v156 + 24) = 1;
                                      *((_DWORD *)v156 + 7) = 1;
                                      *uint64_t v156 = &unk_1EFB0DE60;
                                      v157 = operator new(0x38uLL);
                                      std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::vector(v157, (uint64_t *)&__dst);
                                      v157[3] = 0;
                                      uint64_t v158 = *((void *)&v555 + 1);
                                      if (*((void *)&v555 + 1))
                                      {
                                        v157[3] = *((void *)&v555 + 1);
                                        if (v158)
                                        {
                                          *((_OWORD *)v157 + 2) = v556;
                                          v157[6] = v557;
                                        }
                                        else
                                        {
                                          (*(void (**)(long long *, void *, void))(v158 & 0xFFFFFFFFFFFFFFFELL))(&v556, v157 + 4, 0);
                                        }
                                      }
                                      v156[4] = v157;
                                      v156[5] = 0;
                                      v159 = operator new(0x18uLL);
                                      v159[1] = 0x100000001;
                                      void *v159 = &unk_1EFB0DF08;
                                      v159[2] = v157;
                                      v156[5] = v159;
                                      v156[6] = v54[3];
                                      v160 = (atomic_uint *)v54[4];
                                      v156[7] = v160;
                                      if (v160) {
                                        atomic_fetch_add_explicit(v160 + 2, 1u, memory_order_relaxed);
                                      }
                                      *((_DWORD *)v156 + 16) = 0;
                                      *((unsigned char *)v156 + 68) = 0;
                                      v562 = (uint64_t (**)())v156;
                                      v161 = operator new(0x18uLL);
                                      *((void *)v161 + 1) = 0x100000001;
                                      *(void *)v161 = &unk_1EFB0DF68;
                                      *((void *)v161 + 2) = v156;
                                      unint64_t v563 = (unint64_t)v161;
                                      v162 = (uint64_t *)**v54;
                                      v163 = operator new(0x20uLL);
                                      v164 = v162 + 4;
                                      v163[2] = v156;
                                      v163[3] = v161;
                                      atomic_fetch_add_explicit((atomic_uint *volatile)v161 + 2, 1u, memory_order_relaxed);
                                      uint64_t v165 = *v162;
                                      *(void *)(v165 + 8) = v163;
                                      void *v163 = v165;
                                      uint64_t *v162 = (uint64_t)v163;
                                      v163[1] = v162;
                                      ++v162[2];
                                      v166 = (uint64_t *)v162[4];
                                      if (!v166)
                                      {
                                        v166 = v162 + 4;
                                        goto LABEL_311;
                                      }
                                      v167 = v162 + 4;
                                      uint64_t v168 = v162[4];
                                      do
                                      {
                                        int v169 = *(_DWORD *)(v168 + 32);
                                        BOOL v170 = v169 == 2;
                                        BOOL v171 = v169 < 2;
                                        if (v169 >= 2) {
                                          v172 = (uint64_t *)v168;
                                        }
                                        else {
                                          v172 = (uint64_t *)(v168 + 8);
                                        }
                                        if (!v171) {
                                          v167 = (uint64_t *)v168;
                                        }
                                        if (v170)
                                        {
                                          v172 = (uint64_t *)v168;
                                          v167 = (uint64_t *)v168;
                                        }
                                        uint64_t v168 = *v172;
                                      }
                                      while (*v172);
                                      if (v167 != v164 && *((_DWORD *)v167 + 8) == 2)
                                      {
LABEL_302:
                                        *((_DWORD *)v156 + 16) = 2;
                                        *(void *)((char *)v156 + 68) = 0xAAAAAAAAAAAAAA00;
                                        goto LABEL_314;
                                      }
                                      int v173 = *((_DWORD *)v166 + 8);
                                      while (1)
                                      {
                                        if (v173 == 2) {
                                          goto LABEL_302;
                                        }
                                        if (v173 < 3)
                                        {
                                          v174 = (uint64_t *)v166[1];
                                          if (!v174)
                                          {
                                            v164 = v166 + 1;
LABEL_311:
                                            v175 = operator new(0x38uLL);
                                            v175[4] = 0xAAAAAA0000000002;
                                            *((_DWORD *)v175 + 10) = -1431655766;
                                            v175[6] = v163;
                                            void *v175 = 0;
                                            v175[1] = 0;
                                            v175[2] = v166;
                                            uint64_t *v164 = (uint64_t)v175;
                                            uint64_t v176 = *(void *)v162[3];
                                            if (v176)
                                            {
                                              v162[3] = v176;
                                              v175 = (void *)*v164;
                                            }
                                            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v162[4], v175);
                                            ++v162[5];
                                            uint64_t v156 = v562;
                                            v161 = (void *)v563;
                                            *((_DWORD *)v562 + 16) = 2;
                                            *(void *)((char *)v156 + 68) = 0xAAAAAAAAAAAAAA00;
                                            if (v161)
                                            {
LABEL_314:
                                              atomic_fetch_add_explicit((atomic_uint *volatile)v161 + 3, 1u, memory_order_relaxed);
                                              *(void *)&long long v537 = v156;
                                              *((void *)&v537 + 1) = v161;
                                              atomic_fetch_add_explicit((atomic_uint *volatile)v161 + 3, 1u, memory_order_relaxed);
                                              if (atomic_fetch_add((atomic_uint *volatile)v161 + 3, 0xFFFFFFFF) == 1) {
                                                (*(void (**)(void *))(*(void *)v161 + 24))(v161);
                                              }
                                              v177 = (atomic_uint *)v563;
                                              if (v563)
                                              {
LABEL_317:
                                                if (atomic_fetch_add(v177 + 2, 0xFFFFFFFF) == 1)
                                                {
                                                  (*(void (**)(atomic_uint *))(*(void *)v177 + 16))(v177);
                                                  if (atomic_fetch_add(v177 + 3, 0xFFFFFFFF) == 1) {
                                                    (*(void (**)(atomic_uint *))(*(void *)v177 + 24))(v177);
                                                  }
                                                }
                                              }
                                            }
                                            else
                                            {
                                              long long v537 = (unint64_t)v156;
                                              v177 = (atomic_uint *)v563;
                                              if (v563) {
                                                goto LABEL_317;
                                              }
                                            }
                                            pthread_mutex_unlock(v578);
                                            v178 = (char *)p_block;
                                            if (p_block)
                                            {
                                              if (v577 - 1 >= 0)
                                              {
                                                v179 = (char *)p_block + 16 * v577;
                                                do
                                                {
                                                  v180 = (atomic_uint *)*((void *)v179 - 1);
                                                  if (v180)
                                                  {
                                                    if (atomic_fetch_add(v180 + 2, 0xFFFFFFFF) == 1)
                                                    {
                                                      (*(void (**)(atomic_uint *))(*(void *)v180 + 16))(v180);
                                                      if (atomic_fetch_add(v180 + 3, 0xFFFFFFFF) == 1) {
                                                        (*(void (**)(atomic_uint *))(*(void *)v180 + 24))(v180);
                                                      }
                                                    }
                                                  }
                                                  v179 -= 16;
                                                }
                                                while (v179 > v178);
                                              }
                                              if (v575 >= 0xB) {
                                                operator delete(p_block);
                                              }
                                            }
                                            if (*((void *)&v555 + 1))
                                            {
                                              if ((BYTE8(v555) & 1) == 0)
                                              {
                                                v181 = *(void (**)(long long *, long long *, uint64_t))(*((void *)&v555 + 1) & 0xFFFFFFFFFFFFFFFELL);
                                                if (v181) {
                                                  v181(&v556, &v556, 2);
                                                }
                                              }
                                              *((void *)&v555 + 1) = 0;
                                            }
                                            uint64_t v182 = __dst;
                                            if ((void)__dst)
                                            {
                                              uint64_t v183 = *((void *)&__dst + 1);
                                              v184 = (void *)__dst;
                                              if (*((void *)&__dst + 1) != (void)__dst)
                                              {
                                                do
                                                {
                                                  v183 -= 24;
                                                  boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v183);
                                                }
                                                while (v183 != v182);
                                                v184 = (void *)__dst;
                                              }
                                              *((void *)&__dst + 1) = v182;
                                              operator delete(v184);
                                            }
                                            dispatch_release(v552);
                                            if (v553) {
                                              _Block_release(v553);
                                            }
                                            if (atomic_fetch_add(&v526->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                            {
                                              v185 = v524;
                                              if (!v524) {
                                                goto LABEL_348;
                                              }
LABEL_347:
                                              _Block_release(v185);
                                            }
                                            else
                                            {
                                              ((void (*)(std::__shared_weak_count *))v526->__on_zero_shared)(v526);
                                              std::__shared_weak_count::__release_weak(v526);
                                              v185 = v524;
                                              if (v524) {
                                                goto LABEL_347;
                                              }
                                            }
LABEL_348:
                                            v186 = operator new(0x20uLL);
                                            v186[1] = v537;
                                            uint64_t v187 = a1[24];
                                            v525 = a1 + 24;
                                            *(void *)v186 = v187;
                                            *((void *)v186 + 1) = a1 + 24;
                                            *(void *)(v187 + 8) = v186;
                                            a1[24] = v186;
                                            ++a1[26];
                                            uint64_t v188 = a1[21];
                                            std::string __p = (void *)MEMORY[0x1E4F143A8];
                                            uint64_t v546 = 0x40000000;
                                            int64_t v547 = (int64_t)___ZN3ctu20SharedSynchronizableI5TraceE13connect_eventIN5boost8signals26signalIFvbENS5_19optional_last_valueIvEEiNSt3__14lessIiEENS4_8functionIS7_EENSD_IFvRKNS5_10connectionEbEEENS5_5mutexEEE16EURCoreDumpTracevJbEEEDTcl7connectfp_cvNSA_10shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSR_ST_E_block_invoke;
                                            v548 = &__block_descriptor_tmp_104;
                                            v549 = a1 + 9;
                                            v550 = EURCoreDumpTrace::getCoreDumpEnabledStatusUpdate_sync;
                                            uint64_t v551 = 0;
                                            v189 = _Block_copy(&__p);
                                            uint64_t v533 = v188;
                                            v190 = (std::__shared_weak_count *)a1[10];
                                            if (!v190
                                              || (uint64_t v191 = a1[9], (v192 = std::__shared_weak_count::lock(v190)) == 0))
                                            {
                                              std::__throw_bad_weak_ptr[abi:ne180100]();
                                            }
                                            v193 = v192;
                                            v194 = a1[11];
                                            dispatch_object_t v552 = v194;
                                            if (v189) {
                                              v195 = _Block_copy(v189);
                                            }
                                            else {
                                              v195 = 0;
                                            }
                                            v553 = v195;
                                            dispatch_retain(v194);
                                            long long __dst = 0u;
                                            long long v555 = 0u;
                                            dispatch_object_t v558 = v194;
                                            if (v195) {
                                              v195 = _Block_copy(v195);
                                            }
                                            v559 = v195;
                                            dispatch_retain(v194);
                                            dispatch_object_t v560 = v194;
                                            v527 = v193;
                                            aBlockb = v189;
                                            if (v195)
                                            {
                                              v196 = _Block_copy(v195);
                                              v561 = v196;
                                              dispatch_retain(v194);
                                              if (v196)
                                              {
                                                v197 = _Block_copy(v196);
                                                dispatch_retain(v194);
                                                v562 = 0;
                                                if (v197)
                                                {
                                                  v198 = _Block_copy(v197);
                                                  dispatch_retain(v194);
                                                  v510 = v197;
                                                  if (v198)
                                                  {
                                                    v199 = _Block_copy(v198);
                                                    dispatch_retain(v194);
                                                    v514 = v198;
                                                    if (v199)
                                                    {
                                                      v200 = _Block_copy(v199);
                                                      dispatch_retain(v194);
                                                      if (v200)
                                                      {
                                                        v201 = _Block_copy(v200);
                                                        dispatch_retain(v194);
                                                        unint64_t v563 = (unint64_t)v194;
                                                        if (v201)
                                                        {
                                                          v202 = _Block_copy(v201);
                                                          char v203 = 0;
                                                          char v204 = 0;
                                                          char v205 = 0;
                                                          char v206 = 0;
                                                          char v207 = 0;
                                                          goto LABEL_370;
                                                        }
                                                        char v203 = 0;
                                                        char v204 = 0;
                                                        char v205 = 0;
                                                        char v206 = 0;
                                                        v202 = 0;
LABEL_369:
                                                        char v207 = 1;
LABEL_370:
                                                        v564 = v202;
                                                        dispatch_retain(v194);
                                                        dispatch_release(v194);
                                                        if ((v207 & 1) == 0) {
                                                          _Block_release(v201);
                                                        }
                                                        dispatch_release(v194);
                                                        if ((v206 & 1) == 0) {
                                                          _Block_release(v200);
                                                        }
                                                        dispatch_release(v194);
                                                        if ((v205 & 1) == 0) {
                                                          _Block_release(v199);
                                                        }
                                                        v562 = boost::function1<void,BOOL>::assign_to<ctu::DispatchSlot<dispatch::block<void({block_pointer})(BOOL)>>>(ctu::DispatchSlot<dispatch::block<void({block_pointer})(BOOL)>>)::stored_vtable;
                                                        dispatch_release(v194);
                                                        if ((v204 & 1) == 0) {
                                                          _Block_release(v514);
                                                        }
                                                        dispatch_release(v194);
                                                        if ((v203 & 1) == 0) {
                                                          _Block_release(v510);
                                                        }
                                                        *(void *)&long long v566 = 0xAAAAAAAAAAAAAAAALL;
                                                        *((void *)&v566 + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                        *(void *)&blocuint64_t k = 0;
                                                        *((void *)&block + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                        boost::function1<void,BOOL>::move_assign((uint64_t)&block, (uint64_t *)&v562);
                                                        boost::function1<void,BOOL>::move_assign((uint64_t)&v562, (uint64_t *)&v555 + 1);
                                                        boost::function1<void,BOOL>::move_assign((uint64_t)&v555 + 8, (uint64_t *)&block);
                                                        if ((void)block)
                                                        {
                                                          if ((block & 1) == 0)
                                                          {
                                                            v208 = *(void (**)(char *, char *, uint64_t))(block & 0xFFFFFFFFFFFFFFFELL);
                                                            if (v208) {
                                                              v208((char *)&block + 8, (char *)&block + 8, 2);
                                                            }
                                                          }
                                                        }
                                                        if (v562)
                                                        {
                                                          if ((v562 & 1) == 0)
                                                          {
                                                            v209 = *(void (**)(uint64_t, _WORD *, unsigned int))((unint64_t)v562 & 0xFFFFFFFFFFFFFFFELL);
                                                            if (v209) {
                                                              v209((uint64_t)&v563, &v563, 2u);
                                                            }
                                                          }
                                                          v562 = 0;
                                                        }
                                                        dispatch_release(v560);
                                                        if (v561) {
                                                          _Block_release(v561);
                                                        }
                                                        dispatch_release(v558);
                                                        if (v559) {
                                                          _Block_release(v559);
                                                        }
                                                        atomic_fetch_add_explicit(&v527->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                        v210 = operator new(0x18uLL);
                                                        void *v210 = &unk_1EFB0E178;
                                                        v210[1] = v191;
                                                        v210[2] = v527;
                                                        atomic_fetch_add_explicit(&v527->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                        v211 = operator new(0x18uLL);
                                                        void *v211 = &unk_1EFB0E178;
                                                        v211[1] = v191;
                                                        v211[2] = v527;
                                                        atomic_fetch_add_explicit(&v527->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                        *((void *)&block + 1) = v211;
                                                        LODWORD(block) = 2;
                                                        uint64_t v212 = *((void *)&__dst + 1);
                                                        if (*((void *)&__dst + 1) >= (unint64_t)v555)
                                                        {
                                                          v214 = std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__push_back_slow_path<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>((void **)&__dst, (uint64_t)&block);
                                                        }
                                                        else
                                                        {
                                                          v213 = operator new(0x18uLL);
                                                          void *v213 = &unk_1EFB0E178;
                                                          v213[1] = v191;
                                                          v213[2] = v527;
                                                          atomic_fetch_add_explicit(&v527->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                          *(void *)(v212 + 8) = v213;
                                                          *(_DWORD *)uint64_t v212 = 2;
                                                          v214 = (_DWORD *)(v212 + 24);
                                                        }
                                                        *((void *)&__dst + 1) = v214;
                                                        boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&block);
                                                        (*(void (**)(void *))(*v210 + 8))(v210);
                                                        std::__shared_weak_count::__release_weak(v527);
                                                        v215 = *(uint64_t ***)(v533 + 160);
                                                        *(void *)&long long v216 = 0xAAAAAAAAAAAAAAAALL;
                                                        *((void *)&v216 + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                        long long v573 = v216;
                                                        long long v574 = v216;
                                                        long long v571 = v216;
                                                        long long v572 = v216;
                                                        long long v569 = v216;
                                                        long long v570 = v216;
                                                        long long v567 = v216;
                                                        long long v568 = v216;
                                                        blocuint64_t k = v216;
                                                        long long v566 = v216;
                                                        v217 = (pthread_mutex_t *)v215[3];
                                                        unint64_t v575 = 10;
                                                        p_blocuint64_t k = &block;
                                                        uint64_t v577 = 0;
                                                        v578 = v217;
                                                        pthread_mutex_lock(v217);
                                                        v562 = (uint64_t (**)())0xAAAAAAAAAAAAAAAALL;
                                                        unint64_t v563 = 0xAAAAAAAAAAAAAAAALL;
                                                        v218 = (atomic_uint *)v215[1];
                                                        v534 = (uint64_t ***)v215;
                                                        if (v218
                                                          && atomic_load_explicit(v218 + 2, memory_order_acquire) == 1)
                                                        {
                                                          v219 = (uint64_t *)**v215;
                                                          v220 = v215[2];
                                                          int v221 = 2;
                                                          if (v220 != v219) {
                                                            goto LABEL_486;
                                                          }
                                                          goto LABEL_485;
                                                        }
                                                        v222 = (uint64_t **)operator new(0x20uLL);
                                                        v223 = *v215;
                                                        uint64_t v224 = *v223;
                                                        v515 = v222;
                                                        v225 = operator new(0x40uLL);
                                                        v226 = v225;
                                                        void *v225 = v225;
                                                        v225[1] = v225;
                                                        v225[2] = 0;
                                                        v227 = *(void **)(v224 + 8);
                                                        if (v227 != (void *)v224)
                                                        {
                                                          uint64_t v228 = 0;
                                                          v229 = v225;
                                                          do
                                                          {
                                                            v230 = operator new(0x20uLL);
                                                            v230[2] = v227[2];
                                                            uint64_t v231 = v227[3];
                                                            v230[3] = v231;
                                                            if (v231)
                                                            {
                                                              atomic_fetch_add_explicit((atomic_uint *volatile)(v231 + 8), 1u, memory_order_relaxed);
                                                              v229 = (void *)*v226;
                                                              uint64_t v228 = v226[2];
                                                            }
                                                            void *v230 = v229;
                                                            v230[1] = v226;
                                                            v229[1] = v230;
                                                            void *v226 = v230;
                                                            v226[2] = ++v228;
                                                            v227 = (void *)v227[1];
                                                            v229 = v230;
                                                          }
                                                          while (v227 != (void *)v224);
                                                        }
                                                        v511 = v223;
                                                        v226[3] = 0;
                                                        v232 = (void **)(v226 + 3);
                                                        v226[4] = 0;
                                                        v233 = v226 + 4;
                                                        v226[5] = 0;
                                                        *((unsigned char *)v226 + 48) = *(unsigned char *)(v224 + 48);
                                                        v226[3] = v226 + 4;
                                                        v234 = *(void **)(v224 + 24);
                                                        v235 = (void *)(v224 + 32);
                                                        if (v234 == (void *)(v224 + 32))
                                                        {
LABEL_406:
                                                          *((unsigned char *)v226 + 56) = *(unsigned char *)(v224 + 56);
                                                          v236 = *(void **)(v224 + 24);
                                                          if (v236 != v235)
                                                          {
                                                            v237 = (void *)v226[3];
                                                            uint64_t v238 = v226[1];
                                                            do
                                                            {
                                                              v237[6] = v238;
                                                              uint64_t v239 = v224;
                                                              if (v236 != v235) {
                                                                uint64_t v239 = v236[6];
                                                              }
                                                              v240 = (void *)v236[1];
                                                              v241 = v240;
                                                              v242 = v236;
                                                              if (v240)
                                                              {
                                                                do
                                                                {
                                                                  v243 = v241;
                                                                  v241 = (void *)*v241;
                                                                }
                                                                while (v241);
                                                              }
                                                              else
                                                              {
                                                                do
                                                                {
                                                                  v243 = (void *)v242[2];
                                                                  BOOL v127 = *v243 == (void)v242;
                                                                  v242 = v243;
                                                                }
                                                                while (!v127);
                                                              }
                                                              uint64_t v244 = v224;
                                                              if (v243 != v235) {
                                                                uint64_t v244 = v243[6];
                                                              }
                                                              while (v239 != v244)
                                                              {
                                                                uint64_t v239 = *(void *)(v239 + 8);
                                                                uint64_t v238 = *(void *)(v238 + 8);
                                                              }
                                                              if (v240)
                                                              {
                                                                do
                                                                {
                                                                  v245 = v240;
                                                                  v240 = (void *)*v240;
                                                                }
                                                                while (v240);
                                                              }
                                                              else
                                                              {
                                                                do
                                                                {
                                                                  v245 = (void *)v236[2];
                                                                  BOOL v127 = *v245 == (void)v236;
                                                                  v236 = v245;
                                                                }
                                                                while (!v127);
                                                              }
                                                              v246 = (void *)v237[1];
                                                              if (v246)
                                                              {
                                                                do
                                                                {
                                                                  v247 = v246;
                                                                  v246 = (void *)*v246;
                                                                }
                                                                while (v246);
                                                              }
                                                              else
                                                              {
                                                                do
                                                                {
                                                                  v247 = (void *)v237[2];
                                                                  BOOL v127 = *v247 == (void)v237;
                                                                  v237 = v247;
                                                                }
                                                                while (!v127);
                                                              }
                                                              v236 = v245;
                                                              v237 = v247;
                                                            }
                                                            while (v245 != v235);
                                                          }
                                                          *v515 = v226;
                                                          v515[1] = 0;
                                                          v267 = (uint64_t *)operator new(0x18uLL);
                                                          v215 = (uint64_t **)v534;
                                                          v267[1] = 0x100000001;
                                                          uint64_t *v267 = (uint64_t)&unk_1EFB0E288;
                                                          v267[2] = (uint64_t)v226;
                                                          v515[1] = v267;
                                                          v515[2] = (uint64_t *)v511[2];
                                                          uint64_t v268 = v511[3];
                                                          v515[3] = (uint64_t *)v268;
                                                          if (v268) {
                                                            atomic_fetch_add_explicit((atomic_uint *volatile)(v268 + 8), 1u, memory_order_relaxed);
                                                          }
                                                          v269 = (uint64_t **)operator new(0x18uLL);
                                                          v269[1] = (uint64_t *)0x100000001;
                                                          *v269 = (uint64_t *)&unk_1EFB0E228;
                                                          v269[2] = (uint64_t *)v515;
                                                          v270 = (atomic_uint *)v534[1];
                                                          *v534 = v515;
                                                          v534[1] = v269;
                                                          if (v270)
                                                          {
                                                            if (atomic_fetch_add(v270 + 2, 0xFFFFFFFF) == 1)
                                                            {
                                                              (*(void (**)(atomic_uint *))(*(void *)v270 + 16))(v270);
                                                              if (atomic_fetch_add(v270 + 3, 0xFFFFFFFF) == 1) {
                                                                (*(void (**)(atomic_uint *))(*(void *)v270 + 24))(v270);
                                                              }
                                                            }
                                                          }
                                                          int v221 = 0;
                                                          v219 = **v534;
LABEL_485:
                                                          v220 = (uint64_t *)v219[1];
                                                          if (v219 == v220) {
                                                            goto LABEL_585;
                                                          }
LABEL_486:
                                                          int v271 = 0;
                                                          unsigned int v272 = v221 - 1;
LABEL_494:
                                                          uint64_t v275 = v220[2];
                                                          v276 = *(uint64_t **)(v275 + 32);
                                                          if (!v276) {
                                                            goto LABEL_487;
                                                          }
                                                          for (uint64_t j = *v276; ; j += 24)
                                                          {
                                                            if (j == v276[1]) {
                                                              goto LABEL_487;
                                                            }
                                                            if ((*(_DWORD *)j ^ (*(int *)j >> 31)) > 1)
                                                            {
                                                              if ((*(uint64_t (**)(void))(**(void **)(j + 8) + 24))(*(void *)(j + 8))) {
                                                                goto LABEL_503;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              uint64_t v278 = *(void *)(j + 16);
                                                              if (!v278
                                                                || !atomic_load_explicit((atomic_uint *volatile)(v278 + 8), memory_order_acquire))
                                                              {
LABEL_503:
                                                                if (*(unsigned char *)(v275 + 24))
                                                                {
                                                                  *(unsigned char *)(v275 + 24) = 0;
                                                                  boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)v275, &block);
                                                                }
LABEL_487:
                                                                uint64_t v273 = v220[2];
                                                                if (*(unsigned char *)(v273 + 24))
                                                                {
                                                                  v219 = (uint64_t *)v220[1];
                                                                  goto LABEL_489;
                                                                }
                                                                uint64_t v279 = **v215;
                                                                v281 = (uint64_t **)(v279 + 32);
                                                                v280 = *(char **)(v279 + 32);
                                                                if (!v280)
                                                                {
                                                                  if (*(uint64_t **)(v279 + 80) != v220) {
                                                                    goto LABEL_580;
                                                                  }
                                                                  v303 = (uint64_t *)v220[1];
                                                                  v305 = (uint64_t **)(v279 + 32);
                                                                  v284 = (uint64_t *)(v279 + 32);
                                                                  if (v303 != (uint64_t *)v279) {
                                                                    goto LABEL_576;
                                                                  }
                                                                  goto LABEL_558;
                                                                }
                                                                int v282 = *(_DWORD *)(v273 + 64);
                                                                int v283 = *(_DWORD *)(v273 + 72);
                                                                v284 = (uint64_t *)(v279 + 32);
                                                                uint64_t v285 = *(void *)(v279 + 32);
                                                                if (v282 == 1)
                                                                {
                                                                  v284 = (uint64_t *)(v279 + 32);
                                                                  uint64_t v286 = *(void *)(v279 + 32);
                                                                  do
                                                                  {
                                                                    while (1)
                                                                    {
                                                                      int v292 = *(_DWORD *)(v286 + 32);
                                                                      BOOL v293 = v292 < 1;
                                                                      if (v292 == 1) {
                                                                        BOOL v293 = *(_DWORD *)(v286 + 40) < v283;
                                                                      }
                                                                      if (!v293) {
                                                                        break;
                                                                      }
                                                                      uint64_t v286 = *(void *)(v286 + 8);
                                                                      if (!v286) {
                                                                        goto LABEL_524;
                                                                      }
                                                                    }
                                                                    v284 = (uint64_t *)v286;
                                                                    uint64_t v286 = *(void *)v286;
                                                                  }
                                                                  while (v286);
                                                                }
                                                                else
                                                                {
                                                                  do
                                                                  {
                                                                    int v287 = *(_DWORD *)(v285 + 32);
                                                                    BOOL v288 = v287 == v282;
                                                                    BOOL v289 = v287 < v282;
                                                                    if (v287 >= v282) {
                                                                      v290 = (uint64_t *)v285;
                                                                    }
                                                                    else {
                                                                      v290 = (uint64_t *)(v285 + 8);
                                                                    }
                                                                    if (v289) {
                                                                      v291 = v284;
                                                                    }
                                                                    else {
                                                                      v291 = (uint64_t *)v285;
                                                                    }
                                                                    if (v288)
                                                                    {
                                                                      v290 = (uint64_t *)v285;
                                                                      v284 = (uint64_t *)v285;
                                                                    }
                                                                    else
                                                                    {
                                                                      v284 = v291;
                                                                    }
                                                                    uint64_t v285 = *v290;
                                                                  }
                                                                  while (*v290);
                                                                }
LABEL_524:
                                                                if ((uint64_t *)v284[6] == v220)
                                                                {
                                                                  v294 = (uint64_t **)(v279 + 32);
                                                                  v295 = *(uint64_t ***)(v279 + 32);
                                                                  if (v282 != 1)
                                                                  {
                                                                    do
                                                                    {
                                                                      int v296 = *((_DWORD *)v295 + 8);
                                                                      v297 = (uint64_t ***)(v295 + 1);
                                                                      BOOL v298 = v282 == v296;
                                                                      BOOL v299 = v282 < v296;
                                                                      if (v282 >= v296) {
                                                                        v300 = (uint64_t ***)(v295 + 1);
                                                                      }
                                                                      else {
                                                                        v300 = (uint64_t ***)v295;
                                                                      }
                                                                      if (!v299) {
                                                                        v295 = v294;
                                                                      }
                                                                      if (v298) {
                                                                        v300 = v297;
                                                                      }
                                                                      else {
                                                                        v294 = v295;
                                                                      }
                                                                      v295 = *v300;
                                                                    }
                                                                    while (*v300);
LABEL_542:
                                                                    v302 = (uint64_t *)v279;
                                                                    if (v294 != v281) {
                                                                      v302 = v294[6];
                                                                    }
                                                                    v303 = (uint64_t *)v220[1];
                                                                    if (v303 != v302)
                                                                    {
                                                                      if (v282 != 1)
                                                                      {
                                                                        int v304 = *((_DWORD *)v280 + 8);
                                                                        if (v282 == v304) {
                                                                          goto LABEL_579;
                                                                        }
                                                                        while (1)
                                                                        {
                                                                          if (v282 < v304)
                                                                          {
                                                                            uint64_t v311 = *(void *)v280;
                                                                            if (!*(void *)v280)
                                                                            {
                                                                              v281 = (uint64_t **)v280;
LABEL_575:
                                                                              v305 = (uint64_t **)v280;
LABEL_576:
                                                                              v280 = (char *)operator new(0x38uLL);
                                                                              uint64_t v312 = *(void *)(v273 + 64);
                                                                              *((_DWORD *)v280 + 10) = *(_DWORD *)(v273 + 72);
                                                                              *((void *)v280 + 4) = v312;
                                                                              *((void *)v280 + 6) = 0;
                                                                              *(void *)v280 = 0;
                                                                              *((void *)v280 + 1) = 0;
                                                                              *((void *)v280 + 2) = v305;
                                                                              *v281 = (uint64_t *)v280;
                                                                              uint64_t v313 = **(void **)(v279 + 24);
                                                                              v314 = (uint64_t *)v280;
                                                                              if (v313)
                                                                              {
                                                                                *(void *)(v279 + 24) = v313;
                                                                                v314 = *v281;
                                                                              }
                                                                              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v279 + 32), v314);
                                                                              ++*(void *)(v279 + 40);
LABEL_579:
                                                                              *((void *)v280 + 6) = v303;
                                                                              goto LABEL_580;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            if (v304 >= v282) {
                                                                              goto LABEL_579;
                                                                            }
                                                                            uint64_t v311 = *((void *)v280 + 1);
                                                                            if (!v311)
                                                                            {
                                                                              v281 = (uint64_t **)(v280 + 8);
                                                                              goto LABEL_575;
                                                                            }
                                                                          }
                                                                          int v304 = *(_DWORD *)(v311 + 32);
                                                                          v280 = (char *)v311;
                                                                          if (v282 == v304)
                                                                          {
                                                                            *(void *)(v311 + 48) = v303;
                                                                            goto LABEL_580;
                                                                          }
                                                                        }
                                                                      }
                                                                      while (1)
                                                                      {
                                                                        v305 = (uint64_t **)v280;
                                                                        int v306 = *((_DWORD *)v280 + 8);
                                                                        if (v306 == 1)
                                                                        {
                                                                          int v307 = *((_DWORD *)v280 + 10);
                                                                          if (v307 <= v283)
                                                                          {
                                                                            if (v307 >= v283)
                                                                            {
                                                                              *((void *)v280 + 6) = v303;
                                                                              goto LABEL_580;
                                                                            }
LABEL_554:
                                                                            v280 = (char *)*((void *)v280 + 1);
                                                                            if (!v280)
                                                                            {
                                                                              v281 = v305 + 1;
                                                                              goto LABEL_576;
                                                                            }
                                                                            continue;
                                                                          }
                                                                        }
                                                                        else if (v306 <= 1)
                                                                        {
                                                                          goto LABEL_554;
                                                                        }
                                                                        v280 = *(char **)v280;
                                                                        if (!*v305)
                                                                        {
                                                                          v281 = v305;
                                                                          goto LABEL_576;
                                                                        }
                                                                      }
                                                                    }
LABEL_558:
                                                                    v308 = (uint64_t *)v284[1];
                                                                    v309 = v284;
                                                                    if (v308)
                                                                    {
                                                                      do
                                                                      {
                                                                        v310 = v308;
                                                                        v308 = (uint64_t *)*v308;
                                                                      }
                                                                      while (v308);
                                                                    }
                                                                    else
                                                                    {
                                                                      do
                                                                      {
                                                                        v310 = (uint64_t *)v309[2];
                                                                        BOOL v127 = *v310 == (void)v309;
                                                                        v309 = v310;
                                                                      }
                                                                      while (!v127);
                                                                    }
                                                                    if (*(uint64_t **)(v279 + 24) == v284) {
                                                                      *(void *)(v279 + 24) = v310;
                                                                    }
                                                                    --*(void *)(v279 + 40);
                                                                    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v280, v284);
                                                                    operator delete(v284);
                                                                    goto LABEL_580;
                                                                  }
                                                                  while (1)
                                                                  {
                                                                    int v301 = *((_DWORD *)v295 + 8);
                                                                    if (v301 == 1)
                                                                    {
                                                                      if (v283 >= *((_DWORD *)v295 + 10)) {
                                                                        goto LABEL_536;
                                                                      }
                                                                    }
                                                                    else if (v301 <= 1)
                                                                    {
LABEL_536:
                                                                      v295 = (uint64_t **)v295[1];
                                                                      if (!v295) {
                                                                        goto LABEL_542;
                                                                      }
                                                                      continue;
                                                                    }
                                                                    v294 = v295;
                                                                    v295 = (uint64_t **)*v295;
                                                                    if (!v295) {
                                                                      goto LABEL_542;
                                                                    }
                                                                  }
                                                                }
LABEL_580:
                                                                uint64_t v315 = *v220;
                                                                v219 = (uint64_t *)v220[1];
                                                                *(void *)(v315 + 8) = v219;
                                                                *(void *)v220[1] = v315;
                                                                --*(void *)(v279 + 16);
                                                                v316 = (atomic_uint *)v220[3];
                                                                if (v316)
                                                                {
                                                                  if (atomic_fetch_add(v316 + 2, 0xFFFFFFFF) == 1)
                                                                  {
                                                                    (*(void (**)(atomic_uint *))(*(void *)v316 + 16))(v316);
                                                                    if (atomic_fetch_add(v316 + 3, 0xFFFFFFFF) == 1) {
                                                                      (*(void (**)(atomic_uint *))(*(void *)v316 + 24))(v316);
                                                                    }
                                                                  }
                                                                }
                                                                operator delete(v220);
                                                                v215 = (uint64_t **)v534;
LABEL_489:
                                                                BOOL v274 = v219 != (uint64_t *)**v215 && v272 >= ++v271;
                                                                v220 = v219;
                                                                if (!v274)
                                                                {
LABEL_585:
                                                                  v215[2] = v219;
                                                                  v317 = operator new(0x50uLL);
                                                                  v317[1] = 0;
                                                                  v317[2] = 0;
                                                                  *((unsigned char *)v317 + 24) = 1;
                                                                  *((_DWORD *)v317 + 7) = 1;
                                                                  void *v317 = &unk_1EFB0E2E8;
                                                                  v318 = operator new(0x38uLL);
                                                                  std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::vector(v318, (uint64_t *)&__dst);
                                                                  v318[3] = 0;
                                                                  uint64_t v319 = *((void *)&v555 + 1);
                                                                  if (*((void *)&v555 + 1))
                                                                  {
                                                                    v318[3] = *((void *)&v555 + 1);
                                                                    if (v319)
                                                                    {
                                                                      *((_OWORD *)v318 + 2) = v556;
                                                                      v318[6] = v557;
                                                                    }
                                                                    else
                                                                    {
                                                                      (*(void (**)(long long *, void *, void))(v319 & 0xFFFFFFFFFFFFFFFELL))(&v556, v318 + 4, 0);
                                                                    }
                                                                  }
                                                                  v317[4] = v318;
                                                                  v317[5] = 0;
                                                                  v320 = operator new(0x18uLL);
                                                                  v320[1] = 0x100000001;
                                                                  void *v320 = &unk_1EFB0E340;
                                                                  v320[2] = v318;
                                                                  v317[5] = v320;
                                                                  v317[6] = v215[3];
                                                                  v321 = (atomic_uint *)v215[4];
                                                                  v317[7] = v321;
                                                                  if (v321) {
                                                                    atomic_fetch_add_explicit(v321 + 2, 1u, memory_order_relaxed);
                                                                  }
                                                                  *((_DWORD *)v317 + 16) = 0;
                                                                  *((unsigned char *)v317 + 68) = 0;
                                                                  v562 = (uint64_t (**)())v317;
                                                                  v322 = operator new(0x18uLL);
                                                                  *((void *)v322 + 1) = 0x100000001;
                                                                  *(void *)v322 = &unk_1EFB0E3A0;
                                                                  *((void *)v322 + 2) = v317;
                                                                  unint64_t v563 = (unint64_t)v322;
                                                                  v323 = (uint64_t *)**v215;
                                                                  v324 = operator new(0x20uLL);
                                                                  v325 = v323 + 4;
                                                                  v324[2] = v317;
                                                                  v324[3] = v322;
                                                                  atomic_fetch_add_explicit((atomic_uint *volatile)v322 + 2, 1u, memory_order_relaxed);
                                                                  uint64_t v326 = *v323;
                                                                  *(void *)(v326 + 8) = v324;
                                                                  void *v324 = v326;
                                                                  uint64_t *v323 = (uint64_t)v324;
                                                                  v324[1] = v323;
                                                                  ++v323[2];
                                                                  v327 = (uint64_t *)v323[4];
                                                                  if (!v327)
                                                                  {
                                                                    v327 = v323 + 4;
                                                                    goto LABEL_612;
                                                                  }
                                                                  v328 = v323 + 4;
                                                                  uint64_t v329 = v323[4];
                                                                  do
                                                                  {
                                                                    int v330 = *(_DWORD *)(v329 + 32);
                                                                    BOOL v331 = v330 == 2;
                                                                    BOOL v332 = v330 < 2;
                                                                    if (v330 >= 2) {
                                                                      v333 = (uint64_t *)v329;
                                                                    }
                                                                    else {
                                                                      v333 = (uint64_t *)(v329 + 8);
                                                                    }
                                                                    if (!v332) {
                                                                      v328 = (uint64_t *)v329;
                                                                    }
                                                                    if (v331)
                                                                    {
                                                                      v333 = (uint64_t *)v329;
                                                                      v328 = (uint64_t *)v329;
                                                                    }
                                                                    uint64_t v329 = *v333;
                                                                  }
                                                                  while (*v333);
                                                                  if (v328 != v325 && *((_DWORD *)v328 + 8) == 2)
                                                                  {
LABEL_603:
                                                                    *((_DWORD *)v317 + 16) = 2;
                                                                    *(void *)((char *)v317 + 68) = 0xAAAAAAAAAAAAAA00;
                                                                    goto LABEL_615;
                                                                  }
                                                                  int v334 = *((_DWORD *)v327 + 8);
                                                                  while (1)
                                                                  {
                                                                    if (v334 == 2) {
                                                                      goto LABEL_603;
                                                                    }
                                                                    if (v334 < 3)
                                                                    {
                                                                      v335 = (uint64_t *)v327[1];
                                                                      if (!v335)
                                                                      {
                                                                        v325 = v327 + 1;
LABEL_612:
                                                                        v336 = operator new(0x38uLL);
                                                                        v336[4] = 0xAAAAAA0000000002;
                                                                        *((_DWORD *)v336 + 10) = -1431655766;
                                                                        v336[6] = v324;
                                                                        void *v336 = 0;
                                                                        v336[1] = 0;
                                                                        v336[2] = v327;
                                                                        uint64_t *v325 = (uint64_t)v336;
                                                                        uint64_t v337 = *(void *)v323[3];
                                                                        if (v337)
                                                                        {
                                                                          v323[3] = v337;
                                                                          v336 = (void *)*v325;
                                                                        }
                                                                        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v323[4], v336);
                                                                        ++v323[5];
                                                                        v317 = v562;
                                                                        v322 = (void *)v563;
                                                                        *((_DWORD *)v562 + 16) = 2;
                                                                        *(void *)((char *)v317 + 68) = 0xAAAAAAAAAAAAAA00;
                                                                        if (v322)
                                                                        {
LABEL_615:
                                                                          atomic_fetch_add_explicit((atomic_uint *volatile)v322 + 3, 1u, memory_order_relaxed);
                                                                          *(void *)&long long v538 = v317;
                                                                          *((void *)&v538 + 1) = v322;
                                                                          atomic_fetch_add_explicit((atomic_uint *volatile)v322 + 3, 1u, memory_order_relaxed);
                                                                          if (atomic_fetch_add((atomic_uint *volatile)v322 + 3, 0xFFFFFFFF) == 1)(*(void (**)(void *))(*(void *)v322 + 24))(v322); {
                                                                          v338 = (atomic_uint *)v563;
                                                                          }
                                                                          if (v563)
                                                                          {
LABEL_618:
                                                                            if (atomic_fetch_add(v338 + 2, 0xFFFFFFFF) == 1)
                                                                            {
                                                                              (*(void (**)(atomic_uint *))(*(void *)v338 + 16))(v338);
                                                                              if (atomic_fetch_add(v338 + 3, 0xFFFFFFFF) == 1)(*(void (**)(atomic_uint *))(*(void *)v338 + 24))(v338); {
                                                                            }
                                                                              }
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          long long v538 = (unint64_t)v317;
                                                                          v338 = (atomic_uint *)v563;
                                                                          if (v563) {
                                                                            goto LABEL_618;
                                                                          }
                                                                        }
                                                                        pthread_mutex_unlock(v578);
                                                                        v339 = (char *)p_block;
                                                                        if (p_block)
                                                                        {
                                                                          if (v577 - 1 >= 0)
                                                                          {
                                                                            v340 = (char *)p_block + 16 * v577;
                                                                            do
                                                                            {
                                                                              v341 = (atomic_uint *)*((void *)v340 - 1);
                                                                              if (v341)
                                                                              {
                                                                                if (atomic_fetch_add(v341 + 2, 0xFFFFFFFF) == 1)
                                                                                {
                                                                                  (*(void (**)(atomic_uint *))(*(void *)v341 + 16))(v341);
                                                                                  if (atomic_fetch_add(v341 + 3, 0xFFFFFFFF) == 1)(*(void (**)(atomic_uint *))(*(void *)v341 + 24))(v341); {
                                                                                }
                                                                                  }
                                                                              }
                                                                              v340 -= 16;
                                                                            }
                                                                            while (v340 > v339);
                                                                          }
                                                                          if (v575 >= 0xB) {
                                                                            operator delete(p_block);
                                                                          }
                                                                        }
                                                                        if (*((void *)&v555 + 1))
                                                                        {
                                                                          if ((BYTE8(v555) & 1) == 0)
                                                                          {
                                                                            v342 = *(void (**)(long long *, long long *, uint64_t))(*((void *)&v555 + 1) & 0xFFFFFFFFFFFFFFFELL);
                                                                            if (v342) {
                                                                              v342(&v556, &v556, 2);
                                                                            }
                                                                          }
                                                                          *((void *)&v555 + 1) = 0;
                                                                        }
                                                                        uint64_t v343 = __dst;
                                                                        if ((void)__dst)
                                                                        {
                                                                          uint64_t v344 = *((void *)&__dst + 1);
                                                                          v345 = (void *)__dst;
                                                                          if (*((void *)&__dst + 1) != (void)__dst)
                                                                          {
                                                                            do
                                                                            {
                                                                              v344 -= 24;
                                                                              boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v344);
                                                                            }
                                                                            while (v344 != v343);
                                                                            v345 = (void *)__dst;
                                                                          }
                                                                          *((void *)&__dst + 1) = v343;
                                                                          operator delete(v345);
                                                                        }
                                                                        dispatch_release(v552);
                                                                        if (v553) {
                                                                          _Block_release(v553);
                                                                        }
                                                                        if (atomic_fetch_add(&v527->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                                        {
                                                                          v346 = aBlockb;
                                                                          if (!aBlockb) {
                                                                            goto LABEL_649;
                                                                          }
LABEL_648:
                                                                          _Block_release(v346);
                                                                        }
                                                                        else
                                                                        {
                                                                          ((void (*)(std::__shared_weak_count *))v527->__on_zero_shared)(v527);
                                                                          std::__shared_weak_count::__release_weak(v527);
                                                                          v346 = aBlockb;
                                                                          if (aBlockb) {
                                                                            goto LABEL_648;
                                                                          }
                                                                        }
LABEL_649:
                                                                        v347 = operator new(0x20uLL);
                                                                        v347[1] = v538;
                                                                        uint64_t v348 = a1[24];
                                                                        *(void *)v347 = v348;
                                                                        *((void *)v347 + 1) = v525;
                                                                        *(void *)(v348 + 8) = v347;
                                                                        a1[24] = v347;
                                                                        ++a1[26];
                                                                        uint64_t v349 = a1[21];
                                                                        std::string __p = (void *)MEMORY[0x1E4F143A8];
                                                                        uint64_t v546 = 0x40000000;
                                                                        int64_t v547 = (int64_t)___ZN3ctu20SharedSynchronizableI5TraceE13connect_eventIN5boost8signals26signalIFvN8coredump13CommandDriver6StatusEENS5_19optional_last_valueIvEEiNSt3__14lessIiEENS4_8functionISA_EENSG_IFvRKNS5_10connectionES9_EEENS5_5mutexEEE16EURCoreDumpTracevJS9_EEEDTcl7connectfp_cvNSD_10shared_ptrIS1_EE_EcvP16dispatch_queue_s_EcvPFT1_DpT2_ELi0EEERT_MT0_FSU_SW_E_block_invoke;
                                                                        v548 = &__block_descriptor_tmp_111;
                                                                        v549 = a1 + 9;
                                                                        v550 = EURCoreDumpTrace::commandDriverStatus_sync;
                                                                        uint64_t v551 = 0;
                                                                        v350 = _Block_copy(&__p);
                                                                        uint64_t v535 = v349;
                                                                        v351 = (std::__shared_weak_count *)a1[10];
                                                                        if (!v351
                                                                          || (uint64_t v352 = a1[9],
                                                                              (v529 = std::__shared_weak_count::lock(v351)) == 0))
                                                                        {
                                                                          std::__throw_bad_weak_ptr[abi:ne180100]();
                                                                        }
                                                                        v353 = a1[11];
                                                                        dispatch_object_t v552 = v353;
                                                                        if (v350) {
                                                                          v354 = _Block_copy(v350);
                                                                        }
                                                                        else {
                                                                          v354 = 0;
                                                                        }
                                                                        v553 = v354;
                                                                        dispatch_retain(v353);
                                                                        long long __dst = 0u;
                                                                        long long v555 = 0u;
                                                                        dispatch_object_t v558 = v353;
                                                                        if (v354) {
                                                                          v354 = _Block_copy(v354);
                                                                        }
                                                                        v559 = v354;
                                                                        dispatch_retain(v353);
                                                                        dispatch_object_t v560 = v353;
                                                                        v528 = v350;
                                                                        if (v354)
                                                                        {
                                                                          v355 = _Block_copy(v354);
                                                                          v561 = v355;
                                                                          dispatch_retain(v353);
                                                                          if (v355)
                                                                          {
                                                                            v356 = _Block_copy(v355);
                                                                            dispatch_retain(v353);
                                                                            v562 = 0;
                                                                            if (v356)
                                                                            {
                                                                              v357 = _Block_copy(v356);
                                                                              dispatch_retain(v353);
                                                                              v516 = v356;
                                                                              if (v357)
                                                                              {
                                                                                v358 = _Block_copy(v357);
                                                                                dispatch_retain(v353);
                                                                                aBlockc = v357;
                                                                                if (v358)
                                                                                {
                                                                                  v359 = _Block_copy(v358);
                                                                                  dispatch_retain(v353);
                                                                                  if (v359)
                                                                                  {
                                                                                    v360 = _Block_copy(v359);
                                                                                    dispatch_retain(v353);
                                                                                    unint64_t v563 = (unint64_t)v353;
                                                                                    if (v360)
                                                                                    {
                                                                                      v361 = _Block_copy(v360);
                                                                                      char v362 = 0;
                                                                                      char v363 = 0;
                                                                                      char v364 = 0;
                                                                                      char v365 = 0;
                                                                                      char v366 = 0;
                                                                                      goto LABEL_671;
                                                                                    }
                                                                                    char v362 = 0;
                                                                                    char v363 = 0;
                                                                                    char v364 = 0;
                                                                                    char v365 = 0;
                                                                                    v361 = 0;
LABEL_670:
                                                                                    char v366 = 1;
LABEL_671:
                                                                                    v564 = v361;
                                                                                    dispatch_retain(v353);
                                                                                    dispatch_release(v353);
                                                                                    if ((v366 & 1) == 0) {
                                                                                      _Block_release(v360);
                                                                                    }
                                                                                    dispatch_release(v353);
                                                                                    if ((v365 & 1) == 0) {
                                                                                      _Block_release(v359);
                                                                                    }
                                                                                    dispatch_release(v353);
                                                                                    if ((v364 & 1) == 0) {
                                                                                      _Block_release(v358);
                                                                                    }
                                                                                    v562 = boost::function1<void,coredump::CommandDriver::Status>::assign_to<ctu::DispatchSlot<dispatch::block<void({block_pointer})(coredump::CommandDriver::Status)>>>(ctu::DispatchSlot<dispatch::block<void({block_pointer})(coredump::CommandDriver::Status)>>)::stored_vtable;
                                                                                    dispatch_release(v353);
                                                                                    if ((v363 & 1) == 0) {
                                                                                      _Block_release(aBlockc);
                                                                                    }
                                                                                    dispatch_release(v353);
                                                                                    if ((v362 & 1) == 0) {
                                                                                      _Block_release(v516);
                                                                                    }
                                                                                    *(void *)&long long v566 = 0xAAAAAAAAAAAAAAAALL;
                                                                                    *((void *)&v566 + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                                                    *(void *)&blocuint64_t k = 0;
                                                                                    *((void *)&block + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                                                    boost::function1<void,coredump::CommandDriver::Status>::move_assign((uint64_t)&block, (uint64_t *)&v562);
                                                                                    boost::function1<void,coredump::CommandDriver::Status>::move_assign((uint64_t)&v562, (uint64_t *)&v555 + 1);
                                                                                    boost::function1<void,coredump::CommandDriver::Status>::move_assign((uint64_t)&v555 + 8, (uint64_t *)&block);
                                                                                    if ((void)block)
                                                                                    {
                                                                                      if ((block & 1) == 0)
                                                                                      {
                                                                                        v367 = *(void (**)(char *, char *, uint64_t))(block & 0xFFFFFFFFFFFFFFFELL);
                                                                                        if (v367) {
                                                                                          v367((char *)&block + 8, (char *)&block + 8, 2);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    if (v562)
                                                                                    {
                                                                                      if ((v562 & 1) == 0)
                                                                                      {
                                                                                        v368 = *(void (**)(uint64_t, _WORD *, unsigned int))((unint64_t)v562 & 0xFFFFFFFFFFFFFFFELL);
                                                                                        if (v368) {
                                                                                          v368((uint64_t)&v563, &v563, 2u);
                                                                                        }
                                                                                      }
                                                                                      v562 = 0;
                                                                                    }
                                                                                    dispatch_release(v560);
                                                                                    if (v561) {
                                                                                      _Block_release(v561);
                                                                                    }
                                                                                    dispatch_release(v558);
                                                                                    if (v559) {
                                                                                      _Block_release(v559);
                                                                                    }
                                                                                    atomic_fetch_add_explicit(&v529->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                                                    v369 = operator new(0x18uLL);
                                                                                    void *v369 = &unk_1EFB0E178;
                                                                                    v369[1] = v352;
                                                                                    v369[2] = v529;
                                                                                    atomic_fetch_add_explicit(&v529->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                                                    v370 = operator new(0x18uLL);
                                                                                    void *v370 = &unk_1EFB0E178;
                                                                                    v370[1] = v352;
                                                                                    v370[2] = v529;
                                                                                    atomic_fetch_add_explicit(&v529->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                                                    *((void *)&block + 1) = v370;
                                                                                    LODWORD(block) = 2;
                                                                                    uint64_t v371 = *((void *)&__dst + 1);
                                                                                    if (*((void *)&__dst + 1) >= (unint64_t)v555)
                                                                                    {
                                                                                      v374 = std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::__push_back_slow_path<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>((void **)&__dst, (uint64_t)&block);
                                                                                      v373 = v529;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v372 = operator new(0x18uLL);
                                                                                      void *v372 = &unk_1EFB0E178;
                                                                                      v372[1] = v352;
                                                                                      v373 = v529;
                                                                                      v372[2] = v529;
                                                                                      atomic_fetch_add_explicit(&v529->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                                                                                      *(void *)(v371 + 8) = v372;
                                                                                      *(_DWORD *)uint64_t v371 = 2;
                                                                                      v374 = (_DWORD *)(v371 + 24);
                                                                                    }
                                                                                    *((void *)&__dst + 1) = v374;
                                                                                    boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content((uint64_t)&block);
                                                                                    (*(void (**)(void *))(*v369 + 8))(v369);
                                                                                    std::__shared_weak_count::__release_weak(v373);
                                                                                    v375 = *(uint64_t ***)(v535 + 112);
                                                                                    *(void *)&long long v376 = 0xAAAAAAAAAAAAAAAALL;
                                                                                    *((void *)&v376 + 1) = 0xAAAAAAAAAAAAAAAALL;
                                                                                    long long v573 = v376;
                                                                                    long long v574 = v376;
                                                                                    long long v571 = v376;
                                                                                    long long v572 = v376;
                                                                                    long long v569 = v376;
                                                                                    long long v570 = v376;
                                                                                    long long v567 = v376;
                                                                                    long long v568 = v376;
                                                                                    blocuint64_t k = v376;
                                                                                    long long v566 = v376;
                                                                                    v377 = (pthread_mutex_t *)v375[3];
                                                                                    unint64_t v575 = 10;
                                                                                    p_blocuint64_t k = &block;
                                                                                    uint64_t v577 = 0;
                                                                                    v578 = v377;
                                                                                    pthread_mutex_lock(v377);
                                                                                    v562 = (uint64_t (**)())0xAAAAAAAAAAAAAAAALL;
                                                                                    unint64_t v563 = 0xAAAAAAAAAAAAAAAALL;
                                                                                    v378 = (atomic_uint *)v375[1];
                                                                                    v536 = (uint64_t ***)v375;
                                                                                    if (v378
                                                                                      && atomic_load_explicit(v378 + 2, memory_order_acquire) == 1)
                                                                                    {
                                                                                      v379 = (uint64_t *)**v375;
                                                                                      v380 = v375[2];
                                                                                      int v381 = 2;
                                                                                      if (v380 != v379) {
                                                                                        goto LABEL_787;
                                                                                      }
                                                                                      goto LABEL_786;
                                                                                    }
                                                                                    v382 = (uint64_t **)operator new(0x20uLL);
                                                                                    v383 = *v375;
                                                                                    uint64_t v384 = **v375;
                                                                                    aBlockd = v382;
                                                                                    v385 = operator new(0x40uLL);
                                                                                    v386 = v385;
                                                                                    void *v385 = v385;
                                                                                    v385[1] = v385;
                                                                                    v385[2] = 0;
                                                                                    v387 = *(void **)(v384 + 8);
                                                                                    if (v387 != (void *)v384)
                                                                                    {
                                                                                      uint64_t v388 = 0;
                                                                                      v389 = v385;
                                                                                      do
                                                                                      {
                                                                                        v390 = operator new(0x20uLL);
                                                                                        v390[2] = v387[2];
                                                                                        uint64_t v391 = v387[3];
                                                                                        v390[3] = v391;
                                                                                        if (v391)
                                                                                        {
                                                                                          atomic_fetch_add_explicit((atomic_uint *volatile)(v391 + 8), 1u, memory_order_relaxed);
                                                                                          v389 = (void *)*v386;
                                                                                          uint64_t v388 = v386[2];
                                                                                        }
                                                                                        void *v390 = v389;
                                                                                        v390[1] = v386;
                                                                                        v389[1] = v390;
                                                                                        void *v386 = v390;
                                                                                        v386[2] = ++v388;
                                                                                        v387 = (void *)v387[1];
                                                                                        v389 = v390;
                                                                                      }
                                                                                      while (v387 != (void *)v384);
                                                                                    }
                                                                                    v517 = v383;
                                                                                    v386[3] = 0;
                                                                                    v392 = (void **)(v386 + 3);
                                                                                    v386[4] = 0;
                                                                                    v393 = v386 + 4;
                                                                                    v386[5] = 0;
                                                                                    *((unsigned char *)v386 + 48) = *(unsigned char *)(v384 + 48);
                                                                                    v386[3] = v386 + 4;
                                                                                    v394 = *(void **)(v384 + 24);
                                                                                    v395 = (void *)(v384 + 32);
                                                                                    if (v394 == (void *)(v384 + 32))
                                                                                    {
LABEL_707:
                                                                                      *((unsigned char *)v386 + 56) = *(unsigned char *)(v384 + 56);
                                                                                      v396 = *(void **)(v384 + 24);
                                                                                      if (v396 != v395)
                                                                                      {
                                                                                        v397 = (void *)v386[3];
                                                                                        uint64_t v398 = v386[1];
                                                                                        do
                                                                                        {
                                                                                          v397[6] = v398;
                                                                                          uint64_t v399 = v384;
                                                                                          if (v396 != v395) {
                                                                                            uint64_t v399 = v396[6];
                                                                                          }
                                                                                          v400 = (void *)v396[1];
                                                                                          v401 = v400;
                                                                                          v402 = v396;
                                                                                          if (v400)
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v403 = v401;
                                                                                              v401 = (void *)*v401;
                                                                                            }
                                                                                            while (v401);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v403 = (void *)v402[2];
                                                                                              BOOL v127 = *v403 == (void)v402;
                                                                                              v402 = v403;
                                                                                            }
                                                                                            while (!v127);
                                                                                          }
                                                                                          uint64_t v404 = v384;
                                                                                          if (v403 != v395) {
                                                                                            uint64_t v404 = v403[6];
                                                                                          }
                                                                                          while (v399 != v404)
                                                                                          {
                                                                                            uint64_t v399 = *(void *)(v399 + 8);
                                                                                            uint64_t v398 = *(void *)(v398 + 8);
                                                                                          }
                                                                                          if (v400)
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v405 = v400;
                                                                                              v400 = (void *)*v400;
                                                                                            }
                                                                                            while (v400);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v405 = (void *)v396[2];
                                                                                              BOOL v127 = *v405 == (void)v396;
                                                                                              v396 = v405;
                                                                                            }
                                                                                            while (!v127);
                                                                                          }
                                                                                          v406 = (void *)v397[1];
                                                                                          if (v406)
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v407 = v406;
                                                                                              v406 = (void *)*v406;
                                                                                            }
                                                                                            while (v406);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            do
                                                                                            {
                                                                                              v407 = (void *)v397[2];
                                                                                              BOOL v127 = *v407 == (void)v397;
                                                                                              v397 = v407;
                                                                                            }
                                                                                            while (!v127);
                                                                                          }
                                                                                          v396 = v405;
                                                                                          v397 = v407;
                                                                                        }
                                                                                        while (v405 != v395);
                                                                                      }
                                                                                      *aBlockd = v386;
                                                                                      aBlockd[1] = 0;
                                                                                      v427 = (uint64_t *)operator new(0x18uLL);
                                                                                      v375 = (uint64_t **)v536;
                                                                                      v427[1] = 0x100000001;
                                                                                      uint64_t *v427 = (uint64_t)&unk_1EFB0E4A0;
                                                                                      v427[2] = (uint64_t)v386;
                                                                                      aBlockd[1] = v427;
                                                                                      aBlockd[2] = (uint64_t *)v517[2];
                                                                                      uint64_t v428 = v517[3];
                                                                                      aBlockd[3] = (uint64_t *)v428;
                                                                                      if (v428) {
                                                                                        atomic_fetch_add_explicit((atomic_uint *volatile)(v428 + 8), 1u, memory_order_relaxed);
                                                                                      }
                                                                                      v429 = (uint64_t **)operator new(0x18uLL);
                                                                                      v429[1] = (uint64_t *)0x100000001;
                                                                                      *v429 = (uint64_t *)&unk_1EFB0E440;
                                                                                      v429[2] = (uint64_t *)aBlockd;
                                                                                      v430 = (atomic_uint *)v536[1];
                                                                                      *v536 = aBlockd;
                                                                                      v536[1] = v429;
                                                                                      if (v430)
                                                                                      {
                                                                                        if (atomic_fetch_add(v430 + 2, 0xFFFFFFFF) == 1)
                                                                                        {
                                                                                          (*(void (**)(atomic_uint *))(*(void *)v430 + 16))(v430);
                                                                                          if (atomic_fetch_add(v430 + 3, 0xFFFFFFFF) == 1)(*(void (**)(atomic_uint *))(*(void *)v430 + 24))(v430); {
                                                                                        }
                                                                                          }
                                                                                      }
                                                                                      int v381 = 0;
                                                                                      v379 = **v536;
LABEL_786:
                                                                                      v380 = (uint64_t *)v379[1];
                                                                                      if (v379 == v380) {
                                                                                        goto LABEL_886;
                                                                                      }
LABEL_787:
                                                                                      int v431 = 0;
                                                                                      unsigned int v432 = v381 - 1;
LABEL_795:
                                                                                      uint64_t v435 = v380[2];
                                                                                      v436 = *(uint64_t **)(v435 + 32);
                                                                                      if (!v436) {
                                                                                        goto LABEL_788;
                                                                                      }
                                                                                      for (uint64_t k = *v436; ; k += 24)
                                                                                      {
                                                                                        if (k == v436[1]) {
                                                                                          goto LABEL_788;
                                                                                        }
                                                                                        if ((*(_DWORD *)k ^ (*(int *)k >> 31)) > 1)
                                                                                        {
                                                                                          if ((*(uint64_t (**)(void))(**(void **)(k + 8) + 24))(*(void *)(k + 8))) {
                                                                                            goto LABEL_804;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          uint64_t v438 = *(void *)(k + 16);
                                                                                          if (!v438
                                                                                            || !atomic_load_explicit((atomic_uint *volatile)(v438 + 8), memory_order_acquire))
                                                                                          {
LABEL_804:
                                                                                            if (*(unsigned char *)(v435 + 24))
                                                                                            {
                                                                                              *(unsigned char *)(v435 + 24) = 0;
                                                                                              boost::signals2::detail::connection_body_base::dec_slot_refcount<boost::signals2::mutex>((_DWORD *)v435, &block);
                                                                                            }
LABEL_788:
                                                                                            uint64_t v433 = v380[2];
                                                                                            if (*(unsigned char *)(v433 + 24))
                                                                                            {
                                                                                              v379 = (uint64_t *)v380[1];
                                                                                              goto LABEL_790;
                                                                                            }
                                                                                            uint64_t v439 = **v375;
                                                                                            v441 = (uint64_t **)(v439 + 32);
                                                                                            v440 = *(char **)(v439 + 32);
                                                                                            if (!v440)
                                                                                            {
                                                                                              if (*(uint64_t **)(v439 + 80) != v380) {
                                                                                                goto LABEL_881;
                                                                                              }
                                                                                              v463 = (uint64_t *)v380[1];
                                                                                              v465 = (uint64_t **)(v439 + 32);
                                                                                              v444 = (uint64_t *)(v439 + 32);
                                                                                              if (v463 != (uint64_t *)v439) {
                                                                                                goto LABEL_877;
                                                                                              }
                                                                                              goto LABEL_859;
                                                                                            }
                                                                                            int v442 = *(_DWORD *)(v433 + 64);
                                                                                            int v443 = *(_DWORD *)(v433 + 72);
                                                                                            v444 = (uint64_t *)(v439 + 32);
                                                                                            uint64_t v445 = *(void *)(v439 + 32);
                                                                                            if (v442 == 1)
                                                                                            {
                                                                                              v444 = (uint64_t *)(v439 + 32);
                                                                                              uint64_t v446 = *(void *)(v439 + 32);
                                                                                              do
                                                                                              {
                                                                                                while (1)
                                                                                                {
                                                                                                  int v452 = *(_DWORD *)(v446 + 32);
                                                                                                  BOOL v453 = v452 < 1;
                                                                                                  if (v452 == 1) {
                                                                                                    BOOL v453 = *(_DWORD *)(v446 + 40) < v443;
                                                                                                  }
                                                                                                  if (!v453) {
                                                                                                    break;
                                                                                                  }
                                                                                                  uint64_t v446 = *(void *)(v446 + 8);
                                                                                                  if (!v446) {
                                                                                                    goto LABEL_825;
                                                                                                  }
                                                                                                }
                                                                                                v444 = (uint64_t *)v446;
                                                                                                uint64_t v446 = *(void *)v446;
                                                                                              }
                                                                                              while (v446);
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              do
                                                                                              {
                                                                                                int v447 = *(_DWORD *)(v445 + 32);
                                                                                                BOOL v448 = v447 == v442;
                                                                                                BOOL v449 = v447 < v442;
                                                                                                if (v447 >= v442) {
                                                                                                  v450 = (uint64_t *)v445;
                                                                                                }
                                                                                                else {
                                                                                                  v450 = (uint64_t *)(v445 + 8);
                                                                                                }
                                                                                                if (v449) {
                                                                                                  v451 = v444;
                                                                                                }
                                                                                                else {
                                                                                                  v451 = (uint64_t *)v445;
                                                                                                }
                                                                                                if (v448)
                                                                                                {
                                                                                                  v450 = (uint64_t *)v445;
                                                                                                  v444 = (uint64_t *)v445;
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  v444 = v451;
                                                                                                }
                                                                                                uint64_t v445 = *v450;
                                                                                              }
                                                                                              while (*v450);
                                                                                            }
LABEL_825:
                                                                                            if ((uint64_t *)v444[6] != v380) {
                                                                                              goto LABEL_881;
                                                                                            }
                                                                                            v454 = (uint64_t **)(v439 + 32);
                                                                                            v455 = *(uint64_t ***)(v439 + 32);
                                                                                            if (v442 != 1)
                                                                                            {
                                                                                              do
                                                                                              {
                                                                                                int v456 = *((_DWORD *)v455 + 8);
                                                                                                v457 = (uint64_t ***)(v455 + 1);
                                                                                                BOOL v458 = v442 == v456;
                                                                                                BOOL v459 = v442 < v456;
                                                                                                if (v442 >= v456) {
                                                                                                  v460 = (uint64_t ***)(v455 + 1);
                                                                                                }
                                                                                                else {
                                                                                                  v460 = (uint64_t ***)v455;
                                                                                                }
                                                                                                if (!v459) {
                                                                                                  v455 = v454;
                                                                                                }
                                                                                                if (v458) {
                                                                                                  v460 = v457;
                                                                                                }
                                                                                                else {
                                                                                                  v454 = v455;
                                                                                                }
                                                                                                v455 = *v460;
                                                                                              }
                                                                                              while (*v460);
LABEL_843:
                                                                                              v462 = (uint64_t *)v439;
                                                                                              if (v454 != v441) {
                                                                                                v462 = v454[6];
                                                                                              }
                                                                                              v463 = (uint64_t *)v380[1];
                                                                                              if (v463 != v462)
                                                                                              {
                                                                                                if (v442 != 1)
                                                                                                {
                                                                                                  int v464 = *((_DWORD *)v440 + 8);
                                                                                                  if (v442 == v464) {
                                                                                                    goto LABEL_880;
                                                                                                  }
                                                                                                  while (2)
                                                                                                  {
                                                                                                    if (v442 >= v464)
                                                                                                    {
                                                                                                      if (v464 >= v442) {
                                                                                                        goto LABEL_880;
                                                                                                      }
                                                                                                      uint64_t v471 = *((void *)v440 + 1);
                                                                                                      if (!v471)
                                                                                                      {
                                                                                                        v441 = (uint64_t **)(v440 + 8);
                                                                                                        goto LABEL_876;
                                                                                                      }
                                                                                                      goto LABEL_868;
                                                                                                    }
                                                                                                    uint64_t v471 = *(void *)v440;
                                                                                                    if (*(void *)v440)
                                                                                                    {
LABEL_868:
                                                                                                      int v464 = *(_DWORD *)(v471 + 32);
                                                                                                      v440 = (char *)v471;
                                                                                                      if (v442 == v464)
                                                                                                      {
                                                                                                        *(void *)(v471 + 48) = v463;
                                                                                                        goto LABEL_881;
                                                                                                      }
                                                                                                      continue;
                                                                                                    }
                                                                                                    break;
                                                                                                  }
                                                                                                  v441 = (uint64_t **)v440;
LABEL_876:
                                                                                                  v465 = (uint64_t **)v440;
LABEL_877:
                                                                                                  v440 = (char *)operator new(0x38uLL);
                                                                                                  uint64_t v472 = *(void *)(v433 + 64);
                                                                                                  *((_DWORD *)v440 + 10) = *(_DWORD *)(v433 + 72);
                                                                                                  *((void *)v440 + 4) = v472;
                                                                                                  *((void *)v440 + 6) = 0;
                                                                                                  *(void *)v440 = 0;
                                                                                                  *((void *)v440 + 1) = 0;
                                                                                                  *((void *)v440 + 2) = v465;
                                                                                                  *v441 = (uint64_t *)v440;
                                                                                                  uint64_t v473 = **(void **)(v439 + 24);
                                                                                                  v474 = (uint64_t *)v440;
                                                                                                  if (v473)
                                                                                                  {
                                                                                                    *(void *)(v439 + 24) = v473;
                                                                                                    v474 = *v441;
                                                                                                  }
                                                                                                  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v439 + 32), v474);
                                                                                                  ++*(void *)(v439 + 40);
LABEL_880:
                                                                                                  *((void *)v440 + 6) = v463;
LABEL_881:
                                                                                                  uint64_t v475 = *v380;
                                                                                                  v379 = (uint64_t *)v380[1];
                                                                                                  *(void *)(v475 + 8) = v379;
                                                                                                  *(void *)v380[1] = v475;
                                                                                                  --*(void *)(v439 + 16);
                                                                                                  v476 = (atomic_uint *)v380[3];
                                                                                                  if (v476)
                                                                                                  {
                                                                                                    if (atomic_fetch_add(v476 + 2, 0xFFFFFFFF) == 1)
                                                                                                    {
                                                                                                      (*(void (**)(atomic_uint *))(*(void *)v476 + 16))(v476);
                                                                                                      if (atomic_fetch_add(v476 + 3, 0xFFFFFFFF) == 1) {
                                                                                                        (*(void (**)(atomic_uint *))(*(void *)v476 + 24))(v476);
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                  operator delete(v380);
                                                                                                  v375 = (uint64_t **)v536;
LABEL_790:
                                                                                                  BOOL v434 = v379 != (uint64_t *)**v375 && v432 >= ++v431;
                                                                                                  v380 = v379;
                                                                                                  if (!v434)
                                                                                                  {
LABEL_886:
                                                                                                    v375[2] = v379;
                                                                                                    v477 = operator new(0x50uLL);
                                                                                                    v477[1] = 0;
                                                                                                    v477[2] = 0;
                                                                                                    *((unsigned char *)v477 + 24) = 1;
                                                                                                    *((_DWORD *)v477 + 7) = 1;
                                                                                                    void *v477 = &unk_1EFB0E500;
                                                                                                    v478 = operator new(0x38uLL);
                                                                                                    std::vector<boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>>::vector(v478, (uint64_t *)&__dst);
                                                                                                    v478[3] = 0;
                                                                                                    uint64_t v479 = *((void *)&v555 + 1);
                                                                                                    if (*((void *)&v555 + 1))
                                                                                                    {
                                                                                                      v478[3] = *((void *)&v555 + 1);
                                                                                                      if (v479)
                                                                                                      {
                                                                                                        *((_OWORD *)v478 + 2) = v556;
                                                                                                        v478[6] = v557;
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        (*(void (**)(long long *, void *, void))(v479 & 0xFFFFFFFFFFFFFFFELL))(&v556, v478 + 4, 0);
                                                                                                      }
                                                                                                    }
                                                                                                    v477[4] = v478;
                                                                                                    v477[5] = 0;
                                                                                                    v480 = operator new(0x18uLL);
                                                                                                    v480[1] = 0x100000001;
                                                                                                    void *v480 = &unk_1EFB0E558;
                                                                                                    v480[2] = v478;
                                                                                                    v477[5] = v480;
                                                                                                    v477[6] = v375[3];
                                                                                                    v481 = (atomic_uint *)v375[4];
                                                                                                    v477[7] = v481;
                                                                                                    if (v481) {
                                                                                                      atomic_fetch_add_explicit(v481 + 2, 1u, memory_order_relaxed);
                                                                                                    }
                                                                                                    *((_DWORD *)v477 + 16) = 0;
                                                                                                    *((unsigned char *)v477 + 68) = 0;
                                                                                                    v562 = (uint64_t (**)())v477;
                                                                                                    v482 = operator new(0x18uLL);
                                                                                                    *((void *)v482 + 1) = 0x100000001;
                                                                                                    *(void *)v482 = &unk_1EFB0E5B8;
                                                                                                    *((void *)v482 + 2) = v477;
                                                                                                    unint64_t v563 = (unint64_t)v482;
                                                                                                    v483 = (uint64_t *)**v375;
                                                                                                    v484 = operator new(0x20uLL);
                                                                                                    v485 = v483 + 4;
                                                                                                    v484[2] = v477;
                                                                                                    v484[3] = v482;
                                                                                                    atomic_fetch_add_explicit((atomic_uint *volatile)v482 + 2, 1u, memory_order_relaxed);
                                                                                                    uint64_t v486 = *v483;
                                                                                                    *(void *)(v486 + 8) = v484;
                                                                                                    void *v484 = v486;
                                                                                                    uint64_t *v483 = (uint64_t)v484;
                                                                                                    v484[1] = v483;
                                                                                                    ++v483[2];
                                                                                                    v487 = (uint64_t *)v483[4];
                                                                                                    if (v487)
                                                                                                    {
                                                                                                      v488 = v483 + 4;
                                                                                                      uint64_t v489 = v483[4];
                                                                                                      do
                                                                                                      {
                                                                                                        int v490 = *(_DWORD *)(v489 + 32);
                                                                                                        BOOL v491 = v490 == 2;
                                                                                                        BOOL v492 = v490 < 2;
                                                                                                        if (v490 >= 2) {
                                                                                                          v493 = (uint64_t *)v489;
                                                                                                        }
                                                                                                        else {
                                                                                                          v493 = (uint64_t *)(v489 + 8);
                                                                                                        }
                                                                                                        if (!v492) {
                                                                                                          v488 = (uint64_t *)v489;
                                                                                                        }
                                                                                                        if (v491)
                                                                                                        {
                                                                                                          v493 = (uint64_t *)v489;
                                                                                                          v488 = (uint64_t *)v489;
                                                                                                        }
                                                                                                        uint64_t v489 = *v493;
                                                                                                      }
                                                                                                      while (*v493);
                                                                                                      if (v488 == v485 || *((_DWORD *)v488 + 8) != 2)
                                                                                                      {
                                                                                                        int v494 = *((_DWORD *)v487 + 8);
                                                                                                        while (v494 != 2)
                                                                                                        {
                                                                                                          if (v494 < 3)
                                                                                                          {
                                                                                                            v495 = (uint64_t *)v487[1];
                                                                                                            if (!v495)
                                                                                                            {
                                                                                                              v485 = v487 + 1;
                                                                                                              goto LABEL_913;
                                                                                                            }
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            v495 = (uint64_t *)*v487;
                                                                                                            v485 = v487;
                                                                                                            if (!*v487) {
                                                                                                              goto LABEL_913;
                                                                                                            }
                                                                                                          }
                                                                                                          int v494 = *((_DWORD *)v495 + 8);
                                                                                                          v487 = v495;
                                                                                                        }
                                                                                                      }
                                                                                                      *((_DWORD *)v477 + 16) = 2;
                                                                                                      *(void *)((char *)v477 + 68) = 0xAAAAAAAAAAAAAA00;
LABEL_916:
                                                                                                      atomic_fetch_add_explicit((atomic_uint *volatile)v482 + 3, 1u, memory_order_relaxed);
                                                                                                      *(void *)&long long v539 = v477;
                                                                                                      *((void *)&v539 + 1) = v482;
                                                                                                      atomic_fetch_add_explicit((atomic_uint *volatile)v482 + 3, 1u, memory_order_relaxed);
                                                                                                      if (atomic_fetch_add((atomic_uint *volatile)v482 + 3, 0xFFFFFFFF) == 1) {
                                                                                                        (*(void (**)(void *))(*(void *)v482 + 24))(v482);
                                                                                                      }
                                                                                                      v498 = (atomic_uint *)v563;
                                                                                                      if (v563) {
                                                                                                        goto LABEL_919;
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      v487 = v483 + 4;
LABEL_913:
                                                                                                      v496 = operator new(0x38uLL);
                                                                                                      v496[4] = 0xAAAAAA0000000002;
                                                                                                      *((_DWORD *)v496 + 10) = -1431655766;
                                                                                                      v496[6] = v484;
                                                                                                      void *v496 = 0;
                                                                                                      v496[1] = 0;
                                                                                                      v496[2] = v487;
                                                                                                      uint64_t *v485 = (uint64_t)v496;
                                                                                                      uint64_t v497 = *(void *)v483[3];
                                                                                                      if (v497)
                                                                                                      {
                                                                                                        v483[3] = v497;
                                                                                                        v496 = (void *)*v485;
                                                                                                      }
                                                                                                      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v483[4], v496);
                                                                                                      ++v483[5];
                                                                                                      v477 = v562;
                                                                                                      v482 = (void *)v563;
                                                                                                      *((_DWORD *)v562 + 16) = 2;
                                                                                                      *(void *)((char *)v477 + 68) = 0xAAAAAAAAAAAAAA00;
                                                                                                      if (v482) {
                                                                                                        goto LABEL_916;
                                                                                                      }
                                                                                                      long long v539 = (unint64_t)v477;
                                                                                                      v498 = (atomic_uint *)v563;
                                                                                                      if (v563)
                                                                                                      {
LABEL_919:
                                                                                                        if (atomic_fetch_add(v498 + 2, 0xFFFFFFFF) == 1)
                                                                                                        {
                                                                                                          (*(void (**)(atomic_uint *))(*(void *)v498 + 16))(v498);
                                                                                                          if (atomic_fetch_add(v498 + 3, 0xFFFFFFFF) == 1) {
                                                                                                            (*(void (**)(atomic_uint *))(*(void *)v498 + 24))(v498);
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                    pthread_mutex_unlock(v578);
                                                                                                    v499 = (char *)p_block;
                                                                                                    if (p_block)
                                                                                                    {
                                                                                                      if (v577 - 1 >= 0)
                                                                                                      {
                                                                                                        v500 = (char *)p_block + 16 * v577;
                                                                                                        do
                                                                                                        {
                                                                                                          v501 = (atomic_uint *)*((void *)v500 - 1);
                                                                                                          if (v501)
                                                                                                          {
                                                                                                            if (atomic_fetch_add(v501 + 2, 0xFFFFFFFF) == 1)
                                                                                                            {
                                                                                                              (*(void (**)(atomic_uint *))(*(void *)v501 + 16))(v501);
                                                                                                              if (atomic_fetch_add(v501 + 3, 0xFFFFFFFF) == 1) {
                                                                                                                (*(void (**)(atomic_uint *))(*(void *)v501 + 24))(v501);
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                          v500 -= 16;
                                                                                                        }
                                                                                                        while (v500 > v499);
                                                                                                      }
                                                                                                      if (v575 >= 0xB) {
                                                                                                        operator delete(p_block);
                                                                                                      }
                                                                                                    }
                                                                                                    if (*((void *)&v555 + 1))
                                                                                                    {
                                                                                                      if ((BYTE8(v555) & 1) == 0)
                                                                                                      {
                                                                                                        v502 = *(void (**)(long long *, long long *, uint64_t))(*((void *)&v555 + 1) & 0xFFFFFFFFFFFFFFFELL);
                                                                                                        if (v502) {
                                                                                                          v502(&v556, &v556, 2);
                                                                                                        }
                                                                                                      }
                                                                                                      *((void *)&v555 + 1) = 0;
                                                                                                    }
                                                                                                    uint64_t v503 = __dst;
                                                                                                    if ((void)__dst)
                                                                                                    {
                                                                                                      uint64_t v504 = *((void *)&__dst + 1);
                                                                                                      v505 = (void *)__dst;
                                                                                                      if (*((void *)&__dst + 1) != (void)__dst)
                                                                                                      {
                                                                                                        do
                                                                                                        {
                                                                                                          v504 -= 24;
                                                                                                          boost::variant<boost::weak_ptr<boost::signals2::detail::trackable_pointee>,boost::weak_ptr<void>,boost::signals2::detail::foreign_void_weak_ptr>::destroy_content(v504);
                                                                                                        }
                                                                                                        while (v504 != v503);
                                                                                                        v505 = (void *)__dst;
                                                                                                      }
                                                                                                      *((void *)&__dst + 1) = v503;
                                                                                                      operator delete(v505);
                                                                                                    }
                                                                                                    dispatch_release(v552);
                                                                                                    if (v553) {
                                                                                                      _Block_release(v553);
                                                                                                    }
                                                                                                    if (atomic_fetch_add(&v529->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                                                                    {
                                                                                                      v506 = v528;
                                                                                                      if (!v528)
                                                                                                      {
LABEL_950:
                                                                                                        v507 = operator new(0x20uLL);
                                                                                                        v507[1] = v539;
                                                                                                        uint64_t v508 = a1[24];
                                                                                                        *(void *)v507 = v508;
                                                                                                        *((void *)v507 + 1) = v525;
                                                                                                        *(void *)(v508 + 8) = v507;
                                                                                                        a1[24] = v507;
                                                                                                        ++a1[26];
                                                                                                        return v523;
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      ((void (*)(std::__shared_weak_count *))v529->__on_zero_shared)(v529);
                                                                                                      std::__shared_weak_count::__release_weak(v529);
                                                                                                      v506 = v528;
                                                                                                      if (!v528) {
                                                                                                        goto LABEL_950;
                                                                                                      }
                                                                                                    }
                                                                                                    _Block_release(v506);
                                                                                                    goto LABEL_950;
                                                                                                  }
                                                                                                  goto LABEL_795;
                                                                                                }
                                                                                                while (1)
                                                                                                {
                                                                                                  v465 = (uint64_t **)v440;
                                                                                                  int v466 = *((_DWORD *)v440 + 8);
                                                                                                  if (v466 == 1)
                                                                                                  {
                                                                                                    int v467 = *((_DWORD *)v440 + 10);
                                                                                                    if (v467 <= v443)
                                                                                                    {
                                                                                                      if (v467 >= v443)
                                                                                                      {
                                                                                                        *((void *)v440 + 6) = v463;
                                                                                                        goto LABEL_881;
                                                                                                      }
LABEL_855:
                                                                                                      v440 = (char *)*((void *)v440 + 1);
                                                                                                      if (!v440)
                                                                                                      {
                                                                                                        v441 = v465 + 1;
                                                                                                        goto LABEL_877;
                                                                                                      }
                                                                                                      continue;
                                                                                                    }
                                                                                                  }
                                                                                                  else if (v466 <= 1)
                                                                                                  {
                                                                                                    goto LABEL_855;
                                                                                                  }
                                                                                                  v440 = *(char **)v440;
                                                                                                  if (!*v465)
                                                                                                  {
                                                                                                    v441 = v465;
                                                                                                    goto LABEL_877;
                                                                                                  }
                                                                                                }
                                                                                              }
LABEL_859:
                                                                                              v468 = (uint64_t *)v444[1];
                                                                                              v469 = v444;
                                                                                              if (v468)
                                                                                              {
                                                                                                do
                                                                                                {
                                                                                                  v470 = v468;
                                                                                                  v468 = (uint64_t *)*v468;
                                                                                                }
                                                                                                while (v468);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                do
                                                                                                {
                                                                                                  v470 = (uint64_t *)v469[2];
                                                                                                  BOOL v127 = *v470 == (void)v469;
                                                                                                  v469 = v470;
                                                                                                }
                                                                                                while (!v127);
                                                                                              }
                                                                                              if (*(uint64_t **)(v439 + 24) == v444) {
                                                                                                *(void *)(v439 + 24) = v470;
                                                                                              }
                                                                                              --*(void *)(v439 + 40);
                                                                                              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v440, v444);
                                                                                              operator delete(v444);
                                                                                              goto LABEL_881;
                                                                                            }
                                                                                            while (1)
                                                                                            {
                                                                                              int v461 = *((_DWORD *)v455 + 8);
                                                                                              if (v461 == 1)
                                                                                              {
                                                                                                if (v443 >= *((_DWORD *)v455 + 10)) {
                                                                                                  goto LABEL_837;
                                                                                                }
                                                                                              }
                                                                                              else if (v461 <= 1)
                                                                                              {
LABEL_837:
                                                                                                v455 = (uint64_t **)v455[1];
                                                                                                if (!v455) {
                                                                                                  goto LABEL_843;
                                                                                                }
                                                                                                continue;
                                                                                              }
                                                                                              v454 = v455;
                                                                                              v455 = (uint64_t **)*v455;
                                                                                              if (!v455) {
                                                                                                goto LABEL_843;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    while (2)
                                                                                    {
                                                                                      int v408 = *((_DWORD *)v394 + 8);
                                                                                      v409 = (void *)*v393;
                                                                                      v410 = v386 + 4;
                                                                                      if (*v392 == v393) {
                                                                                        goto LABEL_744;
                                                                                      }
                                                                                      v411 = (void *)*v393;
                                                                                      v412 = v386 + 4;
                                                                                      if (v409)
                                                                                      {
                                                                                        do
                                                                                        {
                                                                                          v410 = v411;
                                                                                          v411 = (void *)v411[1];
                                                                                        }
                                                                                        while (v411);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        do
                                                                                        {
                                                                                          v410 = (void *)v412[2];
                                                                                          BOOL v127 = *v410 == (void)v412;
                                                                                          v412 = v410;
                                                                                        }
                                                                                        while (v127);
                                                                                      }
                                                                                      int v413 = *((_DWORD *)v394 + 10);
                                                                                      int v414 = *((_DWORD *)v410 + 8);
                                                                                      if (v414 == v408)
                                                                                      {
                                                                                        if (v408 == 1)
                                                                                        {
                                                                                          if (*((_DWORD *)v410 + 10) >= v413)
                                                                                          {
                                                                                            v415 = (void *)*v393;
                                                                                            v416 = v386 + 4;
                                                                                            v417 = v386 + 4;
                                                                                            if (v409) {
                                                                                              goto LABEL_756;
                                                                                            }
LABEL_763:
                                                                                            v421 = operator new(0x38uLL);
                                                                                            long long v422 = *((_OWORD *)v394 + 2);
                                                                                            v421[6] = v394[6];
                                                                                            *((_OWORD *)v421 + 2) = v422;
                                                                                            void *v421 = 0;
                                                                                            v421[1] = 0;
                                                                                            v421[2] = v417;
                                                                                            void *v416 = v421;
                                                                                            v423 = (void *)**v392;
                                                                                            if (v423)
                                                                                            {
                                                                                              *v392 = v423;
                                                                                              v421 = (void *)*v416;
                                                                                            }
                                                                                            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v386[4], v421);
                                                                                            ++v386[5];
LABEL_766:
                                                                                            v424 = (void *)v394[1];
                                                                                            if (v424)
                                                                                            {
                                                                                              do
                                                                                              {
                                                                                                v425 = v424;
                                                                                                v424 = (void *)*v424;
                                                                                              }
                                                                                              while (v424);
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              do
                                                                                              {
                                                                                                v425 = (void *)v394[2];
                                                                                                BOOL v127 = *v425 == (void)v394;
                                                                                                v394 = v425;
                                                                                              }
                                                                                              while (!v127);
                                                                                            }
                                                                                            v394 = v425;
                                                                                            if (v425 == v395) {
                                                                                              goto LABEL_707;
                                                                                            }
                                                                                            continue;
                                                                                          }
LABEL_744:
                                                                                          if (v409) {
                                                                                            v417 = v410;
                                                                                          }
                                                                                          else {
                                                                                            v417 = v386 + 4;
                                                                                          }
                                                                                          if (v409) {
                                                                                            v416 = v410 + 1;
                                                                                          }
                                                                                          else {
                                                                                            v416 = v386 + 4;
                                                                                          }
                                                                                          if (!*v416) {
                                                                                            goto LABEL_763;
                                                                                          }
                                                                                          goto LABEL_766;
                                                                                        }
                                                                                      }
                                                                                      else if (v414 < v408)
                                                                                      {
                                                                                        goto LABEL_744;
                                                                                      }
                                                                                      break;
                                                                                    }
                                                                                    v416 = v386 + 4;
                                                                                    v417 = v386 + 4;
                                                                                    if (!v409) {
                                                                                      goto LABEL_763;
                                                                                    }
                                                                                    v415 = (void *)*v393;
                                                                                    if (v408 != 1)
                                                                                    {
                                                                                      int v418 = *((_DWORD *)v409 + 8);
                                                                                      v417 = (void *)*v393;
                                                                                      while (v408 != v418)
                                                                                      {
                                                                                        if (v408 < v418)
                                                                                        {
                                                                                          uint64_t v426 = *v417;
                                                                                          v416 = v417;
                                                                                          if (!*v417) {
                                                                                            goto LABEL_763;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          if (v418 >= v408) {
                                                                                            goto LABEL_766;
                                                                                          }
                                                                                          uint64_t v426 = v417[1];
                                                                                          if (!v426) {
                                                                                            goto LABEL_762;
                                                                                          }
                                                                                        }
                                                                                        int v418 = *(_DWORD *)(v426 + 32);
                                                                                        v417 = (void *)v426;
                                                                                      }
                                                                                      goto LABEL_766;
                                                                                    }
                                                                                    while (1)
                                                                                    {
LABEL_756:
                                                                                      v417 = v415;
                                                                                      int v419 = *((_DWORD *)v415 + 8);
                                                                                      if (v419 == 1)
                                                                                      {
                                                                                        int v420 = *((_DWORD *)v415 + 10);
                                                                                        if (v420 > v413) {
                                                                                          goto LABEL_755;
                                                                                        }
                                                                                        if (v420 >= v413) {
                                                                                          goto LABEL_766;
                                                                                        }
                                                                                      }
                                                                                      else if (v419 > 1)
                                                                                      {
LABEL_755:
                                                                                        v415 = (void *)*v415;
                                                                                        v416 = v417;
                                                                                        if (!*v417) {
                                                                                          goto LABEL_763;
                                                                                        }
                                                                                        continue;
                                                                                      }
                                                                                      v415 = (void *)v415[1];
                                                                                      if (!v415)
                                                                                      {
LABEL_762:
                                                                                        v416 = v417 + 1;
                                                                                        goto LABEL_763;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  char v362 = 0;
                                                                                  char v363 = 0;
                                                                                  char v364 = 0;
LABEL_669:
                                                                                  dispatch_retain(v353);
                                                                                  v359 = 0;
                                                                                  v360 = 0;
                                                                                  v361 = 0;
                                                                                  unint64_t v563 = (unint64_t)v353;
                                                                                  char v365 = 1;
                                                                                  goto LABEL_670;
                                                                                }
                                                                                char v362 = 0;
                                                                                char v363 = 0;
LABEL_668:
                                                                                dispatch_retain(v353);
                                                                                v358 = 0;
                                                                                char v364 = 1;
                                                                                goto LABEL_669;
                                                                              }
                                                                              char v362 = 0;
LABEL_667:
                                                                              dispatch_retain(v353);
                                                                              aBlockc = 0;
                                                                              char v363 = 1;
                                                                              goto LABEL_668;
                                                                            }
LABEL_666:
                                                                            dispatch_retain(v353);
                                                                            v516 = 0;
                                                                            char v362 = 1;
                                                                            goto LABEL_667;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          v561 = 0;
                                                                          dispatch_retain(v353);
                                                                        }
                                                                        dispatch_retain(v353);
                                                                        v562 = 0;
                                                                        goto LABEL_666;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      v335 = (uint64_t *)*v327;
                                                                      v325 = v327;
                                                                      if (!*v327) {
                                                                        goto LABEL_612;
                                                                      }
                                                                    }
                                                                    int v334 = *((_DWORD *)v335 + 8);
                                                                    v327 = v335;
                                                                  }
                                                                }
                                                                goto LABEL_494;
                                                              }
                                                            }
                                                          }
                                                        }
                                                        while (2)
                                                        {
                                                          int v248 = *((_DWORD *)v234 + 8);
                                                          v249 = (void *)*v233;
                                                          v250 = v226 + 4;
                                                          if (*v232 == v233) {
                                                            goto LABEL_443;
                                                          }
                                                          v251 = (void *)*v233;
                                                          v252 = v226 + 4;
                                                          if (v249)
                                                          {
                                                            do
                                                            {
                                                              v250 = v251;
                                                              v251 = (void *)v251[1];
                                                            }
                                                            while (v251);
                                                          }
                                                          else
                                                          {
                                                            do
                                                            {
                                                              v250 = (void *)v252[2];
                                                              BOOL v127 = *v250 == (void)v252;
                                                              v252 = v250;
                                                            }
                                                            while (v127);
                                                          }
                                                          int v253 = *((_DWORD *)v234 + 10);
                                                          int v254 = *((_DWORD *)v250 + 8);
                                                          if (v254 == v248)
                                                          {
                                                            if (v248 == 1)
                                                            {
                                                              if (*((_DWORD *)v250 + 10) >= v253)
                                                              {
                                                                v255 = (void *)*v233;
                                                                v256 = v226 + 4;
                                                                v257 = v226 + 4;
                                                                if (v249) {
                                                                  goto LABEL_455;
                                                                }
LABEL_462:
                                                                v261 = operator new(0x38uLL);
                                                                long long v262 = *((_OWORD *)v234 + 2);
                                                                v261[6] = v234[6];
                                                                *((_OWORD *)v261 + 2) = v262;
                                                                void *v261 = 0;
                                                                v261[1] = 0;
                                                                v261[2] = v257;
                                                                void *v256 = v261;
                                                                v263 = (void *)**v232;
                                                                if (v263)
                                                                {
                                                                  *v232 = v263;
                                                                  v261 = (void *)*v256;
                                                                }
                                                                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v226[4], v261);
                                                                ++v226[5];
LABEL_465:
                                                                v264 = (void *)v234[1];
                                                                if (v264)
                                                                {
                                                                  do
                                                                  {
                                                                    v265 = v264;
                                                                    v264 = (void *)*v264;
                                                                  }
                                                                  while (v264);
                                                                }
                                                                else
                                                                {
                                                                  do
                                                                  {
                                                                    v265 = (void *)v234[2];
                                                                    BOOL v127 = *v265 == (void)v234;
                                                                    v234 = v265;
                                                                  }
                                                                  while (!v127);
                                                                }
                                                                v234 = v265;
                                                                if (v265 == v235) {
                                                                  goto LABEL_406;
                                                                }
                                                                continue;
                                                              }
LABEL_443:
                                                              if (v249) {
                                                                v257 = v250;
                                                              }
                                                              else {
                                                                v257 = v226 + 4;
                                                              }
                                                              if (v249) {
                                                                v256 = v250 + 1;
                                                              }
                                                              else {
                                                                v256 = v226 + 4;
                                                              }
                                                              if (!*v256) {
                                                                goto LABEL_462;
                                                              }
                                                              goto LABEL_465;
                                                            }
                                                          }
                                                          else if (v254 < v248)
                                                          {
                                                            goto LABEL_443;
                                                          }
                                                          break;
                                                        }
                                                        v256 = v226 + 4;
                                                        v257 = v226 + 4;
                                                        if (!v249) {
                                                          goto LABEL_462;
                                                        }
                                                        v255 = (void *)*v233;
                                                        if (v248 != 1)
                                                        {
                                                          int v258 = *((_DWORD *)v249 + 8);
                                                          v257 = (void *)*v233;
                                                          while (v248 != v258)
                                                          {
                                                            if (v248 < v258)
                                                            {
                                                              uint64_t v266 = *v257;
                                                              v256 = v257;
                                                              if (!*v257) {
                                                                goto LABEL_462;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              if (v258 >= v248) {
                                                                goto LABEL_465;
                                                              }
                                                              uint64_t v266 = v257[1];
                                                              if (!v266) {
                                                                goto LABEL_461;
                                                              }
                                                            }
                                                            int v258 = *(_DWORD *)(v266 + 32);
                                                            v257 = (void *)v266;
                                                          }
                                                          goto LABEL_465;
                                                        }
                                                        while (1)
                                                        {
LABEL_455:
                                                          v257 = v255;
                                                          int v259 = *((_DWORD *)v255 + 8);
                                                          if (v259 == 1)
                                                          {
                                                            int v260 = *((_DWORD *)v255 + 10);
                                                            if (v260 > v253) {
                                                              goto LABEL_454;
                                                            }
                                                            if (v260 >= v253) {
                                                              goto LABEL_465;
                                                            }
                                                          }
                                                          else if (v259 > 1)
                                                          {
LABEL_454:
                                                            v255 = (void *)*v255;
                                                            v256 = v257;
                                                            if (!*v257) {
                                                              goto LABEL_462;
                                                            }
                                                            continue;
                                                          }
                                                          v255 = (void *)v255[1];
                                                          if (!v255)
                                                          {
LABEL_461:
                                                            v256 = v257 + 1;
                                                            goto LABEL_462;
                                                          }
                                                        }
                                                      }
                                                      char v203 = 0;
                                                      char v204 = 0;
                                                      char v205 = 0;
LABEL_368:
                                                      dispatch_retain(v194);
                                                      v200 = 0;
                                                      v201 = 0;
                                                      v202 = 0;
                                                      unint64_t v563 = (unint64_t)v194;
                                                      char v206 = 1;
                                                      goto LABEL_369;
                                                    }
                                                    char v203 = 0;
                                                    char v204 = 0;
LABEL_367:
                                                    dispatch_retain(v194);
                                                    v199 = 0;
                                                    char v205 = 1;
                                                    goto LABEL_368;
                                                  }
                                                  char v203 = 0;
LABEL_366:
                                                  dispatch_retain(v194);
                                                  v514 = 0;
                                                  char v204 = 1;
                                                  goto LABEL_367;
                                                }
LABEL_365:
                                                dispatch_retain(v194);
                                                v510 = 0;
                                                char v203 = 1;
                                                goto LABEL_366;
                                              }
                                            }
                                            else
                                            {
                                              v561 = 0;
                                              dispatch_retain(v194);
                                            }
                                            dispatch_retain(v194);
                                            v562 = 0;
                                            goto LABEL_365;
                                          }
                                        }
                                        else
                                        {
                                          v174 = (uint64_t *)*v166;
                                          v164 = v166;
                                          if (!*v166) {
                                            goto LABEL_311;
                                          }
                                        }
                                        int v173 = *((_DWORD *)v174 + 8);
                                        v166 = v174;
                                      }
                                    }
                                  }
                                }
LABEL_184:
                                std::string::size_type v59 = (uint64_t *)v58[1];
                                if (v58 == v59) {
                                  goto LABEL_284;
                                }
                                goto LABEL_185;
                              }
                              __int16 v61 = (uint64_t **)operator new(0x20uLL);
                              char v62 = *v54;
                              uint64_t v63 = *v62;
                              aBlocka = v61;
                              uint64_t v64 = operator new(0x40uLL);
                              std::string v65 = v64;
                              *uint64_t v64 = v64;
                              v64[1] = v64;
                              void v64[2] = 0;
                              uint64_t v66 = *(void **)(v63 + 8);
                              if (v66 != (void *)v63)
                              {
                                uint64_t v67 = 0;
                                long long v68 = v64;
                                do
                                {
                                  long long v69 = operator new(0x20uLL);
                                  v69[2] = v66[2];
                                  uint64_t v70 = v66[3];
                                  v69[3] = v70;
                                  if (v70)
                                  {
                                    atomic_fetch_add_explicit((atomic_uint *volatile)(v70 + 8), 1u, memory_order_relaxed);
                                    long long v68 = (void *)*v65;
                                    uint64_t v67 = v65[2];
                                  }
                                  *long long v69 = v68;
                                  v69[1] = v65;
                                  v68[1] = v69;
                                  *std::string v65 = v69;
                                  void v65[2] = ++v67;
                                  uint64_t v66 = (void *)v66[1];
                                  long long v68 = v69;
                                }
                                while (v66 != (void *)v63);
                              }
                              v513 = v62;
                              v65[3] = 0;
                              std::string::size_type v71 = (void **)(v65 + 3);
                              v65[4] = 0;
                              uint64_t v72 = v65 + 4;
                              v65[5] = 0;
                              *((unsigned char *)v65 + 48) = *(unsigned char *)(v63 + 48);
                              v65[3] = v65 + 4;
                              uint64_t v73 = *(void **)(v63 + 24);
                              uint64_t v74 = (void *)(v63 + 32);
                              if (v73 == (void *)(v63 + 32))
                              {
LABEL_105:
                                *((unsigned char *)v65 + 56) = *(unsigned char *)(v63 + 56);
                                uint64_t v75 = *(void **)(v63 + 24);
                                if (v75 != v74)
                                {
                                  long long v76 = (void *)v65[3];
                                  uint64_t v77 = v65[1];
                                  do
                                  {
                                    v76[6] = v77;
                                    uint64_t v78 = v63;
                                    if (v75 != v74) {
                                      uint64_t v78 = v75[6];
                                    }
                                    long long v79 = (void *)v75[1];
                                    long long v80 = v79;
                                    uint64_t v81 = v75;
                                    if (v79)
                                    {
                                      do
                                      {
                                        uint64_t v82 = v80;
                                        long long v80 = (void *)*v80;
                                      }
                                      while (v80);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        uint64_t v82 = (void *)v81[2];
                                        BOOL v127 = *v82 == (void)v81;
                                        uint64_t v81 = v82;
                                      }
                                      while (!v127);
                                    }
                                    uint64_t v83 = v63;
                                    if (v82 != v74) {
                                      uint64_t v83 = v82[6];
                                    }
                                    while (v78 != v83)
                                    {
                                      uint64_t v78 = *(void *)(v78 + 8);
                                      uint64_t v77 = *(void *)(v77 + 8);
                                    }
                                    if (v79)
                                    {
                                      do
                                      {
                                        uint64_t v84 = v79;
                                        long long v79 = (void *)*v79;
                                      }
                                      while (v79);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        uint64_t v84 = (void *)v75[2];
                                        BOOL v127 = *v84 == (void)v75;
                                        uint64_t v75 = v84;
                                      }
                                      while (!v127);
                                    }
                                    uint64_t v85 = (void *)v76[1];
                                    if (v85)
                                    {
                                      do
                                      {
                                        uint64_t v86 = v85;
                                        uint64_t v85 = (void *)*v85;
                                      }
                                      while (v85);
                                    }
                                    else
                                    {
                                      do
                                      {
                                        uint64_t v86 = (void *)v76[2];
                                        BOOL v127 = *v86 == (void)v76;
                                        long long v76 = v86;
                                      }
                                      while (!v127);
                                    }
                                    uint64_t v75 = v84;
                                    long long v76 = v86;
                                  }
                                  while (v84 != v74);
                                }
                                *aBlocka = v65;
                                aBlocka[1] = 0;
                                xpc_object_t v106 = (uint64_t *)operator new(0x18uLL);
                                std::string v54 = (uint64_t **)v532;
                                v106[1] = 0x100000001;
                                *xpc_object_t v106 = (uint64_t)&unk_1EFB0DE00;
                                v106[2] = (uint64_t)v65;
                                aBlocka[1] = v106;
                                aBlocka[2] = (uint64_t *)v513[2];
                                uint64_t v107 = v513[3];
                                aBlocka[3] = (uint64_t *)v107;
                                if (v107) {
                                  atomic_fetch_add_explicit((atomic_uint *volatile)(v107 + 8), 1u, memory_order_relaxed);
                                }
                                xpc_object_t v108 = (uint64_t **)operator new(0x18uLL);
                                v108[1] = (uint64_t *)0x100000001;
                                *xpc_object_t v108 = (uint64_t *)&unk_1EFB0DD90;
                                v108[2] = (uint64_t *)aBlocka;
                                size_t v109 = (atomic_uint *)v532[1];
                                *v532 = aBlocka;
                                v532[1] = v108;
                                if (v109)
                                {
                                  if (atomic_fetch_add(v109 + 2, 0xFFFFFFFF) == 1)
                                  {
                                    (*(void (**)(atomic_uint *))(*(void *)v109 + 16))(v109);
                                    if (atomic_fetch_add(v109 + 3, 0xFFFFFFFF) == 1) {
                                      (*(void (**)(atomic_uint *))(*(void *)v109 + 24))(v109);
                                    }
                                  }
                                }
                                int v60 = 0;
                                uint64_t v58 = **v532;
                                goto LABEL_184;
                              }
                              while (1)
                              {
                                int v87 = *((_DWORD *)v73 + 8);
                                uint64_t v88 = (void *)*v72;
                                char v89 = v65 + 4;
                                if (*v71 != v72)
                                {
                                  long long v90 = (void *)*v72;
                                  uint64_t v91 = v65 + 4;
                                  if (v88)
                                  {
                                    do
                                    {
                                      char v89 = v90;
                                      long long v90 = (void *)v90[1];
                                    }
                                    while (v90);
                                  }
                                  else
                                  {
                                    do
                                    {
                                      char v89 = (void *)v91[2];
                                      BOOL v127 = *v89 == (void)v91;
                                      uint64_t v91 = v89;
                                    }
                                    while (v127);
                                  }
                                  int v92 = *((_DWORD *)v73 + 10);
                                  int v93 = *((_DWORD *)v89 + 8);
                                  if (v93 == v87)
                                  {
                                    if (v87 != 1) {
                                      goto LABEL_150;
                                    }
                                    if (*((_DWORD *)v89 + 10) >= v92)
                                    {
                                      long long v94 = (void *)*v72;
                                      uint64_t v95 = v65 + 4;
                                      uint64_t v96 = v65 + 4;
                                      if (v88) {
                                        goto LABEL_154;
                                      }
LABEL_161:
                                      uint64_t v100 = operator new(0x38uLL);
                                      long long v101 = *((_OWORD *)v73 + 2);
                                      v100[6] = v73[6];
                                      *((_OWORD *)v100 + 2) = v101;
                                      *uint64_t v100 = 0;
                                      v100[1] = 0;
                                      v100[2] = v96;
                                      *uint64_t v95 = v100;
                                      std::string v102 = (void *)**v71;
                                      if (v102)
                                      {
                                        void *v71 = v102;
                                        uint64_t v100 = (void *)*v95;
                                      }
                                      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v65[4], v100);
                                      ++v65[5];
                                      goto LABEL_164;
                                    }
                                  }
                                  else if (v93 >= v87)
                                  {
LABEL_150:
                                    uint64_t v95 = v65 + 4;
                                    uint64_t v96 = v65 + 4;
                                    if (!v88) {
                                      goto LABEL_161;
                                    }
                                    long long v94 = (void *)*v72;
                                    if (v87 != 1)
                                    {
                                      int v97 = *((_DWORD *)v88 + 8);
                                      uint64_t v96 = (void *)*v72;
                                      while (v87 != v97)
                                      {
                                        if (v87 < v97)
                                        {
                                          uint64_t v105 = *v96;
                                          uint64_t v95 = v96;
                                          if (!*v96) {
                                            goto LABEL_161;
                                          }
                                        }
                                        else
                                        {
                                          if (v97 >= v87) {
                                            goto LABEL_164;
                                          }
                                          uint64_t v105 = v96[1];
                                          if (!v105) {
                                            goto LABEL_160;
                                          }
                                        }
                                        int v97 = *(_DWORD *)(v105 + 32);
                                        uint64_t v96 = (void *)v105;
                                      }
                                      goto LABEL_164;
                                    }
                                    while (1)
                                    {
LABEL_154:
                                      uint64_t v96 = v94;
                                      int v98 = *((_DWORD *)v94 + 8);
                                      if (v98 == 1)
                                      {
                                        int v99 = *((_DWORD *)v94 + 10);
                                        if (v99 > v92) {
                                          goto LABEL_153;
                                        }
                                        if (v99 >= v92) {
                                          goto LABEL_164;
                                        }
                                      }
                                      else if (v98 > 1)
                                      {
LABEL_153:
                                        long long v94 = (void *)*v94;
                                        uint64_t v95 = v96;
                                        if (!*v96) {
                                          goto LABEL_161;
                                        }
                                        continue;
                                      }
                                      long long v94 = (void *)v94[1];
                                      if (!v94)
                                      {
LABEL_160:
                                        uint64_t v95 = v96 + 1;
                                        goto LABEL_161;
                                      }
                                    }
                                  }
                                }
                                if (v88) {
                                  uint64_t v96 = v89;
                                }
                                else {
                                  uint64_t v96 = v65 + 4;
                                }
                                if (v88) {
                                  uint64_t v95 = v89 + 1;
                                }
                                else {
                                  uint64_t v95 = v65 + 4;
                                }
                                if (!*v95) {
                                  goto LABEL_161;
                                }
LABEL_164:
                                xpc_object_t v103 = (void *)v73[1];
                                if (v103)
                                {
                                  do
                                  {
                                    unint64_t v104 = v103;
                                    xpc_object_t v103 = (void *)*v103;
                                  }
                                  while (v103);
                                }
                                else
                                {
                                  do
                                  {
                                    unint64_t v104 = (void *)v73[2];
                                    BOOL v127 = *v104 == (void)v73;
                                    uint64_t v73 = v104;
                                  }
                                  while (!v127);
                                }
                                uint64_t v73 = v104;
                                if (v104 == v74) {
                                  goto LABEL_105;
                                }
                              }
                            }
                            char v42 = 0;
                            char v43 = 0;
                            char v44 = 0;
                            char v45 = 0;
                            std::string::size_type v41 = 0;
LABEL_68:
                            char v46 = 1;
                            goto LABEL_69;
                          }
                          char v42 = 0;
                          char v43 = 0;
                          char v44 = 0;
LABEL_67:
                          dispatch_retain(v33);
                          long long v39 = 0;
                          std::string v40 = 0;
                          std::string::size_type v41 = 0;
                          unint64_t v563 = (unint64_t)v33;
                          char v45 = 1;
                          goto LABEL_68;
                        }
                        char v42 = 0;
                        char v43 = 0;
LABEL_66:
                        dispatch_retain(v33);
                        uint64_t v38 = 0;
                        char v44 = 1;
                        goto LABEL_67;
                      }
                      char v42 = 0;
LABEL_65:
                      dispatch_retain(v33);
                      aBlocuint64_t k = 0;
                      char v43 = 1;
                      goto LABEL_66;
                    }
LABEL_64:
                    dispatch_retain(v33);
                    v512 = 0;
                    char v42 = 1;
                    goto LABEL_65;
                  }
                }
                else
                {
                  v561 = 0;
                  dispatch_retain(v33);
                }
                dispatch_retain(v33);
                v562 = 0;
                goto LABEL_64;
              }
            }
            else if ((SHIBYTE(v547) & 0x80000000) == 0)
            {
              goto LABEL_40;
            }
            operator delete(__p);
            if ((SBYTE7(v555) & 0x80000000) == 0) {
              goto LABEL_41;
            }
            goto LABEL_45;
          }
        }
        memmove(p_p, v16, v18);
        goto LABEL_32;
      }
    }
    memmove(p_dst, v10, v12);
    goto LABEL_24;
  }
  operator delete(v544.__r_.__value_.__l.__data_);
  if (v9) {
    goto LABEL_16;
  }
  return v9;
}