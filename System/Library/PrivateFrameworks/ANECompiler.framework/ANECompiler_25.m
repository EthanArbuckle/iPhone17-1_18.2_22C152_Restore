uint64_t mlir::eraseUnreachableBlocks(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned int v6;
  uint64_t v7;
  char v8;
  void *v9;
  uint64_t v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *j;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  char *v22;
  llvm::SmallPtrSetImplBase *v23;
  unint64_t v24;
  char *v25;
  size_t v26;
  int64_t v27;
  char *v28;
  size_t v29;
  void *v30;
  void *v31;
  BOOL v32;
  void *v33;
  const void **BucketFor;
  int v35;
  int v36;
  char *v37;
  uint64_t v38;
  ZinIrHalH13g *v39;
  ZinIrHalH13g *i;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  char *v49;
  char *v50;
  uint64_t v51;
  int v52;
  unsigned char v53[128];
  llvm::SmallPtrSetImplBase *v54;
  char *v55;
  char *v56;
  char *v57;
  void *v58;
  uint64_t v59;
  void v60[2];

  v60[1] = *MEMORY[0x263EF8340];
  v49 = v53;
  v50 = v53;
  v51 = 16;
  v52 = 0;
  v58 = v60;
  v59 = 0x100000000;
  if (a3 < 2)
  {
    v6 = 0;
    if (!a3)
    {
      v8 = 0;
      goto LABEL_79;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, a3, 8);
    v6 = v59;
  }
  v7 = 24 * a3;
  do
  {
    if (v6 >= HIDWORD(v59))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v6 + 1, 8);
      v6 = v59;
    }
    v58[v6] = a2;
    v6 = v59 + 1;
    LODWORD(v59) = v59 + 1;
    a2 += 24;
    v7 -= 24;
  }
  while (v7);
  v8 = 0;
  while (v6)
  {
    v9 = (void *)v58[--v6];
    LODWORD(v59) = v6;
    if ((void *)*v9 != v9)
    {
      v10 = v9[1];
      if (*(void **)(v10 + 8) != v9)
      {
        if (v50 != v49)
        {
          if (v51 >= 0x21 && 4 * (HIDWORD(v51) - v52) < v51)
          {
            llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v49);
            goto LABEL_29;
          }
          memset(v50, 255, 8 * v51);
        }
        HIDWORD(v51) = 0;
        v52 = 0;
LABEL_29:
        v20 = v9[1];
        if (v20) {
          v21 = (void *)(v20 - 8);
        }
        else {
          v21 = 0;
        }
        llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::df_iterator(&v54, v21, (llvm::SmallPtrSetImplBase *)&v49);
        v23 = v54;
        v22 = v55;
        v24 = v56 - v55;
        if (v56 != v55)
        {
          if ((v24 & 0x8000000000000000) == 0)
          {
            v25 = (char *)operator new(v56 - v55);
            v26 = v24 & 0xFFFFFFFFFFFFFFE0;
            memcpy(v25, v22, v26);
            v24 = (unint64_t)&v25[v26];
            if (v22) {
              goto LABEL_35;
            }
            goto LABEL_36;
          }
LABEL_84:
          abort();
        }
        v25 = 0;
        if (v55)
        {
LABEL_35:
          v56 = v22;
          operator delete(v22);
        }
LABEL_36:
        v54 = v23;
        v27 = v24 - (void)v25;
        if (v27)
        {
          if (v27 < 0) {
            goto LABEL_84;
          }
          v28 = (char *)operator new(v27);
          v55 = v28;
          v57 = &v28[32 * (v27 >> 5)];
          v29 = v27 & 0xFFFFFFFFFFFFFFE0;
          memcpy(v28, v25, v29);
          v56 = &v28[v29];
          if (!v29) {
            goto LABEL_41;
          }
          do
          {
            llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::toNext(&v54);
            v28 = v56;
          }
          while (v56 != v55);
          if (v56)
          {
LABEL_41:
            v56 = v28;
            operator delete(v28);
          }
        }
        if (v25) {
          operator delete(v25);
        }
        v30 = (void *)v9[1];
        while (1)
        {
          if (v30 == v9) {
            goto LABEL_10;
          }
          v31 = v30 - 1;
          v32 = v30 == 0;
          v30 = (void *)v30[1];
          if (v32) {
            v33 = 0;
          }
          else {
            v33 = v31;
          }
          if (v50 == v49)
          {
            v37 = &v50[8 * HIDWORD(v51)];
            if (HIDWORD(v51))
            {
              v38 = 0;
              while (*(void **)&v50[v38] != v33)
              {
                v38 += 8;
                if (8 * HIDWORD(v51) == v38) {
                  goto LABEL_66;
                }
              }
              v37 = &v50[v38];
            }
LABEL_66:
            if (v37 == &v50[8 * HIDWORD(v51)])
            {
LABEL_45:
              mlir::Block::dropAllDefinedValueUses(v33);
              (*(void (**)(uint64_t, void *))(*(void *)a1 + 48))(a1, v33);
              v8 = 1;
              continue;
            }
          }
          else
          {
            BucketFor = llvm::SmallPtrSetImplBase::FindBucketFor((llvm::SmallPtrSetImplBase *)&v49, v33);
            if (*BucketFor != v33)
            {
              v35 = v51;
              if (v50 == v49) {
                v35 = HIDWORD(v51);
              }
              BucketFor = (const void **)&v50[8 * v35];
            }
            if (v50 == v49) {
              v36 = HIDWORD(v51);
            }
            else {
              v36 = v51;
            }
            if (BucketFor == (const void **)&v50[8 * v36]) {
              goto LABEL_45;
            }
          }
          v39 = (ZinIrHalH13g *)(v33 + 4);
          for (i = (ZinIrHalH13g *)v33[5]; i != v39; i = (ZinIrHalH13g *)*((void *)i + 1))
          {
            ZinIrHalH13g::~ZinIrHalH13g(i);
            v42 = *(unsigned int *)(v41 + 44);
            v43 = v42 & 0x7FFFFF;
            if ((v42 & 0x7FFFFF) != 0)
            {
              v44 = (v41 + 16 * ((v42 >> 23) & 1) + ((v42 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8;
              v45 = v59;
              v46 = 24 * v43;
              v47 = v44 + 32 * *(unsigned int *)(v41 + 40);
              do
              {
                if (v45 >= HIDWORD(v59))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v45 + 1, 8);
                  v45 = v59;
                }
                v58[v45] = v47;
                v45 = v59 + 1;
                LODWORD(v59) = v59 + 1;
                v47 += 24;
                v46 -= 24;
              }
              while (v46);
            }
          }
        }
      }
      v11 = (ZinIrHalH13g *)(v10 + 24);
      for (j = *(ZinIrHalH13g **)(v10 + 32); j != v11; j = (ZinIrHalH13g *)*((void *)j + 1))
      {
        ZinIrHalH13g::~ZinIrHalH13g(j);
        v14 = *(unsigned int *)(v13 + 44);
        v15 = v14 & 0x7FFFFF;
        if ((v14 & 0x7FFFFF) != 0)
        {
          v16 = (v13 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8;
          v17 = v59;
          v18 = 24 * v15;
          v19 = v16 + 32 * *(unsigned int *)(v13 + 40);
          do
          {
            if (v17 >= HIDWORD(v59))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, v17 + 1, 8);
              v17 = v59;
            }
            v58[v17] = v19;
            v17 = v59 + 1;
            LODWORD(v59) = v59 + 1;
            v19 += 24;
            v18 -= 24;
          }
          while (v18);
        }
      }
LABEL_10:
      v6 = v59;
    }
  }
LABEL_79:
  if (v58 != v60) {
    free(v58);
  }
  if (v50 != v49) {
    free(v50);
  }
  return v8 & 1;
}

void propagateLiveness(void *a1, int64x2_t *a2)
{
  v220[3] = *MEMORY[0x263EF8340];
  if ((void *)*a1 == a1) {
    return;
  }
  uint64_t v3 = a1[1];
  if (v3) {
    v4 = (mlir::Block *)(v3 - 8);
  }
  else {
    v4 = 0;
  }
  v201 = v4;
  llvm::post_order<mlir::Block *>(&v201, &v207);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v201, &v203, (const llvm::SmallPtrSetImplBase *)&v207);
  v204 = v206;
  uint64_t v205 = 0x800000000;
  unsigned int v5 = v210;
  if (v210)
  {
    if (v210 < 9)
    {
      v7 = v206;
      unsigned int v6 = v210;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v204, v206, v210, 40);
      unsigned int v6 = v210;
      if (!v210)
      {
LABEL_11:
        LODWORD(v205) = v5;
        goto LABEL_12;
      }
      v7 = v204;
    }
    memcpy(v7, __src, 40 * v6);
    goto LABEL_11;
  }
LABEL_12:
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v195, &v197, (const llvm::SmallPtrSetImplBase *)&v212);
  v198 = v200;
  uint64_t v199 = 0x800000000;
  uint64_t v8 = v215;
  if (v215)
  {
    if (v215 < 9uLL)
    {
      v10 = v200;
      uint64_t v9 = v215;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v198, v200, v215, 40);
      uint64_t v9 = v215;
      if (!v215)
      {
LABEL_18:
        LODWORD(v199) = v8;
        goto LABEL_19;
      }
      v10 = v198;
    }
    memcpy(v10, v214, 40 * v9);
    goto LABEL_18;
  }
LABEL_19:
  uint64_t i64 = (uint64_t)a2[2].i64;
  v186 = &a2->i64[1];
  v11 = (void *)&unk_267771000;
  while (1)
  {
    if (v205 != v8) {
      goto LABEL_31;
    }
    if (!v8) {
      break;
    }
    v12 = v198;
    v13 = v204;
    while (*v13 == *v12 && v13[1] == v12[1] && v13[2] == v12[2] && v13[3] == v12[3] && v13[4] == v12[4])
    {
      v13 += 5;
      v12 += 5;
      if (v13 == (void *)((char *)v204 + 40 * v8)) {
        goto LABEL_299;
      }
    }
LABEL_31:
    v14 = (ZinIrHalH13g **)(*((void *)v204 + 5 * v205 - 5) + 32);
    v15 = *v14;
    v187 = (mlir::Block *)*((void *)v204 + 5 * v205 - 5);
    v188 = v14;
    if (*v14 != (ZinIrHalH13g *)v14)
    {
      while (1)
      {
        ZinIrHalH13g::~ZinIrHalH13g(v15);
        uint64_t v19 = v18;
        unint64_t v20 = *(unsigned int *)(v18 + 44);
        if ((v20 & 0x7FFFFF) != 0)
        {
          unint64_t v21 = ((v18 + 16 * ((v20 >> 23) & 1) + ((v20 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
              + 32 * *(unsigned int *)(v18 + 40);
          uint64_t v22 = 24 * (v20 & 0x7FFFFF);
          do
          {
            propagateLiveness(v21, a2);
            v21 += 24;
            v22 -= 24;
          }
          while (v22);
        }
        {
          v217 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
          unint64_t v218 = 84;
          unint64_t v136 = llvm::StringRef::find((uint64_t *)&v217, "DesiredTypeName = ", 0x12uLL, 0);
          if (v218 >= v136) {
            unint64_t v137 = v136;
          }
          else {
            unint64_t v137 = v218;
          }
          v138 = &v217[v137];
          unint64_t v139 = v218 - v137;
          uint64_t v140 = 18;
          if (v139 < 0x12) {
            uint64_t v140 = v139;
          }
          unint64_t v141 = v139 - v140;
          if (v141 >= v141 - 1) {
            uint64_t v142 = v141 - 1;
          }
          else {
            uint64_t v142 = v141;
          }
          v11[233] = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
        }
        char v23 = (*(uint64_t (**)(void, void))(**(void **)(v19 + 48) + 32))(*(void *)(v19 + 48), v11[233]);
        uint64_t v24 = a2[2].i64[0];
        v25 = (mlir::Operation *)a2[3].u32[0];
        if (v23) {
          break;
        }
        if (!v25) {
          goto LABEL_52;
        }
        unsigned int v30 = (v25 - 1) & ((v19 >> 4) ^ (v19 >> 9));
        uint64_t v31 = *(void *)(v24 + 8 * v30);
        if (v31 != v19)
        {
          int v32 = 1;
          while (v31 != -4096)
          {
            unsigned int v33 = v30 + v32++;
            unsigned int v30 = v33 & (v25 - 1);
            uint64_t v31 = *(void *)(v24 + 8 * v30);
            if (v31 == v19) {
              goto LABEL_37;
            }
          }
LABEL_52:
          if (mlir::wouldOpBeTriviallyDead((void ***)v19, v25))
          {
            uint64_t v34 = *(unsigned int *)(v19 + 36);
            if (v34) {
              uint64_t v35 = v19 - 16;
            }
            else {
              uint64_t v35 = 0;
            }
            if (v34)
            {
              for (uint64_t i = 0; i != v34; ++i)
              {
                unint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v35, i);
                processValue(NextResultAtOffset, a2);
              }
            }
            goto LABEL_37;
          }
          unsigned int v75 = a2[3].u32[0];
          if (!v75) {
            goto LABEL_217;
          }
          uint64_t v76 = a2[2].i64[0];
          unsigned int v77 = (v75 - 1) & ((v19 >> 4) ^ (v19 >> 9));
          v78 = (void *)(v76 + 8 * v77);
          uint64_t v79 = *v78;
          if (v19 == *v78)
          {
            char v80 = 0;
LABEL_184:
            a2->i8[0] |= v80;
            goto LABEL_37;
          }
          v126 = 0;
          int v127 = 1;
          while (v79 != -4096)
          {
            char v80 = 0;
            if (v126) {
              BOOL v128 = 0;
            }
            else {
              BOOL v128 = v79 == -8192;
            }
            if (v128) {
              v126 = v78;
            }
            unsigned int v129 = v77 + v127++;
            unsigned int v77 = v129 & (v75 - 1);
            v78 = (void *)(v76 + 8 * v77);
            uint64_t v79 = *v78;
            if (v19 == *v78) {
              goto LABEL_184;
            }
          }
          v130 = v126 ? v126 : v78;
          __int32 v131 = a2[2].i32[2];
          if (4 * v131 + 4 < 3 * v75)
          {
            if (v75 + ~v131 - a2[2].i32[3] <= v75 >> 3) {
              goto LABEL_218;
            }
          }
          else
          {
LABEL_217:
            v75 *= 2;
LABEL_218:
            llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::grow(i64, v75);
            uint64_t v132 = a2[2].i64[0];
            int v133 = a2[3].i32[0] - 1;
            unsigned int v134 = v133 & ((v19 >> 4) ^ (v19 >> 9));
            v130 = (void *)(v132 + 8 * v134);
            uint64_t v135 = *v130;
            if (v19 == *v130)
            {
              uint64_t v115 = v19;
              goto LABEL_181;
            }
            v162 = 0;
            int v163 = 1;
            while (v135 != -4096)
            {
              if (v162) {
                BOOL v164 = 0;
              }
              else {
                BOOL v164 = v135 == -8192;
              }
              if (v164) {
                v162 = v130;
              }
              unsigned int v165 = v134 + v163++;
              unsigned int v134 = v165 & v133;
              v130 = (void *)(v132 + 8 * (v165 & v133));
              uint64_t v135 = *v130;
              if (v19 == *v130)
              {
                uint64_t v115 = v19;
                v11 = (void *)&unk_267771000;
                v14 = v188;
                goto LABEL_181;
              }
            }
            if (v162) {
              v130 = v162;
            }
            v11 = (void *)&unk_267771000;
            v14 = v188;
          }
          uint64_t v115 = *v130;
LABEL_181:
          ++a2[2].i32[2];
          if (v115 != -4096) {
            --a2[2].i32[3];
          }
          void *v130 = v19;
          char v80 = 1;
          goto LABEL_184;
        }
LABEL_37:
        v15 = *(ZinIrHalH13g **)v15;
        if (v15 == (ZinIrHalH13g *)v14) {
          goto LABEL_32;
        }
      }
      if (!v25) {
        goto LABEL_200;
      }
      unsigned int v26 = (v25 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      v27 = (void *)(v24 + 8 * v26);
      uint64_t v28 = *v27;
      if (v19 == *v27)
      {
        char v29 = 0;
        goto LABEL_65;
      }
      v116 = 0;
      int v117 = 1;
      while (v28 != -4096)
      {
        char v29 = 0;
        if (v116) {
          BOOL v118 = 0;
        }
        else {
          BOOL v118 = v28 == -8192;
        }
        if (v118) {
          v116 = v27;
        }
        unsigned int v119 = v26 + v117++;
        unsigned int v26 = v119 & (v25 - 1);
        v27 = (void *)(v24 + 8 * v26);
        uint64_t v28 = *v27;
        if (v19 == *v27) {
          goto LABEL_65;
        }
      }
      v120 = v116 ? v116 : v27;
      __int32 v121 = a2[2].i32[2];
      if (4 * v121 + 4 < (3 * v25))
      {
        if ((int)v25 + ~v121 - a2[2].i32[3] <= v25 >> 3) {
          goto LABEL_201;
        }
        uint64_t v38 = *v120;
        ++a2[2].i32[2];
        if (v38 != -4096) {
          goto LABEL_63;
        }
      }
      else
      {
LABEL_200:
        LODWORD(v25) = 2 * v25;
LABEL_201:
        llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::grow(i64, (int)v25);
        uint64_t v122 = a2[2].i64[0];
        int v123 = a2[3].i32[0] - 1;
        unsigned int v124 = v123 & ((v19 >> 4) ^ (v19 >> 9));
        v120 = (void *)(v122 + 8 * v124);
        uint64_t v125 = *v120;
        if (v19 == *v120)
        {
LABEL_202:
          ++a2[2].i32[2];
          if (v19 == -4096) {
            goto LABEL_64;
          }
        }
        else
        {
          v157 = 0;
          int v158 = 1;
          while (v125 != -4096)
          {
            if (v157) {
              BOOL v159 = 0;
            }
            else {
              BOOL v159 = v125 == -8192;
            }
            if (v159) {
              v157 = v120;
            }
            unsigned int v160 = v124 + v158++;
            unsigned int v124 = v160 & v123;
            v120 = (void *)(v122 + 8 * (v160 & v123));
            uint64_t v125 = *v120;
            if (v19 == *v120) {
              goto LABEL_202;
            }
          }
          if (v157) {
            v120 = v157;
          }
          uint64_t v161 = *v120;
          ++a2[2].i32[2];
          if (v161 == -4096) {
            goto LABEL_64;
          }
        }
LABEL_63:
        --a2[2].i32[3];
      }
LABEL_64:
      void *v120 = v19;
      char v29 = 1;
LABEL_65:
      a2->i8[0] |= v29;
      uint64_t v39 = *(void *)(v19 + 48);
      v40 = *(void **)(v39 + 16);
      if (v40 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v41 = 0;
      }
      else {
        uint64_t v41 = *(void *)(v19 + 48);
      }
      v189 = v15;
      if (v40 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v217 = *(const char **)(v39 + 8);
        uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v217);
        if (!Values) {
          goto LABEL_82;
        }
        uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v39);
        if (!Values) {
          goto LABEL_82;
        }
      }
      else
      {
        {
          v217 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
          unint64_t v218 = 73;
          unint64_t v143 = llvm::StringRef::find((uint64_t *)&v217, "DesiredTypeName = ", 0x12uLL, 0);
          if (v218 >= v143) {
            unint64_t v144 = v143;
          }
          else {
            unint64_t v144 = v218;
          }
          v145 = &v217[v144];
          unint64_t v146 = v218 - v144;
          uint64_t v147 = 18;
          if (v146 < 0x12) {
            uint64_t v147 = v146;
          }
          unint64_t v148 = v146 - v147;
          if (v148 >= v148 - 1) {
            uint64_t v149 = v148 - 1;
          }
          else {
            uint64_t v149 = v148;
          }
          mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v145[v147], v149);
        }
        unint64_t v42 = *(unsigned int *)((v41 | v39 & 0xFFFFFFFFFFFFFF00) + 0x28);
        if (!v42) {
          goto LABEL_317;
        }
        v43 = *(void **)((v41 | v39 & 0xFFFFFFFFFFFFFF00) + 0x20);
        v44 = &v43[2 * v42];
        do
        {
          unint64_t v45 = v42 >> 1;
          v46 = &v43[2 * (v42 >> 1)];
          unint64_t v48 = *v46;
          v47 = v46 + 2;
          v42 += ~(v42 >> 1);
          if (v48 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
            v43 = v47;
          }
          else {
            unint64_t v42 = v45;
          }
        }
        while (v42);
        if (v43 == v44
          || *v43 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
          || !v43[1])
        {
LABEL_317:
          uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(*(void *)((v41 | v39 & 0xFFFFFFFFFFFFFF00) + 0x18), *(void *)(v19 + 48));
          if (!Values)
          {
LABEL_82:
            uint64_t v191 = 0;
            uint64_t v192 = Values;
LABEL_83:
            mlir::SuccessorRange::SuccessorRange((unint64_t *)&v217, (Operation *)v19);
            v50 = &unk_267770000;
            unint64_t v51 = v218;
            if (v218)
            {
              uint64_t v52 = 0;
              v53 = v217;
              while (1)
              {
                uint64_t v54 = *(void *)&v53[32 * v52 + 24];
                v55 = *(unint64_t **)(v54 + 48);
                v56 = *(unint64_t **)(v54 + 56);
                if (v56 != v55) {
                  break;
                }
LABEL_85:
                if (++v52 == v51) {
                  goto LABEL_36;
                }
              }
              while (2)
              {
                unint64_t v58 = *v55;
                v194 = (void *)*v55;
                __int32 v59 = a2[1].i32[2];
                if (!v59)
                {
                  unsigned int v66 = 0;
                  goto LABEL_112;
                }
                uint64_t v60 = a2->i64[1];
                {
                  v50 = &unk_267770000;
                  if (v73)
                  {
                    unint64_t v74 = llvm::hashing::detail::fixed_seed_override;
                    if (!llvm::hashing::detail::fixed_seed_override) {
                      unint64_t v74 = 0xFF51AFD7ED558CCDLL;
                    }
                    llvm::hashing::detail::get_execution_seed(void)::seed = v74;
                    v50 = (void *)&unk_267770000;
                  }
                }
                unint64_t v61 = 0x9DDFEA08EB382D69 * ((v50[385] + 8 * v58) ^ HIDWORD(v58));
                unint64_t v62 = 0x9DDFEA08EB382D69 * (HIDWORD(v58) ^ (v61 >> 47) ^ v61);
                unsigned int v63 = (-348639895 * ((v62 >> 47) ^ v62)) & (v59 - 1);
                v64 = (char *)(v60 + 8 * v63);
                uint64_t v65 = *(void *)v64;
                if (v194 == *(void **)v64)
                {
                  char v57 = 0;
LABEL_90:
                  a2->i8[0] |= v57;
                  if (++v55 == v56) {
                    goto LABEL_85;
                  }
                  continue;
                }
                break;
              }
              v67 = 0;
              int v68 = 1;
              while (v65 != -4096)
              {
                char v57 = 0;
                if (v67) {
                  BOOL v69 = 0;
                }
                else {
                  BOOL v69 = v65 == -8192;
                }
                if (v69) {
                  v67 = v64;
                }
                unsigned int v70 = v63 + v68++;
                unsigned int v63 = v70 & (v59 - 1);
                v64 = (char *)(v60 + 8 * v63);
                uint64_t v65 = *(void *)v64;
                if (v194 == *(void **)v64) {
                  goto LABEL_90;
                }
              }
              if (v67) {
                v71 = v67;
              }
              else {
                v71 = v64;
              }
              unsigned int v66 = a2[1].u32[2];
              __int32 v72 = a2[1].i32[0];
              if (4 * v72 + 4 < 3 * v66)
              {
                if (v66 + ~v72 - a2[1].i32[1] <= v66 >> 3) {
                  goto LABEL_113;
                }
                ++a2[1].i32[0];
                if (*(void *)v71 == -4096)
                {
LABEL_89:
                  *(void *)v71 = v194;
                  char v57 = 1;
                  goto LABEL_90;
                }
              }
              else
              {
LABEL_112:
                v66 *= 2;
LABEL_113:
                llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow((uint64_t)v186, v66);
                v217 = 0;
                llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v186, (unint64_t *)&v194, &v217);
                v50 = (void *)&unk_267770000;
                v71 = (char *)v217;
                ++a2[1].i32[0];
                if (*(void *)v71 == -4096) {
                  goto LABEL_89;
                }
              }
              --a2[1].i32[1];
              goto LABEL_89;
            }
            goto LABEL_36;
          }
        }
      }
      uint64_t v81 = *(void *)(v19 + 48);
      v82 = *(void **)(v81 + 16);
      if (v82 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = *(void *)(v19 + 48);
      }
      if (v82 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v217 = *(const char **)(v81 + 8);
        uint64_t v91 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v217);
        if (v91)
        {
          uint64_t v92 = v81;
LABEL_139:
          uint64_t v91 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(v91, v92);
        }
      }
      else
      {
        {
          v217 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
          unint64_t v218 = 73;
          unint64_t v150 = llvm::StringRef::find((uint64_t *)&v217, "DesiredTypeName = ", 0x12uLL, 0);
          if (v218 >= v150) {
            unint64_t v151 = v150;
          }
          else {
            unint64_t v151 = v218;
          }
          v152 = &v217[v151];
          unint64_t v153 = v218 - v151;
          uint64_t v154 = 18;
          if (v153 < 0x12) {
            uint64_t v154 = v153;
          }
          unint64_t v155 = v153 - v154;
          if (v155 >= v155 - 1) {
            uint64_t v156 = v155 - 1;
          }
          else {
            uint64_t v156 = v155;
          }
          mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v152[v154], v156);
        }
        unint64_t v84 = *(unsigned int *)((v83 | v81 & 0xFFFFFFFFFFFFFF00) + 0x28);
        if (!v84) {
          goto LABEL_136;
        }
        v85 = *(void **)((v83 | v81 & 0xFFFFFFFFFFFFFF00) + 0x20);
        v86 = &v85[2 * v84];
        do
        {
          unint64_t v87 = v84 >> 1;
          v88 = &v85[2 * (v84 >> 1)];
          unint64_t v90 = *v88;
          v89 = v88 + 2;
          v84 += ~(v84 >> 1);
          if (v90 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
            v85 = v89;
          }
          else {
            unint64_t v84 = v87;
          }
        }
        while (v84);
        if (v85 == v86
          || *v85 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
          || (uint64_t v91 = v85[1]) == 0)
        {
LABEL_136:
          uint64_t v91 = *(void *)((v83 | v81 & 0xFFFFFFFFFFFFFF00) + 0x18);
          uint64_t v92 = *(void *)(v19 + 48);
          goto LABEL_139;
        }
      }
      uint64_t v191 = v19;
      uint64_t v192 = v91;
      if (!v19) {
        goto LABEL_83;
      }
      uint64_t v190 = *(unsigned int *)(v19 + 40);
      if (v190)
      {
        uint64_t v93 = 0;
        while (1)
        {
          mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)&v191, v93);
          v94 = &unk_267770000;
          uint64_t v95 = v217;
          if (v217) {
            break;
          }
LABEL_176:
          if (v219 != v220) {
            free(v219);
          }
          if (++v93 == v190) {
            goto LABEL_36;
          }
        }
        uint64_t v96 = 0;
        while (2)
        {
          unint64_t v98 = *(void *)(*(void *)(*(void *)(((v19
                                                    + 64
                                                    + 16 * (((unint64_t)*(unsigned int *)(v19 + 44) >> 23) & 1)
                                                    + (((unint64_t)*(unsigned int *)(v19 + 44) >> 21) & 0x7F8)
                                                    + 7) & 0xFFFFFFFFFFFFFFF8)
                                                  + 32 * v93
                                                  + 24)
                                      + 48)
                          + 8 * v96);
          unint64_t v193 = v98;
          __int32 v99 = a2[1].i32[2];
          if (!v99)
          {
            unsigned int v106 = 0;
            goto LABEL_169;
          }
          uint64_t v100 = a2->i64[1];
          {
            v94 = &unk_267770000;
            if (v113)
            {
              unint64_t v114 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v114 = 0xFF51AFD7ED558CCDLL;
              }
              llvm::hashing::detail::get_execution_seed(void)::seed = v114;
              v94 = (void *)&unk_267770000;
            }
          }
          unint64_t v101 = 0x9DDFEA08EB382D69 * ((v94[385] + 8 * v98) ^ HIDWORD(v98));
          unint64_t v102 = 0x9DDFEA08EB382D69 * (HIDWORD(v98) ^ (v101 >> 47) ^ v101);
          unsigned int v103 = (-348639895 * ((v102 >> 47) ^ v102)) & (v99 - 1);
          v104 = (void *)(v100 + 8 * v103);
          uint64_t v105 = *v104;
          if (v193 == *v104)
          {
            char v97 = 0;
LABEL_147:
            a2->i8[0] |= v97;
            if (++v96 == v95) {
              goto LABEL_176;
            }
            continue;
          }
          break;
        }
        v107 = 0;
        int v108 = 1;
        while (v105 != -4096)
        {
          char v97 = 0;
          if (v107) {
            BOOL v109 = 0;
          }
          else {
            BOOL v109 = v105 == -8192;
          }
          if (v109) {
            v107 = v104;
          }
          unsigned int v110 = v103 + v108++;
          unsigned int v103 = v110 & (v99 - 1);
          v104 = (void *)(v100 + 8 * v103);
          uint64_t v105 = *v104;
          if (v193 == *v104) {
            goto LABEL_147;
          }
        }
        if (v107) {
          v111 = v107;
        }
        else {
          v111 = v104;
        }
        unsigned int v106 = a2[1].u32[2];
        __int32 v112 = a2[1].i32[0];
        if (4 * v112 + 4 < 3 * v106)
        {
          if (v106 + ~v112 - a2[1].i32[1] <= v106 >> 3) {
            goto LABEL_170;
          }
          ++a2[1].i32[0];
          if (*v111 == -4096)
          {
LABEL_146:
            void *v111 = v193;
            char v97 = 1;
            goto LABEL_147;
          }
        }
        else
        {
LABEL_169:
          v106 *= 2;
LABEL_170:
          llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow((uint64_t)v186, v106);
          v194 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v186, &v193, &v194);
          v94 = (void *)&unk_267770000;
          v111 = v194;
          ++a2[1].i32[0];
          if (*v111 == -4096) {
            goto LABEL_146;
          }
        }
        --a2[1].i32[1];
        goto LABEL_146;
      }
LABEL_36:
      v11 = &unk_267771000;
      v14 = v188;
      v15 = v189;
      goto LABEL_37;
    }
LABEL_32:
    if (!mlir::Block::isEntryBlock(v187))
    {
      v16 = (mlir::detail::OpResultImpl **)*((void *)v187 + 6);
      for (j = (mlir::detail::OpResultImpl **)*((void *)v187 + 7); v16 != j; ++v16)
      {
        unint64_t v166 = (unint64_t)*v16;
        if (*v16) {
          BOOL v167 = (*((void *)*v16 + 1) & 7) == 7;
        }
        else {
          BOOL v167 = 1;
        }
        if (v167)
        {
          __int32 v168 = a2[1].i32[2];
          if (v168)
          {
            uint64_t v169 = a2->i64[1];
            {
              unint64_t v184 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v184 = 0xFF51AFD7ED558CCDLL;
              }
              llvm::hashing::detail::get_execution_seed(void)::seed = v184;
            }
            unint64_t v170 = 0x9DDFEA08EB382D69
                 * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v166) ^ HIDWORD(v166));
            unint64_t v171 = 0x9DDFEA08EB382D69 * (HIDWORD(v166) ^ (v170 >> 47) ^ v170);
            unsigned int v172 = (-348639895 * ((v171 >> 47) ^ v171)) & (v168 - 1);
            uint64_t v173 = *(void *)(v169 + 8 * v172);
            if (v166 == v173) {
              continue;
            }
            int v174 = 1;
            while (v173 != -4096)
            {
              unsigned int v175 = v172 + v174++;
              unsigned int v172 = v175 & (v168 - 1);
              uint64_t v173 = *(void *)(v169 + 8 * v172);
              if (v166 == v173) {
                goto LABEL_276;
              }
            }
          }
        }
        else
        {
          uint64_t Owner = mlir::detail::OpResultImpl::getOwner(*v16);
          __int32 v177 = a2[3].i32[0];
          if (v177)
          {
            uint64_t v178 = a2[2].i64[0];
            __int32 v179 = v177 - 1;
            unsigned int v180 = ((Owner >> 4) ^ (Owner >> 9)) & v179;
            uint64_t v181 = *(void *)(v178 + 8 * v180);
            if (v181 == Owner) {
              continue;
            }
            int v182 = 1;
            while (v181 != -4096)
            {
              unsigned int v183 = v180 + v182++;
              unsigned int v180 = v183 & v179;
              uint64_t v181 = *(void *)(v178 + 8 * v180);
              if (v181 == Owner) {
                goto LABEL_276;
              }
            }
          }
        }
        processValue(v166, a2);
LABEL_276:
        ;
      }
    }
    LODWORD(v205) = v205 - 1;
    if (v205) {
      llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>::traverseChild((llvm::SmallPtrSetImplBase *)&v201);
    }
    uint64_t v8 = v199;
  }
LABEL_299:
  if (v198 != v200) {
    free(v198);
  }
  if (v196 != v195) {
    free(v196);
  }
  if (v204 != v206) {
    free(v204);
  }
  if (v202 != v201) {
    free(v202);
  }
  if (v214 != &v216) {
    free(v214);
  }
  if (v213 != v212) {
    free(v213);
  }
  if (__src != &v211) {
    free(__src);
  }
  if (v208 != v207) {
    free(v208);
  }
}

uint64_t deleteDeadness(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v134[3] = *MEMORY[0x263EF8340];
  if (a3)
  {
    unsigned int v5 = a2;
    uint64_t v6 = a1;
    int v7 = 0;
    __int32 v99 = &a2[3 * a3];
    while ((void *)*v5 == v5)
    {
LABEL_3:
      v5 += 3;
      if (v5 == v99) {
        return v7 & 1;
      }
    }
    uint64_t v8 = (void *)v5[1];
    uint64_t v100 = v5;
    BOOL v104 = v8 != v5 && v8[1] == (void)v5;
    if (v8) {
      uint64_t v9 = (mlir::Block *)(v8 - 1);
    }
    else {
      uint64_t v9 = 0;
    }
    unint64_t v114 = v9;
    llvm::post_order<mlir::Block *>(&v114, &v120);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v114, &v116, (const llvm::SmallPtrSetImplBase *)&v120);
    __dst = v119;
    uint64_t v118 = 0x800000000;
    unsigned int v10 = v123;
    if (!v123)
    {
LABEL_17:
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v108, &v110, (const llvm::SmallPtrSetImplBase *)&v125);
      v111 = v113;
      uint64_t v112 = 0x800000000;
      uint64_t v13 = v128;
      if (!v128) {
        goto LABEL_24;
      }
      v14 = v113;
      uint64_t v15 = v128;
      if (v128 >= 9uLL)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v111, v113, v128, 40);
        uint64_t v15 = v128;
        if (!v128)
        {
LABEL_22:
          LODWORD(v112) = v13;
          while (1)
          {
LABEL_24:
            if (v118 == v13)
            {
              if (!v13)
              {
LABEL_142:
                if (v111 != v113) {
                  free(v111);
                }
                unsigned int v5 = v100;
                if (v109 != v108) {
                  free(v109);
                }
                if (__dst != v119) {
                  free(__dst);
                }
                if (v115 != v114) {
                  free(v115);
                }
                if (v127 != &v129) {
                  free(v127);
                }
                if (v126 != v125) {
                  free(v126);
                }
                if (__src != &v124) {
                  free(__src);
                }
                if (v121 != v120) {
                  free(v121);
                }
                for (uint64_t i = *(void **)(v100[1] + 8); i != v100; uint64_t i = (void *)i[1])
                {
                  if (i) {
                    uint64_t v97 = (uint64_t)(i - 1);
                  }
                  else {
                    uint64_t v97 = 0;
                  }
                  v120 = (void *)a4;
                }
                goto LABEL_3;
              }
              v16 = v111;
              v17 = __dst;
              while (*v17 == *v16 && v17[1] == v16[1] && v17[2] == v16[2] && v17[3] == v16[3] && v17[4] == v16[4])
              {
                v17 += 5;
                v16 += 5;
                if (v17 == (void *)((char *)__dst + 40 * v13)) {
                  goto LABEL_142;
                }
              }
            }
            uint64_t v18 = (ZinIrHalH13g **)*((void *)__dst + 5 * v118 - 5);
            if (!v104) {
              break;
            }
LABEL_93:
            unsigned int v63 = v18[4];
            unint64_t v62 = (ZinIrHalH13g *)(v18 + 4);
            unint64_t v61 = v63;
            if (v63 != v62)
            {
              do
              {
                while (1)
                {
                  v64 = *(ZinIrHalH13g **)v61;
                  ZinIrHalH13g::~ZinIrHalH13g(v61);
                  unsigned int v66 = v65;
                  int v67 = *(_DWORD *)(a4 + 48);
                  if (v67) {
                    break;
                  }
LABEL_108:
                  uint64_t v76 = v65[9];
                  if (v76) {
                    uint64_t v77 = (uint64_t)(v65 - 4);
                  }
                  else {
                    uint64_t v77 = 0;
                  }
                  if (v76)
                  {
                    for (uint64_t j = 0; j != v76; ++j)
                    {
                      unint64_t NextResultAtOffset = (void **)mlir::detail::OpResultImpl::getNextResultAtOffset(v77, j);
                      while (1)
                      {
                        char v80 = *NextResultAtOffset;
                        if (!*NextResultAtOffset) {
                          break;
                        }
                        uint64_t v81 = (void *)v80[1];
                        if (v81)
                        {
                          *uint64_t v81 = *v80;
                          if (*v80) {
                            *(void *)(*v80 + 8) = v80[1];
                          }
                        }
                        *char v80 = 0;
                        v80[1] = 0;
                        v80[3] = 0;
                      }
                    }
                  }
                  (*(void (**)(uint64_t, unsigned int *))(*(void *)v6 + 40))(v6, v66);
                  int v7 = 1;
                  unint64_t v61 = v64;
                  if (v64 == v62) {
                    goto LABEL_94;
                  }
                }
                uint64_t v68 = *(void *)(a4 + 32);
                int v69 = v67 - 1;
                unsigned int v70 = ((v65 >> 4) ^ (v65 >> 9)) & v69;
                v71 = *(unsigned int **)(v68 + 8 * v70);
                if (v71 != v65)
                {
                  int v74 = 1;
                  while (v71 != (unsigned int *)-4096)
                  {
                    unsigned int v75 = v70 + v74++;
                    unsigned int v70 = v75 & v69;
                    v71 = *(unsigned int **)(v68 + 8 * v70);
                    if (v71 == v65) {
                      goto LABEL_99;
                    }
                  }
                  goto LABEL_108;
                }
LABEL_99:
                unint64_t v72 = v65[11];
                if ((v72 & 0x7FFFFF) != 0) {
                  unint64_t v73 = (((unint64_t)&v65[4 * ((v72 >> 23) & 1) + 17] + ((v72 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
                }
                      + 32 * v65[10];
                else {
                  unint64_t v73 = 0;
                }
                v7 |= deleteDeadness(v6, v73) != 0;
                unint64_t v61 = v64;
              }
              while (v64 != v62);
            }
LABEL_94:
            LODWORD(v118) = v118 - 1;
            if (v118) {
              llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>::traverseChild((llvm::SmallPtrSetImplBase *)&v114);
            }
            uint64_t v13 = v112;
          }
          unint64_t v102 = (ZinIrHalH13g **)*((void *)__dst + 5 * v118 - 5);
          mlir::Block::getTerminator(v18);
          uint64_t v105 = v19;
          uint64_t v20 = *(void *)(v19 + 48);
          unint64_t v21 = *(void **)(v20 + 16);
          if (v21 == &mlir::detail::TypeIDResolver<void,void>::id) {
            uint64_t v22 = 0;
          }
          else {
            uint64_t v22 = *(void *)(v19 + 48);
          }
          int v103 = v7;
          if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v130 = *(const char **)(v20 + 8);
            uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v130);
            if (!Values
              || (uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v20)) == 0)
            {
LABEL_52:
              uint64_t v106 = 0;
              uint64_t v107 = Values;
LABEL_92:
              uint64_t v6 = a1;
              uint64_t v18 = v102;
              int v7 = v103;
              goto LABEL_93;
            }
          }
          else
          {
            {
              v130 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
              unint64_t v131 = 73;
              unint64_t v82 = llvm::StringRef::find((uint64_t *)&v130, "DesiredTypeName = ", 0x12uLL, 0);
              if (v131 >= v82) {
                unint64_t v83 = v82;
              }
              else {
                unint64_t v83 = v131;
              }
              unint64_t v84 = &v130[v83];
              unint64_t v85 = v131 - v83;
              uint64_t v86 = 18;
              if (v85 < 0x12) {
                uint64_t v86 = v85;
              }
              unint64_t v87 = v85 - v86;
              if (v87 >= v87 - 1) {
                uint64_t v88 = v87 - 1;
              }
              else {
                uint64_t v88 = v87;
              }
              mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
            }
            unint64_t v23 = *(unsigned int *)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x28);
            if (!v23) {
              goto LABEL_168;
            }
            uint64_t v24 = *(void **)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x20);
            v25 = &v24[2 * v23];
            do
            {
              unint64_t v26 = v23 >> 1;
              v27 = &v24[2 * (v23 >> 1)];
              unint64_t v29 = *v27;
              uint64_t v28 = v27 + 2;
              v23 += ~(v23 >> 1);
              if (v29 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
                uint64_t v24 = v28;
              }
              else {
                unint64_t v23 = v26;
              }
            }
            while (v23);
            if (v24 == v25
              || *v24 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
              || !v24[1])
            {
LABEL_168:
              uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(*(void *)((v22 | v20 & 0xFFFFFFFFFFFFFF00) + 0x18), *(void *)(v105 + 48));
              if (!Values) {
                goto LABEL_52;
              }
            }
          }
          uint64_t v31 = *(void *)(v105 + 48);
          int v32 = *(void **)(v31 + 16);
          if (v32 == &mlir::detail::TypeIDResolver<void,void>::id) {
            uint64_t v33 = 0;
          }
          else {
            uint64_t v33 = *(void *)(v105 + 48);
          }
          if (v32 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v130 = *(const char **)(v31 + 8);
            uint64_t v41 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v130);
            if (v41)
            {
              uint64_t v42 = v31;
              goto LABEL_70;
            }
          }
          else
          {
            {
              v130 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
              unint64_t v131 = 73;
              unint64_t v89 = llvm::StringRef::find((uint64_t *)&v130, "DesiredTypeName = ", 0x12uLL, 0);
              if (v131 >= v89) {
                unint64_t v90 = v89;
              }
              else {
                unint64_t v90 = v131;
              }
              uint64_t v91 = &v130[v90];
              unint64_t v92 = v131 - v90;
              uint64_t v93 = 18;
              if (v92 < 0x12) {
                uint64_t v93 = v92;
              }
              unint64_t v94 = v92 - v93;
              if (v94 >= v94 - 1) {
                uint64_t v95 = v94 - 1;
              }
              else {
                uint64_t v95 = v94;
              }
              mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
            }
            unint64_t v34 = *(unsigned int *)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x28);
            if (!v34) {
              goto LABEL_67;
            }
            uint64_t v35 = *(void **)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x20);
            v36 = &v35[2 * v34];
            do
            {
              unint64_t v37 = v34 >> 1;
              uint64_t v38 = &v35[2 * (v34 >> 1)];
              unint64_t v40 = *v38;
              uint64_t v39 = v38 + 2;
              v34 += ~(v34 >> 1);
              if (v40 < mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id) {
                uint64_t v35 = v39;
              }
              else {
                unint64_t v34 = v37;
              }
            }
            while (v34);
            if (v35 == v36
              || *v35 != mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id
              || (uint64_t v41 = v35[1]) == 0)
            {
LABEL_67:
              uint64_t v41 = *(void *)((v33 | v31 & 0xFFFFFFFFFFFFFF00) + 0x18);
              uint64_t v42 = *(void *)(v105 + 48);
LABEL_70:
              uint64_t v41 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(v41, v42);
            }
          }
          uint64_t v106 = v105;
          uint64_t v107 = v41;
          if (v105)
          {
            uint64_t v43 = *(unsigned int *)(v105 + 40);
            if (v43)
            {
              uint64_t v44 = 0;
              while (1)
              {
                uint64_t v45 = v43;
                uint64_t v46 = (v43 + ~v44);
                mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)&v106, v46);
                uint64_t v47 = (v132 + v130);
                if (v132 + v130) {
                  break;
                }
LABEL_90:
                if (v133 != v134) {
                  free(v133);
                }
                ++v44;
                uint64_t v43 = v45;
                if (v44 == v45) {
                  goto LABEL_92;
                }
              }
              uint64_t v48 = 0;
              uint64_t v49 = *(void *)(((v105
                                + 64
                                + 16 * (((unint64_t)*(unsigned int *)(v105 + 44) >> 23) & 1)
                                + (((unint64_t)*(unsigned int *)(v105 + 44) >> 21) & 0x7F8)
                                + 7) & 0xFFFFFFFFFFFFFFF8)
                              + 32 * v46
                              + 24);
              while (2)
              {
                unsigned int v50 = v47 + ~v48;
                int v51 = *(_DWORD *)(a4 + 24);
                if (v51)
                {
                  unint64_t v52 = *(void *)(*(void *)(v49 + 48) + 8 * v50);
                  uint64_t v53 = *(void *)(a4 + 8);
                  {
                    unint64_t v60 = llvm::hashing::detail::fixed_seed_override;
                    if (!llvm::hashing::detail::fixed_seed_override) {
                      unint64_t v60 = 0xFF51AFD7ED558CCDLL;
                    }
                    llvm::hashing::detail::get_execution_seed(void)::seed = v60;
                  }
                  unint64_t v54 = 0x9DDFEA08EB382D69
                      * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v52) ^ HIDWORD(v52));
                  unint64_t v55 = 0x9DDFEA08EB382D69 * (HIDWORD(v52) ^ (v54 >> 47) ^ v54);
                  unsigned int v56 = (-348639895 * ((v55 >> 47) ^ v55)) & (v51 - 1);
                  uint64_t v57 = *(void *)(v53 + 8 * v56);
                  if (v52 != v57)
                  {
                    int v58 = 1;
                    while (v57 != -4096)
                    {
                      unsigned int v59 = v56 + v58++;
                      unsigned int v56 = v59 & (v51 - 1);
                      uint64_t v57 = *(void *)(v53 + 8 * v56);
                      if (v52 == v57) {
                        goto LABEL_78;
                      }
                    }
                    goto LABEL_77;
                  }
                }
                else
                {
LABEL_77:
                  mlir::MutableOperandRange::erase((mlir::MutableOperandRange *)&v131, v50 - v130, 1u);
                }
LABEL_78:
                if (++v48 == v47) {
                  goto LABEL_90;
                }
                continue;
              }
            }
          }
          goto LABEL_92;
        }
        v14 = v111;
      }
      memcpy(v14, v127, 40 * v15);
      goto LABEL_22;
    }
    v11 = v119;
    uint64_t v12 = v123;
    if (v123 >= 9uLL)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v119, v123, 40);
      uint64_t v12 = v123;
      if (!v123)
      {
LABEL_16:
        LODWORD(v118) = v10;
        goto LABEL_17;
      }
      v11 = __dst;
    }
    memcpy(v11, __src, 40 * v12);
    goto LABEL_16;
  }
  LOBYTE(v7) = 0;
  return v7 & 1;
}

void mlir::simplifyRegions(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  mlir::eraseUnreachableBlocks(a1, (uint64_t)a2, a3);
  v8[1] = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v12 = 0;
  v11 = 0;
  unsigned int v13 = 0;
  if (a3)
  {
    do
    {
      LOBYTE(v8[0]) = 0;
      uint64_t v6 = 24 * a3;
      int v7 = a2;
      do
      {
        propagateLiveness(v7, (int64x2_t *)v8);
        v7 += 3;
        v6 -= 24;
      }
      while (v6);
    }
    while (LOBYTE(v8[0]));
  }
  else
  {
    LOBYTE(v8[0]) = 0;
  }
  deleteDeadness(a1, a2, a3, (uint64_t)v8);
  llvm::deallocate_buffer(v11, (void *)(8 * v13));
}

void llvm::post_order<mlir::Block *>(mlir::Block **a1@<X0>, void *a2@<X8>)
{
  v13[40] = *MEMORY[0x263EF8340];
  llvm::po_iterator<mlir::Region *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Region *>>::po_iterator((uint64_t)&v10, *a1);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7[0] = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  llvm::make_range<llvm::po_iterator<mlir::Block *,llvm::SmallPtrSet<mlir::Block *,8u>,false,llvm::GraphTraits<mlir::Block *>>>((uint64_t)&v10, (uint64_t)&v3, a2);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

unint64_t processValue(unint64_t result, int64x2_t *a2)
{
  v2 = *(void **)result;
  if (!*(void *)result) {
    return result;
  }
  v4 = (mlir::detail::OpResultImpl *)result;
  uint64_t v5 = &a2->i64[1];
  uint64_t v6 = a2 + 2;
  while (1)
  {
    uint64_t v7 = v2[2];
    unint64_t OperandNumber = mlir::OpOperand::getOperandNumber((unint64_t)v2);
    result = mlir::OperationName::hasTrait<mlir::OpTrait::IsTerminator>((void *)(v7 + 48));
    if (!result
      || (result = llvm::DefaultDoCastIfPossible<mlir::BranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::BranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v7),
          v21[0] = (void *)result,
          v21[1] = v9,
          !result)
      || (result = mlir::BranchOpInterface::getSuccessorBlockArgument((mlir::BranchOpInterface *)v21, OperandNumber),
          !v10)
      || (unint64_t v20 = result,
          uint64_t Owner = 0,
          result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v5, &v20, &Owner), result))
    {
      __int32 v11 = a2[3].i32[0];
      if (v11) {
        break;
      }
    }
LABEL_13:
    v2 = (void *)*v2;
    if (!v2) {
      return result;
    }
  }
  uint64_t v12 = v2[2];
  uint64_t v13 = a2[2].i64[0];
  __int32 v14 = v11 - 1;
  unsigned int v15 = ((v12 >> 4) ^ (v12 >> 9)) & v14;
  uint64_t v16 = *(void *)(v13 + 8 * v15);
  if (v16 != v12)
  {
    int v17 = 1;
    while (v16 != -4096)
    {
      unsigned int v18 = v15 + v17++;
      unsigned int v15 = v18 & v14;
      uint64_t v16 = *(void *)(v13 + 8 * v15);
      if (v16 == v12) {
        goto LABEL_15;
      }
    }
    goto LABEL_13;
  }
LABEL_15:
  if (!v4 || (*((void *)v4 + 1) & 7) == 7)
  {
    uint64_t Owner = v4;
    v21[0] = 0;
    result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(v5, (unint64_t *)&Owner, v21);
    if (result)
    {
      char v19 = 0;
    }
    else
    {
      result = (unint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v5, (uint64_t)&Owner, (unint64_t *)&Owner, v21[0]);
      *(void *)result = Owner;
      char v19 = 1;
    }
  }
  else
  {
    uint64_t Owner = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getOwner(v4);
    result = (unint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(v6, (uint64_t *)&Owner, (uint64_t)v21);
    char v19 = v22;
  }
  a2->i8[0] |= v19;
  return result;
}

uint64_t llvm::function_ref<BOOL ()(mlir::BlockArgument)>::callback_fn<deleteDeadness(mlir::RewriterBase &,llvm::MutableArrayRef<mlir::Region>,anonymous namespace'::LiveMap &)::$_0>(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = *a1;
  unint64_t v4 = a2;
  uint64_t v5 = 0;
  return llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)(v2 + 8), &v4, &v5) ^ 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::LookupBucketFor<mlir::SuccessorRange>(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = llvm::hashing::detail::hash_combine_range_impl<llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>(*a2, 0, *a2, a2[1]);
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & v7;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    if (v10)
    {
      if (v11 == -8192)
      {
        uint64_t v12 = 0;
        int v13 = 1;
        __int32 v14 = (void *)(v6 + 40 * v9);
        uint64_t v15 = *v14;
        if (*v14 == -4096) {
          goto LABEL_11;
        }
LABEL_5:
        if (v15 != -8192)
        {
          if (v10 != v14[1]) {
            goto LABEL_11;
          }
          uint64_t v16 = (void *)(v15 + 24);
          uint64_t v17 = -8168;
          uint64_t v18 = a2[1];
          while (*(void *)v17 == *v16)
          {
            v16 += 4;
            v17 += 32;
            if (!--v18) {
              goto LABEL_33;
            }
          }
LABEL_11:
          while (v15 != -4096)
          {
            if (v12) {
              BOOL v19 = 0;
            }
            else {
              BOOL v19 = v15 == -8192;
            }
            if (v19) {
              uint64_t v12 = v14;
            }
            unsigned int v20 = v9 + v13++;
            unsigned int v9 = v20 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v15 = *v14;
            if (*v14 != -4096) {
              goto LABEL_5;
            }
          }
LABEL_86:
          uint64_t result = 0;
          if (v12) {
            __int32 v14 = v12;
          }
          *a3 = v14;
          return result;
        }
      }
      else
      {
        if (v11 != -4096)
        {
          uint64_t v12 = 0;
          unint64_t v37 = (void *)(v11 + 24);
          int v38 = 1;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v39 = *v14;
          if ((*v14 | 0x1000) == 0xFFFFFFFFFFFFF000) {
            goto LABEL_68;
          }
LABEL_63:
          if (v10 != v14[1]) {
            goto LABEL_68;
          }
          unint64_t v40 = (void *)(v39 + 24);
          uint64_t v41 = v37;
          uint64_t v42 = a2[1];
          while (*v41 == *v40)
          {
            v40 += 4;
            v41 += 4;
            uint64_t result = 1;
            if (!--v42) {
              goto LABEL_20;
            }
          }
LABEL_68:
          while (v39 != -4096)
          {
            if (v12) {
              BOOL v43 = 0;
            }
            else {
              BOOL v43 = v39 == -8192;
            }
            if (v43) {
              uint64_t v12 = v14;
            }
            unsigned int v44 = v9 + v38++;
            unsigned int v9 = v44 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v39 = *v14;
            if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000) {
              goto LABEL_63;
            }
          }
          goto LABEL_86;
        }
        uint64_t v12 = 0;
        int v26 = 1;
        __int32 v14 = (void *)(v6 + 40 * v9);
        uint64_t v27 = *v14;
        if (*v14 == -8192) {
          goto LABEL_42;
        }
LABEL_36:
        if (v27 != -4096)
        {
          if (v10 != v14[1]) {
            goto LABEL_42;
          }
          uint64_t v28 = (void *)(v27 + 24);
          uint64_t v29 = -4072;
          uint64_t v30 = a2[1];
          while (*(void *)v29 == *v28)
          {
            v28 += 4;
            v29 += 32;
            uint64_t result = 1;
            if (!--v30) {
              goto LABEL_20;
            }
          }
LABEL_42:
          while (v27 != -4096)
          {
            if (v12) {
              BOOL v31 = 0;
            }
            else {
              BOOL v31 = v27 == -8192;
            }
            if (v31) {
              uint64_t v12 = v14;
            }
            unsigned int v32 = v9 + v26++;
            unsigned int v9 = v32 & v8;
            __int32 v14 = (void *)(v6 + 40 * v9);
            uint64_t v27 = *v14;
            if (*v14 != -8192) {
              goto LABEL_36;
            }
          }
          goto LABEL_86;
        }
      }
    }
    else if (v11 == -8192)
    {
      uint64_t v12 = 0;
      int v22 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v23 = *v14;
      if (*v14 == -4096) {
        goto LABEL_25;
      }
LABEL_23:
      if (v23 != -8192 && v14[1])
      {
LABEL_25:
        while (v23 != -4096)
        {
          if (v12) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v23 == -8192;
          }
          if (v24) {
            uint64_t v12 = v14;
          }
          unsigned int v25 = v9 + v22++;
          unsigned int v9 = v25 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v23 = *v14;
          if (*v14 != -4096) {
            goto LABEL_23;
          }
        }
        goto LABEL_86;
      }
    }
    else if (v11 == -4096)
    {
      uint64_t v12 = 0;
      int v33 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v34 = *v14;
      if (*v14 == -8192) {
        goto LABEL_54;
      }
LABEL_52:
      if (v34 != -4096 && v14[1])
      {
LABEL_54:
        while (v34 != -4096)
        {
          if (v12) {
            BOOL v35 = 0;
          }
          else {
            BOOL v35 = v34 == -8192;
          }
          if (v35) {
            uint64_t v12 = v14;
          }
          unsigned int v36 = v9 + v33++;
          unsigned int v9 = v36 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v34 = *v14;
          if (*v14 != -8192) {
            goto LABEL_52;
          }
        }
        goto LABEL_86;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v45 = 1;
      __int32 v14 = (void *)(v6 + 40 * v9);
      uint64_t v46 = *v14;
      if ((*v14 | 0x1000) == 0xFFFFFFFFFFFFF000) {
        goto LABEL_78;
      }
LABEL_77:
      if (v14[1])
      {
LABEL_78:
        while (v46 != -4096)
        {
          if (v12) {
            BOOL v47 = 0;
          }
          else {
            BOOL v47 = v46 == -8192;
          }
          if (v47) {
            uint64_t v12 = v14;
          }
          unsigned int v48 = v9 + v45++;
          unsigned int v9 = v48 & v8;
          __int32 v14 = (void *)(v6 + 40 * v9);
          uint64_t v46 = *v14;
          if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000) {
            goto LABEL_77;
          }
        }
        goto LABEL_86;
      }
    }
LABEL_33:
    uint64_t result = 1;
    *a3 = v14;
    return result;
  }
  __int32 v14 = 0;
  uint64_t result = 0;
LABEL_20:
  *a3 = v14;
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_range_impl<llvm::detail::indexed_accessor_range_base<mlir::SuccessorRange,mlir::BlockOperand *,mlir::Block *,mlir::Block *,mlir::Block *>::iterator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v94[1] = *MEMORY[0x263EF8340];
  {
    uint64_t v82 = a1;
    uint64_t v83 = a4;
    uint64_t v84 = a3;
    uint64_t v85 = a2;
    a2 = v85;
    a3 = v84;
    a4 = v83;
    int v87 = v86;
    a1 = v82;
    if (v87)
    {
      unint64_t v88 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v88 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v88;
      a2 = v85;
      a1 = v82;
      a3 = v84;
      a4 = v83;
    }
  }
  if (a1 == a3)
  {
    if (a2 == a4)
    {
      unint64_t v13 = 0;
    }
    else
    {
      *(void *)&long long v90 = *(void *)(a1 + 32 * a2 + 24);
      if (a2 + 1 == a4)
      {
        unint64_t v13 = 8;
        ++a2;
      }
      else
      {
        *((void *)&v90 + 1) = *(void *)(a1 + 32 * (a2 + 1) + 24);
        if (a2 + 2 == a4)
        {
          unint64_t v13 = 16;
          a2 += 2;
        }
        else
        {
          *(void *)&long long v91 = *(void *)(a1 + 32 * (a2 + 2) + 24);
          if (a2 + 3 == a4)
          {
            unint64_t v13 = 24;
            a2 += 3;
          }
          else
          {
            *((void *)&v91 + 1) = *(void *)(a1 + 32 * (a2 + 3) + 24);
            if (a2 + 4 == a4)
            {
              unint64_t v13 = 32;
              a2 += 4;
            }
            else
            {
              *(void *)&long long v92 = *(void *)(a1 + 32 * (a2 + 4) + 24);
              if (a2 + 5 == a4)
              {
                unint64_t v13 = 40;
                a2 += 5;
              }
              else
              {
                *((void *)&v92 + 1) = *(void *)(a1 + 32 * (a2 + 5) + 24);
                if (a2 + 6 == a4)
                {
                  unint64_t v13 = 48;
                  a2 += 6;
                }
                else
                {
                  *(void *)&long long v93 = *(void *)(a1 + 32 * (a2 + 6) + 24);
                  if (a2 + 7 == a4)
                  {
                    unint64_t v13 = 56;
                    a2 += 7;
                  }
                  else
                  {
                    *((void *)&v93 + 1) = *(void *)(a1 + 32 * (a2 + 7) + 24);
                    a2 += 8;
                    unint64_t v13 = 64;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (a2 == a4) {
      return llvm::hashing::detail::hash_short((llvm::hashing::detail *)&v90, v13, llvm::hashing::detail::get_execution_seed(void)::seed);
    }
    uint64_t v6 = *((void *)&v90 + 1);
    uint64_t v5 = v90;
    uint64_t v8 = *((void *)&v91 + 1);
    uint64_t v7 = v91;
    uint64_t v10 = *((void *)&v92 + 1);
    uint64_t v9 = v92;
    uint64_t v12 = *((void *)&v93 + 1);
    uint64_t v11 = v93;
  }
  else
  {
    int v4 = (void *)(a1 + 32 * a2);
    uint64_t v5 = v4[3];
    *(void *)&long long v90 = v5;
    uint64_t v6 = v4[7];
    *((void *)&v90 + 1) = v6;
    uint64_t v7 = v4[11];
    *(void *)&long long v91 = v7;
    uint64_t v8 = v4[15];
    *((void *)&v91 + 1) = v8;
    uint64_t v9 = v4[19];
    *(void *)&long long v92 = v9;
    uint64_t v10 = v4[23];
    *((void *)&v92 + 1) = v10;
    uint64_t v11 = v4[27];
    *(void *)&long long v93 = v11;
    uint64_t v12 = v4[31];
    *((void *)&v93 + 1) = v12;
    a2 += 8;
  }
  unint64_t v15 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
  uint64_t v16 = __ROR8__(llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273, 49);
  unint64_t v17 = llvm::hashing::detail::get_execution_seed(void)::seed ^ ((unint64_t)llvm::hashing::detail::get_execution_seed(void)::seed >> 47);
  unint64_t v18 = 0x9DDFEA08EB382D69
      * (llvm::hashing::detail::get_execution_seed(void)::seed ^ (((0x9DDFEA08EB382D69
                                                                  * (v17 ^ (0xB492B66FBE98F273
                                                                          * llvm::hashing::detail::get_execution_seed(void)::seed))) ^ llvm::hashing::detail::get_execution_seed(void)::seed) >> 47) ^ (0x9DDFEA08EB382D69 * (v17 ^ (0xB492B66FBE98F273 * llvm::hashing::detail::get_execution_seed(void)::seed))));
  unint64_t v19 = 0x9DDFEA08EB382D69 * (v18 ^ (v18 >> 47));
  unint64_t v20 = (0xB492B66FBE98F273 * __ROR8__(v16 + llvm::hashing::detail::get_execution_seed(void)::seed + v6, 37)) ^ v19;
  unint64_t v21 = v10
      + v16
      - 0x4B6D499041670D8DLL
      * __ROR8__(v11+ llvm::hashing::detail::get_execution_seed(void)::seed- 0x4B6D499041670D8DLL * llvm::hashing::detail::get_execution_seed(void)::seed, 42);
  unint64_t v22 = 0xB492B66FBE98F273 * __ROR8__(v17 - 0x622015F714C7D297 * (v15 ^ (v15 >> 47)), 33);
  uint64_t v23 = v5 - 0x6D8ED9027DD26057 * llvm::hashing::detail::get_execution_seed(void)::seed;
  uint64_t v24 = v23 + v6 + v7;
  uint64_t v25 = __ROR8__(v24, 44) + v23 + __ROR8__(v20 + v17 + v23 + v8, 21);
  uint64_t v26 = v24 + v8;
  uint64_t v27 = v21 + v7;
  unint64_t v28 = v19 + v9 + v22;
  unint64_t v29 = v10 + v11 + v28;
  unint64_t v30 = __ROR8__(v29, 44) + v28 + __ROR8__(v27 + v12 + v28, 21);
  unint64_t v31 = v29 + v12;
  if (a1 != a3 || a2 != a4)
  {
    unint64_t v89 = (char *)&v91 + 8;
    unint64_t v32 = 64;
    while (1)
    {
      if (a1 == a3 && a2 == a4)
      {
        uint64_t v36 = 0;
        a2 = a4;
      }
      else
      {
        *(void *)&long long v90 = *(void *)(a1 + 32 * a2 + 24);
        uint64_t v37 = a2 + 1;
        if (a1 == a3 && v37 == a4)
        {
          uint64_t v38 = 0;
          uint64_t v36 = 8;
          ++a2;
          uint64_t v39 = (char *)&v90 + 8;
        }
        else
        {
          *((void *)&v90 + 1) = *(void *)(a1 + 32 * v37 + 24);
          uint64_t v40 = a2 + 2;
          if (a1 == a3 && v40 == a4)
          {
            uint64_t v38 = 8;
            uint64_t v36 = 16;
            a2 += 2;
            uint64_t v39 = (char *)&v91;
          }
          else
          {
            *(void *)&long long v91 = *(void *)(a1 + 32 * v40 + 24);
            uint64_t v41 = a2 + 3;
            if (a1 == a3 && v41 == a4)
            {
              uint64_t v38 = 16;
              uint64_t v36 = 24;
              a2 += 3;
              uint64_t v39 = v89;
            }
            else
            {
              *((void *)&v91 + 1) = *(void *)(a1 + 32 * v41 + 24);
              uint64_t v42 = a2 + 4;
              if (a1 == a3 && v42 == a4)
              {
                uint64_t v38 = 24;
                uint64_t v36 = 32;
                a2 += 4;
                uint64_t v39 = (char *)&v92;
              }
              else
              {
                *(void *)&long long v92 = *(void *)(a1 + 32 * v42 + 24);
                uint64_t v43 = a2 + 5;
                if (a1 == a3 && v43 == a4)
                {
                  uint64_t v38 = 32;
                  uint64_t v36 = 40;
                  a2 += 5;
                  uint64_t v39 = (char *)&v92 + 8;
                }
                else
                {
                  *((void *)&v92 + 1) = *(void *)(a1 + 32 * v43 + 24);
                  uint64_t v44 = a2 + 6;
                  if (a1 == a3 && v44 == a4)
                  {
                    uint64_t v38 = 40;
                    uint64_t v36 = 48;
                    a2 += 6;
                    uint64_t v39 = (char *)&v93;
                  }
                  else
                  {
                    *(void *)&long long v93 = *(void *)(a1 + 32 * v44 + 24);
                    uint64_t v45 = a2 + 7;
                    if (a1 == a3 && v45 == a4)
                    {
                      uint64_t v38 = 48;
                      uint64_t v36 = 56;
                      a2 += 7;
                      uint64_t v39 = (char *)&v93 + 8;
                    }
                    else
                    {
                      *((void *)&v93 + 1) = *(void *)(a1 + 32 * v45 + 24);
                      a2 += 8;
                      uint64_t v38 = 56;
                      uint64_t v36 = 64;
                      uint64_t v39 = (char *)v94;
                    }
                  }
                }
              }
            }
          }
        }
        if ((v36 & 0x38) == 0) {
          goto LABEL_82;
        }
        uint64_t v46 = 56 - v38;
        uint64_t v47 = v36;
        if (v36 != 56 - v38)
        {
          do
          {
            uint64_t v54 = v47;
            uint64_t v47 = v46;
            uint64_t v46 = v54 % v46;
          }
          while (v46);
          if (v47)
          {
            unint64_t v55 = (long long *)((char *)&v90 + v47);
            do
            {
              char v57 = *((unsigned char *)v55 - 1);
              unint64_t v55 = (long long *)((char *)v55 - 1);
              char v56 = v57;
              int v58 = (long long *)((char *)v55 + v36);
              unsigned int v59 = v55;
              do
              {
                unint64_t v60 = v59;
                unsigned int v59 = v58;
                *(unsigned char *)unint64_t v60 = *(unsigned char *)v58;
                BOOL v61 = v36 < (char *)v94 - (char *)v58;
                unint64_t v62 = (char *)&v90 + v36 - ((char *)v94 - (char *)v58);
                int v58 = (long long *)((char *)v58 + v36);
                if (!v61) {
                  int v58 = (long long *)v62;
                }
              }
              while (v58 != v55);
              *(unsigned char *)unsigned int v59 = v56;
            }
            while (v55 != &v90);
          }
          goto LABEL_82;
        }
        unint64_t v48 = v38 | 7;
        if (55 - v38 < (v38 | 7uLL)) {
          unint64_t v48 = 55 - v38;
        }
        uint64_t v49 = (char *)&v90;
        if (&v90 < (long long *)((char *)&v90 + v38 + v48 + 9))
        {
          uint64_t v50 = v36;
          if (v39 < (char *)&v90 + v48 + 1) {
            goto LABEL_60;
          }
        }
        if (v48 >= 0x1F)
        {
          unint64_t v64 = v48 + 1;
          uint64_t v63 = (v48 + 1) & 0x60;
          uint64_t v65 = (long long *)((char *)&v90 + v36);
          long long v66 = v90;
          long long v67 = v91;
          long long v68 = *(long long *)((char *)&v90 + v36 + 16);
          long long v90 = *(long long *)((char *)&v90 + v36);
          long long v91 = v68;
          *uint64_t v65 = v66;
          v65[1] = v67;
          if (v63 != 32)
          {
            int v69 = (long long *)((char *)&v92 + v36);
            long long v70 = v92;
            long long v71 = v93;
            long long v72 = *(long long *)((char *)&v92 + v36 + 16);
            long long v92 = *(long long *)((char *)&v92 + v36);
            long long v93 = v72;
            *int v69 = v70;
            v69[1] = v71;
          }
          if (v64 == v63) {
            goto LABEL_82;
          }
          if ((v64 & 0x18) == 0)
          {
            uint64_t v49 = (char *)&v90 + v63;
            uint64_t v50 = v36 + v63;
LABEL_60:
            int v51 = v49 + 1;
            do
            {
              char v52 = *(v51 - 1);
              *(v51 - 1) = *((unsigned char *)&v90 + v50);
              *((unsigned char *)&v90 + v50) = v52;
              if (v51 == v39) {
                break;
              }
              ++v51;
            }
            while (v50++ != 63);
            goto LABEL_82;
          }
        }
        else
        {
          uint64_t v63 = 0;
        }
        unint64_t v73 = (uint64_t *)((char *)&v90 + v63);
        uint64_t v74 = v48 - v63 + 1;
        do
        {
          uint64_t v75 = *v73;
          *unint64_t v73 = v73[(unint64_t)v36 / 8];
          v73[(unint64_t)v36 / 8] = v75;
          ++v73;
          v74 -= 8;
        }
        while (v74);
      }
LABEL_82:
      unint64_t v76 = v21 + v26 + v22 + *((void *)&v90 + 1);
      unint64_t v21 = *((void *)&v92 + 1) + v26 - 0x4B6D499041670D8DLL * __ROR8__(v21 + v25 + v93, 42);
      unint64_t v77 = v20 + v31;
      uint64_t v78 = v90 - 0x4B6D499041670D8DLL * v25;
      uint64_t v79 = v78 + *((void *)&v90 + 1) + v91;
      unint64_t v20 = (0xB492B66FBE98F273 * __ROR8__(v76, 37)) ^ v30;
      uint64_t v25 = __ROR8__(v79, 44) + v78 + __ROR8__(v20 + v31 + v78 + *((void *)&v91 + 1), 21);
      unint64_t v22 = 0xB492B66FBE98F273 * __ROR8__(v77, 33);
      unint64_t v80 = v22 + v30 + v92;
      unint64_t v81 = *((void *)&v92 + 1) + v93 + v80;
      uint64_t v26 = v79 + *((void *)&v91 + 1);
      unint64_t v30 = __ROR8__(v21 + v91 + v80 + *((void *)&v93 + 1), 21) + v80 + __ROR8__(v81, 44);
      unint64_t v31 = v81 + *((void *)&v93 + 1);
      v32 += v36;
      if (a1 == a3 && a2 == a4) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v32 = 64;
LABEL_27:
  unint64_t v33 = 0x9DDFEA08EB382D69
      * (v30 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v30)));
  uint64_t v34 = v22 - 0x4B6D499041670D8DLL * (v32 ^ (v32 >> 47)) - 0x622015F714C7D297 * (v33 ^ (v33 >> 47));
  unint64_t v35 = 0x9DDFEA08EB382D69
      * (v34 ^ (v20
              - 0x4B6D499041670D8DLL * (v21 ^ (v21 >> 47))
              - 0x622015F714C7D297
              * ((0x9DDFEA08EB382D69
                * (v31 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v31)))) ^ ((0x9DDFEA08EB382D69 * (v31 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v31)))) >> 47))));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v34 ^ (v35 >> 47) ^ v35)) ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v35 >> 47) ^ v35)) >> 47));
}

_OWORD *llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = 40 * v3;
    llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::moveFromOldBuckets(a1, (uint64_t)v4, (uint64_t)v4 + v10);
    llvm::deallocate_buffer(v4, (void *)v10);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 16);
  if (v11)
  {
    unint64_t v12 = 40 * v11 - 40;
    if (v12 < 0x28)
    {
      unint64_t v13 = result;
LABEL_14:
      unint64_t v17 = (_OWORD *)((char *)result + 40 * v11);
      do
      {
        _OWORD *v13 = xmmword_211F0B180;
        unint64_t v13 = (_OWORD *)((char *)v13 + 40);
      }
      while (v13 != v17);
      return result;
    }
    unint64_t v14 = v12 / 0x28 + 1;
    unint64_t v13 = (_OWORD *)((char *)result + 40 * (v14 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v15 = v14 & 0xFFFFFFFFFFFFFFELL;
    uint64_t v16 = result;
    do
    {
      _OWORD *v16 = xmmword_211F0B180;
      *(_OWORD *)((char *)v16 + 40) = xmmword_211F0B180;
      v16 += 5;
      v15 -= 2;
    }
    while (v15);
    if (v14 != (v14 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_14;
    }
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::moveFromOldBuckets(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)a1;
    unint64_t v8 = 40 * v6 - 40;
    if (v8 < 0x28)
    {
      uint64_t v9 = *(_OWORD **)a1;
LABEL_7:
      unint64_t v13 = (_OWORD *)(v7 + 40 * v6);
      do
      {
        *uint64_t v9 = xmmword_211F0B180;
        uint64_t v9 = (_OWORD *)((char *)v9 + 40);
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    unint64_t v10 = v8 / 0x28 + 1;
    uint64_t v9 = (_OWORD *)(v7 + 40 * (v10 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    unint64_t v12 = *(_OWORD **)a1;
    do
    {
      _OWORD *v12 = xmmword_211F0B180;
      *(_OWORD *)((char *)v12 + 40) = xmmword_211F0B180;
      v12 += 5;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_7;
    }
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v17 = 0;
        llvm::DenseMapBase<llvm::DenseMap<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>,mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>,llvm::DenseMapInfo<mlir::SuccessorRange,void>,llvm::detail::DenseMapPair<mlir::SuccessorRange,llvm::SmallVector<mlir::Block *,1u>>>::LookupBucketFor<mlir::SuccessorRange>((uint64_t *)a1, (uint64_t *)v4, &v17);
        unint64_t v14 = v17;
        _OWORD *v17 = *(_OWORD *)v4;
        *((void *)v14 + 3) = 0x100000000;
        *((void *)v14 + 2) = v14 + 2;
        uint64_t v15 = (uint64_t)(v14 + 1);
        if (*(_DWORD *)(v4 + 24)) {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v15, v4 + 16);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v16 = *(void **)(v4 + 16);
        if ((void *)(v4 + 32) != v16) {
          free(v16);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

uint64_t mlir::OperationEquivalence::ignoreValueEquivalence()
{
  return 1;
}

uint64_t llvm::function_ref<mlir::LogicalResult ()(mlir::Value,mlir::Value)>::callback_fn<mlir::LogicalResult ()(mlir::Value,mlir::Value)>(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t ableToUpdatePredOperands(mlir::Block *a1)
{
  v1 = *(void **)a1;
  if (*(void *)a1)
  {
    while (1)
    {
      uint64_t v3 = (ZinIrHalH13g **)mlir::PredecessorIterator::unwrap((uint64_t)v1);
      mlir::Block::getTerminator(v3);
      uint64_t v5 = *(void *)(v4 + 48);
      unsigned int v6 = *(void **)(v5 + 16);
      BOOL v7 = v6 == &mlir::detail::TypeIDResolver<void,void>::id;
      uint64_t v8 = v6 == &mlir::detail::TypeIDResolver<void,void>::id ? 0 : *(void *)(v4 + 48);
      if (v7) {
        break;
      }
      uint64_t v9 = v4;
      unint64_t v10 = v8 | v5 & 0xFFFFFFFFFFFFFF00;
      if (!mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v10 + 32))
      {
        uint64_t result = *(void *)(v10 + 24);
        uint64_t v11 = *(void *)(v9 + 48);
LABEL_3:
        uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(result, v11);
        if (!result) {
          return result;
        }
      }
      v1 = (void *)*v1;
      if (!v1) {
        return 1;
      }
    }
    uint64_t v12 = *(void *)(v5 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v12);
    if (!result) {
      return result;
    }
    uint64_t v11 = v5;
    goto LABEL_3;
  }
  return 1;
}

void anonymous namespace'::BlockMergeCluster::merge(mlir::RewriterBase &)::$_0::operator()(void **a1, mlir::BlockOperand *a2, unsigned int a3)
{
  v23[3] = *MEMORY[0x263EF8340];
  unint64_t v17 = (mlir::BlockOperand **)a2;
  for (uint64_t i = mlir::PredecessorIterator::unwrap; a2; v17 = (mlir::BlockOperand **)a2)
  {
    uint64_t v5 = (ZinIrHalH13g **)i((uint64_t)a2);
    mlir::Block::getTerminator(v5);
    uint64_t v7 = Values;
    if (Values)
    {
      uint64_t v8 = *(void *)(Values + 48);
      uint64_t v9 = *(void **)(v8 + 16);
      BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
      if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = *(void *)(Values + 48);
      }
      if (v10)
      {
        uint64_t v20 = *(void *)(v8 + 8);
        uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v20);
        if (Values)
        {
          uint64_t v13 = v8;
          goto LABEL_13;
        }
      }
      else
      {
        unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
        uint64_t Values = mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v12 + 32);
        if (!Values)
        {
          uint64_t Values = *(void *)(v12 + 24);
          uint64_t v13 = *(void *)(v7 + 48);
LABEL_13:
          uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v13);
        }
      }
    }
    v16[0] = v7;
    v16[1] = Values;
    unint64_t SuccessorIndex = mlir::PredecessorIterator::getSuccessorIndex((mlir::BlockOperand **)&v17);
    mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)v16, SuccessorIndex);
    uint64_t v15 = **a1 + 80 * a3;
    mlir::ValueRange::ValueRange(v19, *(void *)v15, *(unsigned int *)(v15 + 8));
    mlir::MutableOperandRange::append((uint64_t)&v21, v19[0], v19[1]);
    if (v22 != v23) {
      free(v22);
    }
    a2 = *v17;
  }
}

void llvm::SmallVectorImpl<llvm::SmallVector<mlir::Value,8u>>::assign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,8u>,false>::growAndAssign(a1, a2, a3);
    return;
  }
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = *(unsigned int *)(a1 + 8);
  }
  if (v7)
  {
    uint64_t v8 = *(void *)a1;
    while (1)
    {
      if (v8 == a3) {
        goto LABEL_11;
      }
      unint64_t v9 = *(unsigned int *)(a3 + 8);
      uint64_t v10 = *(unsigned int *)(v8 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)v8, *(const void **)a3, 8 * v9);
        }
        goto LABEL_10;
      }
      if (*(_DWORD *)(v8 + 12) >= v9)
      {
        if (v10)
        {
          memmove(*(void **)v8, *(const void **)a3, 8 * v10);
          uint64_t v11 = *(unsigned int *)(a3 + 8);
          if (v10 != v11) {
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v11 = *(unsigned int *)(a3 + 8);
          if (*(_DWORD *)(a3 + 8)) {
LABEL_23:
          }
            memcpy((void *)(*(void *)v8 + 8 * v10), (const void *)(*(void *)a3 + 8 * v10), *(void *)a3 + 8 * v11 - (*(void *)a3 + 8 * v10));
        }
      }
      else
      {
        *(_DWORD *)(v8 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v8, (void *)(v8 + 16), v9, 8);
        uint64_t v10 = 0;
        uint64_t v11 = *(unsigned int *)(a3 + 8);
        if (*(_DWORD *)(a3 + 8)) {
          goto LABEL_23;
        }
      }
LABEL_10:
      *(_DWORD *)(v8 + 8) = v9;
LABEL_11:
      v8 += 80;
      if (!--v7)
      {
        unint64_t v6 = *(unsigned int *)(a1 + 8);
        break;
      }
    }
  }
  unint64_t v12 = v6 - a2;
  if (v6 < a2)
  {
    uint64_t v13 = (void *)(*(void *)a1 + 80 * v6);
    while (1)
    {
      uint64_t v16 = v13 + 2;
      void *v13 = v13 + 2;
      v13[1] = 0x800000000;
      if (v13 == (void *)a3) {
        goto LABEL_30;
      }
      unint64_t v17 = *(unsigned int *)(a3 + 8);
      if (!*(_DWORD *)(a3 + 8)) {
        goto LABEL_30;
      }
      if (v17 < 9)
      {
        uint64_t v14 = *(unsigned int *)(a3 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v13, v13 + 2, *(unsigned int *)(a3 + 8), 8);
        uint64_t v14 = *(unsigned int *)(a3 + 8);
        if (!v14) {
          goto LABEL_29;
        }
        uint64_t v16 = (void *)*v13;
      }
      memcpy(v16, *(const void **)a3, 8 * v14);
LABEL_29:
      *((_DWORD *)v13 + 2) = v17;
LABEL_30:
      v13 += 10;
      if (__CFADD__(v12++, 1)) {
        goto LABEL_41;
      }
    }
  }
  if (v6 > a2)
  {
    uint64_t v18 = 80 * v6;
    unint64_t v19 = (void **)(v18 + *(void *)a1 - 80);
    unint64_t v20 = 80 * a2 - v18;
    do
    {
      if (v19 + 2 != *v19) {
        free(*v19);
      }
      v19 -= 10;
      v20 += 80;
    }
    while (v20);
  }
LABEL_41:
  *(_DWORD *)(a1 + 8) = a2;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,8u>,false>::growAndAssign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v19 = 0;
  unint64_t v6 = (char *)(a1 + 16);
  unint64_t v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 80, &v19);
  uint64_t v8 = v7;
  if (a2)
  {
    unint64_t v9 = v7;
    for (unint64_t i = a2; i; --i)
    {
      unint64_t v12 = v9 + 2;
      *unint64_t v9 = v9 + 2;
      v9[1] = 0x800000000;
      if (v9 == (void *)a3) {
        goto LABEL_6;
      }
      unint64_t v13 = *(unsigned int *)(a3 + 8);
      if (!*(_DWORD *)(a3 + 8)) {
        goto LABEL_6;
      }
      if (v13 < 9)
      {
        uint64_t v11 = *(unsigned int *)(a3 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v9, v9 + 2, *(unsigned int *)(a3 + 8), 8);
        uint64_t v11 = *(unsigned int *)(a3 + 8);
        if (!v11) {
          goto LABEL_5;
        }
        unint64_t v12 = (void *)*v9;
      }
      memcpy(v12, *(const void **)a3, 8 * v11);
LABEL_5:
      *((_DWORD *)v9 + 2) = v13;
LABEL_6:
      v9 += 10;
    }
  }
  uint64_t v14 = *(char **)a1;
  uint64_t v15 = *(unsigned int *)(a1 + 8);
  if (v15)
  {
    uint64_t v16 = 80 * v15;
    do
    {
      unint64_t v17 = *(char **)&v14[v16 - 80];
      if (&v14[v16 - 64] != v17) {
        free(v17);
      }
      v16 -= 80;
    }
    while (v16);
    uint64_t v14 = *(char **)a1;
  }
  int v18 = v19;
  if (v14 != v6) {
    free(v14);
  }
  *(void *)a1 = v8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v18;
}

void *llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::df_iterator(void *a1, void *a2, llvm::SmallPtrSetImplBase *this)
{
  a1[1] = 0;
  uint64_t v5 = a1 + 1;
  *a1 = this;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v6 = *((void *)this + 1);
  if (v6 != *(void *)this) {
    goto LABEL_2;
  }
  uint64_t v11 = *((unsigned int *)this + 5);
  if (!v11)
  {
LABEL_22:
    if (v11 < *((_DWORD *)this + 4))
    {
      *((_DWORD *)this + 5) = v11 + 1;
      *(void *)(v6 + 8 * v11) = a2;
LABEL_3:
      unint64_t v9 = (unsigned char *)a1[2];
      unint64_t v8 = a1[3];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v15 = (unsigned char *)*v5;
        uint64_t v16 = (uint64_t)&v9[-*v5] >> 5;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 59) {
          abort();
        }
        uint64_t v18 = v8 - (void)v15;
        if (v18 >> 4 > v17) {
          unint64_t v17 = v18 >> 4;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 59) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v20 = (char *)operator new(32 * v19);
        }
        else
        {
          unint64_t v20 = 0;
        }
        uint64_t v21 = &v20[32 * v16];
        *(void *)uint64_t v21 = a2;
        v21[8] = 0;
        v21[24] = 0;
        uint64_t v10 = v21 + 32;
        if (v9 != v15)
        {
          do
          {
            long long v22 = *((_OWORD *)v9 - 1);
            *((_OWORD *)v21 - 2) = *((_OWORD *)v9 - 2);
            *((_OWORD *)v21 - 1) = v22;
            v21 -= 32;
            v9 -= 32;
          }
          while (v9 != v15);
          unint64_t v9 = (unsigned char *)*v5;
        }
        a1[1] = v21;
        a1[2] = v10;
        a1[3] = &v20[32 * v19];
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *(void *)unint64_t v9 = a2;
        v9[8] = 0;
        uint64_t v10 = v9 + 32;
        v9[24] = 0;
      }
      a1[2] = v10;
      return a1;
    }
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big(this, a2);
    if (!v7) {
      return a1;
    }
    goto LABEL_3;
  }
  unint64_t v12 = 0;
  uint64_t v13 = 8 * v11;
  uint64_t v14 = (void *)*((void *)this + 1);
  while ((void *)*v14 != a2)
  {
    if (*v14 == -2) {
      unint64_t v12 = v14;
    }
    ++v14;
    v13 -= 8;
    if (!v13)
    {
      if (!v12) {
        goto LABEL_22;
      }
      void *v12 = a2;
      --*((_DWORD *)this + 6);
      goto LABEL_3;
    }
  }
  return a1;
}

void llvm::df_iterator<mlir::Block *,llvm::df_iterator_default_set<mlir::Block *,16u>,true,llvm::GraphTraits<mlir::Block *>>::toNext(llvm::SmallPtrSetImplBase **a1)
{
  uint64_t v2 = (uint64_t)a1[2];
  while (2)
  {
    uint64_t v3 = *(mlir::Block **)(v2 - 32);
    if (!*(unsigned char *)(v2 - 8))
    {
      mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)v28, *(mlir::Block **)(v2 - 32));
      *(void *)(v2 - 24) = v28[0];
      *(void *)(v2 - 16) = 0;
      *(unsigned char *)(v2 - 8) = 1;
    }
    while (1)
    {
      mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)v28, v3);
      uint64_t v6 = *(void *)(v2 - 24);
      uint64_t v7 = *(void *)(v2 - 16);
      if (v6 == v28[0] && v7 == v28[1]) {
        break;
      }
      *(void *)(v2 - 16) = v7 + 1;
      unint64_t v9 = *(const void **)(v6 + 32 * v7 + 24);
      uint64_t v10 = *a1;
      uint64_t v11 = *((void *)*a1 + 1);
      if (v11 != *(void *)*a1) {
        goto LABEL_4;
      }
      uint64_t v12 = *((unsigned int *)v10 + 5);
      if (v12)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v12;
        uint64_t v15 = (void *)*((void *)*a1 + 1);
        do
        {
          if ((const void *)*v15 == v9)
          {
            int v5 = 0;
            goto LABEL_5;
          }
          if (*v15 == -2) {
            uint64_t v13 = v15;
          }
          ++v15;
          v14 -= 8;
        }
        while (v14);
        if (!v13) {
          goto LABEL_19;
        }
        void *v13 = v9;
        --*((_DWORD *)v10 + 6);
        int v5 = 1;
        goto LABEL_5;
      }
LABEL_19:
      if (v12 < *((_DWORD *)v10 + 4))
      {
        *((_DWORD *)v10 + 5) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v9;
        int v5 = 1;
      }
      else
      {
LABEL_4:
        llvm::SmallPtrSetImplBase::insert_imp_big(v10, v9);
        int v5 = v4;
      }
LABEL_5:
      if (v5)
      {
        uint64_t v18 = a1[2];
        unint64_t v17 = (unint64_t)a1[3];
        if ((unint64_t)v18 >= v17)
        {
          unint64_t v20 = a1[1];
          uint64_t v21 = (v18 - v20) >> 5;
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) >> 59) {
            abort();
          }
          uint64_t v23 = v17 - (void)v20;
          if (v23 >> 4 > v22) {
            unint64_t v22 = v23 >> 4;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          if (v24)
          {
            if (v24 >> 59) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v25 = (char *)operator new(32 * v24);
          }
          else
          {
            uint64_t v25 = 0;
          }
          uint64_t v26 = &v25[32 * v21];
          *(void *)uint64_t v26 = v9;
          v26[8] = 0;
          v26[24] = 0;
          unint64_t v19 = (llvm::SmallPtrSetImplBase *)(v26 + 32);
          if (v18 != v20)
          {
            do
            {
              long long v27 = *((_OWORD *)v18 - 1);
              *((_OWORD *)v26 - 2) = *((_OWORD *)v18 - 2);
              *((_OWORD *)v26 - 1) = v27;
              v26 -= 32;
              uint64_t v18 = (llvm::SmallPtrSetImplBase *)((char *)v18 - 32);
            }
            while (v18 != v20);
            uint64_t v18 = a1[1];
          }
          a1[1] = (llvm::SmallPtrSetImplBase *)v26;
          a1[2] = v19;
          a1[3] = (llvm::SmallPtrSetImplBase *)&v25[32 * v24];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          *(void *)uint64_t v18 = v9;
          *((unsigned char *)v18 + 8) = 0;
          unint64_t v19 = (llvm::SmallPtrSetImplBase *)((char *)v18 + 32);
          *((unsigned char *)v18 + 24) = 0;
        }
        a1[2] = v19;
        return;
      }
    }
    uint64_t v16 = a1[1];
    uint64_t v2 = (uint64_t)a1[2] - 32;
    a1[2] = (llvm::SmallPtrSetImplBase *)v2;
    if (v16 != (llvm::SmallPtrSetImplBase *)v2) {
      continue;
    }
    break;
  }
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedOffsets(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 64))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedSizes(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 72))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getMixedStrides(mlir::OffsetSizeAndStrideOpInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 80))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::OffsetSizeAndStrideOpInterface::getDynamicSize(mlir::OffsetSizeAndStrideOpInterface *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*((void *)this + 1) + 168))(*((void *)this + 1), *(void *)this, a2);
}

uint64_t mlir::verifyListOfOperandsOrIntegers(uint64_t a1, void **a2, const char *a3, unsigned int a4, int64x2_t *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  uint64_t v11 = (const char *)a4;
  if (a6 == (const char *)a4)
  {
    if (!a6)
    {
      unsigned int v13 = 0;
      goto LABEL_36;
    }
    unint64_t v12 = (unint64_t)(a6 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v12 >= 3)
    {
      unint64_t v42 = v12 + 1;
      uint64_t v43 = (v12 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      uint64_t v14 = &a5->i64[v43];
      uint64_t v44 = a5 + 1;
      int64x2_t v45 = 0uLL;
      int64x2_t v46 = vdupq_n_s64(0x8000000000000000);
      uint64_t v47 = v43;
      int64x2_t v48 = 0uLL;
      do
      {
        int64x2_t v45 = vsubq_s64(v45, vceqq_s64(v44[-1], v46));
        int64x2_t v48 = vsubq_s64(v48, vceqq_s64(*v44, v46));
        v44 += 2;
        v47 -= 4;
      }
      while (v47);
      unsigned int v13 = vaddvq_s64(vaddq_s64(v48, v45));
      if (v42 == v43) {
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v13 = 0;
      uint64_t v14 = (uint64_t *)a5;
    }
    do
    {
      uint64_t v49 = *v14++;
      if (v49 == 0x8000000000000000) {
        ++v13;
      }
    }
    while (v14 != (uint64_t *)((char *)a5 + 8 * (void)a6));
LABEL_36:
    uint64_t v50 = (const char *)v13;
    if (a8 == v13) {
      return 1;
    }
    v88[0] = "expected ";
    __int16 v89 = 259;
    mlir::Operation::emitError(a1, (uint64_t)v88, (uint64_t)&v94);
    if (v94)
    {
      LODWORD(v90) = 5;
      long long v91 = v50;
      int v51 = &v90;
      char v52 = (char *)v96;
      if (v97 >= v98)
      {
        unint64_t v74 = v97 + 1;
        if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
        {
          int64_t v83 = (char *)&v90 - (unsigned char *)v96;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v74, 24);
          char v52 = (char *)v96;
          int v51 = (void ***)((char *)v96 + v83);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v74, 24);
          int v51 = &v90;
          char v52 = (char *)v96;
        }
      }
      uint64_t v53 = &v52[24 * v97];
      long long v54 = *(_OWORD *)v51;
      *((void *)v53 + 2) = v51[2];
      *(_OWORD *)uint64_t v53 = v54;
      uint64_t v55 = ++v97;
      if (v94)
      {
        LODWORD(v90) = 3;
        long long v91 = " dynamic ";
        uint64_t v92 = 9;
        char v56 = &v90;
        char v57 = (char *)v96;
        if (v55 >= v98)
        {
          unint64_t v75 = v55 + 1;
          BOOL v76 = (char *)v96 + 24 * v55 > (char *)&v90;
          if (v96 <= &v90 && v76)
          {
            int64_t v84 = (char *)&v90 - (unsigned char *)v96;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v75, 24);
            char v57 = (char *)v96;
            char v56 = (void ***)((char *)v96 + v84);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v75, 24);
            char v56 = &v90;
            char v57 = (char *)v96;
          }
        }
        int v58 = &v57[24 * v97];
        long long v59 = *(_OWORD *)v56;
        *((void *)v58 + 2) = v56[2];
        *(_OWORD *)int v58 = v59;
        ++v97;
        if (v94)
        {
          __int16 v93 = 261;
          long long v90 = a2;
          long long v91 = a3;
          mlir::Diagnostic::operator<<((uint64_t)v95, &v90);
          if (v94)
          {
            LODWORD(v90) = 3;
            long long v91 = " values";
            uint64_t v92 = 7;
            unint64_t v60 = &v90;
            BOOL v61 = (char *)v96;
            if (v97 >= v98)
            {
              unint64_t v80 = v97 + 1;
              if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
              {
                int64_t v87 = (char *)&v90 - (unsigned char *)v96;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v80, 24);
                BOOL v61 = (char *)v96;
                unint64_t v60 = (void ***)((char *)v96 + v87);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v80, 24);
                unint64_t v60 = &v90;
                BOOL v61 = (char *)v96;
              }
            }
            unint64_t v62 = &v61[24 * v97];
            long long v63 = *(_OWORD *)v60;
            *((void *)v62 + 2) = v60[2];
            *(_OWORD *)unint64_t v62 = v63;
            ++v97;
          }
        }
      }
    }
    uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v94);
    if (v94) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v94);
    }
    if (v104)
    {
      unint64_t v64 = __p;
      if (__p)
      {
        uint64_t v65 = v103;
        long long v66 = __p;
        if (v103 != __p)
        {
          do
            uint64_t v65 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v65 - 1);
          while (v65 != v64);
          long long v66 = __p;
        }
        int v103 = v64;
        operator delete(v66);
      }
      uint64_t v37 = v100;
      if (!v100) {
        goto LABEL_62;
      }
      long long v67 = v101;
      uint64_t v39 = v100;
      if (v101 == v100)
      {
LABEL_61:
        unint64_t v101 = v37;
        operator delete(v39);
LABEL_62:
        if (v96 != v99) {
          free(v96);
        }
        return v33;
      }
      do
      {
        uint64_t v69 = *--v67;
        uint64_t v68 = v69;
        void *v67 = 0;
        if (v69) {
          MEMORY[0x21667D390](v68, 0x1000C8077774924);
        }
      }
      while (v67 != v37);
LABEL_60:
      uint64_t v39 = v100;
      goto LABEL_61;
    }
    return v33;
  }
  v88[0] = "expected ";
  __int16 v89 = 259;
  mlir::Operation::emitError(a1, (uint64_t)v88, (uint64_t)&v94);
  if (v94)
  {
    LODWORD(v90) = 5;
    long long v91 = v11;
    uint64_t v15 = &v90;
    uint64_t v16 = (char *)v96;
    if (v97 >= v98)
    {
      unint64_t v71 = v97 + 1;
      if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
      {
        int64_t v81 = (char *)&v90 - (unsigned char *)v96;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v71, 24);
        uint64_t v16 = (char *)v96;
        uint64_t v15 = (void ***)((char *)v96 + v81);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v71, 24);
        uint64_t v15 = &v90;
        uint64_t v16 = (char *)v96;
      }
    }
    unint64_t v17 = &v16[24 * v97];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)unint64_t v17 = v18;
    uint64_t v19 = ++v97;
    if (v94)
    {
      LODWORD(v90) = 3;
      long long v91 = " ";
      uint64_t v92 = 1;
      unint64_t v20 = &v90;
      uint64_t v21 = (char *)v96;
      if (v19 >= v98)
      {
        unint64_t v72 = v19 + 1;
        BOOL v73 = (char *)v96 + 24 * v19 > (char *)&v90;
        if (v96 <= &v90 && v73)
        {
          int64_t v82 = (char *)&v90 - (unsigned char *)v96;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v72, 24);
          uint64_t v21 = (char *)v96;
          unint64_t v20 = (void ***)((char *)v96 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v72, 24);
          unint64_t v20 = &v90;
          uint64_t v21 = (char *)v96;
        }
      }
      unint64_t v22 = &v21[24 * v97];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      ++v97;
      if (v94)
      {
        __int16 v93 = 261;
        long long v90 = a2;
        long long v91 = a3;
        mlir::Diagnostic::operator<<((uint64_t)v95, &v90);
        if (v94)
        {
          LODWORD(v90) = 3;
          long long v91 = " values, got ";
          uint64_t v92 = 13;
          unint64_t v24 = &v90;
          uint64_t v25 = (char *)v96;
          if (v97 >= v98)
          {
            unint64_t v77 = v97 + 1;
            if (v96 <= &v90 && (char *)v96 + 24 * v97 > (char *)&v90)
            {
              int64_t v85 = (char *)&v90 - (unsigned char *)v96;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v77, 24);
              uint64_t v25 = (char *)v96;
              unint64_t v24 = (void ***)((char *)v96 + v85);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v77, 24);
              unint64_t v24 = &v90;
              uint64_t v25 = (char *)v96;
            }
          }
          uint64_t v26 = &v25[24 * v97];
          long long v27 = *(_OWORD *)v24;
          *((void *)v26 + 2) = v24[2];
          *(_OWORD *)uint64_t v26 = v27;
          uint64_t v28 = ++v97;
          if (v94)
          {
            LODWORD(v90) = 5;
            long long v91 = a6;
            unint64_t v29 = &v90;
            unint64_t v30 = (char *)v96;
            if (v28 >= v98)
            {
              unint64_t v78 = v28 + 1;
              BOOL v79 = (char *)v96 + 24 * v28 > (char *)&v90;
              if (v96 <= &v90 && v79)
              {
                int64_t v86 = (char *)&v90 - (unsigned char *)v96;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v78, 24);
                unint64_t v30 = (char *)v96;
                unint64_t v29 = (void ***)((char *)v96 + v86);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, v99, v78, 24);
                unint64_t v29 = &v90;
                unint64_t v30 = (char *)v96;
              }
            }
            unint64_t v31 = &v30[24 * v97];
            long long v32 = *(_OWORD *)v29;
            *((void *)v31 + 2) = v29[2];
            *(_OWORD *)unint64_t v31 = v32;
            ++v97;
          }
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v94);
  if (v94) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v94);
  }
  if (v104)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      unint64_t v35 = v103;
      uint64_t v36 = __p;
      if (v103 != __p)
      {
        do
          unint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      int v103 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v100;
    if (!v100) {
      goto LABEL_62;
    }
    uint64_t v38 = v101;
    uint64_t v39 = v100;
    if (v101 == v100) {
      goto LABEL_61;
    }
    do
    {
      uint64_t v41 = *--v38;
      uint64_t v40 = v41;
      *uint64_t v38 = 0;
      if (v41) {
        MEMORY[0x21667D390](v40, 0x1000C8077774924);
      }
    }
    while (v38 != v37);
    goto LABEL_60;
  }
  return v33;
}

uint64_t mlir::detail::verifyOffsetSizeAndStrideOp(uint64_t a1, uint64_t a2)
{
  uint64_t v158 = *MEMORY[0x263EF8340];
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 8))(a2, a1);
  unsigned int v6 = v5;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 64))(&v139, a2, a1);
  if (v140 == 1 && v4 == 1)
  {
    BOOL v9 = 0;
  }
  else
  {
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t))(a2 + 64))(&v154, a2, a1);
    unsigned int v8 = v155;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&v151, a2, a1);
    BOOL v9 = v8 != v152;
    if (v151 != v153) {
      free(v151);
    }
    if (v154 != v156) {
      free(v154);
    }
  }
  if (v139 != &v141) {
    free(v139);
  }
  if (v9)
  {
    v131[0] = "expected mixed offsets rank to match mixed sizes rank (";
    __int16 v132 = 259;
    mlir::Operation::emitError(a1, (uint64_t)v131, (uint64_t)&v139);
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t))(a2 + 64))(&v154, a2, a1);
    if (v139)
    {
      LODWORD(v151) = 5;
      unint64_t v152 = v155;
      uint64_t v10 = (char *)&v151;
      uint64_t v11 = (char *)v142;
      if (v143 >= v144)
      {
        unint64_t v107 = v143 + 1;
        if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
        {
          int64_t v121 = (char *)&v151 - (unsigned char *)v142;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v107, 24);
          uint64_t v11 = (char *)v142;
          uint64_t v10 = (char *)v142 + v121;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v107, 24);
          uint64_t v10 = (char *)&v151;
          uint64_t v11 = (char *)v142;
        }
      }
      unint64_t v12 = &v11[24 * v143];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)unint64_t v12 = v13;
      uint64_t v14 = ++v143;
      if (v139)
      {
        LODWORD(v151) = 3;
        unint64_t v152 = (unint64_t)" vs ";
        v153[0] = 4;
        uint64_t v15 = (char *)&v151;
        uint64_t v16 = (char *)v142;
        if (v14 >= v144)
        {
          unint64_t v109 = v14 + 1;
          BOOL v110 = (char *)v142 + 24 * v14 > (char *)&v151;
          if (v142 <= &v151 && v110)
          {
            int64_t v123 = (char *)&v151 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            uint64_t v16 = (char *)v142;
            uint64_t v15 = (char *)v142 + v123;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            uint64_t v15 = (char *)&v151;
            uint64_t v16 = (char *)v142;
          }
        }
        unint64_t v17 = &v16[24 * v143];
        long long v18 = *(_OWORD *)v15;
        *((void *)v17 + 2) = *((void *)v15 + 2);
        *(_OWORD *)unint64_t v17 = v18;
        ++v143;
      }
    }
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&v151, a2, a1);
    if (v139)
    {
      int v133 = 5;
      unint64_t v134 = v152;
      uint64_t v19 = &v133;
      unint64_t v20 = (char *)v142;
      if (v143 >= v144)
      {
        unint64_t v108 = v143 + 1;
        if (v142 <= &v133 && (char *)v142 + 24 * v143 > (char *)&v133)
        {
          int64_t v122 = (char *)&v133 - (unsigned char *)v142;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          unint64_t v20 = (char *)v142;
          uint64_t v19 = (int *)((char *)v142 + v122);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          uint64_t v19 = &v133;
          unint64_t v20 = (char *)v142;
        }
      }
      uint64_t v21 = &v20[24 * v143];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)uint64_t v21 = v22;
      uint64_t v23 = ++v143;
      if (v139)
      {
        int v133 = 3;
        unint64_t v134 = (unint64_t)") so the rank of the result type is well-formed.";
        uint64_t v135 = 48;
        unint64_t v24 = &v133;
        uint64_t v25 = (char *)v142;
        if (v23 >= v144)
        {
          unint64_t v111 = v23 + 1;
          BOOL v112 = (char *)v142 + 24 * v23 > (char *)&v133;
          if (v142 <= &v133 && v112)
          {
            int64_t v124 = (char *)&v133 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v111, 24);
            uint64_t v25 = (char *)v142;
            unint64_t v24 = (int *)((char *)v142 + v124);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v111, 24);
            unint64_t v24 = &v133;
            uint64_t v25 = (char *)v142;
          }
        }
        uint64_t v26 = &v25[24 * v143];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v143;
      }
    }
    uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v151 != v153) {
      free(v151);
    }
    if (v154 != v156) {
      free(v154);
    }
    if (v139) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    }
    if (v150)
    {
      unint64_t v29 = __p;
      if (__p)
      {
        unint64_t v30 = v149;
        unint64_t v31 = __p;
        if (v149 != __p)
        {
          do
            unint64_t v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
          while (v30 != v29);
          unint64_t v31 = __p;
        }
        uint64_t v149 = v29;
        operator delete(v31);
      }
      long long v32 = v146;
      if (!v146) {
        goto LABEL_124;
      }
      uint64_t v33 = v147;
      uint64_t v34 = v146;
      if (v147 == v146)
      {
LABEL_123:
        uint64_t v147 = v32;
        operator delete(v34);
LABEL_124:
        if (v142 != v145) {
          free(v142);
        }
        return v28;
      }
      do
      {
        uint64_t v36 = *--v33;
        uint64_t v35 = v36;
        *uint64_t v33 = 0;
        if (v36) {
          MEMORY[0x21667D390](v35, 0x1000C8077774924);
        }
      }
      while (v33 != v32);
LABEL_122:
      uint64_t v34 = v146;
      goto LABEL_123;
    }
  }
  else
  {
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&v139, a2, a1);
    int v37 = v140;
    (*(void (**)(char **__return_ptr, uint64_t, uint64_t))(a2 + 80))(&v154, a2, a1);
    unsigned int v38 = v155;
    if (v154 != v156) {
      free(v154);
    }
    if (v139 != &v141) {
      free(v139);
    }
    if (v37 == v38)
    {
      uint64_t v39 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a2, a1);
      uint64_t v41 = v40;
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
      mlir::ValueRange::ValueRange(v138, v42, v43);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (void **)"offset", (const char *)6, v4, v39, v41, v138[0], v138[1]))return 0; {
      uint64_t v44 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a2, a1);
      }
      int64x2_t v46 = v45;
      uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 24))(a2, a1);
      mlir::ValueRange::ValueRange(v137, v47, v48);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (void **)"size", (const char *)4, HIDWORD(v4), v44, v46, v137[0], v137[1]))return 0; {
      uint64_t v49 = (int64x2_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a2, a1);
      }
      int v51 = v50;
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 32))(a2, a1);
      mlir::ValueRange::ValueRange(v136, v52, v53);
      if (!mlir::verifyListOfOperandsOrIntegers(a1, (void **)"stride", (const char *)6, v6, v49, v51, v136[0], v136[1]))return 0; {
      long long v54 = (const char **)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 40))(a2, a1);
      }
      if (v55)
      {
        uint64_t v56 = 8 * v55;
        while (1)
        {
          char v57 = *v54;
          if ((unint64_t)*v54 >= 0x8000000000000001) {
            break;
          }
          ++v54;
          v56 -= 8;
          if (!v56) {
            goto LABEL_53;
          }
        }
        uint64_t v154 = "expected offsets to be non-negative, but got ";
        __int16 v157 = 259;
        mlir::Operation::emitError(a1, (uint64_t)&v154, (uint64_t)&v139);
        if (v139)
        {
          LODWORD(v151) = 2;
          unint64_t v152 = (unint64_t)v57;
          int64_t v86 = (char *)&v151;
          int64_t v87 = (char *)v142;
          if (v143 >= v144)
          {
            unint64_t v119 = v143 + 1;
            if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
            {
              int64_t v129 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
              int64_t v87 = (char *)v142;
              int64_t v86 = (char *)v142 + v129;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
              int64_t v86 = (char *)&v151;
              int64_t v87 = (char *)v142;
            }
          }
          unint64_t v88 = &v87[24 * v143];
          long long v89 = *(_OWORD *)v86;
          *((void *)v88 + 2) = *((void *)v86 + 2);
          *(_OWORD *)unint64_t v88 = v89;
          ++v143;
        }
        uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v150)
        {
          long long v90 = __p;
          if (__p)
          {
            long long v91 = v149;
            uint64_t v92 = __p;
            if (v149 != __p)
            {
              do
                long long v91 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v91 - 1);
              while (v91 != v90);
              uint64_t v92 = __p;
            }
            uint64_t v149 = v90;
            operator delete(v92);
          }
          long long v32 = v146;
          if (!v146) {
            goto LABEL_124;
          }
          __int16 v93 = v147;
          uint64_t v34 = v146;
          if (v147 == v146) {
            goto LABEL_123;
          }
          do
          {
            uint64_t v95 = *--v93;
            uint64_t v94 = v95;
            *__int16 v93 = 0;
            if (v95) {
              MEMORY[0x21667D390](v94, 0x1000C8077774924);
            }
          }
          while (v93 != v32);
          goto LABEL_122;
        }
      }
      else
      {
LABEL_53:
        int v58 = (const char **)(*(uint64_t (**)(uint64_t, uint64_t))(a2 + 48))(a2, a1);
        if (!v59) {
          return 1;
        }
        uint64_t v60 = 8 * v59;
        while (1)
        {
          BOOL v61 = *v58;
          if ((unint64_t)*v58 >= 0x8000000000000001) {
            break;
          }
          ++v58;
          uint64_t v28 = 1;
          v60 -= 8;
          if (!v60) {
            return v28;
          }
        }
        uint64_t v154 = "expected sizes to be non-negative, but got ";
        __int16 v157 = 259;
        mlir::Operation::emitError(a1, (uint64_t)&v154, (uint64_t)&v139);
        if (v139)
        {
          LODWORD(v151) = 2;
          unint64_t v152 = (unint64_t)v61;
          uint64_t v96 = (char *)&v151;
          unsigned int v97 = (char *)v142;
          if (v143 >= v144)
          {
            unint64_t v120 = v143 + 1;
            if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
            {
              int64_t v130 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v120, 24);
              unsigned int v97 = (char *)v142;
              uint64_t v96 = (char *)v142 + v130;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v120, 24);
              uint64_t v96 = (char *)&v151;
              unsigned int v97 = (char *)v142;
            }
          }
          unsigned int v98 = &v97[24 * v143];
          long long v99 = *(_OWORD *)v96;
          *((void *)v98 + 2) = *((void *)v96 + 2);
          *(_OWORD *)unsigned int v98 = v99;
          ++v143;
        }
        uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v150)
        {
          uint64_t v100 = __p;
          if (__p)
          {
            unint64_t v101 = v149;
            unint64_t v102 = __p;
            if (v149 != __p)
            {
              do
                unint64_t v101 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v101 - 1);
              while (v101 != v100);
              unint64_t v102 = __p;
            }
            uint64_t v149 = v100;
            operator delete(v102);
          }
          long long v32 = v146;
          if (!v146) {
            goto LABEL_124;
          }
          int v103 = v147;
          uint64_t v34 = v146;
          if (v147 == v146) {
            goto LABEL_123;
          }
          do
          {
            uint64_t v105 = *--v103;
            uint64_t v104 = v105;
            *int v103 = 0;
            if (v105) {
              MEMORY[0x21667D390](v104, 0x1000C8077774924);
            }
          }
          while (v103 != v32);
          goto LABEL_122;
        }
      }
    }
    else
    {
      v131[0] = "expected mixed sizes rank to match mixed strides rank (";
      __int16 v132 = 259;
      mlir::Operation::emitError(a1, (uint64_t)v131, (uint64_t)&v139);
      (*(void (**)(char **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&v154, a2, a1);
      if (v139)
      {
        LODWORD(v151) = 5;
        unint64_t v152 = v155;
        unint64_t v62 = (char *)&v151;
        long long v63 = (char *)v142;
        if (v143 >= v144)
        {
          unint64_t v113 = v143 + 1;
          if (v142 <= &v151 && (char *)v142 + 24 * v143 > (char *)&v151)
          {
            int64_t v125 = (char *)&v151 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v113, 24);
            long long v63 = (char *)v142;
            unint64_t v62 = (char *)v142 + v125;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v113, 24);
            unint64_t v62 = (char *)&v151;
            long long v63 = (char *)v142;
          }
        }
        unint64_t v64 = &v63[24 * v143];
        long long v65 = *(_OWORD *)v62;
        *((void *)v64 + 2) = *((void *)v62 + 2);
        *(_OWORD *)unint64_t v64 = v65;
        uint64_t v66 = ++v143;
        if (v139)
        {
          LODWORD(v151) = 3;
          unint64_t v152 = (unint64_t)" vs ";
          v153[0] = 4;
          long long v67 = (char *)&v151;
          uint64_t v68 = (char *)v142;
          if (v66 >= v144)
          {
            unint64_t v115 = v66 + 1;
            BOOL v116 = (char *)v142 + 24 * v66 > (char *)&v151;
            if (v142 <= &v151 && v116)
            {
              int64_t v127 = (char *)&v151 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v115, 24);
              uint64_t v68 = (char *)v142;
              long long v67 = (char *)v142 + v127;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v115, 24);
              long long v67 = (char *)&v151;
              uint64_t v68 = (char *)v142;
            }
          }
          uint64_t v69 = &v68[24 * v143];
          long long v70 = *(_OWORD *)v67;
          *((void *)v69 + 2) = *((void *)v67 + 2);
          *(_OWORD *)uint64_t v69 = v70;
          ++v143;
        }
      }
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 80))(&v151, a2, a1);
      if (v139)
      {
        int v133 = 5;
        unint64_t v134 = v152;
        unint64_t v71 = &v133;
        unint64_t v72 = (char *)v142;
        if (v143 >= v144)
        {
          unint64_t v114 = v143 + 1;
          if (v142 <= &v133 && (char *)v142 + 24 * v143 > (char *)&v133)
          {
            int64_t v126 = (char *)&v133 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
            unint64_t v72 = (char *)v142;
            unint64_t v71 = (int *)((char *)v142 + v126);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
            unint64_t v71 = &v133;
            unint64_t v72 = (char *)v142;
          }
        }
        BOOL v73 = &v72[24 * v143];
        long long v74 = *(_OWORD *)v71;
        *((void *)v73 + 2) = *((void *)v71 + 2);
        *(_OWORD *)BOOL v73 = v74;
        uint64_t v75 = ++v143;
        if (v139)
        {
          int v133 = 3;
          unint64_t v134 = (unint64_t)") so the rank of the result type is well-formed.";
          uint64_t v135 = 48;
          BOOL v76 = &v133;
          unint64_t v77 = (char *)v142;
          if (v75 >= v144)
          {
            unint64_t v117 = v75 + 1;
            BOOL v118 = (char *)v142 + 24 * v75 > (char *)&v133;
            if (v142 <= &v133 && v118)
            {
              int64_t v128 = (char *)&v133 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v117, 24);
              unint64_t v77 = (char *)v142;
              BOOL v76 = (int *)((char *)v142 + v128);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v117, 24);
              BOOL v76 = &v133;
              unint64_t v77 = (char *)v142;
            }
          }
          unint64_t v78 = &v77[24 * v143];
          long long v79 = *(_OWORD *)v76;
          *((void *)v78 + 2) = *((void *)v76 + 2);
          *(_OWORD *)unint64_t v78 = v79;
          ++v143;
        }
      }
      uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
      if (v151 != v153) {
        free(v151);
      }
      if (v154 != v156) {
        free(v154);
      }
      if (v139) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
      }
      if (v150)
      {
        unint64_t v80 = __p;
        if (__p)
        {
          int64_t v81 = v149;
          int64_t v82 = __p;
          if (v149 != __p)
          {
            do
              int64_t v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
            while (v81 != v80);
            int64_t v82 = __p;
          }
          uint64_t v149 = v80;
          operator delete(v82);
        }
        long long v32 = v146;
        if (!v146) {
          goto LABEL_124;
        }
        int64_t v83 = v147;
        uint64_t v34 = v146;
        if (v147 == v146) {
          goto LABEL_123;
        }
        do
        {
          uint64_t v85 = *--v83;
          uint64_t v84 = v85;
          *int64_t v83 = 0;
          if (v85) {
            MEMORY[0x21667D390](v84, 0x1000C8077774924);
          }
        }
        while (v83 != v32);
        goto LABEL_122;
      }
    }
  }
  return v28;
}

llvm::raw_ostream *mlir::printDynamicIndexList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  v31[2] = *MEMORY[0x263EF8340];
  v29[0] = a3;
  v29[1] = a4;
  v31[0] = a7;
  v31[1] = a8;
  v28[0] = a9;
  v28[1] = a10;
  char v14 = 8 * a11 - 8;
  unsigned int v15 = 0x7B3C5B28u >> v14;
  unsigned int v16 = 0x7D3E5D29u >> v14;
  unint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  long long v18 = (unsigned char *)*((void *)v17 + 4);
  if ((unint64_t)v18 >= *((void *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, v15);
    if (a6)
    {
LABEL_3:
      uint64_t v27 = 0;
      v30[0] = v28;
      v30[1] = &v27;
      v30[2] = a1;
      v30[3] = v29;
      v30[4] = (char *)&v27 + 4;
      v30[5] = v31;
      mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, *a5);
      if (a6 != 1)
      {
        uint64_t v19 = a5 + 1;
        uint64_t v20 = 8 * a6 - 8;
        do
        {
          while (1)
          {
            long long v22 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
            uint64_t v23 = (_WORD *)*((void *)v22 + 4);
            if (*((void *)v22 + 3) - (void)v23 <= 1uLL) {
              break;
            }
            *uint64_t v23 = 8236;
            *((void *)v22 + 4) += 2;
            unint64_t v21 = *v19++;
            mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, v21);
            v20 -= 8;
            if (!v20) {
              goto LABEL_8;
            }
          }
          llvm::raw_ostream::write(v22, ", ", 2uLL);
          unint64_t v24 = *v19++;
          mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()((uint64_t)v30, v24);
          v20 -= 8;
        }
        while (v20);
      }
LABEL_8:
      uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v26 = (unsigned char *)*((void *)result + 4);
      if ((unint64_t)v26 >= *((void *)result + 3)) {
        return llvm::raw_ostream::write(result, v16);
      }
      goto LABEL_12;
    }
  }
  else
  {
    *((void *)v17 + 4) = v18 + 1;
    *long long v18 = v15;
    if (a6) {
      goto LABEL_3;
    }
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v26 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v26 < *((void *)result + 3))
  {
LABEL_12:
    *((void *)result + 4) = v26 + 1;
    *uint64_t v26 = v16;
    return result;
  }

  return llvm::raw_ostream::write(result, v16);
}

uint64_t mlir::parseDynamicIndexList(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v53[4] = *MEMORY[0x263EF8340];
  uint64_t v37 = a5;
  int v51 = v53;
  uint64_t v52 = 0x400000000;
  long long v35 = xmmword_211ED5570;
  uint64_t v29 = a1;
  unint64_t v30 = &v34;
  uint64_t v31 = a2;
  long long v32 = (void **)&v51;
  uint64_t v33 = &v37;
  uint64_t v34 = &v36;
  if ((*(unsigned __int8 (**)(void))(*(void *)a1 + 360))())
  {
    unsigned int v8 = (mlir::MLIRContext **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    *a3 = mlir::Builder::getDenseI64ArrayAttr(v8, (uint64_t)v51, v52);
    BOOL v9 = (mlir::MLIRContext **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    *a4 = mlir::Builder::getDenseBoolArrayAttr(v9, (uint64_t)v34, v35);
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    __int16 v28 = 257;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, char *))(*(void *)a1 + 24))(v41, a1, v12, v27);
    if (v41[0])
    {
      int v38 = 3;
      uint64_t v39 = "expected SSA value or integer";
      uint64_t v40 = 29;
      long long v13 = &v38;
      char v14 = (char *)v42;
      if (v43 >= v44)
      {
        unint64_t v25 = v43 + 1;
        if (v42 <= &v38 && (char *)v42 + 24 * v43 > (char *)&v38)
        {
          int64_t v26 = (char *)&v38 - (unsigned char *)v42;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v25, 24);
          char v14 = (char *)v42;
          long long v13 = (int *)((char *)v42 + v26);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v45, v25, 24);
          long long v13 = &v38;
          char v14 = (char *)v42;
        }
      }
      unsigned int v15 = &v14[24 * v43];
      long long v16 = *(_OWORD *)v13;
      *((void *)v15 + 2) = *((void *)v13 + 2);
      *(_OWORD *)unsigned int v15 = v16;
      ++v43;
    }
    uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v50)
    {
      unint64_t v17 = __p;
      if (__p)
      {
        long long v18 = v49;
        uint64_t v19 = __p;
        if (v49 != __p)
        {
          do
            long long v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
          while (v18 != v17);
          uint64_t v19 = __p;
        }
        uint64_t v49 = v17;
        operator delete(v19);
      }
      uint64_t v20 = v46;
      if (v46)
      {
        unint64_t v21 = v47;
        long long v22 = v46;
        if (v47 != v46)
        {
          do
          {
            uint64_t v24 = *--v21;
            uint64_t v23 = v24;
            *unint64_t v21 = 0;
            if (v24) {
              MEMORY[0x21667D390](v23, 0x1000C8077774924);
            }
          }
          while (v21 != v20);
          long long v22 = v46;
        }
        uint64_t v47 = v20;
        operator delete(v22);
      }
      if (v42 != v45) {
        free(v42);
      }
    }
  }
  if (v34 != &v36) {
    free(v34);
  }
  if (v51 != v53) {
    free(v51);
  }
  return v10;
}

uint64_t mlir::detail::sameOffsetsSizesAndStrides(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, void, void), uint64_t a6)
{
  v66[4] = *MEMORY[0x263EF8340];
  (*(void (**)(uint64_t, uint64_t))(a2 + 40))(a2, a1);
  uint64_t v12 = v11;
  (*(void (**)(uint64_t, uint64_t))(a4 + 40))(a4, a3);
  if (v12 != v13) {
    return 0;
  }
  (*(void (**)(uint64_t, uint64_t))(a2 + 48))(a2, a1);
  uint64_t v15 = v14;
  (*(void (**)(uint64_t, uint64_t))(a4 + 48))(a4, a3);
  if (v15 != v16) {
    return 0;
  }
  (*(void (**)(uint64_t, uint64_t))(a2 + 56))(a2, a1);
  uint64_t v18 = v17;
  (*(void (**)(uint64_t, uint64_t))(a4 + 56))(a4, a3);
  if (v18 != v19) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 64))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 64))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v20 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v21 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v21 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v21);
      }
      LODWORD(v62) = v20;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v22 = v56;
  uint64_t v23 = v55;
  if (v56)
  {
    if (v55 != v57)
    {
      unint64_t v64 = v55;
      uint64_t v65 = v56;
      uint64_t v55 = v57;
      HIDWORD(v56) = 0;
      uint64_t v23 = v57;
LABEL_21:
      LODWORD(v56) = 0;
      goto LABEL_22;
    }
    if (v56 < 5)
    {
      uint64_t v24 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v24 = v56;
      uint64_t v23 = v55;
      if (!v56) {
        goto LABEL_20;
      }
    }
    memcpy(v64, v23, 8 * v24);
    uint64_t v23 = v55;
LABEL_20:
    LODWORD(v65) = v22;
    goto LABEL_21;
  }
LABEL_22:
  if (v23 != v57) {
    free(v23);
  }
  if (__src != v60) {
    free(__src);
  }
  unint64_t v25 = v64;
  int v26 = 1;
  if (v62 && v65)
  {
    uint64_t v27 = __dst;
    uint64_t v28 = 8 * v65 - 8;
    uint64_t v29 = 8 * v62 - 8;
    do
    {
      int v26 = a5(a6, *v27, *v25);
      if (!v26) {
        break;
      }
      if (!v29) {
        break;
      }
      ++v27;
      ++v25;
      uint64_t v30 = v28;
      v28 -= 8;
      v29 -= 8;
    }
    while (v30);
    unint64_t v25 = v64;
  }
  if (v25 != v66) {
    free(v25);
  }
  if (__dst != v63) {
    free(__dst);
  }
  if (!v26) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 72))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 72))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v31 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v32 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v32 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v32);
      }
      LODWORD(v62) = v31;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v33 = v56;
  uint64_t v34 = v55;
  if (v56)
  {
    if (v55 != v57)
    {
      unint64_t v64 = v55;
      uint64_t v65 = v56;
      uint64_t v55 = v57;
      HIDWORD(v56) = 0;
      uint64_t v34 = v57;
LABEL_55:
      LODWORD(v56) = 0;
      goto LABEL_56;
    }
    if (v56 < 5)
    {
      uint64_t v35 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v35 = v56;
      uint64_t v34 = v55;
      if (!v56) {
        goto LABEL_54;
      }
    }
    memcpy(v64, v34, 8 * v35);
    uint64_t v34 = v55;
LABEL_54:
    LODWORD(v65) = v33;
    goto LABEL_55;
  }
LABEL_56:
  if (v34 != v57) {
    free(v34);
  }
  if (__src != v60) {
    free(__src);
  }
  uint64_t v36 = v64;
  int v37 = 1;
  if (v62 && v65)
  {
    int v38 = __dst;
    uint64_t v39 = 8 * v65 - 8;
    uint64_t v40 = 8 * v62 - 8;
    do
    {
      int v37 = a5(a6, *v38, *v36);
      if (!v37) {
        break;
      }
      if (!v40) {
        break;
      }
      ++v38;
      ++v36;
      uint64_t v41 = v39;
      v39 -= 8;
      v40 -= 8;
    }
    while (v41);
    uint64_t v36 = v64;
  }
  if (v36 != v66) {
    free(v36);
  }
  if (__dst != v63) {
    free(__dst);
  }
  if (!v37) {
    return 0;
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a2 + 80))(&__src, a2, a1);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(a4 + 80))(&v55, a4, a3);
  __dst = v63;
  uint64_t v62 = 0x400000000;
  int v42 = v59;
  if (v59)
  {
    if (__src == v60)
    {
      unsigned int v45 = v59;
      if (v59 < 5
        || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v63, v59, 8), (unsigned int v45 = v59) != 0))
      {
        memcpy(__dst, __src, 8 * v45);
      }
      LODWORD(v62) = v42;
    }
    else
    {
      __dst = __src;
      uint64_t v62 = v59;
      __src = v60;
      HIDWORD(v59) = 0;
    }
    LODWORD(v59) = 0;
  }
  unint64_t v64 = v66;
  uint64_t v65 = 0x400000000;
  int v46 = v56;
  uint64_t v47 = v55;
  if (!v56) {
    goto LABEL_92;
  }
  if (v55 == v57)
  {
    if (v56 < 5)
    {
      uint64_t v48 = v56;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v66, v56, 8);
      uint64_t v48 = v56;
      uint64_t v47 = v55;
      if (!v56) {
        goto LABEL_90;
      }
    }
    memcpy(v64, v47, 8 * v48);
    uint64_t v47 = v55;
LABEL_90:
    LODWORD(v65) = v46;
    goto LABEL_91;
  }
  unint64_t v64 = v55;
  uint64_t v65 = v56;
  uint64_t v55 = v57;
  HIDWORD(v56) = 0;
  uint64_t v47 = v57;
LABEL_91:
  LODWORD(v56) = 0;
LABEL_92:
  if (v47 != v57) {
    free(v47);
  }
  if (__src != v60) {
    free(__src);
  }
  uint64_t v49 = v64;
  uint64_t v43 = 1;
  if (v62 && v65)
  {
    char v50 = __dst;
    uint64_t v51 = 8 * v62 - 8;
    uint64_t v52 = 8 * v65 - 8;
    do
    {
      uint64_t v43 = a5(a6, *v50, *v49);
      if (!v43) {
        break;
      }
      if (!v51) {
        break;
      }
      ++v50;
      ++v49;
      v51 -= 8;
      uint64_t v53 = v52;
      v52 -= 8;
    }
    while (v53);
    uint64_t v49 = v64;
  }
  if (v49 != v66) {
    free(v49);
  }
  if (__dst != v63) {
    free(__dst);
  }
  return v43;
}

uint64_t mlir::detail::getNumDynamicEntriesUpToIdx(int64x2_t *a1, uint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  unint64_t v3 = (a3 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v3 < 7)
  {
    LODWORD(v4) = 0;
    unsigned int v5 = (uint64_t *)a1;
    do
    {
LABEL_8:
      uint64_t v18 = *v5++;
      if (v18 == 0x8000000000000000) {
        uint64_t v4 = (v4 + 1);
      }
      else {
        uint64_t v4 = v4;
      }
    }
    while (v5 != (uint64_t *)((char *)a1 + 8 * a3));
    return v4;
  }
  unint64_t v7 = v3 + 1;
  uint64_t v8 = (v3 + 1) & 0x3FFFFFFFFFFFFFF8;
  unsigned int v5 = &a1->i64[v8];
  BOOL v9 = a1 + 2;
  int32x4_t v10 = 0uLL;
  int64x2_t v11 = vdupq_n_s64(0x8000000000000000);
  uint64_t v12 = v8;
  int32x4_t v13 = 0uLL;
  do
  {
    int64x2_t v14 = v9[-2];
    int64x2_t v15 = v9[-1];
    int64x2_t v16 = *v9;
    int64x2_t v17 = v9[1];
    v9 += 4;
    int32x4_t v10 = vsubq_s32(v10, vuzp1q_s32((int32x4_t)vceqq_s64(v14, v11), (int32x4_t)vceqq_s64(v15, v11)));
    int32x4_t v13 = vsubq_s32(v13, vuzp1q_s32((int32x4_t)vceqq_s64(v16, v11), (int32x4_t)vceqq_s64(v17, v11)));
    v12 -= 8;
  }
  while (v12);
  uint64_t v4 = vaddvq_s32(vaddq_s32(v13, v10));
  if (v7 != v8) {
    goto LABEL_8;
  }
  return v4;
}

llvm::raw_ostream *mlir::printDynamicIndexList(mlir::OpAsmPrinter &,mlir::Operation *,mlir::OperandRange,llvm::ArrayRef<long long>,mlir::TypeRange,llvm::ArrayRef<BOOL>,mlir::AsmParser::Delimiter)::$_0::operator()(uint64_t a1, unint64_t a2)
{
  if (!*(void *)(*(void *)a1 + 8) || !*(unsigned char *)(**(void **)a1 + **(unsigned int **)(a1 + 8)))
  {
LABEL_5:
    uint64_t v6 = *(void *)(a1 + 16);
    if (a2 == 0x8000000000000000) {
      goto LABEL_6;
    }
LABEL_10:
    int64x2_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    uint64_t result = llvm::raw_ostream::operator<<(v11, a2);
    uint64_t v12 = *(void **)a1;
    if (!*(void *)(*(void *)a1 + 8)) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 91;
    ++*((void *)v4 + 4);
    goto LABEL_5;
  }
  llvm::raw_ostream::write(v4, "[", 1uLL);
  uint64_t v6 = *(void *)(a1 + 16);
  if (a2 != 0x8000000000000000) {
    goto LABEL_10;
  }
LABEL_6:
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 160))(v6, *(void *)(**(void **)(a1 + 24) + 32 * **(unsigned int **)(a1 + 32) + 24));
  if (*(void *)(*(void *)(a1 + 40) + 8))
  {
    uint64_t v8 = *(void *)(a1 + 16);
    BOOL v9 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    uint64_t v10 = *((void *)v9 + 4);
    if ((unint64_t)(*((void *)v9 + 3) - v10) > 2)
    {
      *(unsigned char *)(v10 + 2) = 32;
      *(_WORD *)uint64_t v10 = 14880;
      *((void *)v9 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v9, " : ", 3uLL);
    }
    unint64_t v13 = mlir::TypeRange::dereference_iterator(**(void **)(a1 + 40), **(unsigned int **)(a1 + 32));
    uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v8 + 32))(v8, v13);
  }
  ++**(_DWORD **)(a1 + 32);
  uint64_t v12 = *(void **)a1;
  if (*(void *)(*(void *)a1 + 8))
  {
LABEL_15:
    if (*(unsigned char *)(*v12 + **(unsigned int **)(a1 + 8)))
    {
      uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
      int64x2_t v14 = (unsigned char *)*((void *)result + 4);
      if (*((unsigned char **)result + 3) == v14)
      {
        uint64_t result = llvm::raw_ostream::write(result, "]", 1uLL);
      }
      else
      {
        unsigned char *v14 = 93;
        ++*((void *)result + 4);
      }
    }
  }
LABEL_19:
  ++**(_DWORD **)(a1 + 8);
  return result;
}

BOOL llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<mlir::parseDynamicIndexList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand> &,mlir::detail::DenseArrayAttrImpl<long long> &,mlir::detail::DenseArrayAttrImpl<BOOL> &,llvm::SmallVectorImpl<mlir::Type> *,mlir::AsmParser::Delimiter)::$_0>(uint64_t *a1)
{
  memset(v28, 0, 24);
  unsigned __int16 v2 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)*a1 + 680))(*a1, v28, 1);
  unint64_t v3 = (void *)a1[1];
  char v4 = (*(uint64_t (**)(void))(*(void *)*a1 + 304))();
  uint64_t v5 = v3[1];
  if ((unint64_t)(v5 + 1) > v3[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v3, v3 + 3, v5 + 1, 1);
    uint64_t v5 = v3[1];
  }
  *(unsigned char *)(*v3 + v5) = v4 != 0;
  ++v3[1];
  if (v2 < 0x100u || v2 == 0)
  {
    uint64_t v27 = 0;
    if (!mlir::AsmParser::parseInteger<long long>(*a1, &v27)) {
      return 0;
    }
    uint64_t v7 = a1[3];
    uint64_t v8 = v27;
    uint64_t v9 = *(unsigned int *)(v7 + 8);
    if (v9 >= *(_DWORD *)(v7 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1[3], (void *)(v7 + 16), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(v7 + 8);
    }
    *(void *)(*(void *)v7 + 8 * v9) = v8;
    ++*(_DWORD *)(v7 + 8);
  }
  else
  {
    uint64_t v10 = a1[2];
    uint64_t v11 = *(unsigned int *)(v10 + 8);
    unint64_t v12 = *(void *)v10;
    unint64_t v13 = (char *)v28;
    if (v11 >= *(_DWORD *)(v10 + 12))
    {
      unint64_t v24 = v11 + 1;
      BOOL v25 = v12 + 32 * v11 > (unint64_t)v28;
      if (v12 <= (unint64_t)v28 && v25)
      {
        int v26 = (char *)v28 - v12;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1[2], (void *)(v10 + 16), v24, 32);
        unint64_t v12 = *(void *)v10;
        unint64_t v13 = &v26[*(void *)v10];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1[2], (void *)(v10 + 16), v24, 32);
        unint64_t v12 = *(void *)v10;
        unint64_t v13 = (char *)v28;
      }
    }
    int64x2_t v14 = (_OWORD *)(v12 + 32 * *(unsigned int *)(v10 + 8));
    long long v15 = *((_OWORD *)v13 + 1);
    _OWORD *v14 = *(_OWORD *)v13;
    v14[1] = v15;
    ++*(_DWORD *)(v10 + 8);
    uint64_t v16 = a1[3];
    uint64_t v17 = *(unsigned int *)(v16 + 8);
    if (v17 >= *(_DWORD *)(v16 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1[3], (void *)(v16 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(v16 + 8);
    }
    *(void *)(*(void *)v16 + 8 * v17) = 0x8000000000000000;
    ++*(_DWORD *)(v16 + 8);
    uint64_t v18 = *(void *)a1[4];
    if (v18)
    {
      uint64_t v19 = *a1;
      uint64_t v20 = *(unsigned int *)(v18 + 8);
      if (v20 >= *(_DWORD *)(v18 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v18, (void *)(v18 + 16), v20 + 1, 8);
        *(void *)(*(void *)v18 + 8 * *(unsigned int *)(v18 + 8)) = 0;
        LODWORD(v20) = *(_DWORD *)(v18 + 8);
        uint64_t v21 = *(void *)v18;
      }
      else
      {
        uint64_t v21 = *(void *)v18;
        *(void *)(*(void *)v18 + 8 * v20) = 0;
      }
      unsigned int v22 = v20 + 1;
      *(_DWORD *)(v18 + 8) = v22;
      if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)v19 + 544))(v19, v21 + 8 * v22 - 8)) {
        return 0;
      }
    }
  }
  return !*(unsigned char *)(*(void *)a1[1] + *(void *)(a1[1] + 8) - 1)
      || (*(unsigned __int8 (**)(uint64_t))(*(void *)*a1 + 320))(*a1);
}

void mlir::MPSToANECOpCreator::MPSToANECOpCreator()
{
}

void std::make_unique[abi:nn180100]<mlir::ANECRegionOpCreator,mlir::OpBuilder &,mlir::ConversionTarget &,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family &,mlir::DeviceInfo *,llvm::StringLiteral,long long &,long long &,BOOL &,BOOL &,llvm::StringRef &,BOOL &>()
{
}

void mlir::createMPSToANECPass()
{
}

void mlir::createMPSToANECMinPass()
{
}

mlir::MPSToANECTypeConverter *mlir::MPSToANECTypeConverter::MPSToANECTypeConverter(mlir::MPSToANECTypeConverter *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  unsigned __int16 v2 = (char *)this + 232;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(void *)this = &unk_26C362018;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 0x400000000;
  *((void *)this + 19) = (char *)this + 168;
  *((_DWORD *)this + 41) = 2;
  *((void *)this + 29) = (char *)this + 248;
  *((_DWORD *)this + 61) = 2;
  *((void *)this + 39) = (char *)this + 328;
  *((_DWORD *)this + 81) = 2;
  *((void *)this + 49) = (char *)this + 408;
  *((_DWORD *)this + 101) = 2;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((mlir::MPSToANECTypeConverter *)((char *)this + 520));
  *((void *)this + 66) = 0;
  *(void *)this = &unk_26C362668;
  uint64_t v6 = (void (**)(void **))&unk_26C388720;
  uint64_t v7 = mlir::MPSToANECTypeConverter::canonicalizeType;
  uint64_t v8 = (void **)&v6;
  mlir::TypeConverter::registerConversion((unsigned int *)this, (uint64_t)&v6);
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_26C3886D8;
  uint64_t v7 = mlir::MPSToANECTypeConverter::tensorToMemRef;
  uint64_t v8 = (void **)&v6;
  mlir::TypeConverter::registerConversion((unsigned int *)this, (uint64_t)&v6);
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_26C388768;
  uint64_t v7 = mlir::MPSToANECTypeConverter::materializeTypeChange;
  uint64_t v8 = (void **)&v6;
  uint64_t v3 = *((unsigned int *)this + 60);
  if (v3 >= *((_DWORD *)this + 61))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>((uint64_t)v2, (uint64_t)&v6);
  }
  else
  {
    *(void *)(*((void *)this + 29) + 32 * v3 + 24) = *((void *)this + 29) + 32 * v3;
    (*((void (**)(void **))*v8 + 3))(v8);
    ++*((_DWORD *)this + 60);
  }
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  uint64_t v6 = (void (**)(void **))&unk_26C388768;
  uint64_t v7 = mlir::MPSToANECTypeConverter::materializeTypeChangeWithPromotion;
  uint64_t v8 = (void **)&v6;
  uint64_t v4 = *((unsigned int *)this + 80);
  if (v4 >= *((_DWORD *)this + 81))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>((uint64_t)this + 312, (uint64_t)&v6);
  }
  else
  {
    *(void *)(*((void *)this + 39) + 32 * v4 + 24) = *((void *)this + 39) + 32 * v4;
    (*((void (**)(void **))*v8 + 3))(v8);
    ++*((_DWORD *)this + 80);
  }
  if (v8 == (void **)&v6)
  {
    v6[4]((void **)&v6);
  }
  else if (v8)
  {
    (*((void (**)(void))*v8 + 5))();
  }
  return this;
}

uint64_t mlir::MPSToANECTypeConverter::canonicalizeType(uint64_t a1)
{
  if (*(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return mlir::MPSToANECTypeConverter::canonicalizeIntegerType(a1);
  }
  return a1;
}

uint64_t mlir::MPSToANECTypeConverter::tensorToMemRef(uint64_t a1)
{
  uint64_t v21 = a1;
  uint64_t ElementType = mlir::TensorType::getElementType((mlir::TensorType *)&v21);
  uint64_t v2 = ElementType;
  if (*(_UNKNOWN **)(*(void *)ElementType + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    uint64_t v2 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementType);
  }
  if (!mlir::TensorType::hasRank((mlir::TensorType *)&v21)) {
    return mlir::UnrankedMemRefType::get(v2, 0);
  }
  LOBYTE(v22[0]) = 0;
  char v23 = 0;
  uint64_t v3 = (uint64_t *)mlir::TensorType::cloneWith((uint64_t)&v21, (uint64_t)v22, v2);
  uint64_t v4 = (uint64_t)v3;
  if (!v3) {
    goto LABEL_13;
  }
  uint64_t v5 = *v3;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_13:
  }
    uint64_t v14 = 0;
  v22[0] = mlir::getRankPromotionTypeForANE(v4, v14);
  v22[1] = v15;
  Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v22);
  uint64_t v18 = v17;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22);
  return mlir::MemRefType::get(Shape, v18, OperandRange, 0, 0, 0);
}

char *mlir::MPSToANECTypeConverter::materializeTypeChange(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v10[2] = *MEMORY[0x263EF8340];
  uint64_t v9 = a2;
  v10[0] = a3;
  v10[1] = a4;
  uint64_t v8 = mlir::ValueRange::dereference_iterator(v10, 0);
  return (char *)mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(a1, a5, &v9, &v8)- 16;
}

char *mlir::MPSToANECTypeConverter::materializeTypeChangeWithPromotion(mlir::OpBuilder *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = (uint64_t)a2;
  v21[2] = *MEMORY[0x263EF8340];
  v21[0] = a3;
  v21[1] = a4;
  if (a2)
  {
    uint64_t v8 = *a2;
    unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v10 = *(unsigned int *)(v8 + 16);
    if (!v10) {
      goto LABEL_10;
    }
    uint64_t v11 = *(void **)(v8 + 8);
    unint64_t v12 = &v11[2 * v10];
    do
    {
      unint64_t v13 = v10 >> 1;
      uint64_t v14 = &v11[2 * (v10 >> 1)];
      unint64_t v16 = *v14;
      uint64_t v15 = v14 + 2;
      v10 += ~(v10 >> 1);
      if (v16 < v9) {
        uint64_t v11 = v15;
      }
      else {
        unint64_t v10 = v13;
      }
    }
    while (v10);
    if (v11 != v12 && *v11 == v9) {
      a2 = (uint64_t *)v11[1];
    }
    else {
LABEL_10:
    }
      a2 = 0;
  }
  v20[0] = mlir::getRankPromotionTypeForANE(v6, (uint64_t)a2);
  v20[1] = v17;
  uint64_t v19 = mlir::ValueRange::dereference_iterator(v21, 0);
  return (char *)mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(a1, a5, v20, &v19)- 16;
}

void mlir::MPSToANECTypeConverter::~MPSToANECTypeConverter(pthread_rwlock_t **this)
{
}

void sub_21190C848()
{
  JUMPOUT(0x21667D3C0);
}

void mlir::TypeConverter::~TypeConverter(pthread_rwlock_t **this)
{
}

{
  uint64_t v2;
  llvm *v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;

  *this = (pthread_rwlock_t *)&unk_26C362018;
  llvm::sys::RWMutexImpl::~RWMutexImpl(this + 65);
  uint64_t v2 = *((unsigned int *)this + 128);
  uint64_t v3 = (llvm *)this[62];
  if (v2)
  {
    uint64_t v4 = (char *)v3 + 24;
    uint64_t v5 = 40 * v2;
    do
    {
      if ((*((void *)v4 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = (char *)*((void *)v4 - 2);
        if (v4 != v6) {
          free(v6);
        }
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
    uint64_t v3 = (llvm *)this[62];
    unint64_t v7 = 40 * *((unsigned int *)this + 128);
  }
  else
  {
    unint64_t v7 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v7);
}

void sub_21190C884()
{
  JUMPOUT(0x21667D3C0);
}

void mlir::TypeConverter::registerConversion(unsigned int *a1, uint64_t a2)
{
  uint64_t v3 = a1 + 2;
  uint64_t v4 = a1[4];
  if (v4 >= a1[5])
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>((uint64_t)v3, a2);
    unsigned int v7 = a1[120];
    if (v7) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v5 = *v3 + 32 * v4;
    uint64_t v6 = *(void *)(a2 + 24);
    if (v6)
    {
      if (v6 == a2)
      {
        *(void *)(v5 + 24) = v5;
        (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v5);
        LODWORD(v4) = a1[4];
      }
      else
      {
        *(void *)(v5 + 24) = v6;
        *(void *)(a2 + 24) = 0;
      }
    }
    else
    {
      *(void *)(v5 + 24) = 0;
    }
    a1[4] = v4 + 1;
    unsigned int v7 = a1[120];
    if (v7) {
      goto LABEL_9;
    }
  }
  if (!a1[121]) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v8 = a1 + 118;
  uint64_t v9 = a1[122];
  if (v9 > 4 * v7 && v9 >= 0x41)
  {
    llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear((uint64_t)v8);
LABEL_12:
    unsigned int v10 = a1[126];
    if (v10) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (v9)
  {
    uint64_t v11 = (void *)*v8;
    uint64_t v12 = (v9 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v12)
    {
      uint64_t v13 = v12 + 1;
      uint64_t v14 = (v12 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v15 = &v11[2 * v14];
      unint64_t v16 = v11 + 2;
      uint64_t v17 = v14;
      do
      {
        *(v16 - 2) = -4096;
        void *v16 = -4096;
        v16 += 4;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v15 = (void *)*v8;
    }
    uint64_t v18 = &v11[2 * v9];
    do
    {
      void *v15 = -4096;
      v15 += 2;
    }
    while (v15 != v18);
  }
LABEL_23:
  *((void *)a1 + 60) = 0;
  unsigned int v10 = a1[126];
  if (v10) {
    goto LABEL_25;
  }
LABEL_24:
  if (!a1[127]) {
    return;
  }
LABEL_25:
  uint64_t v19 = a1 + 124;
  uint64_t v20 = a1[128];
  if (v20 <= 4 * v10 || v20 < 0x41)
  {
    if (!v20)
    {
LABEL_38:
      *((void *)a1 + 63) = 0;
      return;
    }
    uint64_t v21 = *v19 + 24;
    uint64_t v22 = 40 * v20;
    while (1)
    {
      uint64_t v23 = *(void *)(v21 - 24);
      if (v23 != -8192)
      {
        if (v23 == -4096) {
          goto LABEL_33;
        }
        unint64_t v24 = *(void **)(v21 - 16);
        if ((void *)v21 != v24) {
          free(v24);
        }
      }
      *(void *)(v21 - 24) = -4096;
LABEL_33:
      v21 += 40;
      v22 -= 40;
      if (!v22) {
        goto LABEL_38;
      }
    }
  }

  llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear((uint64_t)v19);
}

uint64_t llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>(uint64_t a1, uint64_t a2)
{
  unint64_t v20 = 0;
  uint64_t v4 = (void *)(a1 + 16);
  uint64_t v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v20);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  unsigned int v7 = &v5[32 * v6];
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    if (v8 == a2)
    {
      *((void *)v7 + 3) = v7;
      (*(void (**)(void))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24));
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
    else
    {
      *((void *)v7 + 3) = v8;
      *(void *)(a2 + 24) = 0;
      uint64_t v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    *((void *)v7 + 3) = 0;
    uint64_t v9 = *(void **)a1;
    if (!v6) {
      goto LABEL_23;
    }
  }
  uint64_t v10 = 32 * v6;
  uint64_t v11 = v5;
  do
  {
    uint64_t v12 = (void *)v9[3];
    if (v12)
    {
      if (v9 == v12)
      {
        *((void *)v11 + 3) = v11;
        (*(void (**)(void, char *))(*(void *)v9[3] + 24))(v9[3], v11);
      }
      else
      {
        *((void *)v11 + 3) = v12;
        v9[3] = 0;
      }
    }
    else
    {
      *((void *)v11 + 3) = 0;
    }
    v11 += 32;
    v9 += 4;
    v10 -= 32;
  }
  while (v10);
  uint64_t v9 = *(void **)a1;
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13)
  {
    uint64_t v14 = 4 * v13;
    uint64_t v15 = v9 - 4;
    do
    {
      unint64_t v16 = (void *)v15[v14 + 3];
      if (&v15[v14] == v16)
      {
        (*(void (**)(void *))(v15[v14] + 32))(&v15[v14]);
      }
      else if (v16)
      {
        (*(void (**)(void *))(*v16 + 40))(v16);
      }
      v14 -= 4;
    }
    while (v14 * 8);
    uint64_t v9 = *(void **)a1;
  }
LABEL_23:
  int v17 = v20;
  if (v9 != v4) {
    free(v9);
  }
  *(void *)a1 = v5;
  uint64_t v18 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v18;
  *(_DWORD *)(a1 + 12) = v17;
  return (uint64_t)&v5[32 * v18 - 32];
}

uint64_t llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(16 * v1));
  }
  *(void *)(result + 8) = 0;
  if (v1)
  {
    uint64_t v5 = *(llvm **)result;
    uint64_t v6 = (v1 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      uint64_t v7 = v6 + 1;
      uint64_t v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      uint64_t v9 = (llvm *)((char *)v5 + 16 * v8);
      uint64_t v10 = (void *)((char *)v5 + 16);
      uint64_t v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        void *v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8) {
        return result;
      }
    }
    else
    {
      uint64_t v9 = *(llvm **)result;
    }
    uint64_t v12 = (llvm *)((char *)v5 + 16 * v1);
    do
    {
      *(void *)uint64_t v9 = -4096;
      uint64_t v9 = (llvm *)((char *)v9 + 16);
    }
    while (v9 != v12);
  }
  return result;
}

void llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = *(void *)a1 + 24;
    uint64_t v5 = 40 * v2;
    do
    {
      if ((*(void *)(v4 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = *(void **)(v4 - 16);
        if ((void *)v4 != v6) {
          free(v6);
        }
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  int v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64) {
    int v7 = 64;
  }
  if (v3) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v8 != *(_DWORD *)(a1 + 16)) {
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(40 * v2));
  }
  *(void *)(a1 + 8) = 0;
  if (v8)
  {
    uint64_t v9 = *(llvm **)a1;
    unint64_t v10 = 40 * v8 - 40;
    if (v10 < 0x28)
    {
      uint64_t v11 = *(llvm **)a1;
LABEL_20:
      uint64_t v15 = (llvm *)((char *)v9 + 40 * v8);
      do
      {
        *(void *)uint64_t v11 = -4096;
        uint64_t v11 = (llvm *)((char *)v11 + 40);
      }
      while (v11 != v15);
      return;
    }
    unint64_t v12 = v10 / 0x28 + 1;
    uint64_t v11 = (llvm *)((char *)v9 + 40 * (v12 & 0xFFFFFFFFFFFFFFELL));
    uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFELL;
    uint64_t v14 = *(llvm **)a1;
    do
    {
      *(void *)uint64_t v14 = -4096;
      *((void *)v14 + 5) = -4096;
      uint64_t v14 = (llvm *)((char *)v14 + 80);
      v13 -= 2;
    }
    while (v13);
    if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL)) {
      goto LABEL_20;
    }
  }
}

void _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_PFS5_S5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSA_EUlS5_SJ_E_EENS9_IXsr3stdE14is_invocable_vISA_SB_SJ_EESL_E4typeESO_EUlS5_SJ_E_NS_9allocatorISS_EESK_ED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_PFS5_S5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSA_EUlS5_SJ_E_EENS9_IXsr3stdE14is_invocable_vISA_SB_SJ_EESL_E4typeESO_EUlS5_SJ_E_NS_9allocatorISS_EESK_E7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26C388720;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_PFS5_S5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSA_EUlS5_SJ_E_EENS9_IXsr3stdE14is_invocable_vISA_SB_SJ_EESL_E4typeESO_EUlS5_SJ_E_NS_9allocatorISS_EESK_E7__cloneEPNS0_6__baseISK_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C388720;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_PFS5_S5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSA_EUlS5_SJ_E_EENS9_IXsr3stdE14is_invocable_vISA_SB_SJ_EESL_E4typeESO_EUlS5_SJ_E_NS_9allocatorISS_EESK_EclEOS5_SJ_(uint64_t a1, void *a2, uint64_t a3)
{
  if (*a2)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(a1 + 8))();
    if (v4)
    {
      uint64_t v5 = *(unsigned int *)(a3 + 8);
      if (v5 >= *(_DWORD *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v5 + 1, 8);
        LODWORD(v5) = *(_DWORD *)(a3 + 8);
      }
      *(void *)(*(void *)a3 + 8 * v5) = v4;
      ++*(_DWORD *)(a3 + 8);
    }
    BOOL v6 = v4 != 0;
    int v7 = 1;
  }
  else
  {
    BOOL v6 = 0;
    int v7 = 0;
  }
  return v6 | (v7 << 8);
}

uint64_t mlir::MPSToANECTypeConverter::canonicalizeIntegerType(uint64_t a1)
{
  uint64_t v5 = a1;
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v5) > 7)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v5)) {
      return v5;
    }
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v5);
    unsigned int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v5);
    uint64_t v1 = Context;
  }
  else
  {
    uint64_t v1 = mlir::Attribute::getContext((mlir::Attribute *)&v5);
    unsigned int Width = 8;
  }
  return mlir::IntegerType::get(v1, Width, 1u);
}

void _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_10TensorTypeEZNKS3_12wrapCallbackIS5_PFNS_8optionalINS2_4TypeEEES5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS7_INS2_13LogicalResultEEES8_RN4llvm15SmallVectorImplIS8_EEEEEE4typeEOSD_EUlS5_SL_E_EENSC_IXsr3stdE14is_invocable_vISD_SE_SL_EESN_E4typeESQ_EUlS8_SL_E_NS_9allocatorISU_EESM_ED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_10TensorTypeEZNKS3_12wrapCallbackIS5_PFNS_8optionalINS2_4TypeEEES5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS7_INS2_13LogicalResultEEES8_RN4llvm15SmallVectorImplIS8_EEEEEE4typeEOSD_EUlS5_SL_E_EENSC_IXsr3stdE14is_invocable_vISD_SE_SL_EESN_E4typeESQ_EUlS8_SL_E_NS_9allocatorISU_EESM_E7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26C3886D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_10TensorTypeEZNKS3_12wrapCallbackIS5_PFNS_8optionalINS2_4TypeEEES5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS7_INS2_13LogicalResultEEES8_RN4llvm15SmallVectorImplIS8_EEEEEE4typeEOSD_EUlS5_SL_E_EENSC_IXsr3stdE14is_invocable_vISD_SE_SL_EESN_E4typeESQ_EUlS8_SL_E_NS_9allocatorISU_EESM_E7__cloneEPNS0_6__baseISM_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C3886D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_10TensorTypeEZNKS3_12wrapCallbackIS5_PFNS_8optionalINS2_4TypeEEES5_EEENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS7_INS2_13LogicalResultEEES8_RN4llvm15SmallVectorImplIS8_EEEEEE4typeEOSD_EUlS5_SL_E_EENSC_IXsr3stdE14is_invocable_vISD_SE_SL_EESN_E4typeESQ_EUlS8_SL_E_NS_9allocatorISU_EESM_EclEOS8_SL_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(**(void **)a2 + 136);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v3 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v4 && (uint64_t v6 = (*(uint64_t (**)(void))(a1 + 8))(), v7))
  {
    if (v6)
    {
      uint64_t v8 = *(unsigned int *)(a3 + 8);
      if (v8 >= *(_DWORD *)(a3 + 12))
      {
        uint64_t v12 = v6;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v8 + 1, 8);
        uint64_t v6 = v12;
        LODWORD(v8) = *(_DWORD *)(a3 + 8);
      }
      *(void *)(*(void *)a3 + 8 * v8) = v6;
      ++*(_DWORD *)(a3 + 8);
    }
    BOOL v9 = v6 != 0;
    int v10 = 1;
  }
  else
  {
    BOOL v9 = 0;
    int v10 = 0;
  }
  return v9 | (v10 << 8);
}

uint64_t llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>(uint64_t a1, uint64_t a2)
{
  unint64_t v20 = 0;
  BOOL v4 = (void *)(a1 + 16);
  uint64_t v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v20);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  char v7 = &v5[32 * v6];
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8)
  {
    if (v8 == a2)
    {
      *((void *)v7 + 3) = v7;
      (*(void (**)(void))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24));
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      BOOL v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
    else
    {
      *((void *)v7 + 3) = v8;
      *(void *)(a2 + 24) = 0;
      BOOL v9 = *(void **)a1;
      if (!v6) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    *((void *)v7 + 3) = 0;
    BOOL v9 = *(void **)a1;
    if (!v6) {
      goto LABEL_23;
    }
  }
  uint64_t v10 = 32 * v6;
  uint64_t v11 = v5;
  do
  {
    uint64_t v12 = (void *)v9[3];
    if (v12)
    {
      if (v9 == v12)
      {
        *((void *)v11 + 3) = v11;
        (*(void (**)(void, char *))(*(void *)v9[3] + 24))(v9[3], v11);
      }
      else
      {
        *((void *)v11 + 3) = v12;
        v9[3] = 0;
      }
    }
    else
    {
      *((void *)v11 + 3) = 0;
    }
    v11 += 32;
    v9 += 4;
    v10 -= 32;
  }
  while (v10);
  BOOL v9 = *(void **)a1;
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13)
  {
    uint64_t v14 = 4 * v13;
    uint64_t v15 = v9 - 4;
    do
    {
      unint64_t v16 = (void *)v15[v14 + 3];
      if (&v15[v14] == v16)
      {
        (*(void (**)(void *))(v15[v14] + 32))(&v15[v14]);
      }
      else if (v16)
      {
        (*(void (**)(void *))(*v16 + 40))(v16);
      }
      v14 -= 4;
    }
    while (v14 * 8);
    BOOL v9 = *(void **)a1;
  }
LABEL_23:
  int v17 = v20;
  if (v9 != v4) {
    free(v9);
  }
  *(void *)a1 = v5;
  uint64_t v18 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v18;
  *(_DWORD *)(a1 + 12) = v17;
  return (uint64_t)&v5[32 * v18 - 32];
}

void std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::~__func()
{
}

void *std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26C388768;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C388768;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::operator()(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  if (*a3) {
    return (*(uint64_t (**)(uint64_t, void, void, void, void))(a1 + 8))(a2, *a3, *a4, a4[1], *a5);
  }
  else {
    return 0;
  }
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::UnrealizedConversionCast,mlir::Type &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.unrealized_conversion_cast", (const unsigned __int8 *)0x1F, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"anec.unrealized_conversion_cast";
    v17[3] = 31;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::UnrealizedConversionCast,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_26C38C9E8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EE7__cloneEPNS0_6__baseISR_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26C38C9E8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_18MPSToANECOpCreatorC1EPNS2_11MLIRContextENS2_4anec6FamilyEbbbbbbbbjxxN4llvm9StringRefEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSG_EUlSI_E_NS_9allocatorISM_EEFNS_8optionalIbEESI_EEclEOSI_(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    unint64_t v2 = 0;
  }
  unint64_t v5 = v2;
  if (v2)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
    LODWORD(v2) = v3 > 3;
  }
  return v2 | 0x100;
}

uint64_t llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    BOOL v4 = *(char **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      llvm::SmallVectorImpl<std::unique_ptr<mlir::PDLPatternConfigSet>>::assignRemote((char **)a1, (char **)a2);
      return a1;
    }
    unint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6 >= v5)
    {
      __int16 v16 = *(char **)a1;
      if (v5)
      {
        int v17 = &v4[8 * v5];
        do
        {
          uint64_t v18 = *(void *)v4;
          *(void *)BOOL v4 = 0;
          uint64_t v19 = *(char ***)v16;
          *(void *)__int16 v16 = v18;
          if (v19)
          {
            unint64_t v20 = *v19;
            uint64_t v21 = *((unsigned int *)v19 + 2);
            if (v21)
            {
              uint64_t v22 = 8 * v21;
              uint64_t v23 = v20 - 8;
              do
              {
                uint64_t v24 = *(void *)&v23[v22];
                *(void *)&v23[v22] = 0;
                if (v24) {
                  (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
                }
                v22 -= 8;
              }
              while (v22);
              unint64_t v20 = *v19;
            }
            if (v20 != (char *)(v19 + 2)) {
              free(v20);
            }
            MEMORY[0x21667D3C0](v19, 0x1080C407559D7D1);
          }
          v4 += 8;
          v16 += 8;
        }
        while (v4 != v17);
        BOOL v25 = v16;
        __int16 v16 = *(char **)a1;
        uint64_t v6 = *(unsigned int *)(a1 + 8);
      }
      else
      {
        BOOL v25 = *(char **)a1;
      }
      uint64_t v62 = &v16[8 * v6];
      while (v62 != v25)
      {
        unint64_t v64 = (char **)*((void *)v62 - 1);
        v62 -= 8;
        long long v63 = v64;
        *(void *)uint64_t v62 = 0;
        if (v64)
        {
          uint64_t v65 = *v63;
          uint64_t v66 = *((unsigned int *)v63 + 2);
          if (v66)
          {
            uint64_t v67 = 8 * v66;
            uint64_t v68 = v65 - 8;
            do
            {
              uint64_t v69 = *(void *)&v68[v67];
              *(void *)&v68[v67] = 0;
              if (v69) {
                (*(void (**)(uint64_t))(*(void *)v69 + 8))(v69);
              }
              v67 -= 8;
            }
            while (v67);
            uint64_t v65 = *v63;
          }
          if (v65 != (char *)(v63 + 2)) {
            free(v65);
          }
          MEMORY[0x21667D3C0](v63, 0x1080C407559D7D1);
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
      uint64_t v70 = *(unsigned int *)(a2 + 8);
      if (v70)
      {
        unint64_t v71 = *(char **)a2;
        unint64_t v72 = (char *)(*(void *)a2 + 8 * v70);
        do
        {
          long long v74 = (char **)*((void *)v72 - 1);
          v72 -= 8;
          BOOL v73 = v74;
          *(void *)unint64_t v72 = 0;
          if (v74)
          {
            uint64_t v75 = *v73;
            uint64_t v76 = *((unsigned int *)v73 + 2);
            if (v76)
            {
              uint64_t v77 = 8 * v76;
              unint64_t v78 = v75 - 8;
              do
              {
                uint64_t v79 = *(void *)&v78[v77];
                *(void *)&v78[v77] = 0;
                if (v79) {
                  (*(void (**)(uint64_t))(*(void *)v79 + 8))(v79);
                }
                v77 -= 8;
              }
              while (v77);
              uint64_t v75 = *v73;
            }
            if (v75 != (char *)(v73 + 2)) {
              free(v75);
            }
            MEMORY[0x21667D3C0](v73, 0x1080C407559D7D1);
          }
        }
        while (v72 != v71);
      }
      goto LABEL_97;
    }
    if (*(_DWORD *)(a1 + 12) >= v5)
    {
      if (v6)
      {
        int v26 = &v4[8 * v6];
        uint64_t v27 = *(char **)a1;
        do
        {
          uint64_t v28 = *(void *)v4;
          *(void *)BOOL v4 = 0;
          uint64_t v29 = *(char ***)v27;
          *(void *)uint64_t v27 = v28;
          if (v29)
          {
            uint64_t v30 = *v29;
            uint64_t v31 = *((unsigned int *)v29 + 2);
            if (v31)
            {
              uint64_t v32 = 8 * v31;
              int v33 = v30 - 8;
              do
              {
                uint64_t v34 = *(void *)&v33[v32];
                *(void *)&v33[v32] = 0;
                if (v34) {
                  (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
                }
                v32 -= 8;
              }
              while (v32);
              uint64_t v30 = *v29;
            }
            if (v30 != (char *)(v29 + 2)) {
              free(v30);
            }
            MEMORY[0x21667D3C0](v29, 0x1080C407559D7D1);
          }
          v4 += 8;
          v27 += 8;
        }
        while (v4 != v26);
        goto LABEL_48;
      }
    }
    else
    {
      if (v6)
      {
        char v7 = *(char **)a1;
        uint64_t v8 = (char *)(*(void *)a1 + 8 * v6);
        do
        {
          char v10 = (char **)*((void *)v8 - 1);
          v8 -= 8;
          uint64_t v9 = v10;
          *(void *)uint64_t v8 = 0;
          if (v10)
          {
            uint64_t v11 = *v9;
            uint64_t v12 = *((unsigned int *)v9 + 2);
            if (v12)
            {
              uint64_t v13 = 8 * v12;
              uint64_t v14 = v11 - 8;
              do
              {
                uint64_t v15 = *(void *)&v14[v13];
                *(void *)&v14[v13] = 0;
                if (v15) {
                  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
                }
                v13 -= 8;
              }
              while (v13);
              uint64_t v11 = *v9;
            }
            if (v11 != (char *)(v9 + 2)) {
              free(v11);
            }
            MEMORY[0x21667D3C0](v9, 0x1080C407559D7D1);
          }
        }
        while (v8 != v7);
      }
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::PDLPatternConfigSet>,false>::grow(a1, v5);
    }
    uint64_t v6 = 0;
LABEL_48:
    uint64_t v35 = *(char **)a2;
    uint64_t v36 = *(unsigned int *)(a2 + 8);
    if (v6 != v36)
    {
      int v37 = *(char **)a1;
      uint64_t v38 = 8 * v6;
      uint64_t v39 = (char *)(*(void *)a1 + 8 * v6);
      uint64_t v40 = &v35[8 * v6];
      uint64_t v41 = 8 * v36;
      unint64_t v42 = 8 * v36 - 8 * v6 - 8;
      if (v42 < 0x78 || v40 < &v37[v41] && v39 < &v35[v41]) {
        goto LABEL_55;
      }
      uint64_t v43 = (v42 >> 3) + 1;
      uint64_t v44 = 8 * (v43 & 0x3FFFFFFFFFFFFFFCLL);
      v39 += v44;
      v40 += v44;
      uint64_t v45 = v38 + 16;
      int v46 = &v35[v38 + 16];
      uint64_t v47 = &v37[v45];
      uint64_t v48 = v43 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v49 = *((_OWORD *)v46 - 1);
        long long v50 = *(_OWORD *)v46;
        *((_OWORD *)v46 - 1) = 0uLL;
        *(_OWORD *)int v46 = 0uLL;
        *((_OWORD *)v47 - 1) = v49;
        *(_OWORD *)uint64_t v47 = v50;
        v46 += 32;
        v47 += 32;
        v48 -= 4;
      }
      while (v48);
      if (v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_55:
        uint64_t v51 = &v35[8 * v36];
        do
        {
          uint64_t v52 = *(void *)v40;
          *(void *)uint64_t v40 = 0;
          v40 += 8;
          *(void *)uint64_t v39 = v52;
          v39 += 8;
        }
        while (v40 != v51);
      }
      uint64_t v35 = *(char **)a2;
    }
    *(_DWORD *)(a1 + 8) = v5;
    uint64_t v53 = *(unsigned int *)(a2 + 8);
    if (v53)
    {
      long long v54 = &v35[8 * v53];
      do
      {
        uint64_t v56 = (char **)*((void *)v54 - 1);
        v54 -= 8;
        uint64_t v55 = v56;
        *(void *)long long v54 = 0;
        if (v56)
        {
          char v57 = *v55;
          uint64_t v58 = *((unsigned int *)v55 + 2);
          if (v58)
          {
            uint64_t v59 = 8 * v58;
            uint64_t v60 = v57 - 8;
            do
            {
              uint64_t v61 = *(void *)&v60[v59];
              *(void *)&v60[v59] = 0;
              if (v61) {
                (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
              }
              v59 -= 8;
            }
            while (v59);
            char v57 = *v55;
          }
          if (v57 != (char *)(v55 + 2)) {
            free(v57);
          }
          MEMORY[0x21667D3C0](v55, 0x1080C407559D7D1);
        }
      }
      while (v54 != v35);
    }
LABEL_97:
    *(_DWORD *)(a2 + 8) = 0;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::PDLPatternConfigSet>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v30 = 0;
  uint64_t v3 = (uint64_t *)(a1 + 16);
  BOOL v4 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 8, &v30);
  unint64_t v5 = *(void *)a1;
  uint64_t v6 = *(uint64_t **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (!v7) {
    goto LABEL_27;
  }
  unint64_t v8 = (v7 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v8 < 0xB)
  {
    uint64_t v9 = v4;
LABEL_12:
    uint64_t v18 = (uint64_t *)(v5 + 8 * v7);
    do
    {
      uint64_t v19 = *v6;
      *v6++ = 0;
      *(void *)uint64_t v9 = v19;
      v9 += 8;
    }
    while (v6 != v18);
    goto LABEL_14;
  }
  BOOL v10 = v5 >= (unint64_t)&v4[8 * v7] || (unint64_t)v4 >= v5 + 8 * v7;
  uint64_t v9 = v4;
  if (!v10) {
    goto LABEL_12;
  }
  unint64_t v11 = v8 + 1;
  uint64_t v12 = 8 * (v11 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v9 = &v4[v12];
  uint64_t v6 = (uint64_t *)(v5 + v12);
  uint64_t v13 = (long long *)(v5 + 16);
  uint64_t v14 = v4 + 16;
  uint64_t v15 = v11 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v16 = *(v13 - 1);
    long long v17 = *v13;
    *(v13 - 1) = 0uLL;
    long long *v13 = 0uLL;
    *(v14 - 1) = v16;
    _OWORD *v14 = v17;
    v13 += 2;
    v14 += 2;
    v15 -= 4;
  }
  while (v15);
  if (v11 != (v11 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_12;
  }
LABEL_14:
  unint64_t v20 = *(void **)a1;
  uint64_t v21 = (void *)(*(void *)a1 + 8 * v7);
  do
  {
    uint64_t v23 = (char **)*--v21;
    uint64_t v22 = v23;
    *uint64_t v21 = 0;
    if (v23)
    {
      uint64_t v24 = *v22;
      uint64_t v25 = *((unsigned int *)v22 + 2);
      if (v25)
      {
        uint64_t v26 = 8 * v25;
        uint64_t v27 = v24 - 8;
        do
        {
          uint64_t v28 = *(void *)&v27[v26];
          *(void *)&v27[v26] = 0;
          if (v28) {
            (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
          }
          v26 -= 8;
        }
        while (v26);
        uint64_t v24 = *v22;
      }
      if (v24 != (char *)(v22 + 2)) {
        free(v24);
      }
      MEMORY[0x21667D3C0](v22, 0x1080C407559D7D1);
    }
  }
  while (v21 != v20);
  uint64_t v6 = *(uint64_t **)a1;
LABEL_27:
  int v29 = v30;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v29;
}

void mlir::ANECRegionOpCreator::ANECRegionOpCreator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a11;
  *(void *)(a1 + 24) = a12;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)a1 = &unk_26C362518;
  mlir::ConversionTarget::ConversionTarget(a1 + 40);
}

uint64_t sub_21190E3D4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  *(void *)(v32 + 200) = v33;
  mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v32 + 208, v38, 0, 0, 0, 0);
  *(void *)(v32 + 224) = &unk_26C37DA70;
  *(void *)(v32 + 232) = v35;
  *(void *)(v32 + 240) = v41;
  *(_DWORD *)(v32 + 248) = v37;
  *(unsigned char *)(v32 + 252) = v40;
  *(unsigned char *)(v32 + 253) = v39;
  *(void *)(v32 + 256) = v49;
  if (v36 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  int v43 = v37;
  char v44 = *(unsigned char *)(v42 + 72);
  if (v36 >= 0x17)
  {
    uint64_t v46 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v46 = v36 | 7;
    }
    uint64_t v47 = v46 + 1;
    uint64_t v45 = operator new(v46 + 1);
    *(void *)(v32 + 272) = v36;
    *(void *)(v32 + 280) = v47 | 0x8000000000000000;
    *(void *)(v32 + 264) = v45;
    goto LABEL_8;
  }
  uint64_t v45 = (void *)(v32 + 264);
  *(unsigned char *)(v32 + 287) = v36;
  if (v36) {
LABEL_8:
  }
    memmove(v45, *(const void **)(v42 + 56), v36);
  *((unsigned char *)v45 + v36) = 0;
  *(unsigned char *)(v32 + 288) = v44;
  long long v50 = (void (**)(void **))&unk_26C387570;
  int v51 = v43;
  uint64_t v52 = (void **)&v50;
  uint64_t v53 = v55;
  v55[0] = "anec";
  v55[1] = 4;
  uint64_t v54 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v34, (uint64_t)v55, 1, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v34, (uint64_t)v53, v54, &v50);
  if (v53 != v55) {
    free(v53);
  }
  if (v52 == (void **)&v50)
  {
    v50[4]((void **)&v50);
  }
  else if (v52)
  {
    (*((void (**)(void))*v52 + 5))();
  }
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A12,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A12)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A13,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A13)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A14,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A14)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A15,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A15)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A16,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A16)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A17,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A17)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A11Legacy,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A11Legacy)#1}>((uint64_t)v34, (uint64_t *)&v53);
  uint64_t v53 = v33;
  mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::RegionReturn,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::RegionReturn)#1}>((uint64_t)v34, (uint64_t *)&v53);
  mlir::OperationName::OperationName(&v53, "anec.unrealized_conversion_cast", 31, *(void *)(v32 + 192));
  mlir::ConversionTarget::setOpAction((uint64_t)v34, (uint64_t)v53, 2);
  return v32;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A12,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A12)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C3873C0;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A12", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A13,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A13)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C387408;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A13", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A14,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A14)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C387450;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A14", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A15,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A15)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C387498;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A15", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A16,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A16)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C3874E0;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A16", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A17,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A17)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C323288;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A17", 8, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::A11Legacy,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::A11Legacy)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C387528;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.A11Legacy", 14, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

uint64_t mlir::ConversionTarget::addDynamicallyLegalOp<mlir::anec::RegionReturn,mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::anec::RegionReturn)#1}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  v7[0] = &unk_26C387378;
  v7[1] = v3;
  unint64_t v8 = v7;
  mlir::OperationName::OperationName(&v6, "anec.region_return", 18, *(void *)(a1 + 152));
  uint64_t v4 = v6;
  mlir::ConversionTarget::setOpAction(a1, v6, 1);
  mlir::ConversionTarget::setLegalityCallback(a1, v4, v7);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void mlir::ConversionTarget::ConversionTarget(uint64_t a1)
{
  *(void *)a1 = &unk_26C3620B8;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  llvm::deallocate_buffer(0, 0);
}

void sub_21190EFCC()
{
  uint64_t v3 = *(unsigned int *)(v1 + 24);
  *(_DWORD *)(v0 + 24) = v3;
  if (v3)
  {
    buffer = llvm::allocate_buffer(16 * v3, (std::align_val_t)8uLL);
    *(void *)(v0 + 8) = buffer;
    *(void *)(v0 + 16) = *(void *)(v1 + 16);
    memcpy(buffer, *(const void **)(v1 + 8), 16 * *(unsigned int *)(v0 + 24));
  }
  else
  {
    void *v2 = 0;
    v2[1] = 0;
  }
  *(void *)(v0 + 32) = v0 + 48;
  *(void *)(v0 + 40) = 0;
  if (*(_DWORD *)(v1 + 40)) {
    llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=((unsigned int *)(v0 + 32), v1 + 32);
  }
  *(void *)(v0 + 48) = 0;
  *(void *)(v0 + 56) = 0;
  *(_DWORD *)(v0 + 64) = 0;
  llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(v0 + 48);
}

void *sub_21190F038()
{
  llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 9), v1 + 9);
  llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 12), v1 + 12);
  unint64_t v2 = (uint64_t *)v1[18];
  if (v2)
  {
    if (v2 == v1 + 15)
    {
      v0[18] = v0 + 15;
      (*(void (**)(uint64_t))(*(void *)v1[18] + 24))(v1[18]);
    }
    else
    {
      v0[18] = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
    }
  }
  else
  {
    v0[18] = 0;
  }
  v0[19] = v1[19];
  return v0;
}

unsigned int *llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=(unsigned int *a1, uint64_t a2)
{
  if (a1 != (unsigned int *)a2)
  {
    unint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = a1[2];
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v9 = *(void *)a2;
        uint64_t v10 = *(void *)a1;
        uint64_t v11 = 48 * v4;
        do
        {
          std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100](v10, v9);
          v9 += 48;
          v10 += 48;
          v11 -= 48;
        }
        while (v11);
        uint64_t v12 = *(void *)a1;
        LODWORD(v5) = a1[2];
      }
      else
      {
        uint64_t v12 = *(void *)a1;
        uint64_t v10 = *(void *)a1;
      }
      if (v12 + 48 * v5 != v10)
      {
        uint64_t v17 = v12 + 48 * v5 - 32;
        uint64_t v18 = (void *)v17;
        do
        {
          unint64_t v20 = (void *)v18[3];
          if (v18 == v20)
          {
            (*(void (**)(void *))(*v18 + 32))(v18);
          }
          else if (v20)
          {
            (*(void (**)(void *))(*v20 + 40))(v20);
          }
          uint64_t v19 = v18 - 2;
          v18 -= 6;
          v17 -= 48;
        }
        while (v19 != (void *)v10);
      }
    }
    else
    {
      if (a1[3] >= v4)
      {
        uint64_t v13 = *(char **)a1;
        if (v5)
        {
          uint64_t v14 = *(void *)a2;
          uint64_t v15 = 48 * v5;
          do
          {
            std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100]((uint64_t)v13, v14);
            v14 += 48;
            v13 += 48;
            v15 -= 48;
          }
          while (v15);
          uint64_t v13 = *(char **)a1;
        }
        else
        {
          uint64_t v5 = 0;
        }
      }
      else
      {
        if (v5)
        {
          uint64_t v6 = 48 * v5;
          uint64_t v7 = *(void *)a1 - 32;
          do
          {
            uint64_t v8 = *(void *)(v7 + v6 + 24);
            if (v7 + v6 == v8)
            {
              (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
            }
            else if (v8)
            {
              (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
            }
            v6 -= 48;
          }
          while (v6);
        }
        a1[2] = 0;
        unint64_t v30 = 0;
        uint64_t v13 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)a1, a1 + 4, v4, 48, &v30);
        llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::moveElementsForGrow(a1, (uint64_t)v13);
        unsigned int v16 = v30;
        if (*(unsigned int **)a1 != a1 + 4) {
          free(*(void **)a1);
        }
        uint64_t v5 = 0;
        *(void *)a1 = v13;
        a1[3] = v16;
      }
      uint64_t v21 = *(unsigned int *)(a2 + 8);
      if (v5 != v21)
      {
        uint64_t v23 = *(void *)a2;
        uint64_t v24 = 48 * v5;
        uint64_t v25 = 48 * v21;
        do
        {
          uint64_t v26 = &v13[v24];
          uint64_t v27 = v23 + v24;
          *(void *)uint64_t v26 = *(void *)(v23 + v24);
          int v28 = *(_DWORD *)(v23 + v24 + 8);
          v26[12] = *(unsigned char *)(v23 + v24 + 12);
          *((_DWORD *)v26 + 2) = v28;
          uint64_t v29 = *(void *)(v23 + v24 + 40);
          if (v29)
          {
            if (v27 + 16 == v29)
            {
              *(void *)&v13[v24 + 40] = v26 + 16;
              (*(void (**)(void))(**(void **)(v27 + 40) + 24))(*(void *)(v27 + 40));
            }
            else
            {
              *(void *)&v13[v24 + 40] = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
            }
          }
          else
          {
            *((void *)v26 + 5) = 0;
          }
          v13 += 48;
          v25 -= 48;
          v23 += 48;
        }
        while (v24 != v25);
      }
    }
    a1[2] = v4;
  }
  return a1;
}

uint64_t std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>::operator=[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *(void *)a1 = *(void *)a2;
  int v3 = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v3;
  unint64_t v4 = (void *)(a1 + 16);
  uint64_t v5 = *(void *)(a2 + 40);
  if (v5)
  {
    if (v5 == a2 + 16)
    {
      uint64_t v8 = v7;
      (*(void (**)(uint64_t, void *))(*(void *)(a2 + 16) + 24))(a2 + 16, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  std::__function::__value_func<std::optional<BOOL> ()(mlir::Operation *)>::swap[abi:nn180100](v7, v4);
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  return a1;
}

unsigned int *llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::moveElementsForGrow(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2)
  {
    int v3 = result;
    unint64_t v4 = (void *)(a2 + 40);
    uint64_t v5 = 48 * v2;
    uint64_t v6 = *(void *)result + 40;
    do
    {
      *(v4 - 5) = *(void *)(v6 - 40);
      int v7 = *(_DWORD *)(v6 - 32);
      *((unsigned char *)v4 - 28) = *(unsigned char *)(v6 - 28);
      *((_DWORD *)v4 - 8) = v7;
      uint64_t v8 = *(void *)v6;
      if (*(void *)v6)
      {
        if (v6 - 24 == v8)
        {
          void *v4 = v4 - 3;
          uint64_t result = (unsigned int *)(*(uint64_t (**)(void))(**(void **)v6 + 24))();
        }
        else
        {
          void *v4 = v8;
          *(void *)uint64_t v6 = 0;
        }
      }
      else
      {
        void *v4 = 0;
      }
      v4 += 6;
      v6 += 48;
      v5 -= 48;
    }
    while (v5);
    uint64_t v9 = v3[2];
    if (v9)
    {
      uint64_t v10 = *(void *)v3;
      uint64_t v11 = 48 * v9;
      uint64_t v12 = v10 - 32;
      do
      {
        uint64_t result = *(unsigned int **)(v12 + v11 + 24);
        if ((unsigned int *)(v12 + v11) == result)
        {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)(v12 + v11) + 32))(v12 + v11);
        }
        else if (result)
        {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 40))(result);
        }
        v11 -= 48;
      }
      while (v11);
    }
  }
  return result;
}

void llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(llvm **)a1;
  if (v2)
  {
    unint64_t v4 = (void *)((char *)v3 + 8);
    uint64_t v5 = 40 * v2;
    do
    {
      if ((*(void *)v3 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = (void *)*((void *)v3 + 4);
        if ((void *)((char *)v3 + 8) == v6)
        {
          (*(void (**)(void *))(*((void *)v3 + 1) + 32))((void *)v3 + 1);
        }
        else if (v6)
        {
          (*(void (**)(void *))(*v6 + 40))(v6);
        }
      }
      int v3 = (llvm *)((char *)v3 + 40);
      v4 += 5;
      v5 -= 40;
    }
    while (v5);
    int v3 = *(llvm **)a1;
    uint64_t v7 = 40 * *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v7 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v7);
}

llvm::StringMapImpl *llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x1000000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 8 * v5 + 8;
      uint64_t v9 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v10 = *(void *)(*a2 + 8 * v7);
        if (v10) {
          BOOL v11 = v10 == -8;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          *(void *)(*(void *)this + 8 * v7) = v10;
        }
        else
        {
          size_t v12 = *(void *)v10;
          buffer = (char *)llvm::allocate_buffer(*(void *)v10 + 17, (std::align_val_t)8uLL);
          uint64_t v14 = buffer;
          uint64_t v15 = buffer + 16;
          if (v12) {
            memcpy(buffer + 16, (const void *)(v10 + 16), v12);
          }
          v15[v12] = 0;
          *(void *)uint64_t v14 = v12;
          int v16 = *(_DWORD *)(v10 + 8);
          *(void *)(*(void *)this + 8 * v7) = v14;
          *((_DWORD *)v14 + 2) = v16;
          *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(v9 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

llvm::StringMapImpl *llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x2800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v19 = v4 + 8 * v5 + 8;
      uint64_t v8 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v9 = *(size_t **)(*a2 + 8 * v7);
        if (v9) {
          BOOL v10 = v9 + 1 == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          *(void *)(*(void *)this + 8 * v7) = v9;
        }
        else
        {
          size_t v12 = v9 + 1;
          size_t v11 = *v9;
          buffer = llvm::allocate_buffer(*v9 + 41, (std::align_val_t)8uLL);
          uint64_t v14 = buffer;
          uint64_t v15 = (char *)(buffer + 5);
          if (v11) {
            memcpy(buffer + 5, v9 + 5, v11);
          }
          v15[v11] = 0;
          size_t *v14 = v11;
          int v16 = v14 + 1;
          size_t v17 = v9[4];
          if (v17)
          {
            if ((size_t *)v17 == v12)
            {
              v14[4] = (size_t)v16;
              (*(void (**)(size_t *))(*v12 + 24))(v9 + 1);
            }
            else
            {
              v14[4] = (*(uint64_t (**)(size_t, void *))(*(void *)v17 + 16))(v17, v16);
            }
          }
          else
          {
            v14[4] = 0;
          }
          *(void *)(*(void *)this + 8 * v7) = v14;
          *(_DWORD *)(v19 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::~__func()
{
}

_DWORD *std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_26C387570;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26C387570;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

uint64_t std::__function::__func<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1},std::allocator<mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}>,std::optional<BOOL> ()(mlir::Operation *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}::operator()((int *)(a1 + 8), *a2) | 0x100u;
}

BOOL mlir::ANECRegionOpCreator::ANECRegionOpCreator(mlir::OpBuilder &,mlir::ConversionTarget const&,mlir::RewritePatternSet,mlir::TypeConverter &,mlir::anec::Family,mlir::DeviceInfo const*,llvm::StringRef,long long,long long,BOOL,BOOL,std::string_view,BOOL)::{lambda(mlir::Operation *)#1}::operator()(int *a1, uint64_t a2)
{
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v4)) {
    return 1;
  }
  if (!mlir::verifyCompatibleTypesWithANE(a2, *a1, 1, 1)) {
    return 0;
  }
  uint64_t v6 = mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v6) & 1) == 0)
  {
    uint64_t v7 = mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::ConstantFoldable>(void)::Empty>>();
    if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v7) & 1) == 0
      && (*(unsigned char *)(a2 + 46) & 0x80) != 0)
    {
      uint64_t v8 = *(unsigned int *)(a2 + 68);
      if (v8)
      {
        for (unint64_t i = (uint64_t *)(*(void *)(a2 + 72) + 24); ; i += 4)
        {
          uint64_t v13 = *i;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
          if (!DefiningOp) {
            break;
          }
          uint64_t v11 = DefiningOp;
          uint64_t v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 48) + 32))(*(void *)(v11 + 48), v12) & 1) == 0)break; {
          BOOL result = 0;
          }
          if (!--v8) {
            return result;
          }
        }
      }
    }
  }
  return mlir::anec::isCompatibleWithFamily(a2, *a1);
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C3873C0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C3873C0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A12EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C387408;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387408;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A13EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C387450;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387450;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A14EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C387498;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387498;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A15EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C3874E0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C3874E0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A16EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C323288;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C323288;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec3A17EZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C387528;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387528;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec9A11LegacyEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  uint64_t v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t FunctionType = mlir::anec::A11Legacy::getFunctionType(&v5);
  return mlir::TypeConverter::isSignatureLegal(v2, FunctionType) | 0x100u;
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEv(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_26C387378;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EE7__cloneEPNS0_6__baseIS12_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387378;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4anec12RegionReturnEZNS2_19ANECRegionOpCreatorC1ERNS2_9OpBuilderERKS3_NS2_17RewritePatternSetERNS2_13TypeConverterENS5_6FamilyEPKNS2_10DeviceInfoEN4llvm9StringRefExxbbNS_17basic_string_viewIcNS_11char_traitsIcEEEEbEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSR_EUlST_E_NS_9allocatorISX_EEFNS_8optionalIbEEST_EEclEOST_(uint64_t a1, mlir::Operation **a2)
{
  return mlir::TypeConverter::isLegal(*(mlir::TypeConverter **)(a1 + 8), *a2) | 0x100u;
}

uint64_t mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::MPSToANECBase(uint64_t a1)
{
  v11[20] = *MEMORY[0x263EF8340];
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)a1 = &unk_26C361E18;
  uint64_t v3 = (void *)(a1 + 344);
  *(void *)&long long v9 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v9 + 1) = 61;
  int v7 = 0;
  uint64_t v8 = (uint64_t)&v7;
  v10.n128_u64[0] = (unint64_t)v11;
  v10.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v10, v11, 7uLL, 40);
  unsigned __int32 v4 = v10.n128_u32[2];
  unint64_t v5 = v10.n128_u64[0] + 40 * v10.n128_u32[2];
  *(void *)unint64_t v5 = "A12";
  *(void *)(v5 + 8) = 3;
  *(_DWORD *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = "A12 family";
  *(void *)(v5 + 32) = 10;
  *(void *)(v5 + 40) = "A13";
  *(void *)(v5 + 48) = 3;
  *(_DWORD *)(v5 + 56) = 1;
  *(void *)(v5 + 64) = "A13 family";
  *(void *)(v5 + 72) = 10;
  *(void *)(v5 + 80) = "A14";
  *(void *)(v5 + 88) = 3;
  *(_DWORD *)(v5 + 96) = 2;
  *(void *)(v5 + 104) = "A14 family";
  *(void *)(v5 + 112) = 10;
  *(void *)(v5 + 120) = "A15";
  *(void *)(v5 + 128) = 3;
  *(_DWORD *)(v5 + 136) = 3;
  *(void *)(v5 + 144) = "A15 family";
  *(void *)(v5 + 152) = 10;
  *(void *)(v5 + 160) = "A16";
  *(void *)(v5 + 168) = 3;
  *(_DWORD *)(v5 + 176) = 4;
  *(void *)(v5 + 184) = "A16 family";
  *(void *)(v5 + 192) = 10;
  *(void *)(v5 + 200) = "A17";
  *(void *)(v5 + 208) = 3;
  *(_DWORD *)(v5 + 216) = 5;
  *(void *)(v5 + 224) = "A17 family";
  *(void *)(v5 + 232) = 10;
  *(void *)(v5 + 240) = "A11Legacy";
  *(void *)(v5 + 248) = 9;
  *(_DWORD *)(v5 + 256) = 6;
  *(void *)(v5 + 264) = "A11 Legacy family";
  *(void *)(v5 + 272) = 17;
  v10.n128_u32[2] = v4 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>(v3, v2, (uint64_t)"target-family", 13, &v9, (_DWORD **)&v8, (uint64_t *)&v10);
  *(void *)(a1 + 344) = &unk_26C37E500;
  *(void *)(a1 + 944) = &unk_26C37E580;
  if ((void *)v10.n128_u64[0] != v11) {
    free((void *)v10.n128_u64[0]);
  }
  v10.n128_u64[0] = (unint64_t)"If device hints cannot be followed then compilation has failed.";
  v10.n128_u64[1] = 63;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 960), v2, (uint64_t)"strict-hints", 12, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 960) = &unk_26C37E680;
  *(void *)(a1 + 1152) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, the ANEC macho procedure will follow the MPS host function name. If false"
                                      ", it will use the ANEC region symbol name instead.";
  v10.n128_u64[1] = 132;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1168), v2, (uint64_t)"use-function-name-for-anec-procedure", 36, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1168) = &unk_26C37E680;
  *(void *)(a1 + 1360) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, placement uses the cost model.";
  v10.n128_u64[1] = 39;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1376), v2, (uint64_t)"use-cost-model", 14, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1376) = &unk_26C37E680;
  *(void *)(a1 + 1568) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the host. (requires use-cost-model)";
  v10.n128_u64[1] = 73;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1584), v2, (uint64_t)"force-host-placement", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1584) = &unk_26C37E680;
  *(void *)(a1 + 1776) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the ane if possible. (requires use-cost-model)";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1792), v2, (uint64_t)"force-ane-placement", 19, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1792) = &unk_26C37E680;
  *(void *)(a1 + 1984) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, print the estimated cost of the resulting module (requires use-cost-model).";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2000), v2, (uint64_t)"print-estimated-cost", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2000) = &unk_26C37E680;
  *(void *)(a1 + 2192) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v10.n128_u64[1] = 55;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2208), v2, (uint64_t)"insert-instrumentation", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2208) = &unk_26C37E680;
  *(void *)(a1 + 2400) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"The maximum number of mps operations that will be used to create an ANE region.";
  v10.n128_u64[1] = 79;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2416), v2, (uint64_t)"ane-max-ops", 11, &v10, (void **)&v9);
  *(void *)(a1 + 2416) = &unk_26C37E800;
  *(void *)(a1 + 2616) = &unk_26C37E880;
  v10.n128_u64[0] = (unint64_t)"The maximum number of cumulative liveIns and liveOuts for an ANE region.";
  v10.n128_u64[1] = 72;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2632), v2, (uint64_t)"ane-max-liveio", 14, &v10, (void **)&v9);
  *(void *)(a1 + 2632) = &unk_26C37E800;
  *(void *)(a1 + 2832) = &unk_26C37E880;
  v10.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v10.n128_u64[1] = 24;
  LODWORD(v8) = 1;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)(a1 + 2848), v2, (uint64_t)"gpu-core-count", 14, &v10, (int **)&v9);
  *(void *)(a1 + 2848) = &unk_26C37E740;
  *(void *)(a1 + 3040) = &unk_26C37E7C0;
  v10.n128_u64[0] = (unint64_t)"If true, print a report of which ops failed to be placed on ANE.";
  v10.n128_u64[1] = 64;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 3056), v2, (uint64_t)"print-placement-report", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 3056) = &unk_26C37E680;
  *(void *)(a1 + 3248) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"Postfix appended to the name of the ANE regions created.";
  v10.n128_u64[1] = 56;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((void *)(a1 + 3264), v2, (uint64_t)"region-name-postfix", 19, &v10);
  *(void *)(a1 + 3264) = &unk_26C37E5C0;
  *(void *)(a1 + 3496) = &unk_26C37E640;
  v10.n128_u64[0] = (unint64_t)"If true, use GOC and quantimization patterns to optimzie the ANEC IR.";
  v10.n128_u64[1] = 69;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 3512), v2, (uint64_t)"legacy-quant-conversion", 23, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 3512) = &unk_26C37E680;
  *(void *)(a1 + 3704) = &unk_26C37E700;
  return a1;
}

void mlir::anonymous namespace'::MPSToANEC::~MPSToANEC(mlir::_anonymous_namespace_::MPSToANEC *this)
{
  *(void *)this = &unk_26C361E18;
  *((void *)this + 439) = &unk_26C35BE48;
  uint64_t v2 = (char *)this + 3672;
  uint64_t v3 = (char *)*((void *)this + 462);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 439) = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)*((void *)this + 451);
  if (v4 != *((void **)this + 450)) {
    free(v4);
  }
  unint64_t v5 = (char *)*((void *)this + 447);
  if (v5 != (char *)this + 3592) {
    free(v5);
  }
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 3264);
  *((void *)this + 382) = &unk_26C35BE48;
  uint64_t v6 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 405);
  if (v6 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 3216))
  {
    (*(void (**)(char *))(*((void *)this + 402) + 32))((char *)this + 3216);
  }
  else if (v6)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 382) = &unk_26C35BFE8;
  int v7 = (void *)*((void *)this + 394);
  if (v7 != *((void **)this + 393)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 390);
  if (v8 != (char *)this + 3136) {
    free(v8);
  }
  *((void *)this + 356) = &unk_26C35BEB0;
  long long v9 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 379);
  if (v9 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 3008))
  {
    (*(void (**)(char *))(*((void *)this + 376) + 32))((char *)this + 3008);
  }
  else if (v9)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 356) = &unk_26C35BFE8;
  __n128 v10 = (void *)*((void *)this + 368);
  if (v10 != *((void **)this + 367)) {
    free(v10);
  }
  uint64_t v11 = (char *)*((void *)this + 364);
  if (v11 != (char *)this + 2928) {
    free(v11);
  }
  *((void *)this + 329) = &unk_26C35BF18;
  uint64_t v12 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 353);
  if (v12 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2800))
  {
    (*(void (**)(char *))(*((void *)this + 350) + 32))((char *)this + 2800);
  }
  else if (v12)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 329) = &unk_26C35BFE8;
  uint64_t v13 = (void *)*((void *)this + 341);
  if (v13 != *((void **)this + 340)) {
    free(v13);
  }
  uint64_t v14 = (char *)*((void *)this + 337);
  if (v14 != (char *)this + 2712) {
    free(v14);
  }
  *((void *)this + 302) = &unk_26C35BF18;
  uint64_t v15 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 326);
  if (v15 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2584))
  {
    (*(void (**)(char *))(*((void *)this + 323) + 32))((char *)this + 2584);
  }
  else if (v15)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v15 + 40))(v15);
  }
  *((void *)this + 302) = &unk_26C35BFE8;
  int v16 = (void *)*((void *)this + 314);
  if (v16 != *((void **)this + 313)) {
    free(v16);
  }
  size_t v17 = (char *)*((void *)this + 310);
  if (v17 != (char *)this + 2496) {
    free(v17);
  }
  *((void *)this + 276) = &unk_26C35BE48;
  uint64_t v18 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 299);
  if (v18 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2368))
  {
    (*(void (**)(char *))(*((void *)this + 296) + 32))((char *)this + 2368);
  }
  else if (v18)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v18 + 40))(v18);
  }
  *((void *)this + 276) = &unk_26C35BFE8;
  uint64_t v19 = (void *)*((void *)this + 288);
  if (v19 != *((void **)this + 287)) {
    free(v19);
  }
  unint64_t v20 = (char *)*((void *)this + 284);
  if (v20 != (char *)this + 2288) {
    free(v20);
  }
  *((void *)this + 250) = &unk_26C35BE48;
  uint64_t v21 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 273);
  if (v21 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 2160))
  {
    (*(void (**)(char *))(*((void *)this + 270) + 32))((char *)this + 2160);
  }
  else if (v21)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v21 + 40))(v21);
  }
  *((void *)this + 250) = &unk_26C35BFE8;
  uint64_t v22 = (void *)*((void *)this + 262);
  if (v22 != *((void **)this + 261)) {
    free(v22);
  }
  uint64_t v23 = (char *)*((void *)this + 258);
  if (v23 != (char *)this + 2080) {
    free(v23);
  }
  *((void *)this + 224) = &unk_26C35BE48;
  uint64_t v24 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 247);
  if (v24 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1952))
  {
    (*(void (**)(char *))(*((void *)this + 244) + 32))((char *)this + 1952);
  }
  else if (v24)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v24 + 40))(v24);
  }
  *((void *)this + 224) = &unk_26C35BFE8;
  uint64_t v25 = (void *)*((void *)this + 236);
  if (v25 != *((void **)this + 235)) {
    free(v25);
  }
  uint64_t v26 = (char *)*((void *)this + 232);
  if (v26 != (char *)this + 1872) {
    free(v26);
  }
  *((void *)this + 198) = &unk_26C35BE48;
  uint64_t v27 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 221);
  if (v27 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1744))
  {
    (*(void (**)(char *))(*((void *)this + 218) + 32))((char *)this + 1744);
  }
  else if (v27)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v27 + 40))(v27);
  }
  *((void *)this + 198) = &unk_26C35BFE8;
  int v28 = (void *)*((void *)this + 210);
  if (v28 != *((void **)this + 209)) {
    free(v28);
  }
  uint64_t v29 = (char *)*((void *)this + 206);
  if (v29 != (char *)this + 1664) {
    free(v29);
  }
  *((void *)this + 172) = &unk_26C35BE48;
  unint64_t v30 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 195);
  if (v30 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1536))
  {
    (*(void (**)(char *))(*((void *)this + 192) + 32))((char *)this + 1536);
  }
  else if (v30)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v30 + 40))(v30);
  }
  *((void *)this + 172) = &unk_26C35BFE8;
  uint64_t v31 = (void *)*((void *)this + 184);
  if (v31 != *((void **)this + 183)) {
    free(v31);
  }
  uint64_t v32 = (char *)*((void *)this + 180);
  if (v32 != (char *)this + 1456) {
    free(v32);
  }
  *((void *)this + 146) = &unk_26C35BE48;
  int v33 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 169);
  if (v33 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1328))
  {
    (*(void (**)(char *))(*((void *)this + 166) + 32))((char *)this + 1328);
  }
  else if (v33)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v33 + 40))(v33);
  }
  *((void *)this + 146) = &unk_26C35BFE8;
  uint64_t v34 = (void *)*((void *)this + 158);
  if (v34 != *((void **)this + 157)) {
    free(v34);
  }
  uint64_t v35 = (char *)*((void *)this + 154);
  if (v35 != (char *)this + 1248) {
    free(v35);
  }
  *((void *)this + 120) = &unk_26C35BE48;
  size_t v36 = (mlir::_anonymous_namespace_::MPSToANEC *)*((void *)this + 143);
  if (v36 == (mlir::_anonymous_namespace_::MPSToANEC *)((char *)this + 1120))
  {
    (*(void (**)(char *))(*((void *)this + 140) + 32))((char *)this + 1120);
  }
  else if (v36)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANEC *))(*(void *)v36 + 40))(v36);
  }
  *((void *)this + 120) = &unk_26C35BFE8;
  int v37 = (void *)*((void *)this + 132);
  if (v37 != *((void **)this + 131)) {
    free(v37);
  }
  uint64_t v38 = (char *)*((void *)this + 128);
  if (v38 != (char *)this + 1040) {
    free(v38);
  }
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::~Option((void *)this + 43);

  mlir::Pass::~Pass(this);
}

{
  uint64_t vars8;

  JUMPOUT(0x21667D3C0);
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getName()
{
  return "MPSToANEC";
}

void *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[0] = &unk_26C3872D8;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387248;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id, "anec", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387200;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387290;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::memref::MemRefDialect,void>::id, "memref", 6uLL, v4);
  BOOL result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getArgument()
{
  return "mps-to-anec";
}

const char *mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::getDescription()
{
  return "Convert mps ops to anec ops if possible and create regions for ane";
}

void mlir::anonymous namespace'::MPSToANEC::runOnOperation(mlir::_anonymous_namespace_::MPSToANEC *this)
{
}

void sub_211911BF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v69 = a69;
  a69 = 0;
  if (v69) {
    (*(void (**)(uint64_t))(*(void *)v69 + 8))(v69);
  }
  mlir::ConversionTarget::~ConversionTarget((mlir::ConversionTarget *)&a35);
}

uint64_t sub_211911C34()
{
  uint64_t result = v1;
  if (v1) {
    return (*(uint64_t (**)())(*(void *)v1 + 8))();
  }
  return result;
}

void mlir::MPSToANECBase<mlir::anonymous namespace'::MPSToANEC>::clonePass()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, void **a6)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 200;
  *(unsigned char *)(v8 + 208) = 0;
  *(void *)uint64_t v8 = &unk_26C37F720;
  *(void *)(v8 + 200) = &unk_26C37F7A0;
  uint64_t v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  uint64_t v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
    unint64_t v20 = (uint64_t *)&v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *unint64_t v20 = v9;
    uint64_t v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      unint64_t v20 = (uint64_t *)((char *)v20 - v24);
      uint64_t v25 = &v19[8 * v15 - 16];
      uint64_t v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)uint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--unint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      uint64_t v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    uint64_t *v11 = v9;
    uint64_t v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_26C387C40;
  v32[1] = a1;
  uint64_t v35 = v34;
  int v33 = v32;
  v34[0] = &unk_26C387C40;
  v34[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v34, a1 + 21);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, void **a5)
{
  *(void *)a1 = &unk_26C35BFE8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 136) = &unk_26C35BD18;
  *(void *)a1 = &unk_26C35BF18;
  *(void *)(a1 + 160) = &unk_26C35C130;
  *(void *)(a1 + 168) = &unk_26C380DD0;
  *(void *)(a1 + 192) = a1 + 168;
  llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<long long>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, void **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      uint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      void *v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  uint64_t v12 = *a5;
  *(void *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 152) = 1;
  *(void *)(a1 + 144) = *v12;
  return result;
}

void _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26C387C40;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387C40;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIxEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 208) = 1;
  return result;
}

void *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 192;
  *(unsigned char *)(v8 + 200) = 0;
  *(void *)uint64_t v8 = &unk_26C37F660;
  *(void *)(v8 + 192) = &unk_26C37F6E0;
  uint64_t v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  uint64_t v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      uint64_t v19 = 0;
    }
    unint64_t v20 = (uint64_t *)&v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *unint64_t v20 = v9;
    uint64_t v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      unint64_t v20 = (uint64_t *)((char *)v20 - v24);
      uint64_t v25 = &v19[8 * v15 - 16];
      uint64_t v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)uint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--unint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      uint64_t v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    uint64_t *v11 = v9;
    uint64_t v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_26C387BB0;
  v32[1] = a1;
  uint64_t v35 = v34;
  int v33 = v32;
  v34[0] = &unk_26C387BB0;
  v34[1] = a1;
  std::__function::__value_func<void ()(unsigned int const&)>::swap[abi:nn180100](v34, a1 + 20);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

void *mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_26C35BEB0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_26C35BEB0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  unint64_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }

  JUMPOUT(0x21667D3C0);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  unsigned __int32 v4 = *(const void **)(a1 + 16);
  size_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      uint64_t v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    int v7 = this;
  }
  else
  {
    int v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    uint64_t v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    *uint64_t v6 = 61;
  }
  unint64_t v8 = *(unsigned int *)(a1 + 128);

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 - 64);
  *(unsigned char *)(result + 200) = *(unsigned char *)(a2 + 8);
  return result;
}

void non-virtual thunk to'mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_26C35BEB0;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_26C35BFE8;
  unsigned __int32 v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t vars8;

  *(void *)(a1 - 192) = &unk_26C35BEB0;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_26C35BFE8;
  unsigned __int32 v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }

  JUMPOUT(0x21667D3C0);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  unsigned __int32 v4 = *(const void **)(a1 - 176);
  size_t v5 = *(void *)(a1 - 168);
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      uint64_t v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    int v7 = this;
  }
  else
  {
    int v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    uint64_t v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    *uint64_t v6 = 61;
  }
  unint64_t v8 = *(unsigned int *)(a1 - 64);

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::getOption(uint64_t a1)
{
  return a1 - 192;
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result - 64) = *(_DWORD *)(a2 - 64);
  *(unsigned char *)(result + 8) = *(unsigned char *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  *(void *)a1 = &unk_26C35BFE8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_26C35BCF8;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_26C35BEB0;
  *(void *)(a1 + 152) = &unk_26C35C100;
  *(void *)(a1 + 160) = &unk_26C380D88;
  *(void *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_26C35BEB0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(void *a1)
{
  *a1 = &unk_26C35BEB0;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }

  JUMPOUT(0x21667D3C0);
}

void non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_26C35BEB0;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_26C35BFE8;
  unsigned __int32 v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option((void *)(a1 - 192));
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      uint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      void *v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  int v12 = **a5;
  *(_DWORD *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  return result;
}

void *std::__function::__value_func<void ()(unsigned int const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unsigned __int32 v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26C387BB0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26C387BB0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 200) = 1;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::~__func()
{
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26C3872D8;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26C3872D8;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"placement", 9, (uint64_t)&mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::placement::PlacementDialect * mlir::MLIRContext::getOrLoadDialect<mlir::placement::PlacementDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::~__func()
{
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26C387248;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26C387248;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::anec::ANECDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"anec", 4, (uint64_t)&mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::anec::ANECDialect * mlir::MLIRContext::getOrLoadDialect<mlir::anec::ANECDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::~__func()
{
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26C387200;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26C387200;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::mps::MPSDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"mps", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::mps::MPSDialect * mlir::MLIRContext::getOrLoadDialect<mlir::mps::MPSDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::~__func()
{
}

void *std::__function::__func<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26C387290;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26C387290;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::memref::MemRefDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, void **a2)
{
  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"memref", 6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::memref::MemRefDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::memref::MemRefDialect * mlir::MLIRContext::getOrLoadDialect<mlir::memref::MemRefDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::memref::MemRefDialect * mlir::MLIRContext::getOrLoadDialect<mlir::memref::MemRefDialect>(void)::{lambda(void)#1}>()
{
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvEUlNS1_4func6FuncOpEE_SF_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_(void **a1, uint64_t a2)
{
  if (a2 && *(_UNKNOWN **)(*(void *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    uint64_t v3 = *a1;
    if (!*(unsigned char *)(a2 + 47) || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"io_info", 7), !v5)) {
      uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "io_info", 7uLL);
    }
    uint64_t v8 = InherentAttr;
    if (InherentAttr)
    {
      v7[0] = v3[1];
      v7[1] = &v8;
      v7[2] = *v3;
      uint64_t v9 = v7;
      mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&v9, 1);
    }
  }
  return 1;
}

double _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::Operation *a2)
{
  if (a2
    && *(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
  {
    uint64_t v2 = *a1;
    long long v28 = a2;
    Callee = (char *)mlir::placement::RegionCall::getCallee(&v28);
    size_t v5 = v4;
    *(void *)&long long v27 = Callee;
    *((void *)&v27 + 1) = v4;
    uint64_t v6 = **(unsigned int ***)v2;
    uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v6 + 6));
    __int16 v31 = 261;
    uint64_t v29 = Callee;
    uint64_t v30 = v5;
    uint64_t v8 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v29);
    uint64_t v9 = mlir::SymbolTable::lookupSymbolIn(v6, v8);
    uint64_t v10 = **(void **)(v2 + 8);
    uint64_t v11 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
    __int16 v31 = 261;
    uint64_t v29 = "io_info";
    uint64_t v30 = 7;
    uint64_t v12 = mlir::StringAttr::get(v11, (mlir::MLIRContext *)&v29);
    mlir::Operation::setAttr(v9, v12, v10);
    uint64_t v13 = *(void *)(v2 + 16);
    int v14 = *(_DWORD *)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)v13;
      unsigned int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(Callee, v5);
      unint64_t v18 = 0;
      int v19 = v14 - 1;
      for (int i = 1; ; ++i)
      {
        unsigned int v21 = HashValue & v19;
        uint64_t v22 = v15 + 16 * (HashValue & v19);
        uint64_t v23 = *(const void **)v22;
        if (*(void *)v22 == -2)
        {
          if (Callee == (char *)-2) {
            return result;
          }
        }
        else if (v23 == (const void *)-1)
        {
          if (Callee == (char *)-1) {
            return result;
          }
        }
        else if (v5 == *(void *)(v22 + 8) && (!v5 || !memcmp(Callee, *(const void **)v22, v5)))
        {
          return result;
        }
        if (v23 == (const void *)-1) {
          break;
        }
        if (v18) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v23 == (const void *)-2;
        }
        if (v24) {
          unint64_t v18 = (void *)(v15 + 16 * v21);
        }
        unsigned int HashValue = i + v21;
      }
      if (v18) {
        uint64_t v25 = v18;
      }
      else {
        uint64_t v25 = (void *)(v15 + 16 * v21);
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    uint64_t v26 = llvm::DenseMapBase<llvm::DenseMap<llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>,llvm::StringRef,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::StringRef,void>,llvm::detail::DenseSetPair<llvm::StringRef>>::InsertIntoBucketImpl<llvm::StringRef>(v13, (uint64_t)&v27, (uint64_t)&v27, v25);
    double result = *(double *)&v27;
    *(_OWORD *)uint64_t v26 = v27;
  }
  return result;
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvEUlNS1_4func6FuncOpEE0_SF_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESP_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, void *a2)
{
  if (a2 && *(_UNKNOWN **)(a2[6] + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    uint64_t v3 = *a1;
    uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 3));
    uint64_t SymbolName = mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)a2, v5);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
    __int16 v13 = 261;
    uint64_t SymbolName = AttrData;
    uint64_t v11 = v7;
    uint64_t v14 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&SymbolName);
    char v9 = 0;
    uint64_t SymbolName = *v3;
    uint64_t v11 = &v14;
    uint64_t v12 = &v9;
    p_uint64_t SymbolName = &SymbolName;
    mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)a2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE0_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&p_SymbolName, 1);
  }
  return 1;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_12_GLOBAL__N_19MPSToANEC14runOnOperationEvENKUlNS1_4func6FuncOpEE0_clESE_EUlNS1_9placement10RegionCallEE_SH_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESQ_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t *a1, mlir::Operation *a2)
{
  if (a2)
  {
    if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
    {
      uint64_t v2 = *a1;
      __int16 v13 = a2;
      uint64_t Callee = mlir::placement::RegionCall::getCallee(&v13);
      uint64_t v5 = v4;
      uint64_t v6 = **(unsigned int ***)v2;
      uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v6 + 6));
      __int16 v16 = 261;
      uint64_t v14 = (const char *)Callee;
      uint64_t v15 = v5;
      uint64_t v8 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v14);
      uint64_t v9 = mlir::SymbolTable::lookupSymbolIn(v6, v8);
      uint64_t v10 = **(void **)(v2 + 8);
      uint64_t v11 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 24));
      __int16 v16 = 261;
      uint64_t v14 = "procedure_name";
      uint64_t v15 = 14;
      uint64_t v12 = mlir::StringAttr::get(v11, (mlir::MLIRContext *)&v14);
      mlir::Operation::setAttr(v9, v12, v10);
      **(unsigned char **)(v2 + 16) = 1;
    }
  }
}

uint64_t mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::MPSToANECMinBase(uint64_t a1)
{
  v11[20] = *MEMORY[0x263EF8340];
  *(void *)(a1 + 16) = "builtin.module";
  *(void *)(a1 + 24) = 14;
  *(unsigned char *)(a1 + 32) = 1;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t v2 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 200;
  *(void *)(a1 + 192) = 0x400000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)a1 = &unk_26C321820;
  uint64_t v3 = (void *)(a1 + 344);
  *(void *)&long long v9 = "The family to target for ANEC region formation (default A12).";
  *((void *)&v9 + 1) = 61;
  int v7 = 0;
  uint64_t v8 = (uint64_t)&v7;
  v10.n128_u64[0] = (unint64_t)v11;
  v10.n128_u64[1] = 0x400000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v10, v11, 7uLL, 40);
  unsigned __int32 v4 = v10.n128_u32[2];
  unint64_t v5 = v10.n128_u64[0] + 40 * v10.n128_u32[2];
  *(void *)unint64_t v5 = "A12";
  *(void *)(v5 + 8) = 3;
  *(_DWORD *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = "A12 family";
  *(void *)(v5 + 32) = 10;
  *(void *)(v5 + 40) = "A13";
  *(void *)(v5 + 48) = 3;
  *(_DWORD *)(v5 + 56) = 1;
  *(void *)(v5 + 64) = "A13 family";
  *(void *)(v5 + 72) = 10;
  *(void *)(v5 + 80) = "A14";
  *(void *)(v5 + 88) = 3;
  *(_DWORD *)(v5 + 96) = 2;
  *(void *)(v5 + 104) = "A14 family";
  *(void *)(v5 + 112) = 10;
  *(void *)(v5 + 120) = "A15";
  *(void *)(v5 + 128) = 3;
  *(_DWORD *)(v5 + 136) = 3;
  *(void *)(v5 + 144) = "A15 family";
  *(void *)(v5 + 152) = 10;
  *(void *)(v5 + 160) = "A16";
  *(void *)(v5 + 168) = 3;
  *(_DWORD *)(v5 + 176) = 4;
  *(void *)(v5 + 184) = "A16 family";
  *(void *)(v5 + 192) = 10;
  *(void *)(v5 + 200) = "A17";
  *(void *)(v5 + 208) = 3;
  *(_DWORD *)(v5 + 216) = 5;
  *(void *)(v5 + 224) = "A17 family";
  *(void *)(v5 + 232) = 10;
  *(void *)(v5 + 240) = "A11Legacy";
  *(void *)(v5 + 248) = 9;
  *(_DWORD *)(v5 + 256) = 6;
  *(void *)(v5 + 264) = "A11 Legacy family";
  *(void *)(v5 + 272) = 17;
  v10.n128_u32[2] = v4 + 7;
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::anec::Family>,llvm::cl::ValuesClass>(v3, v2, (uint64_t)"target-family", 13, &v9, (_DWORD **)&v8, (uint64_t *)&v10);
  *(void *)(a1 + 344) = &unk_26C37E500;
  *(void *)(a1 + 944) = &unk_26C37E580;
  if ((void *)v10.n128_u64[0] != v11) {
    free((void *)v10.n128_u64[0]);
  }
  v10.n128_u64[0] = (unint64_t)"If device hints cannot be followed then compilation has failed.";
  v10.n128_u64[1] = 63;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 960), v2, (uint64_t)"strict-hints", 12, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 960) = &unk_26C37E680;
  *(void *)(a1 + 1152) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, placement uses the cost model.";
  v10.n128_u64[1] = 39;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1168), v2, (uint64_t)"use-cost-model", 14, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1168) = &unk_26C37E680;
  *(void *)(a1 + 1360) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the host. (requires use-cost-model)";
  v10.n128_u64[1] = 73;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1376), v2, (uint64_t)"force-host-placement", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1376) = &unk_26C37E680;
  *(void *)(a1 + 1568) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, everything will be placed on the ane if possible. (requires use-cost-model)";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1584), v2, (uint64_t)"force-ane-placement", 19, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1584) = &unk_26C37E680;
  *(void *)(a1 + 1776) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"If true, print the estimated cost of the resulting module (requires use-cost-model).";
  v10.n128_u64[1] = 84;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 1792), v2, (uint64_t)"print-estimated-cost", 20, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 1792) = &unk_26C37E680;
  *(void *)(a1 + 1984) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"Insert instrumentation to enable performance recording.";
  v10.n128_u64[1] = 55;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2000), v2, (uint64_t)"insert-instrumentation", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2000) = &unk_26C37E680;
  *(void *)(a1 + 2192) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"The maximum number of mps operations that will be used to create an ANE region.";
  v10.n128_u64[1] = 79;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2208), v2, (uint64_t)"ane-max-ops", 11, &v10, (void **)&v9);
  *(void *)(a1 + 2208) = &unk_26C37E800;
  *(void *)(a1 + 2408) = &unk_26C37E880;
  v10.n128_u64[0] = (unint64_t)"The maximum number of cumulative liveIns and liveOuts for an ANE region.";
  v10.n128_u64[1] = 72;
  uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<long long>>((void *)(a1 + 2424), v2, (uint64_t)"ane-max-liveio", 14, &v10, (void **)&v9);
  *(void *)(a1 + 2424) = &unk_26C37E800;
  *(void *)(a1 + 2624) = &unk_26C37E880;
  v10.n128_u64[0] = (unint64_t)"The number of gpu cores.";
  v10.n128_u64[1] = 24;
  LODWORD(v8) = 1;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((void *)(a1 + 2640), v2, (uint64_t)"gpu-core-count", 14, &v10, (int **)&v9);
  *(void *)(a1 + 2640) = &unk_26C37E740;
  *(void *)(a1 + 2832) = &unk_26C37E7C0;
  v10.n128_u64[0] = (unint64_t)"If true, print a report of which ops failed to be placed on ANE.";
  v10.n128_u64[1] = 64;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 2848), v2, (uint64_t)"print-placement-report", 22, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 2848) = &unk_26C37E680;
  *(void *)(a1 + 3040) = &unk_26C37E700;
  v10.n128_u64[0] = (unint64_t)"Postfix appended to the name of the ANE regions created.";
  v10.n128_u64[1] = 56;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc>((void *)(a1 + 3056), v2, (uint64_t)"region-name-postfix", 19, &v10);
  *(void *)(a1 + 3056) = &unk_26C37E5C0;
  *(void *)(a1 + 3288) = &unk_26C37E640;
  v10.n128_u64[0] = (unint64_t)"If true, use GOC and quantimization patterns to optimzie the ANEC IR.";
  v10.n128_u64[1] = 69;
  LOBYTE(v8) = 0;
  *(void *)&long long v9 = &v8;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((void *)(a1 + 3304), v2, (uint64_t)"legacy-quant-conversion", 23, &v10, (unsigned char **)&v9);
  *(void *)(a1 + 3304) = &unk_26C37E680;
  *(void *)(a1 + 3496) = &unk_26C37E700;
  return a1;
}

void mlir::anonymous namespace'::MPSToANECMin::~MPSToANECMin(mlir::_anonymous_namespace_::MPSToANECMin *this)
{
  *(void *)this = &unk_26C321200;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 440);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_26C321820;
  *((void *)this + 413) = &unk_26C35BE48;
  uint64_t v3 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 436);
  if (v3 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 3464))
  {
    (*(void (**)(char *))(*((void *)this + 433) + 32))((char *)this + 3464);
  }
  else if (v3)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v3 + 40))(v3);
  }
  *((void *)this + 413) = &unk_26C35BFE8;
  unsigned __int32 v4 = (void *)*((void *)this + 425);
  if (v4 != *((void **)this + 424)) {
    free(v4);
  }
  unint64_t v5 = (char *)*((void *)this + 421);
  if (v5 != (char *)this + 3384) {
    free(v5);
  }
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 3056);
  *((void *)this + 356) = &unk_26C35BE48;
  uint64_t v6 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 379);
  if (v6 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 3008))
  {
    (*(void (**)(char *))(*((void *)this + 376) + 32))((char *)this + 3008);
  }
  else if (v6)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v6 + 40))(v6);
  }
  *((void *)this + 356) = &unk_26C35BFE8;
  int v7 = (void *)*((void *)this + 368);
  if (v7 != *((void **)this + 367)) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 364);
  if (v8 != (char *)this + 2928) {
    free(v8);
  }
  *((void *)this + 330) = &unk_26C35BEB0;
  long long v9 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 353);
  if (v9 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 2800))
  {
    (*(void (**)(char *))(*((void *)this + 350) + 32))((char *)this + 2800);
  }
  else if (v9)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v9 + 40))(v9);
  }
  *((void *)this + 330) = &unk_26C35BFE8;
  __n128 v10 = (void *)*((void *)this + 342);
  if (v10 != *((void **)this + 341)) {
    free(v10);
  }
  uint64_t v11 = (char *)*((void *)this + 338);
  if (v11 != (char *)this + 2720) {
    free(v11);
  }
  *((void *)this + 303) = &unk_26C35BF18;
  uint64_t v12 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 327);
  if (v12 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 2592))
  {
    (*(void (**)(char *))(*((void *)this + 324) + 32))((char *)this + 2592);
  }
  else if (v12)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v12 + 40))(v12);
  }
  *((void *)this + 303) = &unk_26C35BFE8;
  __int16 v13 = (void *)*((void *)this + 315);
  if (v13 != *((void **)this + 314)) {
    free(v13);
  }
  uint64_t v14 = (char *)*((void *)this + 311);
  if (v14 != (char *)this + 2504) {
    free(v14);
  }
  *((void *)this + 276) = &unk_26C35BF18;
  uint64_t v15 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 300);
  if (v15 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 2376))
  {
    (*(void (**)(char *))(*((void *)this + 297) + 32))((char *)this + 2376);
  }
  else if (v15)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v15 + 40))(v15);
  }
  *((void *)this + 276) = &unk_26C35BFE8;
  __int16 v16 = (void *)*((void *)this + 288);
  if (v16 != *((void **)this + 287)) {
    free(v16);
  }
  uint64_t v17 = (char *)*((void *)this + 284);
  if (v17 != (char *)this + 2288) {
    free(v17);
  }
  *((void *)this + 250) = &unk_26C35BE48;
  unint64_t v18 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 273);
  if (v18 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 2160))
  {
    (*(void (**)(char *))(*((void *)this + 270) + 32))((char *)this + 2160);
  }
  else if (v18)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v18 + 40))(v18);
  }
  *((void *)this + 250) = &unk_26C35BFE8;
  int v19 = (void *)*((void *)this + 262);
  if (v19 != *((void **)this + 261)) {
    free(v19);
  }
  unint64_t v20 = (char *)*((void *)this + 258);
  if (v20 != (char *)this + 2080) {
    free(v20);
  }
  *((void *)this + 224) = &unk_26C35BE48;
  unsigned int v21 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 247);
  if (v21 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 1952))
  {
    (*(void (**)(char *))(*((void *)this + 244) + 32))((char *)this + 1952);
  }
  else if (v21)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v21 + 40))(v21);
  }
  *((void *)this + 224) = &unk_26C35BFE8;
  uint64_t v22 = (void *)*((void *)this + 236);
  if (v22 != *((void **)this + 235)) {
    free(v22);
  }
  uint64_t v23 = (char *)*((void *)this + 232);
  if (v23 != (char *)this + 1872) {
    free(v23);
  }
  *((void *)this + 198) = &unk_26C35BE48;
  BOOL v24 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 221);
  if (v24 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 1744))
  {
    (*(void (**)(char *))(*((void *)this + 218) + 32))((char *)this + 1744);
  }
  else if (v24)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v24 + 40))(v24);
  }
  *((void *)this + 198) = &unk_26C35BFE8;
  uint64_t v25 = (void *)*((void *)this + 210);
  if (v25 != *((void **)this + 209)) {
    free(v25);
  }
  uint64_t v26 = (char *)*((void *)this + 206);
  if (v26 != (char *)this + 1664) {
    free(v26);
  }
  *((void *)this + 172) = &unk_26C35BE48;
  long long v27 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 195);
  if (v27 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 1536))
  {
    (*(void (**)(char *))(*((void *)this + 192) + 32))((char *)this + 1536);
  }
  else if (v27)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v27 + 40))(v27);
  }
  *((void *)this + 172) = &unk_26C35BFE8;
  long long v28 = (void *)*((void *)this + 184);
  if (v28 != *((void **)this + 183)) {
    free(v28);
  }
  uint64_t v29 = (char *)*((void *)this + 180);
  if (v29 != (char *)this + 1456) {
    free(v29);
  }
  *((void *)this + 146) = &unk_26C35BE48;
  uint64_t v30 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 169);
  if (v30 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 1328))
  {
    (*(void (**)(char *))(*((void *)this + 166) + 32))((char *)this + 1328);
  }
  else if (v30)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v30 + 40))(v30);
  }
  *((void *)this + 146) = &unk_26C35BFE8;
  __int16 v31 = (void *)*((void *)this + 158);
  if (v31 != *((void **)this + 157)) {
    free(v31);
  }
  uint64_t v32 = (char *)*((void *)this + 154);
  if (v32 != (char *)this + 1248) {
    free(v32);
  }
  *((void *)this + 120) = &unk_26C35BE48;
  int v33 = (mlir::_anonymous_namespace_::MPSToANECMin *)*((void *)this + 143);
  if (v33 == (mlir::_anonymous_namespace_::MPSToANECMin *)((char *)this + 1120))
  {
    (*(void (**)(char *))(*((void *)this + 140) + 32))((char *)this + 1120);
  }
  else if (v33)
  {
    (*(void (**)(mlir::_anonymous_namespace_::MPSToANECMin *))(*(void *)v33 + 40))(v33);
  }
  *((void *)this + 120) = &unk_26C35BFE8;
  uint64_t v34 = (void *)*((void *)this + 132);
  if (v34 != *((void **)this + 131)) {
    free(v34);
  }
  uint64_t v35 = (char *)*((void *)this + 128);
  if (v35 != (char *)this + 1040) {
    free(v35);
  }
  mlir::detail::PassOptions::Option<mlir::anec::Family,mlir::detail::PassOptions::GenericOptionParser<mlir::anec::Family>>::~Option((void *)this + 43);

  mlir::Pass::~Pass(this);
}

{
  uint64_t vars8;

  JUMPOUT(0x21667D3C0);
}

const char *mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::getName()
{
  return "MPSToANECMin";
}

void *mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v4[0] = &unk_26C3872D8;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387248;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id, "anec", 4uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387200;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  v4[0] = &unk_26C387290;
  unint64_t v5 = v4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::memref::MemRefDialect,void>::id, "memref", 6uLL, v4);
  double result = v5;
  if (v5 == v4) {
    return (void *)(*(uint64_t (**)(void *))(v4[0] + 32))(v4);
  }
  if (v5) {
    return (void *)(*(uint64_t (**)(void))(*v5 + 40))();
  }
  return result;
}

const char *mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::getArgument()
{
  return "mps-to-anec-min";
}

const char *mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::getDescription()
{
  return "A minimum pass that convert mps ops to anec ops";
}

void mlir::anonymous namespace'::MPSToANECMin::runOnOperation(mlir::_anonymous_namespace_::MPSToANECMin *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  llvm::DebugFlag = 0;
  mlir::Attribute::getContext((mlir::Attribute *)((*((void *)this + 5) & 0xFFFFFFFFFFFFFFF8) + 24));
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v1);
  mlir::populateMPSToANECConversionPatterns();
}

void mlir::MPSToANECMinBase<mlir::anonymous namespace'::MPSToANECMin>::clonePass()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void std::__shared_ptr_emplace<mlir::anec::MLIRConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C323980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::anec::MLIRConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C323980;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21667D3C0);
}

void std::__shared_ptr_emplace<mlir::anec::MLIRConversionInfo>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 24);
  uint64_t v3 = *(unsigned int *)(a1 + 32);
  if (v3)
  {
    unsigned __int32 v4 = v2 - 8;
    uint64_t v5 = 16 * v3;
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)&v4[v5];
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      v5 -= 16;
    }
    while (v5);
    uint64_t v2 = *(char **)(a1 + 24);
  }
  if (v2 != (char *)(a1 + 40))
  {
    free(v2);
  }
}

void _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSToANECMin14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSToANECMin14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EE7__cloneEv(uint64_t a1)
{
  double result = operator new(0x10uLL);
  *(void *)double result = &unk_26C323240;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSToANECMin14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26C323240;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps10ConstantOpEZNS2_12_GLOBAL__N_112MPSToANECMin14runOnOperationEvEUlS6_E_EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_PNS2_9OperationEEEvE4typeEOSB_EUlSD_E_NS_9allocatorISH_EEFNS_8optionalIbEESD_EEclEOSD_(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void *)(*a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v2 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    unint64_t v2 = 0;
  }
  unint64_t v5 = v2;
  if (v2)
  {
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v5);
    LODWORD(v2) = v3 > 3;
  }
  return v2 | 0x100;
}

void mlir::anec::MPSToANECNullOstream::~MPSToANECNullOstream(mlir::anec::MPSToANECNullOstream *this)
{
  llvm::raw_ostream::~raw_ostream(this);

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anec::MPSToANECNullOstream::write_impl(uint64_t this, const char *a2, uint64_t a3)
{
  *(void *)(this + 64) += a3;
  return this;
}

uint64_t mlir::anec::MPSToANECNullOstream::current_pos(mlir::anec::MPSToANECNullOstream *this)
{
  return *((void *)this + 8);
}

uint64_t _ZN4llvm12function_refIFN4mlir10WalkResultEPNS1_9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_12_GLOBAL__N_112MPSToANECMin24basicMPSToANECConversionENS1_8ModuleOpEPNS1_15RegionOpCreatorEPKNS1_15CostModelParamsEEUlNS1_4func6FuncOpEE_SL_S2_EENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S4_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_S2_EE5valueESU_E4typeES4_OT1_EUlS4_E_EES2_lS4_(uint64_t **a1, mlir::SymbolRefAttr *this)
{
  v59[6] = *MEMORY[0x263EF8340];
  if (this
    && *(_UNKNOWN **)(*((void *)this + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = **a1;
    v58[0] = mlir::SymbolRefAttr::get(this, this);
    v36[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v58);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v36);
    uint64_t v7 = v6;
    uint64_t v8 = operator new(0xB0uLL);
    v8[1] = 0;
    v8[2] = 0;
    *uint64_t v8 = &unk_26C3239F0;
    v8[5] = 0;
    v8[6] = 0;
    v8[4] = v7;
    *((_DWORD *)v8 + 14) = 0;
    v8[8] = 0;
    v8[9] = 0;
    *((_DWORD *)v8 + 20) = 0;
    v8[11] = 0;
    v8[12] = 0;
    *((_DWORD *)v8 + 26) = 0;
    v8[14] = v8 + 16;
    v8[15] = 0x300000000;
    v35[1] = v8;
    v8[3] = AttrData;
    v35[0] = v8 + 3;
    uint64_t v10 = *(void *)(v4 + 3512);
    uint64_t v11 = *(unsigned int *)(v10 + 8);
    unint64_t v12 = *(void *)v10;
    __int16 v13 = (char *)v35;
    if (v11 >= *(_DWORD *)(v10 + 12))
    {
      unint64_t v32 = v11 + 1;
      BOOL v33 = v12 + 16 * v11 > (unint64_t)v35;
      if (v12 <= (unint64_t)v35 && v33)
      {
        uint64_t v34 = (char *)v35 - v12;
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(*(void *)(v4 + 3512), v32);
        unint64_t v12 = *(void *)v10;
        __int16 v13 = &v34[*(void *)v10];
      }
      else
      {
        llvm::SmallVectorTemplateBase<std::shared_ptr<mlir::anec::ANECIROutput>,false>::grow(*(void *)(v4 + 3512), v32);
        unint64_t v12 = *(void *)v10;
        __int16 v13 = (char *)v35;
      }
    }
    uint64_t v14 = *(unsigned int *)(v10 + 8);
    long long v15 = *(_OWORD *)v13;
    *(_OWORD *)(v12 + 16 * v14) = *(_OWORD *)v13;
    if (*((void *)&v15 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
      LODWORD(v14) = *(_DWORD *)(v10 + 8);
    }
    *(_DWORD *)(v10 + 8) = v14 + 1;
    __int16 v16 = *(void **)v3[1];
    uint64_t v17 = v3[3];
    uint64_t v55 = v16;
    uint64_t v56 = this;
    uint64_t v54 = v35[0];
    uint64_t v18 = v16[1];
    int v53 = 0;
    uint64_t v52 = &unk_26C322958;
    *(void *)(v18 + 8) = &v52;
    v50[0] = 0;
    v50[1] = 0;
    int v51 = 0;
    v58[0] = mlir::SymbolRefAttr::get(this, v9);
    v36[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v58);
    v49[0] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v36);
    v49[1] = v19;
    uint64_t v20 = (*(uint64_t (**)(void *))(*v16 + 16))(v16);
    uint64_t v47 = 0;
    uint64_t v48 = v20;
    (*(void (**)(void *__return_ptr, void *))(*v16 + 56))(v46, v16);
    v58[0] = v59;
    v58[1] = 0x600000000;
    uint64_t v45 = 0;
    v43[0] = 0;
    v43[1] = 0;
    int v44 = 0;
    char v40 = 0;
    uint64_t v41 = 0;
    unsigned int v42 = 0;
    v38[0] = 0;
    v38[1] = 0;
    unsigned int v39 = 0;
    v37[0] = &v56;
    v37[1] = &v54;
    v37[2] = &v45;
    v37[3] = v43;
    v36[0] = &v56;
    v36[1] = &v55;
    v36[2] = v43;
    v36[3] = &v54;
    v36[4] = v58;
    v36[5] = v18;
    v36[6] = v49;
    v36[7] = &v47;
    v36[8] = v46;
    v36[9] = v17;
    v36[10] = v50;
    v36[11] = v38;
    v36[12] = &v40;
    char v57 = v38;
    if (v41)
    {
      if (v42)
      {
        uint64_t v21 = 24 * v42;
        uint64_t v22 = v40;
        while ((*(void *)v22 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          uint64_t v22 = (llvm *)((char *)v22 + 24);
          v21 -= 24;
          if (!v21) {
            goto LABEL_17;
          }
        }
      }
      else
      {
        uint64_t v22 = v40;
      }
      if (v22 != (llvm *)((char *)v40 + 24 * v42))
      {
        uint64_t v23 = *(void *)v22;
        uint64_t v25 = *((void *)v22 + 1);
        uint64_t v24 = *((void *)v22 + 2);
        if (v24) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
        }
      }
    }
LABEL_17:
    char v57 = (llvm **)&v48;
    *(void *)(v18 + 8) = 0;
    uint64_t v26 = v38[0];
    if (v39)
    {
      long long v27 = (std::__shared_weak_count **)((char *)v38[0] + 16);
      uint64_t v28 = 24 * v39;
      do
      {
        if (((unint64_t)*(v27 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v29 = *v27;
          if (*v27)
          {
            if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
          }
        }
        v27 += 3;
        v28 -= 24;
      }
      while (v28);
      uint64_t v26 = v38[0];
      uint64_t v30 = 24 * v39;
    }
    else
    {
      uint64_t v30 = 0;
    }
    llvm::deallocate_buffer(v26, (void *)v30);
  }
  return 1;
}

void std::__shared_ptr_emplace<mlir::anec::FunctionConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3239F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::anec::FunctionConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3239F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21667D3C0);
}

void std::__shared_ptr_emplace<mlir::anec::FunctionConversionInfo>::__on_zero_shared(uint64_t a1)
{
}

void mlir::anec::FunctionConversionInfo::~FunctionConversionInfo(mlir::anec::FunctionConversionInfo *this)
{
  unint64_t v2 = (char *)*((void *)this + 11);
  uint64_t v3 = *((unsigned int *)this + 24);
  if (v3)
  {
    uint64_t v4 = v2 - 8;
    uint64_t v5 = 16 * v3;
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)&v4[v5];
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      v5 -= 16;
    }
    while (v5);
    unint64_t v2 = (char *)*((void *)this + 11);
  }
  if (v2 != (char *)this + 104) {
    free(v2);
  }
  llvm::deallocate_buffer(*((llvm **)this + 8), (void *)(8 * *((unsigned int *)this + 20)));
}

void sub_2119178DC()
{
  llvm::deallocate_buffer(*(llvm **)(v0 + 40), (void *)(8 * *(unsigned int *)(v0 + 56)));
}

void sub_2119178F0()
{
  llvm::deallocate_buffer(*(llvm **)(v0 + 16), (void *)(8 * *(unsigned int *)(v0 + 32)));
}

uint64_t sub_211917904()
{
  return v0;
}

void mlir::OpBuilder::Listener::~Listener(mlir::OpBuilder::Listener *this)
{
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anonymous namespace'::MPSToANECMin::basicMPSToANECConversion(mlir::func::FuncOp,mlir::RegionOpCreator *,mlir::CostModelParams const*,mlir::anec::FunctionConversionInfo *,mlir::anec::ANECIRWeights &)::{lambda(mlir::Operation *)#1}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v69 = a2;
  uint64_t v4 = **a1;
  uint64_t v5 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v5);
  if (v4 == a2 || (result & 1) != 0) {
    return result;
  }
  uint64_t v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v7))
  {
    uint64_t v8 = a1[2];
    uint64_t v9 = *a1[1];
    uint64_t v12 = *(void *)(v9 + 64);
    uint64_t v10 = v9 + 64;
    uint64_t v11 = v12;
    int v13 = *(_DWORD *)(v10 + 16);
    if (v13)
    {
      int v14 = v13 - 1;
      unsigned int v15 = (37 * *v8) & v14;
      __int16 v16 = (uint64_t *)(v11 + 8 * v15);
      uint64_t v17 = *v16;
      if (*v8 == *v16) {
        goto LABEL_17;
      }
      uint64_t v18 = 0;
      int v19 = 1;
      while (v17 != -1)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          uint64_t v18 = v16;
        }
        unsigned int v21 = v15 + v19++;
        unsigned int v15 = v21 & v14;
        __int16 v16 = (uint64_t *)(v11 + 8 * v15);
        uint64_t v17 = *v16;
        if (*v8 == *v16) {
          goto LABEL_17;
        }
      }
      if (v18) {
        uint64_t v22 = v18;
      }
      else {
        uint64_t v22 = v16;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    llvm::DenseMapBase<llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>,unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::InsertIntoBucket<unsigned long const&,llvm::detail::DenseSetEmpty&>(v10, v22, v8);
  }
LABEL_17:
  uint64_t v23 = a1[2];
  uint64_t v24 = (*v23)++;
  uint64_t result = (uint64_t)a1[3];
  int v25 = *(_DWORD *)(result + 16);
  if (!v25)
  {
    uint64_t v35 = 0;
LABEL_29:
    uint64_t result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,unsigned long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long>>,mlir::Operation *,unsigned long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long>>::InsertIntoBucket<mlir::Operation * const&>(result, v35, &v69);
    uint64_t v29 = (uint64_t *)result;
    uint64_t v26 = v69;
    goto LABEL_30;
  }
  uint64_t v26 = v69;
  int v27 = v25 - 1;
  unsigned int v28 = ((v69 >> 4) ^ (v69 >> 9)) & (v25 - 1);
  uint64_t v29 = (uint64_t *)(*(void *)result + 16 * v28);
  uint64_t v30 = *v29;
  if (v69 != *v29)
  {
    __int16 v31 = 0;
    int v32 = 1;
    while (v30 != -4096)
    {
      if (v31) {
        BOOL v33 = 0;
      }
      else {
        BOOL v33 = v30 == -8192;
      }
      if (v33) {
        __int16 v31 = v29;
      }
      unsigned int v34 = v28 + v32++;
      unsigned int v28 = v34 & v27;
      uint64_t v29 = (uint64_t *)(*(void *)result + 16 * (v34 & v27));
      uint64_t v30 = *v29;
      if (v69 == *v29) {
        goto LABEL_30;
      }
    }
    if (v31) {
      uint64_t v35 = v31;
    }
    else {
      uint64_t v35 = v29;
    }
    goto LABEL_29;
  }
LABEL_30:
  v29[1] = v24;
  if ((*(unsigned char *)(v26 + 46) & 0x80) != 0 && (uint64_t v36 = *(unsigned int *)(v26 + 68), v36))
  {
    uint64_t v37 = v36 - 1;
    uint64_t v38 = *(void *)(v26 + 72) + 24;
    while (1)
    {
      uint64_t v39 = v37;
      unint64_t v40 = *(void *)(*(void *)v38 + 8) & 0xFFFFFFFFFFFFFFF8;
      if (*(_UNKNOWN **)(*(void *)v40 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        unint64_t v40 = 0;
      }
      unint64_t v70 = v40;
      if (!v40) {
        break;
      }
      uint64_t result = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
      BOOL v42 = v41 > 5;
      if (v41 <= 5)
      {
        uint64_t v37 = v39 - 1;
        v38 += 32;
        if (v39) {
          continue;
        }
      }
      goto LABEL_41;
    }
    BOOL v42 = 1;
  }
  else
  {
    BOOL v42 = 0;
  }
LABEL_41:
  uint64_t v43 = *(unsigned int *)(v69 + 36);
  if (v43) {
    uint64_t v44 = v69 - 16;
  }
  else {
    uint64_t v44 = 0;
  }
  if (v43)
  {
    uint64_t v45 = 0;
    while (1)
    {
      uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v44, v45);
      unint64_t v46 = *(void *)(result + 8) & 0xFFFFFFFFFFFFFFF8;
      if (*(_UNKNOWN **)(*(void *)v46 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        unint64_t v46 = 0;
      }
      unint64_t v70 = v46;
      if (!v46) {
        break;
      }
      uint64_t result = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
      if (v47 >= 6) {
        break;
      }
      if (v43 == ++v45) {
        goto LABEL_51;
      }
    }
  }
  else
  {
LABEL_51:
    if (!v42) {
      return result;
    }
  }
  uint64_t v48 = *a1[1];
  uint64_t v49 = a1[3];
  uint64_t v50 = *v49;
  uint64_t v51 = *((unsigned int *)v49 + 4);
  if (!v51) {
    goto LABEL_58;
  }
  LODWORD(v52) = ((v69 >> 4) ^ (v69 >> 9)) & (v51 - 1);
  int v53 = (uint64_t *)(v50 + 16 * v52);
  uint64_t v54 = *v53;
  if (*v53 != v69)
  {
    int v55 = 1;
    while (v54 != -4096)
    {
      int v56 = v52 + v55++;
      uint64_t v52 = v56 & (v51 - 1);
      uint64_t v54 = *(void *)(v50 + 16 * v52);
      if (v54 == v69)
      {
        int v53 = (uint64_t *)(v50 + 16 * v52);
        goto LABEL_59;
      }
    }
LABEL_58:
    int v53 = (uint64_t *)(v50 + 16 * v51);
  }
LABEL_59:
  char v57 = v53 + 1;
  int v58 = *(_DWORD *)(v48 + 32);
  if (v58)
  {
    uint64_t v59 = *(void *)(v48 + 16);
    int v60 = v58 - 1;
    unsigned int v61 = (37 * *v57) & v60;
    uint64_t v62 = (uint64_t *)(v59 + 8 * v61);
    uint64_t v63 = *v62;
    if (*v57 == *v62) {
      return result;
    }
    unint64_t v64 = 0;
    int v65 = 1;
    while (v63 != -1)
    {
      if (v64) {
        BOOL v66 = 0;
      }
      else {
        BOOL v66 = v63 == -2;
      }
      if (v66) {
        unint64_t v64 = v62;
      }
      unsigned int v67 = v61 + v65++;
      unsigned int v61 = v67 & v60;
      uint64_t v62 = (uint64_t *)(v59 + 8 * v61);
      uint64_t v63 = *v62;
      if (*v57 == *v62) {
        return result;
      }
    }
    if (v64) {
      uint64_t v68 = v64;
    }
    else {
      uint64_t v68 = v62;
    }
  }
  else
  {
    uint64_t v68 = 0;
  }
  return (uint64_t)llvm::DenseMapBase<llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>,unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::InsertIntoBucket<unsigned long const&,llvm::detail::DenseSetEmpty&>(v48 + 16, v68, v57);
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>,unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::InsertIntoBucket<unsigned long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = (37 * *a3) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 8 * v11);
  uint64_t v12 = *a2;
  if (*a3 != *a2)
  {
    int v13 = 0;
    int v14 = 1;
    while (v12 != -1)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -2;
      }
      if (v15) {
        int v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 8 * (v16 & v10));
      uint64_t v12 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  return a2;
}

char *llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11) {
      memset(result, 255, 8 * v11);
    }
    if (v3)
    {
      int v12 = 0;
      int v13 = v11 - 1;
      int v14 = v4;
      do
      {
        uint64_t v17 = *(void *)v14;
        if (*(void *)v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unsigned int v18 = (37 * v17) & v13;
          unsigned int v16 = &v10[8 * v18];
          uint64_t v19 = *(void *)v16;
          if (v17 != *(void *)v16)
          {
            BOOL v20 = 0;
            int v21 = 1;
            while (v19 != -1)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -2;
              }
              if (v22) {
                BOOL v20 = v16;
              }
              unsigned int v23 = v18 + v21++;
              unsigned int v18 = v23 & v13;
              unsigned int v16 = &v10[8 * (v23 & v13)];
              uint64_t v19 = *(void *)v16;
              if (v17 == *(void *)v16) {
                goto LABEL_16;
              }
            }
            if (v20) {
              unsigned int v16 = v20;
            }
          }
LABEL_16:
          *(void *)unsigned int v16 = v17;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        int v14 = (llvm *)((char *)v14 + 8);
      }
      while (v14 != (llvm *)((char *)v4 + 8 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(8 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 16);
  if (v15)
  {
    return (char *)memset(result, 255, 8 * v15);
  }
  return result;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,unsigned long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long>>,mlir::Operation *,unsigned long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long>>::InsertIntoBucket<mlir::Operation * const&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::Operation *,unsigned long,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,unsigned long>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a2;
  if (*a3 != *a2)
  {
    int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        int v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 16 * (v16 & v10));
      uint64_t v12 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  a2[1] = 0;
  return a2;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anonymous namespace'::MPSToANECMin::basicMPSToANECConversion(mlir::func::FuncOp,mlir::RegionOpCreator *,mlir::CostModelParams const*,mlir::anec::FunctionConversionInfo *,mlir::anec::ANECIRWeights &)::{lambda(mlir::Operation *)#2}>(mlir::Block ***a1, uint64_t a2)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  uint64_t v4 = **a1;
  if (v4) {
    uint64_t InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)**a1);
  }
  else {
    uint64_t InterfaceFor = 0;
  }
  if (!mlir::collect_regions::detail::verifyShouldAddToQueue(v4, InterfaceFor, (uint64_t)*a1[1], a2, 0))
  {
    uint64_t v36 = a1[2];
    int v37 = *((_DWORD *)v36 + 4);
    if (!v37) {
      return;
    }
    uint64_t v38 = *v36;
    unsigned int v39 = (a2 >> 4) ^ (a2 >> 9);
    int v40 = v37 - 1;
    unsigned int v41 = v40 & v39;
    uint64_t v42 = *((void *)v38 + 2 * (v40 & v39));
    if (v42 != a2)
    {
      int v99 = 1;
      while (v42 != -4096)
      {
        unsigned int v100 = v41 + v99++;
        unsigned int v41 = v100 & v40;
        uint64_t v42 = *((void *)v38 + 2 * v41);
        if (v42 == a2) {
          goto LABEL_57;
        }
      }
      return;
    }
LABEL_57:
    if ((*(uint64_t (**)(void, uint64_t))(*(void *)*a1[1] + 24))(*a1[1], a2)) {
      return;
    }
    uint64_t v43 = a1[2];
    uint64_t v44 = (uint64_t)*a1[3];
    uint64_t v45 = *v43;
    uint64_t v46 = *((unsigned int *)v43 + 4);
    if (v46)
    {
      LODWORD(v47) = (v46 - 1) & v39;
      uint64_t v48 = (uint64_t *)((char *)v45 + 16 * v47);
      uint64_t v49 = *v48;
      if (*v48 == a2) {
        goto LABEL_75;
      }
      int v50 = 1;
      while (v49 != -4096)
      {
        int v51 = v47 + v50++;
        uint64_t v47 = v51 & (v46 - 1);
        uint64_t v49 = *((void *)v45 + 2 * v47);
        if (v49 == a2)
        {
          uint64_t v48 = (uint64_t *)((char *)v45 + 16 * v47);
          goto LABEL_75;
        }
      }
    }
    uint64_t v48 = (uint64_t *)((char *)v45 + 16 * v46);
LABEL_75:
    int v60 = v48 + 1;
    int v61 = *(_DWORD *)(v44 + 32);
    if (v61)
    {
      uint64_t v62 = *(void *)(v44 + 16);
      int v63 = v61 - 1;
      unsigned int v64 = (37 * *v60) & v63;
      int v65 = (uint64_t *)(v62 + 8 * v64);
      uint64_t v66 = *v65;
      if (*v60 == *v65) {
        goto LABEL_88;
      }
      unsigned int v67 = 0;
      int v68 = 1;
      while (v66 != -1)
      {
        if (v67) {
          BOOL v69 = 0;
        }
        else {
          BOOL v69 = v66 == -2;
        }
        if (v69) {
          unsigned int v67 = v65;
        }
        unsigned int v70 = v64 + v68++;
        unsigned int v64 = v70 & v63;
        int v65 = (uint64_t *)(v62 + 8 * v64);
        uint64_t v66 = *v65;
        if (*v60 == *v65) {
          goto LABEL_88;
        }
      }
      if (v67) {
        unint64_t v71 = v67;
      }
      else {
        unint64_t v71 = v65;
      }
    }
    else
    {
      unint64_t v71 = 0;
    }
    llvm::DenseMapBase<llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>,unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::InsertIntoBucket<unsigned long const&,llvm::detail::DenseSetEmpty&>(v44 + 16, v71, v60);
LABEL_88:
    if ((*(unsigned char *)(a2 + 46) & 0x80) == 0) {
      return;
    }
    uint64_t v72 = *(unsigned int *)(a2 + 68);
    if (!v72) {
      return;
    }
    uint64_t v73 = 0;
    uint64_t v74 = *(void *)(a2 + 72);
    while (1)
    {
      __p[0] = *(void **)(v74 + 32 * v73 + 24);
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)__p);
      if (!DefiningOp) {
        goto LABEL_92;
      }
      uint64_t v81 = DefiningOp;
      uint64_t v82 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v81 + 48) + 32))(*(void *)(v81 + 48), v82))goto LABEL_92; {
      int64_t v83 = a1[2];
      }
      uint64_t v84 = *v83;
      uint64_t v85 = *((unsigned int *)v83 + 4);
      if (v85)
      {
        LODWORD(v86) = (v85 - 1) & ((v81 >> 4) ^ (v81 >> 9));
        int64_t v87 = (uint64_t *)((char *)v84 + 16 * v86);
        uint64_t v88 = *v87;
        if (*v87 == v81) {
          goto LABEL_102;
        }
        int v89 = 1;
        while (v88 != -4096)
        {
          int v90 = v86 + v89++;
          uint64_t v86 = v90 & (v85 - 1);
          uint64_t v88 = *((void *)v84 + 2 * v86);
          if (v88 == v81)
          {
            int64_t v87 = (uint64_t *)((char *)v84 + 16 * v86);
            goto LABEL_102;
          }
        }
      }
      int64_t v87 = (uint64_t *)((char *)v84 + 16 * v85);
LABEL_102:
      uint64_t v91 = (uint64_t)*a1[3];
      uint64_t v92 = v87 + 1;
      int v93 = *(_DWORD *)(v91 + 32);
      if (!v93)
      {
        uint64_t v94 = 0;
LABEL_104:
        llvm::DenseMapBase<llvm::DenseMap<unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>,unsigned long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned long,void>,llvm::detail::DenseSetPair<unsigned long>>::InsertIntoBucket<unsigned long const&,llvm::detail::DenseSetEmpty&>(v91 + 16, v94, v92);
        goto LABEL_92;
      }
      uint64_t v75 = *(void *)(v91 + 16);
      int v76 = v93 - 1;
      unsigned int v77 = (37 * *v92) & v76;
      unint64_t v78 = (uint64_t *)(v75 + 8 * v77);
      uint64_t v79 = *v78;
      if (*v92 != *v78)
      {
        uint64_t v95 = 0;
        int v96 = 1;
        while (v79 != -1)
        {
          if (v95) {
            BOOL v97 = 0;
          }
          else {
            BOOL v97 = v79 == -2;
          }
          if (v97) {
            uint64_t v95 = v78;
          }
          unsigned int v98 = v77 + v96++;
          unsigned int v77 = v98 & v76;
          unint64_t v78 = (uint64_t *)(v75 + 8 * v77);
          uint64_t v79 = *v78;
          if (*v92 == *v78) {
            goto LABEL_92;
          }
        }
        if (v95) {
          uint64_t v94 = v95;
        }
        else {
          uint64_t v94 = v78;
        }
        goto LABEL_104;
      }
LABEL_92:
      if (++v73 == v72) {
        return;
      }
    }
  }
  unint64_t v107 = v109;
  uint64_t v108 = 0x600000000;
  if (*(_UNKNOWN **)(*(void *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
  {
LABEL_6:
    v104[0] = (llvm *)a2;
    *(_OWORD *)__p = 0u;
    long long v111 = 0u;
    *(_OWORD *)BOOL v112 = 0u;
    std::deque<mlir::Operation *>::__append_with_size[abi:nn180100]<mlir::Operation * const*>(__p, (uint64_t *)v104, 1uLL);
    unint64_t v101 = (llvm *)a2;
    llvm::detail::DenseSetImpl<mlir::Operation *,llvm::DenseMap<mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>,llvm::DenseMapInfo<mlir::Operation *,void>>::DenseSetImpl((uint64_t)v104, (uint64_t *)&v101, 1);
    int v6 = v112[1];
    if (!v112[1])
    {
LABEL_49:
      if (v108)
      {
        int v32 = (char *)v107 + 8 * v108 - 8;
        if (v32 > v107)
        {
          BOOL v33 = (char *)v107 + 8;
          do
          {
            uint64_t v34 = *((void *)v33 - 1);
            *((void *)v33 - 1) = *(void *)v32;
            *(void *)int v32 = v34;
            v32 -= 8;
            BOOL v35 = v33 >= v32;
            v33 += 8;
          }
          while (!v35);
        }
      }
      llvm::deallocate_buffer(v104[0], (void *)(8 * v105));
    }
    while (1)
    {
      uint64_t v7 = *(void *)(*(void *)((char *)__p[1] + (((unint64_t)v112[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * ((uint64_t)v112[0] & 0x1FF));
      v112[1] = (mlir::Operation *)((char *)v6 - 1);
      if (++v112[0] >= (mlir::Operation *)0x400)
      {
        operator delete(*(void **)__p[1]);
        __p[1] = (char *)__p[1] + 8;
        v112[0] = (mlir::Operation *)((char *)v112[0] - 512);
      }
      uint64_t v8 = v108;
      if (v108 >= (unint64_t)HIDWORD(v108))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v107, v109, v108 + 1, 8);
        uint64_t v8 = v108;
      }
      *((void *)v107 + v8) = v7;
      LODWORD(v108) = v108 + 1;
      if ((*(unsigned char *)(v7 + 46) & 0x80) != 0)
      {
        uint64_t v9 = *(unsigned int *)(v7 + 68);
        if (v9) {
          break;
        }
      }
LABEL_8:
      int v6 = v112[1];
      if (!v112[1]) {
        goto LABEL_49;
      }
    }
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(v7 + 72);
    while (1)
    {
      unint64_t v101 = *(llvm **)(v11 + 32 * v10 + 24);
      int v103 = 0;
      BOOL v15 = (void *)mlir::Value::getDefiningOp((mlir::Value *)&v101);
      int v103 = v15;
      if (!v15) {
        goto LABEL_17;
      }
      unsigned int v16 = (void **)v15;
      if (v105)
      {
        LODWORD(v17) = (v105 - 1) & ((v15 >> 4) ^ (v15 >> 9));
        unsigned int v18 = (llvm *)((char *)v104[0] + 8 * v17);
        uint64_t v19 = *(void **)v18;
        if (*(void **)v18 != v15)
        {
          int v20 = 1;
          do
          {
            if (v19 == (void *)-4096) {
              goto LABEL_25;
            }
            int v21 = v17 + v20++;
            uint64_t v17 = v21 & (v105 - 1);
            uint64_t v19 = (void *)*((void *)v104[0] + v17);
          }
          while (v19 != v15);
          unsigned int v18 = (llvm *)((char *)v104[0] + 8 * v17);
        }
      }
      else
      {
LABEL_25:
        unsigned int v18 = (llvm *)((char *)v104[0] + 8 * v105);
      }
      if (v18 != (llvm *)((char *)v104[0] + 8 * v105)) {
        goto LABEL_17;
      }
      uint64_t v22 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if (((*(uint64_t (**)(void *, uint64_t))(*v16[6] + 32))(v16[6], v22) & 1) == 0
        && *(_UNKNOWN **)(*((void *)v103 + 6) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
      {
        goto LABEL_17;
      }
      unsigned int v23 = (char *)__p[1];
      if ((void *)v111 == __p[1]) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = (mlir::Operation *)((((void)v111 - (unint64_t)__p[1]) << 6) - 1);
      }
      int v25 = v112[1];
      unint64_t v26 = (unint64_t)v112[1] + (unint64_t)v112[0];
      if (v24 == (mlir::Operation *)((char *)v112[1] + (unint64_t)v112[0]))
      {
        std::deque<mlir::Operation *>::__add_back_capacity((uint64_t)__p);
        int v25 = v112[1];
        unsigned int v23 = (char *)__p[1];
        unint64_t v26 = (unint64_t)v112[0] + (unint64_t)v112[1];
      }
      *(void *)(*(void *)&v23[(v26 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v26 & 0x1FF)) = v103;
      v112[1] = (mlir::Operation *)((char *)v25 + 1);
      if (!v105) {
        break;
      }
      unsigned int v12 = ((v103 >> 4) ^ (v103 >> 9)) & (v105 - 1);
      int v13 = (uint64_t *)((char *)v104[0] + 8 * v12);
      int v14 = (void *)*v13;
      if (v103 != (void *)*v13)
      {
        unsigned int v28 = 0;
        int v29 = 1;
        while (v14 != (void *)-4096)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v14 == (void *)-8192;
          }
          if (v30) {
            unsigned int v28 = v13;
          }
          unsigned int v31 = v12 + v29++;
          unsigned int v12 = v31 & (v105 - 1);
          int v13 = (uint64_t *)((char *)v104[0] + 8 * v12);
          int v14 = (void *)*v13;
          if (v103 == (void *)*v13) {
            goto LABEL_17;
          }
        }
        if (v28) {
          int v27 = v28;
        }
        else {
          int v27 = v13;
        }
        goto LABEL_36;
      }
LABEL_17:
      if (++v10 == v9) {
        goto LABEL_8;
      }
    }
    int v27 = 0;
LABEL_36:
    llvm::DenseMapBase<llvm::DenseMap<void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>,void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>::InsertIntoBucket<void const*,llvm::detail::DenseSetEmpty&>((uint64_t)v104, v27, (uint64_t *)&v103);
    goto LABEL_17;
  }
  uint64_t v52 = *(unsigned int *)(a2 + 36);
  if (v52) {
    int v53 = (llvm *)(a2 - 16);
  }
  else {
    int v53 = 0;
  }
  unint64_t v101 = v53;
  uint64_t v102 = v52;
  mlir::ResultRange::use_begin((uint64_t *)&v101, (uint64_t *)v104);
  uint64_t v54 = *(unsigned int *)(a2 + 36);
  if (v54) {
    int v55 = (llvm *)(a2 - 16);
  }
  else {
    int v55 = 0;
  }
  unint64_t v101 = v55;
  uint64_t v102 = v54;
  mlir::ResultRange::use_end((uint64_t *)&v101, (uint64_t *)&v112[1]);
  int v56 = v106;
  v112[0] = v106;
  *(_OWORD *)__p = *(_OWORD *)v104;
  long long v111 = v105;
  for (int i = v113; v106 != i; v56 = v106)
  {
    uint64_t v58 = *((void *)v56 + 2);
    uint64_t v59 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
    if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v58 + 48) + 32))(*(void *)(v58 + 48), v59)) {
      goto LABEL_6;
    }
    mlir::ResultRange::UseIterator::operator++((uint64_t *)v104);
  }
  if (v107 != v109) {
    free(v107);
  }
}

void std::deque<mlir::Operation *>::__append_with_size[abi:nn180100]<mlir::Operation * const*>(void *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  if (v7 == v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = ((v7 - v6) << 6) - 1;
  }
  uint64_t v9 = a1[5];
  unint64_t v10 = v9 + a1[4];
  unint64_t v11 = v8 - v10;
  if (a3 > v11)
  {
    std::deque<mlir::Operation *>::__add_back_capacity((uint64_t)a1, a3 - v11);
    uint64_t v9 = a1[5];
    uint64_t v6 = a1[1];
    uint64_t v7 = a1[2];
    unint64_t v10 = a1[4] + v9;
  }
  unsigned int v12 = (void *)(v6 + 8 * (v10 >> 9));
  if (v7 == v6)
  {
    uint64_t v13 = 0;
    if (!a3) {
      return;
    }
  }
  else
  {
    uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
    if (!a3) {
      return;
    }
  }
  uint64_t v14 = a3 + ((v13 - *v12) >> 3);
  if (v14 < 1)
  {
    unint64_t v16 = 511 - v14;
    LOWORD(v14) = ~(511 - v14);
    BOOL v15 = &v12[-(v16 >> 9)];
  }
  else
  {
    BOOL v15 = &v12[(unint64_t)v14 >> 9];
  }
  uint64_t v17 = *v15 + 8 * (v14 & 0x1FF);
  if (v13 != v17)
  {
    while (1)
    {
      uint64_t v18 = v17;
      if (v12 != v15) {
        uint64_t v18 = *v12 + 4096;
      }
      if (v13 == v18)
      {
        uint64_t v18 = v13;
        goto LABEL_27;
      }
      unint64_t v19 = v18 - v13 - 8;
      if (v19 < 0x18 || (unint64_t)(v13 - (void)a2) < 0x20)
      {
        uint64_t v22 = a2;
        unsigned int v23 = (void *)v13;
      }
      else
      {
        uint64_t v20 = (v19 >> 3) + 1;
        uint64_t v21 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v22 = &a2[v21];
        unsigned int v23 = (void *)(v13 + v21 * 8);
        uint64_t v24 = (_OWORD *)(v13 + 16);
        int v25 = (long long *)(a2 + 2);
        uint64_t v26 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v27 = *v25;
          *(v24 - 1) = *(v25 - 1);
          *uint64_t v24 = v27;
          v24 += 2;
          v25 += 2;
          v26 -= 4;
        }
        while (v26);
        if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_26;
        }
      }
      do
      {
        uint64_t v28 = *v22++;
        *v23++ = v28;
      }
      while (v23 != (void *)v18);
LABEL_26:
      a2 = v22;
LABEL_27:
      v9 += (v18 - v13) >> 3;
      if (v12 != v15)
      {
        uint64_t v29 = v12[1];
        ++v12;
        uint64_t v13 = v29;
        if (v29 != v17) {
          continue;
        }
      }
      a1[5] = v9;
      return;
    }
  }
}

void std::deque<mlir::Operation *>::__add_back_capacity(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(char **)(a1 + 16);
  uint64_t v4 = (uint64_t)&v3[-*(void *)(a1 + 8)];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = *(void *)(a1 + 32);
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    *(void *)(a1 + 32) = v7 - (v8 << 9);
    if (!v8) {
      return;
    }
    while (1)
    {
      BOOL v15 = *(void **)(a1 + 8);
      unint64_t v16 = (char *)(v15 + 1);
      uint64_t v17 = *v15;
      *(void *)(a1 + 8) = v15 + 1;
      if (v3 == *(char **)(a1 + 24))
      {
        uint64_t v18 = *(char **)a1;
        if ((unint64_t)v16 <= *(void *)a1)
        {
          unint64_t v24 = (v3 - v18) >> 2;
          if (v3 == v18) {
            unint64_t v24 = 1;
          }
          if (v24 >> 61) {
            goto LABEL_133;
          }
          unint64_t v25 = v24 >> 2;
          uint64_t v26 = 8 * v24;
          long long v27 = (char *)operator new(8 * v24);
          uint64_t v28 = &v27[8 * v25];
          int64_t v30 = v3 - v16;
          BOOL v29 = v3 == v16;
          uint64_t v3 = v28;
          if (!v29)
          {
            uint64_t v3 = &v28[v30 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v31 = v30 - 8;
            if ((unint64_t)(v30 - 8) < 0x38)
            {
              int v32 = &v27[8 * v25];
              goto LABEL_39;
            }
            int v32 = &v27[8 * v25];
            if ((unint64_t)(v32 - v16) < 0x20) {
              goto LABEL_136;
            }
            uint64_t v33 = (v31 >> 3) + 1;
            uint64_t v34 = 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
            int v32 = &v28[v34];
            v16 += v34;
            BOOL v35 = (long long *)(v15 + 3);
            uint64_t v36 = &v27[8 * v25 + 16];
            uint64_t v37 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v38 = *v35;
              *((_OWORD *)v36 - 1) = *(v35 - 1);
              *(_OWORD *)uint64_t v36 = v38;
              v35 += 2;
              v36 += 32;
              v37 -= 4;
            }
            while (v37);
            if (v33 != (v33 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_136:
              do
              {
LABEL_39:
                uint64_t v39 = *(void *)v16;
                v16 += 8;
                *(void *)int v32 = v39;
                v32 += 8;
              }
              while (v32 != v3);
            }
          }
          *(void *)a1 = v27;
          *(void *)(a1 + 8) = v28;
          *(void *)(a1 + 16) = v3;
          *(void *)(a1 + 24) = &v27[v26];
          if (v18)
          {
            operator delete(v18);
            uint64_t v3 = *(char **)(a1 + 16);
          }
          goto LABEL_21;
        }
        uint64_t v19 = (uint64_t)&v16[-*(void *)a1] >> 3;
        if (v19 >= -1) {
          uint64_t v20 = v19 + 1;
        }
        else {
          uint64_t v20 = v19 + 2;
        }
        uint64_t v21 = v20 >> 1;
        uint64_t v22 = &v16[-8 * (v20 >> 1)];
        int64_t v23 = v3 - v16;
        if (v3 != v16)
        {
          memmove(&v16[-8 * (v20 >> 1)], v16, v3 - v16);
          uint64_t v3 = *(char **)(a1 + 8);
        }
        uint64_t v14 = &v3[-8 * v21];
        uint64_t v3 = &v22[v23];
        *(void *)(a1 + 8) = v14;
        *(void *)(a1 + 16) = &v22[v23];
      }
LABEL_21:
      *(void *)uint64_t v3 = v17;
      uint64_t v3 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v3;
      if (!--v8) {
        return;
      }
    }
  }
  unint64_t v9 = v6 - v8;
  uint64_t v10 = *(void *)(a1 + 24) - *(void *)a1;
  uint64_t v11 = v4 >> 3;
  if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
  {
    if (v9)
    {
      while (*(void *)(a1 + 24) != *(void *)(a1 + 16))
      {
        *(void *)&long long v126 = operator new(0x1000uLL);
        std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v126);
        --v6;
        if (!--v9) {
          goto LABEL_107;
        }
      }
      for (uint64_t i = 0; i != v9; ++i)
      {
        *(void *)&long long v126 = operator new(0x1000uLL);
        std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v126);
        if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
          uint64_t v98 = 511;
        }
        else {
          uint64_t v98 = 512;
        }
        uint64_t v99 = v98 + *(void *)(a1 + 32);
        *(void *)(a1 + 32) = v99;
      }
      unint64_t v8 = v6;
    }
    else
    {
LABEL_107:
      uint64_t v99 = *(void *)(a1 + 32);
    }
    *(void *)(a1 + 32) = v99 - (v8 << 9);
    if (!v8) {
      return;
    }
    unsigned int v100 = *(char **)(a1 + 16);
    while (1)
    {
      uint64_t v102 = *(void **)(a1 + 8);
      int v103 = (char *)(v102 + 1);
      uint64_t v104 = *v102;
      *(void *)(a1 + 8) = v102 + 1;
      if (v100 == *(char **)(a1 + 24))
      {
        long long v105 = *(char **)a1;
        if ((unint64_t)v103 <= *(void *)a1)
        {
          unint64_t v111 = (v100 - v105) >> 2;
          if (v100 == v105) {
            unint64_t v111 = 1;
          }
          if (v111 >> 61) {
            goto LABEL_133;
          }
          unint64_t v112 = v111 >> 2;
          uint64_t v113 = 8 * v111;
          uint64_t v114 = (char *)operator new(8 * v111);
          unint64_t v115 = &v114[8 * v112];
          int64_t v116 = v100 - v103;
          BOOL v29 = v100 == v103;
          unsigned int v100 = v115;
          if (!v29)
          {
            unsigned int v100 = &v115[v116 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v117 = v116 - 8;
            if ((unint64_t)(v116 - 8) < 0x38)
            {
              BOOL v118 = &v114[8 * v112];
              goto LABEL_129;
            }
            BOOL v118 = &v114[8 * v112];
            if ((unint64_t)(v118 - v103) < 0x20) {
              goto LABEL_137;
            }
            uint64_t v119 = (v117 >> 3) + 1;
            uint64_t v120 = 8 * (v119 & 0x3FFFFFFFFFFFFFFCLL);
            BOOL v118 = &v115[v120];
            v103 += v120;
            int64_t v121 = (long long *)(v102 + 3);
            int64_t v122 = &v114[8 * v112 + 16];
            uint64_t v123 = v119 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v124 = *v121;
              *((_OWORD *)v122 - 1) = *(v121 - 1);
              *(_OWORD *)int64_t v122 = v124;
              v121 += 2;
              v122 += 32;
              v123 -= 4;
            }
            while (v123);
            if (v119 != (v119 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_137:
              do
              {
LABEL_129:
                uint64_t v125 = *(void *)v103;
                v103 += 8;
                *(void *)BOOL v118 = v125;
                v118 += 8;
              }
              while (v118 != v100);
            }
          }
          *(void *)a1 = v114;
          *(void *)(a1 + 8) = v115;
          *(void *)(a1 + 16) = v100;
          *(void *)(a1 + 24) = &v114[v113];
          if (v105)
          {
            operator delete(v105);
            unsigned int v100 = *(char **)(a1 + 16);
          }
          goto LABEL_111;
        }
        uint64_t v106 = (uint64_t)&v103[-*(void *)a1] >> 3;
        if (v106 >= -1) {
          uint64_t v107 = v106 + 1;
        }
        else {
          uint64_t v107 = v106 + 2;
        }
        uint64_t v108 = v107 >> 1;
        unint64_t v109 = &v103[-8 * (v107 >> 1)];
        int64_t v110 = v100 - v103;
        if (v100 != v103)
        {
          memmove(&v103[-8 * (v107 >> 1)], v103, v100 - v103);
          unsigned int v100 = *(char **)(a1 + 8);
        }
        unint64_t v101 = &v100[-8 * v108];
        unsigned int v100 = &v109[v110];
        *(void *)(a1 + 8) = v101;
        *(void *)(a1 + 16) = &v109[v110];
      }
LABEL_111:
      *(void *)unsigned int v100 = v104;
      unsigned int v100 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v100;
      if (!--v8) {
        return;
      }
    }
  }
  if (v10 >> 2 <= v9 + v11) {
    unint64_t v12 = v9 + v11;
  }
  else {
    unint64_t v12 = v10 >> 2;
  }
  uint64_t v129 = a1 + 24;
  if (v12)
  {
    if (v12 >> 61) {
LABEL_133:
    }
      std::__throw_bad_array_new_length[abi:nn180100]();
    uint64_t v13 = (char *)operator new(8 * v12);
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v40 = v8 << 9;
  unsigned int v41 = &v13[8 * (v11 - v8)];
  *(void *)&long long v126 = v13;
  *((void *)&v126 + 1) = v41;
  int64_t v127 = v41;
  int64_t v128 = &v13[8 * v12];
  do
  {
    uint64_t v43 = operator new(0x1000uLL);
    if (v41 != v128) {
      goto LABEL_49;
    }
    uint64_t v45 = (uint64_t *)*((void *)&v126 + 1);
    uint64_t v44 = (void *)v126;
    if (*((void *)&v126 + 1) > (unint64_t)v126)
    {
      uint64_t v46 = (uint64_t)(*((void *)&v126 + 1) - v126) >> 3;
      if (v46 >= -1) {
        uint64_t v47 = v46 + 1;
      }
      else {
        uint64_t v47 = v46 + 2;
      }
      uint64_t v48 = v47 >> 1;
      uint64_t v49 = *((void *)&v126 + 1) - 8 * (v47 >> 1);
      int v50 = &v41[-*((void *)&v126 + 1)];
      if (v41 != *((char **)&v126 + 1))
      {
        memmove((void *)(*((void *)&v126 + 1) - 8 * (v47 >> 1)), *((const void **)&v126 + 1), (size_t)&v41[-*((void *)&v126 + 1)]);
        unsigned int v41 = (char *)*((void *)&v126 + 1);
      }
      uint64_t v42 = &v41[-8 * v48];
      unsigned int v41 = &v50[v49];
      *((void *)&v126 + 1) = v42;
      int64_t v127 = &v50[v49];
      goto LABEL_49;
    }
    unint64_t v51 = (uint64_t)&v41[-v126] >> 2;
    if (v41 == (char *)v126) {
      unint64_t v51 = 1;
    }
    if (v51 >> 61) {
      goto LABEL_133;
    }
    unint64_t v52 = v51 >> 2;
    uint64_t v53 = 8 * v51;
    uint64_t v54 = (char *)operator new(8 * v51);
    int v55 = &v54[8 * v52];
    unint64_t v56 = (unint64_t)&v41[-*((void *)&v126 + 1)];
    BOOL v29 = v41 == *((char **)&v126 + 1);
    unsigned int v41 = v55;
    if (!v29)
    {
      unsigned int v41 = &v55[v56 & 0xFFFFFFFFFFFFFFF8];
      char v57 = (char *)(v56 - 8);
      if (v56 - 8 < 0x38)
      {
        uint64_t v58 = &v54[8 * v52];
        do
        {
LABEL_67:
          uint64_t v66 = *v45++;
          *(void *)uint64_t v58 = v66;
          v58 += 8;
        }
        while (v58 != v41);
        goto LABEL_68;
      }
      uint64_t v58 = &v54[8 * v52];
      if ((unint64_t)&v58[-*((void *)&v126 + 1)] < 0x20) {
        goto LABEL_67;
      }
      uint64_t v59 = ((unint64_t)v57 >> 3) + 1;
      uint64_t v60 = 8 * (v59 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v58 = &v55[v60];
      int v61 = (uint64_t *)(*((void *)&v126 + 1) + v60);
      uint64_t v62 = (long long *)(*((void *)&v126 + 1) + 16);
      int v63 = &v54[8 * v52 + 16];
      uint64_t v64 = v59 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v65 = *v62;
        *((_OWORD *)v63 - 1) = *(v62 - 1);
        *(_OWORD *)int v63 = v65;
        v62 += 2;
        v63 += 32;
        v64 -= 4;
      }
      while (v64);
      uint64_t v45 = v61;
      if (v59 != (v59 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_67;
      }
    }
LABEL_68:
    *(void *)&long long v126 = v54;
    *((void *)&v126 + 1) = &v54[8 * v52];
    int64_t v127 = v41;
    int64_t v128 = &v54[v53];
    if (v44) {
      operator delete(v44);
    }
LABEL_49:
    *(void *)unsigned int v41 = v43;
    unsigned int v41 = v127 + 8;
    v127 += 8;
    --v9;
  }
  while (v9);
  for (uint64_t j = *(char **)(a1 + 8); v8; --v8)
  {
    if (v41 == v128)
    {
      uint64_t v75 = (uint64_t *)*((void *)&v126 + 1);
      uint64_t v74 = (void *)v126;
      if (*((void *)&v126 + 1) <= (unint64_t)v126)
      {
        unint64_t v81 = (uint64_t)&v41[-v126] >> 2;
        if (v41 == (char *)v126) {
          unint64_t v81 = 1;
        }
        if (v81 >> 61) {
          goto LABEL_133;
        }
        unint64_t v82 = v81 >> 2;
        uint64_t v83 = 8 * v81;
        uint64_t v84 = (char *)operator new(8 * v81);
        uint64_t v85 = &v84[8 * v82];
        unint64_t v86 = (unint64_t)&v41[-*((void *)&v126 + 1)];
        BOOL v29 = v41 == *((char **)&v126 + 1);
        unsigned int v41 = v85;
        if (!v29)
        {
          unsigned int v41 = &v85[v86 & 0xFFFFFFFFFFFFFFF8];
          int64_t v87 = (char *)(v86 - 8);
          if (v86 - 8 < 0x38)
          {
            uint64_t v88 = &v84[8 * v82];
            goto LABEL_98;
          }
          uint64_t v88 = &v84[8 * v82];
          if ((unint64_t)&v88[-*((void *)&v126 + 1)] < 0x20) {
            goto LABEL_138;
          }
          uint64_t v89 = ((unint64_t)v87 >> 3) + 1;
          uint64_t v90 = 8 * (v89 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v88 = &v85[v90];
          uint64_t v91 = (uint64_t *)(*((void *)&v126 + 1) + v90);
          uint64_t v92 = (long long *)(*((void *)&v126 + 1) + 16);
          int v93 = &v84[8 * v82 + 16];
          uint64_t v94 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v95 = *v92;
            *((_OWORD *)v93 - 1) = *(v92 - 1);
            *(_OWORD *)int v93 = v95;
            v92 += 2;
            v93 += 32;
            v94 -= 4;
          }
          while (v94);
          uint64_t v75 = v91;
          if (v89 != (v89 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_138:
            do
            {
LABEL_98:
              uint64_t v96 = *v75++;
              *(void *)uint64_t v88 = v96;
              v88 += 8;
            }
            while (v88 != v41);
          }
        }
        *(void *)&long long v126 = v84;
        *((void *)&v126 + 1) = &v84[8 * v82];
        int64_t v127 = v41;
        int64_t v128 = &v84[v83];
        if (v74) {
          operator delete(v74);
        }
        goto LABEL_80;
      }
      uint64_t v76 = (uint64_t)(*((void *)&v126 + 1) - v126) >> 3;
      if (v76 >= -1) {
        uint64_t v77 = v76 + 1;
      }
      else {
        uint64_t v77 = v76 + 2;
      }
      uint64_t v78 = v77 >> 1;
      uint64_t v79 = *((void *)&v126 + 1) - 8 * (v77 >> 1);
      unint64_t v80 = &v41[-*((void *)&v126 + 1)];
      if (v41 != *((char **)&v126 + 1))
      {
        memmove((void *)(*((void *)&v126 + 1) - 8 * (v77 >> 1)), *((const void **)&v126 + 1), (size_t)&v41[-*((void *)&v126 + 1)]);
        unsigned int v41 = (char *)*((void *)&v126 + 1);
      }
      uint64_t v73 = &v41[-8 * v78];
      unsigned int v41 = &v80[v79];
      *((void *)&v126 + 1) = v73;
      int64_t v127 = &v80[v79];
    }
LABEL_80:
    *(void *)unsigned int v41 = *(void *)j;
    unsigned int v41 = v127 + 8;
    v127 += 8;
    uint64_t j = (char *)(*(void *)(a1 + 8) + 8);
    *(void *)(a1 + 8) = j;
  }
  int v68 = j;
  if (*(char **)(a1 + 16) != j)
  {
    int v68 = *(char **)(a1 + 16);
    do
    {
      v68 -= 8;
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)&v126, v68);
    }
    while (v68 != *(char **)(a1 + 8));
    uint64_t j = *(char **)(a1 + 16);
    unsigned int v41 = v127;
  }
  BOOL v69 = v128;
  unsigned int v70 = *(char **)(a1 + 24);
  uint64_t v71 = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = v41;
  *(void *)(a1 + 24) = v69;
  uint64_t v72 = *(char **)a1;
  *(_OWORD *)a1 = v126;
  *(void *)&long long v126 = v72;
  *((void *)&v126 + 1) = v68;
  int64_t v127 = j;
  int64_t v128 = v70;
  *(void *)(a1 + 32) = v71 - v40;
  if (j != v68) {
    int64_t v127 = &j[(v68 - j + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v72) {
    operator delete(v72);
  }
}

uint64_t llvm::detail::DenseSetImpl<mlir::Operation *,llvm::DenseMap<mlir::Operation *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseSetPair<mlir::Operation *>>,llvm::DenseMapInfo<mlir::Operation *,void>>::DenseSetImpl(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (!a3
    || (unint64_t v6 = (a3 - 1) | ((unint64_t)(a3 - 1) >> 1) | (((a3 - 1) | ((unint64_t)(a3 - 1) >> 1)) >> 2),
        unint64_t v7 = v6 | (v6 >> 4) | ((v6 | (v6 >> 4)) >> 8),
        LODWORD(v7) = ((v7 | (v7 >> 16)) >> 32) | v7 | (v7 >> 16),
        BOOL v8 = __CFADD__(v7, 1),
        int v9 = v7 + 1,
        v8))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  else
  {
    unint64_t v22 = (4 * v9 / 3u + 1) | ((unint64_t)(4 * v9 / 3u + 1) >> 1);
    unint64_t v23 = v22 | (v22 >> 2) | ((v22 | (v22 >> 2)) >> 4);
    LODWORD(v23) = (((v23 | (v23 >> 8)) >> 16) | v23 | (v23 >> 8)) + 1;
    *(_DWORD *)(a1 + 16) = v23;
    buffer = (int64x2_t *)llvm::allocate_buffer(8 * v23, (std::align_val_t)8uLL);
    *(void *)a1 = buffer;
    *(void *)(a1 + 8) = 0;
    uint64_t v25 = *(unsigned int *)(a1 + 16);
    if (!v25) {
      goto LABEL_6;
    }
    unint64_t v26 = (v25 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    long long v27 = (char *)buffer;
    if (v26 < 3) {
      goto LABEL_30;
    }
    unint64_t v28 = v26 + 1;
    long long v27 = &buffer->i8[8 * (v28 & 0x3FFFFFFFFFFFFFFCLL)];
    BOOL v29 = buffer + 1;
    int64x2_t v30 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v31 = v28 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v29[-1] = v30;
      *BOOL v29 = v30;
      v29 += 2;
      v31 -= 4;
    }
    while (v31);
    if (v28 != (v28 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_30:
      int v32 = &buffer->i8[8 * v25];
      do
      {
        *(void *)long long v27 = -4096;
        v27 += 8;
      }
      while (v27 != v32);
    }
  }
  if (a3)
  {
LABEL_6:
    uint64_t v10 = &a2[a3];
    while (1)
    {
      int v15 = *(_DWORD *)(a1 + 16);
      if (!v15) {
        break;
      }
      int v11 = v15 - 1;
      unsigned int v12 = ((*a2 >> 4) ^ (*a2 >> 9)) & v11;
      uint64_t v13 = (uint64_t *)(*(void *)a1 + 8 * v12);
      uint64_t v14 = *v13;
      if (*a2 != *v13)
      {
        uint64_t v17 = 0;
        int v18 = 1;
        while (v14 != -4096)
        {
          if (v17) {
            BOOL v19 = 0;
          }
          else {
            BOOL v19 = v14 == -8192;
          }
          if (v19) {
            uint64_t v17 = v13;
          }
          unsigned int v20 = v12 + v18++;
          unsigned int v12 = v20 & v11;
          uint64_t v13 = (uint64_t *)(*(void *)a1 + 8 * v12);
          uint64_t v14 = *v13;
          if (*a2 == *v13) {
            goto LABEL_8;
          }
        }
        if (v17) {
          unint64_t v16 = v17;
        }
        else {
          unint64_t v16 = v13;
        }
        goto LABEL_11;
      }
LABEL_8:
      if (++a2 == v10) {
        return a1;
      }
    }
    unint64_t v16 = 0;
LABEL_11:
    llvm::DenseMapBase<llvm::DenseMap<void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>,void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>::InsertIntoBucket<void const*,llvm::detail::DenseSetEmpty&>(a1, v16, a2);
    goto LABEL_8;
  }
  return a1;
}

void std::__shared_ptr_emplace<mlir::anec::RegionConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3239B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<mlir::anec::RegionConversionInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C3239B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x21667D3C0);
}

void std::__shared_ptr_emplace<mlir::anec::RegionConversionInfo>::__on_zero_shared(uint64_t a1)
{
}

void mlir::anec::RegionConversionInfo::~RegionConversionInfo(mlir::anec::RegionConversionInfo *this)
{
  unint64_t v2 = (char *)*((void *)this + 24);
  uint64_t v3 = *((unsigned int *)this + 50);
  if (v3)
  {
    uint64_t v4 = v2 - 8;
    uint64_t v5 = 16 * v3;
    do
    {
      unint64_t v6 = *(std::__shared_weak_count **)&v4[v5];
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      v5 -= 16;
    }
    while (v5);
    unint64_t v2 = (char *)*((void *)this + 24);
  }
  if (v2 != (char *)this + 208) {
    free(v2);
  }
  unint64_t v7 = (char *)*((void *)this + 16);
  if (v7 != (char *)this + 144) {
    free(v7);
  }
  BOOL v8 = (char *)*((void *)this + 8);
  uint64_t v9 = *((unsigned int *)this + 18);
  if (v9)
  {
    uint64_t v10 = v8 - 8;
    uint64_t v11 = 16 * v9;
    do
    {
      unsigned int v12 = *(std::__shared_weak_count **)&v10[v11];
      if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      v11 -= 16;
    }
    while (v11);
    BOOL v8 = (char *)*((void *)this + 8);
  }
  if (v8 != (char *)this + 80) {
    free(v8);
  }
  uint64_t v13 = *(char **)this;
  uint64_t v14 = *((unsigned int *)this + 2);
  if (v14)
  {
    int v15 = v13 - 8;
    uint64_t v16 = 16 * v14;
    do
    {
      uint64_t v17 = *(std::__shared_weak_count **)&v15[v16];
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
      v16 -= 16;
    }
    while (v16);
    uint64_t v13 = *(char **)this;
  }
  if (v13 != (char *)this + 16) {
    free(v13);
  }
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>,mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::InsertIntoBucket<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    uint64_t v10 = *(void *)a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::grow(a1, v9);
  uint64_t v10 = *a3;
  int v12 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v13 = ((*a3 >> 4) ^ (*a3 >> 9)) & v12;
  a2 = *(void *)a1 + 24 * v13;
  uint64_t v14 = *(void *)a2;
  if (*a3 != *(void *)a2)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v14 != -4096)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -8192;
      }
      if (v17) {
        uint64_t v15 = a2;
      }
      unsigned int v18 = v13 + v16++;
      unsigned int v13 = v18 & v12;
      a2 = *(void *)a1 + 24 * (v18 & v12);
      uint64_t v14 = *(void *)a2;
      if (v10 == *(void *)a2) {
        goto LABEL_4;
      }
    }
    if (v15) {
      a2 = v15;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)a2 = *a3;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)a4;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  return a2;
}

void *llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = 3 * v3;
    llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>,mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::moveFromOldBuckets(a1, v4, &v4[v10]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(v10 * 8));
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 16);
  if (v11)
  {
    unint64_t v12 = 24 * v11 - 24;
    if (v12 < 0x18)
    {
      unsigned int v13 = result;
LABEL_14:
      BOOL v17 = &result[3 * v11];
      do
      {
        void *v13 = -4096;
        v13 += 3;
      }
      while (v13 != v17);
      return result;
    }
    unint64_t v14 = v12 / 0x18 + 1;
    unsigned int v13 = &result[3 * (v14 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v15 = v14 & 0x1FFFFFFFFFFFFFFELL;
    int v16 = result;
    do
    {
      void *v16 = -4096;
      v16[3] = -4096;
      v16 += 6;
      v15 -= 2;
    }
    while (v15);
    if (v14 != (v14 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>,mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::moveFromOldBuckets(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  unsigned int v3 = *(_DWORD *)(result + 16);
  if (v3)
  {
    uint64_t v4 = *(void **)result;
    unint64_t v5 = 24 * v3 - 24;
    if (v5 < 0x18)
    {
      unint64_t v6 = *(void **)result;
LABEL_7:
      uint64_t v10 = &v4[3 * v3];
      do
      {
        *unint64_t v6 = -4096;
        v6 += 3;
      }
      while (v6 != v10);
      goto LABEL_9;
    }
    unint64_t v7 = v5 / 0x18 + 1;
    unint64_t v6 = &v4[3 * (v7 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v8 = v7 & 0x1FFFFFFFFFFFFFFELL;
    unsigned int v9 = *(void **)result;
    do
    {
      *unsigned int v9 = -4096;
      v9[3] = -4096;
      v9 += 6;
      v8 -= 2;
    }
    while (v8);
    if (v7 != (v7 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_7;
    }
  }
LABEL_9:
  while (a2 != a3)
  {
    uint64_t v12 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v13 = *(_DWORD *)(result + 16) - 1;
      unsigned int v14 = v13 & ((v12 >> 4) ^ (v12 >> 9));
      uint64_t v11 = *(void *)result + 24 * v14;
      uint64_t v15 = *(void *)v11;
      if (v12 != *(void *)v11)
      {
        uint64_t v16 = 0;
        int v17 = 1;
        while (v15 != -4096)
        {
          if (v16) {
            BOOL v18 = 0;
          }
          else {
            BOOL v18 = v15 == -8192;
          }
          if (v18) {
            uint64_t v16 = v11;
          }
          unsigned int v19 = v14 + v17++;
          unsigned int v14 = v19 & v13;
          uint64_t v11 = *(void *)result + 24 * (v19 & v13);
          uint64_t v15 = *(void *)v11;
          if (v12 == *(void *)v11) {
            goto LABEL_13;
          }
        }
        if (v16) {
          uint64_t v11 = v16;
        }
      }
LABEL_13:
      *(void *)uint64_t v11 = v12;
      *(_OWORD *)(v11 + 8) = *(_OWORD *)(a2 + 1);
      a2[1] = 0;
      a2[2] = 0;
      ++*(_DWORD *)(result + 8);
    }
    a2 += 3;
  }
  return result;
}

void mlir::anonymous namespace'::associateUnmaterializedOpIds(mlir::anec::FunctionConversionInfo *,llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>> &,llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>> &)::$_0::operator()(uint64_t **a1, uint64_t a2, uint64_t a3, int a4)
{
  v94[6] = *MEMORY[0x263EF8340];
  *(void *)&v92[0] = a2;
  *(_OWORD *)__p = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  std::deque<mlir::Operation *>::__append_with_size[abi:nn180100]<mlir::Operation * const*>(__p, (uint64_t *)v92, 1uLL);
  v83[0] = 0;
  v83[1] = 0;
  uint64_t v84 = 0;
  uint64_t v7 = *((void *)&v87 + 1);
  if (!*((void *)&v87 + 1)) {
    goto LABEL_107;
  }
  while (1)
  {
    uint64_t v8 = *(void *)(*(void *)((char *)__p[1] + (((unint64_t)v87 >> 6) & 0x3FFFFFFFFFFFFF8))
                   + 8 * (v87 & 0x1FF));
    uint64_t v82 = v8;
    *(void *)&long long v87 = v87 + 1;
    *((void *)&v87 + 1) = v7 - 1;
    if ((unint64_t)v87 >= 0x400)
    {
      operator delete(*(void **)__p[1]);
      __p[1] = (char *)__p[1] + 8;
      *(void *)&long long v87 = v87 - 512;
    }
    int v9 = *((_DWORD *)*a1 + 4);
    if (!v9) {
      goto LABEL_10;
    }
    uint64_t v10 = **a1;
    int v11 = v9 - 1;
    unsigned int v12 = ((v8 >> 4) ^ (v8 >> 9)) & v11;
    uint64_t v13 = *(void *)(v10 + 24 * v12);
    if (v13 == v8) {
      break;
    }
    int v14 = 1;
    while (v13 != -4096)
    {
      unsigned int v15 = v12 + v14++;
      unsigned int v12 = v15 & v11;
      uint64_t v13 = *(void *)(v10 + 24 * v12);
      if (v13 == v8) {
        goto LABEL_85;
      }
    }
LABEL_10:
    if (a4)
    {
      uint64_t v16 = *(unsigned int *)(v8 + 36);
      if (v16) {
        uint64_t v17 = v8 - 16;
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v90 = v17;
      uint64_t v91 = v16;
      mlir::ResultRange::use_begin(&v90, (uint64_t *)v88);
      uint64_t v18 = *(unsigned int *)(v8 + 36);
      if (v18) {
        uint64_t v19 = v8 - 16;
      }
      else {
        uint64_t v19 = 0;
      }
      uint64_t v90 = v19;
      uint64_t v91 = v18;
      mlir::ResultRange::use_end(&v90, v94);
      uint64_t v20 = v89;
      uint64_t v93 = v89;
      v92[0] = v88[0];
      v92[1] = v88[1];
      uint64_t v21 = v94[4];
      while (1)
      {
        if (v20 == v21) {
          goto LABEL_83;
        }
        uint64_t v26 = *(void *)(v20 + 16);
        uint64_t v90 = v26;
        int v27 = v84;
        if (v84)
        {
          LODWORD(v28) = (v84 - 1) & ((v26 >> 4) ^ (v26 >> 9));
          BOOL v29 = (llvm *)((char *)v83[0] + 8 * v28);
          uint64_t v30 = *(void *)v29;
          if (*(void *)v29 != v26)
          {
            int v31 = 1;
            do
            {
              if (v30 == -4096) {
                goto LABEL_27;
              }
              int v32 = v28 + v31++;
              uint64_t v28 = v32 & (v84 - 1);
              uint64_t v30 = *((void *)v83[0] + v28);
            }
            while (v30 != v26);
            BOOL v29 = (llvm *)((char *)v83[0] + 8 * v28);
          }
        }
        else
        {
LABEL_27:
          BOOL v29 = (llvm *)((char *)v83[0] + 8 * v84);
        }
        if (v29 == (llvm *)((char *)v83[0] + 8 * v84))
        {
          uint64_t v33 = (char *)__p[1];
          if ((void *)v86 == __p[1]) {
            unint64_t v34 = 0;
          }
          else {
            unint64_t v34 = (((void)v86 - (unint64_t)__p[1]) << 6) - 1;
          }
          uint64_t v35 = *((void *)&v87 + 1);
          unint64_t v36 = *((void *)&v87 + 1) + v87;
          if (v34 == *((void *)&v87 + 1) + (void)v87)
          {
            std::deque<mlir::Operation *>::__add_back_capacity((uint64_t)__p);
            uint64_t v35 = *((void *)&v87 + 1);
            uint64_t v33 = (char *)__p[1];
            unint64_t v36 = v87 + *((void *)&v87 + 1);
            uint64_t v26 = v90;
            int v27 = v84;
          }
          *(void *)(*(void *)&v33[(v36 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v36 & 0x1FF)) = v26;
          *((void *)&v87 + 1) = v35 + 1;
          if (v27)
          {
            int v22 = v27 - 1;
            unsigned int v23 = ((v90 >> 4) ^ (v90 >> 9)) & v22;
            unint64_t v24 = (uint64_t *)((char *)v83[0] + 8 * v23);
            uint64_t v25 = *v24;
            if (v90 == *v24) {
              goto LABEL_19;
            }
            long long v38 = 0;
            int v39 = 1;
            while (v25 != -4096)
            {
              if (v38) {
                BOOL v40 = 0;
              }
              else {
                BOOL v40 = v25 == -8192;
              }
              if (v40) {
                long long v38 = v24;
              }
              unsigned int v41 = v23 + v39++;
              unsigned int v23 = v41 & v22;
              unint64_t v24 = (uint64_t *)((char *)v83[0] + 8 * v23);
              uint64_t v25 = *v24;
              if (v90 == *v24) {
                goto LABEL_19;
              }
            }
            if (v38) {
              uint64_t v37 = v38;
            }
            else {
              uint64_t v37 = v24;
            }
          }
          else
          {
            uint64_t v37 = 0;
          }
          llvm::DenseMapBase<llvm::DenseMap<void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>,void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>::InsertIntoBucket<void const*,llvm::detail::DenseSetEmpty&>((uint64_t)v83, v37, &v90);
        }
LABEL_19:
        mlir::ResultRange::UseIterator::operator++((uint64_t *)v88);
        uint64_t v20 = v89;
      }
    }
    if ((*(unsigned char *)(v8 + 46) & 0x80) != 0)
    {
      uint64_t v42 = *(unsigned int *)(v8 + 68);
      if (v42)
      {
        uint64_t v43 = 0;
        uint64_t v44 = *(void *)(v8 + 72);
        while (1)
        {
          *(void *)&v92[0] = *(void *)(v44 + 32 * v43 + 24);
          *(void *)&v88[0] = 0;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v92);
          *(void *)&v88[0] = DefiningOp;
          if (!DefiningOp) {
            goto LABEL_53;
          }
          int v50 = v84;
          if (v84)
          {
            LODWORD(v51) = (v84 - 1) & ((DefiningOp >> 4) ^ (DefiningOp >> 9));
            unint64_t v52 = (llvm *)((char *)v83[0] + 8 * v51);
            uint64_t v53 = *(void *)v52;
            if (*(void *)v52 != DefiningOp)
            {
              int v54 = 1;
              do
              {
                if (v53 == -4096) {
                  goto LABEL_61;
                }
                int v55 = v51 + v54++;
                uint64_t v51 = v55 & (v84 - 1);
                uint64_t v53 = *((void *)v83[0] + v51);
              }
              while (v53 != DefiningOp);
              unint64_t v52 = (llvm *)((char *)v83[0] + 8 * v51);
            }
          }
          else
          {
LABEL_61:
            unint64_t v52 = (llvm *)((char *)v83[0] + 8 * v84);
          }
          if (v52 != (llvm *)((char *)v83[0] + 8 * v84)) {
            goto LABEL_53;
          }
          unint64_t v56 = (char *)__p[1];
          if ((void *)v86 == __p[1]) {
            unint64_t v57 = 0;
          }
          else {
            unint64_t v57 = (((void)v86 - (unint64_t)__p[1]) << 6) - 1;
          }
          uint64_t v58 = *((void *)&v87 + 1);
          unint64_t v59 = *((void *)&v87 + 1) + v87;
          if (v57 == *((void *)&v87 + 1) + (void)v87)
          {
            std::deque<mlir::Operation *>::__add_back_capacity((uint64_t)__p);
            uint64_t v58 = *((void *)&v87 + 1);
            unint64_t v56 = (char *)__p[1];
            unint64_t v59 = v87 + *((void *)&v87 + 1);
            uint64_t DefiningOp = *(void *)&v88[0];
            int v50 = v84;
          }
          *(void *)(*(void *)&v56[(v59 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v59 & 0x1FF)) = DefiningOp;
          *((void *)&v87 + 1) = v58 + 1;
          if (!v50) {
            break;
          }
          int v45 = v50 - 1;
          unsigned int v46 = ((LODWORD(v88[0]) >> 4) ^ (LODWORD(v88[0]) >> 9)) & v45;
          uint64_t v47 = (uint64_t *)((char *)v83[0] + 8 * v46);
          uint64_t v48 = *v47;
          if (*(void *)&v88[0] != *v47)
          {
            int v61 = 0;
            int v62 = 1;
            while (v48 != -4096)
            {
              if (v61) {
                BOOL v63 = 0;
              }
              else {
                BOOL v63 = v48 == -8192;
              }
              if (v63) {
                int v61 = v47;
              }
              unsigned int v64 = v46 + v62++;
              unsigned int v46 = v64 & v45;
              uint64_t v47 = (uint64_t *)((char *)v83[0] + 8 * v46);
              uint64_t v48 = *v47;
              if (*(void *)&v88[0] == *v47) {
                goto LABEL_53;
              }
            }
            if (v61) {
              uint64_t v60 = v61;
            }
            else {
              uint64_t v60 = v47;
            }
            goto LABEL_70;
          }
LABEL_53:
          if (++v43 == v42) {
            goto LABEL_83;
          }
        }
        uint64_t v60 = 0;
LABEL_70:
        llvm::DenseMapBase<llvm::DenseMap<void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>,void const*,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseSetPair<void const*>>::InsertIntoBucket<void const*,llvm::detail::DenseSetEmpty&>((uint64_t)v83, v60, (uint64_t *)v88);
        goto LABEL_53;
      }
    }
LABEL_83:
    uint64_t v7 = *((void *)&v87 + 1);
    if (!*((void *)&v87 + 1)) {
      goto LABEL_107;
    }
  }
LABEL_85:
  uint64_t v65 = *(unsigned int *)(a3 + 136);
  if (!v65) {
LABEL_107:
  }
    llvm::deallocate_buffer(v83[0], (void *)(8 * v84));
  uint64_t v66 = *(uint64_t **)(a3 + 128);
  unsigned int v67 = &v66[v65];
  while (1)
  {
    uint64_t v68 = *v66;
    BOOL v69 = *a1;
    int v70 = *((_DWORD *)*a1 + 4);
    if (!v70) {
      break;
    }
    int v71 = v70 - 1;
    unsigned int v72 = ((v82 >> 4) ^ (v82 >> 9)) & (v70 - 1);
    uint64_t v73 = (void *)(*v69 + 24 * v72);
    uint64_t v74 = *v73;
    if (v82 != *v73)
    {
      uint64_t v75 = 0;
      int v76 = 1;
      while (v74 != -4096)
      {
        if (v75) {
          BOOL v77 = 0;
        }
        else {
          BOOL v77 = v74 == -8192;
        }
        if (v77) {
          uint64_t v75 = v73;
        }
        unsigned int v78 = v72 + v76++;
        unsigned int v72 = v78 & v71;
        uint64_t v73 = (void *)(*v69 + 24 * (v78 & v71));
        uint64_t v74 = *v73;
        if (v82 == *v73) {
          goto LABEL_100;
        }
      }
      if (v75) {
        uint64_t v79 = v75;
      }
      else {
        uint64_t v79 = v73;
      }
      goto LABEL_99;
    }
LABEL_100:
    uint64_t v80 = v73[1];
    unint64_t v81 = *(unsigned int *)(v80 + 136);
    if (v81 >= *(unsigned int *)(v80 + 140))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v80 + 128, (void *)(v80 + 144), v81 + 1, 8);
      unint64_t v81 = *(unsigned int *)(v80 + 136);
    }
    *(void *)(*(void *)(v80 + 128) + 8 * v81) = v68;
    ++*(_DWORD *)(v80 + 136);
    if (++v66 == v67) {
      goto LABEL_107;
    }
  }
  uint64_t v79 = 0;
LABEL_99:
  uint64_t v73 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>,mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::InsertIntoBucket<mlir::Operation * const&>((uint64_t)v69, v79, &v82);
  goto LABEL_100;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>,mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::InsertIntoBucket<mlir::Operation * const&>(uint64_t a1, void *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,std::shared_ptr<mlir::anec::RegionConversionInfo>>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v11 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v12 = ((*a3 >> 4) ^ (*a3 >> 9)) & v11;
  a2 = (void *)(*(void *)a1 + 24 * v12);
  uint64_t v13 = *a2;
  if (*a3 != *a2)
  {
    int v14 = 0;
    int v15 = 1;
    while (v13 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == -8192;
      }
      if (v16) {
        int v14 = a2;
      }
      unsigned int v17 = v12 + v15++;
      unsigned int v12 = v17 & v11;
      a2 = (void *)(*(void *)a1 + 24 * (v17 & v11));
      uint64_t v13 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v14) {
      a2 = v14;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t v9 = *a3;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = v9;
  return a2;
}

uint64_t llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::anonymous namespace'::MPSToANECMin::basicMPSToANECConversion(mlir::func::FuncOp,mlir::RegionOpCreator *,mlir::CostModelParams const*,mlir::anec::FunctionConversionInfo *,mlir::anec::ANECIRWeights &)::{lambda(mlir::Operation *)#3}>(uint64_t **a1, uint64_t a2)
{
  return mlir::Operation::removeAttr(a2, **a1);
}

uint64_t mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    uint64_t v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      unsigned int v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(mlir::MLIRContext **a1, uint64_t a2, mlir::SymbolRefAttr **a3, int *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.region_call", (const unsigned __int8 *)0x15, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"placement.region_call";
    v19[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::placement::RegionCall::build(a1, (uint64_t)v21, *a3, *a4, *a5, a5[1]);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

BOOL mlir::verifyANECompatibleElementType(void *a1)
{
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  uint64_t v3 = ElementTypeOrSelf;
  if (ElementTypeOrSelf
    && *(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    uint64_t v3 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
  }
  return mlir::Type::isF16((mlir::Type *)&v3)
      || mlir::Type::isSignedInteger((mlir::Type *)&v3, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&v3, 8);
}

uint64_t *mlir::verifyANECompatibleType(uint64_t *a1, int a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(a1);
  v8[0] = result;
  v8[1] = v5;
  if (result)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v8);
    if (a2 <= 1 && v6 == 5)
    {
      return 0;
    }
    else
    {
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
      uint64_t v9 = ElementTypeOrSelf;
      if (ElementTypeOrSelf
        && *(_UNKNOWN **)(*(void *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        uint64_t v9 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
      }
      if (mlir::Type::isF16((mlir::Type *)&v9) || mlir::Type::isSignedInteger((mlir::Type *)&v9, 8)) {
        return (uint64_t *)1;
      }
      else {
        return (uint64_t *)mlir::Type::isUnsignedInteger((mlir::Type *)&v9, 8);
      }
    }
  }
  return result;
}

BOOL mlir::verifyCompatibleTypesWithANE(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v8)) {
    return *(void *)(*(void *)mlir::getElementTypeOrSelf(a1 - 16) + 136) != (void)&mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id;
  }
  if (a3 && (*(unsigned char *)(a1 + 46) & 0x80) != 0 && (uint64_t v10 = *(unsigned int *)(a1 + 68), v10))
  {
    uint64_t v11 = (uint64_t *)(*(void *)(a1 + 72) + 24);
    while (1)
    {
      uint64_t v12 = *v11;
      uint64_t v20 = *v11;
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
      if (!DefiningOp
        || (uint64_t v14 = DefiningOp,
            uint64_t v15 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
            !(*(unsigned int (**)(void, uint64_t))(**(void **)(v14 + 48) + 32))(*(void *)(v14 + 48), v15))|| *(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf(v12) + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
      {
        if (!mlir::verifyANECompatibleType((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8), a2))break; {
      }
        }
      v11 += 4;
      if (!--v10) {
        goto LABEL_13;
      }
    }
  }
  else
  {
LABEL_13:
    if (!a4) {
      return 1;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 36);
    uint64_t v17 = v16 ? a1 - 16 : 0;
    if (!v16) {
      return 1;
    }
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, v18);
      if (!mlir::verifyANECompatibleType((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), a2))break; {
      if (v16 == ++v18)
      }
        return 1;
    }
  }
  return 0;
}

uint64_t mlir::materializeMPSToANECHostTypeConversion(mlir::UnknownLoc **a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  v105[1] = a5;
  uint64_t v106 = (uint64_t)a3;
  v105[0] = a4;
  unint64_t v7 = (void *)(a3[1] & 0xFFFFFFFFFFFFFFF8);
  if (a4 == v7)
  {
    RawStringData = a3;
    v104[0] = 0;
    char v47 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&RawStringData, v104);
    uint64_t v48 = v104[0];
    if ((v47 & 1) == 0)
    {
      uint64_t v48 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&RawStringData, (unint64_t *)&RawStringData, v104[0]);
      *uint64_t v48 = RawStringData;
      v48[1] = 0;
    }
    v48[1] = a3;
  }
  else
  {
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v10 = *v7;
    unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v12 = *(unsigned int *)(v10 + 16);
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v13 = *(void **)(v10 + 8);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      uint64_t v16 = &v13[2 * (v12 >> 1)];
      unint64_t v18 = *v16;
      uint64_t v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11) {
        uint64_t v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == v11) {
      uint64_t v19 = (void *)v13[1];
    }
    else {
LABEL_11:
    }
      uint64_t v19 = 0;
    v104[0] = v7;
    v104[1] = v19;
    uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v105);
    uint64_t v22 = v21;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    uint64_t v24 = mlir::RankedTensorType::get(Shape, v22, OperandRange, 0);
    uint64_t v103 = 0;
    uint64_t v25 = v105[0];
    uint64_t v26 = *(void **)(*v105[0] + 136);
    if (v26 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
      uint64_t v25 = 0;
    }
    uint64_t v107 = v25;
    if (v26 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v107);
      BOOL v29 = v28;
      uint64_t v30 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = (void *)mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v107);
      uint64_t v102 = v31;
      unint64_t canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&RawStringData);
      uint64_t LayerSchedule = ZinIrHazardNode::GetLayerSchedule((ZinIrHazardNode *)&v107);
      uint64_t v103 = mlir::MemRefType::get(Value, v29, v30, canMapOperands, LayerSchedule);
    }
    uint64_t v34 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v104);
    uint64_t v35 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    unint64_t v36 = *(void **)(*v105[0] + 136);
    if (v36 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      uint64_t v49 = *(void **)(*v104[0] + 136);
      if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        uint64_t v66 = (void *)v106;
        uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v66;
        uint64_t v107 = (void *)v67;
        if (v34 != v35) {
          uint64_t v66 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        }
        unsigned int v100 = (char *)v66;
        uint64_t v68 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v104);
        uint64_t v70 = v69;
        int v71 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
        if (v70 != v72 || memcmp(v68, v71, 8 * v70))
        {
          uint64_t v73 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v66;
          uint64_t v107 = (void *)v73;
          if (v34 != v35) {
            uint64_t v66 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          uint64_t v107 = v66;
          RawStringData = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
          uint64_t v102 = v74;
          unsigned int v100 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
        }
        int v45 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(a1, a2, &v100) - 16;
        uint64_t v107 = (void *)v106;
LABEL_65:
        RawStringData = 0;
        char v87 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        uint64_t v88 = RawStringData;
        if ((v87 & 1) == 0)
        {
          uint64_t v88 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          void *v88 = v107;
          v88[1] = 0;
        }
        v88[1] = v45;
        return 1;
      }
      if (v49 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v106);
        if (DefiningOp
          && ((uint64_t v51 = *(void **)(*(void *)(DefiningOp + 48) + 16),
               BOOL v52 = v51 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id,
               v51 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
            ? (uint64_t v53 = 0)
            : (uint64_t v53 = (char *)DefiningOp),
              unsigned int v100 = v53,
              v52))
        {
          Input = (void *)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v100);
          uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v105[0]);
          RawStringData = Input;
          uint64_t v107 = (void *)ElementTypeOrSelf;
          if (v34 != v35) {
            Input = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          RawStringData = Input;
          uint64_t v91 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)a1, a2, (uint64_t)&v103, (uint64_t)&RawStringData)- 16;
          uint64_t v107 = (void *)v106;
          RawStringData = 0;
          char v92 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
          uint64_t v93 = RawStringData;
          if ((v92 & 1) == 0)
          {
            uint64_t v93 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
            *uint64_t v93 = v107;
            v93[1] = 0;
          }
          v93[1] = v91;
        }
        else
        {
          int v54 = *(void **)v106;
          if (*(void *)v106)
          {
            if (!*v54)
            {
              uint64_t v55 = v54[2];
              if (v55)
              {
                if (*(_UNKNOWN **)(*(void *)(v55 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::HostTypeCast,void>::id)
                {
                  uint64_t v56 = mlir::ShapedType::getShape((mlir::ShapedType *)v104);
                  uint64_t v58 = v57;
                  uint64_t v59 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  uint64_t v60 = mlir::RankedTensorType::get(v56, v58, v59, 0);
                  int v61 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106)
                      - 16;
                  if (v60 != v24)
                  {
                    uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                    RawStringData = v61;
                    uint64_t v107 = (void *)v62;
                    if (v34 != v35) {
                      int v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                    }
                    uint64_t v107 = v61;
                    RawStringData = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
                    uint64_t v102 = v63;
                    int v61 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
                  }
                  unint64_t v64 = v106;
                  uint64_t v65 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  RawStringData = v61;
                  uint64_t v107 = (void *)v65;
                  if (v34 != v35) {
                    int v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                  }
                  mlir::IRMapping::map((uint64_t *)a6, v64, (uint64_t)v61);
                }
              }
            }
          }
        }
        uint64_t v94 = v106;
        uint64_t v107 = (void *)v106;
        RawStringData = 0;
        long long v95 = (void *)v106;
        if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData))
        {
          long long v95 = (void *)v94;
          if (RawStringData != (void *)(*(void *)a6 + 16 * *(unsigned int *)(a6 + 16))) {
            long long v95 = (void *)RawStringData[1];
          }
        }
        uint64_t v96 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v95;
        uint64_t v107 = (void *)v96;
        if (v34 != v35) {
          long long v95 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        }
        uint64_t v107 = (void *)v94;
        RawStringData = 0;
        char v97 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        uint64_t v98 = RawStringData;
        if ((v97 & 1) == 0)
        {
          uint64_t v98 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          *uint64_t v98 = v107;
          v98[1] = 0;
        }
        v98[1] = v95;
      }
    }
    else
    {
      if (v36 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        return 1;
      }
      if (*(_UNKNOWN **)(*(void *)(*(void *)(v106 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        if (*(_UNKNOWN **)(*v104[0] + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
          return 1;
        }
        uint64_t v37 = mlir::ShapedType::getShape((mlir::ShapedType *)v104);
        uint64_t v39 = v38;
        uint64_t v40 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        uint64_t v41 = mlir::RankedTensorType::get(v37, v39, v40, 0);
        uint64_t v42 = (void *)v106;
        if (v41 == v24)
        {
          int v45 = (char *)v106;
        }
        else
        {
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v42;
          uint64_t v107 = (void *)v43;
          if (v34 != v35) {
            uint64_t v42 = (void *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          }
          uint64_t v107 = v42;
          RawStringData = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
          uint64_t v102 = v44;
          int v45 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
          uint64_t v42 = (void *)v106;
        }
        uint64_t v107 = v42;
        goto LABEL_65;
      }
      uint64_t v75 = mlir::ShapedType::getShape((mlir::ShapedType *)v104);
      uint64_t v77 = v76;
      uint64_t v78 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      uint64_t v79 = mlir::RankedTensorType::get(v75, v77, v78, 0);
      uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106) - 16;
      if (v79 != v24)
      {
        uint64_t v81 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v80;
        uint64_t v107 = (void *)v81;
        if (v34 != v35) {
          uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
        }
        uint64_t v107 = v80;
        RawStringData = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v105);
        uint64_t v102 = v82;
        uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
      }
      uint64_t v83 = v106;
      uint64_t v84 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = v80;
      uint64_t v107 = (void *)v84;
      if (v34 != v35) {
        uint64_t v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
      }
      uint64_t v107 = (void *)v83;
      RawStringData = 0;
      char v85 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
      long long v86 = RawStringData;
      if ((v85 & 1) == 0)
      {
        long long v86 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
        void *v86 = v107;
        v86[1] = 0;
      }
      v86[1] = v80;
    }
  }
  return 1;
}

uint64_t mlir::IRMapping::map(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = a2;
  uint64_t v8 = 0;
  uint64_t result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a1, &v7, &v8);
  uint64_t v6 = v8;
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a1, (uint64_t)&v7, &v7, v8);
    uint64_t v6 = (void *)result;
    *(void *)uint64_t result = v7;
    *(void *)(result + 8) = 0;
  }
  v6[1] = a3;
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,llvm::ArrayRef<long long>>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, v19, *a3, *(void *)a4, *(void **)(a4 + 8));
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"placement.tensor_to_memref";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::placement::TensorToMemref::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.memref_to_tensor", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"placement.memref_to_tensor";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::placement::MemrefToTensor::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"placement.tensor_to_memref";
    v17[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, a3, 1uLL);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], a4, 1, 0, 0);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::populateMPSToANECConversionPatterns()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  _ZN4mlir12_GLOBAL__N_120addPatternsForTargetIJNS0_14ConvertBiasAddENS0_15ConvertConstantENS0_17ConvertCropResizeENS0_22ConvertDepthwiseConv3DENS0_31ConvertElementwiseBinaryA14PlusINS_3mps5AddOpENS_4anec14ElementwiseAddELNS9_6FamilyE2EEENS6_INS7_10MultiplyOpENS9_15ElementwiseMultELSB_2EEENS6_INS7_10SubtractOpENS9_14ElementwiseSubELSB_2EEENS6_INS7_9MaximumOpENS9_14ElementwiseMaxELSB_2EEENS6_INS7_9MinimumOpENS9_14ElementwiseMinELSB_2EEENS6_INS7_7PowerOpENS9_16ElementwisePowerELSB_2EEENS0_32ConvertElementwiseBinaryA14MinusIS8_SA_LSB_1EEENSS_ISD_SE_LSB_1EEENSS_ISG_SH_LSB_1EEENSS_ISJ_SK_LSB_1EEENSS_ISM_SN_LSB_1EEENSS_ISP_SQ_LSB_1EEENSS_IS8_SA_LSB_0EEENSS_ISD_SE_LSB_0EEENSS_ISG_SH_LSB_0EEENSS_ISJ_SK_LSB_0EEENSS_ISM_SN_LSB_0EEENSS_ISP_SQ_LSB_0EEENS0_23ConvertElementwiseUnaryINS7_10AbsoluteOpENS9_14ElementwiseAbsEEENS0_15ConvertExponentENS0_16ConvertLogarithmENS0_13ConvertSelectENS0_16ConvertFlatten2DENS0_13ConvertDivideILSB_0EEENS1D_ILSB_1EEENS1D_ILSB_2EEENS1D_ILSB_3EEENS1D_ILSB_4EEENS1D_ILSB_5EEENS1D_ILSB_6EEENS0_18ConvertFloorDivideILSB_0EEENS1L_ILSB_1EEENS1L_ILSB_2EEENS1L_ILSB_3EEENS1L_ILSB_4EEENS1L_ILSB_5EEENS1L_ILSB_6EEENS0_13ConvertMatMulILSB_0EEENS1T_ILSB_1EEENS1T_ILSB_2EEENS1T_ILSB_3EEENS1T_ILSB_4EEENS1T_ILSB_5EEENS1T_ILSB_6EEENS15_INS7_9DegammaOpENS9_7DegammaEEENS15_INS7_7DiracOpENS9_5DiracEEENS15_INS7_6GeluOpENS9_4GeluEEENS15_INS7_6ReluOpENS9_4ReluEEENS15_INS7_7RoundOpENS9_12RoundNearestEEENS15_INS7_9SigmoidOpENS9_20HighPrecisionSigmoidEEENS15_INS7_8SquareOpENS9_17ElementwiseSquareEEENS15_INS7_12SquareRootOpENS9_4SqrtEEENS15_INS7_7SwishOpENS9_5SwishEEENS15_INS7_6TanhOpENS9_4TanhEEENS0_20ConvertBinaryCompareINS7_9EqualToOpENS9_16ElementwiseEqualEEENS0_26ConvertBinaryCompareToZeroIS2W_NS9_20ElementwiseEqualZeroEEENS2V_INS7_12NotEqualToOpENS9_19ElementwiseNotEqualEEENS2Z_IS32_NS9_23ElementwiseNotEqualZeroEEENS2V_INS7_13GreaterThanOpENS9_22ElementwiseGreaterThanEEENS2Z_IS37_NS9_26ElementwiseGreaterThanZeroEEENS2V_INS7_22GreaterThanOrEqualToOpENS9_27ElementwiseGreaterThanEqualEEENS2Z_IS3C_NS9_31ElementwiseGreaterThanEqualZeroEEENS2V_INS7_10LessThanOpENS9_19ElementwiseLessThanEEENS2Z_IS3H_NS9_23ElementwiseLessThanZeroEEENS2V_INS7_19LessThanOrEqualToOpENS9_24ElementwiseLessThanEqualEEENS2Z_IS3M_NS9_28ElementwiseLessThanEqualZeroEEENS15_INS7_5NotOpES30_EENS0_11ConvertPoolINS7_9PoolAvgOpENS9_11AveragePoolEEENS3T_INS7_12PoolL2NormOpENS9_10L2NormPoolEEENS3T_INS7_9PoolMaxOpENS9_7MaxPoolEEENS0_14ConvertStencilENS15_INS7_6CeilOpENS9_4CeilEEENS15_INS7_5ErfOpENS9_3ErfEEENS15_INS7_15ExponentBase2OpENS9_4Exp2EEENS15_INS7_7FloorOpENS9_5FloorEEENS15_INS7_6SignOpENS9_4SignEEENS15_INS7_10TruncateOpENS9_5TruncEEENS0_23ConvertReductionA14PlusINS7_14ReductionMaxOpENS9_9ReduceMaxELSB_2EEENS4M_INS7_15ReductionMeanOpENS9_9ReduceAvgELSB_2EEENS4M_INS7_14ReductionMinOpENS9_9ReduceMinELSB_2EEENS4M_INS7_14ReductionSumOpENS9_9ReduceSumELSB_2EEENS0_24ConvertReductionA14MinusIS4N_S4O_LSB_1EEENS4Z_IS4Q_S4R_LSB_1EEENS4Z_IS4T_S4U_LSB_1EEENS4Z_IS4W_S4X_LSB_1EEENS4Z_IS4N_S4O_LSB_0EEENS4Z_IS4Q_S4R_LSB_0EEENS4Z_IS4T_S4U_LSB_0EEENS4Z_IS4W_S4X_LSB_0EEENS0_14ConvertReshapeILSB_0EEENS58_ILSB_1EEENS58_ILSB_2EEENS58_ILSB_3EEENS58_ILSB_4EEENS58_ILSB_5EEENS58_ILSB_6EEENS0_17ConvertExpandDimsILSB_0EEENS5G_ILSB_1EEENS5G_ILSB_2EEENS5G_ILSB_3EEENS5G_ILSB_4EEENS5G_ILSB_5EEENS5G_ILSB_6EEENS0_14ConvertSqueezeILSB_0EEENS5O_ILSB_1EEENS5O_ILSB_2EEENS5O_ILSB_3EEENS5O_ILSB_4EEENS5O_ILSB_5EEENS5O_ILSB_6EEENS0_11ConvertCastENS0_14ConvertSoftmaxENS0_13ConvertConcatENS0_12ConvertSplitENS0_13ConvertResizeILSB_0EEENS60_ILSB_1EEENS60_ILSB_2EEENS60_ILSB_3EEENS60_ILSB_4EEENS60_ILSB_5EEENS60_ILSB_6EEENS0_19ConvertInstanceNormENS0_14ConvertPermuteENS0_15ConvertGatherNDENS0_13ConvertGatherENS0_21ConvertDepthToSpace2DINS9_12PixelShuffleEEENS6C_INS9_14ChannelToSpaceEEENS0_21ConvertSpaceToDepth2DINS9_14PixelUnshuffleEEENS6H_INS9_14SpaceToChannelEEENS0_19ConvertBatchToSpaceINS7_14BatchToSpaceOpENS9_12BatchToSpaceEEENS6M_INS7_14SpaceToBatchOpENS9_12SpaceToBatchEEENS0_16ConvertTransposeILSB_0EEENS6T_ILSB_1EEENS6T_ILSB_2EEENS6T_ILSB_3EEENS6T_ILSB_4EEENS6T_ILSB_5EEENS6T_ILSB_6EEENS0_16ConvertBroadcastILSB_0EEENS71_ILSB_1EEENS71_ILSB_2EEENS71_ILSB_3EEENS71_ILSB_4EEENS71_ILSB_5EEENS71_ILSB_6EEENS0_14ConvertPaddingILSB_0EEENS79_ILSB_1EEENS79_ILSB_2EEENS79_ILSB_3EEENS79_ILSB_4EEENS79_ILSB_5EEENS79_ILSB_6EEENS0_12ConvertSliceILSB_0EEENS7H_ILSB_1EEENS7H_ILSB_2EEENS7H_ILSB_3EEENS7H_ILSB_4EEENS7H_ILSB_5EEENS7H_ILSB_6EEENS0_19ConvertStridedSliceILSB_0EEENS7P_ILSB_1EEENS7P_ILSB_2EEENS7P_ILSB_3EEENS7P_ILSB_4EEENS7P_ILSB_5EEENS7P_ILSB_6EEENS0_11ConvertCropILSB_0EEENS7X_ILSB_1EEENS7X_ILSB_2EEENS7X_ILSB_3EEENS7X_ILSB_4EEENS7X_ILSB_5EEENS7X_ILSB_6EEENS15_INS7_5CosOpENS9_3CosEEENS15_INS7_5SinOpENS9_3SinEEENS0_13FoldOperationINS7_10IdentityOpEEENS0_20ConvertNormalizationENS0_24ConvertReductionVarianceENS0_19ConvertReductionArgINS7_17ReductionArgMinOpELSB_0EEENS8G_IS8H_LSB_1EEENS8G_IS8H_LSB_2EEENS8G_IS8H_LSB_3EEENS8G_IS8H_LSB_4EEENS8G_IS8H_LSB_5EEENS8G_IS8H_LSB_6EEENS8G_INS7_17ReductionArgMaxOpELSB_0EEENS8G_IS8P_LSB_1EEENS8G_IS8P_LSB_2EEENS8G_IS8P_LSB_3EEENS8G_IS8P_LSB_4EEENS8G_IS8P_LSB_5EEENS8G_IS8P_LSB_6EEENS0_14ConvertSignBitENS0_11ConvertTileEEEEvSB_RNS_17RewritePatternSetERNS_13TypeConverterE();
  mlir::populateFunctionOpInterfaceTypeConversionPattern();
}

#error "21191FB6C: too big function (funcsize=0)"

uint64_t std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v6 = (void *)(a2 + 8);
  uint64_t v7 = *(void **)(a2 + 8);
  if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) == v7) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, v6);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v5, (uint64_t)v6);
  }
  size_t v8 = strlen(a3);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    char v10 = operator new(v11 + 1);
    *(void *)(a1 + 40) = v9;
    *(void *)(a1 + 48) = v12 | 0x8000000000000000;
    *(void *)(a1 + 32) = v10;
  }
  else
  {
    char v10 = (void *)(a1 + 32);
    *(unsigned char *)(a1 + 55) = v8;
    if (!v8) {
      goto LABEL_12;
    }
  }
  memmove(v10, a3, v9);
LABEL_12:
  *((unsigned char *)v10 + v9) = 0;
  return a1;
}

void mlir::anonymous namespace'::ConvertBiasAdd::~ConvertBiasAdd(mlir::_anonymous_namespace_::ConvertBiasAdd *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v39 = a2;
  long long v42 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v42, 0);
  uint64_t v6 = (char *)mlir::ValueRange::dereference_iterator(&v42, 1);
  uint64_t v7 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = mlir::getRankPromotionTypeForANE((uint64_t)v7, v17);
  v38[1] = v18;
  mlir::ShapedType::getShape((mlir::ShapedType *)v38);
  uint64_t v20 = v19;
  mlir::ShapedType::getShape((mlir::ShapedType *)v38);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v21);
  if (!v23) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v24 = IndexFromDim;
  int PaddingMode = mlir::mps::PadOp::getPaddingMode((mlir::mps::PadOp *)&v39);
  if (PaddingMode)
  {
    if (PaddingMode != 1)
    {
      uint64_t v36 = v39;
      GOC = &v39;
      uint64_t v32 = *(void *)(a4 + 16);
      if (!v32 || !mlir::RewriterBase::Listener::classof(v32)) {
        return 0;
      }
      uint64_t v34 = *(void *)(v36 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(void *)v32 + 64))(v32, v34, v35, &GOC);
    }
    uint64_t v26 = -1;
  }
  else
  {
    uint64_t v26 = -3;
  }
  if (v20 + v26 != v24
    || (GOC = (uint64_t *)v6, (uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&GOC)) == 0)
    || (uint64_t v28 = DefiningOp,
        uint64_t v29 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(void, uint64_t))(**(void **)(v28 + 48) + 32))(*(void *)(v28 + 48), v29)))
  {
    uint64_t v32 = *(void *)(a4 + 16);
    if (!v32) {
      return 0;
    }
    uint64_t v33 = v39;
    if (!mlir::RewriterBase::Listener::classof(v32)) {
      return 0;
    }
    uint64_t v34 = *(void *)(v33 + 24);
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(void *)v32 + 64))(v32, v34, v35, &GOC);
  }
  uint64_t v30 = (unsigned int *)v39;
  if (!GOC) {
    return 0;
  }
  uint64_t v40 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
  uint64_t v31 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v30, (uint64_t)&v40, 1);
  return v31;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::mps::PadOp **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "BiasAdd unsupported data format ");
  unsigned int PaddingMode = mlir::mps::PadOp::getPaddingMode(*a1);
  __int16 v9 = 261;
  v8[0] = (void **)mlir::mps::stringifyTensorDataLayout(PaddingMode);
  v8[1] = v5;
  uint64_t v6 = mlir::Diagnostic::operator<<(v3, v8);
  return mlir::Diagnostic::operator<<(v6, "\n");
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::makeGOC(uint64_t a1, mlir::MLIRContext *a2, uint64_t a3, char *a4, char *a5, uint64_t OperandRange, int a7, int a8)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v44 = a4;
  uint64_t v45 = a3;
  uint64_t v43 = a5;
  uint64_t v15 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v15) {
    goto LABEL_10;
  }
  uint64_t v16 = *v15;
  unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v18 = *(unsigned int *)(v16 + 16);
  if (!v18) {
    goto LABEL_10;
  }
  uint64_t v19 = *(void **)(v16 + 8);
  uint64_t v20 = &v19[2 * v18];
  do
  {
    unint64_t v21 = v18 >> 1;
    uint64_t v22 = &v19[2 * (v18 >> 1)];
    unint64_t v24 = *v22;
    char v23 = v22 + 2;
    v18 += ~(v18 >> 1);
    if (v24 < v17) {
      uint64_t v19 = v23;
    }
    else {
      unint64_t v18 = v21;
    }
  }
  while (v18);
  if (v19 != v20 && *v19 == v17) {
    uint64_t v25 = v19[1];
  }
  else {
LABEL_10:
  }
    uint64_t v25 = 0;
  v42[0] = mlir::getRankPromotionTypeForANE((uint64_t)v15, v25);
  v42[1] = v26;
  mlir::ShapedType::getShape((mlir::ShapedType *)v42);
  mlir::anec::getIndexFromDim(1, v27);
  if (v28)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v42);
    uint64_t v51 = v53;
    uint64_t v52 = 0xC00000000;
    uint64_t v41 = 0;
    if (a4)
    {
      uint64_t v29 = v41;
    }
    else
    {
      uint64_t v29 = 0;
      v53[0] = 1065353216;
      LODWORD(v52) = 1;
    }
    mlir::ShapedType::getShape((mlir::ShapedType *)v42);
    if (v32)
    {
      uint64_t v44 = (char *)GOCConstant - 16;
      uint64_t v48 = v50;
      uint64_t v49 = 0xC00000000;
      uint64_t v40 = 0;
      if (a5)
      {
        {
LABEL_27:
          if (v48 != v50) {
            free(v48);
          }
          goto LABEL_29;
        }
        uint64_t v33 = v40;
      }
      else
      {
        uint64_t v33 = 0;
        v50[0] = 0;
        LODWORD(v49) = 1;
      }
      mlir::ShapedType::getShape((mlir::ShapedType *)v42);
      if (v36)
      {
        uint64_t v43 = (char *)v35 - 16;
        if (!OperandRange) {
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
        }
        LOBYTE(v46) = 0;
        char v47 = 0;
        uint64_t v37 = (void *)mlir::ShapedType::cloneWith(v42, &v46, OperandRange);
      }
      goto LABEL_27;
    }
LABEL_29:
    if (v51 != v53) {
      free(v51);
    }
  }
  return 0;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::getGOCConstantValue(void *a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  v43[2] = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t OperandRange = (uint64_t **)&v39;
  ArgOperands = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&OperandRange, DefiningOp)) {
    return 0;
  }
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39);
  uint64_t v42 = v11;
  uint64_t OperandRange = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  if (mlir::Type::isF32((mlir::Type *)&OperandRange) || a3)
  {
    ArgOperands = (void *)(a1[1] & 0xFFFFFFFFFFFFFFF8);
    uint64_t Context = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    uint64_t v14 = mlir::Float32Type::get(Context, v17);
  }
  else
  {
    ArgOperands = (void *)(a1[1] & 0xFFFFFFFFFFFFFFF8);
    uint64_t v12 = (mlir::Float16Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    uint64_t v14 = mlir::Float16Type::get(v12, v13);
  }
  *a5 = v14;
  ArgOperands = v43;
  uint64_t v42 = 0x400000000;
  uint64_t OperandRange = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39);
  uint64_t v38 = v18;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || (uint64_t OperandRange = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39),
        uint64_t v38 = v19,
        uint64_t v20 = *(void **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                       + 136),
        v20 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v20 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::getIntValues<float>(v39, v40, (uint64_t)&ArgOperands, 1);
    unint64_t v22 = v42;
    unsigned int v23 = *(_DWORD *)(a2 + 8);
    if (v23 != v42)
    {
      if (v23 <= v42)
      {
        if (*(_DWORD *)(a2 + 12) < v42)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v42, 4);
          unsigned int v23 = *(_DWORD *)(a2 + 8);
        }
        if (v23 != v22) {
          bzero((void *)(*(void *)a2 + 4 * v23), 4 * (v22 - v23));
        }
      }
      *(_DWORD *)(a2 + 8) = v22;
      unint64_t v22 = v42;
    }
    unint64_t v21 = (float *)ArgOperands;
    if (v22)
    {
      uint64_t v24 = 0;
      uint64_t v25 = *(void *)a2;
      if (v22 < 4 || (unint64_t)(v25 - (void)ArgOperands) < 0x10) {
        goto LABEL_52;
      }
      unint64_t v26 = 0;
      uint64_t v24 = v22 & 0xFFFFFFFC;
      __asm { FMOV            V0.4S, #1.0 }
      do
      {
        if (a3) {
          unsigned int v32 = -1;
        }
        else {
          unsigned int v32 = 0;
        }
        float32x4_t v33 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v32), (int8x16_t)vdivq_f32(_Q0, *(float32x4_t *)&v21[v26 / 4]), *(int8x16_t *)&v21[v26 / 4]);
        if (a4) {
          unsigned int v34 = -1;
        }
        else {
          unsigned int v34 = 0;
        }
        *(int8x16_t *)(v25 + v26) = vbslq_s8((int8x16_t)vdupq_n_s32(v34), (int8x16_t)vnegq_f32(v33), (int8x16_t)v33);
        v26 += 16;
      }
      while (((4 * v22) & 0x3FFFFFFF0) != v26);
      if (v22 != v24)
      {
LABEL_52:
        do
        {
          float v35 = v21[v24];
          if (a3) {
            float v35 = 1.0 / v35;
          }
          if (a4) {
            float v35 = -v35;
          }
          *(float *)(v25 + 4 * v24++) = v35;
        }
        while (v22 != v24);
      }
    }
    uint64_t v15 = 1;
  }
  else
  {
    uint64_t v15 = 0;
    unint64_t v21 = (float *)ArgOperands;
  }
  if (v21 != (float *)v43) {
    free(v21);
  }
  return v15;
}

ZinIrHalH13g *mlir::anonymous namespace'::anonymous namespace'::makeGOCConstant(uint64_t a1, mlir::MLIRContext *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, char a7, uint64_t a8)
{
  uint64_t F16Type = a8;
  v75[5] = *MEMORY[0x263EF8340];
  uint64_t v71 = a8;
  if (a8)
  {
    if (a7) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a1 + 8), a2);
    uint64_t v71 = F16Type;
    if (a7) {
      goto LABEL_7;
    }
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, a3);
  if (!v17) {
    return 0;
  }
  a6 = IndexFromDim;
LABEL_7:
  __b = v75;
  int v74 = 5;
  if (a3 < 6)
  {
    if (a3) {
      memset_pattern16(v75, &unk_211ED5510, 8 * a3);
    }
    uint64_t v18 = v75;
  }
  else
  {
    unsigned int v73 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v75, a3, 8);
    uint64_t v18 = __b;
    memset_pattern16(__b, &unk_211ED5510, 8 * a3);
  }
  unsigned int v73 = a3;
  v18[a6] = a5;
  uint64_t v19 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v18, a3, F16Type, 0);
  uint64_t v20 = (uint64_t *)__b;
  unint64_t v21 = (mlir::AffineMap *)v73;
  unint64_t v22 = (mlir::Float16Type **)(a1 + 8);
  uint64_t v24 = mlir::Builder::getF16Type(v22, v23);
  uint64_t v70 = mlir::MemRefType::get(v20, v21, v24, 0, 0, 0);
  if (!v19) {
    goto LABEL_21;
  }
  uint64_t v25 = *v19;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_21;
  }
  char v28 = *(void **)(v25 + 8);
  uint64_t v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unsigned int v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      char v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_21:
  }
    uint64_t v34 = 0;
  mlir::mps::CPUNDArray::CPUNDArray(v68, v19, v34, 0);
  BOOL isF32 = mlir::Type::isF32((mlir::Type *)&v71);
  uint64_t v36 = v69;
  if (isF32)
  {
    if (a5 >= 1)
    {
      uint64_t v37 = 0;
      if ((unint64_t)a5 < 8) {
        goto LABEL_29;
      }
      if ((unint64_t)(v69 - a4) < 0x20) {
        goto LABEL_29;
      }
      uint64_t v37 = a5 & 0x7FFFFFFFFFFFFFF8;
      uint64_t v38 = (long long *)(a4 + 16);
      uint64_t v39 = (_OWORD *)(v69 + 16);
      unint64_t v40 = a5 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        long long v41 = *v38;
        *(v39 - 1) = *(v38 - 1);
        *uint64_t v39 = v41;
        v38 += 2;
        v39 += 2;
        v40 -= 8;
      }
      while (v40);
      if (a5 != v37)
      {
LABEL_29:
        uint64_t v42 = a5 - v37;
        uint64_t v43 = 4 * v37;
        uint64_t v44 = (_DWORD *)(v36 + v43);
        uint64_t v45 = (int *)(a4 + v43);
        do
        {
          int v46 = *v45++;
          *v44++ = v46;
          --v42;
        }
        while (v42);
      }
    }
    goto LABEL_41;
  }
  if (a5 >= 1)
  {
    if ((unint64_t)a5 < 0x10)
    {
      uint64_t v47 = 0;
LABEL_39:
      uint64_t v56 = a5 - v47;
      uint64_t v57 = (_WORD *)(v36 + 2 * v47);
      uint64_t v58 = (int *)(a4 + 4 * v47);
      do
      {
        int v59 = *v58++;
        _S0 = v59;
        __asm { FCVT            H0, S0 }
        *v57++ = _S0;
        --v56;
      }
      while (v56);
      goto LABEL_41;
    }
    uint64_t v47 = a5 & 0x7FFFFFFFFFFFFFF0;
    uint64_t v49 = (float32x4_t *)(a4 + 32);
    int v50 = (float16x8_t *)(v69 + 16);
    unint64_t v51 = a5 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float32x4_t v53 = v49[-2];
      float32x4_t v52 = v49[-1];
      float32x4_t v55 = *v49;
      float32x4_t v54 = v49[1];
      v49 += 4;
      v50[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v53), v52);
      float16x8_t *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v55), v54);
      v50 += 2;
      v51 -= 16;
    }
    while (v51);
    if (a5 != v47) {
      goto LABEL_39;
    }
  }
LABEL_41:
  v67[0] = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v68, 0, 1);
  v67[1] = v65;
  uint64_t v48 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v22, (uint64_t)a2, &v70, v67);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v68);
  if (__b != v75) {
    free(__b);
  }
  return v48;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    void v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::anonymous namespace'::canonicalizeType(void *a1, uint64_t a2)
{
  v31[67] = *(pthread_rwlock_t **)MEMORY[0x263EF8340];
  unint64_t v26 = a1;
  uint64_t v27 = a2;
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v31);
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v26);
  if (mlir::ShapedType::getNumElements(Shape, v3) == 1
    && (mlir::ShapedType::getShape((mlir::ShapedType *)&v26), v4 <= 3))
  {
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    uint64_t v6 = mlir::TypeConverter::convertType((uint64_t)v31, OperandRange);
    if (!v6) {
      uint64_t v6 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    }
    mlir::getRankPromotionShapeForANE((uint64_t)v26, v27, (uint64_t **)&RankPromotionTypeForANE);
    mlir::MemRefType::get((uint64_t *)RankPromotionTypeForANE, (mlir::AffineMap *)v29, v6, 0, 0, 0);
    if (RankPromotionTypeForANE != &v30) {
      free(RankPromotionTypeForANE);
    }
  }
  else
  {
    uint64_t v7 = (void *)mlir::TypeConverter::convertType((uint64_t)v31, v26);
    uint64_t v8 = (uint64_t)v7;
    uint64_t v25 = v7;
    if (!v7) {
      goto LABEL_16;
    }
    uint64_t v9 = *v7;
    unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v11 = *(unsigned int *)(v9 + 16);
    if (!v11) {
      goto LABEL_16;
    }
    uint64_t v12 = *(void **)(v9 + 8);
    uint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = v11 >> 1;
      uint64_t v15 = &v12[2 * (v11 >> 1)];
      unint64_t v17 = *v15;
      uint64_t v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10) {
        uint64_t v12 = v16;
      }
      else {
        unint64_t v11 = v14;
      }
    }
    while (v11);
    if (v12 != v13 && *v12 == v10) {
      uint64_t v18 = v12[1];
    }
    else {
LABEL_16:
    }
      uint64_t v18 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v8, v18);
    uint64_t v29 = v19;
    __int16 v20 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
    __int16 v22 = v21;
    uint64_t v23 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    uint64_t LayerSchedule = ZinIrHazardNode::GetLayerSchedule((ZinIrHazardNode *)&v25);
    mlir::MemRefType::get(v20, v22, v23, 0, LayerSchedule);
  }
  mlir::TypeConverter::~TypeConverter(v31);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BiasAdd invalid channel or not a constant bias\n");
}

void mlir::anonymous namespace'::ConvertConstant::~ConvertConstant(mlir::_anonymous_namespace_::ConvertConstant *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v18, a3, a4);
  unint64_t v8 = v18[0];
  unint64_t v9 = v18[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v19, a2);
  unint64_t v21 = v8;
  unint64_t v22 = v9;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v19, a5);
  unint64_t v11 = v20;
  if (v20)
  {
    uint64_t v12 = *(void **)(v20->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v11 = 0;
    }
    unint64_t v17 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v17, &v16);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      uint64_t Manager = mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      return mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, v16.n128_i64[0]);
    }
  }
  return result;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v19, a3, a4);
  unint64_t v8 = v19[0];
  unint64_t v9 = v19[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v20, a2);
  unint64_t v22 = v8;
  unint64_t v23 = v9;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v20, a5);
  unint64_t v11 = v21;
  if (v21)
  {
    uint64_t v12 = *(void **)(v21->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v11 = 0;
    }
    uint64_t v18 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v18, &v17);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
      uint64_t Manager = mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, v17.n128_i64[0]);
    }
  }
  return v10;
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  unint64_t v8 = (__n128 *)*((void *)a3 + 6);
  uint64_t v9 = *((void *)a3 + 7);
  uint64_t v10 = a3 + 3;
  float32x4_t v53 = v8;
  uint64_t v54 = 0;
  if (v9)
  {
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v13 = mlir::ValueRange::dereference_iterator(&v53, v11);
      v44[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8));
      v44[1] = v14;
      if (v44[0])
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44))
        {
          goto LABEL_15;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v44);
        if (v16) {
          break;
        }
      }
LABEL_3:
      uint64_t v11 = ++v54;
      if (v53 == v8 && v11 == v9) {
        goto LABEL_18;
      }
    }
    uint64_t v17 = 8 * v16;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v17 -= 8;
      if (!v17) {
        goto LABEL_3;
      }
    }
LABEL_15:
    __int16 v47 = 259;
    uint64_t v45 = v46;
    v46[0].n128_u64[0] = (unint64_t)"failed: unranked input types or dynamic shapes are not supported on ANEs.";
    uint64_t v18 = *(void *)(a4 + 16);
    if (v18 && mlir::RewriterBase::Listener::classof(v18)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), __n128 **))(*(void *)v18 + 64))(v18, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v45);
    }
    return 0;
  }
LABEL_18:
  uint64_t v20 = *(unsigned int *)(a2 + 36);
  if (v20) {
    uint64_t v21 = a2 - 16;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v20)
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, v22);
      float32x4_t v53 = (__n128 *)llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v54 = v24;
      if (v53)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        {
          goto LABEL_32;
        }
        uint64_t v25 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v53);
        if (v26) {
          break;
        }
      }
LABEL_23:
      if (++v22 == v20) {
        goto LABEL_38;
      }
    }
    uint64_t v27 = 8 * v26;
    while (*v25 != 0x8000000000000000)
    {
      ++v25;
      v27 -= 8;
      if (!v27) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v46[0].n128_u64[0] = (unint64_t)"failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v47 = 259;
    v44[0] = v46;
    uint64_t v28 = *(void *)(a4 + 16);
    if (v28 && mlir::RewriterBase::Listener::classof(v28)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v28 + 64))(v28, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
    }
    return 0;
  }
LABEL_38:
  long long v48 = *a3;
  char v49 = *((unsigned char *)a3 + 16);
  uint64_t v31 = (__n128 *)*((void *)a3 + 3);
  int v50 = v31;
  if (v31)
  {
    unsigned int v32 = *(void **)(v31->n128_u64[0] + 136);
    if (v32 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      uint64_t v31 = 0;
    }
    float32x4_t v53 = v31;
    if (v32 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      uint64_t Manager = mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v34);
      unint64_t v36 = v46[0].n128_u64[0];
      uint64_t v37 = (pthread_rwlock_t **)(Manager + 48);
      llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(Manager + 48));
      ++*(void *)(v36 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v37);
    }
  }
  long long v38 = *v10;
  long long v51 = a3[2];
  long long v52 = v38;
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, long long *, uint64_t))(*(void *)a1 + 88))(a1, a2, &v48, a4);
  uint64_t v39 = v50;
  if (v50)
  {
    unint64_t v40 = *(void **)(v50->n128_u64[0] + 136);
    if (v40 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      uint64_t v39 = 0;
    }
    float32x4_t v53 = v39;
    if (v40 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      long long v41 = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      uint64_t v43 = mlir::mps::MPSResourceBlobManagerInterface::getManager(v41, v42);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(v43, v46[0].n128_i64[0]);
    }
  }
  return v29;
}

void mlir::anonymous namespace'::ConvertConstant::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v44[67] = *(pthread_rwlock_t **)MEMORY[0x263EF8340];
  uint64_t v40 = a2;
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v44, *(const mlir::TypeConverter **)(a1 + 96));
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v40) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v40);
  uint64_t v38 = v16;
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Value);
  uint64_t v42 = v17;
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  uint64_t v19 = mlir::TypeConverter::convertType((uint64_t)v44, OperandRange);
  uint64_t v20 = (uint64_t)Value;
  uint64_t v21 = v38;
  LOBYTE(ArgOperands) = 0;
  char v43 = 0;
  uint64_t v22 = (uint64_t *)mlir::BaseMemRefType::cloneWith(&v39, (uint64_t)&ArgOperands, v19);
  uint64_t v23 = (uint64_t)v22;
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v24 = *v22;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_20;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  uint64_t v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    uint64_t v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    uint64_t v33 = v27[1];
  }
  else {
LABEL_20:
  }
    uint64_t v33 = 0;
  ArgOperands = mlir::rewriteElementsAttr(v20, v21, v23, v33, 0);
  uint64_t v42 = v34;
  uint64_t v35 = v40;
  unint64_t v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v40 + 24), (uint64_t *)&v39, &ArgOperands);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v35, v36);
  mlir::TypeConverter::~TypeConverter(v44);
}

BOOL mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (pthread_rwlock_t **)(a1 + 48);
  llvm::sys::RWMutexImpl::lock((pthread_rwlock_t **)(a1 + 48));
  if (*(void *)(a2 + 88) == 1)
  {
    *(void *)(a2 + 88) = 0;
    if (*(unsigned char *)(a2 + 80))
    {
      unint64_t v4 = *(void *)(a2 + 64);
      if (v4 >= 8)
      {
        uint64_t v5 = (void *)(a2 + 40);
        uint64_t v6 = (void *)(a2 + 40);
        if ((v4 & 2) == 0) {
          uint64_t v6 = (void *)*v5;
        }
        (*(void (**)(void *, void, void, void))(v4 & 0xFFFFFFFFFFFFFFF8))(v6, *(void *)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 32));
        unint64_t v7 = *(void *)(a2 + 64);
        if (v7 >= 8)
        {
          if ((v7 & 4) != 0)
          {
            if ((v7 & 2) == 0) {
              uint64_t v5 = (void *)*v5;
            }
            (*(void (**)(void *))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))(v5);
          }
          if ((v7 & 2) == 0) {
            llvm::deallocate_buffer(*(llvm **)(a2 + 40), *(void **)(a2 + 48));
          }
        }
      }
      *(unsigned char *)(a2 + 80) = 0;
    }
  }
  else
  {
    --*(void *)(a2 + 88);
  }

  return llvm::sys::RWMutexImpl::unlock_shared(v3);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::canonicalizeType(uint64_t a1, void *a2, uint64_t a3)
{
  v34[5] = *MEMORY[0x263EF8340];
  uint64_t v30 = a2;
  uint64_t v31 = a3;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v30);
  if (mlir::ShapedType::getNumElements(Shape, v5) == 1
    && (mlir::ShapedType::getShape((mlir::ShapedType *)&v30), v6 <= 3))
  {
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    uint64_t v8 = mlir::TypeConverter::convertType(a1, OperandRange);
    if (!v8) {
      uint64_t v8 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    }
    mlir::getRankPromotionShapeForANE((uint64_t)v30, v31, (uint64_t **)&RankPromotionTypeForANE);
    uint64_t v9 = mlir::MemRefType::get((uint64_t *)RankPromotionTypeForANE, (mlir::AffineMap *)v33, v8, 0, 0, 0);
    if (RankPromotionTypeForANE != v34) {
      free(RankPromotionTypeForANE);
    }
  }
  else
  {
    uint64_t v10 = (void *)mlir::TypeConverter::convertType(a1, v30);
    uint64_t v11 = (uint64_t)v10;
    unint64_t v29 = v10;
    if (!v10) {
      goto LABEL_16;
    }
    uint64_t v12 = *v10;
    unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_16;
    }
    uint64_t v15 = *(void **)(v12 + 8);
    uint64_t v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      uint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      uint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        uint64_t v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_16:
    }
      uint64_t v21 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v11, v21);
    uint64_t v33 = v22;
    uint64_t v23 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
    unint64_t v25 = v24;
    uint64_t v26 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    uint64_t LayerSchedule = ZinIrHazardNode::GetLayerSchedule((ZinIrHazardNode *)&v29);
    return mlir::MemRefType::get(v23, v25, v26, 0, LayerSchedule);
  }
  return v9;
}

mlir::TypeConverter *mlir::TypeConverter::TypeConverter(mlir::TypeConverter *this, const mlir::TypeConverter *a2)
{
  *(void *)this = &unk_26C362018;
  *((void *)this + 1) = (char *)this + 24;
  unint64_t v4 = (void **)((char *)this + 8);
  *((void *)this + 2) = 0x400000000;
  if (*((_DWORD *)a2 + 4)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=(v4, (void **)a2 + 1);
  }
  *((void *)this + 19) = (char *)this + 168;
  *((void *)this + 20) = 0x200000000;
  if (*((_DWORD *)a2 + 40)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 19, (void **)a2 + 19);
  }
  *((void *)this + 29) = (char *)this + 248;
  *((void *)this + 30) = 0x200000000;
  if (*((_DWORD *)a2 + 60)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 29, (void **)a2 + 29);
  }
  *((void *)this + 39) = (char *)this + 328;
  *((void *)this + 40) = 0x200000000;
  if (*((_DWORD *)a2 + 80)) {
    llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=((void **)this + 39, (void **)a2 + 39);
  }
  *((void *)this + 49) = (char *)this + 408;
  *((void *)this + 50) = 0x200000000;
  if (*((_DWORD *)a2 + 100)) {
    llvm::SmallVectorImpl<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>>::operator=((void **)this + 49, (void **)a2 + 49);
  }
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((mlir::TypeConverter *)((char *)this + 520));
  *((void *)this + 66) = 0;
  return this;
}

void **llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)> const*,std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void **llvm::SmallVectorImpl<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> const*,std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void **llvm::SmallVectorImpl<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>>::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *((unsigned int *)a2 + 2);
    uint64_t v5 = *((unsigned int *)a1 + 2);
    if (v5 >= v4)
    {
      if (v4)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>((uint64_t)&v25, *a2, &(*a2)[4 * v4], *a1);
        uint64_t v10 = v9;
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v5 = *((unsigned int *)a1 + 2);
      }
      else
      {
        uint64_t v11 = (uint64_t)*a1;
        uint64_t v10 = *a1;
      }
      uint64_t v19 = (void *)(v11 + 32 * v5);
      if (v19 != v10)
      {
        unint64_t v20 = v19 - 4;
        uint64_t v21 = v19 - 4;
        do
        {
          uint64_t v23 = (void *)v21[3];
          if (v21 == v23)
          {
            (*(void (**)(void *))(*v21 + 32))(v21);
          }
          else if (v23)
          {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          v20 -= 4;
          BOOL v22 = v21 == v10;
          v21 -= 4;
        }
        while (!v22);
      }
      goto LABEL_33;
    }
    if (*((_DWORD *)a1 + 3) >= v4)
    {
      if (v5)
      {
        std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>((uint64_t)&v26, *a2, &(*a2)[4 * v5], *a1);
        goto LABEL_17;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v6 = 32 * v5;
        uint64_t v7 = (uint64_t)(*a1 - 4);
        do
        {
          uint64_t v8 = *(void *)(v7 + v6 + 24);
          if (v7 + v6 == v8)
          {
            (*(void (**)(uint64_t))(*(void *)(v7 + v6) + 32))(v7 + v6);
          }
          else if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
          }
          v6 -= 32;
        }
        while (v6);
      }
      *((_DWORD *)a1 + 2) = 0;
      llvm::SmallVectorTemplateBase<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>,false>::grow((uint64_t)a1, v4);
    }
    uint64_t v5 = 0;
LABEL_17:
    uint64_t v12 = *((unsigned int *)a2 + 2);
    if (v5 != v12)
    {
      uint64_t v13 = (uint64_t)*a2;
      uint64_t v14 = 32 * v5;
      uint64_t v15 = (uint64_t)&(*a1)[4 * v5];
      uint64_t v16 = v13 + 32 * v5;
      uint64_t v17 = 32 * v12 - v14;
      do
      {
        uint64_t v18 = *(void *)(v16 + 24);
        if (v18)
        {
          if (v16 == v18)
          {
            *(void *)(v15 + 24) = v15;
            (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 24))(*(void *)(v16 + 24), v15);
          }
          else
          {
            *(void *)(v15 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
          }
        }
        else
        {
          *(void *)(v15 + 24) = 0;
        }
        v16 += 32;
        v15 += 32;
        v17 -= 32;
      }
      while (v17);
    }
LABEL_33:
    *((_DWORD *)a1 + 2) = v4;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v16 = 0;
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  uint64_t v5 = v4;
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (void *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          v9[3] = v9;
          (*(void (**)(void, void *))(*(void *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(void **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 4 * v11;
      uint64_t v13 = v6 - 4;
      do
      {
        uint64_t v14 = (void *)v13[v12 + 3];
        if (&v13[v12] == v14)
        {
          (*(void (**)(void *))(v13[v12] + 32))(&v13[v12]);
        }
        else if (v14)
        {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        v12 -= 4;
      }
      while (v12 * 8);
      uint64_t v6 = *(void **)a1;
    }
  }
  int v15 = v16;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)> const*,std::function<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a2 != a3)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = (void *)v5[3];
      if (v8)
      {
        if (v5 == v8)
        {
          uint64_t v11 = v10;
          (*(void (**)(void *, void *))(*v5 + 24))(v5, v10);
        }
        else
        {
          uint64_t v11 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      std::__function::__value_func<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>::swap[abi:nn180100](v10, a4);
      if (v11 == v10)
      {
        (*(void (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*v11 + 40))();
      }
      v5 += 4;
      a4 += 4;
      v7 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::__function::__value_func<mlir::TypeConverter::AttributeConversionResult ()(mlir::Type,mlir::Attribute)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void mlir::anonymous namespace'::ConvertCropResize::~ConvertCropResize(mlir::_anonymous_namespace_::ConvertCropResize *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  uint64_t v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 96);
      long long v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      long long v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      long long v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v35 = 259;
    v32[0] = v34;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  uint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertCropResize::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v259 = *MEMORY[0x263EF8340];
  uint64_t v227 = a2;
  long long v258 = *(_OWORD *)(a3 + 96);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v258, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v226[0] = v5;
  v226[1] = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v227) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  GOCConstant = v16;
  uint64_t v250 = v26;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&GOCConstant);
  uint64_t v29 = v27;
  v255 = v257;
  uint64_t v256 = 0x500000000;
  size_t v30 = 8 * v27;
  if ((unint64_t)(8 * v27) < 0x29)
  {
    int v31 = 0;
    unint64_t v32 = v257;
    if (!v29) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v255, v257, (8 * v27) >> 3, 8);
  int v31 = v256;
  unint64_t v32 = v255;
  if (v29)
  {
LABEL_25:
    memcpy(&v32[8 * v31], Shape, v30);
    int v31 = v256;
    unint64_t v32 = v255;
  }
LABEL_26:
  LODWORD(v256) = v31 + (v30 >> 3);
  llvm::SmallVectorImpl<long long>::insert((uint64_t)&v255, (uint64_t)v32, 3uLL, 1uLL);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v256);
  if (!v34) {
    goto LABEL_203;
  }
  unint64_t v35 = IndexFromDim;
  unint64_t v36 = mlir::anec::getIndexFromDim(3, v256);
  if (!v37) {
    goto LABEL_203;
  }
  uint64_t v38 = v255;
  uint64_t v39 = v255[v35];
  v255[v35] = v255[v36];
  v38[v36] = v39;
  uint64_t v40 = (mlir::AffineMap *)v256;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v226);
  uint64_t v225 = mlir::MemRefType::get(v38, v40, OperandRange, 0, 0, 0);
  uint64_t v42 = *(void *)(v227 + 24);
  GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v258, 1);
  uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v42, &v225, (uint64_t *)&GOCConstant)- 16;
  char v43 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v227) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v43) {
    goto LABEL_37;
  }
  uint64_t v44 = *v43;
  unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v46 = *(unsigned int *)(v44 + 16);
  if (!v46) {
    goto LABEL_37;
  }
  __int16 v47 = *(void **)(v44 + 8);
  long long v48 = &v47[2 * v46];
  do
  {
    unint64_t v49 = v46 >> 1;
    int v50 = &v47[2 * (v46 >> 1)];
    unint64_t v52 = *v50;
    long long v51 = v50 + 2;
    v46 += ~(v46 >> 1);
    if (v52 < v45) {
      __int16 v47 = v51;
    }
    else {
      unint64_t v46 = v49;
    }
  }
  while (v46);
  if (v47 != v48 && *v47 == v45) {
    uint64_t v53 = v47[1];
  }
  else {
LABEL_37:
  }
    uint64_t v53 = 0;
  v223[0] = v43;
  v223[1] = v53;
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v227, (uint64_t)&GOCConstant);
  uint64_t v54 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v242, 1.0);
  uint64_t v55 = llvm::APFloatBase::IEEEsingle(v54);
  llvm::APFloat::Storage::Storage(&v253, &v242, v55);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v242);
  uint64_t v56 = (void *)v250;
  uint64_t v57 = v253;
  int v59 = llvm::APFloatBase::PPCDoubleDouble(v58);
  if (v56 == (void *)v57)
  {
    char v61 = v59 == v56
        ? llvm::detail::DoubleAPFloat::bitwiseIsEqual((llvm::detail::DoubleAPFloat *)&v250, (const llvm::detail::DoubleAPFloat *)&v253): llvm::detail::IEEEFloat::bitwiseIsEqual((llvm::detail::IEEEFloat *)&v250, (const llvm::detail::IEEEFloat *)&v253);
    char v60 = v61;
  }
  else
  {
    char v60 = 0;
  }
  if (v59 == (void *)v253) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v253);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v253);
  }
  if (v59 == (void *)v250)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v250);
    if (v60) {
      goto LABEL_62;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v250);
    if (v60) {
      goto LABEL_62;
    }
  }
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v227, (uint64_t)&GOCConstant);
  float v62 = llvm::APFloat::convertToFloat((llvm::APFloat *)&GOCConstant);
  if (v59 == (void *)v250) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v250);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v250);
  }
  uint64_t v63 = *(mlir::MLIRContext **)(v227 + 24);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  *(float *)&v252 = v62;
  uint64_t v250 = v65;
  uint64_t v66 = *(mlir::MLIRContext **)(v227 + 24);
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  LODWORD(v242) = 0;
  uint64_t v253 = v68;
  v236 = 0;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225);
  uint64_t v70 = (void *)mlir::anec::getIndexFromDim(4, v69);
  if (!v71) {
    goto LABEL_203;
  }
  v236 = v70;
  uint64_t v72 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v225) + 8 * v70);
  if (v72 == 5)
  {
    uint64_t v73 = *(void *)(v227 + 24);
    LODWORD(v242) = 4;
    LODWORD(v239) = 1;
    int v74 = (char *)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v73, &v224, (unint64_t *)&v236, (int *)&v242, (int *)&v239)- 16;
    uint64_t v75 = *(void *)(v227 + 24);
    LODWORD(v242) = 0;
    LODWORD(v239) = 4;
    uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v75, &v224, (unint64_t *)&v236, (int *)&v242, (int *)&v239)- 16;
  }
  else
  {
    int v74 = 0;
  }
  if (!(_BYTE)v250 || !(_BYTE)v253) {
LABEL_203:
  }
    std::__throw_bad_optional_access[abi:nn180100]();
  uint64_t v76 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(v227 + 24), &v224, &GOCConstant, &v252);
  uint64_t v224 = (uint64_t)v76 - 16;
  if (v72 == 5)
  {
    uint64_t v77 = *(void *)(v227 + 24);
    v239 = (char *)v76 - 16;
    uint64_t v240 = (uint64_t)v74;
    mlir::ValueRange::ValueRange((unint64_t *)&v242, (uint64_t)&v239, 2uLL);
    LOBYTE(v234[0]) = 0;
    uint64_t v224 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 8), v77, (uint64_t *)&v242, (unint64_t *)&v236, (unsigned __int8 *)v234)- 16;
  }
LABEL_62:
  uint64_t v78 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v258, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v78) {
    goto LABEL_71;
  }
  uint64_t v79 = *v78;
  unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v81 = *(unsigned int *)(v79 + 16);
  if (!v81) {
    goto LABEL_71;
  }
  uint64_t v82 = *(void **)(v79 + 8);
  uint64_t v83 = &v82[2 * v81];
  do
  {
    unint64_t v84 = v81 >> 1;
    char v85 = &v82[2 * (v81 >> 1)];
    unint64_t v87 = *v85;
    long long v86 = v85 + 2;
    v81 += ~(v81 >> 1);
    if (v87 < v80) {
      uint64_t v82 = v86;
    }
    else {
      unint64_t v81 = v84;
    }
  }
  while (v81);
  if (v82 != v83 && *v82 == v80) {
    uint64_t v88 = v82[1];
  }
  else {
LABEL_71:
  }
    uint64_t v88 = 0;
  v222[0] = v78;
  v222[1] = v88;
  uint64_t v90 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v222);
  uint64_t v91 = v89;
  v252 = (ZinIrHalH13g *)v254;
  uint64_t v253 = 0x500000000;
  size_t v92 = 8 * v89;
  if ((unint64_t)(8 * v89) < 0x29)
  {
    unsigned int v93 = 0;
    if (!v89) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v252, v254, (8 * v89) >> 3, 8);
  unsigned int v93 = v253;
  if (v91)
  {
LABEL_76:
    memcpy((char *)v252 + 8 * v93, v90, v92);
    unsigned int v93 = v253;
  }
LABEL_77:
  LODWORD(v253) = v93 + (v92 >> 3);
  unint64_t v94 = mlir::anec::getIndexFromDim(4, v256);
  if (!v95) {
    goto LABEL_203;
  }
  uint64_t v96 = v255[v94];
  GOCConstant = (void *)1;
  llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v252, (uint64_t)v252 + 8 * (v96 == 5), (uint64_t *)&GOCConstant);
  char v97 = (uint64_t *)v252;
  uint64_t v98 = (mlir::AffineMap *)v253;
  uint64_t v99 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v222);
  uint64_t v221 = mlir::MemRefType::get(v97, v98, v99, 0, 0, 0);
  uint64_t v100 = *(void *)(v227 + 24);
  GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v258, 0);
  uint64_t v220 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v100, &v221, (uint64_t *)&GOCConstant)- 16;
  if (v96 == 5) {
    goto LABEL_88;
  }
  GOCConstant = v251;
  uint64_t v250 = 0x500000000;
  int v101 = v253;
  if (v253)
  {
    if (v253 < 6)
    {
      uint64_t v103 = v251;
      unsigned int v102 = v253;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&GOCConstant, v251, v253, 8);
      unsigned int v102 = v253;
      if (!v253)
      {
LABEL_85:
        LODWORD(v250) = v101;
        goto LABEL_86;
      }
      uint64_t v103 = GOCConstant;
    }
    memcpy(v103, v252, 8 * v102);
    goto LABEL_85;
  }
LABEL_86:
  uint64_t v104 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v223);
  long long v105 = (uint64_t *)GOCConstant;
  *(void *)GOCConstant = *v104;
  uint64_t v106 = (mlir::AffineMap *)v250;
  uint64_t v107 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v222);
  v242 = (void *)mlir::MemRefType::get(v105, v106, v107, 0, 0, 0);
  uint64_t v220 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v227 + 24), (uint64_t *)&v242, &v220)- 16;
  if (GOCConstant != v251) {
    free(GOCConstant);
  }
LABEL_88:
  GOCConstant = v251;
  uint64_t v250 = 0x400000000;
  v251[8] = 4;
  uint64_t ResizeHeight = mlir::mps::CropResizeOp::getResizeHeight((mlir::mps::CropResizeOp *)&v227);
  Resizeunsigned int Width = mlir::mps::CropResizeOp::getResizeWidth((mlir::mps::CropResizeOp *)&v227);
  v246 = v248;
  v248[0] = ResizeHeight;
  v248[1] = ResizeWidth;
  uint64_t v247 = 0x200000002;
  v242 = (void *)2;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v111 = (void *)mlir::RankedTensorType::get((uint64_t)&v242, 1, IntegerType, 0);
  unint64_t v112 = v111;
  if (!v111) {
    goto LABEL_97;
  }
  uint64_t v113 = *v111;
  unint64_t v114 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v115 = *(unsigned int *)(v113 + 16);
  if (!v115) {
    goto LABEL_97;
  }
  int64_t v116 = *(void **)(v113 + 8);
  unint64_t v117 = &v116[2 * v115];
  do
  {
    unint64_t v118 = v115 >> 1;
    uint64_t v119 = &v116[2 * (v115 >> 1)];
    unint64_t v121 = *v119;
    uint64_t v120 = v119 + 2;
    v115 += ~(v115 >> 1);
    if (v121 < v114) {
      int64_t v116 = v120;
    }
    else {
      unint64_t v115 = v118;
    }
  }
  while (v115);
  if (v116 != v117 && *v116 == v114) {
    uint64_t v122 = v116[1];
  }
  else {
LABEL_97:
  }
    uint64_t v122 = 0;
  uint64_t v123 = mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v246, 8 * v247, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"output_dims", 11, v123);
  v242 = v244;
  memset(v244, 0, sizeof(v244));
  uint64_t v245 = 0;
  uint64_t v243 = 0x500000005;
  uint64_t v124 = 0;
  if (mlir::mps::CropResizeOp::getNormalizeCoordinates((mlir::mps::CropResizeOp *)&v227)) {
    uint64_t v124 = 2 * (mlir::mps::PadOp::getPaddingMode((mlir::mps::PadOp *)&v227) == 1);
  }
  if (mlir::mps::CropResizeOp::getNormalizeCoordinates((mlir::mps::CropResizeOp *)&v227)
    && mlir::mps::PadOp::getPaddingMode((mlir::mps::PadOp *)&v227) == 2)
  {
    uint64_t v124 = 1;
  }
  v239 = v241;
  v241[0] = v124;
  v241[1] = v124;
  v241[2] = v124;
  v241[3] = v124;
  v241[4] = v124;
  uint64_t v240 = 0x500000005;
  v236 = (void *)5;
  uint64_t v125 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  long long v126 = (void *)mlir::RankedTensorType::get((uint64_t)&v236, 1, v125, 0);
  int64_t v127 = v126;
  if (!v126) {
    goto LABEL_112;
  }
  uint64_t v128 = *v126;
  unint64_t v129 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v130 = *(unsigned int *)(v128 + 16);
  if (!v130) {
    goto LABEL_112;
  }
  unint64_t v131 = *(void **)(v128 + 8);
  __int16 v132 = &v131[2 * v130];
  do
  {
    unint64_t v133 = v130 >> 1;
    unint64_t v134 = &v131[2 * (v130 >> 1)];
    unint64_t v136 = *v134;
    uint64_t v135 = v134 + 2;
    v130 += ~(v130 >> 1);
    if (v136 < v129) {
      unint64_t v131 = v135;
    }
    else {
      unint64_t v130 = v133;
    }
  }
  while (v130);
  if (v131 != v132 && *v131 == v129) {
    uint64_t v137 = v131[1];
  }
  else {
LABEL_112:
  }
    uint64_t v137 = 0;
  uint64_t v138 = mlir::DenseElementsAttr::getFromRawBuffer(v127, v137, v242, 8 * v243, 8, 1, 0);
  v236 = (void *)5;
  uint64_t v139 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  int v140 = (void *)mlir::RankedTensorType::get((uint64_t)&v236, 1, v139, 0);
  uint64_t v141 = v140;
  if (!v140) {
    goto LABEL_122;
  }
  uint64_t v142 = *v140;
  unint64_t v143 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v144 = *(unsigned int *)(v142 + 16);
  if (!v144) {
    goto LABEL_122;
  }
  v145 = *(void **)(v142 + 8);
  unint64_t v146 = &v145[2 * v144];
  do
  {
    unint64_t v147 = v144 >> 1;
    unint64_t v148 = &v145[2 * (v144 >> 1)];
    unint64_t v150 = *v148;
    uint64_t v149 = v148 + 2;
    v144 += ~(v144 >> 1);
    if (v150 < v143) {
      v145 = v149;
    }
    else {
      unint64_t v144 = v147;
    }
  }
  while (v144);
  if (v145 != v146 && *v145 == v143) {
    uint64_t v151 = v145[1];
  }
  else {
LABEL_122:
  }
    uint64_t v151 = 0;
  uint64_t v152 = mlir::DenseElementsAttr::getFromRawBuffer(v141, v151, v239, 8 * v240, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"normalized_range", 16, v138);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"coordinate_mode", 15, v152);
  int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v227);
  v236 = v238;
  v238[0] = InterpolationMode != 1;
  v238[1] = v238[0];
  v238[2] = v238[0];
  v238[3] = v238[0];
  v238[4] = v238[0];
  uint64_t v237 = 0x500000005;
  v234[0] = (void *)5;
  uint64_t v154 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unsigned int v155 = (void *)mlir::RankedTensorType::get((uint64_t)v234, 1, v154, 0);
  uint64_t v156 = v155;
  if (!v155) {
    goto LABEL_132;
  }
  uint64_t v157 = *v155;
  unint64_t v158 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v159 = *(unsigned int *)(v157 + 16);
  if (!v159) {
    goto LABEL_132;
  }
  unsigned int v160 = *(void **)(v157 + 8);
  uint64_t v161 = &v160[2 * v159];
  do
  {
    unint64_t v162 = v159 >> 1;
    int v163 = &v160[2 * (v159 >> 1)];
    unint64_t v165 = *v163;
    BOOL v164 = v163 + 2;
    v159 += ~(v159 >> 1);
    if (v165 < v158) {
      unsigned int v160 = v164;
    }
    else {
      unint64_t v159 = v162;
    }
  }
  while (v159);
  if (v160 != v161 && *v160 == v158) {
    uint64_t v166 = v160[1];
  }
  else {
LABEL_132:
  }
    uint64_t v166 = 0;
  uint64_t v167 = mlir::DenseElementsAttr::getFromRawBuffer(v156, v166, v236, 8 * v237, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_method", 15, v167);
  uint64_t v168 = qword_211F1A528[(int)mlir::mps::PadOp::getPaddingMode((mlir::mps::PadOp *)&v227)];
  v234[0] = v235;
  v235[0] = v168;
  v235[1] = v168;
  v235[2] = v168;
  v235[3] = v168;
  v235[4] = v168;
  v234[1] = (void *)0x500000005;
  v231 = (void *)5;
  uint64_t v169 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v170 = (void *)mlir::RankedTensorType::get((uint64_t)&v231, 1, v169, 0);
  unint64_t v171 = v170;
  if (!v170) {
    goto LABEL_142;
  }
  uint64_t v172 = *v170;
  unint64_t v173 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v174 = *(unsigned int *)(v172 + 16);
  if (!v174) {
    goto LABEL_142;
  }
  unsigned int v175 = *(void **)(v172 + 8);
  v176 = &v175[2 * v174];
  do
  {
    unint64_t v177 = v174 >> 1;
    uint64_t v178 = &v175[2 * (v174 >> 1)];
    unint64_t v180 = *v178;
    __int32 v179 = v178 + 2;
    v174 += ~(v174 >> 1);
    if (v180 < v173) {
      unsigned int v175 = v179;
    }
    else {
      unint64_t v174 = v177;
    }
  }
  while (v174);
  if (v175 != v176 && *v175 == v173) {
    uint64_t v181 = v175[1];
  }
  else {
LABEL_142:
  }
    uint64_t v181 = 0;
  uint64_t v182 = mlir::DenseElementsAttr::getFromRawBuffer(v171, v181, v236, 8 * v237, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_mode", 13, v182);
  v231 = v233;
  memset_pattern16(v233, &xmmword_211EE6370, 0x28uLL);
  uint64_t v232 = 0x500000005;
  v230[0] = 5;
  uint64_t v183 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v184 = (void *)mlir::RankedTensorType::get((uint64_t)v230, 1, v183, 0);
  v185 = v184;
  if (!v184) {
    goto LABEL_152;
  }
  uint64_t v186 = *v184;
  unint64_t v187 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v188 = *(unsigned int *)(v186 + 16);
  if (!v188) {
    goto LABEL_152;
  }
  v189 = *(void **)(v186 + 8);
  uint64_t v190 = &v189[2 * v188];
  do
  {
    unint64_t v191 = v188 >> 1;
    uint64_t v192 = &v189[2 * (v188 >> 1)];
    unint64_t v194 = *v192;
    unint64_t v193 = v192 + 2;
    v188 += ~(v188 >> 1);
    if (v194 < v187) {
      v189 = v193;
    }
    else {
      unint64_t v188 = v191;
    }
  }
  while (v188);
  if (v189 != v190 && *v189 == v187) {
    uint64_t v195 = v189[1];
  }
  else {
LABEL_152:
  }
    uint64_t v195 = 0;
  uint64_t v196 = mlir::DenseElementsAttr::getFromRawBuffer(v185, v195, v231, 8 * v232, 8, 1, 0);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"padding_modes", 13, v196);
  F16FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v197);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"background_value", 16, (uint64_t)F16FloatAttr);
  uint64_t v199 = (uint64_t *)(*(void *)(*(void *)(*(void *)(v227 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v199) {
    goto LABEL_162;
  }
  uint64_t v200 = *v199;
  unint64_t v201 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v202 = *(unsigned int *)(v200 + 16);
  if (!v202) {
    goto LABEL_162;
  }
  v203 = *(void **)(v200 + 8);
  v204 = &v203[2 * v202];
  do
  {
    unint64_t v205 = v202 >> 1;
    v206 = &v203[2 * (v202 >> 1)];
    unint64_t v208 = *v206;
    v207 = v206 + 2;
    v202 += ~(v202 >> 1);
    if (v208 < v201) {
      v203 = v207;
    }
    else {
      unint64_t v202 = v205;
    }
  }
  while (v202);
  if (v203 != v204 && *v203 == v201) {
    uint64_t v209 = v203[1];
  }
  else {
LABEL_162:
  }
    uint64_t v209 = 0;
  v230[0] = v199;
  v230[1] = v209;
  uint64_t v210 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v230) + 8);
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v227 + 24));
  switch(mlir::mps::CropResizeOp::getCoordinateMode((mlir::mps::CropResizeOp *)&v227))
  {
    case 1u:
      if (v210 == 5) {
        unint64_t v212 = 1;
      }
      else {
        unint64_t v212 = 9;
      }
      break;
    case 2u:
      BOOL v213 = v210 == 5;
      uint64_t v214 = 10;
      uint64_t v215 = 2;
      goto LABEL_170;
    case 3u:
      BOOL v213 = v210 == 5;
      uint64_t v214 = 11;
      uint64_t v215 = 3;
LABEL_170:
      if (v213) {
        unint64_t v212 = v215;
      }
      else {
        unint64_t v212 = v214;
      }
      break;
    default:
      unint64_t v212 = 8 * (v210 != 5);
      break;
  }
  uint64_t v216 = mlir::anec::BoxCoordinateModeAttr::get(Context, v212);
  mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"box_coordinate_mode", 19, v216);
  uint64_t v217 = v227;
  v228[0] = v220;
  v228[1] = v224;
  mlir::ValueRange::ValueRange((unint64_t *)v229, (uint64_t)v228, 2uLL);
  unint64_t v218 = mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v217 + 24), v229, (uint64_t)&GOCConstant);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v217, v218);
  if (v231 != v233) {
    free(v231);
  }
  if (v234[0] != v235) {
    free(v234[0]);
  }
  if (v236 != v238) {
    free(v236);
  }
  if (v239 != v241) {
    free(v239);
  }
  if (v242 != v244) {
    free(v242);
  }
  if (v246 != v248) {
    free(v246);
  }
  if (GOCConstant != v251) {
    free(GOCConstant);
  }
  if (v252 != (ZinIrHalH13g *)v254) {
    free(v252);
  }
  if (v255 != (void *)v257) {
    free(v255);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, int *a5, int *a6)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"anec.input_view";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.gain_offset_control";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GOC::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5 - 16);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.concat", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.concat";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Concat::build(a1, (uint64_t)v21, *a3, a3[1], *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.broadcast", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"anec.broadcast";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Broadcast,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.crop_resize", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"anec.crop_resize";
    void v21[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::CropResize::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::CropResize,void>::id) {
    __int16 v16 = v15;
  }
  else {
    __int16 v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertDepthwiseConv3D::~ConvertDepthwiseConv3D(mlir::_anonymous_namespace_::ConvertDepthwiseConv3D *this)
{
  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  unint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 80);
  uint64_t v9 = *(void *)(a3 + 88);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      void v35[2] = *(_OWORD *)(a3 + 32);
      v35[3] = v28;
      long long v29 = *(_OWORD *)(a3 + 80);
      v35[4] = *(_OWORD *)(a3 + 64);
      v35[5] = v29;
      long long v30 = *(_OWORD *)(a3 + 16);
      v35[0] = *(_OWORD *)a3;
      v35[1] = v30;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v35, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v34 = 259;
    v31[0] = v33;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v31);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v34 = 259;
  unint64_t v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  }
  return result;
}

void mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, void *a4)
{
  uint64_t v119 = *MEMORY[0x263EF8340];
  uint64_t v104 = a2;
  long long v118 = *(_OWORD *)(a3 + 80);
  uint64_t v6 = *((void *)a2 + 3);
  uint64_t v103 = mlir::ValueRange::dereference_iterator(&v118, 0);
  unint64_t v7 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v118, 1);
  unsigned int v102 = v7;
  uint64_t Result = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v104);
  uint64_t v9 = (uint64_t *)(*(void *)(v103 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  v101[0] = v9;
  v101[1] = v19;
  uint64_t v20 = (uint64_t *)(v7[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *v20;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_20;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_20:
  }
    uint64_t v30 = 0;
  v100[0] = v20;
  v100[1] = v30;
  if (*(void *)(Result + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v117, *(const mlir::TypeConverter **)(a1 + 96));
  mlir::ShapedType::getShape((mlir::ShapedType *)v101);
  if (v31 == 4 && (mlir::ShapedType::getShape((mlir::ShapedType *)v100), v32 == 4))
  {
    uint64_t ChannelAxis = (int)mlir::mps::DepthwiseConv3DOp::getChannelAxis((mlir::mps::DepthwiseConv3DOp *)&v104);
    __int16 v34 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v104) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v34) {
      goto LABEL_34;
    }
    uint64_t v35 = *v34;
    unint64_t v36 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v37 = *(unsigned int *)(v35 + 16);
    if (!v37) {
      goto LABEL_34;
    }
    uint64_t v38 = *(void **)(v35 + 8);
    uint64_t v39 = &v38[2 * v37];
    do
    {
      unint64_t v40 = v37 >> 1;
      long long v41 = &v38[2 * (v37 >> 1)];
      unint64_t v43 = *v41;
      uint64_t v42 = v41 + 2;
      v37 += ~(v37 >> 1);
      if (v43 < v36) {
        uint64_t v38 = v42;
      }
      else {
        unint64_t v37 = v40;
      }
    }
    while (v37);
    if (v38 != v39 && *v38 == v36) {
      uint64_t v44 = v38[1];
    }
    else {
LABEL_34:
    }
      uint64_t v44 = 0;
    uint64_t Strides = (uint64_t)v34;
    uint64_t v106 = v44;
    mlir::ShapedType::getShape((mlir::ShapedType *)&Strides);
    if (mlir::getPositiveAxis(ChannelAxis, v45) == 1)
    {
      if (*(void *)mlir::ShapedType::getShape((mlir::ShapedType *)v100) == 1)
      {
        uint64_t v46 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v100) + 8);
        uint64_t v47 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v101) + 8);
        uint64_t v98 = 0;
        uint64_t v99 = 0;
        unint64_t v114 = &v98;
        uint64_t Strides = (uint64_t)v7;
        uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Strides);
        if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v114, DefiningOp))
        {
          uint64_t Strides = 3;
          uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          char v97 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, IntegerType, 0);
          uint64_t Strides = 6;
          uint64_t v50 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          uint64_t v96 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, v50, 0);
          unint64_t v114 = v116;
          uint64_t v115 = 0x300000000;
          uint64_t Strides = mlir::mps::DepthwiseConv2DOp::getStrides((mlir::mps::DepthwiseConv2DOp *)&v104);
          long long v51 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
          mlir::getIntValues<unsigned long long>((uint64_t)v51, v52, (uint64_t)&v114, 1);
          if (*(void *)v114 == 1)
          {
            uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(&v97);
            uint64_t v95 = mlir::DenseElementsAttr::getFromRawBuffer(v53, v54, v114, 8 * v115, 8, 1, 0);
            unint64_t v111 = v113;
            uint64_t v112 = 0x300000000;
            uint64_t Strides = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v104);
            uint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            mlir::getIntValues<unsigned long long>((uint64_t)v55, v56, (uint64_t)&v111, 1);
            uint64_t v57 = mlir::Type::cast<mlir::ShapedType>(&v97);
            uint64_t v94 = mlir::DenseElementsAttr::getFromRawBuffer(v57, v58, v111, 8 * v112, 8, 1, 0);
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v100);
            uint64_t v60 = *((void *)v111 + 1) * (*(void *)(Shape + 16) - 1) + 1;
            uint64_t v61 = mlir::ShapedType::getShape((mlir::ShapedType *)v100);
            uint64_t v62 = *((void *)v111 + 2) * (*(void *)(v61 + 24) - 1) + 1;
            unint64_t v92 = 0;
            unint64_t v93 = 0;
            unint64_t v90 = 0;
            unint64_t v91 = 0;
            uint64_t Strides = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v104);
            uint64_t v63 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            uint64_t v65 = v64;
            int PaddingStyle = mlir::mps::DepthwiseConv2DOp::getPaddingStyle((mlir::mps::DepthwiseConv2DOp *)&v104);
            uint64_t v67 = mlir::ShapedType::getShape((mlir::ShapedType *)v101);
            {
              uint64_t ArgOperands = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v96);
              uint64_t v88 = v69;
              uint64_t Strides = 0;
              uint64_t v106 = 0;
              unint64_t v107 = v93;
              unint64_t v108 = v92;
              unint64_t v109 = v91;
              unint64_t v110 = v90;
              v86[0] = (uint64_t)&Strides;
              v86[1] = 6;
              uint64_t v89 = mlir::DenseIntElementsAttr::get<unsigned long long>(&ArgOperands, v86);
              v86[0] = 0;
              if (v46 / v47 == 1)
              {
                LODWORD(v85) = 1;
                LOBYTE(v84) = 1;
                uint64_t Strides = 0;
                uint64_t ArgOperands = 0;
                uint64_t v70 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v103, (uint64_t *)&v102, &v95, &v94, &v89, (unint64_t *)v86, (int *)&v85, (char *)&v84);
              }
              else
              {
                unint64_t v85 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v101) + 8);
                uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v98);
                uint64_t v88 = v77;
                uint64_t Strides = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v100) + 8);
                uint64_t v106 = 1;
                unint64_t v107 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v100) + 16);
                unint64_t v108 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v100) + 24);
                uint64_t v78 = (void *)mlir::ShapedType::clone((mlir::MemoryMapperInterface *)&ArgOperands, (uint64_t)&Strides, 4);
                uint64_t ArgOperands = mlir::TypeConverter::convertType((uint64_t)v117, v78);
                uint64_t v79 = v98;
                uint64_t v80 = v99;
                unint64_t v84 = (uint64_t *)v78;
                unint64_t v81 = mlir::Type::cast<mlir::ShapedType>(&v84);
                uint64_t Strides = (uint64_t)mlir::reshapeElementsAttr(v79, v80, (uint64_t)v81, v82);
                uint64_t v106 = v83;
                unsigned int v102 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v6, &ArgOperands, (void **)&Strides)- 16);
                LOBYTE(v84) = 0;
                uint64_t Strides = 0;
                uint64_t ArgOperands = 0;
                uint64_t v70 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v103, (uint64_t *)&v102, &v95, &v94, &v89, (unint64_t *)v86, &v85, (char *)&v84);
              }
              mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v104, v70);
            }
            else
            {
            }
            if (v111 != v113) {
              free(v111);
            }
          }
          else
          {
          }
          if (v114 != v116) {
            free(v114);
          }
        }
        else
        {
        }
LABEL_55:
        mlir::TypeConverter::~TypeConverter(v117);
      }
      uint64_t v71 = a4[2];
      if (!v71) {
        goto LABEL_55;
      }
      uint64_t v76 = v104;
      if (!mlir::RewriterBase::Listener::classof(v71)) {
        goto LABEL_55;
      }
      uint64_t v73 = *((void *)v76 + 3);
    }
    else
    {
      uint64_t v71 = a4[2];
      if (!v71) {
        goto LABEL_55;
      }
      uint64_t v75 = v104;
      if (!mlir::RewriterBase::Listener::classof(v71)) {
        goto LABEL_55;
      }
      uint64_t v73 = *((void *)v75 + 3);
    }
  }
  else
  {
    uint64_t v71 = a4[2];
    if (!v71) {
      goto LABEL_55;
    }
    uint64_t v72 = v104;
    if (!mlir::RewriterBase::Listener::classof(v71)) {
      goto LABEL_55;
    }
    uint64_t v73 = *((void *)v72 + 3);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v71 + 64))(v71, v73, v74, &Strides);
  goto LABEL_55;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

void mlir::getIntValues<unsigned long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v132[5] = *MEMORY[0x263EF8340];
  *(void *)&long long v126 = a1;
  *((void *)&v126 + 1) = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v126) || a4) {
    unint64_t NumElements = mlir::ElementsAttr::getNumElements(v126, *((uint64_t *)&v126 + 1));
  }
  else {
    unint64_t NumElements = 1;
  }
  unint64_t v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 8);
        unint64_t v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7) {
        bzero((void *)(*(void *)a3 + 8 * v7), 8 * (NumElements - v7));
      }
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  unint64_t v8 = *(uint64x2_t **)a3;
  long long v129 = v126;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v129);
  uint64_t v10 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v11 = *Type;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_21;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  unint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_21:
  }
    uint64_t v20 = 0;
  v128[0] = v10;
  v128[1] = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v128);
  int v21 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v129);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v129);
  uint64_t v24 = v23;
  if (!v21 || a4)
  {
    uint64_t v25 = mlir::ElementsAttr::getNumElements(v129, *((uint64_t *)&v129 + 1));
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_39;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1) {
        return;
      }
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v31 = 0;
        unint64_t v30 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v32 = 0;
          }
          else {
            unint64_t v32 = v31;
          }
          if (v21) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v31 + 1;
          }
          uint64_t v34 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v33];
          uint64_t v35 = &v8[v31 / 2];
          v35->i64[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v32];
          v35->i64[1] = v34;
          v31 += 2;
        }
        while (v31 != v30);
        goto LABEL_282;
      }
      goto LABEL_48;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_66;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_73;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_89;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_105;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_125;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_136;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_143;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_159;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
LABEL_174:
      if ((unint64_t)v25 >= 2)
      {
        uint64_t v96 = 0;
        unint64_t v72 = v25 & 0xFFFFFFFFFFFFFFFELL;
        char v97 = v8;
        do
        {
          if (v21) {
            uint64_t v98 = 0;
          }
          else {
            uint64_t v98 = v96;
          }
          if (v21) {
            uint64_t v99 = 0;
          }
          else {
            uint64_t v99 = v96 + 1;
          }
          v71.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v98];
          v71.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v99];
          uint64x2_t v71 = vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)v71.i8, 0x10uLL)));
          *v97++ = v71;
          v96 += 2;
        }
        while (v96 != v72);
        goto LABEL_324;
      }
      unint64_t v72 = 0;
      do
      {
        if (v21) {
          unint64_t v123 = 0;
        }
        else {
          unint64_t v123 = v72;
        }
        v8->i64[v72++] = (unint64_t)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v123] << 16);
LABEL_324:
        ;
      }
      while (v25 != v72);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      uint64_t v25 = 1;
LABEL_28:
      for (uint64_t i = 0; i != v25; ++i)
      {
        if (v21) {
          uint64_t v27 = 0;
        }
        else {
          uint64_t v27 = i;
        }
        v8->i64[i] = ElementsAttrRawData[v27];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      uint64_t v25 = 1;
LABEL_39:
      for (uint64_t j = 0; j != v25; ++j)
      {
        if (v21) {
          uint64_t v29 = 0;
        }
        else {
          uint64_t v29 = j;
        }
        v8->i64[j] = (char)ElementsAttrRawData[v29];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      uint64_t v25 = 1;
LABEL_48:
      unint64_t v30 = 0;
      do
      {
        if (v21) {
          unint64_t v116 = 0;
        }
        else {
          unint64_t v116 = v30;
        }
        v8->i64[v30++] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v116];
LABEL_282:
        ;
      }
      while (v25 != v30);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      uint64_t v25 = 1;
LABEL_66:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v38 = 0;
        unint64_t v36 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v39 = 0;
          }
          else {
            unint64_t v39 = v38;
          }
          if (v21) {
            unint64_t v40 = 0;
          }
          else {
            unint64_t v40 = v38 + 1;
          }
          uint64_t v41 = *(__int16 *)&ElementsAttrRawData[2 * v40];
          uint64_t v42 = &v8[v38 / 2];
          v42->i64[0] = *(__int16 *)&ElementsAttrRawData[2 * v39];
          v42->i64[1] = v41;
          v38 += 2;
        }
        while (v38 != v36);
        goto LABEL_288;
      }
      unint64_t v36 = 0;
      do
      {
        if (v21) {
          unint64_t v117 = 0;
        }
        else {
          unint64_t v117 = v36;
        }
        v8->i64[v36++] = *(__int16 *)&ElementsAttrRawData[2 * v117];
LABEL_288:
        ;
      }
      while (v25 != v36);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v25 = 1;
LABEL_73:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v44 = 0;
        unint64_t v37 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v45 = 0;
          }
          else {
            unint64_t v45 = v44;
          }
          if (v21) {
            unint64_t v46 = 0;
          }
          else {
            unint64_t v46 = v44 + 1;
          }
          uint64_t v47 = *(unsigned int *)&ElementsAttrRawData[4 * v46];
          long long v48 = &v8[v44 / 2];
          v48->i64[0] = *(unsigned int *)&ElementsAttrRawData[4 * v45];
          v48->i64[1] = v47;
          v44 += 2;
        }
        while (v44 != v37);
        goto LABEL_294;
      }
      unint64_t v37 = 0;
      do
      {
        if (v21) {
          unint64_t v118 = 0;
        }
        else {
          unint64_t v118 = v37;
        }
        v8->i64[v37++] = *(unsigned int *)&ElementsAttrRawData[4 * v118];
LABEL_294:
        ;
      }
      while (v25 != v37);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v25 = 1;
LABEL_89:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v51 = 0;
        unint64_t v43 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v52 = 0;
          }
          else {
            unint64_t v52 = v51;
          }
          if (v21) {
            unint64_t v53 = 0;
          }
          else {
            unint64_t v53 = v51 + 1;
          }
          uint64_t v54 = *(int *)&ElementsAttrRawData[4 * v53];
          uint64_t v55 = &v8[v51 / 2];
          v55->i64[0] = *(int *)&ElementsAttrRawData[4 * v52];
          v55->i64[1] = v54;
          v51 += 2;
        }
        while (v51 != v43);
        goto LABEL_300;
      }
      unint64_t v43 = 0;
      do
      {
        if (v21) {
          unint64_t v119 = 0;
        }
        else {
          unint64_t v119 = v43;
        }
        v8->i64[v43++] = *(int *)&ElementsAttrRawData[4 * v119];
LABEL_300:
        ;
      }
      while (v25 != v43);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v25 = 1;
LABEL_105:
      for (uint64_t k = 0; k != v25; ++k)
      {
        if (v21) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = k;
        }
        v8->i64[k] = *(void *)&ElementsAttrRawData[8 * v50];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v25 = 1;
LABEL_125:
      for (uint64_t m = 0; m != v25; ++m)
      {
        if (v21) {
          uint64_t v57 = 0;
        }
        else {
          uint64_t v57 = m;
        }
        v8->i64[m] = *(void *)&ElementsAttrRawData[8 * v57];
      }
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_136:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v60 = 0;
        unint64_t v58 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v61 = 0;
          }
          else {
            unint64_t v61 = v60;
          }
          if (v21) {
            unint64_t v62 = 0;
          }
          else {
            unint64_t v62 = v60 + 1;
          }
          unint64_t v63 = (unint64_t)*(short float *)&ElementsAttrRawData[2 * v62];
          uint64_t v64 = &v8[v60 / 2];
          v64->i64[0] = (unint64_t)*(short float *)&ElementsAttrRawData[2 * v61];
          v64->i64[1] = v63;
          v60 += 2;
        }
        while (v60 != v58);
        goto LABEL_306;
      }
      unint64_t v58 = 0;
      do
      {
        if (v21) {
          unint64_t v120 = 0;
        }
        else {
          unint64_t v120 = v58;
        }
        v8->i64[v58++] = (unint64_t)*(short float *)&ElementsAttrRawData[2 * v120];
LABEL_306:
        ;
      }
      while (v25 != v58);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_143:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v66 = 0;
        unint64_t v59 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v67 = 0;
          }
          else {
            unint64_t v67 = v66;
          }
          if (v21) {
            unint64_t v68 = 0;
          }
          else {
            unint64_t v68 = v66 + 1;
          }
          unint64_t v69 = (unint64_t)*(float *)&ElementsAttrRawData[4 * v68];
          uint64_t v70 = &v8[v66 / 2];
          v70->i64[0] = (unint64_t)*(float *)&ElementsAttrRawData[4 * v67];
          v70->i64[1] = v69;
          v66 += 2;
        }
        while (v66 != v59);
        goto LABEL_312;
      }
      unint64_t v59 = 0;
      do
      {
        if (v21) {
          unint64_t v121 = 0;
        }
        else {
          unint64_t v121 = v59;
        }
        v8->i64[v59++] = (unint64_t)*(float *)&ElementsAttrRawData[4 * v121];
LABEL_312:
        ;
      }
      while (v25 != v59);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_159:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v76 = 0;
        unint64_t v65 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v77 = 0;
          }
          else {
            unint64_t v77 = v76;
          }
          if (v21) {
            unint64_t v78 = 0;
          }
          else {
            unint64_t v78 = v76 + 1;
          }
          unint64_t v79 = (unint64_t)*(double *)&ElementsAttrRawData[8 * v78];
          uint64_t v80 = &v8[v76 / 2];
          v80->i64[0] = (unint64_t)*(double *)&ElementsAttrRawData[8 * v77];
          v80->i64[1] = v79;
          v76 += 2;
        }
        while (v76 != v65);
        goto LABEL_318;
      }
      unint64_t v65 = 0;
      do
      {
        if (v21) {
          unint64_t v122 = 0;
        }
        else {
          unint64_t v122 = v65;
        }
        v8->i64[v65++] = (unint64_t)*(double *)&ElementsAttrRawData[8 * v122];
LABEL_318:
        ;
      }
      while (v25 != v65);
      return;
    }
    uint64_t v25 = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      goto LABEL_174;
    }
  }
  if (!mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitunsigned int Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    if (!v24) {
      return;
    }
    uint64_t v82 = 0;
    int v83 = ~(-1 << IntOrFloatBitWidth);
    unint64_t v84 = v25;
    unint64_t v85 = 8 / IntOrFloatBitWidth;
    while (1)
    {
      unint64_t v86 = v82 * v85;
      unint64_t v87 = v25 - v82 * v85;
      if (v87 >= v85) {
        unint64_t v87 = 8 / IntOrFloatBitWidth;
      }
      if (!v87) {
        goto LABEL_194;
      }
      unsigned int v88 = *ElementsAttrRawData;
      if (v84 >= v85) {
        unint64_t v89 = 8 / IntOrFloatBitWidth;
      }
      else {
        unint64_t v89 = v84;
      }
      uint64x2_t v90 = (uint64x2_t)vdupq_n_s64(v89 - 1);
      int32x2_t v91 = vmovn_s64((int64x2_t)vcgeq_u64(v90, (uint64x2_t)xmmword_211ED5A80));
      if (v91.i8[0]) {
        v8->i64[v86] = v83 & v88;
      }
      if (v91.i8[4]) {
        v8->i64[v86 + 1] = (v88 >> IntOrFloatBitWidth) & v83;
      }
      uint64_t v92 = ((_BYTE)v89 + 1) & 0x1E;
      if (v92 == 2) {
        goto LABEL_194;
      }
      int32x2_t v93 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211ED4670));
      if (v93.i8[0])
      {
        v8[1].i64[v86] = (v88 >> (2 * IntOrFloatBitWidth)) & v83;
        if (v93.i8[4]) {
          goto LABEL_211;
        }
      }
      else if (v93.i8[4])
      {
LABEL_211:
        v8[1].i64[v86 + 1] = (v88 >> (3 * IntOrFloatBitWidth)) & v83;
        if (v92 == 4) {
          goto LABEL_194;
        }
        goto LABEL_212;
      }
      if (v92 == 4) {
        goto LABEL_194;
      }
LABEL_212:
      int32x2_t v94 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211F09590));
      if (v94.i8[0])
      {
        v8[2].i64[v86] = (v88 >> (4 * IntOrFloatBitWidth)) & v83;
        if ((v94.i8[4] & 1) == 0) {
          goto LABEL_214;
        }
      }
      else if ((v94.i8[4] & 1) == 0)
      {
LABEL_214:
        if (v92 != 6) {
          goto LABEL_218;
        }
        goto LABEL_194;
      }
      v8[2].i64[v86 + 1] = (v88 >> (5 * IntOrFloatBitWidth)) & v83;
      if (v92 != 6)
      {
LABEL_218:
        int32x2_t v95 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211F095A0));
        if (v95.i8[0]) {
          v8[3].i64[v86] = (v88 >> (6 * IntOrFloatBitWidth)) & v83;
        }
        if (v95.i8[4]) {
          v8[3].i64[v86 + 1] = (v88 >> (7 * IntOrFloatBitWidth)) & v83;
        }
      }
LABEL_194:
      ++v82;
      v84 -= v85;
      ++ElementsAttrRawData;
      if (!--v24) {
        return;
      }
    }
  }
  uint64_t v125 = v8;
  if (v21) {
    unint64_t v73 = 1;
  }
  else {
    unint64_t v73 = v25;
  }
  int v74 = v132;
  unint64_t v130 = v132;
  long long v131 = xmmword_211F09580;
  if (v73)
  {
    if (v73 < 0x29)
    {
      uint64_t v75 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v130, v132, v73, 1);
      int v74 = v130;
      uint64_t v75 = v131;
    }
    if (v73 != v75) {
      bzero((char *)v74 + v75, v73 - v75);
    }
    *(void *)&long long v131 = v73;
  }
  if (v24)
  {
    uint64_t v100 = (BOOL *)v74 + 3;
    do
    {
      if (v73 >= 8) {
        uint64_t v101 = 8;
      }
      else {
        uint64_t v101 = v73;
      }
      if (!v101) {
        goto LABEL_237;
      }
      if (v73 >= 8) {
        uint64_t v102 = 8;
      }
      else {
        uint64_t v102 = v73;
      }
      unsigned int v103 = *ElementsAttrRawData;
      uint64x2_t v104 = (uint64x2_t)vdupq_n_s64(v102 - 1);
      int32x2_t v105 = vmovn_s64((int64x2_t)vcgeq_u64(v104, (uint64x2_t)xmmword_211ED5A80));
      if (v105.i8[0]) {
        *(v100 - 3) = v103 & 1;
      }
      if (v105.i8[4]) {
        *(v100 - 2) = (v103 & 2) != 0;
      }
      uint64_t v106 = ((_BYTE)v102 + 1) & 0x1E;
      if (v106 == 2) {
        goto LABEL_237;
      }
      int32x2_t v107 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211ED4670));
      if (v107.i8[0])
      {
        *(v100 - 1) = (v103 & 4) != 0;
        if (v107.i8[4]) {
          goto LABEL_255;
        }
      }
      else if (v107.i8[4])
      {
LABEL_255:
        *uint64_t v100 = (v103 & 8) != 0;
        if (v106 == 4) {
          goto LABEL_237;
        }
        goto LABEL_256;
      }
      if (v106 == 4) {
        goto LABEL_237;
      }
LABEL_256:
      int32x2_t v108 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211F09590));
      if (v108.i8[0])
      {
        v100[1] = (v103 & 0x10) != 0;
        if ((v108.i8[4] & 1) == 0) {
          goto LABEL_258;
        }
      }
      else if ((v108.i8[4] & 1) == 0)
      {
LABEL_258:
        if (v106 != 6) {
          goto LABEL_262;
        }
        goto LABEL_237;
      }
      void v100[2] = (v103 & 0x20) != 0;
      if (v106 != 6)
      {
LABEL_262:
        int32x2_t v109 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211F095A0));
        if (v109.i8[0]) {
          v100[3] = (v103 & 0x40) != 0;
        }
        if (v109.i8[4]) {
          v100[4] = v103 >> 7;
        }
      }
LABEL_237:
      ++ElementsAttrRawData;
      v100 += 8;
      v73 -= 8;
      --v24;
    }
    while (v24);
  }
  if (v25 >= 1)
  {
    if (v25 == 1)
    {
      unint64_t v111 = 0;
      goto LABEL_326;
    }
    unint64_t v110 = 0;
    unint64_t v111 = v25 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      if (v21) {
        unint64_t v112 = 0;
      }
      else {
        unint64_t v112 = v110;
      }
      if (v21) {
        unint64_t v113 = 0;
      }
      else {
        unint64_t v113 = v110 + 1;
      }
      uint64_t v114 = *((unsigned __int8 *)v74 + v113);
      uint64_t v115 = &v125[v110 / 2];
      v115->i64[0] = *((unsigned __int8 *)v74 + v112);
      v115->i64[1] = v114;
      v110 += 2;
    }
    while (v110 != v111);
    while (v25 != v111)
    {
LABEL_326:
      if (v21) {
        unint64_t v124 = 0;
      }
      else {
        unint64_t v124 = v111;
      }
      v125->i64[v111++] = *((unsigned __int8 *)v74 + v124);
    }
  }
  if (v74 != v132) {
    free(v74);
  }
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::anonymous namespace'::getExplicitConv2DPadding(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, unint64_t *a11, unint64_t *a12, unint64_t *a13)
{
  v27[8] = *MEMORY[0x263EF8340];
  uint64_t v13 = 1;
  switch(a3)
  {
    case 0:
      uint64_t v25 = v27;
      uint64_t v26 = 0x800000000;
      mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v25, 1);
      uint64_t v20 = v25;
      int v21 = (char *)v25 + 8 * v26;
      if (v25 == v21 - 32)
      {
LABEL_12:
        *a10 = *((void *)v21 - 4);
        *a11 = *((void *)v21 - 3);
        *a12 = *((void *)v21 - 2);
        *a13 = *((void *)v21 - 1);
        uint64_t v13 = 1;
        if (v20 == v27) {
          return v13;
        }
        goto LABEL_16;
      }
      uint64_t v22 = 8 * v26 - 32;
      uint64_t v23 = v25;
      while (!*v23)
      {
        ++v23;
        v22 -= 8;
        if (!v22) {
          goto LABEL_12;
        }
      }
      uint64_t v13 = 0;
      if (v25 != v27) {
LABEL_16:
      }
        free(v20);
      return v13;
    case 1:
      *a10 = 0;
      *a11 = 0;
      *a12 = 0;
      *a13 = 0;
      return v13;
    case 2:
    case 4:
      uint64_t v14 = *(void *)(a4 + 16) % *(void *)(a6 + 8);
      if (!v14) {
        uint64_t v14 = *(void *)(a6 + 8);
      }
      unint64_t v15 = (a8 - v14) & ~((a8 - v14) >> 63);
      uint64_t v16 = *(void *)(a4 + 24) % *(void *)(a6 + 16);
      if (!v16) {
        uint64_t v16 = *(void *)(a6 + 16);
      }
      unint64_t v17 = (a9 - v16) & ~((a9 - v16) >> 63);
      *a10 = v15 >> 1;
      *a11 = v15 - (v15 >> 1);
      *a12 = v17 >> 1;
      *a13 = v17 - (v17 >> 1);
      if (a3 == 4)
      {
        unint64_t v18 = *a10;
        *a10 = *a11;
        *a11 = v18;
        unint64_t v19 = *a12;
        *a12 = *a13;
        *a13 = v19;
      }
      return v13;
    default:
      return v13;
  }
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16))) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t))(*(void *)v3 + 64);
}

uint64_t mlir::DenseIntElementsAttr::get<unsigned long long>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a2[1];
  if (v2) {
    uint64_t v3 = *a2;
  }
  else {
    uint64_t v3 = 0;
  }
  return mlir::DenseElementsAttr::getFromRawBuffer(*a1, a1[1], v3, 8 * v2, 8, 1, 0);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unint64_t *a8, int *a9, char *a10)
{
  v29[38] = *MEMORY[0x263EF8340];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  int v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t mlir::ShapedType::clone(mlir::MemoryMapperInterface *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v6 = a2;
  *((void *)&v6 + 1) = a3;
  char v7 = 1;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(a1);
  return mlir::ShapedType::cloneWith((uint64_t *)a1, &v6, OperandRange);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unint64_t *a8, unint64_t *a9, char *a10)
{
  v29[38] = *MEMORY[0x263EF8340];
  uint64_t v24 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    __int16 v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  int v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have 4D inputs\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use NCHW data format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use (1, C*ChannelMult, H, W) weights format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have constant weights");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Conv stride must be 1 for batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported padding values for Conv2D\n");
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    unint64_t v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::anonymous namespace'::anonymous namespace'::assembleBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v7 = *(void *)(v6 + 24);
  uint64_t v8 = *(void *)(v6 + 56);
  uint64_t v9 = **(void **)a3;
  uint64_t v10 = *(void *)(*(void *)a3 + 8);
  {
    uint64_t v13 = v12;
  }
  else
  {
      return;
    uint64_t BroadcastOperands = v14;
  }
  *(_DWORD *)(a3 + 8) = 0;
  if (*(_DWORD *)(a3 + 12) > 1u)
  {
    uint64_t v15 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), 2uLL, 8);
    uint64_t v15 = *(unsigned int *)(a3 + 8);
  }
  uint64_t v16 = (uint64_t *)(*(void *)a3 + 8 * v15);
  uint64_t *v16 = BroadcastOperands;
  v16[1] = v13;
  *(_DWORD *)(a3 + 8) += 2;
}

BOOL mlir::anonymous namespace'::anonymous namespace'::isBroadcastWithFullRank(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v33[0] = v3;
  v33[1] = v13;
  uint64_t v14 = (uint64_t *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v32[0] = v14;
  v32[1] = v24;
  mlir::ShapedType::getShape((mlir::ShapedType *)v33);
  uint64_t v26 = v25;
  mlir::ShapedType::getShape((mlir::ShapedType *)v32);
  if (v26 >= v27) {
    return 0;
  }
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v33);
  if (mlir::ShapedType::getNumElements(Shape, v29) < 2) {
    return 0;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)v32);
  return v30 > 3;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::getBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v51[4] = *MEMORY[0x263EF8340];
  uint64_t v47 = a4;
  uint64_t v48 = a5;
  uint64_t v10 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v46[0] = v10;
  v46[1] = v20;
  uint64_t v21 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21) {
    goto LABEL_20;
  }
  uint64_t v22 = *v21;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_20;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_20:
  }
    uint64_t v31 = 0;
  v45[0] = (uint64_t)v21;
  v45[1] = v31;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v45);
  uint64_t v34 = v32;
  unint64_t v49 = v51;
  uint64_t v50 = 0x400000000;
  size_t v35 = 8 * v32;
  if ((unint64_t)(8 * v32) < 0x21)
  {
    unsigned int v36 = 0;
    if (!v32) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, (8 * v32) >> 3, 8);
  unsigned int v36 = v50;
  if (v34)
  {
LABEL_25:
    memcpy((char *)v49 + 8 * v36, Shape, v35);
    unsigned int v36 = v50;
  }
LABEL_26:
  LODWORD(v50) = v36 + (v35 >> 3);
  mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  uint64_t v37 = (mlir::AffineMap *)v50;
  if (v38 != v50)
  {
    unint64_t v39 = v49;
    mlir::ShapedType::getShape((mlir::ShapedType *)v46);
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v49, (uint64_t)v39, v40 - v50, 1uLL);
    uint64_t v37 = (mlir::AffineMap *)v50;
  }
  uint64_t v41 = (uint64_t *)v49;
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a5);
  v45[0] = mlir::MemRefType::get(v41, v37, ElementTypeOrSelf, 0, 0, 0);
  mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a6 + 8), a1, v45, &v48);
  uint64_t v43 = v47;
  if (v49 != v51) {
    free(v49);
  }
  return v43;
}

uint64_t mlir::anonymous namespace'::anonymous namespace'::isCompatibleWithGOC(uint64_t a1, void *a2)
{
  v46[4] = *MEMORY[0x263EF8340];
  __s2 = a2;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__s2);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v5 = DefiningOp;
  uint64_t v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(v5 + 48) + 32))(*(void *)(v5 + 48), v6)) {
    return 0;
  }
  uint64_t v7 = (uint64_t *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  unint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_12:
  }
    uint64_t v17 = 0;
  v43[0] = v7;
  v43[1] = v17;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v43);
  if (mlir::ShapedType::getNumElements(Shape, v19) == 1) {
    return 1;
  }
  uint64_t v21 = mlir::ShapedType::getShape((mlir::ShapedType *)v43);
  if (v22 < 3) {
    return 0;
  }
  unint64_t v23 = (uint64_t *)v21;
  unint64_t v24 = v22;
  uint64_t v25 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v43);
  if (mlir::ShapedType::getNumElements(v25, v26) != *(uint64_t *)((char *)v23
                                                                + ((uint64_t)((v24 << 32) - 0x300000000) >> 29)))
    return 0;
  unint64_t v27 = (uint64_t *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_26;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_26;
  }
  uint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    size_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      uint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_26:
  }
    uint64_t v37 = 0;
  __s2 = v27;
  uint64_t v45 = v37;
  uint64_t v38 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&__s2);
  unint64_t v40 = v39;
  __s2 = v46;
  uint64_t v45 = 0x400000000;
  if (mlir::OpTrait::util::getBroadcastedShape((uint64_t *)v38, v39, v23, v24, (uint64_t)&__s2))
  {
    uint64_t v41 = __s2;
    BOOL v20 = v40 == v45 && memcmp(v38, __s2, 8 * v45) == 0;
  }
  else
  {
    BOOL v20 = 0;
    uint64_t v41 = __s2;
  }
  if (v41 != v46) {
    free(v41);
  }
  return v20;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  unint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  size_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      size_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    unint64_t v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    uint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.mult";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  size_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      size_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    unint64_t v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  unint64_t v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sub", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.sub";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.max";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.min", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.min";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  unint64_t v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    unint64_t v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  unint64_t v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.power", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.power";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    __int16 v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    char v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v27;
  uint64_t v25 = v27;
  uint64_t v26 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v28 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    uint64_t v9 = v26;
    char v8 = v25;
    long long v28 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    uint64_t v10 = ++*((void *)&v28 + 1);
  }
  while ((void)v28 != v7 || v10 != v6);
  int v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  long long v28 = v24;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v28, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v14;
    uint64_t v19 = v15;
  }
  else
  {
      goto LABEL_17;
    unint64_t v16 = *(mlir::MLIRContext **)(a2 + 24);
    uint64_t v17 = (uint64_t)a4;
    uint64_t v18 = (uint64_t)v15;
    uint64_t v19 = v14;
  }
  if (GOC)
  {
    uint64_t v22 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27) {
    free(v25);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  v37[1] = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v34;
  __int16 v32 = v34;
  uint64_t v33 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    long long v35 = v7;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    uint64_t v9 = v33;
    char v8 = v32;
    long long v35 = v7;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    uint64_t v10 = ++*((void *)&v35 + 1);
  }
  while ((void)v35 != v7 || v10 != v6);
  int v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  uint64_t v30 = a2;
  long long v35 = v31;
  __int16 v14 = (char *)mlir::ValueRange::dereference_iterator(&v35, 0);
  uint64_t v15 = (char *)mlir::ValueRange::dereference_iterator(&v35, 1);
  uint64_t v16 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v30);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    uint64_t v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v28);
      uint64_t v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      uint64_t v21 = (void *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      uint64_t v23 = *(void *)(v30 + 24);
      uint64_t v36 = 1;
      uint64_t v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      uint64_t v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      uint64_t v17 = (unsigned int *)v30;
      if (v37[0])
      {
        uint64_t v36 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v37);
        uint64_t v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  uint64_t v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34) {
    free(v32);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void *mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  char v8 = v19;
  uint64_t v17 = v19;
  uint64_t v18 = 0x200000000;
  if (v6 < 3)
  {
    uint64_t v9 = 0;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
    if (!v6)
    {
      int v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    uint64_t v9 = v18;
    char v8 = v17;
    uint64_t v20 = v7;
    uint64_t v21 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    uint64_t v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  int v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  __int16 v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19) {
    free(v17);
  }
  return 1;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3600A0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        uint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        unint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21194EF04()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  long long v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      long long v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  unint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          uint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          unint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    unint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      uint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        uint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        uint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      unint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = (unint64_t)(*a3 - *a2) >> 5;
  if (!v6)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    goto LABEL_12;
  }
  unint64_t v7 = (4 * (int)v6 / 3u + 1) | ((unint64_t)(4 * (int)v6 / 3u + 1) >> 1);
  unint64_t v8 = v7 | (v7 >> 2) | ((v7 | (v7 >> 2)) >> 4);
  LODWORD(v8) = (((v8 | (v8 >> 8)) >> 16) | v8 | (v8 >> 8)) + 1;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = buffer;
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = (v10 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (!v11)
  {
    unsigned int v14 = buffer;
LABEL_10:
    uint64_t v17 = &buffer[8 * v10];
    do
    {
      _DWORD *v14 = -1;
      v14 += 8;
    }
    while (v14 != v17);
    goto LABEL_12;
  }
  uint64_t v12 = v11 + 1;
  uint64_t v13 = (v11 + 1) & 0xFFFFFFFFFFFFFFELL;
  unsigned int v14 = &buffer[8 * v13];
  uint64_t v15 = buffer + 8;
  uint64_t v16 = v13;
  do
  {
    *(v15 - 8) = -1;
    _DWORD *v15 = -1;
    v15 += 16;
    v16 -= 2;
  }
  while (v16);
  if (v12 != v13) {
    goto LABEL_10;
  }
LABEL_12:
  uint64_t v18 = *a2;
  uint64_t v19 = *a3;
  if (v18 != v19)
  {
    while (1)
    {
      int v24 = *(_DWORD *)(a1 + 16);
      if (!v24) {
        break;
      }
      unsigned int v20 = v24 - 1;
      uint64_t v21 = (37 * *(_DWORD *)v18) & v20;
      char v22 = (_DWORD *)(*(void *)a1 + 32 * v21);
      int v23 = *v22;
      if (*(_DWORD *)v18 != *v22)
      {
        uint64_t v26 = 0;
        int v27 = 1;
        while (v23 != -1)
        {
          if (v26) {
            BOOL v28 = 0;
          }
          else {
            BOOL v28 = v23 == -2;
          }
          if (v28) {
            uint64_t v26 = v22;
          }
          int v29 = v21 + v27++;
          uint64_t v21 = v29 & v20;
          char v22 = (_DWORD *)(*(void *)a1 + 32 * v21);
          int v23 = *v22;
          if (*(_DWORD *)v18 == *v22) {
            goto LABEL_15;
          }
        }
        if (v26) {
          uint64_t v25 = (uint64_t)v26;
        }
        else {
          uint64_t v25 = (uint64_t)v22;
        }
        goto LABEL_18;
      }
LABEL_15:
      v18 += 32;
      if (v18 == v19) {
        return a1;
      }
    }
    uint64_t v25 = 0;
LABEL_18:
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(a1, v25, (_DWORD *)v18, (long long *)(v18 + 8));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(uint64_t a1, uint64_t a2, _DWORD *a3, long long *a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(a1, v9);
  int v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    unsigned int v14 = v13 - 1;
    uint64_t v15 = (37 * *a3) & v14;
    a2 = *(void *)a1 + 32 * v15;
    int v16 = *(_DWORD *)a2;
    if (*a3 != *(_DWORD *)a2)
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != -1)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -2;
        }
        if (v19) {
          uint64_t v17 = a2;
        }
        int v20 = v15 + v18++;
        uint64_t v15 = v20 & v14;
        a2 = *(void *)a1 + 32 * v15;
        int v16 = *(_DWORD *)a2;
        if (*a3 == *(_DWORD *)a2) {
          goto LABEL_3;
        }
      }
      if (v17) {
        a2 = v17;
      }
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a2 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *(_DWORD *)a2 = *a3;
  uint64_t v10 = (std::string *)(a2 + 8);
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v11 = *a4;
    *(void *)(a2 + 24) = *((void *)a4 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  return a2;
}

_DWORD *llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = (char *)(32 * v3);
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(a1, v4, (int *)&v10[(void)v4]);
    llvm::deallocate_buffer((llvm *)v4, v10);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v11 = *(unsigned int *)(a1 + 16);
  if (v11)
  {
    uint64_t v12 = (v11 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v12)
    {
      uint64_t v13 = v12 + 1;
      uint64_t v14 = (v12 + 1) & 0xFFFFFFFFFFFFFFELL;
      uint64_t v15 = &result[8 * v14];
      int v16 = result + 8;
      uint64_t v17 = v14;
      do
      {
        *(v16 - 8) = -1;
        _DWORD *v16 = -1;
        v16 += 16;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14) {
        return result;
      }
    }
    else
    {
      uint64_t v15 = result;
    }
    int v18 = &result[8 * v11];
    do
    {
      _DWORD *v15 = -1;
      v15 += 8;
    }
    while (v15 != v18);
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(uint64_t a1, int *a2, int *a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v8)
    {
      uint64_t v9 = v8 + 1;
      uint64_t v10 = (v8 + 1) & 0xFFFFFFFFFFFFFFELL;
      uint64_t v11 = &v7[8 * v10];
      uint64_t v12 = v7 + 8;
      uint64_t v13 = v10;
      do
      {
        *(v12 - 8) = -1;
        _DWORD *v12 = -1;
        v12 += 16;
        v13 -= 2;
      }
      while (v13);
      if (v9 == v10) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v11 = *(_DWORD **)a1;
    }
    uint64_t v14 = &v7[8 * v6];
    do
    {
      _DWORD *v11 = -1;
      v11 += 8;
    }
    while (v11 != v14);
  }
LABEL_10:
  if (a2 != a3)
  {
    do
    {
      int v15 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v16 = *(_DWORD *)(a1 + 16);
        if (v16)
        {
          unsigned int v17 = v16 - 1;
          uint64_t v18 = (v16 - 1) & (37 * v15);
          uint64_t v19 = *(void *)a1 + 32 * v18;
          int v20 = *(_DWORD *)v19;
          if (v15 != *(_DWORD *)v19)
          {
            uint64_t v21 = 0;
            int v22 = 1;
            while (v20 != -1)
            {
              if (v21) {
                BOOL v23 = 0;
              }
              else {
                BOOL v23 = v20 == -2;
              }
              if (v23) {
                uint64_t v21 = v19;
              }
              int v24 = v18 + v22++;
              uint64_t v18 = v24 & v17;
              uint64_t v19 = *(void *)a1 + 32 * v18;
              int v20 = *(_DWORD *)v19;
              if (v15 == *(_DWORD *)v19) {
                goto LABEL_26;
              }
            }
            if (v21) {
              uint64_t v19 = v21;
            }
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
LABEL_26:
        *(_DWORD *)uint64_t v19 = v15;
        long long v25 = *(_OWORD *)(v4 + 2);
        *(void *)(v19 + 24) = *((void *)v4 + 3);
        *(_OWORD *)(v19 + 8) = v25;
        *((void *)v4 + 2) = 0;
        *((void *)v4 + 3) = 0;
        *((void *)v4 + 1) = 0;
        ++*(_DWORD *)(a1 + 8);
        if (*((char *)v4 + 31) < 0) {
          operator delete(*((void **)v4 + 1));
        }
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
}

void llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
  uint64_t v7 = a1[2];
  if (v6 + v7 > (unint64_t)a1[3])
  {
    unint64_t v19 = 0;
    uint64_t v8 = a1 + 4;
    uint64_t v9 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)a1, a1 + 4, v6 + v7, 56, &v19);
    llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(v5, (uint64_t)v9);
    unsigned int v10 = v19;
    a1 = *(unsigned int **)v5;
    if (*(unsigned int **)v5 != v8) {
      free(a1);
    }
    *(void *)unint64_t v5 = v9;
    v5[3] = v10;
    LODWORD(v7) = v5[2];
  }
  if (a2 != a3)
  {
    uint64_t v11 = *(void *)v5 + 56 * v7;
    uint64_t v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = (llvm::detail::IEEEFloat *)(v11 + v13 + 8);
      int v15 = (const llvm::detail::DoubleAPFloat *)(a2 + v13 + 8);
      if (v12 == *(void **)v15) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v14, v15);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat(v14, v15);
      }
      int v16 = (std::string *)(v11 + v13 + 32);
      unsigned int v17 = (const std::string::value_type **)(a2 + v13 + 32);
      if (*(char *)(a2 + v13 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v16, *v17, *(void *)(a2 + v13 + 40));
      }
      else
      {
        long long v18 = *(_OWORD *)v17;
        *(void *)(v11 + v13 + 48) = *(void *)(a2 + v13 + 48);
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v18;
      }
      v13 += 56;
    }
    while (a2 + v13 != a3);
    LODWORD(v7) = v5[2];
  }
  v5[2] = v7 + v6;
}

void llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    uint64_t v7 = a2 + 32;
    uint64_t v8 = 56 * v2;
    uint64_t v9 = (long long *)(v5 + 32);
    do
    {
      uint64_t v11 = (void *)(v7 - 24);
      uint64_t v12 = (void *)v9 - 3;
      if (v6 == *((void **)v9 - 3)) {
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v11, v12);
      }
      else {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v11, (uint64_t)v12);
      }
      long long v10 = *v9;
      *(void *)(v7 + 16) = *((void *)v9 + 2);
      *(_OWORD *)uint64_t v7 = v10;
      v7 += 56;
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)uint64_t v9 = 0;
      uint64_t v9 = (long long *)((char *)v9 + 56);
      v8 -= 56;
    }
    while (v8);
    uint64_t v13 = a1[2];
    if (v13)
    {
      uint64_t v14 = *(void *)a1;
      uint64_t v15 = 56 * v13;
      do
      {
        while (1)
        {
          uint64_t v16 = v14 + v15;
          if (*(char *)(v14 + v15 - 1) < 0) {
            operator delete(*(void **)(v16 - 24));
          }
          unsigned int v17 = (llvm::detail::DoubleAPFloat *)(v16 - 48);
          if (v6 != *(void **)(v16 - 48)) {
            break;
          }
          llvm::detail::DoubleAPFloat::~DoubleAPFloat(v17);
          v15 -= 56;
          if (!v15) {
            return;
          }
        }
        llvm::detail::IEEEFloat::~IEEEFloat(v17);
        v15 -= 56;
      }
      while (v15);
    }
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(mlir::mps::AbsoluteOp,mlir::mps::AbsoluteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.abs", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"anec.abs";
    void v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertExponent::~ConvertExponent(mlir::_anonymous_namespace_::ConvertExponent *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertExponent::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::Float16Type **a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  long long v36 = *(_OWORD *)(a3 + 40);
  uint64_t v35 = mlir::ValueRange::dereference_iterator(&v36, 0);
  uint64_t v6 = (uint64_t *)(*(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v34[0] = v6;
  v34[1] = v16;
  uint64_t v17 = *((void *)a2 + 3);
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v34);
  uint64_t v20 = v19;
  uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
  uint64_t v33 = mlir::MemRefType::get(Shape, v20, F16Type, 0, 0, 0);
  uint64_t v22 = mlir::ShapedType::getShape((mlir::ShapedType *)v34);
  uint64_t v24 = (uint64_t)v23;
  uint64_t v25 = mlir::Builder::getF16Type(a4 + 1, v23);
  uint64_t v26 = (void *)mlir::RankedTensorType::get(v22, v24, v25, 0);
  v32[0] = mlir::createSplatF16ElementsAttr(v26, 1.4427);
  v32[1] = v27;
  long long v31 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v17, &v33, v32);
  uint64_t v30 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, v17, &v35, &v31);
  long long v28 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>((uint64_t *)a4 + 1, v17, &v30);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v28);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, void *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.exp2";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3 - 16);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::anonymous namespace'::ConvertLogarithm::~ConvertLogarithm(mlir::_anonymous_namespace_::ConvertLogarithm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertLogarithm::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, unint64_t *a3, mlir::Float16Type **a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v40 = *(_OWORD *)(a3 + 5);
  uint64_t v7 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v40, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v39[0] = v7;
  v39[1] = v17;
  uint64_t v18 = *(void *)(a2 + 24);
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v39);
  uint64_t v21 = v20;
  uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v20);
  uint64_t v38 = mlir::MemRefType::get(Shape, v21, F16Type, 0, 0, 0);
  uint64_t v23 = mlir::ShapedType::getShape((mlir::ShapedType *)v39);
  uint64_t v25 = (uint64_t)v24;
  uint64_t v26 = mlir::Builder::getF16Type(a4 + 1, v24);
  uint64_t v27 = (void *)mlir::RankedTensorType::get(v23, v25, v26, 0);
  v37[0] = mlir::createSplatF16ElementsAttr(v27, 0.69315);
  v37[1] = v28;
  uint64_t v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v18, &v38, v37);
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 0);
  unint64_t v30 = a3[5];
  uint64_t v41 = (ZinIrHalH13g *)v30;
  uint64_t v42 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v30 = mlir::ValueRange::offset_base(&v41, ODSOperandIndexAndLength);
  }
  uint64_t v41 = (ZinIrHalH13g *)v30;
  uint64_t v42 = 0;
  uint64_t v35 = mlir::ValueRange::dereference_iterator(&v41, 0);
  F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr(a4 + 1, 0.0, v31);
  uint64_t v41 = mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>((uint64_t *)a4 + 1, v18, &v35, (uint64_t *)&F16FloatAttr);
  __int16 v32 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, *(void *)(a2 + 24), &v41, &v36);
  (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v32);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.log2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.log2";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertSelect::~ConvertSelect(mlir::_anonymous_namespace_::ConvertSelect *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSelect::matchAndRewriteWithStaticShapes(int a1, uint64_t a2, mlir::mps::detail::CastOpGenericAdaptorBase *this, uint64_t *a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v7 = a4 + 1;
  uint64_t v8 = *(void *)(a2 + 24);
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v10 = *((void *)this + 5);
  unint64_t v26 = v10;
  uint64_t v27 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v10 = mlir::ValueRange::offset_base(&v26, ODSOperandIndexAndLength);
  }
  unint64_t v26 = v10;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v25 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(v7, v8, (uint64_t *)&v26) - 16;
  uint64_t v11 = *(void *)(a2 + 24);
  unsigned int v12 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v13 = *((void *)this + 5);
  unint64_t v26 = v13;
  uint64_t v27 = v12;
  if (v12) {
    unint64_t v13 = mlir::ValueRange::offset_base(&v26, v12);
  }
  unint64_t v26 = v13;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v24 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(v7, v11, (uint64_t *)&v26) - 16;
  uint64_t v14 = *(void *)(a2 + 24);
  unsigned int v15 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u);
  unint64_t v16 = *((void *)this + 5);
  unint64_t v26 = v16;
  uint64_t v27 = v15;
  if (v15) {
    unint64_t v16 = mlir::ValueRange::offset_base(&v26, v15);
  }
  unint64_t v26 = v16;
  uint64_t v27 = 0;
  unint64_t v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  uint64_t v23 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v14, (uint64_t *)&v26, &v25);
  uint64_t v17 = *(void *)(a2 + 24);
  unsigned int v18 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 2u);
  unint64_t v19 = *((void *)this + 5);
  unint64_t v26 = v19;
  uint64_t v27 = v18;
  if (v18) {
    unint64_t v19 = mlir::ValueRange::offset_base(&v26, v18);
  }
  unint64_t v26 = v19;
  uint64_t v27 = 0;
  uint64_t v22 = mlir::ValueRange::dereference_iterator(&v26, 0);
  unint64_t v26 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v17, &v22, &v24);
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(v7, *(void *)(a2 + 24), &v23, &v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.equal_zero";
    v15[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.add";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertFlatten2D::~ConvertFlatten2D(mlir::_anonymous_namespace_::ConvertFlatten2D *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v104[1] = *MEMORY[0x263EF8340];
  uint64_t v88 = a2;
  long long v95 = *(_OWORD *)(a3 + 40);
  uint64_t v6 = (void *)(*(void *)(*(void *)(*(void *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  unint64_t v89 = v6;
  uint64_t v90 = v16;
  uint64_t v17 = *(void **)(*(void *)(a2 + 72) + 56);
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  if (!v20)
  {
    LOBYTE(v91) = 0;
    char v94 = 0;
    goto LABEL_70;
  }
  uint64_t v21 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
  RankPromotionTypeForANE = v104;
  uint64_t v103 = 0x100000000;
  if (!SortedUniquePromotedPositiveAxesAttr) {
    goto LABEL_21;
  }
  uint64_t v22 = *SortedUniquePromotedPositiveAxesAttr;
  unint64_t v23 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_21;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    long long v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    int v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_21:
  }
    uint64_t v31 = 0;
  uint64_t v32 = 1;
  mlir::getIntValues<long long>(v21, v31, (uint64_t)&RankPromotionTypeForANE, 1);
  mlir::getRankPromotionShapeForANE((uint64_t)v89, v90, (uint64_t **)&v99);
  uint64_t v96 = &v98;
  HIDWORD(v97) = 2;
  uint64_t v33 = RankPromotionTypeForANE;
  uint64_t v34 = *RankPromotionTypeForANE;
  if (!*RankPromotionTypeForANE)
  {
    uint64_t v43 = 1;
    goto LABEL_33;
  }
  uint64_t v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (!v35)
  {
    uint64_t v43 = 1;
    uint64_t v38 = (char *)v99;
LABEL_31:
    unint64_t v44 = (char *)v99 + 8 * v34;
    do
    {
      uint64_t v45 = *(void *)v38;
      v38 += 8;
      v43 *= v45;
    }
    while (v38 != v44);
    goto LABEL_33;
  }
  uint64_t v36 = v35 + 1;
  uint64_t v37 = (v35 + 1) & 0x3FFFFFFFFFFFFFFELL;
  uint64_t v38 = (char *)v99 + 8 * v37;
  unint64_t v39 = (char *)v99 + 8;
  uint64_t v40 = 1;
  uint64_t v41 = v37;
  uint64_t v42 = 1;
  do
  {
    v40 *= *(v39 - 1);
    v42 *= *v39;
    v39 += 2;
    v41 -= 2;
  }
  while (v41);
  uint64_t v43 = v42 * v40;
  if (v36 != v37) {
    goto LABEL_31;
  }
LABEL_33:
  *(void *)&long long v98 = v43;
  LODWORD(v97) = 1;
  uint64_t v46 = *RankPromotionTypeForANE;
  if (*RankPromotionTypeForANE == v100) {
    goto LABEL_40;
  }
  uint64_t v47 = 8 * v46;
  uint64_t v48 = (uint64_t *)((char *)v99 + 8 * v46);
  unint64_t v49 = 8 * v100 - 8 - v47;
  if (!v49)
  {
    uint64_t v32 = 1;
    do
    {
LABEL_39:
      uint64_t v55 = *v48++;
      v32 *= v55;
    }
    while (v48 != (uint64_t *)((char *)v99 + 8 * v100));
    goto LABEL_40;
  }
  uint64_t v50 = (v49 >> 3) + 1;
  v48 += v50 & 0x3FFFFFFFFFFFFFFELL;
  unint64_t v51 = (char *)v99 + v47 + 8;
  uint64_t v52 = 1;
  uint64_t v53 = v50 & 0x3FFFFFFFFFFFFFFELL;
  uint64_t v54 = 1;
  do
  {
    v52 *= *(v51 - 1);
    v54 *= *v51;
    v51 += 2;
    v53 -= 2;
  }
  while (v53);
  uint64_t v32 = v54 * v52;
  if (v50 != (v50 & 0x3FFFFFFFFFFFFFFELL)) {
    goto LABEL_39;
  }
LABEL_40:
  *((void *)&v98 + 1) = v32;
  int32x2_t v91 = &v93;
  long long v93 = v98;
  uint64_t v92 = 0x200000002;
  char v94 = 1;
  if (v99 != v101)
  {
    free(v99);
    uint64_t v33 = RankPromotionTypeForANE;
  }
  if (v33 != v104) {
    free(v33);
  }
  if (!v94)
  {
LABEL_70:
    uint64_t v84 = a4[2];
    if (v84)
    {
      if (!mlir::RewriterBase::Listener::classof(v84))
      {
        uint64_t v84 = 0;
        if (v94)
        {
LABEL_74:
          if (v91 != &v93) {
            free(v91);
          }
        }
        return v84;
      }
    }
    if (v94) {
      goto LABEL_74;
    }
    return v84;
  }
  uint64_t v56 = (long long *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v88) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56) {
    goto LABEL_54;
  }
  uint64_t v57 = *(void *)v56;
  unint64_t v58 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v59 = *(unsigned int *)(v57 + 16);
  if (!v59) {
    goto LABEL_54;
  }
  unint64_t v60 = *(void **)(v57 + 8);
  unint64_t v61 = &v60[2 * v59];
  do
  {
    unint64_t v62 = v59 >> 1;
    uint64_t v63 = &v60[2 * (v59 >> 1)];
    unint64_t v65 = *v63;
    uint64_t v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58) {
      unint64_t v60 = v64;
    }
    else {
      unint64_t v59 = v62;
    }
  }
  while (v59);
  if (v60 != v61 && *v60 == v58) {
    uint64_t v66 = v60[1];
  }
  else {
LABEL_54:
  }
    uint64_t v66 = 0;
  uint64_t v96 = v56;
  uint64_t v97 = v66;
  if (v94)
  {
    long long v67 = *(_OWORD *)v91;
    uint64_t v99 = v101;
    *(_OWORD *)uint64_t v101 = v67;
    uint64_t v100 = 0x500000002;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v96);
    unint64_t v69 = (uint64_t *)mlir::MemRefType::get(v101, (mlir::AffineMap *)2, OperandRange, 0, 0, 0);
    uint64_t v70 = (uint64_t)v69;
    if (!v69) {
      goto LABEL_65;
    }
    uint64_t v71 = *v69;
    unint64_t v72 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v73 = *(unsigned int *)(v71 + 16);
    if (!v73) {
      goto LABEL_65;
    }
    int v74 = *(void **)(v71 + 8);
    uint64_t v75 = &v74[2 * v73];
    do
    {
      unint64_t v76 = v73 >> 1;
      unint64_t v77 = &v74[2 * (v73 >> 1)];
      unint64_t v79 = *v77;
      unint64_t v78 = v77 + 2;
      v73 += ~(v73 >> 1);
      if (v79 < v72) {
        int v74 = v78;
      }
      else {
        unint64_t v73 = v76;
      }
    }
    while (v73);
    if (v74 != v75 && *v74 == v72) {
      uint64_t v80 = v74[1];
    }
    else {
LABEL_65:
    }
      uint64_t v80 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v70, v80);
    uint64_t v103 = v81;
    uint64_t v82 = v88;
    unint64_t v89 = (void *)mlir::ValueRange::dereference_iterator(&v95, 0);
    int v83 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(v82 + 24), (uint64_t *)&RankPromotionTypeForANE, (uint64_t *)&v89);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v82, v83);
    if (v99 != v101) {
      free(v99);
    }
    uint64_t v84 = 1;
    if (!v94) {
      return v84;
    }
    goto LABEL_74;
  }
  unint64_t v86 = (void ****)std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(v86, v87);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::getIntValues<long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v132[5] = *MEMORY[0x263EF8340];
  *(void *)&long long v126 = a1;
  *((void *)&v126 + 1) = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v126) || a4) {
    unint64_t NumElements = mlir::ElementsAttr::getNumElements(v126, *((uint64_t *)&v126 + 1));
  }
  else {
    unint64_t NumElements = 1;
  }
  unint64_t v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 8);
        unint64_t v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7) {
        bzero((void *)(*(void *)a3 + 8 * v7), 8 * (NumElements - v7));
      }
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  unint64_t v8 = *(int64x2_t **)a3;
  long long v129 = v126;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v129);
  uint64_t v10 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v11 = *Type;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_21;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  unint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_21:
  }
    uint64_t v20 = 0;
  v128[0] = v10;
  v128[1] = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v128);
  int v21 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v129);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v129);
  uint64_t v24 = v23;
  if (!v21 || a4)
  {
    uint64_t v25 = mlir::ElementsAttr::getNumElements(v129, *((uint64_t *)&v129 + 1));
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_39;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1) {
        return;
      }
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v31 = 0;
        unint64_t v30 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v32 = 0;
          }
          else {
            unint64_t v32 = v31;
          }
          if (v21) {
            unint64_t v33 = 0;
          }
          else {
            unint64_t v33 = v31 + 1;
          }
          uint64_t v34 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v33];
          uint64_t v35 = &v8[v31 / 2];
          v35->i64[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v32];
          v35->i64[1] = v34;
          v31 += 2;
        }
        while (v31 != v30);
        goto LABEL_282;
      }
      goto LABEL_48;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_66;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_73;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_89;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_105;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_125;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_136;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_143;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
      goto LABEL_159;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1) {
        return;
      }
LABEL_174:
      if ((unint64_t)v25 >= 2)
      {
        uint64_t v96 = 0;
        unint64_t v72 = v25 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v97 = v8;
        do
        {
          if (v21) {
            uint64_t v98 = 0;
          }
          else {
            uint64_t v98 = v96;
          }
          if (v21) {
            uint64_t v99 = 0;
          }
          else {
            uint64_t v99 = v96 + 1;
          }
          v71.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v98];
          v71.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v99];
          int64x2_t v71 = vcvtq_s64_f64(vcvtq_f64_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)v71.i8, 0x10uLL)));
          *v97++ = v71;
          v96 += 2;
        }
        while (v96 != v72);
        goto LABEL_324;
      }
      unint64_t v72 = 0;
      do
      {
        if (v21) {
          unint64_t v123 = 0;
        }
        else {
          unint64_t v123 = v72;
        }
        v8->i64[v72++] = (uint64_t)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v123] << 16);
LABEL_324:
        ;
      }
      while (v25 != v72);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      uint64_t v25 = 1;
LABEL_28:
      for (uint64_t i = 0; i != v25; ++i)
      {
        if (v21) {
          uint64_t v27 = 0;
        }
        else {
          uint64_t v27 = i;
        }
        v8->i64[i] = ElementsAttrRawData[v27];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      uint64_t v25 = 1;
LABEL_39:
      for (uint64_t j = 0; j != v25; ++j)
      {
        if (v21) {
          uint64_t v29 = 0;
        }
        else {
          uint64_t v29 = j;
        }
        v8->i64[j] = (char)ElementsAttrRawData[v29];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      uint64_t v25 = 1;
LABEL_48:
      unint64_t v30 = 0;
      do
      {
        if (v21) {
          unint64_t v116 = 0;
        }
        else {
          unint64_t v116 = v30;
        }
        v8->i64[v30++] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v116];
LABEL_282:
        ;
      }
      while (v25 != v30);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      uint64_t v25 = 1;
LABEL_66:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v38 = 0;
        unint64_t v36 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v39 = 0;
          }
          else {
            unint64_t v39 = v38;
          }
          if (v21) {
            unint64_t v40 = 0;
          }
          else {
            unint64_t v40 = v38 + 1;
          }
          uint64_t v41 = *(__int16 *)&ElementsAttrRawData[2 * v40];
          uint64_t v42 = &v8[v38 / 2];
          v42->i64[0] = *(__int16 *)&ElementsAttrRawData[2 * v39];
          v42->i64[1] = v41;
          v38 += 2;
        }
        while (v38 != v36);
        goto LABEL_288;
      }
      unint64_t v36 = 0;
      do
      {
        if (v21) {
          unint64_t v117 = 0;
        }
        else {
          unint64_t v117 = v36;
        }
        v8->i64[v36++] = *(__int16 *)&ElementsAttrRawData[2 * v117];
LABEL_288:
        ;
      }
      while (v25 != v36);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v25 = 1;
LABEL_73:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v44 = 0;
        unint64_t v37 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v45 = 0;
          }
          else {
            unint64_t v45 = v44;
          }
          if (v21) {
            unint64_t v46 = 0;
          }
          else {
            unint64_t v46 = v44 + 1;
          }
          uint64_t v47 = *(unsigned int *)&ElementsAttrRawData[4 * v46];
          uint64_t v48 = &v8[v44 / 2];
          v48->i64[0] = *(unsigned int *)&ElementsAttrRawData[4 * v45];
          v48->i64[1] = v47;
          v44 += 2;
        }
        while (v44 != v37);
        goto LABEL_294;
      }
      unint64_t v37 = 0;
      do
      {
        if (v21) {
          unint64_t v118 = 0;
        }
        else {
          unint64_t v118 = v37;
        }
        v8->i64[v37++] = *(unsigned int *)&ElementsAttrRawData[4 * v118];
LABEL_294:
        ;
      }
      while (v25 != v37);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v25 = 1;
LABEL_89:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v51 = 0;
        unint64_t v43 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v52 = 0;
          }
          else {
            unint64_t v52 = v51;
          }
          if (v21) {
            unint64_t v53 = 0;
          }
          else {
            unint64_t v53 = v51 + 1;
          }
          uint64_t v54 = *(int *)&ElementsAttrRawData[4 * v53];
          uint64_t v55 = &v8[v51 / 2];
          v55->i64[0] = *(int *)&ElementsAttrRawData[4 * v52];
          v55->i64[1] = v54;
          v51 += 2;
        }
        while (v51 != v43);
        goto LABEL_300;
      }
      unint64_t v43 = 0;
      do
      {
        if (v21) {
          unint64_t v119 = 0;
        }
        else {
          unint64_t v119 = v43;
        }
        v8->i64[v43++] = *(int *)&ElementsAttrRawData[4 * v119];
LABEL_300:
        ;
      }
      while (v25 != v43);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v25 = 1;
LABEL_105:
      for (uint64_t k = 0; k != v25; ++k)
      {
        if (v21) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = k;
        }
        v8->i64[k] = *(void *)&ElementsAttrRawData[8 * v50];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v25 = 1;
LABEL_125:
      for (uint64_t m = 0; m != v25; ++m)
      {
        if (v21) {
          uint64_t v57 = 0;
        }
        else {
          uint64_t v57 = m;
        }
        v8->i64[m] = *(void *)&ElementsAttrRawData[8 * v57];
      }
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_136:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v60 = 0;
        unint64_t v58 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v61 = 0;
          }
          else {
            unint64_t v61 = v60;
          }
          if (v21) {
            unint64_t v62 = 0;
          }
          else {
            unint64_t v62 = v60 + 1;
          }
          uint64_t v63 = (uint64_t)*(short float *)&ElementsAttrRawData[2 * v62];
          uint64_t v64 = &v8[v60 / 2];
          v64->i64[0] = (uint64_t)*(short float *)&ElementsAttrRawData[2 * v61];
          v64->i64[1] = v63;
          v60 += 2;
        }
        while (v60 != v58);
        goto LABEL_306;
      }
      unint64_t v58 = 0;
      do
      {
        if (v21) {
          unint64_t v120 = 0;
        }
        else {
          unint64_t v120 = v58;
        }
        v8->i64[v58++] = (uint64_t)*(short float *)&ElementsAttrRawData[2 * v120];
LABEL_306:
        ;
      }
      while (v25 != v58);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_143:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v66 = 0;
        unint64_t v59 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v67 = 0;
          }
          else {
            unint64_t v67 = v66;
          }
          if (v21) {
            unint64_t v68 = 0;
          }
          else {
            unint64_t v68 = v66 + 1;
          }
          uint64_t v69 = (uint64_t)*(float *)&ElementsAttrRawData[4 * v68];
          uint64_t v70 = &v8[v66 / 2];
          v70->i64[0] = (uint64_t)*(float *)&ElementsAttrRawData[4 * v67];
          v70->i64[1] = v69;
          v66 += 2;
        }
        while (v66 != v59);
        goto LABEL_312;
      }
      unint64_t v59 = 0;
      do
      {
        if (v21) {
          unint64_t v121 = 0;
        }
        else {
          unint64_t v121 = v59;
        }
        v8->i64[v59++] = (uint64_t)*(float *)&ElementsAttrRawData[4 * v121];
LABEL_312:
        ;
      }
      while (v25 != v59);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      uint64_t v25 = 1;
LABEL_159:
      if ((unint64_t)v25 >= 2)
      {
        unint64_t v76 = 0;
        unint64_t v65 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21) {
            unint64_t v77 = 0;
          }
          else {
            unint64_t v77 = v76;
          }
          if (v21) {
            unint64_t v78 = 0;
          }
          else {
            unint64_t v78 = v76 + 1;
          }
          uint64_t v79 = (uint64_t)*(double *)&ElementsAttrRawData[8 * v78];
          uint64_t v80 = &v8[v76 / 2];
          v80->i64[0] = (uint64_t)*(double *)&ElementsAttrRawData[8 * v77];
          v80->i64[1] = v79;
          v76 += 2;
        }
        while (v76 != v65);
        goto LABEL_318;
      }
      unint64_t v65 = 0;
      do
      {
        if (v21) {
          unint64_t v122 = 0;
        }
        else {
          unint64_t v122 = v65;
        }
        v8->i64[v65++] = (uint64_t)*(double *)&ElementsAttrRawData[8 * v122];
LABEL_318:
        ;
      }
      while (v25 != v65);
      return;
    }
    uint64_t v25 = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      goto LABEL_174;
    }
  }
  if (!mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitunsigned int Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    if (!v24) {
      return;
    }
    uint64_t v82 = 0;
    int v83 = ~(-1 << IntOrFloatBitWidth);
    unint64_t v84 = v25;
    unint64_t v85 = 8 / IntOrFloatBitWidth;
    while (1)
    {
      unint64_t v86 = v82 * v85;
      unint64_t v87 = v25 - v82 * v85;
      if (v87 >= v85) {
        unint64_t v87 = 8 / IntOrFloatBitWidth;
      }
      if (!v87) {
        goto LABEL_194;
      }
      unsigned int v88 = *ElementsAttrRawData;
      if (v84 >= v85) {
        unint64_t v89 = 8 / IntOrFloatBitWidth;
      }
      else {
        unint64_t v89 = v84;
      }
      uint64x2_t v90 = (uint64x2_t)vdupq_n_s64(v89 - 1);
      int32x2_t v91 = vmovn_s64((int64x2_t)vcgeq_u64(v90, (uint64x2_t)xmmword_211ED5A80));
      if (v91.i8[0]) {
        v8->i64[v86] = v83 & v88;
      }
      if (v91.i8[4]) {
        v8->i64[v86 + 1] = (v88 >> IntOrFloatBitWidth) & v83;
      }
      uint64_t v92 = ((_BYTE)v89 + 1) & 0x1E;
      if (v92 == 2) {
        goto LABEL_194;
      }
      int32x2_t v93 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211ED4670));
      if (v93.i8[0])
      {
        v8[1].i64[v86] = (v88 >> (2 * IntOrFloatBitWidth)) & v83;
        if (v93.i8[4]) {
          goto LABEL_211;
        }
      }
      else if (v93.i8[4])
      {
LABEL_211:
        v8[1].i64[v86 + 1] = (v88 >> (3 * IntOrFloatBitWidth)) & v83;
        if (v92 == 4) {
          goto LABEL_194;
        }
        goto LABEL_212;
      }
      if (v92 == 4) {
        goto LABEL_194;
      }
LABEL_212:
      int32x2_t v94 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211F09590));
      if (v94.i8[0])
      {
        v8[2].i64[v86] = (v88 >> (4 * IntOrFloatBitWidth)) & v83;
        if ((v94.i8[4] & 1) == 0) {
          goto LABEL_214;
        }
      }
      else if ((v94.i8[4] & 1) == 0)
      {
LABEL_214:
        if (v92 != 6) {
          goto LABEL_218;
        }
        goto LABEL_194;
      }
      v8[2].i64[v86 + 1] = (v88 >> (5 * IntOrFloatBitWidth)) & v83;
      if (v92 != 6)
      {
LABEL_218:
        int32x2_t v95 = vmovn_s64((int64x2_t)vcgtq_u64(v90, (uint64x2_t)xmmword_211F095A0));
        if (v95.i8[0]) {
          v8[3].i64[v86] = (v88 >> (6 * IntOrFloatBitWidth)) & v83;
        }
        if (v95.i8[4]) {
          v8[3].i64[v86 + 1] = (v88 >> (7 * IntOrFloatBitWidth)) & v83;
        }
      }
LABEL_194:
      ++v82;
      v84 -= v85;
      ++ElementsAttrRawData;
      if (!--v24) {
        return;
      }
    }
  }
  uint64_t v125 = v8;
  if (v21) {
    unint64_t v73 = 1;
  }
  else {
    unint64_t v73 = v25;
  }
  int v74 = v132;
  unint64_t v130 = v132;
  long long v131 = xmmword_211F09580;
  if (v73)
  {
    if (v73 < 0x29)
    {
      uint64_t v75 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v130, v132, v73, 1);
      int v74 = v130;
      uint64_t v75 = v131;
    }
    if (v73 != v75) {
      bzero((char *)v74 + v75, v73 - v75);
    }
    *(void *)&long long v131 = v73;
  }
  if (v24)
  {
    uint64_t v100 = (BOOL *)v74 + 3;
    do
    {
      if (v73 >= 8) {
        uint64_t v101 = 8;
      }
      else {
        uint64_t v101 = v73;
      }
      if (!v101) {
        goto LABEL_237;
      }
      if (v73 >= 8) {
        uint64_t v102 = 8;
      }
      else {
        uint64_t v102 = v73;
      }
      unsigned int v103 = *ElementsAttrRawData;
      uint64x2_t v104 = (uint64x2_t)vdupq_n_s64(v102 - 1);
      int32x2_t v105 = vmovn_s64((int64x2_t)vcgeq_u64(v104, (uint64x2_t)xmmword_211ED5A80));
      if (v105.i8[0]) {
        *(v100 - 3) = v103 & 1;
      }
      if (v105.i8[4]) {
        *(v100 - 2) = (v103 & 2) != 0;
      }
      uint64_t v106 = ((_BYTE)v102 + 1) & 0x1E;
      if (v106 == 2) {
        goto LABEL_237;
      }
      int32x2_t v107 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211ED4670));
      if (v107.i8[0])
      {
        *(v100 - 1) = (v103 & 4) != 0;
        if (v107.i8[4]) {
          goto LABEL_255;
        }
      }
      else if (v107.i8[4])
      {
LABEL_255:
        *uint64_t v100 = (v103 & 8) != 0;
        if (v106 == 4) {
          goto LABEL_237;
        }
        goto LABEL_256;
      }
      if (v106 == 4) {
        goto LABEL_237;
      }
LABEL_256:
      int32x2_t v108 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211F09590));
      if (v108.i8[0])
      {
        v100[1] = (v103 & 0x10) != 0;
        if ((v108.i8[4] & 1) == 0) {
          goto LABEL_258;
        }
      }
      else if ((v108.i8[4] & 1) == 0)
      {
LABEL_258:
        if (v106 != 6) {
          goto LABEL_262;
        }
        goto LABEL_237;
      }
      void v100[2] = (v103 & 0x20) != 0;
      if (v106 != 6)
      {
LABEL_262:
        int32x2_t v109 = vmovn_s64((int64x2_t)vcgtq_u64(v104, (uint64x2_t)xmmword_211F095A0));
        if (v109.i8[0]) {
          v100[3] = (v103 & 0x40) != 0;
        }
        if (v109.i8[4]) {
          v100[4] = v103 >> 7;
        }
      }
LABEL_237:
      ++ElementsAttrRawData;
      v100 += 8;
      v73 -= 8;
      --v24;
    }
    while (v24);
  }
  if (v25 >= 1)
  {
    if (v25 == 1)
    {
      unint64_t v111 = 0;
      goto LABEL_326;
    }
    unint64_t v110 = 0;
    unint64_t v111 = v25 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      if (v21) {
        unint64_t v112 = 0;
      }
      else {
        unint64_t v112 = v110;
      }
      if (v21) {
        unint64_t v113 = 0;
      }
      else {
        unint64_t v113 = v110 + 1;
      }
      uint64_t v114 = *((unsigned __int8 *)v74 + v113);
      uint64_t v115 = &v125[v110 / 2];
      v115->i64[0] = *((unsigned __int8 *)v74 + v112);
      v115->i64[1] = v114;
      v110 += 2;
    }
    while (v110 != v111);
    while (v25 != v111)
    {
LABEL_326:
      if (v21) {
        unint64_t v124 = 0;
      }
      else {
        unint64_t v124 = v111;
      }
      v125->i64[v111++] = *((unsigned __int8 *)v74 + v124);
    }
  }
  if (v74 != v132) {
    free(v74);
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(mlir::mps::Flatten2DOp,mlir::mps::Flatten2DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Flatten2DOp axis argument was not a constant. \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v19 = *(_OWORD *)(a3 + 40);
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  uint64_t v16 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  F16uint64_t FloatAttr = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (F16uint64_t FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16uint64_t FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16uint64_t FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v17, &v15)- 16;
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.invert", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.invert";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v19 = *(_OWORD *)(a3 + 40);
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  uint64_t v16 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  F16uint64_t FloatAttr = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (F16uint64_t FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16uint64_t FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16uint64_t FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v17, &v15)- 16;
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.div", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.div";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v10 = *(_OWORD *)(a3 + 40);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  uint64_t v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v20 = *(_OWORD *)(a3 + 40);
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  uint64_t v17 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t ElementTypeOrSelf = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v18, &v15)- 16;
    F16uint64_t FloatAttr = (ZinIrHalH13g *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &ElementTypeOrSelf)- 16);
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.floor";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v20 = *(_OWORD *)(a3 + 40);
  uint64_t v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  uint64_t v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  uint64_t v17 = v6;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t ElementTypeOrSelf = v6;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (uint64_t v9 = DefiningOp,
        uint64_t v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v9 + 48) + 32))(*(void *)(v9 + 48), v10))
    && (uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16uint64_t FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    uint64_t v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    uint64_t ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v18, &v15)- 16;
    F16uint64_t FloatAttr = (ZinIrHalH13g *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &ElementTypeOrSelf)- 16);
    uint64_t v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    uint64_t v13 = *(void *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13)) {
    else
    }
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  long long v11 = *(_OWORD *)(a3 + 40);
  uint64_t v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  uint64_t v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  uint64_t v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v10, &v9)- 16;
  uint64_t v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(void *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  unint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  int32x2_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  int32x2_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  __int16 v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  unint64_t v89 = v27;
  uint64_t v90 = v37;
  uint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unsigned int v88 = v38;
  unint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    uint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unsigned int v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    unint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unsigned int v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::matchAsConst(uint64_t **a1, uint64_t a2)
{
  uint64_t v28 = a1;
  unint64_t v30 = (uint64_t **)a2;
  uint64_t ArgOperands = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ArgOperands);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v30, DefiningOp)) {
    return 1;
  }
  uint64_t ArgOperands = (uint64_t **)a2;
  uint64_t v25 = a2 + 16;
  uint64_t v26 = a2 + 32;
  uint64_t v27 = a2 + 48;
  uint64_t v29 = (uint64_t)a1;
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!v6) {
    return 0;
  }
  v23[0] = v6;
  if (*(_UNKNOWN **)(*(void *)(v6 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    return 0;
  }
  if ((*(unsigned char *)(v6 + 46) & 0x80) == 0) {
    return 0;
  }
  if (*(_DWORD *)(v6 + 68) != 4) {
    return 0;
  }
  char v32 = 1;
  unint64_t v30 = (uint64_t **)&v32;
  unint64_t v31 = v23;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>(&ArgOperands, (uint64_t)&v30);
  if (!v32
    || mlir::ElementsAttr::getNumElements(*(void *)(a2 + 48), *(void *)(a2 + 56)) != 1
    || (mlir::getSingleFloatValue<float>(*(void *)(a2 + 48), *(void *)(a2 + 56)) & 0x7FFFFFFF) != 0)
  {
    return 0;
  }
  uint64_t v29 = mlir::Value::getDefiningOp((mlir::Value *)&v28);
  uint64_t ArgOperands = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 16));
  uint64_t v25 = v7;
  unint64_t v30 = (uint64_t **)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 32));
  unint64_t v31 = v8;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
  if (mlir::ShapedType::getNumElements(Shape, v10) == 1)
  {
    unint64_t v11 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v30);
    if (mlir::ShapedType::getNumElements(v11, v12) == 1
      && (mlir::mps::DequantizeOp::getAxis((mlir::mps::DequantizeOp *)&v29) & 0xFF00000000) == 0)
    {
      return 1;
    }
  }
  if ((mlir::mps::DequantizeOp::getAxis((mlir::mps::DequantizeOp *)&v29) & 0xFF00000000) == 0) {
    return 0;
  }
  v23[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)a2);
  v23[1] = v13;
  mlir::ShapedType::getShape((mlir::ShapedType *)v23);
  uint64_t v15 = v14;
  mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
  uint64_t v17 = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v30);
  uint64_t result = 0;
  if (v17 <= 1 && v18 <= 1)
  {
    if (v17 == 1 || v18 == 1)
    {
      uint64_t Axis = mlir::mps::DequantizeOp::getAxis((mlir::mps::DequantizeOp *)&v29);
      if ((Axis & 0xFF00000000) != 0)
      {
        uint64_t KernelDimFromIndex = mlir::anec::getKernelDimFromIndex((int)Axis, v15);
        return (KernelDimFromIndex & 0xFF00000000) != 0 && KernelDimFromIndex == 0;
      }
      else
      {
        uint64_t v22 = std::__throw_bad_optional_access[abi:nn180100]();
      }
    }
    return 1;
  }
  return result;
}

uint64_t mlir::anonymous namespace'::convertToLinear(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, unsigned __int8 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  int v20 = a9;
  uint64_t v115 = *MEMORY[0x263EF8340];
  uint64_t v105 = a11;
  uint64_t v106 = a1;
  uint64_t v103 = a13;
  uint64_t v104 = a10;
  uint64_t v101 = a15;
  uint64_t v102 = a12;
  uint64_t v99 = 0;
  uint64_t v100 = a14;
  uint64_t v98 = 0;
  if (a9)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v104);
    uint64_t v22 = (char *)a5;
    if (v23 >= 4)
    {
      unint64_t v111 = (char *)a5;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((void *)&v113 + 1) = v24;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
      unint64_t v26 = v25;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v25);
      uint64_t v110 = v27;
      unint64_t v107 = mlir::anec::getIndexFromDim(3, v26);
      uint64_t v108 = v28;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (!mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v106))
    {
      unint64_t v111 = v22;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((void *)&v113 + 1) = v29;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
      unint64_t v31 = v30;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v30);
      uint64_t v110 = v32;
      unint64_t v107 = mlir::anec::getIndexFromDim(4, v31);
      uint64_t v108 = v33;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a5 = a6;
  }
  else
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)&v102);
    uint64_t v22 = (char *)a6;
    if (v35 >= 4)
    {
      unint64_t v111 = (char *)a6;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((void *)&v113 + 1) = v36;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
      unint64_t v38 = v37;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v37);
      uint64_t v110 = v39;
      unint64_t v107 = mlir::anec::getIndexFromDim(3, v38);
      uint64_t v108 = v40;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v106))
    {
      unint64_t v111 = v22;
      *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((void *)&v113 + 1) = v41;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
      unint64_t v43 = v42;
      unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v42);
      uint64_t v110 = v44;
      unint64_t v107 = mlir::anec::getIndexFromDim(4, v43);
      uint64_t v108 = v45;
      uint64_t v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a8 = a7;
  }
  uint64_t v98 = a5;
  uint64_t v99 = v22;
  uint64_t v46 = a8[2];
  if (v46)
  {
    uint64_t v47 = mlir::convertElementsAttr(v46, a8[3], 1);
    uint64_t v48 = (mlir::OpBuilder *)(a2 + 8);
    *(void *)&long long v113 = mlir::getElementTypeOrSelf((void *)a8[4]);
    BOOL isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v113);
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a2 + 8), 8u, isSignedInteger);
    unint64_t IndexFromDim = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a8 + 4));
    uint64_t v110 = v51;
    LOBYTE(v113) = 0;
    char v114 = 0;
    uint64_t v52 = mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, IntegerType);
    uint64_t v54 = mlir::rewriteElementsAttr(a8[4], a8[5], v52, v53, 1);
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)a8);
    uint64_t v56 = Type;
    if (!Type) {
      goto LABEL_22;
    }
    uint64_t v57 = *Type;
    unint64_t v58 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v59 = *(unsigned int *)(v57 + 16);
    if (!v59) {
      goto LABEL_22;
    }
    uint64_t v60 = *(void **)(v57 + 8);
    uint64_t v61 = &v60[2 * v59];
    do
    {
      unint64_t v62 = v59 >> 1;
      unint64_t v63 = &v60[2 * (v59 >> 1)];
      unint64_t v65 = *v63;
      unint64_t v64 = v63 + 2;
      v59 += ~(v59 >> 1);
      if (v65 < v58) {
        uint64_t v60 = v64;
      }
      else {
        unint64_t v59 = v62;
      }
    }
    while (v59);
    if (v60 != v61 && *v60 == v58) {
      uint64_t v66 = v60[1];
    }
    else {
LABEL_22:
    }
      uint64_t v66 = 0;
    *(void *)&long long v113 = v56;
    *((void *)&v113 + 1) = v66;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v113);
    unint64_t v68 = (void *)(*(void *)(v98 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v68)
    {
      uint64_t v69 = a3;
      uint64_t v70 = *v68;
      unint64_t v71 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v72 = *(unsigned int *)(v70 + 16);
      if (v72)
      {
        uint64_t v73 = *(void **)(v70 + 8);
        uint64_t v74 = &v73[2 * v72];
        do
        {
          unint64_t v75 = v72 >> 1;
          unint64_t v76 = &v73[2 * (v72 >> 1)];
          unint64_t v78 = *v76;
          uint64_t v77 = v76 + 2;
          v72 += ~(v72 >> 1);
          if (v78 < v71) {
            uint64_t v73 = v77;
          }
          else {
            unint64_t v72 = v75;
          }
        }
        while (v72);
        a3 = v69;
        if (v73 == v74)
        {
          uint64_t v79 = 0;
          int v20 = a9;
        }
        else
        {
          int v20 = a9;
          if (*v73 == v71) {
            uint64_t v79 = v73[1];
          }
          else {
            uint64_t v79 = 0;
          }
        }
      }
      else
      {
        uint64_t v79 = 0;
        a3 = v69;
        int v20 = a9;
      }
      uint64_t v48 = (mlir::OpBuilder *)(a2 + 8);
    }
    else
    {
      uint64_t v79 = 0;
    }
    unint64_t IndexFromDim = v68;
    uint64_t v110 = v79;
    LOBYTE(v113) = 0;
    char v114 = 0;
    uint64_t v80 = (void *)mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, OperandRange);
    uint64_t v82 = v81;
    *(void *)&long long v113 = mlir::rewriteElementsAttr(*a8, a8[1], (uint64_t)v80, v82, 0);
    *((void *)&v113 + 1) = v83;
    uint64_t v98 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v48, a4, (uint64_t *)&IndexFromDim, (void **)&v113)- 16;
    *(void *)&long long v113 = v47;
  }
  else
  {
    uint64_t v54 = 0;
    *(void *)&long long v113 = 0;
  }
  unint64_t IndexFromDim = v54;
  uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>((mlir::UnknownLoc **)(a2 + 8), a4, (uint64_t *)&v99, &v98, (uint64_t *)&v113, (uint64_t *)&IndexFromDim)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v100);
  if (v85 >= 4)
  {
    unint64_t v111 = v84;
    *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((void *)&v113 + 1) = v86;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
    unint64_t v88 = v87;
    unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v87);
    uint64_t v110 = v89;
    unint64_t v107 = mlir::anec::getIndexFromDim(3, v88);
    uint64_t v108 = v90;
    uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  if (v20)
  {
    unint64_t v111 = v84;
    *(void *)&long long v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((void *)&v113 + 1) = v91;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v113);
    unint64_t v93 = v92;
    unint64_t IndexFromDim = (void *)mlir::anec::getIndexFromDim(1, v92);
    uint64_t v110 = v94;
    unint64_t v107 = mlir::anec::getIndexFromDim(4, v93);
    uint64_t v108 = v95;
    uint64_t v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  unint64_t v96 = v106;
  *(void *)&long long v113 = v84;
  mlir::ValueRange::ValueRange(v112, (uint64_t)&v113, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a2, v96, v112[0], v112[1]);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4, 0);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::getSingleFloatValue<float>(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = a1;
  uint64_t v23 = a2;
  v21[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v22);
  v21[1] = v2;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v21);
  if (mlir::ShapedType::getNumElements(Shape, v4) != 1) {
    goto LABEL_36;
  }
  v20[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v22);
  v20[1] = v5;
  uint64_t v6 = *(void **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v20) + 136);
  BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id;
  BOOL v8 = v7 || v6 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id;
  BOOL v9 = v8 || v6 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id;
  BOOL v10 = v9 || v6 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id;
  BOOL v11 = v10 || v6 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id;
  BOOL v12 = v11 || v6 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id;
  BOOL v13 = v12 || v6 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id;
  BOOL v14 = v13 || v6 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id;
  BOOL v15 = v14 || v6 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
  if (v15
    || (v6 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      ? (BOOL v18 = v6 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
      : (BOOL v18 = 1),
        v18))
  {
    LODWORD(v20[0]) = 0;
    mlir::copyElementsAttrData<float>(v22, v23, (uint64_t)v20, 1);
    uint64_t v16 = LODWORD(v20[0]);
    uint64_t v17 = 0x100000000;
  }
  else
  {
LABEL_36:
    uint64_t v17 = 0;
    uint64_t v16 = 0;
  }
  return v16 | v17;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (DefiningOp) {
    LOBYTE(DefiningOp) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1, DefiningOp);
  }
  if (**(unsigned char **)a2) {
    char v5 = DefiningOp;
  }
  else {
    char v5 = 0;
  }
  **(unsigned char **)a2 = v5;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 56);
  uint64_t v6 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v6) {
    LOBYTE(v6) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 1, v6);
  }
  if (**(unsigned char **)a2) {
    char v7 = v6;
  }
  else {
    char v7 = 0;
  }
  **(unsigned char **)a2 = v7;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 88);
  uint64_t v8 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v8) {
    LOBYTE(v8) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 2, v8);
  }
  if (**(unsigned char **)a2) {
    char v9 = v8;
  }
  else {
    char v9 = 0;
  }
  **(unsigned char **)a2 = v9;
  uint64_t v12 = *(void *)(*(void *)(**(void **)(a2 + 8) + 72) + 120);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (result) {
    uint64_t result = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 3, result);
  }
  if (**(unsigned char **)a2) {
    char v11 = result;
  }
  else {
    char v11 = 0;
  }
  **(unsigned char **)a2 = v11;
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.linear", (const unsigned __int8 *)0xB, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.linear";
    void v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Linear::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  BOOL v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.transpose";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    char v14 = v13;
  }
  else {
    char v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void *mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v103 = *(_OWORD *)(a3 + 56);
  char v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  char v9 = *(void **)(v6 + 8);
  BOOL v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      char v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v93 = v5;
  uint64_t v94 = v15;
  uint64_t v82 = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    uint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t v84 = (uint64_t)v5;
  uint64_t v91 = v16;
  uint64_t v92 = v26;
  uint64_t v27 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  unint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      unint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  uint64_t v89 = v27;
  uint64_t v90 = v37;
  unint64_t v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  unint64_t v88 = v38;
  uint64_t v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  unint64_t v87 = v39;
  uint64_t v40 = *(void *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (uint64_t **)mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95);
  Filter = (uint64_t **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 0;
LABEL_37:
    uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    uint64_t v105 = v46;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2) {
        goto LABEL_42;
      }
LABEL_53:
      uint64_t v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    unint64_t IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    uint64_t v99 = v48;
    mlir::ShapedType::getShape((mlir::ShapedType *)&IndexFromDim);
    if (v49 != 2) {
      goto LABEL_42;
    }
    unsigned __int8 v45 = 1;
    goto LABEL_53;
  }
  BOOL TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  unsigned __int8 v45 = TransposeRhs;
  if (matched) {
    goto LABEL_37;
  }
  if (TransposeRhs) {
    goto LABEL_39;
  }
LABEL_42:
  mlir::ShapedType::getShape((mlir::ShapedType *)&v93);
  if (v50 >= 4)
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v51;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v53 = v52;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    uint64_t v99 = v54;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v53);
    uint64_t v97 = v55;
    unint64_t v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v88 = v38;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)&v91);
  if (v56 >= 4)
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v57;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v59 = v58;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    uint64_t v99 = v60;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v59);
    uint64_t v97 = v61;
    uint64_t v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    unint64_t v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    uint64_t v100 = v38;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    uint64_t v105 = v62;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v64 = v63;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    uint64_t v99 = v65;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v64);
    uint64_t v97 = v66;
    unint64_t v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    uint64_t v100 = v39;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    uint64_t v105 = v67;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v69 = v68;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    uint64_t v99 = v70;
    unint64_t v96 = mlir::anec::getIndexFromDim(4, v69);
    uint64_t v97 = v71;
    unint64_t v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t ArgOperands = 0;
  unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v89);
  if (v73 >= 4)
  {
    uint64_t v100 = v72;
    uint64_t ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    uint64_t v105 = v74;
    mlir::ShapedType::getShape((mlir::ShapedType *)&ArgOperands);
    unint64_t v76 = v75;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    uint64_t v99 = v77;
    unint64_t v96 = mlir::anec::getIndexFromDim(3, v76);
    uint64_t v97 = v78;
    unint64_t v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  uint64_t v79 = (unsigned int *)v95;
  uint64_t ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360C00;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        char v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        unint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    unint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    unint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_211959D60()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  char v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      unint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(mlir::mps::DegammaOp,mlir::mps::DegammaOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.degamma", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.degamma";
    void v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360880;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195AA7C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(mlir::mps::DiracOp,mlir::mps::DiracOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.dirac", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.dirac";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360650;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195B798()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(mlir::mps::GeluOp,mlir::mps::GeluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gelu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.gelu";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3606C0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195C4B4()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(mlir::mps::ReluOp,mlir::mps::ReluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.relu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.relu";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360AB0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195D1D0()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(mlir::mps::RoundOp,mlir::mps::RoundOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.round_nearest", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.round_nearest";
    void v21[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360C70;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195DEEC()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(mlir::mps::SigmoidOp,mlir::mps::SigmoidOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.high_precision_sigmoid", (const unsigned __int8 *)0x1B, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.high_precision_sigmoid";
    void v21[3] = 27;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360B90;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195EC08()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(mlir::mps::SquareOp,mlir::mps::SquareOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.square", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.square";
    void v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360260;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21195F924()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(mlir::mps::SquareRootOp,mlir::mps::SquareRootOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sqrt", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.sqrt";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360B20;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_211960640()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(mlir::mps::SwishOp,mlir::mps::SwishOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.swish", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.swish";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3607A0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21196135C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(mlir::mps::TanhOp,mlir::mps::TanhOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.tanh", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.tanh";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  __int16 v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::detail::constant_int_op_binder_any_splat::match(mlir::detail::constant_int_op_binder_any_splat *this, mlir::Operation *a2)
{
  v25[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 6) + 32))(*((void *)a2 + 6), v4)) {
    return 0;
  }
  v24[0] = v25;
  v24[1] = (void *)0x100000000;
  mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v24);
  unint64_t v5 = *(void *)v24[0] & 0xFFFFFFFFFFFFFFF8;
  if (v24[0] != v25) {
    free(v24[0]);
  }
  if (!v5) {
    return 0;
  }
  unint64_t v6 = *(void **)(*(void *)(*((void *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136);
  if (v6 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    uint64_t v8 = *(void *)this;
    uint64_t v9 = *(void **)(*(void *)v5 + 136);
    BOOL v10 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    BOOL v11 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
      unint64_t v12 = v5;
    }
    else {
      unint64_t v12 = 0;
    }
    v23[0] = v12;
    if (v10)
    {
      mlir::IntegerAttr::getValue((uint64_t)v23, (llvm::APInt *)v24);
      if (*(_DWORD *)(v8 + 8) >= 0x41u && *(void *)v8) {
        MEMORY[0x21667D390](*(void *)v8, 0x1000C8000313F17);
      }
      *(void **)uint64_t v8 = v24[0];
      *(_DWORD *)(v8 + 8) = v24[1];
    }
  }
  else
  {
    if (mlir::DenseElementsAttr::classof(v5)) {
      uint64_t v15 = (mlir::detail::constant_int_op_binder_any_splat *)v5;
    }
    else {
      uint64_t v15 = 0;
    }
    v24[0] = v15;
    if (v15)
    {
      uint64_t v15 = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v24)
          ? (mlir::detail::constant_int_op_binder_any_splat *)v5
          : 0;
      __int16 v22 = v15;
      if (v15)
      {
        uint64_t v16 = *(void *)this;
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v22);
        ZinMirCacheTensors::ZinMirCacheTensors(v24, (uint64_t)v22, 0);
        this = v22;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v22);
        ZinMirCacheTensors::ZinMirCacheTensors(v23, (uint64_t)this, NumElements);
        uint64_t v18 = mlir::DenseElementsAttr::AttributeElementIterator::operator*(v24);
        BOOL v19 = *(void **)(*(void *)v18 + 136);
        BOOL v20 = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        LODWORD(this) = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        if (v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
          uint64_t v21 = v18;
        }
        else {
          uint64_t v21 = 0;
        }
        v23[0] = v21;
        if (v20)
        {
          mlir::IntegerAttr::getValue((uint64_t)v23, (llvm::APInt *)v24);
          if (*(_DWORD *)(v16 + 8) >= 0x41u && *(void *)v16) {
            MEMORY[0x21667D390](*(void *)v16, 0x1000C8000313F17);
          }
          *(void **)uint64_t v16 = v24[0];
          *(_DWORD *)(v16 + 8) = v24[1];
        }
        LODWORD(v15) = 1;
      }
    }
    return v15 & this;
  }
  return v11;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.equal";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  BOOL v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than", (const unsigned __int8 *)0x11, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than";
    v15[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_zero", (const unsigned __int8 *)0x16, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_zero";
    v15[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal", (const unsigned __int8 *)0x17, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal";
    v15[3] = 23;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal_zero", (const unsigned __int8 *)0x1C, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal_zero";
    v15[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      unint64_t v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  unint64_t v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp) {
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29) {
          MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        }
        goto LABEL_32;
      }
      uint64_t v18 = v29;
    }
    else
    {
      uint64_t v18 = &v29;
    }
    BOOL v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
        if (!v19) {
          goto LABEL_32;
        }
LABEL_26:
        uint64_t v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20)) {
        else
        }
          uint64_t v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    BOOL v19 = 0;
    if (v30 >= 0x41) {
      goto LABEL_22;
    }
  }
  if (v19) {
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(void *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v22);
  uint64_t v21 = 1;
LABEL_33:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal", (const unsigned __int8 *)0x14, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal";
    v15[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a3 + 40);
  unint64_t v6 = *(void *)(a3 + 48);
  uint64_t v26 = v28;
  uint64_t v27 = 0x600000000;
  if (v6 < 7)
  {
    uint64_t v29 = v7;
    uint64_t v30 = 0;
    if (!v6)
    {
      int v13 = 0;
      __int16 v14 = v28;
      goto LABEL_12;
    }
    uint64_t v8 = 0;
    uint64_t v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    uint64_t v8 = v27;
    uint64_t v9 = v26;
    uint64_t v29 = v7;
    uint64_t v30 = 0;
  }
  uint64_t v10 = 0;
  BOOL v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    uint64_t v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  int v13 = v27;
  __int16 v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  uint64_t v24 = *((void *)v14 + 1);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    uint64_t v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
    else
    }
      uint64_t v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  uint64_t v29 = 0;
  uint64_t v25 = &v29;
  int v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  unsigned int v17 = v30;
  if (!v16)
  {
    BOOL v19 = 0;
    if (v30 < 0x41) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29) {
        MEMORY[0x21667D390](v29, 0x1000C8000313F17);
      }
      goto LABEL_28;
    }
    uint64_t v18 = v29;
  }
  else
  {
    uint64_t v18 = &v29;
  }
  BOOL v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29) {
      MEMORY[0x21667D390](v29, 0x1000C8000313F17);
    }
  }
LABEL_24:
  if (!v19) {
    goto LABEL_28;
  }
  uint64_t v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v20);
  uint64_t v21 = 1;
LABEL_32:
  if (v26 != v28) {
    free(v26);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal_zero", (const unsigned __int8 *)0x19, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal_zero";
    v15[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360500;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        unint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    BOOL v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    BOOL v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_211967318()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      BOOL v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          uint64_t v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    unint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  uint64_t v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotOp,mlir::mps::NotOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.equal_zero";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  uint64_t v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 96);
      long long v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      long long v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      long long v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v35 = 259;
    v32[0] = v34;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::SmallVectorImpl<unsigned long long>::resize(uint64_t result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(result + 8);
  unint64_t v4 = a2 - v3;
  if (a2 != v3)
  {
    int v5 = a2;
    if (a2 < v3)
    {
LABEL_11:
      *(_DWORD *)(result + 8) = v5;
      return result;
    }
    if (*(unsigned int *)(result + 12) < a2)
    {
      uint64_t v14 = result;
      unint64_t v12 = a2 - v3;
      unint64_t v13 = a3;
      llvm::SmallVectorBase<unsigned int>::grow_pod(result, (void *)(result + 16), a2, 8);
      unint64_t v4 = v12;
      a3 = v13;
      uint64_t result = v14;
      unint64_t v3 = *(unsigned int *)(v14 + 8);
      if (v12) {
        goto LABEL_5;
      }
    }
    else if (v4)
    {
LABEL_5:
      uint64_t v6 = *(void *)result + 8 * v3;
      uint64_t v7 = (unint64_t *)v6;
      unint64_t v8 = v4;
      if (v4 < 4) {
        goto LABEL_17;
      }
      uint64_t v7 = (unint64_t *)(v6 + 8 * (v4 & 0xFFFFFFFFFFFFFFFCLL));
      unint64_t v8 = v4 & 3;
      int64x2_t v9 = vdupq_n_s64(a3);
      uint64_t v10 = (int64x2_t *)(v6 + 16);
      unint64_t v11 = v4 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v10[-1] = v9;
        int64x2_t *v10 = v9;
        v10 += 2;
        v11 -= 4;
      }
      while (v11);
      if (v4 != (v4 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_17:
        do
        {
          *v7++ = a3;
          --v8;
        }
        while (v8);
      }
    }
    int v5 = v3 + v4;
    goto LABEL_11;
  }
  return result;
}

uint64_t mlir::anonymous namespace'::updatePoolPadding(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, unint64_t **a7, int a8, char a9)
{
  v55[0] = a1;
  v55[1] = a2;
  uint64_t v13 = *a3;
  uint64_t v14 = *a5;
  mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  uint64_t v16 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v55) + 8 * (v15 - 4));
  uint64_t v17 = v16 % v14;
  if (v16 % v14) {
    uint64_t v18 = v16 % v14;
  }
  else {
    uint64_t v18 = v14;
  }
  unint64_t v19 = (v13 - v18) & ~((v13 - v18) >> 63);
  unint64_t v20 = v19 >> 1;
  uint64_t v21 = *a7;
  unint64_t v22 = v19 - (v19 >> 1);
  *uint64_t v21 = v20;
  v21[1] = v22;
  if (a9)
  {
    *uint64_t v21 = v22;
    v21[1] = v20;
    unint64_t v22 = v20;
  }
  if (v17) {
    BOOL v23 = a8 == 0;
  }
  else {
    BOOL v23 = 1;
  }
  if (!v23) {
    v21[1] = v22 + 1;
  }
  uint64_t v24 = a3[1];
  uint64_t v25 = a5[1];
  mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  uint64_t v27 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v55) + 8 * (v26 - 3));
  uint64_t v28 = v27 % v25;
  if (v27 % v25) {
    uint64_t v29 = v27 % v25;
  }
  else {
    uint64_t v29 = v25;
  }
  unint64_t v30 = (v24 - v29) & ~((v24 - v29) >> 63);
  unint64_t v31 = v30 >> 1;
  __int16 v32 = *a7;
  unint64_t v33 = v30 - (v30 >> 1);
  void v32[2] = v31;
  void v32[3] = v33;
  if (a9)
  {
    void v32[2] = v33;
    void v32[3] = v31;
    unint64_t v33 = v31;
  }
  if (v28) {
    BOOL v34 = a8 == 0;
  }
  else {
    BOOL v34 = 1;
  }
  if (!v34) {
    void v32[3] = v33 + 1;
  }
  uint64_t v35 = a3[2];
  uint64_t v36 = a5[2];
  mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  uint64_t v38 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v55) + 8 * (v37 - 2)) % v36;
  if (v38) {
    uint64_t v39 = v38;
  }
  else {
    uint64_t v39 = v36;
  }
  unint64_t v40 = (v35 - v39) & ~((v35 - v39) >> 63);
  unint64_t v41 = v40 >> 1;
  unint64_t v42 = *a7;
  unint64_t v43 = v40 - (v40 >> 1);
  v42[4] = v41;
  v42[5] = v43;
  if (a9)
  {
    v42[4] = v43;
    v42[5] = v41;
    unint64_t v43 = v41;
  }
  if (v38 && a8) {
    v42[5] = v43 + 1;
  }
  uint64_t v44 = a3[3];
  uint64_t v45 = a5[3];
  mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  unsigned int v47 = v46 - 1;
  uint64_t result = mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  uint64_t v49 = *(void *)(result + 8 * v47) % v45;
  if (v49) {
    uint64_t v50 = *(void *)(result + 8 * v47) % v45;
  }
  else {
    uint64_t v50 = v45;
  }
  unint64_t v51 = (v44 - v50) & ~((v44 - v50) >> 63);
  unint64_t v52 = v51 >> 1;
  unint64_t v53 = *a7;
  unint64_t v54 = v51 - (v51 >> 1);
  v53[6] = v52;
  v53[7] = v54;
  if (a9)
  {
    v53[6] = v54;
    v53[7] = v52;
    unint64_t v54 = v52;
  }
  if (v49)
  {
    if (a8) {
      v53[7] = v54 + 1;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.average_pool";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  unint64_t v11 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::AveragePool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(char *__src, char *a2, char *a3)
{
  unint64_t v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 8 == a2)
    {
      uint64_t v13 = *(void *)__src;
      int64_t v14 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      unint64_t v4 = &__src[v14];
      *(void *)unint64_t v4 = v13;
    }
    else if (a2 + 8 == a3)
    {
      uint64_t v15 = *((void *)a3 - 1);
      unint64_t v4 = __src + 8;
      size_t v16 = a3 - 8 - __src;
      if (a3 - 8 != __src) {
        memmove(__src + 8, __src, v16);
      }
      *(void *)__src = v15;
    }
    else
    {
      uint64_t v6 = (a2 - __src) >> 3;
      uint64_t v7 = (a3 - a2) >> 3;
      if (v6 == v7)
      {
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = *(void *)&__src[v8];
          *(void *)&__src[v8] = *(void *)&a2[v8];
          char v10 = &__src[v8 + 8];
          *(void *)&a2[v8] = v9;
          uint64_t v11 = (uint64_t)&a2[v8 + 8];
          v8 += 8;
        }
        while (v10 != a2 && v11 != (void)a3);
        return a2;
      }
      else
      {
        uint64_t v17 = (a3 - a2) >> 3;
        uint64_t v18 = (a2 - __src) >> 3;
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = v17;
          uint64_t v17 = v19 % v17;
        }
        while (v17);
        if (v18)
        {
          __int16 v20 = &__src[8 * v18];
          do
          {
            uint64_t v22 = *((void *)v20 - 1);
            v20 -= 8;
            uint64_t v21 = v22;
            BOOL v23 = &v20[8 * v6];
            uint64_t v24 = v20;
            do
            {
              uint64_t v25 = v24;
              uint64_t v24 = v23;
              *(void *)uint64_t v25 = *(void *)v23;
              uint64_t v26 = (a3 - v23) >> 3;
              BOOL v27 = __OFSUB__(v6, v26);
              uint64_t v29 = v6 - v26;
              char v28 = (v29 < 0) ^ v27;
              BOOL v23 = &__src[8 * v29];
              if (v28) {
                BOOL v23 = &v24[8 * v6];
              }
            }
            while (v23 != v20);
            *(void *)uint64_t v24 = v21;
          }
          while (v20 != __src);
        }
        return &__src[8 * v7];
      }
    }
  }
  return v4;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 96);
  uint64_t v9 = *(void *)(a3 + 104);
  int v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 96);
      long long v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      long long v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      long long v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      int v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v35 = 259;
    v32[0] = v34;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.l2norm_pool", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.l2norm_pool";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::L2NormPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::L2NormPool,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void *mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  char v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  char v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 112);
  uint64_t v9 = *(void *)(a3 + 120);
  int v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 112);
      v36[6] = *(_OWORD *)(a3 + 96);
      _OWORD v36[7] = v28;
      long long v29 = *(_OWORD *)(a3 + 80);
      v36[4] = *(_OWORD *)(a3 + 64);
      v36[5] = v29;
      long long v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      long long v31 = *(_OWORD *)(a3 + 48);
      v36[2] = *(_OWORD *)(a3 + 32);
      v36[3] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      int v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v35 = 259;
    v32[0] = v34;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max_pool", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.max_pool";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::MaxPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MaxPool,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::anonymous namespace'::ConvertStencil::~ConvertStencil(mlir::_anonymous_namespace_::ConvertStencil *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 104);
  uint64_t v9 = *(void *)(a3 + 112);
  uint64_t v38 = v8;
  uint64_t v39 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 96);
      uint64_t v37 = *(void *)(a3 + 112);
      long long v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      long long v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      long long v31 = *(_OWORD *)(a3 + 48);
      v36[2] = *(_OWORD *)(a3 + 32);
      v36[3] = v31;
      v36[4] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v36, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v38 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v39 = v23;
      if (v38)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v38);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v35 = 259;
    v32[0] = v34;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v38, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v32);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v39;
    if (v38 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v35 = 259;
  unint64_t v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  char v3 = 1;
  char v9 = 1;
  if (*a3)
  {
    uint64_t v7 = a3;
    char v3 = 3;
  }
  char v8 = v3;
  uint64_t v4 = *a2;
  uint64_t v10 = &v7;
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(*(void *)(a1 + 16));
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v5 + 64))(v5, *(void *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  }
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void *llvm::SmallVector<unsigned long long,3u>::SmallVector(void *a1, const void *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  size_t v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    unsigned int v7 = *((_DWORD *)a1 + 2);
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  unsigned int v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    unsigned int v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v25[38] = *MEMORY[0x263EF8340];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.average_pool";
    v23[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::AveragePool::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  uint64_t v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
    __int16 v18 = v17;
  }
  else {
    __int16 v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3605E0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        uint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        unsigned int v7 = *(v5 - 6);
        size_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21196DC6C()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  __int16 v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      __int16 v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  long long v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(mlir::mps::CeilOp,mlir::mps::CeilOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.ceil", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.ceil";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360490;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21196E988()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(mlir::mps::ErfOp,mlir::mps::ErfOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.erf", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.erf";
    void v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3602D0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_21196F6A4()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(mlir::mps::ExponentBase2Op,mlir::mps::ExponentBase2OpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.exp2";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C3608F0;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_2119703C0()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(mlir::mps::FloorOp,mlir::mps::FloorOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.floor";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360730;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_2119710DC()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(mlir::mps::SignOp,mlir::mps::SignOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sign", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.sign";
    void v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::~ConvertElementwiseUnary(uint64_t a1)
{
  *(void *)a1 = &unk_26C360110;
  uint64_t v2 = *(char **)(a1 + 128);
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    do
    {
      while (1)
      {
        unint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0) {
          operator delete(*(v5 - 3));
        }
        uint64_t v7 = *(v5 - 6);
        uint64_t v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4) {
          goto LABEL_8;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    uint64_t v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144)) {
    free(v2);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 120);
  uint64_t v9 = *(void *)(a1 + 104);
  if (v8)
  {
    uint64_t v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    uint64_t v9 = *(void *)(a1 + 104);
    uint64_t v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    uint64_t v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

void *sub_211971DF8()
{
  uint64_t v1 = (void *)v0[10];
  if (v1 != v0 + 12) {
    free(v1);
  }
  uint64_t v2 = (void *)v0[4];
  if (v2 != v0 + 6) {
    free(v2);
  }
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a1;
  v70[9] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a3 + 40);
  uint64_t v6 = *(void *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  uint64_t v65 = 0;
  uint64_t v66 = v68;
  uint64_t v67 = 0x400000000;
  uint64_t v63 = 0;
  uint64_t v64 = v7;
  uint64_t v55 = v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    uint64_t v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      uint64_t v11 = a1;
      uint64_t v12 = *((void *)v5 + 13);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      if (v13)
      {
        unsigned int v14 = v13 - 1;
        uint64_t v15 = (_DWORD *)(v12 + 32 * ((v13 - 1) & (37 * v9)));
        int v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          uint64_t v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        int v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          int v20 = v19 + v18++;
          uint64_t v19 = v20 & v14;
          int v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            uint64_t v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      uint64_t v15 = (_DWORD *)(v12 + 32 * v13);
      uint64_t v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        uint64_t v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          uint64_t v35 = v67;
        }
        *((void *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        uint64_t v56 = &v58;
        uint64_t v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56)) {
          BOOL v21 = v57 == 1;
        }
        else {
          BOOL v21 = 0;
        }
        char v22 = v21;
        if (v21)
        {
          uint64_t v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          __int16 v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          uint64_t v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          int v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0) {
            uint64_t v29 = v59[0] + 8;
          }
          else {
            uint64_t v29 = *(void *)(v59[0] + 8);
          }
          if (v28 >= 0) {
            uint64_t v30 = *(unsigned __int8 *)(v59[0] + 31);
          }
          else {
            uint64_t v30 = *(void *)(v59[0] + 16);
          }
          uint64_t F16Type = mlir::Builder::getF16Type(v10, v27);
          uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          unint64_t v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          uint64_t v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
          }
        }
        else
        {
          uint64_t v61 = v59;
          uint64_t v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2])) {
            else
            }
              uint64_t v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58) {
          free(v56);
        }
        if ((v22 & 1) == 0) {
          goto LABEL_57;
        }
      }
      int v9 = v63 + 1;
      uint64_t v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  uint64_t v36 = *((unsigned int *)v5 + 34);
  if (v36)
  {
    uint64_t v37 = *((void *)v5 + 16);
    uint64_t v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    uint64_t v39 = (mlir::Float16Type **)(a4 + 1);
    uint64_t v40 = 56 * v36;
    uint64_t v41 = v37 + 32;
    do
    {
      unint64_t v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24)) {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::DoubleAPFloat::DoubleAPFloat(v62, v42);
      }
      else {
        unint64_t v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      }
      uint64_t v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      int v46 = *(char *)(v41 + 23);
      if (v46 >= 0) {
        uint64_t v47 = v41;
      }
      else {
        uint64_t v47 = *(void *)v41;
      }
      if (v46 >= 0) {
        uint64_t v48 = *(unsigned __int8 *)(v41 + 23);
      }
      else {
        uint64_t v48 = *(void *)(v41 + 8);
      }
      uint64_t v49 = mlir::Builder::getF16Type(v39, v45);
      uint64_t v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      }
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  unint64_t v51 = mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(void *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v51);
  uint64_t v4 = 1;
LABEL_57:
  if (v66 != v68) {
    free(v66);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(mlir::mps::TruncateOp,mlir::mps::TruncateOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = ***a1;
  int v15 = 5;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  uint64_t v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      unsigned int v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      uint64_t v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.trunc", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.trunc";
    void v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  BOOL v13 = (const void *)ANECStepToZinIrDims3D(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x263EF8340];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v29[0] = *(void *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        uint64_t v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

unint64_t mlir::anonymous namespace'::convertAxes(uint64_t a1, unint64_t a2, uint64_t a3)
{
  void v55[2] = *MEMORY[0x263EF8340];
  v55[0] = a1;
  v55[1] = a2;
  unint64_t v51 = 0;
  unint64_t v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a3 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v52 = v5;
  uint64_t v53 = v15;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v52);
  unint64_t v17 = v16;
  unint64_t v51 = v16;
  if (a2 > 1)
  {
    uint64_t v21 = (void *)mlir::ValueRange::dereference_iterator(v55, 1);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v21, v17, 0, 0);
    if (v23) {
      unsigned __int8 v24 = SortedUniquePromotedPositiveAxesAttr;
    }
    else {
      unsigned __int8 v24 = 0;
    }
    if (v23) {
      unint64_t v25 = SortedUniquePromotedPositiveAxesAttr & 0xFFFFFFFFFFFFFF00;
    }
    else {
      unint64_t v25 = 0;
    }
    return v25 | v24;
  }
  unint64_t v52 = v54;
  uint64_t v53 = 0x600000000;
  if (!v16) {
    goto LABEL_31;
  }
  if (v16 < 7)
  {
    uint64_t v18 = 0;
    unint64_t v19 = (int64x2_t *)v54;
    unint64_t v20 = v16;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v54, v16, 8);
    uint64_t v18 = v53;
    unint64_t v19 = (int64x2_t *)v52;
    unint64_t v20 = v17 - v53;
    if (v17 == v53) {
      goto LABEL_24;
    }
  }
  bzero((char *)v19 + 8 * v18, 8 * v20);
LABEL_24:
  LODWORD(v53) = v17;
  if (!v17) {
    goto LABEL_31;
  }
  unint64_t v26 = (v17 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v26 < 3)
  {
    uint64_t v27 = 0;
    long long v28 = (uint64_t *)v19;
    do
LABEL_30:
      *v28++ = v27++;
    while (v28 != (uint64_t *)((char *)v19 + 8 * v17));
    goto LABEL_31;
  }
  unint64_t v29 = v26 + 1;
  uint64_t v27 = (v26 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  long long v28 = &v19->i64[v27];
  int64x2_t v30 = (int64x2_t)xmmword_211ED5A80;
  long long v31 = v19 + 1;
  int64x2_t v32 = vdupq_n_s64(2uLL);
  int64x2_t v33 = vdupq_n_s64(4uLL);
  uint64_t v34 = v27;
  do
  {
    v31[-1] = v30;
    *long long v31 = vaddq_s64(v30, v32);
    int64x2_t v30 = vaddq_s64(v30, v33);
    v31 += 2;
    v34 -= 4;
  }
  while (v34);
  if (v29 != v27) {
    goto LABEL_30;
  }
LABEL_31:
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a3 + 24));
  uint64_t v36 = mlir::IntegerType::get(Context, 0x40u, 2u);
  uint64_t v37 = (void *)mlir::RankedTensorType::get((uint64_t)&v51, 1, v36, 0);
  uint64_t v38 = v37;
  if (!v37) {
    goto LABEL_40;
  }
  uint64_t v39 = *v37;
  unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v41 = *(unsigned int *)(v39 + 16);
  if (!v41) {
    goto LABEL_40;
  }
  unint64_t v42 = *(void **)(v39 + 8);
  unint64_t v43 = &v42[2 * v41];
  do
  {
    unint64_t v44 = v41 >> 1;
    uint64_t v45 = &v42[2 * (v41 >> 1)];
    unint64_t v47 = *v45;
    int v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40) {
      unint64_t v42 = v46;
    }
    else {
      unint64_t v41 = v44;
    }
  }
  while (v41);
  if (v42 != v43 && *v42 == v40) {
    uint64_t v48 = v42[1];
  }
  else {
LABEL_40:
  }
    uint64_t v48 = 0;
  uint64_t v49 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v52, 8 * v53, 8, 1, 0);
  unsigned __int8 v24 = v49;
  unint64_t v25 = v49 & 0xFFFFFFFFFFFFFF00;
  if (v52 != v54) {
    free(v52);
  }
  return v25 | v24;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_max", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_max";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMax::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x263EF8340];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v29[0] = *(void *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_avg", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_avg";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceAvg::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x263EF8340];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v29[0] = *(void *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_min", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_min";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMin::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  long long v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v29[2] = *MEMORY[0x263EF8340];
  uint64_t v25 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v29[0] = *(void *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    uint64_t v9 = mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v13 = *(unsigned int *)(v11 + 16);
      if (!v13) {
        goto LABEL_12;
      }
      unint64_t v14 = *(void **)(v11 + 8);
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        __int16 v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          unint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_12:
      }
        uint64_t v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    uint64_t v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    __int16 v27 = 259;
    long long v28 = v26;
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), uint64_t **))(*(void *)v22 + 64))(v22, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    }
    else {
      return 0;
    }
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_sum", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reduce_sum";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceSum::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v112[2] = *MEMORY[0x263EF8340];
  unint64_t v93 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v112[0] = *(void *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    unint64_t v96 = "failed to convert operand axes";
    v98[8] = 259;
    int32x2_t v109 = &v96;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    uint64_t v57 = v93;
    unint64_t v96 = &v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
    return 0;
    }
  }
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  int32x2_t v109 = (void **)v111;
  uint64_t v110 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  uint64_t v106 = v108;
  memset(v108, 0, sizeof(v108));
  uint64_t v107 = 0x600000006;
  long long v103 = v105;
  memset_pattern16(v105, &unk_211ED5510, 0x18uLL);
  uint64_t v104 = 0x600000003;
  uint64_t v100 = v102;
  memset_pattern16(v102, &unk_211ED5510, 0x18uLL);
  uint64_t v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v92);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    uint64_t v89 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v110)
  {
    unint64_t v35 = IndexFromDim;
    uint64_t v36 = (uint64_t *)v109;
    uint64_t v37 = 8 * v110;
    while (1)
    {
      uint64_t v38 = *v36;
      v94[0] = v38;
      if (v38 == v35) {
        break;
      }
      if (v38 <= 1)
      {
        uint64_t v61 = v93;
        unint64_t v96 = &v93;
        uint64_t v55 = *(void *)(a4 + 16);
        if (!v55) {
          goto LABEL_89;
        }
        if (mlir::RewriterBase::Listener::classof(v55))
        {
          uint64_t v59 = *((void *)v61 + 3);
          goto LABEL_54;
        }
        goto LABEL_56;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v92);
      *((void *)v100 + v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    uint64_t v58 = v93;
    unint64_t v96 = v94;
    uint64_t v97 = (uint64_t)&v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      goto LABEL_89;
    }
    if (mlir::RewriterBase::Listener::classof(v55))
    {
      uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v96);
      goto LABEL_89;
    }
LABEL_56:
    uint64_t v55 = 0;
  }
  else
  {
LABEL_29:
    unint64_t v96 = v98;
    uint64_t v97 = 0x400000000;
    uint64_t v99 = 4;
    v94[0] = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
    v94[0] = 6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
    v94[0] = "ksize";
    __int16 v95 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          unint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
    v94[0] = "stride";
    __int16 v95 = 259;
    uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v41)
    {
      uint64_t v64 = v43;
      uint64_t v65 = *v41;
      unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v67 = *(unsigned int *)(v65 + 16);
      if (v67)
      {
        unint64_t v68 = *(void **)(v65 + 8);
        unint64_t v69 = &v68[2 * v67];
        do
        {
          unint64_t v70 = v67 >> 1;
          uint64_t v71 = &v68[2 * (v67 >> 1)];
          unint64_t v73 = *v71;
          unint64_t v72 = v71 + 2;
          v67 += ~(v67 >> 1);
          if (v73 < v66) {
            unint64_t v68 = v72;
          }
          else {
            unint64_t v67 = v70;
          }
        }
        while (v67);
        unint64_t v43 = v64;
        if (v68 == v69)
        {
          uint64_t v74 = 0;
        }
        else if (*v68 == v66)
        {
          uint64_t v74 = v68[1];
        }
        else
        {
          uint64_t v74 = 0;
        }
      }
      else
      {
        uint64_t v74 = 0;
        unint64_t v43 = v64;
      }
    }
    else
    {
      uint64_t v74 = 0;
    }
    uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
    v94[0] = "padding";
    __int16 v95 = 259;
    uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v43
      && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
    {
      uint64_t v80 = *(void **)(v77 + 8);
      uint64_t v81 = &v80[2 * v79];
      do
      {
        unint64_t v82 = v79 >> 1;
        uint64_t v83 = &v80[2 * (v79 >> 1)];
        unint64_t v85 = *v83;
        uint64_t v84 = v83 + 2;
        v79 += ~(v79 >> 1);
        if (v85 < v78) {
          uint64_t v80 = v84;
        }
        else {
          unint64_t v79 = v82;
        }
      }
      while (v79);
      if (v80 != v81 && *v80 == v78) {
        uint64_t v86 = v80[1];
      }
      else {
        uint64_t v86 = 0;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
    v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
    uint64_t v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
    if (v96 != v98) {
      free(v96);
    }
    uint64_t v55 = 1;
  }
LABEL_89:
  if (v100 != v102) {
    free(v100);
  }
  if (v103 != v105) {
    free(v103);
  }
  if (v106 != v108) {
    free(v106);
  }
  if (v109 != (void **)v111) {
    free(v109);
  }
  return v55;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v114[2] = *MEMORY[0x263EF8340];
  __int16 v95 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v114[0] = *(void *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    uint64_t v98 = "failed to convert operand axes";
    v100[8] = 259;
    unint64_t v111 = &v98;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    uint64_t v57 = v95;
    uint64_t v98 = &v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  unint64_t v111 = (void **)v113;
  uint64_t v112 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  uint64_t v108 = v110;
  memset(v110, 0, sizeof(v110));
  uint64_t v109 = 0x600000006;
  uint64_t v105 = v107;
  memset_pattern16(v107, &unk_211ED5510, 0x18uLL);
  uint64_t v106 = 0x600000003;
  uint64_t v102 = v104;
  memset_pattern16(v104, &unk_211ED5510, 0x18uLL);
  uint64_t v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v94);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    uint64_t v91 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v112)
  {
    unint64_t v35 = IndexFromDim;
    uint64_t v36 = (uint64_t *)v111;
    uint64_t v37 = 8 * v112;
    while (1)
    {
      uint64_t v38 = *v36;
      v96[0] = v38;
      if (v38 == v35) {
        break;
      }
      if (v38 <= 1)
      {
        uint64_t v61 = v95;
        uint64_t v98 = &v95;
        uint64_t v55 = *(void *)(a4 + 16);
        if (!v55) {
          goto LABEL_89;
        }
        if (mlir::RewriterBase::Listener::classof(v55))
        {
          uint64_t v59 = *((void *)v61 + 3);
          goto LABEL_54;
        }
        goto LABEL_56;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v94);
      *((void *)v102 + v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    uint64_t v58 = v95;
    uint64_t v98 = v96;
    uint64_t v99 = (uint64_t)&v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      goto LABEL_89;
    }
    if (mlir::RewriterBase::Listener::classof(v55))
    {
      uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v98);
      goto LABEL_89;
    }
LABEL_56:
    uint64_t v55 = 0;
  }
  else
  {
LABEL_29:
    uint64_t v98 = v100;
    uint64_t v99 = 0x400000000;
    uint64_t v101 = 4;
    v96[0] = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
    v96[0] = 6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
    v96[0] = "ksize";
    __int16 v97 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          unint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
    v96[0] = "stride";
    __int16 v97 = 259;
    uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v41)
    {
      uint64_t v64 = v43;
      uint64_t v65 = *v41;
      unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v67 = *(unsigned int *)(v65 + 16);
      if (v67)
      {
        unint64_t v68 = *(void **)(v65 + 8);
        unint64_t v69 = &v68[2 * v67];
        do
        {
          unint64_t v70 = v67 >> 1;
          uint64_t v71 = &v68[2 * (v67 >> 1)];
          unint64_t v73 = *v71;
          unint64_t v72 = v71 + 2;
          v67 += ~(v67 >> 1);
          if (v73 < v66) {
            unint64_t v68 = v72;
          }
          else {
            unint64_t v67 = v70;
          }
        }
        while (v67);
        unint64_t v43 = v64;
        if (v68 == v69)
        {
          uint64_t v74 = 0;
        }
        else if (*v68 == v66)
        {
          uint64_t v74 = v68[1];
        }
        else
        {
          uint64_t v74 = 0;
        }
      }
      else
      {
        uint64_t v74 = 0;
        unint64_t v43 = v64;
      }
    }
    else
    {
      uint64_t v74 = 0;
    }
    uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
    v96[0] = "padding";
    __int16 v97 = 259;
    uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v43
      && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
    {
      uint64_t v80 = *(void **)(v77 + 8);
      uint64_t v81 = &v80[2 * v79];
      do
      {
        unint64_t v82 = v79 >> 1;
        uint64_t v83 = &v80[2 * (v79 >> 1)];
        unint64_t v85 = *v83;
        uint64_t v84 = v83 + 2;
        v79 += ~(v79 >> 1);
        if (v85 < v78) {
          uint64_t v80 = v84;
        }
        else {
          unint64_t v79 = v82;
        }
      }
      while (v79);
      if (v80 != v81 && *v80 == v78) {
        uint64_t v86 = v80[1];
      }
      else {
        uint64_t v86 = 0;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
    v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
    mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
    unint64_t v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
    if (v98 != v100) {
      free(v98);
    }
    uint64_t v55 = 1;
  }
LABEL_89:
  if (v102 != v104) {
    free(v102);
  }
  if (v105 != v107) {
    free(v105);
  }
  if (v108 != v110) {
    free(v108);
  }
  if (v111 != (void **)v113) {
    free(v111);
  }
  return v55;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v140[2] = *MEMORY[0x263EF8340];
  unint64_t v119 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v140[0] = *(void *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    unint64_t v124 = "failed to convert operand axes";
    v126[8] = 259;
    uint64_t v137 = &v124;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    uint64_t v57 = v119;
    unint64_t v124 = &v119;
    uint64_t v58 = *(void *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  uint64_t v137 = (void **)v139;
  uint64_t v138 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  unint64_t v134 = v136;
  memset(v136, 0, sizeof(v136));
  uint64_t v135 = 0x600000006;
  long long v131 = v133;
  memset_pattern16(v133, &unk_211ED5510, 0x18uLL);
  uint64_t v132 = 0x600000003;
  uint64_t v128 = v130;
  memset_pattern16(v130, &unk_211ED5510, 0x18uLL);
  uint64_t v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v117);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    char v114 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v138)
  {
    unint64_t v35 = (uint64_t *)IndexFromDim;
    uint64_t v36 = (uint64_t **)v137;
    uint64_t v37 = 8 * v138;
    while (1)
    {
      uint64_t v38 = *v36;
      v122[0] = v38;
      if (v38 == v35) {
        break;
      }
      if ((uint64_t)v38 <= 1)
      {
        uint64_t v64 = v119;
        unint64_t v124 = &v119;
        uint64_t v61 = *(void *)(a4 + 16);
        if (v61 && mlir::RewriterBase::Listener::classof(v61))
        {
          uint64_t v62 = *((void *)v64 + 3);
          goto LABEL_54;
        }
        goto LABEL_55;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v117);
      *((void *)v128 + (void)v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    uint64_t v60 = v119;
    unint64_t v124 = v122;
    uint64_t v125 = (uint64_t)&v119;
    uint64_t v61 = *(void *)(a4 + 16);
    if (v61 && mlir::RewriterBase::Listener::classof(v61))
    {
      uint64_t v62 = *((void *)v60 + 3);
LABEL_54:
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v61 + 64))(v61, v62, v63, &v124);
      goto LABEL_96;
    }
LABEL_55:
    uint64_t v59 = 0;
  }
  else
  {
LABEL_29:
    unint64_t v124 = v126;
    uint64_t v125 = 0x400000000;
    uint64_t v127 = 4;
    v122[0] = (uint64_t *)3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
    v122[0] = (uint64_t *)6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
    v122[0] = (uint64_t *)"ksize";
    __int16 v123 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          unint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
    v122[0] = (uint64_t *)"stride";
    __int16 v123 = 259;
    uint64_t v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (!v41) {
      goto LABEL_70;
    }
    uint64_t v67 = *v41;
    unint64_t v68 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v69 = *(unsigned int *)(v67 + 16);
    if (!v69) {
      goto LABEL_70;
    }
    unint64_t v70 = *(void **)(v67 + 8);
    uint64_t v71 = &v70[2 * v69];
    do
    {
      unint64_t v72 = v69 >> 1;
      unint64_t v73 = &v70[2 * (v69 >> 1)];
      unint64_t v75 = *v73;
      uint64_t v74 = v73 + 2;
      v69 += ~(v69 >> 1);
      if (v75 < v68) {
        unint64_t v70 = v74;
      }
      else {
        unint64_t v69 = v72;
      }
    }
    while (v69);
    if (v70 != v71 && *v70 == v68) {
      uint64_t v76 = v70[1];
    }
    else {
LABEL_70:
    }
      uint64_t v76 = 0;
    uint64_t v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
    v122[0] = (uint64_t *)"padding";
    __int16 v123 = 259;
    uint64_t v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (!v43) {
      goto LABEL_80;
    }
    uint64_t v79 = *v43;
    unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v81 = *(unsigned int *)(v79 + 16);
    if (!v81) {
      goto LABEL_80;
    }
    unint64_t v82 = *(void **)(v79 + 8);
    uint64_t v83 = &v82[2 * v81];
    do
    {
      unint64_t v84 = v81 >> 1;
      unint64_t v85 = &v82[2 * (v81 >> 1)];
      unint64_t v87 = *v85;
      uint64_t v86 = v85 + 2;
      v81 += ~(v81 >> 1);
      if (v87 < v80) {
        unint64_t v82 = v86;
      }
      else {
        unint64_t v81 = v84;
      }
    }
    while (v81);
    if (v82 != v83 && *v82 == v80) {
      uint64_t v88 = v82[1];
    }
    else {
LABEL_80:
    }
      uint64_t v88 = 0;
    uint64_t v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
    uint64_t v90 = mlir::ValueRange::dereference_iterator(v140, 0);
    v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
    if (mlir::Type::isF16((mlir::Type *)v122)
      || (uint64_t GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
          mlir::Type::isF32((mlir::Type *)&GOC)))
    {
      uint64_t GOC = 1;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
      uint64_t v93 = (uint64_t)v92;
      if (!v92) {
        goto LABEL_92;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_92;
      }
      __int16 v97 = *(void **)(v94 + 8);
      uint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          __int16 v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_92:
      }
        uint64_t v103 = 0;
      uint64_t v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
      uint64_t v59 = 1;
      v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
      uint64_t v105 = *((void *)v119 + 3);
      uint64_t v120 = 1;
      uint64_t v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
      uint64_t v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
      uint64_t v108 = *((void *)v119 + 3);
      uint64_t v116 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
      uint64_t v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
      uint64_t v109 = (mlir::MLIRContext *)*((void *)v119 + 3);
      uint64_t v110 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v120);
      mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
    }
    else
    {
      uint64_t v112 = v119;
      v122[0] = v118;
      uint64_t v113 = *(void *)(a4 + 16);
      if (v113)
      {
        if (mlir::RewriterBase::Listener::classof(v113)) {
        else
        }
          uint64_t v59 = 0;
      }
      else
      {
        uint64_t v59 = 0;
      }
    }
    if (v124 != v126) {
      free(v124);
    }
  }
LABEL_96:
  if (v128 != v130) {
    free(v128);
  }
  if (v131 != v133) {
    free(v131);
  }
  if (v134 != v136) {
    free(v134);
  }
  if (v137 != (void **)v139) {
    free(v137);
  }
  return v59;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  unint64_t v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  uint64_t v6 = v3 + 16;
  unint64_t v7 = *(void *)(v3 + 16);
  uint64_t v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v8 + 1;
    BOOL v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      uint64_t v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = v15;
    }
  }
  unint64_t v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v5;
  *(void *)(v9 + 16) = *((void *)v5 + 2);
  *(_OWORD *)unint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

ZinIrHalH13g *mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  unint64_t v72 = a2;
  unint64_t v6 = *(void *)(a3 + 56);
  uint64_t v94 = *(void *)(a3 + 48);
  unint64_t v95 = v6;
  if (!v8)
  {
    unint64_t v75 = "failed to convert operand axes";
    v77[8] = 259;
    uint64_t v78 = &v75;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
        return (ZinIrHalH13g *)(*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v42 + 64))(v42, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v78);
      }
      return 0;
    }
    return (ZinIrHalH13g *)v42;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v72))
  {
    unint64_t v44 = v72;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      return 0;
      }
    }
    return (ZinIrHalH13g *)v42;
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v91 = v93;
  uint64_t v92 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v91, 1);
  uint64_t v88 = v90;
  memset(v90, 0, sizeof(v90));
  uint64_t v89 = 0x600000006;
  unint64_t v85 = v87;
  memset_pattern16(v87, &unk_211ED5510, 0x18uLL);
  uint64_t v86 = 0x600000003;
  unint64_t v82 = v84;
  memset_pattern16(v84, &unk_211ED5510, 0x18uLL);
  uint64_t v83 = 0x600000003;
  v71[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v71[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v71);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if (v92 == 1 && *v91 == IndexFromDim)
    {
      uint64_t v69 = *((void *)v72 + 3);
      uint64_t v35 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v71) + 8 * IndexFromDim);
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      uint64_t v78 = v80;
      v80[0] = 1;
      v80[1] = v35;
      int64x2_t v81 = vdupq_n_s64(1uLL);
      uint64_t v79 = 0x1000000004;
      uint64_t v70 = mlir::MemRefType::get(v80, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
      uint64_t NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
      unint64_t v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
      unint64_t v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
      if (v41 != v40)
      {
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v74, (uint64_t)v40, (llvm::APInt *)1);
        unint64_t v75 = v77;
        uint64_t v76 = 0x1000000000;
        llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v75, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
        if (v41 == (llvm::APFloatBase *)v74[0]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v74);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v74);
        }
        unint64_t v47 = v78;
        uint64_t v48 = v79;
        uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
        unint64_t v50 = (void *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
        ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v75, v76);
        v74[0] = v51;
        mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v69, &v70, (void **)&ElementsAttr);
        unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v52) {
          goto LABEL_53;
        }
        uint64_t v53 = *v52;
        unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v55 = *(unsigned int *)(v53 + 16);
        if (!v55) {
          goto LABEL_53;
        }
        uint64_t v56 = *(void **)(v53 + 8);
        uint64_t v57 = &v56[2 * v55];
        do
        {
          unint64_t v58 = v55 >> 1;
          uint64_t v59 = &v56[2 * (v55 >> 1)];
          unint64_t v61 = *v59;
          uint64_t v60 = v59 + 2;
          v55 += ~(v55 >> 1);
          if (v61 < v54) {
            uint64_t v56 = v60;
          }
          else {
            unint64_t v55 = v58;
          }
        }
        while (v55);
        if (v56 != v57 && *v56 == v54) {
          uint64_t v62 = v56[1];
        }
        else {
LABEL_53:
        }
          uint64_t v62 = 0;
      }
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v74, (uint64_t)v40);
    }
    uint64_t v45 = v72;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42)) {
      else
      }
        uint64_t v42 = 0;
    }
    if (v82 != v84) {
      free(v82);
    }
    if (v85 != v87) {
      free(v85);
    }
    if (v88 != v90) {
      free(v88);
    }
    if (v91 != (void *)v93) {
      free(v91);
    }
    return (ZinIrHalH13g *)v42;
  }
  uint64_t v64 = (mlir::Builder *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(v64, v65, v66, v67, v68);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.convolution";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Convolution::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::SmallVectorImpl<llvm::APFloat>::assign(unsigned int *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a1;
  if (a1[3] >= a2)
  {
    unint64_t v6 = a1[2];
    if (v6 >= a2) {
      unint64_t v7 = a2;
    }
    else {
      unint64_t v7 = a1[2];
    }
    if (v7)
    {
      char v8 = (llvm::APFloatBase *)(*(void *)a1 + 8);
      do
      {
        a1 = (unsigned int *)llvm::APFloat::Storage::operator=(v8, (uint64_t *)(a3 + 8));
        char v8 = (llvm::APFloatBase *)((char *)v8 + 32);
        --v7;
      }
      while (v7);
      unint64_t v6 = v5[2];
    }
    unint64_t v9 = v6 - a2;
    if (v6 >= a2)
    {
      if (v6 > a2)
      {
        uint64_t v16 = *(void *)v5;
        uint64_t v17 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
        __int16 v18 = (llvm::detail::DoubleAPFloat *)(32 * v6 + v16 - 24);
        uint64_t v19 = 32 * a2 - 32 * v6;
        do
        {
          if (v17 == *(void **)v18) {
            llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
          }
          else {
            llvm::detail::IEEEFloat::~IEEEFloat(v18);
          }
          __int16 v18 = (llvm::detail::DoubleAPFloat *)(v20 - 32);
          v19 += 32;
        }
        while (v19);
      }
    }
    else
    {
      uint64_t v10 = *(void *)v5;
      uint64_t v11 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
      char v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
      unint64_t v13 = (llvm::detail::IEEEFloat *)(v10 + 32 * v6 + 8);
      do
      {
        if (v12 == *(void **)v11) {
          uint64_t v14 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, v11);
        }
        else {
          uint64_t v14 = (void *)llvm::detail::IEEEFloat::IEEEFloat(v13, v11);
        }
        unint64_t v13 = (llvm::detail::IEEEFloat *)(v14 + 4);
      }
      while (!__CFADD__(v9++, 1));
    }
    v5[2] = a2;
  }
  else
  {
    llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign((uint64_t)a1, a2, a3);
  }
}

void llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v20 = 0;
  unint64_t v6 = (char *)(a1 + 16);
  unint64_t v7 = (llvm::APFloatBase *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v20);
  char v8 = v7;
  if (a2)
  {
    unint64_t v9 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
    uint64_t v10 = llvm::APFloatBase::PPCDoubleDouble(v7);
    unint64_t v7 = (llvm::APFloatBase *)((char *)v8 + 8);
    unint64_t v11 = a2;
    do
    {
      if (v10 == *(void **)v9) {
        char v12 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v7, v9);
      }
      else {
        char v12 = (void *)llvm::detail::IEEEFloat::IEEEFloat(v7, v9);
      }
      unint64_t v7 = (llvm::APFloatBase *)(v12 + 4);
      --v11;
    }
    while (v11);
  }
  unint64_t v13 = *(char **)a1;
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  if (v14)
  {
    int v15 = llvm::APFloatBase::PPCDoubleDouble(v7);
    uint64_t v16 = v13 - 24;
    uint64_t v17 = 32 * v14;
    do
    {
      while (1)
      {
        __int16 v18 = (llvm::detail::DoubleAPFloat *)&v16[v17];
        if (v15 != *(void **)&v16[v17]) {
          break;
        }
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
        v17 -= 32;
        if (!v17) {
          goto LABEL_12;
        }
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v18);
      v17 -= 32;
    }
    while (v17);
LABEL_12:
    unint64_t v13 = *(char **)a1;
  }
  int v19 = v20;
  if (v13 != v6) {
    free(v13);
  }
  *(void *)a1 = v8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v19;
}

llvm::APFloatBase *llvm::APFloat::Storage::operator=(llvm::APFloatBase *a1, uint64_t *a2)
{
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  uint64_t v6 = *a2;
  if (v5 != v4 && v5 != (void *)v6)
  {
    llvm::detail::IEEEFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  char v8 = v5;
  if (v5 != v4)
  {
    if (a1 == (llvm::APFloatBase *)a2) {
      return a1;
    }
    llvm::detail::IEEEFloat::~IEEEFloat(a1);
    goto LABEL_12;
  }
  if (v4 == (void *)v6)
  {
    llvm::detail::DoubleAPFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  if (a1 != (llvm::APFloatBase *)a2)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(a1);
LABEL_12:
    if (v8 == (void *)*a2) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(a1, (const llvm::detail::DoubleAPFloat *)a2);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat(a1, (const llvm::detail::IEEEFloat *)a2);
    }
  }
  return a1;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v112[2] = *MEMORY[0x263EF8340];
  uint64_t v93 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v112[0] = *(void *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    uint64_t v96 = "failed to convert operand axes";
    v98[8] = 259;
    uint64_t v109 = &v96;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
    }
    return 0;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    uint64_t v57 = v93;
    uint64_t v96 = &v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
    return 0;
    }
  }
  uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v109 = (void **)v111;
  uint64_t v110 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  uint64_t v106 = v108;
  memset(v108, 0, sizeof(v108));
  uint64_t v107 = 0x600000006;
  uint64_t v103 = v105;
  memset_pattern16(v105, &unk_211ED5510, 0x18uLL);
  uint64_t v104 = 0x600000003;
  uint64_t v100 = v102;
  memset_pattern16(v102, &unk_211ED5510, 0x18uLL);
  uint64_t v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v92);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    uint64_t v89 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v110)
  {
    unint64_t v35 = IndexFromDim;
    uint64_t v36 = (uint64_t *)v109;
    uint64_t v37 = 8 * v110;
    while (1)
    {
      uint64_t v38 = *v36;
      v94[0] = v38;
      if (v38 == v35) {
        break;
      }
      if (v38 <= 1)
      {
        unint64_t v61 = v93;
        uint64_t v96 = &v93;
        uint64_t v55 = *(void *)(a4 + 16);
        if (!v55) {
          goto LABEL_89;
        }
        if (mlir::RewriterBase::Listener::classof(v55))
        {
          uint64_t v59 = *((void *)v61 + 3);
          goto LABEL_54;
        }
        goto LABEL_56;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v92);
      *((void *)v100 + v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    unint64_t v58 = v93;
    uint64_t v96 = v94;
    uint64_t v97 = (uint64_t)&v93;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      goto LABEL_89;
    }
    if (mlir::RewriterBase::Listener::classof(v55))
    {
      uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v96);
      goto LABEL_89;
    }
LABEL_56:
    uint64_t v55 = 0;
  }
  else
  {
LABEL_29:
    uint64_t v96 = v98;
    uint64_t v97 = 0x400000000;
    uint64_t v99 = 4;
    v94[0] = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
    v94[0] = 6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
    v94[0] = "ksize";
    __int16 v95 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          uint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
    v94[0] = "stride";
    __int16 v95 = 259;
    uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v41)
    {
      uint64_t v64 = v43;
      uint64_t v65 = *v41;
      unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v67 = *(unsigned int *)(v65 + 16);
      if (v67)
      {
        unint64_t v68 = *(void **)(v65 + 8);
        uint64_t v69 = &v68[2 * v67];
        do
        {
          unint64_t v70 = v67 >> 1;
          uint64_t v71 = &v68[2 * (v67 >> 1)];
          unint64_t v73 = *v71;
          unint64_t v72 = v71 + 2;
          v67 += ~(v67 >> 1);
          if (v73 < v66) {
            unint64_t v68 = v72;
          }
          else {
            unint64_t v67 = v70;
          }
        }
        while (v67);
        unint64_t v43 = v64;
        if (v68 == v69)
        {
          uint64_t v74 = 0;
        }
        else if (*v68 == v66)
        {
          uint64_t v74 = v68[1];
        }
        else
        {
          uint64_t v74 = 0;
        }
      }
      else
      {
        uint64_t v74 = 0;
        unint64_t v43 = v64;
      }
    }
    else
    {
      uint64_t v74 = 0;
    }
    uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
    v94[0] = "padding";
    __int16 v95 = 259;
    uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
    if (v43
      && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
    {
      unint64_t v80 = *(void **)(v77 + 8);
      int64x2_t v81 = &v80[2 * v79];
      do
      {
        unint64_t v82 = v79 >> 1;
        uint64_t v83 = &v80[2 * (v79 >> 1)];
        unint64_t v85 = *v83;
        unint64_t v84 = v83 + 2;
        v79 += ~(v79 >> 1);
        if (v85 < v78) {
          unint64_t v80 = v84;
        }
        else {
          unint64_t v79 = v82;
        }
      }
      while (v79);
      if (v80 != v81 && *v80 == v78) {
        uint64_t v86 = v80[1];
      }
      else {
        uint64_t v86 = 0;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
    v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
    uint64_t v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
    if (v96 != v98) {
      free(v96);
    }
    uint64_t v55 = 1;
  }
LABEL_89:
  if (v100 != v102) {
    free(v100);
  }
  if (v103 != v105) {
    free(v103);
  }
  if (v106 != v108) {
    free(v106);
  }
  if (v109 != (void **)v111) {
    free(v109);
  }
  return v55;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v114[2] = *MEMORY[0x263EF8340];
  __int16 v95 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 56);
  v114[0] = *(void *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    uint64_t v98 = "failed to convert operand axes";
    v100[8] = 259;
    unint64_t v111 = &v98;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    uint64_t v57 = v95;
    uint64_t v98 = &v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      return v55;
    }
    if (mlir::RewriterBase::Listener::classof(v55)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  unint64_t v111 = (void **)v113;
  uint64_t v112 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  uint64_t v108 = v110;
  memset(v110, 0, sizeof(v110));
  uint64_t v109 = 0x600000006;
  uint64_t v105 = v107;
  memset_pattern16(v107, &unk_211ED5510, 0x18uLL);
  uint64_t v106 = 0x600000003;
  unint64_t v102 = v104;
  memset_pattern16(v104, &unk_211ED5510, 0x18uLL);
  uint64_t v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v94);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    uint64_t v91 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v112)
  {
    unint64_t v35 = IndexFromDim;
    uint64_t v36 = (uint64_t *)v111;
    uint64_t v37 = 8 * v112;
    while (1)
    {
      uint64_t v38 = *v36;
      v96[0] = v38;
      if (v38 == v35) {
        break;
      }
      if (v38 <= 1)
      {
        unint64_t v61 = v95;
        uint64_t v98 = &v95;
        uint64_t v55 = *(void *)(a4 + 16);
        if (!v55) {
          goto LABEL_89;
        }
        if (mlir::RewriterBase::Listener::classof(v55))
        {
          uint64_t v59 = *((void *)v61 + 3);
          goto LABEL_54;
        }
        goto LABEL_56;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v94);
      *((void *)v102 + v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    unint64_t v58 = v95;
    uint64_t v98 = v96;
    uint64_t v99 = (uint64_t)&v95;
    uint64_t v55 = *(void *)(a4 + 16);
    if (!v55) {
      goto LABEL_89;
    }
    if (mlir::RewriterBase::Listener::classof(v55))
    {
      uint64_t v59 = *((void *)v58 + 3);
LABEL_54:
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v55 + 64))(v55, v59, v60, &v98);
      goto LABEL_89;
    }
LABEL_56:
    uint64_t v55 = 0;
  }
  else
  {
LABEL_29:
    uint64_t v98 = v100;
    uint64_t v99 = 0x400000000;
    uint64_t v101 = 4;
    v96[0] = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
    v96[0] = 6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
    v96[0] = "ksize";
    __int16 v97 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          uint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
    v96[0] = "stride";
    __int16 v97 = 259;
    uint64_t v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v41)
    {
      uint64_t v64 = v43;
      uint64_t v65 = *v41;
      unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v67 = *(unsigned int *)(v65 + 16);
      if (v67)
      {
        unint64_t v68 = *(void **)(v65 + 8);
        uint64_t v69 = &v68[2 * v67];
        do
        {
          unint64_t v70 = v67 >> 1;
          uint64_t v71 = &v68[2 * (v67 >> 1)];
          unint64_t v73 = *v71;
          unint64_t v72 = v71 + 2;
          v67 += ~(v67 >> 1);
          if (v73 < v66) {
            unint64_t v68 = v72;
          }
          else {
            unint64_t v67 = v70;
          }
        }
        while (v67);
        unint64_t v43 = v64;
        if (v68 == v69)
        {
          uint64_t v74 = 0;
        }
        else if (*v68 == v66)
        {
          uint64_t v74 = v68[1];
        }
        else
        {
          uint64_t v74 = 0;
        }
      }
      else
      {
        uint64_t v74 = 0;
        unint64_t v43 = v64;
      }
    }
    else
    {
      uint64_t v74 = 0;
    }
    uint64_t v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
    v96[0] = "padding";
    __int16 v97 = 259;
    uint64_t v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
    if (v43
      && (uint64_t v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), v79))
    {
      unint64_t v80 = *(void **)(v77 + 8);
      int64x2_t v81 = &v80[2 * v79];
      do
      {
        unint64_t v82 = v79 >> 1;
        uint64_t v83 = &v80[2 * (v79 >> 1)];
        unint64_t v85 = *v83;
        unint64_t v84 = v83 + 2;
        v79 += ~(v79 >> 1);
        if (v85 < v78) {
          unint64_t v80 = v84;
        }
        else {
          unint64_t v79 = v82;
        }
      }
      while (v79);
      if (v80 != v81 && *v80 == v78) {
        uint64_t v86 = v80[1];
      }
      else {
        uint64_t v86 = 0;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    uint64_t v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
    v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
    mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
    uint64_t v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((void *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
    if (v98 != v100) {
      free(v98);
    }
    uint64_t v55 = 1;
  }
LABEL_89:
  if (v102 != v104) {
    free(v102);
  }
  if (v105 != v107) {
    free(v105);
  }
  if (v108 != v110) {
    free(v108);
  }
  if (v111 != (void **)v113) {
    free(v111);
  }
  return v55;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v140[2] = *MEMORY[0x263EF8340];
  unint64_t v119 = (unsigned int *)a2;
  unint64_t v6 = *(void *)(a3 + 64);
  v140[0] = *(void *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    unint64_t v124 = "failed to convert operand axes";
    v126[8] = 259;
    uint64_t v137 = &v124;
    uint64_t v55 = *(void *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void ***))(*(void *)v55 + 64))(v55, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    }
    return 0;
  }
  uint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    uint64_t v57 = v119;
    unint64_t v124 = &v119;
    uint64_t v58 = *(void *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  uint64_t v137 = (void **)v139;
  uint64_t v138 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  unint64_t v134 = v136;
  memset(v136, 0, sizeof(v136));
  uint64_t v135 = 0x600000006;
  long long v131 = v133;
  memset_pattern16(v133, &unk_211ED5510, 0x18uLL);
  uint64_t v132 = 0x600000003;
  uint64_t v128 = v130;
  memset_pattern16(v130, &unk_211ED5510, 0x18uLL);
  uint64_t v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v117);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    char v114 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v138)
  {
    unint64_t v35 = (uint64_t *)IndexFromDim;
    uint64_t v36 = (uint64_t **)v137;
    uint64_t v37 = 8 * v138;
    while (1)
    {
      uint64_t v38 = *v36;
      v122[0] = v38;
      if (v38 == v35) {
        break;
      }
      if ((uint64_t)v38 <= 1)
      {
        uint64_t v64 = v119;
        unint64_t v124 = &v119;
        uint64_t v61 = *(void *)(a4 + 16);
        if (v61 && mlir::RewriterBase::Listener::classof(v61))
        {
          uint64_t v62 = *((void *)v64 + 3);
          goto LABEL_54;
        }
        goto LABEL_55;
      }
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v117);
      *((void *)v128 + (void)v38 - 2) = *(void *)(Shape + 8 * v38);
      ++v36;
      v37 -= 8;
      if (!v37) {
        goto LABEL_29;
      }
    }
    uint64_t v60 = v119;
    unint64_t v124 = v122;
    uint64_t v125 = (uint64_t)&v119;
    uint64_t v61 = *(void *)(a4 + 16);
    if (v61 && mlir::RewriterBase::Listener::classof(v61))
    {
      uint64_t v62 = *((void *)v60 + 3);
LABEL_54:
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(void *)v61 + 64))(v61, v62, v63, &v124);
      goto LABEL_96;
    }
LABEL_55:
    uint64_t v59 = 0;
  }
  else
  {
LABEL_29:
    unint64_t v124 = v126;
    uint64_t v125 = 0x400000000;
    uint64_t v127 = 4;
    v122[0] = (uint64_t *)3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
    v122[0] = (uint64_t *)6;
    uint64_t v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    unint64_t v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
    v122[0] = (uint64_t *)"ksize";
    __int16 v123 = 259;
    uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (v41)
    {
      uint64_t v45 = *v41;
      unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v47 = *(unsigned int *)(v45 + 16);
      if (v47)
      {
        uint64_t v48 = *(void **)(v45 + 8);
        uint64_t v49 = &v48[2 * v47];
        do
        {
          unint64_t v50 = v47 >> 1;
          uint64_t v51 = &v48[2 * (v47 >> 1)];
          unint64_t v53 = *v51;
          unint64_t v52 = v51 + 2;
          v47 += ~(v47 >> 1);
          if (v53 < v46) {
            uint64_t v48 = v52;
          }
          else {
            unint64_t v47 = v50;
          }
        }
        while (v47);
        if (v48 == v49)
        {
          uint64_t v54 = 0;
        }
        else if (*v48 == v46)
        {
          uint64_t v54 = v48[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
      }
    }
    else
    {
      uint64_t v54 = 0;
    }
    uint64_t v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
    v122[0] = (uint64_t *)"stride";
    __int16 v123 = 259;
    uint64_t v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (!v41) {
      goto LABEL_70;
    }
    uint64_t v67 = *v41;
    unint64_t v68 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v69 = *(unsigned int *)(v67 + 16);
    if (!v69) {
      goto LABEL_70;
    }
    unint64_t v70 = *(void **)(v67 + 8);
    uint64_t v71 = &v70[2 * v69];
    do
    {
      unint64_t v72 = v69 >> 1;
      unint64_t v73 = &v70[2 * (v69 >> 1)];
      unint64_t v75 = *v73;
      uint64_t v74 = v73 + 2;
      v69 += ~(v69 >> 1);
      if (v75 < v68) {
        unint64_t v70 = v74;
      }
      else {
        unint64_t v69 = v72;
      }
    }
    while (v69);
    if (v70 != v71 && *v70 == v68) {
      uint64_t v76 = v70[1];
    }
    else {
LABEL_70:
    }
      uint64_t v76 = 0;
    uint64_t v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
    v122[0] = (uint64_t *)"padding";
    __int16 v123 = 259;
    uint64_t v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
    if (!v43) {
      goto LABEL_80;
    }
    uint64_t v79 = *v43;
    unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v81 = *(unsigned int *)(v79 + 16);
    if (!v81) {
      goto LABEL_80;
    }
    unint64_t v82 = *(void **)(v79 + 8);
    uint64_t v83 = &v82[2 * v81];
    do
    {
      unint64_t v84 = v81 >> 1;
      unint64_t v85 = &v82[2 * (v81 >> 1)];
      unint64_t v87 = *v85;
      uint64_t v86 = v85 + 2;
      v81 += ~(v81 >> 1);
      if (v87 < v80) {
        unint64_t v82 = v86;
      }
      else {
        unint64_t v81 = v84;
      }
    }
    while (v81);
    if (v82 != v83 && *v82 == v80) {
      uint64_t v88 = v82[1];
    }
    else {
LABEL_80:
    }
      uint64_t v88 = 0;
    uint64_t v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
    mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
    uint64_t v90 = mlir::ValueRange::dereference_iterator(v140, 0);
    v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
    if (mlir::Type::isF16((mlir::Type *)v122)
      || (uint64_t GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
          mlir::Type::isF32((mlir::Type *)&GOC)))
    {
      uint64_t GOC = 1;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
      uint64_t v93 = (uint64_t)v92;
      if (!v92) {
        goto LABEL_92;
      }
      uint64_t v94 = *v92;
      unint64_t v95 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v96 = *(unsigned int *)(v94 + 16);
      if (!v96) {
        goto LABEL_92;
      }
      __int16 v97 = *(void **)(v94 + 8);
      uint64_t v98 = &v97[2 * v96];
      do
      {
        unint64_t v99 = v96 >> 1;
        uint64_t v100 = &v97[2 * (v96 >> 1)];
        unint64_t v102 = *v100;
        uint64_t v101 = v100 + 2;
        v96 += ~(v96 >> 1);
        if (v102 < v95) {
          __int16 v97 = v101;
        }
        else {
          unint64_t v96 = v99;
        }
      }
      while (v96);
      if (v97 != v98 && *v97 == v95) {
        uint64_t v103 = v97[1];
      }
      else {
LABEL_92:
      }
        uint64_t v103 = 0;
      uint64_t v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
      uint64_t v59 = 1;
      v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
      uint64_t v105 = *((void *)v119 + 3);
      uint64_t v120 = 1;
      uint64_t v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      uint64_t GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
      uint64_t v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
      uint64_t v108 = *((void *)v119 + 3);
      uint64_t v116 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&GOC);
      uint64_t v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
      uint64_t v109 = (mlir::MLIRContext *)*((void *)v119 + 3);
      uint64_t v110 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v120);
      mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
    }
    else
    {
      uint64_t v112 = v119;
      v122[0] = v118;
      uint64_t v113 = *(void *)(a4 + 16);
      if (v113)
      {
        if (mlir::RewriterBase::Listener::classof(v113)) {
        else
        }
          uint64_t v59 = 0;
      }
      else
      {
        uint64_t v59 = 0;
      }
    }
    if (v124 != v126) {
      free(v124);
    }
  }
LABEL_96:
  if (v128 != v130) {
    free(v128);
  }
  if (v131 != v133) {
    free(v131);
  }
  if (v134 != v136) {
    free(v134);
  }
  if (v137 != (void **)v139) {
    free(v137);
  }
  return v59;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  uint64_t v4 = v3 + 16;
  unint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = **a1;
  int v15 = 2;
  uint64_t v16 = v6;
  uint64_t v7 = *(unsigned int *)(v3 + 24);
  char v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v7 + 1;
    BOOL v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      uint64_t v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      unint64_t v5 = *(void *)(v3 + 16);
      char v8 = &v15;
    }
  }
  uint64_t v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v8;
  *(void *)(v9 + 16) = *((void *)v8 + 2);
  *(_OWORD *)uint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  uint64_t v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  mlir::Diagnostic::operator<<(v11, (mlir::Block **)*a1[1]);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  unint64_t v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  uint64_t v6 = v3 + 16;
  unint64_t v7 = *(void *)(v3 + 16);
  uint64_t v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    unint64_t v12 = v8 + 1;
    BOOL v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      uint64_t v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      unint64_t v7 = *(void *)(v3 + 16);
      unint64_t v5 = v15;
    }
  }
  unint64_t v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  long long v10 = *(_OWORD *)v5;
  *(void *)(v9 + 16) = *((void *)v5 + 2);
  *(_OWORD *)unint64_t v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

void *mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  unint64_t v69 = a2;
  unint64_t v6 = *(void *)(a3 + 56);
  uint64_t v91 = *(void *)(a3 + 48);
  unint64_t v92 = v6;
  if (!v8)
  {
    unint64_t v72 = "failed to convert operand axes";
    v74[8] = 259;
    unint64_t v75 = &v72;
    uint64_t v42 = *(void *)(a4 + 16);
    if (!v42) {
      return v42;
    }
    if (mlir::RewriterBase::Listener::classof(v42)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v42 + 64))(v42, *((void *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v75);
    }
    return 0;
  }
  unint64_t v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v69))
  {
    unint64_t v44 = v69;
    unint64_t v72 = &v69;
    uint64_t v42 = *(void *)(a4 + 16);
    if (!v42) {
      return v42;
    }
    if (mlir::RewriterBase::Listener::classof(v42)) {
    return 0;
    }
  }
  long long v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  int v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  uint64_t v88 = v90;
  uint64_t v89 = 0x600000000;
  if (!v9) {
    goto LABEL_22;
  }
  uint64_t v21 = *v9;
  unint64_t v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_22;
  }
  unsigned __int8 v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    long long v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unsigned __int8 v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_22:
  }
    uint64_t v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v88, 1);
  unint64_t v85 = v87;
  memset(v87, 0, sizeof(v87));
  uint64_t v86 = 0x600000006;
  unint64_t v82 = v84;
  memset_pattern16(v84, &unk_211ED5510, 0x18uLL);
  uint64_t v83 = 0x600000003;
  uint64_t v79 = v81;
  memset_pattern16(v81, &unk_211ED5510, 0x18uLL);
  uint64_t v80 = 0x600000003;
  v68[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v68[1] = v31;
  mlir::ShapedType::getShape((mlir::ShapedType *)v68);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (!v34)
  {
    uint64_t v64 = (mlir::Block ****)std::__throw_bad_optional_access[abi:nn180100]();
  }
  if (v89 == 1 && *v88 == IndexFromDim)
  {
    uint64_t v66 = *((void *)v69 + 3);
    uint64_t v35 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v68) + 8 * IndexFromDim);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68);
    unint64_t v75 = v77;
    v77[0] = 1;
    v77[1] = v35;
    int64x2_t v78 = vdupq_n_s64(1uLL);
    uint64_t v76 = 0x1000000004;
    uint64_t v67 = mlir::MemRefType::get(v77, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
    Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v67);
    uint64_t NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
    unint64_t v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
    unint64_t v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
    if (v41 != v40)
    {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v71, (uint64_t)v40, (llvm::APInt *)1);
      unint64_t v72 = v74;
      uint64_t v73 = 0x1000000000;
      llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v72, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
      if (v41 == (llvm::APFloatBase *)v71[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v71);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v71);
      }
      unint64_t v47 = v75;
      uint64_t v48 = v76;
      uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
      unint64_t v50 = (void *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
      ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v72, v73);
      v71[0] = v51;
      mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v66, &v67, (void **)&ElementsAttr);
      unint64_t v52 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v52) {
        goto LABEL_53;
      }
      uint64_t v53 = *v52;
      unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v55 = *(unsigned int *)(v53 + 16);
      if (!v55) {
        goto LABEL_53;
      }
      uint64_t v56 = *(void **)(v53 + 8);
      uint64_t v57 = &v56[2 * v55];
      do
      {
        unint64_t v58 = v55 >> 1;
        uint64_t v59 = &v56[2 * (v55 >> 1)];
        unint64_t v61 = *v59;
        uint64_t v60 = v59 + 2;
        v55 += ~(v55 >> 1);
        if (v61 < v54) {
          uint64_t v56 = v60;
        }
        else {
          unint64_t v55 = v58;
        }
      }
      while (v55);
      if (v56 != v57 && *v56 == v54) {
        uint64_t v62 = v56[1];
      }
      else {
LABEL_53:
      }
        uint64_t v62 = 0;
    }
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v71, (uint64_t)v40);
  }
  uint64_t v45 = v69;
  unint64_t v72 = &v69;
  uint64_t v42 = *(void *)(a4 + 16);
  if (v42)
  {
    if (mlir::RewriterBase::Listener::classof(v42)) {
    else
    }
      uint64_t v42 = 0;
  }
  if (v79 != v81) {
    free(v79);
  }
  if (v82 != v84) {
    free(v82);
  }
  if (v85 != v87) {
    free(v85);
  }
  if (v88 != (void *)v90) {
    free(v88);
  }
  return v42;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v149 = *MEMORY[0x263EF8340];
  uint64_t v138 = a2;
  long long v144 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v136 = v5;
  uint64_t v137 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  *(void *)&long long v146 = v16;
  *((void *)&v146 + 1) = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v146);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  *(void *)&long long v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((void *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v135);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v128 = (unsigned int *)v138;
    *(void *)&long long v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    uint64_t v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(void *)&long long v148 = v138;
  long long v146 = v144;
  unint64_t v50 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50) {
    goto LABEL_42;
  }
  uint64_t v51 = *v50;
  unint64_t v52 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v53 = *(unsigned int *)(v51 + 16);
  if (!v53) {
    goto LABEL_42;
  }
  unint64_t v54 = *(void **)(v51 + 8);
  unint64_t v55 = &v54[2 * v53];
  do
  {
    unint64_t v56 = v53 >> 1;
    uint64_t v57 = &v54[2 * (v53 >> 1)];
    unint64_t v59 = *v57;
    unint64_t v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52) {
      unint64_t v54 = v58;
    }
    else {
      unint64_t v53 = v56;
    }
  }
  while (v53);
  if (v54 != v55 && *v54 == v52) {
    uint64_t v60 = v54[1];
  }
  else {
LABEL_42:
  }
    uint64_t v60 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  uint64_t v63 = v62;
  uint64_t v64 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64) {
    goto LABEL_52;
  }
  uint64_t v65 = *v64;
  unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v67 = *(unsigned int *)(v65 + 16);
  if (!v67) {
    goto LABEL_52;
  }
  unint64_t v68 = *(void **)(v65 + 8);
  unint64_t v69 = &v68[2 * v67];
  do
  {
    unint64_t v70 = v67 >> 1;
    uint64_t v71 = &v68[2 * (v67 >> 1)];
    unint64_t v73 = *v71;
    unint64_t v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66) {
      unint64_t v68 = v72;
    }
    else {
      unint64_t v67 = v70;
    }
  }
  while (v67);
  if (v68 != v69 && *v68 == v66) {
    uint64_t v74 = v68[1];
  }
  else {
LABEL_52:
  }
    uint64_t v74 = 0;
  uint64_t v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    uint64_t v77 = *(void *)(v148 + 24);
    uint64_t v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1uLL);
    *(void *)&long long v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  uint64_t v80 = *(void *)(a4 + 16);
  if (v80)
  {
    uint64_t v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v142 = v138;
  long long v148 = v144;
  long long v141 = v135;
  unint64_t v82 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82) {
    goto LABEL_67;
  }
  uint64_t v83 = *v82;
  unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v85 = *(unsigned int *)(v83 + 16);
  if (!v85) {
    goto LABEL_67;
  }
  uint64_t v86 = *(void **)(v83 + 8);
  unint64_t v87 = &v86[2 * v85];
  do
  {
    unint64_t v88 = v85 >> 1;
    uint64_t v89 = &v86[2 * (v85 >> 1)];
    unint64_t v91 = *v89;
    uint64_t v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84) {
      uint64_t v86 = v90;
    }
    else {
      unint64_t v85 = v88;
    }
  }
  while (v85);
  if (v86 != v87 && *v86 == v84) {
    uint64_t v92 = v86[1];
  }
  else {
LABEL_67:
  }
    uint64_t v92 = 0;
  uint64_t v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  uint64_t v95 = v94;
  unint64_t v96 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96) {
    goto LABEL_77;
  }
  uint64_t v97 = *v96;
  unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v99 = *(unsigned int *)(v97 + 16);
  if (!v99) {
    goto LABEL_77;
  }
  uint64_t v100 = *(void **)(v97 + 8);
  uint64_t v101 = &v100[2 * v99];
  do
  {
    unint64_t v102 = v99 >> 1;
    uint64_t v103 = &v100[2 * (v99 >> 1)];
    unint64_t v105 = *v103;
    uint64_t v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98) {
      uint64_t v100 = v104;
    }
    else {
      unint64_t v99 = v102;
    }
  }
  while (v99);
  if (v100 != v101 && *v100 == v98) {
    uint64_t v106 = v100[1];
  }
  else {
LABEL_77:
  }
    uint64_t v106 = 0;
  uint64_t v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    uint64_t v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1uLL);
    uint64_t v110 = mlir::ShapedType::getShape((mlir::ShapedType *)&v141);
    uint64_t v112 = v110 + 8 * v111;
    *(void *)&long long v146 = v147;
    v147[0] = *(void *)(v112 - 24);
    v147[1] = *(void *)(v112 - 16);
    v147[2] = *(void *)(v112 - 8);
    *((void *)&v146 + 1) = 0x300000003;
    uint64_t v145 = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    char v114 = (void *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    uint64_t v115 = v114;
    if (!v114) {
      goto LABEL_88;
    }
    uint64_t v116 = *v114;
    unint64_t v117 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v118 = *(unsigned int *)(v116 + 16);
    if (!v118) {
      goto LABEL_88;
    }
    unint64_t v119 = *(void **)(v116 + 8);
    uint64_t v120 = &v119[2 * v118];
    do
    {
      unint64_t v121 = v118 >> 1;
      unint64_t v122 = &v119[2 * (v118 >> 1)];
      unint64_t v124 = *v122;
      __int16 v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117) {
        unint64_t v119 = v123;
      }
      else {
        unint64_t v118 = v121;
      }
    }
    while (v118);
    if (v119 != v120 && *v119 == v117) {
      uint64_t v125 = v119[1];
    }
    else {
LABEL_88:
    }
      uint64_t v125 = 0;
    uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    uint64_t v126 = v142;
    uint64_t v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    uint64_t v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v126, v127);
    if ((void *)v146 != v147) {
      free((void *)v146);
    }
    return 1;
  }
  uint64_t v129 = *(void *)(a4 + 16);
  if (v129)
  {
    uint64_t v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v131 = *(void *)(a4 + 16);
  if (v131 && (uint64_t v132 = v138, mlir::RewriterBase::Listener::classof(v131))) {
  else
  }
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.flatten", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.flatten";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Flatten::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Flatten,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.unflatten", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.unflatten";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Unflatten::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Unflatten,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v149 = *MEMORY[0x263EF8340];
  uint64_t v138 = a2;
  long long v144 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v136 = v5;
  uint64_t v137 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  *(void *)&long long v146 = v16;
  *((void *)&v146 + 1) = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v146);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  *(void *)&long long v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((void *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v135);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v128 = (unsigned int *)v138;
    *(void *)&long long v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    uint64_t v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(void *)&long long v148 = v138;
  long long v146 = v144;
  unint64_t v50 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50) {
    goto LABEL_42;
  }
  uint64_t v51 = *v50;
  unint64_t v52 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v53 = *(unsigned int *)(v51 + 16);
  if (!v53) {
    goto LABEL_42;
  }
  unint64_t v54 = *(void **)(v51 + 8);
  unint64_t v55 = &v54[2 * v53];
  do
  {
    unint64_t v56 = v53 >> 1;
    uint64_t v57 = &v54[2 * (v53 >> 1)];
    unint64_t v59 = *v57;
    unint64_t v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52) {
      unint64_t v54 = v58;
    }
    else {
      unint64_t v53 = v56;
    }
  }
  while (v53);
  if (v54 != v55 && *v54 == v52) {
    uint64_t v60 = v54[1];
  }
  else {
LABEL_42:
  }
    uint64_t v60 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  uint64_t v63 = v62;
  uint64_t v64 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64) {
    goto LABEL_52;
  }
  uint64_t v65 = *v64;
  unint64_t v66 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v67 = *(unsigned int *)(v65 + 16);
  if (!v67) {
    goto LABEL_52;
  }
  unint64_t v68 = *(void **)(v65 + 8);
  unint64_t v69 = &v68[2 * v67];
  do
  {
    unint64_t v70 = v67 >> 1;
    uint64_t v71 = &v68[2 * (v67 >> 1)];
    unint64_t v73 = *v71;
    unint64_t v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66) {
      unint64_t v68 = v72;
    }
    else {
      unint64_t v67 = v70;
    }
  }
  while (v67);
  if (v68 != v69 && *v68 == v66) {
    uint64_t v74 = v68[1];
  }
  else {
LABEL_52:
  }
    uint64_t v74 = 0;
  uint64_t v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    uint64_t v77 = *(void *)(v148 + 24);
    uint64_t v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1uLL);
    *(void *)&long long v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  uint64_t v80 = *(void *)(a4 + 16);
  if (v80)
  {
    uint64_t v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v142 = v138;
  long long v148 = v144;
  long long v141 = v135;
  unint64_t v82 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82) {
    goto LABEL_67;
  }
  uint64_t v83 = *v82;
  unint64_t v84 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v85 = *(unsigned int *)(v83 + 16);
  if (!v85) {
    goto LABEL_67;
  }
  uint64_t v86 = *(void **)(v83 + 8);
  unint64_t v87 = &v86[2 * v85];
  do
  {
    unint64_t v88 = v85 >> 1;
    uint64_t v89 = &v86[2 * (v85 >> 1)];
    unint64_t v91 = *v89;
    uint64_t v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84) {
      uint64_t v86 = v90;
    }
    else {
      unint64_t v85 = v88;
    }
  }
  while (v85);
  if (v86 != v87 && *v86 == v84) {
    uint64_t v92 = v86[1];
  }
  else {
LABEL_67:
  }
    uint64_t v92 = 0;
  uint64_t v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  uint64_t v95 = v94;
  unint64_t v96 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96) {
    goto LABEL_77;
  }
  uint64_t v97 = *v96;
  unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v99 = *(unsigned int *)(v97 + 16);
  if (!v99) {
    goto LABEL_77;
  }
  uint64_t v100 = *(void **)(v97 + 8);
  uint64_t v101 = &v100[2 * v99];
  do
  {
    unint64_t v102 = v99 >> 1;
    uint64_t v103 = &v100[2 * (v99 >> 1)];
    unint64_t v105 = *v103;
    uint64_t v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98) {
      uint64_t v100 = v104;
    }
    else {
      unint64_t v99 = v102;
    }
  }
  while (v99);
  if (v100 != v101 && *v100 == v98) {
    uint64_t v106 = v100[1];
  }
  else {
LABEL_77:
  }
    uint64_t v106 = 0;
  uint64_t v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    uint64_t v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    uint64_t v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1uLL);
    uint64_t v110 = mlir::ShapedType::getShape((mlir::ShapedType *)&v141);
    uint64_t v112 = v110 + 8 * v111;
    *(void *)&long long v146 = v147;
    v147[0] = *(void *)(v112 - 24);
    v147[1] = *(void *)(v112 - 16);
    v147[2] = *(void *)(v112 - 8);
    *((void *)&v146 + 1) = 0x300000003;
    uint64_t v145 = 3;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    char v114 = (void *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    uint64_t v115 = v114;
    if (!v114) {
      goto LABEL_88;
    }
    uint64_t v116 = *v114;
    unint64_t v117 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v118 = *(unsigned int *)(v116 + 16);
    if (!v118) {
      goto LABEL_88;
    }
    unint64_t v119 = *(void **)(v116 + 8);
    uint64_t v120 = &v119[2 * v118];
    do
    {
      unint64_t v121 = v118 >> 1;
      unint64_t v122 = &v119[2 * (v118 >> 1)];
      unint64_t v124 = *v122;
      __int16 v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117) {
        unint64_t v119 = v123;
      }
      else {
        unint64_t v118 = v121;
      }
    }
    while (v118);
    if (v119 != v120 && *v119 == v117) {
      uint64_t v125 = v119[1];
    }
    else {
LABEL_88:
    }
      uint64_t v125 = 0;
    uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    uint64_t v126 = v142;
    uint64_t v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    uint64_t v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v126, v127);
    if ((void *)v146 != v147) {
      free((void *)v146);
    }
    return 1;
  }
  uint64_t v129 = *(void *)(a4 + 16);
  if (v129)
  {
    uint64_t v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  uint64_t v131 = *(void *)(a4 + 16);
  if (v131 && (uint64_t v132 = v138, mlir::RewriterBase::Listener::classof(v131))) {
  else
  }
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 48);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    char v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      __int16 v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v60 = a2;
  long long v63 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  unint64_t v58 = v5;
  uint64_t v59 = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = (uint64_t)v16;
  uint64_t v57 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  uint64_t v45 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  uint64_t v47 = v46;
  uint64_t v48 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    uint64_t v53 = v60;
    uint64_t v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    uint64_t v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    uint64_t v50 = *(void *)(a4 + 16);
    if (v50 && (uint64_t v51 = v60, mlir::RewriterBase::Listener::classof(v50))) {
    else
    }
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void *mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = a2;
  long long v52 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  uint64_t v16 = (void *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unsigned __int8 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  uint64_t RankPromotionTypeForANE = v16;
  uint64_t v49 = v26;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  long long v29 = v28;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  uint64_t v31 = (uint64_t *)mlir::MemRefType::get(Shape, v29, OperandRange, 0, 0, 0);
  uint64_t v32 = (uint64_t)v31;
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_30;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_30:
  }
    uint64_t v42 = 0;
  uint64_t RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v32, v42);
  uint64_t v49 = v43;
  uint64_t v44 = v51;
  uint64_t v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  uint64_t v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v44, v45);
  return 1;
}

void mlir::anonymous namespace'::ConvertCast::~ConvertCast(mlir::_anonymous_namespace_::ConvertCast *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertCast::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::mps::detail::CastOpGenericAdaptorBase *this, uint64_t *a4)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v35 = a2;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v9 = *((void *)this + 6);
  *(void *)&long long v36 = v9;
  *((void *)&v36 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v9 = mlir::ValueRange::offset_base(&v36, ODSOperandIndexAndLength);
  }
  long long v36 = v9;
  uint64_t v10 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v36, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_12;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_12:
  }
    uint64_t v20 = 0;
  v34[0] = (uint64_t)v10;
  v34[1] = v20;
  *(void *)&long long v36 = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  if (mlir::Type::isInteger((mlir::Type *)&v36, 1))
  {
    mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)&v36, *(const mlir::TypeConverter **)(a1 + 96));
    uint64_t v21 = *(void *)(a2 + 24);
    unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
    unint64_t v23 = *((void *)this + 6);
    unint64_t v38 = v23;
    uint64_t v39 = v22;
    if (v22) {
      unint64_t v23 = mlir::ValueRange::offset_base(&v38, v22);
    }
    unint64_t v38 = v23;
    uint64_t v39 = 0;
    uint64_t v33 = mlir::ValueRange::dereference_iterator(&v38, 0);
    unint64_t v38 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, v21, &v33);
    uint64_t v24 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v35);
    uint64_t v33 = mlir::TypeConverter::convertType((uint64_t)&v36, (void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = v35;
    uint64_t v26 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>((mlir::OpBuilder *)(a4 + 1), *(void *)(v35 + 24), &v33, &v38);
    (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v25, v26);
    mlir::TypeConverter::~TypeConverter((pthread_rwlock_t **)&v36);
  }
  Resultuint64_t ElementType = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  LOBYTE(v36) = 0;
  char v37 = 0;
  unint64_t v38 = mlir::ShapedType::cloneWith(v34, &v36, ResultElementType);
  uint64_t v39 = v28;
  unsigned int v29 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  unint64_t v30 = *((void *)this + 6);
  *(void *)&long long v36 = v30;
  *((void *)&v36 + 1) = v29;
  if (v29) {
    unint64_t v30 = mlir::ValueRange::offset_base(&v36, v29);
  }
  long long v36 = v30;
  *(void *)&long long v36 = mlir::ValueRange::dereference_iterator(&v36, 0);
  uint64_t v31 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), (uint64_t *)&v38, (uint64_t *)&v36);
  (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v31);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertSoftmax::~ConvertSoftmax(mlir::_anonymous_namespace_::ConvertSoftmax *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v29 = a2;
  long long v30 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v29) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v28[0] = v5;
  v28[1] = v15;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v28) & 1) == 0)
  {
    uint64_t v22 = *(void *)(a4 + 16);
    if (v22)
    {
      uint64_t v23 = v29;
      if (mlir::RewriterBase::Listener::classof(v22)) {
    }
      }
    return 0;
  }
  uint64_t v16 = 1;
  uint64_t v17 = (void *)mlir::ValueRange::dereference_iterator(&v30, 1);
  mlir::ShapedType::getShape((mlir::ShapedType *)v28);
  v27[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  v27[1] = v19;
  if (!(_BYTE)v19) {
    return 0;
  }
  unsigned __int8 v26 = 1;
  uint64_t v20 = v29;
  uint64_t v25 = mlir::ValueRange::dereference_iterator(&v30, 0);
  uint64_t v21 = mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>((mlir::UnitAttr **)(a4 + 8), *(void *)(v20 + 24), &v25, v27, &v26);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v20, v21);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(mlir::mps::SoftmaxOp,mlir::mps::SoftmaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.softmax", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.softmax";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Softmax::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Softmax,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::anonymous namespace'::ConvertConcat::~ConvertConcat(mlir::_anonymous_namespace_::ConvertConcat *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  v40[2] = *MEMORY[0x263EF8340];
  unint64_t v38 = a2;
  uint64_t v5 = *(void *)(a3 + 48);
  uint64_t v6 = *(void *)(a3 + 56);
  v40[0] = v5;
  v40[1] = v6;
  if (v6 == 2)
  {
    v39[0] = mlir::ValueRange::dereference_iterator(v40, 0);
    uint64_t v8 = 1;
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, a2, (uint64_t)v39, 1);
    return v8;
  }
  uint64_t v9 = (uint64_t *)(*(void *)(*(void *)(mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v38) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_12;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_12:
  }
    uint64_t v19 = 0;
  v37[0] = v9;
  v37[1] = v19;
  uint64_t Axis = (void *)mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v38);
  mlir::ShapedType::getShape((mlir::ShapedType *)v37);
  v36[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Axis, v21, 0, 0);
  v36[1] = v22;
  if (!(_BYTE)v22)
  {
    uint64_t v24 = a4[2];
    if (v24)
    {
      uint64_t v25 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        uint64_t v26 = *((void *)v25 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v36) != 1)
  {
    uint64_t v24 = a4[2];
    if (v24)
    {
      long long v28 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        uint64_t v26 = *((void *)v28 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(void *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v39, v36[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v39, (llvm::APInt *)&v34);
  if (v35 > 0x40) {
    uint64_t v23 = *v34;
  }
  else {
    uint64_t v23 = (uint64_t)((void)v34 << -(uint64_t)v35) >> -(uint64_t)v35;
  }
  uint64_t v33 = v23;
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v38);
  long long v29 = v38;
  v39[0] = v5;
  v39[1] = v6 - 1;
  long long v30 = mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 1), *((void *)v38 + 3), v39, (unint64_t *)&v33, (unsigned __int8 *)&InferredResultTypes);
  (*(void (**)(void *, unsigned int *, ZinIrHalH13g *))(*a4 + 32))(a4, v29, v30);
  if (v35 >= 0x41 && v34) {
    MEMORY[0x21667D390](v34, 0x1000C8000313F17);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Concat supports only supports const positive axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Concat supports only 1 axis \n");
}

void mlir::anonymous namespace'::ConvertSplit::~ConvertSplit(mlir::_anonymous_namespace_::ConvertSplit *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unsigned int v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unsigned int v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  uint64_t v84 = a2;
  long long v92 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v84) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v83[0] = v5;
  v83[1] = v15;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v84);
  mlir::ShapedType::getShape((mlir::ShapedType *)v83);
  v82[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  v82[1] = v18;
  if (!(_BYTE)v18)
  {
    uint64_t v21 = *(void *)(a4 + 16);
    if (!v21) {
      return v21;
    }
    uint64_t v22 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v23 = *(void *)(v22 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(void *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v82) != 1)
  {
    uint64_t v21 = *(void *)(a4 + 16);
    if (!v21) {
      return v21;
    }
    uint64_t v25 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v23 = *(void *)(v25 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(void *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  uint64_t v19 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v89, v82[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v19, (llvm::APInt *)&v80);
  if (v81 > 0x40) {
    uint64_t v20 = *v80;
  }
  else {
    uint64_t v20 = (uint64_t)((void)v80 << -(uint64_t)v81) >> -(uint64_t)v81;
  }
  uint64_t v79 = v20;
  uint64_t v26 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v92, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_33;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_33;
  }
  long long v30 = *(void **)(v27 + 8);
  uint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    __int16 v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      long long v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_33:
  }
    uint64_t v36 = 0;
  v78[0] = v26;
  v78[1] = v36;
  uint64_t v37 = *(void *)(mlir::ShapedType::getShape((mlir::ShapedType *)v78) + 8 * v20);
  uint64_t v89 = (int64x2_t *)v91;
  uint64_t v90 = 0x400000000;
  if (mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84))
  {
    uint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84);
    if (mlir::matchConstantWithIntVector<long long>(SplitSizes, (uint64_t)&v89))
    {
      LODWORD(v39) = v90;
LABEL_75:
      FastmathAttr = v88;
      uint64_t v87 = 0x400000000;
      if (v39 >= 5)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v39, 8);
        LODWORD(v39) = v90;
      }
      unint64_t v77 = 0;
      if (v39)
      {
        unint64_t v67 = (unint64_t *)v89;
        uint64_t v68 = 8 * v39;
        do
        {
          unint64_t v76 = *v67;
          uint64_t v69 = *(void *)(v84 + 24);
          uint64_t v75 = mlir::ValueRange::dereference_iterator(&v92, 0);
          unint64_t v70 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a4 + 8), v69, &v75, (unint64_t *)&v79, &v77, &v76);
          uint64_t v71 = v87;
          if (v87 >= (unint64_t)HIDWORD(v87))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v87 + 1, 8);
            uint64_t v71 = v87;
          }
          *((void *)FastmathAttr + v71) = (char *)v70 - 16;
          unsigned int v72 = v87 + 1;
          LODWORD(v87) = v87 + 1;
          v77 += v76;
          ++v67;
          v68 -= 8;
        }
        while (v68);
      }
      else
      {
        unsigned int v72 = v87;
      }
      unint64_t v73 = (unsigned int *)v84;
      mlir::ValueRange::ValueRange(v85, (uint64_t)FastmathAttr, v72);
      mlir::ConversionPatternRewriter::replaceOp(a4, v73, v85[0], v85[1]);
      if (FastmathAttr != v88) {
        free(FastmathAttr);
      }
      uint64_t v21 = 1;
      goto LABEL_87;
    }
    uint64_t v21 = *(void *)(a4 + 16);
    if (v21)
    {
      uint64_t v48 = v84;
      if (mlir::RewriterBase::Listener::classof(v21))
      {
        uint64_t v49 = *(void *)(v48 + 24);
LABEL_52:
        uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v21 + 64))(v21, v49, v50, &FastmathAttr);
        goto LABEL_87;
      }
      goto LABEL_65;
    }
    goto LABEL_87;
  }
  if (mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84))
  {
    FastmathAttr = (void *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84);
    unint64_t UInt = mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&FastmathAttr);
    uint64_t v41 = (v37 + UInt - 1) / UInt;
    unint64_t v39 = v37 / v41;
    if (v37 / v41 > (unint64_t)HIDWORD(v90))
    {
      LODWORD(v90) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v37 / v41, 8);
      uint64_t v42 = (uint64_t *)v89;
      uint64_t v43 = (uint64_t *)v89;
      uint64_t v44 = v37 / v41;
      if (v39 < 4) {
        goto LABEL_95;
      }
      uint64_t v43 = &v89->i64[v39 & 0xFFFFFFFFFFFFFFFCLL];
      uint64_t v44 = (v37 / v41) & 3;
      int64x2_t v45 = vdupq_n_s64(v41);
      uint64_t v46 = v89 + 1;
      unint64_t v47 = v39 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v46[-1] = v45;
        int64x2_t *v46 = v45;
        v46 += 2;
        v47 -= 4;
      }
      while (v47);
      if (v39 != (v39 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_95:
        do
        {
          *v43++ = v41;
          --v44;
        }
        while (v44);
      }
      goto LABEL_71;
    }
    uint64_t v42 = (uint64_t *)v89;
    unint64_t v52 = v90;
    if (v90 >= v39) {
      unint64_t v53 = v37 / v41;
    }
    else {
      unint64_t v53 = v90;
    }
    if (v53)
    {
      unint64_t v54 = (uint64_t *)v89;
      unint64_t v55 = v53;
      if (v53 < 4) {
        goto LABEL_96;
      }
      unint64_t v54 = &v89->i64[v53 & 0xFFFFFFFC];
      unint64_t v55 = v53 & 3;
      int64x2_t v56 = vdupq_n_s64(v41);
      uint64_t v57 = v89 + 1;
      uint64_t v58 = v53 & 0xFFFFFFFC;
      do
      {
        v57[-1] = v56;
        *uint64_t v57 = v56;
        v57 += 2;
        v58 -= 4;
      }
      while (v58);
      if (v53 != (v53 & 0xFFFFFFFC))
      {
LABEL_96:
        do
        {
          *v54++ = v41;
          --v55;
        }
        while (v55);
      }
    }
    unint64_t v59 = v39 - v52;
    if (v39 <= v52) {
      goto LABEL_71;
    }
    uint64_t v60 = (int64x2_t *)&v42[v52];
    if (v59 >= 4)
    {
      uint64_t v61 = &v60->i64[v59 & 0xFFFFFFFFFFFFFFFCLL];
      unint64_t v62 = v59 & 3;
      int64x2_t v63 = vdupq_n_s64(v41);
      uint64_t v64 = v60 + 1;
      unint64_t v65 = v59 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v64[-1] = v63;
        int64x2_t *v64 = v63;
        v64 += 2;
        v65 -= 4;
      }
      while (v65);
      if (v59 == (v59 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_71:
        LODWORD(v90) = v37 / v41;
        uint64_t v66 = v37 % v41;
        if (v66)
        {
          if (HIDWORD(v90) <= v39)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v39 + 1, 8);
            LODWORD(v39) = v90;
            uint64_t v42 = (uint64_t *)v89;
          }
          v42[v39] = v66;
          LODWORD(v39) = v90 + 1;
          LODWORD(v90) = v90 + 1;
        }
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v61 = &v42[v52];
      unint64_t v62 = v59;
    }
    do
    {
      *v61++ = v41;
      --v62;
    }
    while (v62);
    goto LABEL_71;
  }
  uint64_t v21 = *(void *)(a4 + 16);
  if (v21)
  {
    uint64_t v51 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      uint64_t v49 = *(void *)(v51 + 24);
      goto LABEL_52;
    }
LABEL_65:
    uint64_t v21 = 0;
  }
LABEL_87:
  if (v89 != (int64x2_t *)v91) {
    free(v89);
  }
  if (v81 >= 0x41 && v80) {
    MEMORY[0x21667D390](v80, 0x1000C8000313F17);
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::matchConstantWithIntVector<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (!a1) {
    return 0;
  }
  unint64_t v8 = (uint64_t **)&v9;
  uint64_t v11 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v8, DefiningOp)) {
    return 0;
  }
  v7[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v9);
  v7[1] = v4;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v7) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return 0;
  }
  uint64_t v5 = 1;
  mlir::getIntValues<long long>(v9, v10, a2, 1);
  return v5;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.input_view";
    void v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Split supports only supports const positive axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Split supports only 1 axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot statically infer split sizes");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot infer split sizes");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 88);
  uint64_t v9 = *(void *)(a3 + 96);
  uint64_t v37 = v8;
  uint64_t v38 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      uint64_t v36 = *(void *)(a3 + 96);
      long long v28 = *(_OWORD *)(a3 + 80);
      v35[4] = *(_OWORD *)(a3 + 64);
      v35[5] = v28;
      long long v29 = *(_OWORD *)(a3 + 16);
      v35[0] = *(_OWORD *)a3;
      v35[1] = v29;
      long long v30 = *(_OWORD *)(a3 + 48);
      void v35[2] = *(_OWORD *)(a3 + 32);
      v35[3] = v30;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v35, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v37);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v34 = 259;
    v31[0] = v33;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v31);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v38;
    if (v37 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v34 = 259;
  unint64_t v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  uint64_t v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  __int16 v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    __int16 v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      unint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      uint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)v276 = *(void *)&v262[16];
          *(_OWORD *)v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              uint64_t v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              uint64_t v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              unint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              unint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          BOOL v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            uint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              BOOL v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  uint64_t v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              unint64_t v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              unint64_t v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            unint64_t v202 = *(void **)(v199 + 8);
            v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                unint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            uint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  uint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9)
{
  v40[38] = *MEMORY[0x263EF8340];
  uint64_t v31 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v31);
  uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.resize", (const unsigned __int8 *)0xB, Context);
  if (!v19)
  {
    __int16 v35 = 1283;
    uint64_t v34[2] = (uint64_t)"anec.resize";
    v34[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v33 = 259;
    llvm::operator+(v34, (uint64_t *)&v32, (uint64_t)v40);
    llvm::report_fatal_error((llvm::Twine *)v40, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v18);
  uint64_t v20 = *a3;
  unint64_t v21 = *a4;
  unint64_t v22 = *a5;
  uint64_t v24 = *(void **)(a6 + 8);
  uint64_t v23 = (void *)(a6 + 8);
  unint64_t v26 = llvm::APFloatBase::PPCDoubleDouble(v25);
  if (v26 == v24) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v39, v23);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v39, (uint64_t)v23);
  }
  uint64_t v27 = (void *)(a7 + 8);
  if (v26 == *(void **)(a7 + 8)) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v37, v27);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v37, (uint64_t)v27);
  }
  mlir::anec::Resize::build(a1, (uint64_t)v40, v20, v21, v22, (uint64_t)v38, (uint64_t)v36, *a8, *a9);
  if (v26 == (void *)v37[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v37);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v37);
  }
  if (v26 == (void *)v39[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v39);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v39);
  }
  long long v28 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (*(_UNKNOWN **)(*((void *)v28 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Resize,void>::id) {
    unint64_t v29 = v28;
  }
  else {
    unint64_t v29 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v29;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  unint64_t v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      unint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      uint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)v276 = *(void *)&v262[16];
          *(_OWORD *)v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              uint64_t v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              uint64_t v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              unint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              unint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          BOOL v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            uint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              BOOL v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  uint64_t v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              unint64_t v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              unint64_t v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            unint64_t v202 = *(void **)(v199 + 8);
            v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                unint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            uint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  uint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = (unsigned int *)a2;
  uint64_t v297 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v265 = a3[4];
  *(_OWORD *)unint64_t v266 = v6;
  *(void *)&v266[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v261 = *a3;
  long long v262 = v7;
  long long v8 = a3[3];
  long long v263 = a3[2];
  long long v264 = v8;
  long long v257 = a2;
  long long v296 = *(_OWORD *)&v266[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v256 = mlir::ValueRange::dereference_iterator(&v296, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v257) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v255[0] = v10;
  v255[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v261, 0);
  unint64_t v22 = *(void **)&v266[8];
  v274[0] = *(void **)&v266[8];
  v274[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v274, ODSOperandIndexAndLength);
  }
  v274[0] = v22;
  v274[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v274, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v274[0] = v23;
  v274[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v274);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v249 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v255);
  if (v39 <= 3)
  {
    v274[0] = &v275;
    *(void *)&long long v275 = IndexFromDim;
    *((void *)&v275 + 1) = v37;
    *(void *)&long long v276 = v37;
    *((void *)&v276 + 1) = v38;
    *(void *)&long long v277 = v38;
    *((void *)&v277 + 1) = IndexFromDim;
    v274[1] = (void *)0x600000006;
    *(_OWORD *)unint64_t v268 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v268, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    uint64_t v293 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v274[0], 8 * LODWORD(v274[1]), 8, 1, 0);
    uint64_t v256 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v256, (uint64_t *)&v293)- 16;
    if (v274[0] != &v275) {
      free(v274[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v257) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v250 = v38;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v254[0] = v53;
  v254[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v254);
  uint64_t v66 = v64;
  uint64_t v293 = (mlir::Operation *)v295;
  uint64_t v294 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v295;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v293, v295, (8 * v64) >> 3, 8);
  unsigned int v68 = v294;
  uint64_t v69 = v293;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v294;
    uint64_t v69 = v293;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v294) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v293, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v293;
  }
  uint64_t v71 = *((void *)v69 + v250);
  uint64_t v72 = *((void *)v69 + v249);
  uint64_t v290 = v292;
  v292[0] = v71;
  v292[1] = v72;
  uint64_t v291 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v257, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v247 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v274[0] = &v275;
      *(void *)&long long v275 = v37;
      *((void *)&v275 + 1) = v250;
      *(void *)&long long v276 = v250;
      *((void *)&v276 + 1) = v249;
      *(void *)&long long v277 = v249;
      *((void *)&v277 + 1) = v37;
      v274[1] = (void *)0x600000006;
      *(_OWORD *)unint64_t v268 = xmmword_211F1A410;
      uint64_t v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v75 = (void *)mlir::RankedTensorType::get((uint64_t)v268, 2, v74, 0);
      unint64_t v76 = v75;
      if (v75)
      {
        uint64_t v77 = v9;
        uint64_t v78 = *v75;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v9 = v77;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v9 = v77;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      uint64_t v287 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v87, v274[0], 8 * LODWORD(v274[1]), 8, 1, 0);
      uint64_t v256 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v256, (uint64_t *)&v287)- 16;
      uint64_t v89 = v293;
      uint64_t v90 = v290;
      *uint64_t v290 = *((void *)v293 + v37);
      v90[1] = *((void *)v89 + v250);
      if (v274[0] != &v275) {
        free(v274[0]);
      }
    }
    v253[0] = 0;
    v253[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v257);
    v268[0] = v253;
    v274[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v274);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v268, DefiningOp))
    {
      uint64_t v245 = v9;
      uint64_t v287 = v289;
      v289[0] = 0;
      v289[1] = 0;
      uint64_t v288 = 0x200000002;
      uint64_t v284 = v286;
      memset_pattern16(v286, &unk_211ED5510, 0x10uLL);
      uint64_t v285 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v257);
      v274[0] = (void *)2;
      v246 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v274, 1, v94, 0);
      unint64_t v96 = v95;
      if (v95)
      {
        uint64_t v97 = v5;
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v5 = v97;
          if (v101 == v102)
          {
            uint64_t v107 = 0;
          }
          else if (*v101 == v99)
          {
            uint64_t v107 = v101[1];
          }
          else
          {
            uint64_t v107 = 0;
          }
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v5 = v97;
        }
      }
      else
      {
        uint64_t v107 = 0;
      }
      if (InterpolationMode == 1) {
        uint64_t v115 = (void **)&v287;
      }
      else {
        uint64_t v115 = &v284;
      }
      uint64_t v116 = *v115;
      unint64_t v117 = &v288;
      if (InterpolationMode != 1) {
        unint64_t v117 = &v285;
      }
      uint64_t v252 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
      __dst = v283;
      uint64_t v282 = 0x200000000;
      BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v257);
      BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v257);
      if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v257)
        && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v257))
      {
        goto LABEL_201;
      }
      long long v278 = v265;
      long long v279 = *(_OWORD *)v266;
      *(void *)v280 = *(void *)&v266[16];
      *(_OWORD *)long long v274 = v261;
      long long v275 = v262;
      long long v276 = v263;
      long long v277 = v264;
      v259[0] = v257;
      uint64_t v121 = mlir::mps::getResizeLayout(v257, v120);
      if ((v121 & 0xFF00000000) == 0) {
        goto LABEL_195;
      }
      uint64_t v122 = 8 * (int)v121;
      unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
      uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
      unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v274, 2u);
      uint64_t v126 = (void *)*((void *)&v279 + 1);
      v268[0] = *((void **)&v279 + 1);
      v268[1] = (void *)v125;
      if (v125)
      {
        uint64_t v126 = (void *)mlir::ValueRange::offset_base(v268, v125);
        uint64_t v127 = v268[1];
      }
      else
      {
        uint64_t v127 = 0;
      }
      if ((void *)(HIDWORD(v125) + v125) == v127
        || (v268[0] = v126, v268[1] = 0, !mlir::ValueRange::dereference_iterator(v268, 0)))
      {
        float v131 = 1.0;
        float v132 = 1.0;
      }
      else
      {
        *(_OWORD *)unint64_t v267 = 0uLL;
        unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v274, 2u);
        uint64_t v129 = (void *)*((void *)&v279 + 1);
        v268[0] = *((void **)&v279 + 1);
        v268[1] = (void *)v128;
        if (v128)
        {
          uint64_t v129 = (void *)mlir::ValueRange::offset_base(v268, v128);
          uint64_t v130 = v268[1];
        }
        else
        {
          uint64_t v130 = 0;
        }
        if ((void *)(HIDWORD(v128) + v128) == v130)
        {
          unint64_t v172 = 0;
        }
        else
        {
          v268[0] = v129;
          v268[1] = 0;
          unint64_t v172 = (void *)mlir::ValueRange::dereference_iterator(v268, 0);
        }
        long long v258 = (uint64_t **)v267;
        v268[0] = v172;
        uint64_t v173 = mlir::Value::getDefiningOp((mlir::Value *)v268);
        if (!v173 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v258, v173)) {
          goto LABEL_195;
        }
        v268[0] = &v269;
        v268[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v267[0], v267[1], (uint64_t)v268, 1);
        unint64_t v174 = LODWORD(v268[1]);
        float v131 = 1.0;
        float v132 = 1.0;
        if (v123 < LODWORD(v268[1]))
        {
          float v132 = *((float *)v268[0] + v123);
          float v131 = *((float *)v268[0] + v124);
        }
        if (v268[0] != &v269) {
          free(v268[0]);
        }
        if (v123 >= v174) {
          goto LABEL_195;
        }
      }
      unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v274, 3u);
      unint64_t v134 = (void *)*((void *)&v279 + 1);
      v268[0] = *((void **)&v279 + 1);
      v268[1] = (void *)v133;
      if (v133)
      {
        unint64_t v134 = (void *)mlir::ValueRange::offset_base(v268, v133);
        long long v135 = v268[1];
      }
      else
      {
        long long v135 = 0;
      }
      if ((void *)(HIDWORD(v133) + v133) == v135
        || (v268[0] = v134, v268[1] = 0, !mlir::ValueRange::dereference_iterator(v268, 0)))
      {
        float v139 = 0.0;
        float v140 = 0.0;
      }
      else
      {
        *(_OWORD *)unint64_t v267 = 0uLL;
        unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v274, 3u);
        uint64_t v137 = (void *)*((void *)&v279 + 1);
        v268[0] = *((void **)&v279 + 1);
        v268[1] = (void *)v136;
        if (v136)
        {
          uint64_t v137 = (void *)mlir::ValueRange::offset_base(v268, v136);
          uint64_t v138 = v268[1];
        }
        else
        {
          uint64_t v138 = 0;
        }
        if ((void *)(HIDWORD(v136) + v136) == v138)
        {
          unint64_t v175 = 0;
        }
        else
        {
          v268[0] = v137;
          v268[1] = 0;
          unint64_t v175 = (void *)mlir::ValueRange::dereference_iterator(v268, 0);
        }
        long long v258 = (uint64_t **)v267;
        v268[0] = v175;
        uint64_t v176 = mlir::Value::getDefiningOp((mlir::Value *)v268);
        if (!v176 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v258, v176)) {
          goto LABEL_195;
        }
        v268[0] = &v269;
        v268[1] = (void *)0x400000000;
        mlir::getIntValues<float>(v267[0], v267[1], (uint64_t)v268, 1);
        unint64_t v177 = LODWORD(v268[1]);
        float v139 = 0.0;
        float v140 = 0.0;
        if (v123 < LODWORD(v268[1]))
        {
          float v140 = *((float *)v268[0] + v123);
          float v139 = *((float *)v268[0] + v124);
        }
        if (v268[0] != &v269) {
          free(v268[0]);
        }
        if (v123 >= v177) {
          goto LABEL_195;
        }
      }
      unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v274, 0);
      uint64_t v142 = (void *)*((void *)&v279 + 1);
      v268[0] = *((void **)&v279 + 1);
      v268[1] = (void *)v141;
      if (v141) {
        uint64_t v142 = (void *)mlir::ValueRange::offset_base(v268, v141);
      }
      v268[0] = v142;
      v268[1] = 0;
      unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v268, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v143) {
        goto LABEL_143;
      }
      uint64_t v144 = *v143;
      unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v146 = *(unsigned int *)(v144 + 16);
      if (!v146) {
        goto LABEL_143;
      }
      unint64_t v147 = *(void **)(v144 + 8);
      long long v148 = &v147[2 * v146];
      do
      {
        unint64_t v149 = v146 >> 1;
        unint64_t v150 = &v147[2 * (v146 >> 1)];
        unint64_t v152 = *v150;
        uint64_t v151 = v150 + 2;
        v146 += ~(v146 >> 1);
        if (v152 < v145) {
          unint64_t v147 = v151;
        }
        else {
          unint64_t v146 = v149;
        }
      }
      while (v146);
      if (v147 != v148 && *v147 == v145) {
        unint64_t v153 = (void *)v147[1];
      }
      else {
LABEL_143:
      }
        unint64_t v153 = 0;
      v268[0] = v143;
      v268[1] = v153;
      uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v268);
      unint64_t v156 = v155;
      uint64_t v157 = *(void *)(a1 + 96);
      uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v259);
      unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
      unsigned int v160 = v159;
      if (!v159) {
        goto LABEL_153;
      }
      unint64_t v161 = v156;
      uint64_t v162 = *v159;
      unint64_t v163 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v164 = *(unsigned int *)(v162 + 16);
      if (v164)
      {
        unint64_t v165 = *(void **)(v162 + 8);
        unint64_t v166 = &v165[2 * v164];
        do
        {
          unint64_t v167 = v164 >> 1;
          uint64_t v168 = &v165[2 * (v164 >> 1)];
          unint64_t v170 = *v168;
          unint64_t v169 = v168 + 2;
          v164 += ~(v164 >> 1);
          if (v170 < v163) {
            unint64_t v165 = v169;
          }
          else {
            unint64_t v164 = v167;
          }
        }
        while (v164);
        unint64_t v156 = v161;
        if (v165 == v166 || *v165 != v163)
        {
LABEL_153:
          uint64_t v171 = 0;
          goto LABEL_181;
        }
        uint64_t v171 = (void *)v165[1];
      }
      else
      {
        uint64_t v171 = 0;
        unint64_t v156 = v161;
      }
LABEL_181:
      v268[0] = v160;
      v268[1] = v171;
      uint64_t v178 = mlir::ShapedType::getShape((mlir::ShapedType *)v268);
      unint64_t v180 = v179;
      unint64_t v181 = mlir::anec::getIndexFromDim(3, v156);
      unint64_t v182 = mlir::anec::getIndexFromDim(4, v180);
      float v183 = (float)*(uint64_t *)(v154 + 8 * v181);
      float v184 = (float)*(uint64_t *)(v154 + 8 * v182);
      float v185 = (float)*(uint64_t *)(v178 + 8 * v181);
      float v186 = (float)*(uint64_t *)(v178 + 8 * v182);
      BOOL v187 = v140 != 0.0;
      if (v139 != 0.0) {
        BOOL v187 = 1;
      }
      BOOL v188 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
      BOOL v189 = v132 != (float)(v185 / v183) || v131 != (float)(v186 / v184);
      BOOL v190 = v132 != (float)((float)(v185 + -1.0) / (float)(v183 + -1.0))
          || v131 != (float)((float)(v186 + -1.0) / (float)(v184 + -1.0));
      if (v187 || v189)
      {
        if (v187 || v190)
        {
          if (v188 || v189)
          {
LABEL_195:
            uint64_t v191 = *(void *)(a4 + 16);
            if (!v191) {
              goto LABEL_207;
            }
            uint64_t v192 = v257;
            if (!mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              goto LABEL_207;
            }
            uint64_t v193 = *((void *)v192 + 3);
LABEL_206:
            (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v191 + 64))(v191, v193, v194, v268);
LABEL_207:
            uint64_t v110 = 0;
            int v111 = 0;
LABEL_208:
            if (__dst != v283) {
              free(__dst);
            }
            if (v284 != v286) {
              free(v284);
            }
            if (v287 != v289) {
              free(v287);
            }
            goto LABEL_93;
          }
          BOOL InferredResultTypes = 0;
          BOOL IsSize = 1;
        }
        else
        {
          BOOL IsSize = 1;
          BOOL InferredResultTypes = 1;
        }
      }
      else
      {
        BOOL IsSize = 0;
        BOOL InferredResultTypes = 0;
      }
LABEL_201:
      if (InferredResultTypes && IsSize)
      {
        uint64_t v191 = *(void *)(a4 + 16);
        if (!v191) {
          goto LABEL_207;
        }
        uint64_t v195 = v257;
        if (!mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
          goto LABEL_207;
        }
        uint64_t v193 = *((void *)v195 + 3);
        goto LABEL_206;
      }
      if (InferredResultTypes || IsSize)
      {
        if (InferredResultTypes || !IsSize)
        {
          uint64_t v191 = *(void *)(a4 + 16);
          if (!v191) {
            goto LABEL_207;
          }
          v198 = v257;
          if (!mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
            goto LABEL_207;
          }
          uint64_t v193 = *((void *)v198 + 3);
          goto LABEL_206;
        }
        v268[0] = &v269;
        uint64_t v196 = &unk_211ED5510;
      }
      else
      {
        v268[0] = &v269;
        uint64_t v196 = &unk_211F1A430;
      }
      memset_pattern16(&v269, v196, 0x10uLL);
      v268[1] = (void *)0x600000002;
      uint64_t v197 = v282;
      if (v282 >= 2)
      {
        *(_OWORD *)__dst = v269;
      }
      else
      {
        if (HIDWORD(v282) > 1)
        {
          if (v282) {
            memmove(__dst, &v269, 8 * v282);
          }
          else {
            uint64_t v197 = 0;
          }
        }
        else
        {
          LODWORD(v282) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v283, 2uLL, 8);
          uint64_t v197 = 0;
        }
        if (v197 != LODWORD(v268[1])) {
          memcpy((char *)__dst + 8 * v197, (char *)v268[0] + 8 * v197, 8 * LODWORD(v268[1]) - 8 * v197);
        }
      }
      LODWORD(v282) = 2;
      LODWORD(v268[1]) = 0;
      if (v268[0] != &v269) {
        free(v268[0]);
      }
      v268[0] = (void *)2;
      uint64_t v199 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
      unint64_t v200 = (void *)mlir::RankedTensorType::get((uint64_t)v268, 1, v199, 0);
      unint64_t v201 = v200;
      if (!v200) {
        goto LABEL_242;
      }
      uint64_t v202 = *v200;
      unint64_t v203 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v204 = *(unsigned int *)(v202 + 16);
      if (!v204) {
        goto LABEL_242;
      }
      unint64_t v205 = *(void **)(v202 + 8);
      v206 = &v205[2 * v204];
      do
      {
        unint64_t v207 = v204 >> 1;
        uint64_t v208 = &v205[2 * (v204 >> 1)];
        unint64_t v210 = *v208;
        uint64_t v209 = v208 + 2;
        v204 += ~(v204 >> 1);
        if (v210 < v203) {
          unint64_t v205 = v209;
        }
        else {
          unint64_t v204 = v207;
        }
      }
      while (v204);
      if (v205 != v206 && *v205 == v203) {
        uint64_t v211 = v205[1];
      }
      else {
LABEL_242:
      }
        uint64_t v211 = 0;
      long long v258 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v201, v211, __dst, 8 * v282, 8, 1, 0);
      unint64_t v212 = v290;
      BOOL v213 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v267, -1.0);
      uint64_t v214 = llvm::APFloatBase::IEEEsingle(v213);
      llvm::APFloat::Storage::Storage(&v268[1], v267, v214);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v267);
      llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v259, -1.0);
      llvm::APFloat::Storage::Storage(&v267[1], v259, v214);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v259);
      uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v246, v245, &v256, v212, v212 + 1, (uint64_t)v268, (uint64_t)v267, &v252, (uint64_t *)&v258);
      v259[0] = v110;
      uint64_t v215 = (void *)v267[1];
      uint64_t v216 = llvm::APFloatBase::PPCDoubleDouble(v110);
      if (v216 == v215) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v267[1]);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v267[1]);
      }
      if (v216 == v268[1]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v268[1]);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v268[1]);
      }
      if (v247 != 1)
      {
LABEL_266:
        mlir::ShapedType::getShape((mlir::ShapedType *)v255);
        if (v231 <= 3)
        {
          v268[0] = &v269;
          *(void *)&long long v269 = v37;
          *((void *)&v269 + 1) = IndexFromDim;
          unint64_t v270 = v250;
          unint64_t v271 = v37;
          unint64_t v272 = IndexFromDim;
          unint64_t v273 = v250;
          v268[1] = (void *)0x600000006;
          *(_OWORD *)unint64_t v267 = xmmword_211F1A410;
          uint64_t v232 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
          unint64_t v233 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v232, 0);
          v234 = v233;
          if (!v233) {
            goto LABEL_278;
          }
          uint64_t v235 = *v233;
          unint64_t v236 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v237 = *(unsigned int *)(v235 + 16);
          if (v237)
          {
            v238 = *(void **)(v235 + 8);
            unint64_t v239 = &v238[2 * v237];
            do
            {
              unint64_t v240 = v237 >> 1;
              uint64_t v241 = &v238[2 * (v237 >> 1)];
              unint64_t v243 = *v241;
              uint64_t v242 = v241 + 2;
              v237 += ~(v237 >> 1);
              if (v243 < v236) {
                v238 = v242;
              }
              else {
                unint64_t v237 = v240;
              }
            }
            while (v237);
            uint64_t v244 = v238 != v239 && *v238 == v236 ? v238[1] : 0;
          }
          else
          {
LABEL_278:
            uint64_t v244 = 0;
          }
          uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v234, v244, v268[0], 8 * LODWORD(v268[1]), 8, 1, 0);
          v267[0] = (uint64_t)v110 - 16;
          uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v246, v245, v267, &v251);
          if (v268[0] != &v269) {
            free(v268[0]);
          }
        }
        int v111 = 1;
        goto LABEL_208;
      }
      uint64_t v217 = v5;
      v268[0] = &v269;
      *(void *)&long long v269 = v37;
      *((void *)&v269 + 1) = v249;
      unint64_t v270 = v250;
      unint64_t v271 = v37;
      unint64_t v272 = v249;
      unint64_t v273 = v250;
      v268[1] = (void *)0x600000006;
      *(_OWORD *)unint64_t v267 = xmmword_211F1A410;
      uint64_t v218 = mlir::Builder::getIntegerType(v246, 0x40u, 0);
      unint64_t v219 = (void *)mlir::RankedTensorType::get((uint64_t)v267, 2, v218, 0);
      uint64_t v220 = v219;
      if (v219)
      {
        uint64_t v221 = *v219;
        unint64_t v222 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v223 = *(unsigned int *)(v221 + 16);
        if (!v223)
        {
          uint64_t v230 = 0;
          goto LABEL_263;
        }
        uint64_t v224 = *(void **)(v221 + 8);
        unint64_t v225 = &v224[2 * v223];
        do
        {
          unint64_t v226 = v223 >> 1;
          uint64_t v227 = &v224[2 * (v223 >> 1)];
          unint64_t v229 = *v227;
          uint64_t v228 = v227 + 2;
          v223 += ~(v223 >> 1);
          if (v229 < v222) {
            uint64_t v224 = v228;
          }
          else {
            unint64_t v223 = v226;
          }
        }
        while (v223);
        if (v224 != v225 && *v224 == v222)
        {
          uint64_t v230 = v224[1];
          goto LABEL_263;
        }
      }
      uint64_t v230 = 0;
LABEL_263:
      uint64_t v251 = mlir::DenseElementsAttr::getFromRawBuffer(v220, v230, v268[0], 8 * LODWORD(v268[1]), 8, 1, 0);
      uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v246, v245, v259, &v251);
      if (v268[0] != &v269) {
        free(v268[0]);
      }
      uint64_t v5 = v217;
      goto LABEL_266;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v274[0] = (void *)v88;
  LOWORD(v276) = 259;
  uint64_t v108 = v257;
  v268[0] = v274;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v268);
  }
  uint64_t v110 = 0;
  int v111 = 0;
LABEL_93:
  if (v290 != v292) {
    free(v290);
  }
  if (v293 != (mlir::Operation *)v295) {
    free(v293);
  }
  if (v111)
  {
    v274[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v260, (uint64_t)v274, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v5, v260[0], v260[1]);
  }
  else
  {
    v274[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v276) = 259;
    v268[0] = v274;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v5 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v268);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize alignCorners == centerResult == true is not supported on A14-class ANEs. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)long long v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  unint64_t v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)long long v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)long long v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      uint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      unint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)long long v276 = *(void *)&v262[16];
          *(_OWORD *)unint64_t v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              float v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              float v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              uint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              uint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          unint64_t v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            unint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              unint64_t v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  BOOL v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              float v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              float v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            uint64_t v202 = *(void **)(v199 + 8);
            unint64_t v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                uint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            unint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)long long v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)long long v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)long long v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  unint64_t v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)long long v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)long long v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      uint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      unint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)long long v276 = *(void *)&v262[16];
          *(_OWORD *)unint64_t v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              float v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              float v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              uint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              uint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          unint64_t v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            unint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              unint64_t v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  BOOL v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              float v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              float v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            uint64_t v202 = *(void **)(v199 + 8);
            unint64_t v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                uint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            unint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)long long v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)long long v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)long long v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  unint64_t v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)long long v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)long long v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      uint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      unint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)long long v276 = *(void *)&v262[16];
          *(_OWORD *)unint64_t v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              float v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              float v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              uint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              uint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          unint64_t v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            unint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              unint64_t v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  BOOL v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              float v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              float v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            uint64_t v202 = *(void **)(v199 + 8);
            unint64_t v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                uint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            unint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)long long v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)long long v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void *mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, long long *a3, uint64_t a4)
{
  uint64_t v293 = *MEMORY[0x263EF8340];
  long long v6 = a3[5];
  long long v261 = a3[4];
  *(_OWORD *)long long v262 = v6;
  *(void *)&v262[16] = *((void *)a3 + 12);
  long long v7 = a3[1];
  long long v257 = *a3;
  long long v258 = v7;
  long long v8 = a3[3];
  long long v259 = a3[2];
  long long v260 = v8;
  uint64_t v253 = a2;
  long long v292 = *(_OWORD *)&v262[8];
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v252 = mlir::ValueRange::dereference_iterator(&v292, 0);
  char v10 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    uint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    __int16 v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v251[0] = v10;
  v251[1] = v20;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v257, 0);
  unint64_t v22 = *(void **)&v262[8];
  v270[0] = *(void **)&v262[8];
  v270[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v22 = (void *)mlir::ValueRange::offset_base(v270, ODSOperandIndexAndLength);
  }
  v270[0] = v22;
  v270[1] = 0;
  uint64_t v23 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v270, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_22;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_22;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  long long v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    long long v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    uint64_t v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    __int16 v33 = (void *)v27[1];
  }
  else {
LABEL_22:
  }
    __int16 v33 = 0;
  v270[0] = v23;
  v270[1] = v33;
  mlir::ShapedType::getShape((mlir::ShapedType *)v270);
  unint64_t v35 = v34;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  unint64_t v37 = mlir::anec::getIndexFromDim(1, v35);
  unint64_t v38 = mlir::anec::getIndexFromDim(3, v35);
  unint64_t v245 = mlir::anec::getIndexFromDim(4, v35);
  mlir::ShapedType::getShape((mlir::ShapedType *)v251);
  if (v39 <= 3)
  {
    v270[0] = &v271;
    *(void *)&long long v271 = IndexFromDim;
    *((void *)&v271 + 1) = v37;
    *(void *)&long long v272 = v37;
    *((void *)&v272 + 1) = v38;
    *(void *)&long long v273 = v38;
    *((void *)&v273 + 1) = IndexFromDim;
    v270[1] = (void *)0x600000006;
    *(_OWORD *)long long v264 = xmmword_211F1A410;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v41 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, IntegerType, 0);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_33;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_33;
    }
    uint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      uint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      uint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        uint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_33:
    }
      uint64_t v52 = 0;
    v289 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v42, v52, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
    uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v289)- 16;
    if (v270[0] != &v271) {
      free(v270[0]);
    }
  }
  unint64_t v53 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v253) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v244 = IndexFromDim;
  if (!v53) {
    goto LABEL_45;
  }
  uint64_t v54 = *v53;
  unint64_t v55 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v56 = *(unsigned int *)(v54 + 16);
  if (!v56) {
    goto LABEL_45;
  }
  uint64_t v57 = *(void **)(v54 + 8);
  uint64_t v58 = &v57[2 * v56];
  do
  {
    unint64_t v59 = v56 >> 1;
    uint64_t v60 = &v57[2 * (v56 >> 1)];
    unint64_t v62 = *v60;
    uint64_t v61 = v60 + 2;
    v56 += ~(v56 >> 1);
    if (v62 < v55) {
      uint64_t v57 = v61;
    }
    else {
      unint64_t v56 = v59;
    }
  }
  while (v56);
  if (v57 != v58 && *v57 == v55) {
    uint64_t v63 = v57[1];
  }
  else {
LABEL_45:
  }
    uint64_t v63 = 0;
  v250[0] = v53;
  v250[1] = v63;
  uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v250);
  uint64_t v66 = v64;
  v289 = (mlir::Operation *)v291;
  uint64_t v290 = 0x400000000;
  size_t v67 = 8 * v64;
  if ((unint64_t)(8 * v64) < 0x21)
  {
    unsigned int v68 = 0;
    uint64_t v69 = (mlir::Operation *)v291;
    if (!v66) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v289, v291, (8 * v64) >> 3, 8);
  unsigned int v68 = v290;
  uint64_t v69 = v289;
  if (v66)
  {
LABEL_50:
    memcpy((char *)v69 + 8 * v68, Shape, v67);
    unsigned int v68 = v290;
    uint64_t v69 = v289;
  }
LABEL_51:
  unsigned int v70 = v68 + (v67 >> 3);
  LODWORD(v290) = v70;
  if (v70 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v289, (uint64_t)v69, 4 - v70, 1uLL);
    uint64_t v69 = v289;
  }
  uint64_t v71 = *((void *)v69 + v38);
  uint64_t v72 = *((void *)v69 + v245);
  v286 = v288;
  v288[0] = v71;
  v288[1] = v72;
  uint64_t v287 = 0x200000002;
  uint64_t ResizeLayout = mlir::mps::getResizeLayout(v253, v69);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    uint64_t v74 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v270[0] = &v271;
      *(void *)&long long v271 = v37;
      *((void *)&v271 + 1) = v38;
      *(void *)&long long v272 = v38;
      *((void *)&v272 + 1) = v245;
      *(void *)&long long v273 = v245;
      *((void *)&v273 + 1) = v37;
      v270[1] = (void *)0x600000006;
      *(_OWORD *)long long v264 = xmmword_211F1A410;
      uint64_t v75 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      unint64_t v76 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 2, v75, 0);
      uint64_t v77 = v76;
      if (v76)
      {
        uint64_t v78 = *v76;
        unint64_t v79 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v80 = *(unsigned int *)(v78 + 16);
        if (v80)
        {
          unsigned int v81 = *(void **)(v78 + 8);
          unint64_t v82 = &v81[2 * v80];
          do
          {
            unint64_t v83 = v80 >> 1;
            uint64_t v84 = &v81[2 * (v80 >> 1)];
            unint64_t v86 = *v84;
            unint64_t v85 = v84 + 2;
            v80 += ~(v80 >> 1);
            if (v86 < v79) {
              unsigned int v81 = v85;
            }
            else {
              unint64_t v80 = v83;
            }
          }
          while (v80);
          uint64_t v74 = 1;
          if (v81 == v82) {
            uint64_t v87 = 0;
          }
          else {
            uint64_t v87 = *v81 == v79 ? v81[1] : 0;
          }
        }
        else
        {
          uint64_t v87 = 0;
          uint64_t v74 = 1;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      v283 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v77, v87, v270[0], 8 * LODWORD(v270[1]), 8, 1, 0);
      uint64_t v252 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v9, &v252, (uint64_t *)&v283)- 16;
      uint64_t v89 = v289;
      uint64_t v90 = v286;
      void *v286 = *((void *)v289 + v37);
      v90[1] = *((void *)v89 + v38);
      if (v270[0] != &v271) {
        free(v270[0]);
      }
    }
    v249[0] = 0;
    v249[1] = 0;
    unint64_t v91 = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v253);
    v264[0] = v249;
    v270[0] = v91;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v270);
    if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)v264, DefiningOp))
    {
      uint64_t v241 = a1;
      uint64_t v242 = v74;
      v283 = v285;
      v285[0] = 0;
      v285[1] = 0;
      uint64_t v284 = 0x200000002;
      v280 = v282;
      memset_pattern16(v282, &unk_211ED5510, 0x10uLL);
      uint64_t v281 = 0x200000002;
      int InterpolationMode = mlir::mps::CropResizeOp::getInterpolationMode((mlir::mps::CropResizeOp *)&v253);
      v270[0] = (void *)2;
      unint64_t v243 = (mlir::Builder *)(a4 + 8);
      uint64_t v94 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      uint64_t v95 = (void *)mlir::RankedTensorType::get((uint64_t)v270, 1, v94, 0);
      unint64_t v96 = v95;
      uint64_t v97 = (unsigned int *)a2;
      if (v95)
      {
        uint64_t v98 = *v95;
        unint64_t v99 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v100 = *(unsigned int *)(v98 + 16);
        if (v100)
        {
          uint64_t v101 = *(void **)(v98 + 8);
          unint64_t v102 = &v101[2 * v100];
          do
          {
            unint64_t v103 = v100 >> 1;
            uint64_t v104 = &v101[2 * (v100 >> 1)];
            unint64_t v106 = *v104;
            unint64_t v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99) {
              uint64_t v101 = v105;
            }
            else {
              unint64_t v100 = v103;
            }
          }
          while (v100);
          uint64_t v97 = (unsigned int *)a2;
          if (v101 == v102 || *v101 != v99) {
            goto LABEL_87;
          }
          uint64_t v107 = v101[1];
        }
        else
        {
          uint64_t v107 = 0;
          uint64_t v97 = (unsigned int *)a2;
        }
LABEL_106:
        if (InterpolationMode == 1) {
          uint64_t v115 = (void **)&v283;
        }
        else {
          uint64_t v115 = &v280;
        }
        uint64_t v116 = *v115;
        unint64_t v117 = &v284;
        if (InterpolationMode != 1) {
          unint64_t v117 = &v281;
        }
        uint64_t v248 = mlir::DenseElementsAttr::getFromRawBuffer(v96, v107, v116, 8 * *(unsigned int *)v117, 8, 1, 0);
        __dst = v279;
        uint64_t v278 = 0x200000000;
        BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v253);
        BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v253);
        if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v253)
          || mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v253))
        {
          long long v274 = v261;
          long long v275 = *(_OWORD *)v262;
          *(void *)long long v276 = *(void *)&v262[16];
          *(_OWORD *)unint64_t v270 = v257;
          long long v271 = v258;
          long long v272 = v259;
          long long v273 = v260;
          v255[0] = v253;
          uint64_t v121 = mlir::mps::getResizeLayout(v253, v120);
          if ((v121 & 0xFF00000000) == 0) {
            goto LABEL_211;
          }
          uint64_t v122 = 8 * (int)v121;
          unint64_t v123 = *(void *)((char *)&unk_211F1A540 + v122);
          uint64_t v124 = *(void *)((char *)&unk_211F1A578 + v122);
          unint64_t v125 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
          uint64_t v126 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v125;
          if (v125)
          {
            uint64_t v126 = (void *)mlir::ValueRange::offset_base(v264, v125);
            uint64_t v127 = v264[1];
          }
          else
          {
            uint64_t v127 = 0;
          }
          if ((void *)(HIDWORD(v125) + v125) == v127
            || (v264[0] = v126, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v131 = 1.0;
            float v132 = 1.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v128 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 2u);
            uint64_t v129 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v128;
            if (v128)
            {
              uint64_t v129 = (void *)mlir::ValueRange::offset_base(v264, v128);
              uint64_t v130 = v264[1];
            }
            else
            {
              uint64_t v130 = 0;
            }
            if ((void *)(HIDWORD(v128) + v128) == v130)
            {
              float v186 = 0;
            }
            else
            {
              v264[0] = v129;
              v264[1] = 0;
              float v186 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v186;
            uint64_t v187 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v187 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v187)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v188 = LODWORD(v264[1]);
            float v131 = 1.0;
            float v132 = 1.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v132 = *((float *)v264[0] + v123);
              float v131 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v188) {
              goto LABEL_211;
            }
          }
          unint64_t v133 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
          unint64_t v134 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v133;
          if (v133)
          {
            unint64_t v134 = (void *)mlir::ValueRange::offset_base(v264, v133);
            long long v135 = v264[1];
          }
          else
          {
            long long v135 = 0;
          }
          if ((void *)(HIDWORD(v133) + v133) == v135
            || (v264[0] = v134, v264[1] = 0, !mlir::ValueRange::dereference_iterator(v264, 0)))
          {
            float v139 = 0.0;
            float v140 = 0.0;
          }
          else
          {
            *(_OWORD *)long long v263 = 0uLL;
            unint64_t v136 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 3u);
            uint64_t v137 = (void *)*((void *)&v275 + 1);
            v264[0] = *((void **)&v275 + 1);
            v264[1] = (void *)v136;
            if (v136)
            {
              uint64_t v137 = (void *)mlir::ValueRange::offset_base(v264, v136);
              uint64_t v138 = v264[1];
            }
            else
            {
              uint64_t v138 = 0;
            }
            if ((void *)(HIDWORD(v136) + v136) == v138)
            {
              uint64_t v191 = 0;
            }
            else
            {
              v264[0] = v137;
              v264[1] = 0;
              uint64_t v191 = (void *)mlir::ValueRange::dereference_iterator(v264, 0);
            }
            v254 = (uint64_t **)v263;
            v264[0] = v191;
            uint64_t v192 = mlir::Value::getDefiningOp((mlir::Value *)v264);
            if (!v192 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v254, v192)) {
              goto LABEL_211;
            }
            v264[0] = &v265;
            v264[1] = (void *)0x400000000;
            mlir::getIntValues<float>(v263[0], v263[1], (uint64_t)v264, 1);
            unint64_t v193 = LODWORD(v264[1]);
            float v139 = 0.0;
            float v140 = 0.0;
            if (v123 < LODWORD(v264[1]))
            {
              float v140 = *((float *)v264[0] + v123);
              float v139 = *((float *)v264[0] + v124);
            }
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            if (v123 >= v193) {
              goto LABEL_211;
            }
          }
          unsigned int v141 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v270, 0);
          uint64_t v142 = (void *)*((void *)&v275 + 1);
          v264[0] = *((void **)&v275 + 1);
          v264[1] = (void *)v141;
          if (v141) {
            uint64_t v142 = (void *)mlir::ValueRange::offset_base(v264, v141);
          }
          v264[0] = v142;
          v264[1] = 0;
          unint64_t v143 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v264, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v143) {
            goto LABEL_141;
          }
          uint64_t v144 = *v143;
          unint64_t v145 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v146 = *(unsigned int *)(v144 + 16);
          if (!v146) {
            goto LABEL_141;
          }
          unint64_t v147 = *(void **)(v144 + 8);
          long long v148 = &v147[2 * v146];
          do
          {
            unint64_t v149 = v146 >> 1;
            unint64_t v150 = &v147[2 * (v146 >> 1)];
            unint64_t v152 = *v150;
            uint64_t v151 = v150 + 2;
            v146 += ~(v146 >> 1);
            if (v152 < v145) {
              unint64_t v147 = v151;
            }
            else {
              unint64_t v146 = v149;
            }
          }
          while (v146);
          if (v147 != v148 && *v147 == v145) {
            unint64_t v153 = (void *)v147[1];
          }
          else {
LABEL_141:
          }
            unint64_t v153 = 0;
          v264[0] = v143;
          v264[1] = v153;
          uint64_t v154 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v156 = v155;
          uint64_t v157 = *(void *)(v241 + 96);
          uint64_t v158 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)v255);
          unint64_t v159 = (uint64_t *)mlir::TypeConverter::convertType(v157, (void *)(*(void *)(v158 + 8) & 0xFFFFFFFFFFFFFFF8));
          unsigned int v160 = v159;
          if (!v159) {
            goto LABEL_151;
          }
          uint64_t v161 = *v159;
          unint64_t v162 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v163 = *(unsigned int *)(v161 + 16);
          if (!v163) {
            goto LABEL_151;
          }
          unint64_t v164 = *(void **)(v161 + 8);
          unint64_t v165 = &v164[2 * v163];
          do
          {
            unint64_t v166 = v163 >> 1;
            unint64_t v167 = &v164[2 * (v163 >> 1)];
            unint64_t v169 = *v167;
            uint64_t v168 = v167 + 2;
            v163 += ~(v163 >> 1);
            if (v169 < v162) {
              unint64_t v164 = v168;
            }
            else {
              unint64_t v163 = v166;
            }
          }
          while (v163);
          if (v164 != v165 && *v164 == v162) {
            unint64_t v170 = (void *)v164[1];
          }
          else {
LABEL_151:
          }
            unint64_t v170 = 0;
          v264[0] = v160;
          v264[1] = v170;
          uint64_t v171 = mlir::ShapedType::getShape((mlir::ShapedType *)v264);
          unint64_t v173 = v172;
          unint64_t v174 = mlir::anec::getIndexFromDim(3, v156);
          unint64_t v175 = mlir::anec::getIndexFromDim(4, v173);
          float v176 = (float)*(uint64_t *)(v154 + 8 * v174);
          float v177 = (float)*(uint64_t *)(v154 + 8 * v175);
          float v178 = (float)*(uint64_t *)(v171 + 8 * v174);
          float v179 = (float)*(uint64_t *)(v171 + 8 * v175);
          BOOL v180 = v140 != 0.0;
          if (v139 != 0.0) {
            BOOL v180 = 1;
          }
          BOOL v181 = (v132 + -1.0) * 0.5 != v140 || (v131 + -1.0) * 0.5 != v139;
          uint64_t v97 = (unsigned int *)a2;
          BOOL v182 = v132 != (float)(v178 / v176) || v131 != (float)(v179 / v177);
          BOOL v183 = v132 != (float)((float)(v178 + -1.0) / (float)(v176 + -1.0))
              || v131 != (float)((float)(v179 + -1.0) / (float)(v177 + -1.0));
          if (v180 || v182)
          {
            if (v180 || v183)
            {
              if (!v181 && !v182)
              {
                BOOL InferredResultTypes = 0;
                BOOL IsSize = 1;
                uint64_t v97 = (unsigned int *)a2;
                goto LABEL_172;
              }
LABEL_211:
              uint64_t v194 = *(void *)(a4 + 16);
              if (v194)
              {
                uint64_t v195 = v253;
                if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
              }
                }
              uint64_t v110 = 0;
              int v111 = 0;
              uint64_t v97 = (unsigned int *)a2;
LABEL_271:
              if (__dst != v279) {
                free(__dst);
              }
              if (v280 != v282) {
                free(v280);
              }
              if (v283 != v285) {
                free(v283);
              }
              goto LABEL_93;
            }
            BOOL IsSize = 1;
            BOOL InferredResultTypes = 1;
LABEL_169:
            if (IsSize)
            {
              v264[0] = &v265;
              long long v265 = 0uLL;
              goto LABEL_178;
            }
LABEL_172:
            if (InferredResultTypes || IsSize)
            {
              if (InferredResultTypes || !IsSize)
              {
                uint64_t v189 = *(void *)(a4 + 16);
                if (v189)
                {
                  BOOL v190 = v253;
                  if (mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
                }
                  }
                uint64_t v110 = 0;
                int v111 = 0;
                goto LABEL_271;
              }
              v264[0] = &v265;
              float v184 = &unk_211ED5510;
            }
            else
            {
              v264[0] = &v265;
              float v184 = &unk_211F1A430;
            }
            memset_pattern16(&v265, v184, 0x10uLL);
LABEL_178:
            v264[1] = (void *)0x600000002;
            uint64_t v185 = v278;
            if (v278 >= 2)
            {
              *(_OWORD *)__dst = v265;
            }
            else
            {
              if (HIDWORD(v278) > 1)
              {
                if (v278) {
                  memmove(__dst, &v265, 8 * v278);
                }
                else {
                  uint64_t v185 = 0;
                }
              }
              else
              {
                LODWORD(v278) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v279, 2uLL, 8);
                uint64_t v185 = 0;
              }
              if (v185 != LODWORD(v264[1])) {
                memcpy((char *)__dst + 8 * v185, (char *)v264[0] + 8 * v185, 8 * LODWORD(v264[1]) - 8 * v185);
              }
            }
            LODWORD(v278) = 2;
            LODWORD(v264[1]) = 0;
            if (v264[0] != &v265) {
              free(v264[0]);
            }
            v264[0] = (void *)2;
            uint64_t v196 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v197 = (void *)mlir::RankedTensorType::get((uint64_t)v264, 1, v196, 0);
            v198 = v197;
            if (!v197) {
              goto LABEL_229;
            }
            uint64_t v199 = *v197;
            unint64_t v200 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v201 = *(unsigned int *)(v199 + 16);
            if (!v201) {
              goto LABEL_229;
            }
            uint64_t v202 = *(void **)(v199 + 8);
            unint64_t v203 = &v202[2 * v201];
            do
            {
              unint64_t v204 = v201 >> 1;
              unint64_t v205 = &v202[2 * (v201 >> 1)];
              unint64_t v207 = *v205;
              v206 = v205 + 2;
              v201 += ~(v201 >> 1);
              if (v207 < v200) {
                uint64_t v202 = v206;
              }
              else {
                unint64_t v201 = v204;
              }
            }
            while (v201);
            if (v202 != v203 && *v202 == v200) {
              uint64_t v208 = v202[1];
            }
            else {
LABEL_229:
            }
              uint64_t v208 = 0;
            v254 = (uint64_t **)mlir::DenseElementsAttr::getFromRawBuffer(v198, v208, __dst, 8 * v278, 8, 1, 0);
            uint64_t v209 = v286;
            unint64_t v210 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v263, -1.0);
            uint64_t v211 = llvm::APFloatBase::IEEEsingle(v210);
            llvm::APFloat::Storage::Storage(&v264[1], v263, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v263);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v255, -1.0);
            llvm::APFloat::Storage::Storage(&v263[1], v255, v211);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v255);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v243, v9, &v252, v209, v209 + 1, (uint64_t)v264, (uint64_t)v263, &v248, (uint64_t *)&v254);
            v255[0] = v110;
            unint64_t v212 = (void *)v263[1];
            BOOL v213 = llvm::APFloatBase::PPCDoubleDouble(v110);
            if (v213 == v212) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v263[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v263[1]);
            }
            if (v213 == v264[1]) {
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v264[1]);
            }
            else {
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v264[1]);
            }
            uint64_t v97 = (unsigned int *)a2;
            if (v242 != 1) {
              goto LABEL_254;
            }
            v264[0] = &v265;
            *(void *)&long long v265 = v37;
            *((void *)&v265 + 1) = v245;
            unint64_t v266 = v38;
            unint64_t v267 = v37;
            unint64_t v268 = v245;
            unint64_t v269 = v38;
            v264[1] = (void *)0x600000006;
            *(_OWORD *)long long v263 = xmmword_211F1A410;
            uint64_t v214 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
            uint64_t v215 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v214, 0);
            uint64_t v216 = v215;
            if (!v215) {
              goto LABEL_246;
            }
            uint64_t v217 = *v215;
            unint64_t v218 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v219 = *(unsigned int *)(v217 + 16);
            if (v219)
            {
              uint64_t v220 = *(void **)(v217 + 8);
              uint64_t v221 = &v220[2 * v219];
              do
              {
                unint64_t v222 = v219 >> 1;
                unint64_t v223 = &v220[2 * (v219 >> 1)];
                unint64_t v225 = *v223;
                uint64_t v224 = v223 + 2;
                v219 += ~(v219 >> 1);
                if (v225 < v218) {
                  uint64_t v220 = v224;
                }
                else {
                  unint64_t v219 = v222;
                }
              }
              while (v219);
              uint64_t v97 = (unsigned int *)a2;
              if (v220 == v221 || *v220 != v218)
              {
LABEL_246:
                uint64_t v226 = 0;
                goto LABEL_252;
              }
              uint64_t v226 = v220[1];
            }
            else
            {
              uint64_t v226 = 0;
              uint64_t v97 = (unsigned int *)a2;
            }
LABEL_252:
            uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v216, v226, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
            uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v255, &v247);
            if (v264[0] != &v265) {
              free(v264[0]);
            }
LABEL_254:
            mlir::ShapedType::getShape((mlir::ShapedType *)v251);
            if (v227 <= 3)
            {
              v264[0] = &v265;
              *(void *)&long long v265 = v37;
              *((void *)&v265 + 1) = v244;
              unint64_t v266 = v38;
              unint64_t v267 = v37;
              unint64_t v268 = v244;
              unint64_t v269 = v38;
              v264[1] = (void *)0x600000006;
              *(_OWORD *)long long v263 = xmmword_211F1A410;
              uint64_t v228 = mlir::Builder::getIntegerType(v243, 0x40u, 0);
              unint64_t v229 = (void *)mlir::RankedTensorType::get((uint64_t)v263, 2, v228, 0);
              uint64_t v230 = v229;
              if (v229
                && (uint64_t v231 = *v229,
                    unint64_t v232 = mlir::TypeID::get<mlir::ShapedType>(),
                    unint64_t v233 = *(unsigned int *)(v231 + 16),
                    v233))
              {
                v234 = *(void **)(v231 + 8);
                uint64_t v235 = &v234[2 * v233];
                do
                {
                  unint64_t v236 = v233 >> 1;
                  unint64_t v237 = &v234[2 * (v233 >> 1)];
                  unint64_t v239 = *v237;
                  v238 = v237 + 2;
                  v233 += ~(v233 >> 1);
                  if (v239 < v232) {
                    v234 = v238;
                  }
                  else {
                    unint64_t v233 = v236;
                  }
                }
                while (v233);
                if (v234 != v235 && *v234 == v232) {
                  uint64_t v240 = v234[1];
                }
                else {
                  uint64_t v240 = 0;
                }
              }
              else
              {
                uint64_t v240 = 0;
              }
              uint64_t v247 = mlir::DenseElementsAttr::getFromRawBuffer(v230, v240, v264[0], 8 * LODWORD(v264[1]), 8, 1, 0);
              v263[0] = (uint64_t)v110 - 16;
              uint64_t v110 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v243, v9, v263, &v247);
              if (v264[0] != &v265) {
                free(v264[0]);
              }
              uint64_t v97 = (unsigned int *)a2;
            }
            int v111 = 1;
            goto LABEL_271;
          }
          BOOL IsSize = 0;
          BOOL InferredResultTypes = 0;
        }
        if (!InferredResultTypes) {
          goto LABEL_172;
        }
        goto LABEL_169;
      }
LABEL_87:
      uint64_t v107 = 0;
      goto LABEL_106;
    }
    unint64_t v88 = "Shape operand was not a constant";
  }
  else
  {
    unint64_t v88 = "Resize layout not supported";
  }
  v270[0] = (void *)v88;
  LOWORD(v272) = 259;
  uint64_t v108 = v253;
  v264[0] = v270;
  uint64_t v109 = *(void *)(a4 + 16);
  if (v109 && mlir::RewriterBase::Listener::classof(*(void *)(a4 + 16))) {
    (*(void (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v109 + 64))(v109, *((void *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
  }
  uint64_t v110 = 0;
  int v111 = 0;
  uint64_t v97 = (unsigned int *)a2;
LABEL_93:
  if (v286 != v288) {
    free(v286);
  }
  if (v289 != (mlir::Operation *)v291) {
    free(v289);
  }
  if (v111)
  {
    v270[0] = (char *)v110 - 16;
    uint64_t v112 = 1;
    mlir::ValueRange::ValueRange(v256, (uint64_t)v270, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v97, v256[0], v256[1]);
  }
  else
  {
    v270[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v272) = 259;
    v264[0] = v270;
    uint64_t v113 = *(void *)(a4 + 16);
    if (v113 && mlir::RewriterBase::Listener::classof(v113)) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v113 + 64))(v113, *((void *)v97 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v264);
    }
    else {
      return 0;
    }
  }
  return v112;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void mlir::anonymous namespace'::ConvertInstanceNorm::~ConvertInstanceNorm(mlir::_anonymous_namespace_::ConvertInstanceNorm *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertInstanceNorm::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, mlir::mps::detail::CastOpGenericAdaptorBase *a3, uint64_t a4)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v57 = a2;
  long long v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v56[0] = v6;
  v56[1] = v16;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  unint64_t v18 = *((void *)a3 + 6);
  *(void *)&long long v58 = v18;
  *((void *)&v58 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v18 = mlir::ValueRange::offset_base(&v58, ODSOperandIndexAndLength);
  }
  long long v58 = v18;
  uint64_t v19 = (void *)mlir::ValueRange::dereference_iterator(&v58, 0);
  mlir::ShapedType::getShape((mlir::ShapedType *)v56);
  v55[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v19, v20, 0, 0);
  v55[1] = v21;
  if (!(_BYTE)v21) {
    return 0;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v23 = *((void *)a3 + 6);
  *(void *)&long long v58 = v23;
  *((void *)&v58 + 1) = v22;
  if (v22) {
    unint64_t v23 = mlir::ValueRange::offset_base(&v58, v22);
  }
  long long v58 = v23;
  uint64_t v24 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v58, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24) {
    goto LABEL_25;
  }
  uint64_t v25 = *v24;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_25;
  }
  long long v28 = *(void **)(v25 + 8);
  long long v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unint64_t v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      long long v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_25:
  }
    uint64_t v34 = 0;
  v54[0] = mlir::getRankPromotionTypeForANE((uint64_t)v24, v34);
  v54[1] = (uint64_t)v35;
  uint64_t v36 = *((void *)v57 + 3);
  uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v35);
  LOBYTE(v58) = 0;
  char v59 = 0;
  v52[0] = mlir::ShapedType::cloneWith(v54, &v58, F16Type);
  v52[1] = v38;
  unsigned int v39 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v40 = *((void *)a3 + 6);
  *(void *)&long long v58 = v40;
  *((void *)&v58 + 1) = v39;
  if (v39) {
    unint64_t v40 = mlir::ValueRange::offset_base(&v58, v39);
  }
  long long v58 = v40;
  *(void *)&long long v58 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v36, v52, (uint64_t *)&v58)- 16;
  uint64_t v41 = *((void *)v57 + 3);
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon(a3, (uint64_t)&v58);
  uint64_t v42 = mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>((mlir::Float32Type **)(a4 + 8), v41, &v53, v55, (uint64_t)&v58);
  uint64_t v53 = (uint64_t)v42 - 16;
  uint64_t v43 = (void *)*((void *)&v58 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v42) == v43) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v58 + 8));
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v58 + 8));
  }
  uint64_t v45 = *((void *)v57 + 3);
  unsigned int v46 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  unint64_t v47 = *((void *)a3 + 6);
  *(void *)&long long v58 = v47;
  *((void *)&v58 + 1) = v46;
  if (v46) {
    unint64_t v47 = mlir::ValueRange::offset_base(&v58, v46);
  }
  long long v58 = v47;
  uint64_t v48 = mlir::ValueRange::dereference_iterator(&v58, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v48);
  LOBYTE(v58) = 0;
  char v59 = 0;
  *(void *)&long long v58 = mlir::ShapedType::cloneWith(v54, &v58, ElementTypeOrSelf);
  *((void *)&v58 + 1) = v50;
  uint64_t v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v45, (uint64_t *)&v58, &v53)- 16;
  uint64_t v44 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v57, (uint64_t)&v53, 1);
  return v44;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v29[38] = *MEMORY[0x263EF8340];
  uint64_t v22 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.instance_norm", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    __int16 v26 = 1283;
    void v25[2] = (uint64_t)"anec.instance_norm";
    v25[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v11);
  uint64_t v13 = *a3;
  uint64_t v14 = *a4;
  uint64_t v16 = *(void **)(a5 + 8);
  unint64_t v15 = (void *)(a5 + 8);
  unint64_t v18 = llvm::APFloatBase::PPCDoubleDouble(v17);
  if (v18 == v16) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v15);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v15);
  }
  mlir::anec::InstanceNorm::build(a1, (uint64_t)v29, v13, v14, (uint64_t)v27);
  if (v18 == (void *)v28[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  }
  uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((void *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InstanceNorm,void>::id) {
    unint64_t v20 = v19;
  }
  else {
    unint64_t v20 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

void mlir::anonymous namespace'::ConvertPermute::~ConvertPermute(mlir::_anonymous_namespace_::ConvertPermute *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  v51[6] = *MEMORY[0x263EF8340];
  uint64_t v43 = a2;
  long long v45 = *(_OWORD *)(a3 + 40);
  if (*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v43) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v5 = (void *)mlir::ValueRange::dereference_iterator(&v45, 1);
  unsigned int v46 = &v41;
  uint64_t v49 = v5;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v49);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v46, DefiningOp))
  {
    uint64_t v8 = v42;
    uint64_t v7 = v43;
    long long v9 = v45;
    uint64_t v10 = v41;
    uint64_t v11 = (uint64_t *)(*(void *)(*(void *)(*((void *)v43 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v11) {
      goto LABEL_14;
    }
    uint64_t v12 = *v11;
    unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_14;
    }
    uint64_t v15 = *(void **)(v12 + 8);
    uint64_t v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      unint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      uint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        uint64_t v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_14:
    }
      uint64_t v21 = 0;
    v44[0] = v11;
    v44[1] = v21;
    uint64_t v49 = v51;
    uint64_t v50 = 0x600000000;
    mlir::getIntValues<long long>(v10, v8, (uint64_t)&v49, 1);
    unsigned int v46 = v48;
    uint64_t v47 = 0x400000000;
    uint64_t v22 = (uint64_t *)v49;
    uint64_t v23 = v50;
    mlir::ShapedType::getShape((mlir::ShapedType *)v44);
    char PositivePromotedAxes = mlir::getPositivePromotedAxes(v22, v23, v24, (uint64_t)&v46, 0, 0);
    if (PositivePromotedAxes)
    {
      if (v47)
      {
        size_t v26 = 8 * v47;
        uint64_t v27 = v46;
        long long v28 = (char *)operator new(v26);
        memcpy(v28, v27, v26);
        long long v29 = &v28[v26];
      }
      else
      {
        long long v28 = 0;
        long long v29 = 0;
      }
      unsigned __int8 v34 = Transpose;
      unint64_t v36 = Transpose >> 8;
      if (v28) {
        operator delete(v28);
      }
      uint64_t v35 = 1;
    }
    else
    {
      unsigned __int8 v34 = 0;
      uint64_t v35 = 0;
      unint64_t v36 = 0;
    }
    if (v46 != v48) {
      free(v46);
    }
    if (v49 != v51) {
      free(v49);
    }
    uint64_t v49 = (void *)(v34 | (v36 << 8));
    uint64_t v50 = v35;
    uint64_t v38 = v43;
    if (PositivePromotedAxes)
    {
      uint64_t v33 = 1;
      mlir::ConversionPatternRewriter::replaceOp(a4, v43, (uint64_t)&v49, 1);
      return v33;
    }
    uint64_t v39 = *(void *)(a4 + 16);
    if (v39 && mlir::RewriterBase::Listener::classof(v39)) {
    return 0;
    }
  }
  uint64_t v30 = *(void *)(a4 + 16);
  if (!v30) {
    return 0;
  }
  uint64_t v31 = v43;
  if (!mlir::RewriterBase::Listener::classof(v30)) {
    return 0;
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Permute can be lowered to Transpose only if indices argument is a constant \n");
}

uint64_t mlir::anonymous namespace'::createTranspose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t a6)
{
  v58[1] = *MEMORY[0x263EF8340];
  v56[0] = a2;
  v56[1] = a3;
  uint64_t v10 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    unint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  v48[0] = v10;
  v48[1] = v20;
  uint64_t v52 = v55;
  int v54 = 4;
  if (a5 < 5)
  {
    if (!a5)
    {
      unsigned int v53 = 0;
      uint64_t v49 = v51;
      uint64_t v50 = 0x500000000;
      goto LABEL_49;
    }
    bzero(v55, 8 * a5);
    uint64_t v21 = (int64x2_t *)v55;
  }
  else
  {
    unsigned int v53 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, a5, 8);
    uint64_t v21 = (int64x2_t *)v52;
    bzero(v52, 8 * a5);
  }
  unsigned int v53 = a5;
  if (!a5) {
    goto LABEL_38;
  }
  unint64_t v22 = (a5 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v22 < 3)
  {
    uint64_t v23 = 0;
    unint64_t v24 = (uint64_t *)v21;
    do
LABEL_21:
      *v24++ = v23++;
    while (v24 != (uint64_t *)((char *)v21 + 8 * a5));
    goto LABEL_22;
  }
  unint64_t v25 = v22 + 1;
  uint64_t v23 = (v22 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  unint64_t v24 = &v21->i64[v23];
  int64x2_t v26 = (int64x2_t)xmmword_211ED5A80;
  uint64_t v27 = v21 + 1;
  int64x2_t v28 = vdupq_n_s64(2uLL);
  int64x2_t v29 = vdupq_n_s64(4uLL);
  uint64_t v30 = v23;
  do
  {
    v27[-1] = v26;
    int64x2_t *v27 = vaddq_s64(v26, v28);
    int64x2_t v26 = vaddq_s64(v26, v29);
    v27 += 2;
    v30 -= 4;
  }
  while (v30);
  if (v25 != v23) {
    goto LABEL_21;
  }
LABEL_22:
  if (a5)
  {
    uint64_t v31 = 8 * a5;
    do
    {
      uint64_t v32 = v21->i64[0];
      mlir::ShapedType::getShape((mlir::ShapedType *)v48);
      if (v32 == 2) {
        uint64_t v34 = 3;
      }
      else {
        uint64_t v34 = v32;
      }
      if (v32) {
        uint64_t v35 = 3;
      }
      else {
        uint64_t v35 = 1;
      }
      if (v33 != 2) {
        uint64_t v35 = v32;
      }
      if (v33 != 3) {
        uint64_t v34 = v35;
      }
      if (v33 < 2) {
        uint64_t v34 = 3;
      }
      v21->i64[0] = v34;
      uint64_t v21 = (int64x2_t *)((char *)v21 + 8);
      v31 -= 8;
    }
    while (v31);
    uint64_t v21 = (int64x2_t *)v52;
    unsigned int v36 = v53;
    goto LABEL_39;
  }
LABEL_38:
  unsigned int v36 = a5;
LABEL_39:
  uint64_t v49 = v51;
  uint64_t v50 = 0x500000000;
  if (v36)
  {
    unsigned int v37 = 0;
    uint64_t v38 = 8 * v36 - 8;
    uint64_t v39 = 8 * a5 - 8;
    do
    {
      uint64_t v40 = *a4;
      uint64_t v41 = v21->i64[0];
      if (*a4 != v21->i64[0])
      {
        if (v37 >= HIDWORD(v50))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v37 + 1, 16);
          unsigned int v37 = v50;
        }
        uint64_t v42 = (char *)v49 + 16 * v37;
        *uint64_t v42 = v40;
        v42[1] = v41;
        unsigned int v37 = v50 + 1;
        LODWORD(v50) = v50 + 1;
      }
      if (!v39) {
        break;
      }
      ++a4;
      uint64_t v21 = (int64x2_t *)((char *)v21 + 8);
      uint64_t v43 = v38;
      v38 -= 8;
      v39 -= 8;
    }
    while (v43);
  }
LABEL_49:
  uint64_t v44 = *(void *)(a1 + 24);
  uint64_t v47 = mlir::ValueRange::dereference_iterator(v56, 0);
  v57[0] = v58;
  v57[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>((mlir::Builder *)(a6 + 8), (uint64_t)v57, v44, &v47, (uint64_t)&v49);
  uint64_t v45 = *(void *)v57[0];
  if (v57[0] != v58) {
    free(v57[0]);
  }
  if (v49 != v51) {
    free(v49);
  }
  if (v52 != v55) {
    free(v52);
  }
  return v45;
}

void mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  v25[38] = *MEMORY[0x263EF8340];
  uint64_t v20 = a3;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.transpose";
    v23[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v25, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8));
  unint64_t v14 = (ZinIrHalH13g *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *((void *)a1 + 2);
  if (v15)
  {
    unint64_t v16 = (uint64_t *)*((void *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    ZinIrHalH13g::~ZinIrHalH13g(v14);
    uint64_t v17 = *v16;
    *unint64_t v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    ZinIrHalH13g::~ZinIrHalH13g(v14);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *((void *)a1 + 1);
    if (v19) {
      (*(void (**)(uint64_t, ZinIrHalH13g *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Could not extract valid positive and rank-promoted axes. \n");
}

void mlir::anonymous namespace'::ConvertGatherND::~ConvertGatherND(mlir::_anonymous_namespace_::ConvertGatherND *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unsigned int v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unsigned int v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v200 = *MEMORY[0x263EF8340];
  uint64_t v181 = a2;
  long long v194 = *(_OWORD *)(a3 + 56);
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v180[0] = v5;
  v180[1] = v15;
  uint64_t v16 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_20;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    uint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    __int16 v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      uint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_20:
  }
    uint64_t v26 = 0;
  v179[0] = v16;
  v179[1] = v26;
  uint64_t v27 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27) {
    goto LABEL_30;
  }
  uint64_t v28 = *v27;
  unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v30 = *(unsigned int *)(v28 + 16);
  if (!v30) {
    goto LABEL_30;
  }
  uint64_t v31 = *(void **)(v28 + 8);
  uint64_t v32 = &v31[2 * v30];
  do
  {
    unint64_t v33 = v30 >> 1;
    uint64_t v34 = &v31[2 * (v30 >> 1)];
    unint64_t v36 = *v34;
    uint64_t v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29) {
      uint64_t v31 = v35;
    }
    else {
      unint64_t v30 = v33;
    }
  }
  while (v30);
  if (v31 != v32 && *v31 == v29) {
    uint64_t v37 = v31[1];
  }
  else {
LABEL_30:
  }
    uint64_t v37 = 0;
  v178[0] = v27;
  v178[1] = v37;
  unsigned int Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v181);
  uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v179);
  uint64_t v41 = *(void *)(Shape + 8 * v40 - 8);
  mlir::ShapedType::getShape((mlir::ShapedType *)v180);
  if (v42 > 5
    || (mlir::ShapedType::getShape((mlir::ShapedType *)v179), v43 > 5)
    || (mlir::ShapedType::getShape((mlir::ShapedType *)v178), v44 >= 6))
  {
    uint64_t v45 = *(void *)(a4 + 16);
    if (!v45) {
      return 0;
    }
    uint64_t v46 = v181;
    uint64_t result = mlir::RewriterBase::Listener::classof(v45);
    if (result) {
    return result;
    }
  }
  uint64_t v177 = mlir::ValueRange::dereference_iterator(&v194, 1);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf((void *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    uint64_t v49 = (uint64_t *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v49) {
      goto LABEL_49;
    }
    uint64_t v50 = *v49;
    unint64_t v51 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v52 = *(unsigned int *)(v50 + 16);
    if (!v52) {
      goto LABEL_49;
    }
    unsigned int v53 = *(void **)(v50 + 8);
    int v54 = &v53[2 * v52];
    do
    {
      unint64_t v55 = v52 >> 1;
      unint64_t v56 = &v53[2 * (v52 >> 1)];
      unint64_t v58 = *v56;
      uint64_t v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51) {
        unsigned int v53 = v57;
      }
      else {
        unint64_t v52 = v55;
      }
    }
    while (v52);
    if (v53 != v54 && *v53 == v51) {
      uint64_t v59 = v53[1];
    }
    else {
LABEL_49:
    }
      uint64_t v59 = 0;
    uint64_t v191 = v49;
    uint64_t v192 = v59;
    uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v48);
    LOBYTE(v197) = 0;
    LOBYTE(v198) = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v191, &v197, F16Type);
    uint64_t v61 = *(void *)(v181 + 24);
    uint64_t v191 = (void *)mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v62);
    *(void *)&long long v197 = &v198;
    *((void *)&v197 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(a4 + 8, (uint64_t)&v197, v61, &v177, (uint64_t *)&v191);
    uint64_t v63 = *(void *)v197;
    if ((uint64_t *)v197 != &v198) {
      free((void *)v197);
    }
    uint64_t v177 = v63;
  }
  uint64_t v64 = Count;
  uint64_t v191 = v193;
  uint64_t v192 = 0x500000000;
  unint64_t v65 = (unsigned char *)mlir::ShapedType::getShape((mlir::ShapedType *)v180);
  uint64_t v66 = mlir::ShapedType::getShape((mlir::ShapedType *)v180);
  unsigned int v67 = 0;
  uint64_t v69 = (unsigned char *)(v66 + 8 * v68);
  LODWORD(v192) = 0;
  unint64_t v70 = (v69 - v65) >> 3;
  if (v70 > HIDWORD(v192))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v191, v193, v70, 8);
    unsigned int v67 = v192;
  }
  if (v69 != v65)
  {
    memcpy((char *)v191 + 8 * v67, v65, v69 - v65);
    unsigned int v67 = v192;
  }
  LODWORD(v192) = v67 + ((unint64_t)(v69 - v65) >> 3);
  mlir::ShapedType::getShape((mlir::ShapedType *)v179);
  uint64_t v72 = v71 + ~(v41 + v64);
  uint64_t v73 = v72 & ~(v72 >> 63);
  if (v72 >= 1)
  {
    uint64_t v74 = v72 & ~(v72 >> 63);
    do
    {
      *(void *)&long long v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191 + 8 * v64, (uint64_t *)&v197);
      --v74;
    }
    while (v74);
  }
  unsigned int v75 = v192;
  uint64_t v76 = 5 - v192;
  if (v192 <= 4)
  {
    uint64_t v77 = v76 <= 1 ? 1 : 5 - v192;
    *(void *)&long long v197 = 1;
    llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
    if (v75 <= 3)
    {
      *(void *)&long long v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
      if (v77 != 2)
      {
        *(void *)&long long v197 = 1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
        if (v77 != 3)
        {
          *(void *)&long long v197 = 1;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          if (v77 != 4)
          {
            *(void *)&long long v197 = 1;
            llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          }
        }
      }
    }
  }
  unint64_t v188 = v190;
  uint64_t v78 = (char *)v191;
  unint64_t v79 = (char *)v191 + 8 * v76 + 8 * v64;
  uint64_t v189 = 0x500000000;
  size_t v80 = 8 * v76 + 8 * v64;
  if (v80 >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, (uint64_t)v80 >> 3, 8);
    unsigned int v81 = v189;
    if (v78 == v79) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }
  unsigned int v81 = 0;
  if (v191 != v79)
  {
LABEL_76:
    memcpy((char *)v188 + 8 * v81, v78, v80);
    unsigned int v81 = v189;
  }
LABEL_77:
  unsigned int v82 = v81 + (v80 >> 3);
  LODWORD(v189) = v82;
  unint64_t v83 = -v72 & ~(-v72 >> 63);
  if (v72 < 0)
  {
    if (v83 <= 1) {
      uint64_t v95 = 1;
    }
    else {
      uint64_t v95 = -v72 & ~(-v72 >> 63);
    }
    do
    {
      if (v82 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v82 + 1, 8);
        unsigned int v82 = v189;
      }
      *((void *)v188 + v82) = 1;
      unsigned int v82 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      --v95;
    }
    while (v95);
  }
  uint64_t v84 = (char *)v188 + 8 * v82;
  unint64_t v85 = (char *)(mlir::ShapedType::getShape((mlir::ShapedType *)v179) + 8 * v64);
  uint64_t v86 = mlir::ShapedType::getShape((mlir::ShapedType *)v179);
  llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v188, (uint64_t)v84, v85, (char *)(v86 + 8 * v87 - 8));
  uint64_t v88 = v73 + v64 + v76;
  uint64_t v89 = 5 - (v41 + v88);
  if (v89 >= 1)
  {
    uint64_t v90 = 0;
    unsigned int v91 = v189;
    do
    {
      if (v91 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v91 + 1, 8);
        unsigned int v91 = v189;
      }
      *((void *)v188 + v91) = 1;
      unsigned int v91 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      ++v90;
    }
    while (v90 < v89);
  }
  uint64_t v185 = v187;
  uint64_t v186 = 0x500000000;
  LODWORD(v92) = 0;
  if (v41)
  {
    uint64_t v93 = v41;
    do
    {
      if (v92 >= HIDWORD(v186))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v185, v187, v92 + 1, 8);
        LODWORD(v92) = v186;
      }
      *((void *)v185 + v92) = v88;
      LODWORD(v92) = v186 + 1;
      LODWORD(v186) = v186 + 1;
      ++v88;
      --v93;
    }
    while (v93);
    uint64_t v94 = v185;
  }
  else
  {
    uint64_t v94 = v187;
  }
  BOOL v182 = v184;
  uint64_t v183 = 0x500000000;
  if (*(void *)&v94[8 * v92 - 8] <= 2uLL)
  {
    uint64_t v92 = v92;
  }
  else
  {
    unint64_t v96 = (uint64_t *)(*(void *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v96) {
      goto LABEL_107;
    }
    uint64_t v97 = *v96;
    unint64_t v98 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v99 = *(unsigned int *)(v97 + 16);
    if (!v99) {
      goto LABEL_107;
    }
    unint64_t v100 = *(void **)(v97 + 8);
    uint64_t v101 = &v100[2 * v99];
    do
    {
      unint64_t v102 = v99 >> 1;
      unint64_t v103 = &v100[2 * (v99 >> 1)];
      unint64_t v105 = *v103;
      uint64_t v104 = v103 + 2;
      v99 += ~(v99 >> 1);
      if (v105 < v98) {
        unint64_t v100 = v104;
      }
      else {
        unint64_t v99 = v102;
      }
    }
    while (v99);
    if (v100 != v101 && *v100 == v98) {
      uint64_t v106 = v100[1];
    }
    else {
LABEL_107:
    }
      uint64_t v106 = 0;
    *(void *)&long long v197 = v96;
    *((void *)&v197 + 1) = v106;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v197);
    unsigned int v108 = v183;
    if (v107)
    {
      uint64_t v109 = v107;
      unint64_t v110 = 0;
      uint64_t v111 = *((void *)v185 + v186 - 1);
      uint64_t v112 = v83 + v107 - v111 + 1;
      uint64_t v113 = v107 - 1;
      uint64_t v114 = v83 - v111 + v107 + 1;
      do
      {
        if (v114 == v110) {
          uint64_t v115 = v113;
        }
        else {
          uint64_t v115 = (__PAIR128__(v110, v112) - v110) >> 64;
        }
        if (v108 >= HIDWORD(v183))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v182, v184, v108 + 1, 8);
          unsigned int v108 = v183;
        }
        *((void *)v182 + v108) = v115;
        unsigned int v108 = v183 + 1;
        LODWORD(v183) = v183 + 1;
        ++v110;
      }
      while (v109 != v110);
    }
    uint64_t v116 = v182;
    uint64_t v117 = *(void *)(v181 + 24);
    *(void *)&long long v197 = &v198;
    *((void *)&v197 + 1) = 0x500000000;
    if (v108)
    {
      uint64_t v118 = 0;
      uint64_t v119 = 8 * v108;
      do
      {
        if (v118 != v116[v118])
        {
          unint64_t __src = v116[v118];
          uint64_t v196 = v118;
          llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v197, v197 + 8 * DWORD2(v197), (char *)&__src, (char *)&v197);
        }
        ++v118;
        v119 -= 8;
      }
      while (v119);
      unint64_t v120 = (unint64_t)DWORD2(v197) >> 1;
    }
    else
    {
      unint64_t v120 = 0;
    }
    unint64_t __src = v120;
    uint64_t v196 = 2;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    uint64_t v122 = (void *)mlir::RankedTensorType::get((uint64_t)&__src, 2, IntegerType, 0);
    unint64_t v123 = v122;
    if (!v122) {
      goto LABEL_134;
    }
    uint64_t v124 = *v122;
    unint64_t v125 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v126 = *(unsigned int *)(v124 + 16);
    if (!v126) {
      goto LABEL_134;
    }
    uint64_t v127 = *(void **)(v124 + 8);
    unint64_t v128 = &v127[2 * v126];
    do
    {
      unint64_t v129 = v126 >> 1;
      uint64_t v130 = &v127[2 * (v126 >> 1)];
      unint64_t v132 = *v130;
      float v131 = v130 + 2;
      v126 += ~(v126 >> 1);
      if (v132 < v125) {
        uint64_t v127 = v131;
      }
      else {
        unint64_t v126 = v129;
      }
    }
    while (v126);
    if (v127 != v128 && *v127 == v125) {
      uint64_t v133 = v127[1];
    }
    else {
LABEL_134:
    }
      uint64_t v133 = 0;
    uint64_t v134 = mlir::DenseElementsAttr::getFromRawBuffer(v123, v133, v197, 8 * DWORD2(v197), 8, 1, 0);
    if ((uint64_t *)v197 != &v198) {
      free((void *)v197);
    }
    *(void *)&long long v197 = v134;
    uint64_t v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v117, &v177, (uint64_t *)&v197)- 16;
    uint64_t v92 = v186;
  }
  *(void *)&long long v197 = v92;
  uint64_t v135 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  unint64_t v136 = (void *)mlir::RankedTensorType::get((uint64_t)&v197, 1, v135, 0);
  uint64_t v137 = v136;
  if (!v136) {
    goto LABEL_147;
  }
  uint64_t v138 = *v136;
  unint64_t v139 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v140 = *(unsigned int *)(v138 + 16);
  if (!v140) {
    goto LABEL_147;
  }
  unsigned int v141 = *(void **)(v138 + 8);
  uint64_t v142 = &v141[2 * v140];
  do
  {
    unint64_t v143 = v140 >> 1;
    uint64_t v144 = &v141[2 * (v140 >> 1)];
    unint64_t v146 = *v144;
    unint64_t v145 = v144 + 2;
    v140 += ~(v140 >> 1);
    if (v146 < v139) {
      unsigned int v141 = v145;
    }
    else {
      unint64_t v140 = v143;
    }
  }
  while (v140);
  if (v141 != v142 && *v141 == v139) {
    uint64_t v147 = v141[1];
  }
  else {
LABEL_147:
  }
    uint64_t v147 = 0;
  unint64_t __src = mlir::DenseElementsAttr::getFromRawBuffer(v137, v147, v185, 8 * v186, 8, 1, 0);
  long long v148 = (uint64_t *)v191;
  unint64_t v149 = (mlir::AffineMap *)v192;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v180);
  uint64_t v175 = mlir::MemRefType::get(v148, v149, OperandRange, 0, 0, 0);
  long long v197 = *(_OWORD *)v188;
  uint64_t v198 = *((void *)v188 + 2) * v41;
  long long v199 = *(_OWORD *)((char *)v188 + 24);
  uint64_t v151 = mlir::getElementTypeOrSelf(v177);
  uint64_t v174 = mlir::MemRefType::get((uint64_t *)&v197, (mlir::AffineMap *)5, v151, 0, 0, 0);
  uint64_t v152 = *(void *)(v181 + 24);
  *(void *)&long long v197 = mlir::ValueRange::dereference_iterator(&v194, 0);
  uint64_t v173 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v152, &v175, (uint64_t *)&v197)- 16;
  uint64_t v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(void *)(v181 + 24), &v174, &v177)- 16;
  unint64_t v172 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v181 + 24), &v173, &v177, (uint64_t *)&__src);
  unint64_t v153 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v178);
  unint64_t v155 = v154;
  uint64_t v156 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v178);
  uint64_t v157 = (uint64_t *)mlir::MemRefType::get(v153, v155, v156, 0, 0, 0);
  uint64_t v158 = (uint64_t)v157;
  uint64_t v159 = v181;
  if (!v157) {
    goto LABEL_157;
  }
  uint64_t v160 = *v157;
  unint64_t v161 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v162 = *(unsigned int *)(v160 + 16);
  if (!v162) {
    goto LABEL_157;
  }
  unint64_t v163 = *(void **)(v160 + 8);
  unint64_t v164 = &v163[2 * v162];
  do
  {
    unint64_t v165 = v162 >> 1;
    unint64_t v166 = &v163[2 * (v162 >> 1)];
    unint64_t v168 = *v166;
    unint64_t v167 = v166 + 2;
    v162 += ~(v162 >> 1);
    if (v168 < v161) {
      unint64_t v163 = v167;
    }
    else {
      unint64_t v162 = v165;
    }
  }
  while (v162);
  if (v163 != v164 && *v163 == v161) {
    uint64_t v169 = v163[1];
  }
  else {
LABEL_157:
  }
    uint64_t v169 = 0;
  *(void *)&long long v197 = mlir::getRankPromotionTypeForANE(v158, v169);
  *((void *)&v197 + 1) = v170;
  uint64_t v171 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 8), *(void *)(v159 + 24), (uint64_t *)&v197, &v172);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v159, v171);
  if (v182 != v184) {
    free(v182);
  }
  if (v185 != v187) {
    free(v185);
  }
  if (v188 != v190) {
    free(v188);
  }
  if (v191 != v193) {
    free(v191);
  }
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  v21[38] = *MEMORY[0x263EF8340];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gather_nd", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    __int16 v20 = 1283;
    unint64_t v19[2] = (uint64_t)"anec.gather_nd";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GatherND::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  uint64_t v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GatherND,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(mlir::mps::GatherNDOp,mlir::mps::GatherNDOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Inputs / output with rank > 5 not supported");
}

void mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  v25[38] = *MEMORY[0x263EF8340];
  uint64_t v20 = a3;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"mps.cast";
    v23[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::CastOp::build((mlir::UnknownLoc **)a1, (uint64_t)v25, *a4, *a5);
  unint64_t v14 = (ZinIrHalH13g *)mlir::Operation::create((mlir::Operation *)v25, v13);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15)
  {
    uint64_t v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    ZinIrHalH13g::~ZinIrHalH13g(v14);
    uint64_t v17 = *v16;
    *__int16 v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(void *)(v17 + 8) = v18;
    uint64_t *v16 = (uint64_t)v18;
    ZinIrHalH13g::~ZinIrHalH13g(v14);
  }
  if (mlir::OpBuilder::tryFold((void *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 8);
    if (v19) {
      (*(void (**)(uint64_t, ZinIrHalH13g *))(*(void *)v19 + 16))(v19, v14);
    }
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    char v12 = v11;
  }
  else {
    char v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anonymous namespace'::ConvertGather::~ConvertGather(mlir::_anonymous_namespace_::ConvertGather *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertGather::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::mps::detail::GatherOpGenericAdaptorBase *a3, mlir::Float16Type **a4)
{
  uint64_t v169 = *MEMORY[0x263EF8340];
  uint64_t v152 = a2;
  uint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v151[0] = v6;
  v151[1] = v16;
  uint64_t v17 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  __int16 v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    __int16 v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  v150[0] = v17;
  v150[1] = v27;
  long long v28 = (uint64_t *)(*(void *)(mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&v152) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v28) {
    goto LABEL_30;
  }
  uint64_t v29 = *v28;
  unint64_t v30 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v31 = *(unsigned int *)(v29 + 16);
  if (!v31) {
    goto LABEL_30;
  }
  uint64_t v32 = *(void **)(v29 + 8);
  __int16 v33 = &v32[2 * v31];
  do
  {
    unint64_t v34 = v31 >> 1;
    uint64_t v35 = &v32[2 * (v31 >> 1)];
    unint64_t v37 = *v35;
    unint64_t v36 = v35 + 2;
    v31 += ~(v31 >> 1);
    if (v37 < v30) {
      uint64_t v32 = v36;
    }
    else {
      unint64_t v31 = v34;
    }
  }
  while (v31);
  if (v32 != v33 && *v32 == v30) {
    uint64_t v38 = v32[1];
  }
  else {
LABEL_30:
  }
    uint64_t v38 = 0;
  v149[0] = v28;
  v149[1] = v38;
  unsigned int BatchDims = mlir::mps::detail::GatherOpGenericAdaptorBase::getBatchDims(a3);
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  unint64_t v41 = *((void *)a3 + 7);
  *(void *)&long long v154 = v41;
  *((void *)&v154 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    unint64_t v41 = mlir::ValueRange::offset_base(&v154, ODSOperandIndexAndLength);
  }
  long long v154 = v41;
  uint64_t v148 = mlir::ValueRange::dereference_iterator(&v154, 0);
  uint64_t ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf(v148);
  if ((unint64_t)mlir::getElementBitWidth(ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    uint64_t v43 = (unint64_t *)(*(void *)(v148 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v43) {
      goto LABEL_44;
    }
    unint64_t v44 = *v43;
    unint64_t v45 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v46 = *(unsigned int *)(v44 + 16);
    if (!v46) {
      goto LABEL_44;
    }
    uint64_t v47 = *(void **)(v44 + 8);
    uint64_t v48 = &v47[2 * v46];
    do
    {
      unint64_t v49 = v46 >> 1;
      uint64_t v50 = &v47[2 * (v46 >> 1)];
      unint64_t v52 = *v50;
      unint64_t v51 = v50 + 2;
      v46 += ~(v46 >> 1);
      if (v52 < v45) {
        uint64_t v47 = v51;
      }
      else {
        unint64_t v46 = v49;
      }
    }
    while (v46);
    if (v47 != v48 && *v47 == v45) {
      uint64_t v53 = v47[1];
    }
    else {
LABEL_44:
    }
      uint64_t v53 = 0;
    uint64_t v159 = v43;
    uint64_t v160 = v53;
    uint64_t F16Type = mlir::Builder::getF16Type(a4 + 1, v42);
    LOBYTE(v154) = 0;
    v155[0] = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v159, &v154, F16Type);
    uint64_t v55 = *(void *)(v152 + 24);
    uint64_t v159 = (unint64_t *)mlir::Builder::getF16Type(a4 + 1, v56);
    *(void *)&long long v154 = v155;
    *((void *)&v154 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>((uint64_t)(a4 + 1), (uint64_t)&v154, v55, &v148, (uint64_t *)&v159);
    uint64_t v57 = *(void *)v154;
    if ((unsigned char *)v154 != v155) {
      free((void *)v154);
    }
    uint64_t v148 = v57;
  }
  unint64_t v146 = 0;
  unsigned int v58 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 2u);
  unint64_t v59 = *((void *)a3 + 7);
  *(void *)&long long v154 = v59;
  *((void *)&v154 + 1) = v58;
  if (v58) {
    unint64_t v59 = mlir::ValueRange::offset_base(&v154, v58);
  }
  long long v154 = v59;
  uint64_t v60 = mlir::ValueRange::dereference_iterator(&v154, 0);
  uint64_t v159 = (unint64_t *)&v146;
  *(void *)&long long v154 = v60;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v154);
  if (!DefiningOp || !mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(&v159, DefiningOp)) {
    return 0;
  }
  unint64_t v164 = &v166;
  uint64_t v165 = 0x100000000;
  uint64_t v62 = (uint64_t)v146;
  if (!v146) {
    goto LABEL_61;
  }
  uint64_t v63 = *v146;
  unint64_t v64 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v65 = *(unsigned int *)(v63 + 16);
  if (!v65) {
    goto LABEL_61;
  }
  uint64_t v66 = *(void **)(v63 + 8);
  unsigned int v67 = &v66[2 * v65];
  do
  {
    unint64_t v68 = v65 >> 1;
    uint64_t v69 = &v66[2 * (v65 >> 1)];
    unint64_t v71 = *v69;
    unint64_t v70 = v69 + 2;
    v65 += ~(v65 >> 1);
    if (v71 < v64) {
      uint64_t v66 = v70;
    }
    else {
      unint64_t v65 = v68;
    }
  }
  while (v65);
  if (v66 != v67 && *v66 == v64) {
    uint64_t v72 = v66[1];
  }
  else {
LABEL_61:
  }
    uint64_t v72 = 0;
  mlir::getIntValues<long long>(v62, v72, (uint64_t)&v164, 1);
  v162[0] = &v163;
  v162[1] = (void *)0x100000000;
  uint64_t v73 = v164;
  uint64_t v74 = v165;
  mlir::ShapedType::getShape((mlir::ShapedType *)v151);
  if (mlir::getPositiveAxes(v73, v74, v75, (uint64_t)v162, 0, 0, 0))
  {
    uint64_t v141 = *(void *)v162[0];
    mlir::ShapedType::getShape((mlir::ShapedType *)v151);
    uint64_t v77 = v76;
    uint64_t Shape = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v151);
    uint64_t v80 = v78;
    uint64_t v159 = (unint64_t *)v161;
    uint64_t v160 = 0x500000000;
    if ((unint64_t)(8 * v78) < 0x29)
    {
      int v81 = 0;
      uint64_t v82 = BatchDims;
      if (!v78) {
        goto LABEL_70;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v159, v161, (8 * v78) >> 3, 8);
      int v81 = v160;
      uint64_t v82 = BatchDims;
      if (!v80)
      {
LABEL_70:
        LODWORD(v160) = v81 + v80;
        mlir::ShapedType::getShape((mlir::ShapedType *)v150);
        if (v84) {
          mlir::ShapedType::getShape((mlir::ShapedType *)v150);
        }
        else {
          uint64_t v85 = 1;
        }
        llvm::SmallVectorImpl<long long>::insert((uint64_t)&v159, (uint64_t)&v159[*(void *)v162[0]], v85 + ~v82, 1uLL);
        uint64_t v86 = (5 - v160) & ~((5 - v160) >> 63);
        if (v160 <= 4) {
          llvm::SmallVectorImpl<long long>::insert((uint64_t)&v159, (uint64_t)v159, (5 - v160) & ~((5 - v160) >> 63), 1uLL);
        }
        uint64_t v156 = v158;
        uint64_t v87 = v159;
        uint64_t v88 = &v159[v86 + v82];
        uint64_t v157 = 0x500000000;
        uint64_t v89 = (char *)v88 - (char *)v159;
        if ((unint64_t)((char *)v88 - (char *)v159) < 0x29)
        {
          unsigned int v90 = 0;
          if (v159 == v88) {
            goto LABEL_83;
          }
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v156, v158, v89 >> 3, 8);
          unsigned int v90 = v157;
          if (v87 == v88)
          {
LABEL_83:
            unsigned int v91 = v90 + ((unint64_t)v89 >> 3);
            LODWORD(v157) = v91;
            if (*(void *)v162[0] - v82 >= 1) {
              llvm::SmallVectorImpl<long long>::insert((uint64_t)&v156, (uint64_t)v156 + 8 * v91, *(void *)v162[0] - v82, 1uLL);
            }
            uint64_t v93 = (const void *)mlir::ShapedType::getShape((mlir::ShapedType *)v150);
            uint64_t v94 = v92;
            *(void *)&long long v154 = v155;
            *((void *)&v154 + 1) = 0x600000000;
            size_t v95 = 8 * v92;
            if ((unint64_t)(8 * v92) < 0x31)
            {
              unsigned int v96 = 0;
              if (!v92)
              {
LABEL_90:
                unsigned int v97 = v96 + (v95 >> 3);
                DWORD2(v154) = v97;
                if (!v97)
                {
                  if (HIDWORD(v154))
                  {
                    uint64_t v98 = 0;
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v154, v155, 1uLL, 8);
                    uint64_t v98 = DWORD2(v154);
                  }
                  *(void *)(v154 + 8 * v98) = 1;
                  unsigned int v97 = ++DWORD2(v154);
                }
                llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v156, (uint64_t)v156 + 8 * v157, (char *)(v154 + 8 * v82), (char *)(v154 + 8 * v97));
                if (v157 <= 4) {
                  llvm::SmallVectorImpl<long long>::insert((uint64_t)&v156, (uint64_t)v156 + 8 * v157, 5 - v157, 1uLL);
                }
                uint64_t RankPromotionTypeForANE = 1;
                uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
                unint64_t v100 = (void *)mlir::RankedTensorType::get((uint64_t)&RankPromotionTypeForANE, 1, IntegerType, 0);
                uint64_t v101 = v100;
                if (!v100) {
                  goto LABEL_105;
                }
                uint64_t v102 = *v100;
                unint64_t v103 = mlir::TypeID::get<mlir::ShapedType>();
                unint64_t v104 = *(unsigned int *)(v102 + 16);
                if (!v104) {
                  goto LABEL_105;
                }
                unint64_t v105 = *(void **)(v102 + 8);
                uint64_t v106 = &v105[2 * v104];
                do
                {
                  unint64_t v107 = v104 >> 1;
                  unsigned int v108 = &v105[2 * (v104 >> 1)];
                  unint64_t v110 = *v108;
                  uint64_t v109 = v108 + 2;
                  v104 += ~(v104 >> 1);
                  if (v110 < v103) {
                    unint64_t v105 = v109;
                  }
                  else {
                    unint64_t v104 = v107;
                  }
                }
                while (v104);
                if (v105 != v106 && *v105 == v103) {
                  uint64_t v111 = v105[1];
                }
                else {
LABEL_105:
                }
                  uint64_t v111 = 0;
                uint64_t v153 = ((5 - v77) & ~((5 - v77) >> 63)) + v141;
                uint64_t v145 = mlir::DenseElementsAttr::getFromRawBuffer(v101, v111, &v153, 8, 8, 1, 0);
                uint64_t v112 = (uint64_t *)v159;
                uint64_t v113 = (mlir::AffineMap *)v160;
                uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v151);
                uint64_t v153 = mlir::MemRefType::get(v112, v113, OperandRange, 0, 0, 0);
                uint64_t v115 = (uint64_t *)v156;
                uint64_t v116 = (mlir::AffineMap *)v157;
                uint64_t v117 = mlir::getElementTypeOrSelf(v148);
                uint64_t v144 = mlir::MemRefType::get(v115, v116, v117, 0, 0, 0);
                uint64_t v118 = *(void *)(v152 + 24);
                unsigned int v119 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
                unint64_t v120 = *((void *)a3 + 7);
                uint64_t RankPromotionTypeForANE = v120;
                uint64_t v168 = v119;
                if (v119) {
                  unint64_t v120 = mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v119);
                }
                uint64_t RankPromotionTypeForANE = v120;
                uint64_t v168 = 0;
                uint64_t RankPromotionTypeForANE = mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0);
                uint64_t v143 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), v118, &v153, &RankPromotionTypeForANE)- 16;
                uint64_t v148 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(void *)(v152 + 24), &v144, &v148)- 16;
                uint64_t v142 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(a4 + 1, *(void *)(v152 + 24), &v143, &v148, &v145);
                uint64_t v121 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v149);
                unint64_t v123 = v122;
                uint64_t v124 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v149);
                unint64_t v125 = (uint64_t *)mlir::MemRefType::get(v121, v123, v124, 0, 0, 0);
                uint64_t v126 = (uint64_t)v125;
                uint64_t v127 = v152;
                if (!v125) {
                  goto LABEL_117;
                }
                uint64_t v128 = *v125;
                unint64_t v129 = mlir::TypeID::get<mlir::ShapedType>();
                unint64_t v130 = *(unsigned int *)(v128 + 16);
                if (!v130) {
                  goto LABEL_117;
                }
                float v131 = *(void **)(v128 + 8);
                unint64_t v132 = &v131[2 * v130];
                do
                {
                  unint64_t v133 = v130 >> 1;
                  uint64_t v134 = &v131[2 * (v130 >> 1)];
                  unint64_t v136 = *v134;
                  uint64_t v135 = v134 + 2;
                  v130 += ~(v130 >> 1);
                  if (v136 < v129) {
                    float v131 = v135;
                  }
                  else {
                    unint64_t v130 = v133;
                  }
                }
                while (v130);
                if (v131 != v132 && *v131 == v129) {
                  uint64_t v137 = v131[1];
                }
                else {
LABEL_117:
                }
                  uint64_t v137 = 0;
                uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v126, v137);
                uint64_t v168 = v138;
                unint64_t v139 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 1), *(void *)(v127 + 24), &RankPromotionTypeForANE, &v142);
                (*((void (**)(mlir::Float16Type **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, v127, v139);
                if ((unsigned char *)v154 != v155) {
                  free((void *)v154);
                }
                if (v156 != v158) {
                  free(v156);
                }
                if (v159 != (unint64_t *)v161) {
                  free(v159);
                }
                uint64_t v83 = 1;
                goto LABEL_125;
              }
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v154, v155, (8 * v92) >> 3, 8);
              unsigned int v96 = DWORD2(v154);
              if (!v94) {
                goto LABEL_90;
              }
            }
            memcpy((void *)(v154 + 8 * v96), v93, v95);
            unsigned int v96 = DWORD2(v154);
            goto LABEL_90;
          }
        }
        memcpy((char *)v156 + 8 * v90, v87, (char *)v88 - (char *)v87);
        unsigned int v90 = v157;
        goto LABEL_83;
      }
    }
    memcpy(&v159[v81], Shape, 8 * v80);
    int v81 = v160;
    goto LABEL_70;
  }
  uint64_t v83 = 0;
LABEL_125:
  if (v162[0] != &v163) {
    free(v162[0]);
  }
  if (v164 != &v166) {
    free(v164);
  }
  return v83;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

BOOL mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(unint64_t **a1, uint64_t a2)
{
  v10[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v4)) {
    return 0;
  }
  v9[0] = v10;
  v9[1] = (void *)0x100000000;
  mlir::Operation::fold(a2, 0, 0, (uint64_t)v9);
  unint64_t v5 = *(void *)v9[0] & 0xFFFFFFFFFFFFFFF8;
  if (mlir::DenseIntElementsAttr::classof(v5)) {
    unint64_t v6 = v5;
  }
  else {
    unint64_t v6 = 0;
  }
  BOOL v7 = v6 != 0;
  if (v6 && *a1) {
    **a1 = v6;
  }
  if (v9[0] != v10) {
    free(v9[0]);
  }
  return v7;
}

void *mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  unint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (!*(unsigned char *)(a2 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL)) {
      goto LABEL_4;
    }
    return 0;
  }
  if (!InherentAttr) {
    return 0;
  }
LABEL_4:
  uint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  uint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v12 = *v9;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = *(void **)(v12 + 8);
  uint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    uint64_t v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    uint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_13:
  }
    uint64_t v21 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  uint64_t v22 = v34;
  uint64_t v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
  uint64_t v25 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v28 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    long long v29 = mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v28, v29);
    uint64_t v30 = 1;
  }
  else
  {
    uint64_t v30 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  unint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  unint64_t v17 = *(void **)(v14 + 8);
  uint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    unint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      unint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    uint64_t v43 = *(void *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      uint64_t v44 = *(void *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)v70);
  if (v24 != 4)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v70);
    if (v25 != 5)
    {
      uint64_t v43 = *(void *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v44 = *(void *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  uint64_t v26 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_23;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_23;
  }
  uint64_t v30 = *(void **)(v27 + 8);
  unint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      uint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_23:
  }
    uint64_t v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::ShapedType::getShape((mlir::ShapedType *)v70);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    unint64_t v40 = IndexFromDim;
    v71[0] = &v72;
    uint64_t v72 = a7;
    uint64_t v73 = a6;
    uint64_t v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::ShapedType::getShape((mlir::ShapedType *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    uint64_t v68 = v42;
    if (!(_BYTE)v42) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
    if (v66 > 0x40)
    {
      uint64_t v47 = *v65;
      MEMORY[0x21667D390]();
      if (v40 != v47) {
        goto LABEL_51;
      }
    }
    else if (v40 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    uint64_t v48 = v73;
    mlir::ShapedType::getShape((mlir::ShapedType *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    uint64_t v68 = v50;
    if (!(_BYTE)v50) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    unint64_t v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66) {
        goto LABEL_51;
      }
LABEL_47:
      uint64_t v53 = v74;
      mlir::ShapedType::getShape((mlir::ShapedType *)v69);
      unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      uint64_t v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          unint64_t v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
          if (v66 >= 0x41)
          {
            uint64_t v61 = *v65;
            MEMORY[0x21667D390]();
            if (v56 != v61) {
              goto LABEL_51;
            }
          }
          else if (v56 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          uint64_t v46 = 1;
LABEL_59:
          if (v71[0] != &v72) {
            free(v71[0]);
          }
          return v46;
        }
LABEL_54:
        uint64_t v57 = *(void *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          uint64_t v58 = *(void *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      uint64_t v46 = 0;
      goto LABEL_59;
    }
    uint64_t v52 = *v65;
    MEMORY[0x21667D390]();
    if (v51 == v52) {
      goto LABEL_47;
    }
LABEL_51:
    uint64_t v57 = *(void *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      uint64_t v58 = *(void *)(a1 + 24);
LABEL_57:
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void *))(*(void *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  int v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_shuffle", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.pixel_shuffle";
    v17[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelShuffle::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (*(unsigned char *)(a2 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr) {
      return 0;
    }
  }
  else if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
  {
    return 0;
  }
  unint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  char v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v10) {
    goto LABEL_15;
  }
  uint64_t v13 = *v10;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_15;
  }
  __int16 v16 = *(void **)(v13 + 8);
  unint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    unint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    unint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      __int16 v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_15:
  }
    uint64_t v22 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  uint64_t v23 = v34;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  unint64_t v28 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v29 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    uint64_t v30 = mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v29, v30);
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v8;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.channel_to_space", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.channel_to_space";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ChannelToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 56);
  uint64_t v9 = *(void *)(a3 + 64);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      uint64_t v35 = *(void *)(a3 + 64);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (!*(unsigned char *)(a2 + 47)
    || (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL)) {
      goto LABEL_4;
    }
    return 0;
  }
  if (!InherentAttr) {
    return 0;
  }
LABEL_4:
  uint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  uint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v12 = *v9;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = *(void **)(v12 + 8);
  uint64_t v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    __int16 v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    uint64_t v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      uint64_t v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_13:
  }
    uint64_t v21 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  uint64_t v22 = v34;
  uint64_t v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
  uint64_t v25 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v28 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    long long v29 = mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v28, v29);
    uint64_t v30 = 1;
  }
  else
  {
    uint64_t v30 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  unint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  unint64_t v17 = *(void **)(v14 + 8);
  __int16 v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    unint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      unint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    uint64_t v43 = *(void *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      uint64_t v44 = *(void *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)v70);
  if (v24 != 4)
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v70);
    if (v25 != 5)
    {
      uint64_t v43 = *(void *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v44 = *(void *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  uint64_t v26 = (uint64_t *)(*(void *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26) {
    goto LABEL_23;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_23;
  }
  uint64_t v30 = *(void **)(v27 + 8);
  unint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      uint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_23:
  }
    uint64_t v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::ShapedType::getShape((mlir::ShapedType *)v70);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    unint64_t v40 = IndexFromDim;
    v71[0] = &v72;
    uint64_t v72 = a7;
    uint64_t v73 = a6;
    uint64_t v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::ShapedType::getShape((mlir::ShapedType *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    uint64_t v68 = v42;
    if (!(_BYTE)v42) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
    if (v66 > 0x40)
    {
      uint64_t v47 = *v65;
      MEMORY[0x21667D390]();
      if (v40 != v47) {
        goto LABEL_51;
      }
    }
    else if (v40 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    uint64_t v48 = v73;
    mlir::ShapedType::getShape((mlir::ShapedType *)v69);
    unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    uint64_t v68 = v50;
    if (!(_BYTE)v50) {
      goto LABEL_58;
    }
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1) {
      goto LABEL_54;
    }
    unint64_t v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66) {
        goto LABEL_51;
      }
LABEL_47:
      uint64_t v53 = v74;
      mlir::ShapedType::getShape((mlir::ShapedType *)v69);
      unint64_t SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      uint64_t v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          unint64_t v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&v65);
          if (v66 >= 0x41)
          {
            uint64_t v61 = *v65;
            MEMORY[0x21667D390]();
            if (v56 != v61) {
              goto LABEL_51;
            }
          }
          else if (v56 != (uint64_t)((void)v65 << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          uint64_t v46 = 1;
LABEL_59:
          if (v71[0] != &v72) {
            free(v71[0]);
          }
          return v46;
        }
LABEL_54:
        uint64_t v57 = *(void *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          uint64_t v58 = *(void *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      uint64_t v46 = 0;
      goto LABEL_59;
    }
    uint64_t v52 = *v65;
    MEMORY[0x21667D390]();
    if (v51 == v52) {
      goto LABEL_47;
    }
LABEL_51:
    uint64_t v57 = *(void *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      uint64_t v58 = *(void *)(a1 + 24);
LABEL_57:
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void *))(*(void *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  int v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_unshuffle", (const unsigned __int8 *)0x14, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.pixel_unshuffle";
    v17[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelUnshuffle::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v34 = a2;
  long long v38 = *(_OWORD *)(a3 + 56);
  if (*(unsigned char *)(a2 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr) {
      return 0;
    }
  }
  else if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
  {
    return 0;
  }
  unint64_t v35 = (void *)3;
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  char v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  uint64_t Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unsigned int v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  unint64_t v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  void v37[2] = 1;
  uint64_t v36 = 0x300000003;
  if (!v10) {
    goto LABEL_15;
  }
  uint64_t v13 = *v10;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_15;
  }
  __int16 v16 = *(void **)(v13 + 8);
  unint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    unint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    unint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      __int16 v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_15:
  }
    uint64_t v22 = 0;
  uint64_t v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  uint64_t v23 = v34;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  uint64_t Input = mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v34);
  uint64_t v26 = (void *)mlir::ValueRange::dereference_iterator(&v38, 1);
  uint64_t v27 = (void *)mlir::ValueRange::dereference_iterator(&v38, 2);
  unint64_t v28 = (void *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    uint64_t v29 = v34;
    uint64_t v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    uint64_t v30 = mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(void *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(void *)a4 + 32))(a4, v29, v30);
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v35 != v37) {
    free(v35);
  }
  return v8;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_channel", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.space_to_channel";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToChannel::build(a1, (uint64_t)v19, *a3, *a4);
  unsigned int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v108 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  uint64_t v94 = v5;
  unint64_t v6 = (char *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  unsigned int v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t RankPromotionTypeForANE = v6;
  uint64_t v106 = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  unint64_t v18 = v17;
  uint64_t v19 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  uint64_t v106 = v30;
  mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  unint64_t v32 = v31;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(void *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(void *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v38 = mlir::anec::getIndexFromDim(2, v32);
  uint64_t v40 = v39;
  unint64_t v91 = mlir::anec::getIndexFromDim(3, v32);
  unint64_t v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  uint64_t v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&v101);
  if (v102 >= 0x41)
  {
    uint64_t v50 = *(void *)v101;
    MEMORY[0x21667D390]();
    if (IndexFromDim != v50) {
      goto LABEL_26;
    }
  }
  else if (IndexFromDim != (uint64_t)((void)v101 << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  uint64_t RankPromotionTypeForANE = v107;
  uint64_t v106 = 0x300000000;
  uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(Length, (uint64_t)&RankPromotionTypeForANE))
  {
    unint64_t v89 = v41;
    unint64_t v90 = v38;
    uint64_t v101 = &v103;
    uint64_t v104 = 1;
    long long v103 = xmmword_211F1A450;
    uint64_t v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v96, v93[0], 0);
    long long v98 = v96;
    long long v99 = v97;
    unint64_t v100 = RankPromotionTypeForANE;
    uint64_t v52 = v93[0];
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v96, v52, NumElements);
    uint64_t v54 = v96;
    int v55 = BYTE8(v96);
    uint64_t v56 = v97;
    BOOL v58 = (void)v99 == (void)v97 && BYTE8(v98) == BYTE8(v96) && (void)v98 == (void)v96;
    if (v58 || (unint64_t v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(void *)&long long v98 = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v73 = (void *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      uint64_t v74 = v73;
      if (v73
        && (uint64_t v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), v77))
      {
        uint64_t v78 = *(void **)(v75 + 8);
        unint64_t v79 = &v78[2 * v77];
        do
        {
          unint64_t v80 = v77 >> 1;
          int v81 = &v78[2 * (v77 >> 1)];
          unint64_t v83 = *v81;
          uint64_t v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76) {
            uint64_t v78 = v82;
          }
          else {
            unint64_t v77 = v80;
          }
        }
        while (v77);
        if (v78 != v79 && *v78 == v76) {
          uint64_t v84 = v78[1];
        }
        else {
          uint64_t v84 = 0;
        }
      }
      else
      {
        uint64_t v84 = 0;
      }
      uint64_t v40 = 1;
      *(void *)&long long v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, v101, 8 * v102, 8, 1, 0);
      uint64_t v87 = v95;
      uint64_t v88 = mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(void *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      uint64_t v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*(&v98, (llvm::APInt *)&v96);
        unsigned int v61 = DWORD2(v96);
        uint64_t v62 = v96;
        if (v60
          && (DWORD2(v96) > 0x40 ? (uint64_t v63 = *(void *)v96) : (uint64_t v63 = (uint64_t)((void)v96 << -BYTE8(v96)) >> -BYTE8(v96)),
              v63 == v90))
        {
          *((void *)v101 + 2) = *(void *)v100;
          int v64 = 1;
        }
        else
        {
          uint64_t v65 = DWORD2(v96) > 0x40 ? *(void *)v96 : (uint64_t)((void)v96 << -BYTE8(v96)) >> -BYTE8(v96);
          if (v65 == v91)
          {
            *((void *)v101 + 1) = *(void *)v100;
            int v64 = 1;
          }
          else
          {
            uint64_t v66 = *(void *)v100;
            if (v65 == v89)
            {
              *(void *)uint64_t v101 = v66;
              int v64 = 1;
            }
            else if (v66 == 1)
            {
              int v64 = 1;
            }
            else
            {
              uint64_t v40 = a4[2];
              if (v40)
              {
                uint64_t v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2])) {
                else
                }
                  uint64_t v40 = 0;
              }
              int v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62) {
          MEMORY[0x21667D390](v62, 0x1000C8000313F17);
        }
        if (!v64) {
          break;
        }
        uint64_t v68 = v100 + 8;
        *(void *)&long long v99 = v99 + 1;
        v100 += 8;
        if ((void)v99 == v56 && BYTE8(v98) == v55 && (void)v98 == v54 || v68 == v59) {
          goto LABEL_84;
        }
      }
    }
    if (v101 != &v103) {
      free(v101);
    }
  }
  else
  {
    uint64_t v85 = a4[2];
    if (v85 && (uint64_t v86 = v95, mlir::RewriterBase::Listener::classof(v85))) {
    else
    }
      uint64_t v40 = 0;
  }
  if (RankPromotionTypeForANE != v107) {
    free(RankPromotionTypeForANE);
  }
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::matchConstantWithIntVector<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (!a1) {
    return 0;
  }
  unint64_t v8 = (uint64_t **)&v9;
  uint64_t v11 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp) {
    return 0;
  }
  if (!mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v8, DefiningOp)) {
    return 0;
  }
  v7[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v9);
  v7[1] = v4;
  if (*(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v7) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    return 0;
  }
  uint64_t v5 = 1;
  mlir::getIntValues<unsigned long long>(v9, v10, a2, 1);
  return v5;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.batch_to_space", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.batch_to_space";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::BatchToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  unint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  uint64_t v95 = a2;
  long long v108 = *(_OWORD *)(a3 + 48);
  uint64_t v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  uint64_t v94 = v5;
  unint64_t v6 = (char *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t RankPromotionTypeForANE = v6;
  uint64_t v106 = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  unint64_t v18 = v17;
  uint64_t v19 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = *v19;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  uint64_t v106 = v30;
  mlir::ShapedType::getShape((mlir::ShapedType *)&RankPromotionTypeForANE);
  unint64_t v32 = v31;
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(void *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(void *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  unint64_t v38 = mlir::anec::getIndexFromDim(2, v32);
  uint64_t v40 = v39;
  unint64_t v91 = mlir::anec::getIndexFromDim(3, v32);
  unint64_t v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    uint64_t v43 = a4[2];
    if (v43)
    {
      uint64_t v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        uint64_t v45 = *(void *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(void *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  uint64_t v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&v101);
  if (v102 >= 0x41)
  {
    uint64_t v50 = *(void *)v101;
    MEMORY[0x21667D390]();
    if (IndexFromDim != v50) {
      goto LABEL_26;
    }
  }
  else if (IndexFromDim != (uint64_t)((void)v101 << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  uint64_t RankPromotionTypeForANE = v107;
  uint64_t v106 = 0x300000000;
  uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(Length, (uint64_t)&RankPromotionTypeForANE))
  {
    unint64_t v89 = v41;
    unint64_t v90 = v38;
    uint64_t v101 = &v103;
    uint64_t v104 = 1;
    long long v103 = xmmword_211F1A450;
    uint64_t v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v96, v93[0], 0);
    long long v98 = v96;
    long long v99 = v97;
    unint64_t v100 = RankPromotionTypeForANE;
    uint64_t v52 = v93[0];
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v96, v52, NumElements);
    uint64_t v54 = v96;
    int v55 = BYTE8(v96);
    uint64_t v56 = v97;
    BOOL v58 = (void)v99 == (void)v97 && BYTE8(v98) == BYTE8(v96) && (void)v98 == (void)v96;
    if (v58 || (unint64_t v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(void *)&long long v98 = 3;
      uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      uint64_t v73 = (void *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      uint64_t v74 = v73;
      if (v73
        && (uint64_t v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), v77))
      {
        uint64_t v78 = *(void **)(v75 + 8);
        unint64_t v79 = &v78[2 * v77];
        do
        {
          unint64_t v80 = v77 >> 1;
          int v81 = &v78[2 * (v77 >> 1)];
          unint64_t v83 = *v81;
          uint64_t v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76) {
            uint64_t v78 = v82;
          }
          else {
            unint64_t v77 = v80;
          }
        }
        while (v77);
        if (v78 != v79 && *v78 == v76) {
          uint64_t v84 = v78[1];
        }
        else {
          uint64_t v84 = 0;
        }
      }
      else
      {
        uint64_t v84 = 0;
      }
      uint64_t v40 = 1;
      *(void *)&long long v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, v101, 8 * v102, 8, 1, 0);
      uint64_t v87 = v95;
      uint64_t v88 = mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(void *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      uint64_t v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*(&v98, (llvm::APInt *)&v96);
        unsigned int v61 = DWORD2(v96);
        uint64_t v62 = v96;
        if (v60
          && (DWORD2(v96) > 0x40 ? (uint64_t v63 = *(void *)v96) : (uint64_t v63 = (uint64_t)((void)v96 << -BYTE8(v96)) >> -BYTE8(v96)),
              v63 == v90))
        {
          *((void *)v101 + 2) = *(void *)v100;
          int v64 = 1;
        }
        else
        {
          uint64_t v65 = DWORD2(v96) > 0x40 ? *(void *)v96 : (uint64_t)((void)v96 << -BYTE8(v96)) >> -BYTE8(v96);
          if (v65 == v91)
          {
            *((void *)v101 + 1) = *(void *)v100;
            int v64 = 1;
          }
          else
          {
            uint64_t v66 = *(void *)v100;
            if (v65 == v89)
            {
              *(void *)uint64_t v101 = v66;
              int v64 = 1;
            }
            else if (v66 == 1)
            {
              int v64 = 1;
            }
            else
            {
              uint64_t v40 = a4[2];
              if (v40)
              {
                uint64_t v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2])) {
                else
                }
                  uint64_t v40 = 0;
              }
              int v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62) {
          MEMORY[0x21667D390](v62, 0x1000C8000313F17);
        }
        if (!v64) {
          break;
        }
        uint64_t v68 = v100 + 8;
        *(void *)&long long v99 = v99 + 1;
        v100 += 8;
        if ((void)v99 == v56 && BYTE8(v98) == v55 && (void)v98 == v54 || v68 == v59) {
          goto LABEL_84;
        }
      }
    }
    if (v101 != &v103) {
      free(v101);
    }
  }
  else
  {
    uint64_t v85 = a4[2];
    if (v85 && (uint64_t v86 = v95, mlir::RewriterBase::Listener::classof(v85))) {
    else
    }
      uint64_t v40 = 0;
  }
  if (RankPromotionTypeForANE != v107) {
    free(RankPromotionTypeForANE);
  }
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_batch", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.space_to_batch";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToBatch::build(a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v37 = a2;
  long long v47 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::ShapedType::getShape((mlir::ShapedType *)v36);
  unint64_t v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  unsigned int ODSOperandIndexAndLength = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 1u);
  uint64_t v20 = *(void **)(a3 + 40);
  uint64_t v40 = v20;
  uint64_t v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength) {
    uint64_t v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  }
  uint64_t v40 = v20;
  uint64_t v41 = 0;
  uint64_t v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45)) {
    goto LABEL_23;
  }
  unsigned int v22 = mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::CastOpGenericAdaptorBase *)a3, 2u);
  uint64_t v23 = *(void **)(a3 + 40);
  uint64_t v40 = v23;
  uint64_t v41 = v22;
  if (v22) {
    uint64_t v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  }
  uint64_t v40 = v23;
  uint64_t v41 = 0;
  uint64_t v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    uint64_t v25 = *(void *)v45[0];
    uint64_t v26 = *(void *)v43[0];
    uint64_t v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    uint64_t v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      uint64_t v27 = v37;
      uint64_t v28 = *(void *)v38[0];
      uint64_t v34 = *((void *)v38[0] + 1);
      unint64_t v35 = (uint64_t *)v28;
      uint64_t v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      uint64_t v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(void *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, v27, v29);
      uint64_t v30 = 1;
    }
    else
    {
      uint64_t v32 = v37;
      unint64_t v35 = &v37;
      uint64_t v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30)) {
        else
        }
          uint64_t v30 = 0;
      }
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v40 != v42) {
      free(v40);
    }
  }
  else
  {
LABEL_23:
    uint64_t v30 = 0;
  }
  if (v43[0] != &v44) {
    free(v43[0]);
  }
  if (v45[0] != &v46) {
    free(v45[0]);
  }
  return v30;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  uint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  long long v88 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v75 = v6;
  uint64_t v76 = v16;
  uint64_t v85 = (uint64_t *)v87;
  uint64_t v86 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
LABEL_35:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    uint64_t v51 = 0;
    goto LABEL_57;
  }
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  unint64_t v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  uint64_t v19 = (uint64_t)v18;
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v20 = *v18;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  uint64_t v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  uint64_t v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  uint64_t v82 = v84;
  uint64_t v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v73);
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if (v83)
    {
      unint64_t v37 = IndexFromDim;
      unint64_t v38 = v82;
      uint64_t v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
          uint64_t v42 = v41;
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v44 = (void *)mlir::RankedTensorType::get(Shape, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          uint64_t v80 = v45;
          uint64_t v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v73, (void **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          long long v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::ShapedType::getShape((mlir::ShapedType *)v73);
      unint64_t v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          uint64_t v59 = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
          uint64_t v60 = SplatF16ElementsAttr;
          *((void *)SplatF16ElementsAttr + v37) = *(void *)(v59 + 8 * v37);
          uint64_t v61 = v80;
          uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v63 = (void *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          uint64_t v65 = *(void *)(a2 + 24);
          uint64_t v66 = (uint64_t *)SplatF16ElementsAttr;
          uint64_t v67 = (mlir::AffineMap *)v80;
          uint64_t v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          uint64_t v71 = 0;
          uint64_t v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(void *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81) {
            free(SplatF16ElementsAttr);
          }
LABEL_54:
          uint64_t v51 = 1;
          goto LABEL_55;
        }
        size_t v58 = 8 * v55;
        uint64_t v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        uint64_t v57 = SplatF16ElementsAttr;
        size_t v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_211ED5510, v58);
      goto LABEL_52;
    }
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
LABEL_44:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  uint64_t v51 = 0;
LABEL_55:
  if (v82 != v84) {
    free(v82);
  }
LABEL_57:
  if (v85 != (uint64_t *)v87) {
    free(v85);
  }
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, void *a4)
{
  v19[38] = *MEMORY[0x263EF8340];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    unint64_t v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4 - 16, 0);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  v17[38] = *MEMORY[0x263EF8340];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::Ceil::build(a1, (uint64_t)v17, *a3, a3[1], 0, 0);
  uint64_t v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    char v10 = v9;
  }
  else {
    char v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  long long v88 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (void *)(*(void *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v75 = v6;
  uint64_t v76 = v16;
  uint64_t v85 = (uint64_t *)v87;
  uint64_t v86 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
LABEL_35:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    uint64_t v51 = 0;
    goto LABEL_57;
  }
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  __int16 v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  uint64_t v19 = (uint64_t)v18;
  if (!v18) {
    goto LABEL_21;
  }
  uint64_t v20 = *v18;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  uint64_t v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      uint64_t v49 = *(void *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  uint64_t v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  uint64_t v82 = v84;
  uint64_t v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::ShapedType::getShape((mlir::ShapedType *)v73);
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if (v83)
    {
      unint64_t v37 = IndexFromDim;
      unint64_t v38 = v82;
      uint64_t v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
          uint64_t v42 = v41;
          uint64_t v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v44 = (void *)mlir::RankedTensorType::get(Shape, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          uint64_t v80 = v45;
          uint64_t v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v73, (void **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          long long v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(void *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      uint64_t v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::ShapedType::getShape((mlir::ShapedType *)v73);
      unint64_t v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          uint64_t v59 = mlir::ShapedType::getShape((mlir::ShapedType *)v73);
          uint64_t v60 = SplatF16ElementsAttr;
          *((void *)SplatF16ElementsAttr + v37) = *(void *)(v59 + 8 * v37);
          uint64_t v61 = v80;
          uint64_t v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v63 = (void *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          uint64_t v65 = *(void *)(a2 + 24);
          uint64_t v66 = (uint64_t *)SplatF16ElementsAttr;
          uint64_t v67 = (mlir::AffineMap *)v80;
          uint64_t v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          uint64_t v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          uint64_t v71 = 0;
          uint64_t v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(void *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, ZinIrHalH13g *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81) {
            free(SplatF16ElementsAttr);
          }
LABEL_54:
          uint64_t v51 = 1;
          goto LABEL_55;
        }
        size_t v58 = 8 * v55;
        uint64_t v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        uint64_t v57 = SplatF16ElementsAttr;
        size_t v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_211ED5510, v58);
      goto LABEL_52;
    }
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      uint64_t v53 = *(void *)(a2 + 24);
LABEL_44:
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(void *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  uint64_t v51 = 0;
LABEL_55:
  if (v82 != v84) {
    free(v82);
  }
LABEL_57:
  if (v85 != (uint64_t *)v87) {
    free(v85);
  }
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get((uint64_t *)v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get((uint64_t *)v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get((uint64_t *)v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get((uint64_t *)v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  long long v42 = *(_OWORD *)(a3 + 40);
  unint64_t v6 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  char v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    __int16 v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      char v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  uint64_t v39 = v41;
  uint64_t v40 = 0x500000000;
  uint64_t v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    uint64_t v19 = (uint64_t *)mlir::MemRefType::get((uint64_t *)v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_21;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_21;
    }
    uint64_t v24 = *(void **)(v21 + 8);
    unint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      unint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        uint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_21:
    }
      uint64_t v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    uint64_t v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    uint64_t v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(void *)(a2 + 24), v37, &v36);
    (*(void (**)(void *, uint64_t, ZinIrHalH13g *))(*a4 + 32))(a4, a2, v32);
    uint64_t v33 = 1;
  }
  else
  {
    uint64_t v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34)) {
    else
    }
      uint64_t v33 = 0;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 48);
  uint64_t v9 = *(void *)(a3 + 56);
  unint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      long long v29 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      unint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  uint64_t v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  unint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::createPadding(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  size_t v58 = v60;
  memset(v60, 0, sizeof(v60));
  uint64_t v59 = 0xA0000000ALL;
  unint64_t v55 = v57;
  memset_pattern16(v57, &unk_211F1A440, 0x28uLL);
  uint64_t v56 = 0x500000005;
  uint64_t v12 = a5[2];
  if (v12)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 16 * v12;
    uint64_t v15 = (void *)(*(void *)a5 + 8);
    do
    {
      ReferenceFormatuint64_t Index = mlir::anec::getReferenceFormatIndex(v13, a5[2], 5uLL);
      if (!v18) {
        std::__throw_bad_optional_access[abi:nn180100]();
      }
      uint64_t v19 = *(v15 - 1);
      if (v19 || *v15)
      {
        uint64_t v16 = (char *)v58 + 16 * ReferenceFormatIndex;
        void *v16 = v19;
        v16[1] = *v15;
        *((void *)v55 + ReferenceFormatIndex) = a4;
      }
      uint64_t v13 = (mlir::anec *)((char *)v13 + 1);
      v15 += 2;
      v14 -= 16;
    }
    while (v14);
  }
  long long v54 = xmmword_211F09570;
  uint64_t v20 = (mlir::Builder *)(a7 + 8);
  uint64_t IntegerType = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  unint64_t v22 = (void *)mlir::RankedTensorType::get((uint64_t)&v54, 2, IntegerType, 0);
  uint64_t v23 = v22;
  if (v22 && (uint64_t v24 = *v22, v25 = mlir::TypeID::get<mlir::ShapedType>(), v26 = *(unsigned int *)(v24 + 16), v26))
  {
    uint64_t v27 = *(void **)(v24 + 8);
    long long v28 = &v27[2 * v26];
    do
    {
      unint64_t v29 = v26 >> 1;
      uint64_t v30 = &v27[2 * (v26 >> 1)];
      unint64_t v32 = *v30;
      uint64_t v31 = v30 + 2;
      v26 += ~(v26 >> 1);
      if (v32 < v25) {
        uint64_t v27 = v31;
      }
      else {
        unint64_t v26 = v29;
      }
    }
    while (v26);
    __int16 v33 = a6;
    uint64_t v34 = a1;
    if (v27 != v28 && *v27 == v25) {
      uint64_t v35 = v27[1];
    }
    else {
      uint64_t v35 = 0;
    }
  }
  else
  {
    uint64_t v35 = 0;
    __int16 v33 = a6;
    uint64_t v34 = a1;
  }
  uint64_t v52 = mlir::DenseElementsAttr::getFromRawBuffer(v23, v35, v58, 8 * v59, 8, 1, 0);
  uint64_t v53 = 5;
  uint64_t v36 = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  uint64_t v37 = (void *)mlir::RankedTensorType::get((uint64_t)&v53, 1, v36, 0);
  unint64_t v38 = v37;
  if (!v37) {
    goto LABEL_29;
  }
  uint64_t v39 = *v37;
  unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v41 = *(unsigned int *)(v39 + 16);
  if (!v41) {
    goto LABEL_29;
  }
  long long v42 = *(void **)(v39 + 8);
  uint64_t v43 = &v42[2 * v41];
  do
  {
    unint64_t v44 = v41 >> 1;
    uint64_t v45 = &v42[2 * (v41 >> 1)];
    unint64_t v47 = *v45;
    uint64_t v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40) {
      long long v42 = v46;
    }
    else {
      unint64_t v41 = v44;
    }
  }
  while (v41);
  if (v42 != v43 && *v42 == v40) {
    uint64_t v48 = v42[1];
  }
  else {
LABEL_29:
  }
    uint64_t v48 = 0;
  *(void *)&long long v54 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v55, 8 * v56, 8, 1, 0);
  uint64_t v49 = mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>((mlir::UnknownLoc **)v20, v34, a2, (uint64_t *)&v54, &v52, v33);
  if (v55 != v57) {
    free(v55);
  }
  if (v58 != v60) {
    free(v58);
  }
  return v49;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  uint64_t v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void mlir::getListOfPairs<unsigned long long>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v13[8] = *MEMORY[0x263EF8340];
  uint64_t v11 = v13;
  uint64_t v12 = 0x800000000;
  mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v11, 1);
  uint64_t v4 = (char *)v11;
  uint64_t v5 = v12;
  if (v12)
  {
    unsigned int v6 = *(_DWORD *)(a3 + 8);
    uint64_t v7 = (char *)v11;
    do
    {
      long long v8 = *(_OWORD *)v7;
      v7 += 16;
      long long v9 = v8;
      if (v6 >= *(_DWORD *)(a3 + 12))
      {
        long long v10 = v9;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v6 + 1, 16);
        *(_OWORD *)(*(void *)a3 + 16 * *(unsigned int *)(a3 + 8)) = v10;
        unsigned int v6 = *(_DWORD *)(a3 + 8);
        uint64_t v4 = (char *)v11;
        uint64_t v5 = v12;
      }
      else
      {
        *(_OWORD *)(*(void *)a3 + 16 * v6) = v9;
      }
      *(_DWORD *)(a3 + 8) = ++v6;
    }
    while (v7 != &v4[8 * v5]);
  }
  if (v4 != (char *)v13) {
    free(v4);
  }
}

char *llvm::SmallVectorImpl<std::pair<unsigned long long,unsigned long long>>::insert<std::pair<unsigned long long,unsigned long long>*,void>(uint64_t a1, uint64_t a2, char *__src, char *a4)
{
  uint64_t v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 4;
  uint64_t v10 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  size_t v12 = a4 - __src;
  unint64_t v13 = (a4 - __src) >> 4;
  unint64_t v14 = v13 + v10;
  if (*(void *)a1 + 16 * v10 == a2)
  {
    if (v14 > v9)
    {
      uint64_t v23 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      uint64_t v5 = v23;
      unsigned int v11 = *(_DWORD *)(a1 + 8);
      uint64_t v7 = *(void *)a1;
    }
    if (v5 != a4)
    {
      memcpy((void *)(v7 + 16 * v11), v5, v12);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
      uint64_t v7 = *(void *)a1;
    }
    *(_DWORD *)(a1 + 8) = v11 + (v12 >> 4);
    return (char *)(v7 + 16 * v8);
  }
  else
  {
    uint64_t v100 = a2 - *(void *)a1;
    if (v14 > v9)
    {
      uint64_t v15 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      uint64_t v5 = v15;
      uint64_t v7 = *(void *)a1;
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    uint64_t v16 = (char *)(v7 + 16 * v8);
    unint64_t v17 = v7 + 16 * v10;
    unint64_t v18 = v17 - (void)v16;
    uint64_t v19 = v8;
    unint64_t v20 = (uint64_t)(v17 - (void)v16) >> 4;
    if (v20 < v13)
    {
      unsigned int v21 = v11 + (v12 >> 4);
      *(_DWORD *)(a1 + 8) = v21;
      if (v19 == v10)
      {
        unint64_t v22 = (long long *)v5;
        goto LABEL_103;
      }
      uint64_t v79 = v19;
      uint64_t v80 = v5;
      memcpy((void *)(v7 + 16 * v21 - 16 * v20), v16, v17 - (void)v16);
      if (v18 >= 0xE0)
      {
        uint64_t v84 = v7 + (v100 & 0xFFFFFFFFFFFFFFF0);
        unint64_t v85 = v84 + v18 - 8;
        BOOL v87 = v84 + 8 < (unint64_t)&v80[v18] && (unint64_t)(v80 + 8) < v84 + v18;
        BOOL v88 = v85 <= (unint64_t)v80 || v16 >= &v80[v18 - 8];
        if (!v88 || v87)
        {
          int v81 = v16;
          uint64_t v82 = (uint64_t)(v17 - (void)v16) >> 4;
          unint64_t v22 = (long long *)v80;
        }
        else
        {
          unint64_t v89 = 16 * (v20 & 0xFFFFFFFFFFFFFFFCLL);
          int v81 = &v16[v89];
          uint64_t v82 = (v18 >> 4) & 3;
          unint64_t v22 = (long long *)&v80[v89];
          unint64_t v90 = (long long *)(v80 + 32);
          unint64_t v91 = (_OWORD *)(v7 + 16 * v79 + 32);
          unint64_t v92 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            long long v94 = *(v90 - 2);
            long long v93 = *(v90 - 1);
            long long v96 = *v90;
            long long v95 = v90[1];
            v90 += 4;
            *(v91 - 2) = v94;
            *(v91 - 1) = v93;
            *unint64_t v91 = v96;
            v91[1] = v95;
            v91 += 4;
            v92 -= 4;
          }
          while (v92);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL))
          {
LABEL_103:
            if (v22 != (long long *)a4) {
              memcpy((void *)(v7 + 16 * v10), v22, a4 - (char *)v22);
            }
            return v16;
          }
        }
      }
      else
      {
        int v81 = v16;
        uint64_t v82 = (uint64_t)(v17 - (void)v16) >> 4;
        unint64_t v22 = (long long *)v80;
      }
      do
      {
        long long v97 = *v22++;
        *(_OWORD *)int v81 = v97;
        v81 += 16;
        --v82;
      }
      while (v82);
      goto LABEL_103;
    }
    uint64_t v99 = v19;
    uint64_t v24 = v10;
    if (v13 + v10 > *(unsigned int *)(a1 + 12))
    {
      unint64_t v25 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v13 + v10, 16);
      uint64_t v5 = v25;
      uint64_t v24 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    unint64_t v26 = (void *)(v17 - 16 * v13);
    if (a4 != v5)
    {
      uint64_t v27 = (_OWORD *)(*(void *)a1 + 16 * v24);
      uint64_t v28 = -16 * v13;
      do
      {
        *v27++ = *(_OWORD *)(v17 + v28);
        v28 += 16;
      }
      while (v28);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v11 + v13;
    if (v26 != (void *)v16)
    {
      uint64_t v29 = 16 * v10;
      unint64_t v30 = 16 * v10 - 16 * (v13 + v99) - 16;
      if (v30 < 0x550) {
        goto LABEL_60;
      }
      uint64_t v31 = v29 - 16;
      uint64_t v32 = v29 - 16 - 16 * (v13 + v99);
      if (v7 - -16 * (v13 + v99) > v7 + v29 - 16) {
        goto LABEL_60;
      }
      uint64_t v33 = v29 - 8;
      if (v7 + v33 - v32 > (unint64_t)(v7 + v33)
        || v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0)
        || v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0))
      {
        goto LABEL_60;
      }
      uint64_t v34 = 16 * (v13 + v99);
      uint64_t v35 = v31 - v34;
      unint64_t v36 = v7 + v34;
      unint64_t v37 = v7 + v33;
      unint64_t v38 = v7 + v33 - (v31 - v34);
      size_t v39 = v7 + v34 - (v12 & 0xFFFFFFFFFFFFFFF0);
      size_t v40 = v33 - (v12 & 0xFFFFFFFFFFFFFFF0);
      unint64_t v41 = v7 + v40;
      size_t v42 = v7 + v40 - v35;
      BOOL v43 = v36 >= v7 + v40 || v39 >= v37;
      BOOL v44 = !v43;
      BOOL v45 = v36 >= (unint64_t)v26 || v42 >= v37;
      BOOL v46 = !v45;
      BOOL v47 = v38 >= v41 || v39 >= v17;
      BOOL v48 = !v47;
      BOOL v49 = v38 >= (unint64_t)v26 || v42 >= v17;
      BOOL v50 = !v49;
      if (v38 < v37 && v36 < v17) {
        goto LABEL_60;
      }
      if (v44) {
        goto LABEL_60;
      }
      if (v46) {
        goto LABEL_60;
      }
      if (v48) {
        goto LABEL_60;
      }
      if (v50) {
        goto LABEL_60;
      }
      uint64_t v52 = (v30 >> 4) + 1;
      uint64_t v53 = 16 * (v52 & 0x1FFFFFFFFFFFFFFCLL);
      unint64_t v54 = v17 - v53;
      unint64_t v26 = (void *)((char *)v26 - v53);
      unint64_t v55 = (double *)(v17 - 32);
      uint64_t v56 = v52 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        uint64_t v57 = &v55[-2 * v13];
        float64x2x2_t v101 = vld2q_f64(v57);
        v57 -= 4;
        float64x2x2_t v102 = vld2q_f64(v57);
        size_t v58 = v55 - 4;
        vst2q_f64(v55, v101);
        vst2q_f64(v58, v102);
        v55 -= 8;
        v56 -= 4;
      }
      while (v56);
      unint64_t v17 = v54;
      if (v52 != (v52 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_60:
        uint64_t v59 = (void *)(v17 - 8);
        do
        {
          uint64_t v60 = *(v26 - 2);
          v26 -= 2;
          *(v59 - 1) = v60;
          *uint64_t v59 = v26[1];
          v59 -= 2;
        }
        while (v26 != (void *)v16);
      }
    }
    if (a4 != v5)
    {
      unint64_t v61 = a4 - v5 - 16;
      if (v61 < 0x150
        || ((unint64_t v62 = (v100 & 0xFFFFFFFFFFFFFFF0) + v7 + (v61 & 0xFFFFFFFFFFFFFFF0),
             unint64_t v63 = v62 + 8,
             unint64_t v64 = v62 + 16,
             v7 + (v100 & 0xFFFFFFFFFFFFFFF0) + 8 < (unint64_t)&v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 16])
          ? (BOOL v65 = (unint64_t)(v5 + 8) >= v64)
          : (BOOL v65 = 1),
            v65 ? (char v66 = 0) : (char v66 = 1),
            v63 > (unint64_t)v5 ? (BOOL v67 = v16 >= &v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 8]) : (BOOL v67 = 1),
            !v67 || (v66 & 1) != 0))
      {
        unint64_t v70 = v16;
        uint64_t v71 = v5;
      }
      else
      {
        uint64_t v68 = (v61 >> 4) + 1;
        uint64_t v69 = 16 * (v68 & 0x1FFFFFFFFFFFFFFCLL);
        unint64_t v70 = &v16[v69];
        uint64_t v71 = &v5[v69];
        uint64_t v72 = (long long *)(v5 + 32);
        uint64_t v73 = (_OWORD *)(v7 + 16 * v99 + 32);
        uint64_t v74 = v68 & 0x1FFFFFFFFFFFFFFCLL;
        do
        {
          long long v76 = *(v72 - 2);
          long long v75 = *(v72 - 1);
          long long v78 = *v72;
          long long v77 = v72[1];
          v72 += 4;
          *(v73 - 2) = v76;
          *(v73 - 1) = v75;
          *uint64_t v73 = v78;
          v73[1] = v77;
          v73 += 4;
          v74 -= 4;
        }
        while (v74);
        if (v68 == (v68 & 0x1FFFFFFFFFFFFFFCLL)) {
          return v16;
        }
      }
      do
      {
        long long v83 = *(_OWORD *)v71;
        v71 += 16;
        *(_OWORD *)unint64_t v70 = v83;
        v70 += 16;
      }
      while (v71 != a4);
    }
  }
  return v16;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  v23[38] = *MEMORY[0x263EF8340];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.padding", (const unsigned __int8 *)0xC, Context);
  if (!v14)
  {
    __int16 v22 = 1283;
    void v21[2] = (uint64_t)"anec.padding";
    void v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Padding::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  uint64_t v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void std::deque<std::pair<mlir::anec::Dim,std::pair<unsigned long long,unsigned long long>>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unsigned int v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        uint64_t v33 = (char *)operator new(8 * v30);
        uint64_t v34 = &v33[8 * v31];
        uint64_t v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            uint64_t v52 = &v33[8 * v31];
            size_t v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              uint64_t v53 = (v38 >> 3) + 1;
              uint64_t v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v39 = &v34[v54];
              v7 += v54;
              unint64_t v55 = (long long *)(v6 + 3);
              uint64_t v56 = v52 + 16;
              uint64_t v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                _OWORD *v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4;
              }
              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            size_t v39 = &v33[8 * v31];
          }
          do
          {
            uint64_t v59 = *(void *)v7;
            v7 += 8;
            *(void *)size_t v39 = v59;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_55;
      }
LABEL_65:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }
  uint64_t v18 = *(char **)(a1 + 8);
  unint64_t v17 = *(char **)(a1 + 16);
  uint64_t v19 = v17 - v18;
  uint64_t v20 = (v17 - v18) >> 3;
  unsigned int v21 = *(char **)(a1 + 24);
  uint64_t v22 = (uint64_t)&v21[-*(void *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      uint64_t v68 = (char *)operator new(0xFF0uLL);
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v68);
      return;
    }
    uint64_t v68 = (char *)operator new(0xFF0uLL);
    std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v68);
    size_t v40 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_57;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        uint64_t v33 = (char *)operator new(8 * v41);
        uint64_t v34 = &v33[8 * v42];
        uint64_t v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        uint64_t v5 = v34;
        if (!v36)
        {
          uint64_t v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            uint64_t v60 = &v33[8 * v42];
            BOOL v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              uint64_t v61 = (v45 >> 3) + 1;
              uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v46 = &v34[v62];
              v7 += v62;
              unint64_t v63 = (long long *)(v40 + 3);
              unint64_t v64 = v60 + 16;
              uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                _OWORD *v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4;
              }
              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }
          else
          {
            BOOL v46 = &v33[8 * v42];
          }
          do
          {
            uint64_t v67 = *(void *)v7;
            v7 += 8;
            *(void *)BOOL v46 = v67;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_55:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_57;
      }
      goto LABEL_65;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v21 == *(char **)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  uint64_t v72 = a1 + 24;
  if (v24 >> 61) {
    goto LABEL_65;
  }
  unint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = &v25[8 * v20];
  uint64_t v68 = v25;
  uint64_t v69 = v26;
  uint64_t v27 = &v25[8 * v24];
  uint64_t v71 = v27;
  uint64_t v28 = operator new(0xFF0uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18) {
        unint64_t v47 = 1;
      }
      else {
        unint64_t v47 = v19 >> 2;
      }
      if (v47 >> 61) {
        goto LABEL_65;
      }
      BOOL v48 = (char *)operator new(8 * v47);
      unint64_t v26 = &v48[8 * (v47 >> 2)];
      uint64_t v27 = &v48[8 * v47];
      uint64_t v68 = v48;
      uint64_t v69 = v26;
      uint64_t v71 = v27;
      operator delete(v25);
      uint64_t v18 = *(char **)(a1 + 8);
      unint64_t v17 = *(char **)(a1 + 16);
      unint64_t v25 = v48;
    }
    else
    {
      unint64_t v29 = v20 + 2;
      if (v20 >= -1) {
        unint64_t v29 = v20 + 1;
      }
      v26 -= 8 * (v29 >> 1);
      uint64_t v69 = v26;
    }
  }
  *(void *)unint64_t v26 = v28;
  BOOL v49 = v26 + 8;
  unint64_t v70 = v26 + 8;
  if (v17 == v18)
  {
    unint64_t v17 = v18;
  }
  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)&v68, v17);
    }
    while (v17 != *(char **)(a1 + 8));
    unint64_t v25 = v68;
    unint64_t v26 = v69;
    uint64_t v18 = *(char **)(a1 + 16);
    BOOL v49 = v70;
    uint64_t v27 = v71;
  }
  BOOL v50 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v26;
  uint64_t v68 = v50;
  uint64_t v69 = v17;
  uint64_t v51 = *(char **)(a1 + 24);
  *(void *)(a1 + 16) = v49;
  *(void *)(a1 + 24) = v27;
  unint64_t v70 = v18;
  uint64_t v71 = v51;
  if (v18 != v17) {
    unint64_t v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v50) {
    operator delete(v50);
  }
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

void mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v14 = *(_OWORD *)(a3 + 48);
  BOOL v3 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Block ****a1, uint64_t a2)
{
  BOOL v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  mlir::Diagnostic::operator<<(v3, **a1);
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(void *a1)
{
  unint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 40);
  uint64_t v9 = *(void *)(a3 + 48);
  uint64_t v35 = v8;
  uint64_t v36 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      void v33[2] = *(_OWORD *)(a3 + 32);
      uint64_t v34 = *(void *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v33, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v35);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v32 = 259;
    v29[0] = v31;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v29);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v36;
    if (v35 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v32 = 259;
  unint64_t v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  }
  return result;
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  BOOL v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  unint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  BOOL v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  unint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    uint64_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              unint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      unint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

ZinIrHalH13g *mlir::anonymous namespace'::makeInputViewOp<(mlir::anec::Family)0>(uint64_t a1, uint64_t a2, uint64_t a3, mlir::anec *a4, unint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v52 = a3;
  uint64_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  uint64_t v17 = *(void **)(v14 + 8);
  unint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    uint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      uint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v51[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v51[1] = v24;
  uint64_t OperandRange = (ZinIrHalH13g *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
  unsigned int v25 = 12;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
    if (mlir::Type::isF32((mlir::Type *)&v49)) {
      unsigned int v25 = 12;
    }
    else {
      unsigned int v25 = 28;
    }
  }
  mlir::ShapedType::getShape((mlir::ShapedType *)v51);
  DimFromuint64_t Index = mlir::anec::getDimFromIndex(a4, v26);
  if ((DimFromIndex & 0xFF00000000) != 0)
  {
    if (DimFromIndex != 4 || v25 >= a5)
    {
      unint64_t v41 = (mlir::Builder *)(a1 + 8);
      uint64_t v49 = a5;
      uint64_t OperandRange = a4;
      unint64_t v47 = a7;
      unint64_t v48 = a6;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (unint64_t *)&OperandRange, (unint64_t *)&v49, &v48, &v47);
    }
    unint64_t v45 = a6;
    unint64_t v46 = a7;
    mlir::ShapedType::getShape((mlir::ShapedType *)v51);
    unsigned int IndexFromDim = mlir::anec::getIndexFromDim(4, v28);
    if (v30)
    {
      unsigned int v31 = IndexFromDim;
      uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v51);
      unint64_t v33 = a5 / v25;
      unint64_t v34 = a5 % v25;
      uint64_t v36 = v33 > 1 && v34 == 0;
      uint64_t v37 = v33 - v36;
      if (v33 != v36)
      {
        uint64_t v38 = *(void *)(Shape + 8 * v31);
        unsigned int v39 = v25;
        do
        {
          unint64_t v48 = v25;
          uint64_t v49 = (uint64_t)a4;
          unint64_t v47 = v38 - v39;
          uint64_t OperandRange = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a1 + 8), a2, &v52, (unint64_t *)&v49, &v48, &v47);
          uint64_t v52 = mlir::anec::Convolution::getResult((mlir::anec::Convolution *)&OperandRange);
          v39 += v25;
          --v37;
        }
        while (v37);
      }
      if (v34) {
        unint64_t v40 = v34;
      }
      else {
        unint64_t v40 = v25;
      }
      unint64_t v41 = (mlir::Builder *)(a1 + 8);
      uint64_t v49 = v40;
      uint64_t OperandRange = a4;
      unint64_t v47 = v46;
      unint64_t v48 = v45;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (unint64_t *)&OperandRange, (unint64_t *)&v49, &v48, &v47);
    }
  }
  uint64_t v43 = std::__throw_bad_optional_access[abi:nn180100]();
  return (ZinIrHalH13g *)mlir::getSingleIntValue<int>(v43, v44);
}

uint64_t mlir::getSingleIntValue<int>(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a1;
  uint64_t v13 = a2;
  v11[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12);
  v11[1] = v2;
  uint64_t Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)v11);
  if (mlir::ShapedType::getNumElements(Shape, v4) == 1
    && (v10[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12),
        v10[1] = v5,
        *(_UNKNOWN **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v10)
                     + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
    LODWORD(v10[0]) = 0;
    mlir::copyElementsAttrData<int>(v12, v13, (uint64_t)v10, 1);
    unsigned int v8 = v10[0] & 0xFFFFFF00;
    int v6 = LOBYTE(v10[0]);
    uint64_t v7 = 0x100000000;
  }
  else
  {
    int v6 = 0;
    uint64_t v7 = 0;
    unsigned int v8 = 0;
  }
  return v7 | v8 | v6;
}

void mlir::copyElementsAttrData<int>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v102[5] = *MEMORY[0x263EF8340];
  uint64_t v99 = a1;
  uint64_t v100 = a2;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v99);
  uint64_t v7 = Type;
  if (!Type) {
    goto LABEL_10;
  }
  uint64_t v8 = *Type;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  unint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      unint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v98[0] = v7;
  v98[1] = v17;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v98);
  int v18 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v99);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v99);
  uint64_t v21 = v20;
  if (!v18 || a4)
  {
    int64_t NumElements = mlir::ElementsAttr::getNumElements(v99, v100);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_17;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_28;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return;
      }
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v28 = 0;
        unint64_t v27 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v29 = 0;
          }
          else {
            uint64_t v29 = v28;
          }
          if (v18) {
            uint64_t v30 = 0;
          }
          else {
            uint64_t v30 = v28 + 1;
          }
          int v31 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v30];
          int v32 = (_DWORD *)(a3 + 4 * v28);
          *int v32 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v29];
          v32[1] = v31;
          v28 += 2;
        }
        while (v28 != v27);
        goto LABEL_204;
      }
      goto LABEL_37;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_55;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_62;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_82;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_93;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_100;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_116;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_132;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return;
      }
      goto LABEL_148;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1) {
        return;
      }
LABEL_163:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v78 = 0;
        unint64_t v69 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v79 = (int32x2_t *)a3;
        do
        {
          if (v18) {
            uint64_t v80 = 0;
          }
          else {
            uint64_t v80 = v78;
          }
          if (v18) {
            uint64_t v81 = 0;
          }
          else {
            uint64_t v81 = v78 + 1;
          }
          v68.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v80];
          v68.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v81];
          int32x2_t v68 = vcvt_s32_f32((float32x2_t)vshl_n_s32(v68, 0x10uLL));
          *v79++ = v68;
          v78 += 2;
        }
        while (v78 != v69);
        goto LABEL_246;
      }
      unint64_t v69 = 0;
      do
      {
        if (v18) {
          unint64_t v95 = 0;
        }
        else {
          unint64_t v95 = v69;
        }
        *(_DWORD *)(a3 + 4 * v69++) = (int)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v95] << 16);
LABEL_246:
        ;
      }
      while (NumElements != v69);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      int64_t NumElements = 1;
LABEL_17:
      for (uint64_t i = 0; i != NumElements; ++i)
      {
        if (v18) {
          uint64_t v24 = 0;
        }
        else {
          uint64_t v24 = i;
        }
        *(_DWORD *)(a3 + 4 * i) = ElementsAttrRawData[v24];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      int64_t NumElements = 1;
LABEL_28:
      for (uint64_t j = 0; j != NumElements; ++j)
      {
        if (v18) {
          uint64_t v26 = 0;
        }
        else {
          uint64_t v26 = j;
        }
        *(_DWORD *)(a3 + 4 * j) = (char)ElementsAttrRawData[v26];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      int64_t NumElements = 1;
LABEL_37:
      unint64_t v27 = 0;
      do
      {
        if (v18) {
          unint64_t v88 = 0;
        }
        else {
          unint64_t v88 = v27;
        }
        *(_DWORD *)(a3 + 4 * v27++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v88];
LABEL_204:
        ;
      }
      while (NumElements != v27);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      int64_t NumElements = 1;
LABEL_55:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v36 = 0;
        unint64_t v33 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v37 = 0;
          }
          else {
            uint64_t v37 = v36;
          }
          if (v18) {
            uint64_t v38 = 0;
          }
          else {
            uint64_t v38 = v36 + 1;
          }
          int v39 = *(__int16 *)&ElementsAttrRawData[2 * v38];
          unint64_t v40 = (_DWORD *)(a3 + 4 * v36);
          _DWORD *v40 = *(__int16 *)&ElementsAttrRawData[2 * v37];
          v40[1] = v39;
          v36 += 2;
        }
        while (v36 != v33);
        goto LABEL_210;
      }
      unint64_t v33 = 0;
      do
      {
        if (v18) {
          unint64_t v89 = 0;
        }
        else {
          unint64_t v89 = v33;
        }
        *(_DWORD *)(a3 + 4 * v33++) = *(__int16 *)&ElementsAttrRawData[2 * v89];
LABEL_210:
        ;
      }
      while (NumElements != v33);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      int64_t NumElements = 1;
LABEL_62:
      for (uint64_t k = 0; k != NumElements; ++k)
      {
        if (v18) {
          uint64_t v35 = 0;
        }
        else {
          uint64_t v35 = k;
        }
        *(_DWORD *)(a3 + 4 * k) = *(_DWORD *)&ElementsAttrRawData[4 * v35];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      int64_t NumElements = 1;
LABEL_82:
      for (uint64_t m = 0; m != NumElements; ++m)
      {
        if (v18) {
          uint64_t v42 = 0;
        }
        else {
          uint64_t v42 = m;
        }
        *(_DWORD *)(a3 + 4 * m) = *(_DWORD *)&ElementsAttrRawData[4 * v42];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      int64_t NumElements = 1;
LABEL_93:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v45 = 0;
        unint64_t v43 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v46 = 0;
          }
          else {
            uint64_t v46 = v45;
          }
          if (v18) {
            uint64_t v47 = 0;
          }
          else {
            uint64_t v47 = v45 + 1;
          }
          uint64_t v48 = *(void *)&ElementsAttrRawData[8 * v47];
          uint64_t v49 = (_DWORD *)(a3 + 4 * v45);
          *uint64_t v49 = *(void *)&ElementsAttrRawData[8 * v46];
          v49[1] = v48;
          v45 += 2;
        }
        while (v45 != v43);
        goto LABEL_216;
      }
      unint64_t v43 = 0;
      do
      {
        if (v18) {
          unint64_t v90 = 0;
        }
        else {
          unint64_t v90 = v43;
        }
        *(_DWORD *)(a3 + 4 * v43++) = *(void *)&ElementsAttrRawData[8 * v90];
LABEL_216:
        ;
      }
      while (NumElements != v43);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      int64_t NumElements = 1;
LABEL_100:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v51 = 0;
        unint64_t v44 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v52 = 0;
          }
          else {
            uint64_t v52 = v51;
          }
          if (v18) {
            uint64_t v53 = 0;
          }
          else {
            uint64_t v53 = v51 + 1;
          }
          uint64_t v54 = *(void *)&ElementsAttrRawData[8 * v53];
          uint64_t v55 = (_DWORD *)(a3 + 4 * v51);
          _DWORD *v55 = *(void *)&ElementsAttrRawData[8 * v52];
          v55[1] = v54;
          v51 += 2;
        }
        while (v51 != v44);
        goto LABEL_222;
      }
      unint64_t v44 = 0;
      do
      {
        if (v18) {
          unint64_t v91 = 0;
        }
        else {
          unint64_t v91 = v44;
        }
        *(_DWORD *)(a3 + 4 * v44++) = *(void *)&ElementsAttrRawData[8 * v91];
LABEL_222:
        ;
      }
      while (NumElements != v44);
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      int64_t NumElements = 1;
LABEL_116:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v57 = 0;
        unint64_t v50 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v58 = 0;
          }
          else {
            uint64_t v58 = v57;
          }
          if (v18) {
            uint64_t v59 = 0;
          }
          else {
            uint64_t v59 = v57 + 1;
          }
          int v60 = (int)*(short float *)&ElementsAttrRawData[2 * v59];
          uint64_t v61 = (_DWORD *)(a3 + 4 * v57);
          *uint64_t v61 = (int)*(short float *)&ElementsAttrRawData[2 * v58];
          v61[1] = v60;
          v57 += 2;
        }
        while (v57 != v50);
        goto LABEL_228;
      }
      unint64_t v50 = 0;
      do
      {
        if (v18) {
          unint64_t v92 = 0;
        }
        else {
          unint64_t v92 = v50;
        }
        *(_DWORD *)(a3 + 4 * v50++) = (int)*(short float *)&ElementsAttrRawData[2 * v92];
LABEL_228:
        ;
      }
      while (NumElements != v50);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      int64_t NumElements = 1;
LABEL_132:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v63 = 0;
        unint64_t v56 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v64 = 0;
          }
          else {
            uint64_t v64 = v63;
          }
          if (v18) {
            uint64_t v65 = 0;
          }
          else {
            uint64_t v65 = v63 + 1;
          }
          int v66 = (int)*(float *)&ElementsAttrRawData[4 * v65];
          uint64_t v67 = (_DWORD *)(a3 + 4 * v63);
          _DWORD *v67 = (int)*(float *)&ElementsAttrRawData[4 * v64];
          v67[1] = v66;
          v63 += 2;
        }
        while (v63 != v56);
        goto LABEL_234;
      }
      unint64_t v56 = 0;
      do
      {
        if (v18) {
          unint64_t v93 = 0;
        }
        else {
          unint64_t v93 = v56;
        }
        *(_DWORD *)(a3 + 4 * v56++) = (int)*(float *)&ElementsAttrRawData[4 * v93];
LABEL_234:
        ;
      }
      while (NumElements != v56);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      int64_t NumElements = 1;
LABEL_148:
      if ((unint64_t)NumElements >= 2)
      {
        uint64_t v72 = 0;
        unint64_t v62 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18) {
            uint64_t v73 = 0;
          }
          else {
            uint64_t v73 = v72;
          }
          if (v18) {
            uint64_t v74 = 0;
          }
          else {
            uint64_t v74 = v72 + 1;
          }
          int v75 = (int)*(double *)&ElementsAttrRawData[8 * v74];
          long long v76 = (_DWORD *)(a3 + 4 * v72);
          *long long v76 = (int)*(double *)&ElementsAttrRawData[8 * v73];
          v76[1] = v75;
          v72 += 2;
        }
        while (v72 != v62);
        goto LABEL_240;
      }
      unint64_t v62 = 0;
      do
      {
        if (v18) {
          unint64_t v94 = 0;
        }
        else {
          unint64_t v94 = v62;
        }
        *(_DWORD *)(a3 + 4 * v62++) = (int)*(double *)&ElementsAttrRawData[8 * v94];
LABEL_240:
        ;
      }
      while (NumElements != v62);
      return;
    }
    int64_t NumElements = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      goto LABEL_163;
    }
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    if (v18) {
      unint64_t v70 = 1;
    }
    else {
      unint64_t v70 = NumElements;
    }
    llvm::SmallVector<BOOL,40u>::SmallVector((uint64_t)v101, v70);
    mlir::detail::unpackBooleanData(ElementsAttrRawData, v21, (uint64_t)v101[0], (unint64_t)v101[1]);
    uint64_t v71 = (unsigned __int8 *)v101[0];
    if (NumElements >= 1)
    {
      if (NumElements == 1)
      {
        unint64_t v83 = 0;
        goto LABEL_248;
      }
      uint64_t v82 = 0;
      unint64_t v83 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18) {
          uint64_t v84 = 0;
        }
        else {
          uint64_t v84 = v82;
        }
        if (v18) {
          uint64_t v85 = 0;
        }
        else {
          uint64_t v85 = v82 + 1;
        }
        int v86 = v71[v85];
        BOOL v87 = (_DWORD *)(a3 + 4 * v82);
        *BOOL v87 = v71[v84];
        v87[1] = v86;
        v82 += 2;
      }
      while (v82 != v83);
      while (NumElements != v83)
      {
LABEL_248:
        if (v18) {
          unint64_t v96 = 0;
        }
        else {
          unint64_t v96 = v83;
        }
        *(_DWORD *)(a3 + 4 * v83++) = v71[v96];
      }
    }
    if (v71 != (unsigned __int8 *)v102) {
      free(v71);
    }
  }
  else
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitunsigned int Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    mlir::detail::unpackQuantizedData<int>(ElementsAttrRawData, v21, a3, NumElements, IntOrFloatBitWidth);
  }
}

unsigned __int8 *mlir::detail::unpackQuantizedData<int>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    int v6 = ~(-1 << a5);
    unint64_t v7 = a4;
    unint64_t v8 = 8 / a5;
    do
    {
      unint64_t v9 = v5 * v8;
      unint64_t v10 = a4 - v5 * v8;
      if (v10 >= v8) {
        unint64_t v10 = 8 / a5;
      }
      if (!v10) {
        goto LABEL_3;
      }
      unsigned int v11 = *result;
      if (v7 >= v8) {
        unint64_t v12 = 8 / a5;
      }
      else {
        unint64_t v12 = v7;
      }
      uint64x2_t v13 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      int32x2_t v14 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)xmmword_211ED5A80));
      if (v14.i8[0]) {
        *(_DWORD *)(a3 + 4 * v9) = v6 & v11;
      }
      if (v14.i8[4]) {
        *(_DWORD *)(a3 + 4 * v9 + 4) = (v11 >> a5) & v6;
      }
      uint64_t v15 = ((_BYTE)v12 + 1) & 0x1E;
      if (v15 == 2) {
        goto LABEL_3;
      }
      int32x2_t v16 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_211ED4670));
      if (v16.i8[0])
      {
        *(_DWORD *)(a3 + 4 * v9 + 8) = (v11 >> (2 * a5)) & v6;
        if (v16.i8[4])
        {
LABEL_20:
          *(_DWORD *)(a3 + 4 * v9 + 12) = (v11 >> (3 * a5)) & v6;
          if (v15 == 4) {
            goto LABEL_3;
          }
          goto LABEL_21;
        }
      }
      else if (v16.i8[4])
      {
        goto LABEL_20;
      }
      if (v15 == 4) {
        goto LABEL_3;
      }
LABEL_21:
      int32x2_t v17 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_211F09590));
      if (v17.i8[0])
      {
        *(_DWORD *)(a3 + 4 * v9 + 16) = (v11 >> (4 * a5)) & v6;
        if ((v17.i8[4] & 1) == 0)
        {
LABEL_23:
          if (v15 != 6) {
            goto LABEL_27;
          }
          goto LABEL_3;
        }
      }
      else if ((v17.i8[4] & 1) == 0)
      {
        goto LABEL_23;
      }
      *(_DWORD *)(a3 + 4 * v9 + 20) = (v11 >> (5 * a5)) & v6;
      if (v15 != 6)
      {
LABEL_27:
        int32x2_t v18 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_211F095A0));
        if (v18.i8[0]) {
          *(_DWORD *)(a3 + 4 * v9 + 24) = (v11 >> (6 * a5)) & v6;
        }
        if (v18.i8[4]) {
          *(_DWORD *)(a3 + 4 * v9 + 28) = (v11 >> (7 * a5)) & v6;
        }
      }
LABEL_3:
      ++v5;
      v7 -= v8;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  v25[38] = *MEMORY[0x263EF8340];
  uint64_t v20 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v16)
  {
    __int16 v24 = 1283;
    void v23[2] = (uint64_t)"anec.input_view";
    v23[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::InputView::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  int32x2_t v17 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((void *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    int32x2_t v18 = v17;
  }
  else {
    int32x2_t v18 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              unint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

ZinIrHalH13g *mlir::anonymous namespace'::makeInputViewOp<(mlir::anec::Family)2>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v31 = a3;
  uint64x2_t v13 = (uint64_t *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  int32x2_t v17 = *(void **)(v14 + 8);
  unint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    uint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      int32x2_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v30[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v30[1] = v24;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v28 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
    mlir::Type::isF32((mlir::Type *)&v28);
  }
  uint64_t v28 = a5;
  uint64_t OperandRange = a4;
  unint64_t v26 = a7;
  unint64_t v27 = a6;
  return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>((mlir::Builder *)(a1 + 8), a2, &v31, (unint64_t *)&OperandRange, (unint64_t *)&v28, &v27, &v26);
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v48 = a2;
  long long v56 = *(_OWORD *)(a3 + 40);
  uint64_t v5 = (void *)(*(void *)(mlir::anec::Deconvolution::getInput((mlir::anec::Deconvolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64x2_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  uint64_t v46 = v5;
  uint64_t v47 = v15;
  v54[0] = &v55;
  v54[1] = (void *)0x100000000;
  uint64_t v45 = 0;
  v44[0] = (unint64_t *)&v45;
  Filter = (const char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::DenseIntElementsAttr>::match(v44, DefiningOp))
  {
    int32x2_t v17 = v45;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
    if (mlir::getPositivePromotedAxes(v17, v18, (uint64_t)v54, 0, 0))
    {
      v44[0] = (unint64_t *)mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
      v44[1] = v19;
      uint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
      Filter = 0;
      uint64_t v50 = 0;
      p_Filter = &Filter;
      uint64_t v53 = (const char **)Bias;
      uint64_t v21 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
      if (v21)
      {
        if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v21))
        {
          uint64_t SingleInt = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
          if ((SingleInt & 0xFF00000000) != 0)
          {
            uint64_t v23 = (int)SingleInt;
            uint64_t v24 = *(unsigned int *)v54[0];
            uint64_t Shape = mlir::ShapedType::getShape((mlir::ShapedType *)v44);
            Positiveuint64_t Axis = mlir::tryGetPositiveAxis(v23, *(void *)(Shape + 8 * v24), 0, 0, 0);
            if (v27)
            {
              uint64_t v28 = PositiveAxis;
              uint64_t Length = mlir::mps::SliceOp::getLength((mlir::mps::SliceOp *)&v48);
              Filter = 0;
              uint64_t v50 = 0;
              p_Filter = &Filter;
              uint64_t v53 = (const char **)Length;
              uint64_t v30 = mlir::Value::getDefiningOp((mlir::Value *)&v53);
              if (v30)
              {
                if (mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&p_Filter, v30))
                {
                  uint64_t v31 = mlir::getSingleIntValue<int>((uint64_t)Filter, v50);
                  if ((v31 & 0xFF00000000) != 0)
                  {
                    int v32 = v31;
                    uint64_t v33 = *((void *)v48 + 3);
                    uint64_t v34 = mlir::ValueRange::dereference_iterator(&v56, 0);
                    unint64_t v35 = v32;
                    uint64_t v36 = 1;
                    mlir::ConversionPatternRewriter::replaceOp(a4, v48, v37);
                    goto LABEL_31;
                  }
                }
              }
              goto LABEL_30;
            }
            Filter = "failed: could not extract a positive value for start attribute";
            __int16 v51 = 259;
            unint64_t v41 = v48;
            uint64_t v53 = &Filter;
            uint64_t v42 = *((void *)a4 + 2);
            if (v42)
            {
              if (mlir::RewriterBase::Listener::classof(v42))
              {
                uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), const char ***))(*(void *)v42 + 64))(v42, *((void *)v41 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v53);
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      Filter = "failed: could not extract positive promoted axes";
      __int16 v51 = 259;
      uint64_t v38 = v48;
      v44[0] = (unint64_t *)&Filter;
      uint64_t v39 = *((void *)a4 + 2);
      if (v39 && mlir::RewriterBase::Listener::classof(v39))
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), unint64_t **))(*(void *)v39 + 64))(v39, *((void *)v38 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
LABEL_25:
        uint64_t v36 = v40;
        goto LABEL_31;
      }
    }
  }
LABEL_30:
  uint64_t v36 = 0;
LABEL_31:
  if (v54[0] != &v55) {
    free(v54[0]);
  }
  return v36;
}

void *mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  BOOL v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  unint64_t v8 = v11[0];
  unint64_t v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  unint64_t v13 = v8;
  unint64_t v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(uint64_t **)(a3 + 72);
  uint64_t v9 = *(void *)(a3 + 80);
  uint64_t v36 = v8;
  uint64_t v37 = 0;
  if (!v9)
  {
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a2 + 36);
    if (v19) {
      uint64_t v20 = a2 - 16;
    }
    else {
      uint64_t v20 = 0;
    }
    if (!v19)
    {
LABEL_36:
      long long v28 = *(_OWORD *)(a3 + 48);
      uint64_t v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      _OWORD v34[4] = *(_OWORD *)(a3 + 64);
      uint64_t v35 = *(void *)(a3 + 80);
      long long v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)a1 + 88))(a1, a2, v34, a4);
    }
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      uint64_t v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      uint64_t v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        uint64_t Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v36);
        if (v25) {
          break;
        }
      }
LABEL_23:
      if (++v21 == v19) {
        goto LABEL_36;
      }
    }
    uint64_t v26 = 8 * v25;
    while (*Shape != 0x8000000000000000)
    {
      ++Shape;
      v26 -= 8;
      if (!v26) {
        goto LABEL_23;
      }
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    __int16 v33 = 259;
    v30[0] = v32;
    uint64_t v27 = *(void *)(a4 + 16);
    if (v27)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v27);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void *))(*(void *)v27 + 64))(v27, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      }
      return result;
    }
    return 0;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      unint64_t v14 = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v30);
      if (v15) {
        break;
      }
    }
LABEL_3:
    uint64_t v10 = ++v37;
    if (v36 == v8 && v10 == v9) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16) {
      goto LABEL_3;
    }
  }
LABEL_15:
  __int16 v33 = 259;
  uint64_t v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  uint64_t v17 = *(void *)(a4 + 16);
  if (!v17) {
    return 0;
  }
  uint64_t result = mlir::RewriterBase::Listener::classof(v17);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(void ****, uint64_t), void **))(*(void *)v17 + 64))(v17, *(void *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  }
  return result;
}